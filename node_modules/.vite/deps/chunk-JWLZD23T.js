import {
  EffectFallbacks,
  Material,
  MaterialDefines,
  PushMaterial,
  init_effectFallbacks,
  init_material,
  init_materialDefines,
  init_pushMaterial
} from "./chunk-OBADV6JF.js";
import {
  AbstractMesh,
  TransformNode,
  VertexData,
  createYieldingScheduler,
  init_abstractMesh,
  init_coroutine,
  init_mesh_vertexData,
  init_transformNode,
  runCoroutineAsync,
  runCoroutineSync
} from "./chunk-TMHG26QH.js";
import {
  BoundingInfo,
  SubMesh,
  init_boundingInfo,
  init_subMesh
} from "./chunk-JTDOLEW4.js";
import {
  Node,
  init_node
} from "./chunk-E7XHG63E.js";
import {
  AddClipPlaneUniforms,
  BindBonesParameters,
  BindClipPlane,
  BindFogParameters,
  BindIBLParameters,
  BindIBLSamplers,
  BindLights,
  BindLogDepth,
  BindMorphTargetParameters,
  BindSceneUniformBuffer,
  BindTextureMatrix,
  HandleFallbacksForShadows,
  MaterialFlags,
  PrepareAttributesForBakedVertexAnimation,
  PrepareAttributesForBones,
  PrepareAttributesForInstances,
  PrepareAttributesForMorphTargets,
  PrepareDefinesAndAttributesForMorphTargets,
  PrepareDefinesForAttributes,
  PrepareDefinesForFrameBoundValues,
  PrepareDefinesForIBL,
  PrepareDefinesForLights,
  PrepareDefinesForMergedUV,
  PrepareDefinesForMisc,
  PrepareDefinesForMultiview,
  PrepareDefinesForOIT,
  PrepareDefinesForPrePass,
  PrepareStringDefinesForClipPlanes,
  PrepareUniformLayoutForIBL,
  PrepareUniformsAndSamplersForIBL,
  PrepareUniformsAndSamplersList,
  PushAttributesForInstances,
  init_clipPlaneMaterialHelper,
  init_materialFlags,
  init_materialHelper_functions
} from "./chunk-R3NLUQNA.js";
import {
  extractMinAndMax,
  init_math_functions
} from "./chunk-Y5XTKMAE.js";
import {
  RGBDTextureTools,
  init_baseTexture_polynomial,
  init_rgbdTextureTools
} from "./chunk-ESGOHTGL.js";
import {
  ImageProcessingConfiguration,
  Scene,
  SceneComponentConstants,
  init_imageProcessingConfiguration,
  init_scene,
  init_sceneComponent
} from "./chunk-U45B254N.js";
import {
  UniformBuffer,
  init_uniformBuffer
} from "./chunk-ETNKJY4V.js";
import {
  Axis,
  RenderTargetTexture,
  init_math_axis,
  init_renderTargetTexture
} from "./chunk-E2UXTG46.js";
import {
  Path2,
  init_math_path
} from "./chunk-2EZNXTHP.js";
import {
  Frustum,
  SmartArray,
  init_math_frustum,
  init_smartArray
} from "./chunk-XUMUHFKD.js";
import {
  LightConstants,
  init_lightConstants
} from "./chunk-3V3ZT36M.js";
import {
  Viewport,
  init_math_viewport
} from "./chunk-4L5VDV4X.js";
import {
  DrawWrapper,
  init_drawWrapper
} from "./chunk-NER52ESJ.js";
import {
  Buffer,
  VertexBuffer,
  init_buffer
} from "./chunk-YEEYUO2W.js";
import {
  Texture,
  init_compatibilityOptions,
  init_texture,
  useOpenGLOrientationForUV
} from "./chunk-W2Z3EUIE.js";
import {
  SerializationHelper,
  Tags,
  init_decorators_serialization,
  init_tags
} from "./chunk-HNJVWIJU.js";
import {
  Color3,
  Color4,
  TmpColors,
  init_math_color
} from "./chunk-FQA5U7KF.js";
import {
  __decorate,
  addAccessorsForMaterialProperty,
  expandToProperty,
  init_decorators,
  init_tslib_es6,
  serialize,
  serializeAsColor3,
  serializeAsFresnelParameters,
  serializeAsImageProcessingConfiguration,
  serializeAsMeshReference,
  serializeAsTexture,
  serializeAsVector2,
  serializeAsVector3
} from "./chunk-KU6EWKFQ.js";
import {
  AsyncLoop,
  DeepCopier,
  Tools,
  init_deepCopier,
  init_tools
} from "./chunk-TQMUJQOB.js";
import {
  CopyFloatData,
  GetTypedArrayData,
  init_bufferUtils
} from "./chunk-X7JT3LZV.js";
import {
  WebRequest,
  init_webRequest
} from "./chunk-T55R2ONV.js";
import {
  ProcessIncludes,
  init_shaderProcessor
} from "./chunk-WTQMXJ7P.js";
import {
  _WarnImport,
  init_devTools
} from "./chunk-HCT32MRG.js";
import {
  ShaderStore,
  init_shaderStore
} from "./chunk-4OYBTWIA.js";
import {
  Epsilon,
  Matrix,
  Quaternion,
  TmpVectors,
  Vector2,
  Vector3,
  Vector4,
  init_math_constants,
  init_math_vector
} from "./chunk-VQZCJUUR.js";
import {
  GetClass,
  RegisterClass,
  init_typeStore
} from "./chunk-7ANHXSNA.js";
import {
  EngineStore,
  init_engineStore
} from "./chunk-TS7QJBPS.js";
import {
  HighestCommonFactor,
  init_math_scalar_functions,
  math_scalar_functions_exports
} from "./chunk-XBFJXXXT.js";
import {
  Logger,
  init_logger
} from "./chunk-2X44KPCK.js";
import {
  Observable,
  init_observable
} from "./chunk-PY47FUFT.js";
import {
  __esm
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@babylonjs/core/Cameras/camera.js
var Camera;
var init_camera = __esm({
  "node_modules/@babylonjs/core/Cameras/camera.js"() {
    init_tslib_es6();
    init_decorators();
    init_smartArray();
    init_tools();
    init_observable();
    init_math_vector();
    init_node();
    init_logger();
    init_typeStore();
    init_devTools();
    init_math_viewport();
    init_math_frustum();
    init_decorators_serialization();
    Camera = class _Camera extends Node {
      /**
       * Define the current local position of the camera in the scene
       */
      get position() {
        return this._position;
      }
      set position(newPosition) {
        this._position = newPosition;
      }
      /**
       * The vector the camera should consider as up.
       * (default is Vector3(0, 1, 0) aka Vector3.Up())
       */
      set upVector(vec) {
        this._upVector = vec;
      }
      get upVector() {
        return this._upVector;
      }
      /**
       * The screen area in scene units squared
       */
      get screenArea() {
        let x = 0;
        let y = 0;
        if (this.mode === _Camera.PERSPECTIVE_CAMERA) {
          if (this.fovMode === _Camera.FOVMODE_VERTICAL_FIXED) {
            y = this.minZ * 2 * Math.tan(this.fov / 2);
            x = this.getEngine().getAspectRatio(this) * y;
          } else {
            x = this.minZ * 2 * Math.tan(this.fov / 2);
            y = x / this.getEngine().getAspectRatio(this);
          }
        } else {
          const halfWidth = this.getEngine().getRenderWidth() / 2;
          const halfHeight = this.getEngine().getRenderHeight() / 2;
          x = (this.orthoRight ?? halfWidth) - (this.orthoLeft ?? -halfWidth);
          y = (this.orthoTop ?? halfHeight) - (this.orthoBottom ?? -halfHeight);
        }
        return x * y;
      }
      /**
       * Define the current limit on the left side for an orthographic camera
       * In scene unit
       */
      set orthoLeft(value) {
        this._orthoLeft = value;
        for (const rigCamera of this._rigCameras) {
          rigCamera.orthoLeft = value;
        }
      }
      get orthoLeft() {
        return this._orthoLeft;
      }
      /**
       * Define the current limit on the right side for an orthographic camera
       * In scene unit
       */
      set orthoRight(value) {
        this._orthoRight = value;
        for (const rigCamera of this._rigCameras) {
          rigCamera.orthoRight = value;
        }
      }
      get orthoRight() {
        return this._orthoRight;
      }
      /**
       * Define the current limit on the bottom side for an orthographic camera
       * In scene unit
       */
      set orthoBottom(value) {
        this._orthoBottom = value;
        for (const rigCamera of this._rigCameras) {
          rigCamera.orthoBottom = value;
        }
      }
      get orthoBottom() {
        return this._orthoBottom;
      }
      /**
       * Define the current limit on the top side for an orthographic camera
       * In scene unit
       */
      set orthoTop(value) {
        this._orthoTop = value;
        for (const rigCamera of this._rigCameras) {
          rigCamera.orthoTop = value;
        }
      }
      get orthoTop() {
        return this._orthoTop;
      }
      /**
       * Sets the camera's field of view in radians based on the focal length and sensor size.
       * @param value the focal length of the camera in mm.
       * @param sensorSize the sensor width size of the camera in mm. (default is 36mm, which is a full frame sensor)
       */
      setFocalLength(value, sensorSize = 36) {
        this.fov = 2 * Math.atan(sensorSize / (2 * value));
      }
      /**
       * Define the mode of the camera (Camera.PERSPECTIVE_CAMERA or Camera.ORTHOGRAPHIC_CAMERA)
       */
      set mode(mode) {
        this._mode = mode;
        for (const rigCamera of this._rigCameras) {
          rigCamera.mode = mode;
        }
      }
      get mode() {
        return this._mode;
      }
      /**
       * Gets a flag indicating that the camera has moved in some way since the last call to Camera.update()
       */
      get hasMoved() {
        return this._hasMoved;
      }
      /**
       * Instantiates a new camera object.
       * This should not be used directly but through the inherited cameras: ArcRotate, Free...
       * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras
       * @param name Defines the name of the camera in the scene
       * @param position Defines the position of the camera
       * @param scene Defines the scene the camera belongs too
       * @param setActiveOnSceneIfNoneActive Defines if the camera should be set as active after creation if no other camera have been defined in the scene
       */
      constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {
        super(name, scene, false);
        this._position = Vector3.Zero();
        this._upVector = Vector3.Up();
        this.oblique = null;
        this._orthoLeft = null;
        this._orthoRight = null;
        this._orthoBottom = null;
        this._orthoTop = null;
        this.fov = 0.8;
        this.projectionPlaneTilt = 0;
        this.minZ = 1;
        this.maxZ = 1e4;
        this.inertia = 0.9;
        this._mode = _Camera.PERSPECTIVE_CAMERA;
        this.isIntermediate = false;
        this.viewport = new Viewport(0, 0, 1, 1);
        this.layerMask = 268435455;
        this.fovMode = _Camera.FOVMODE_VERTICAL_FIXED;
        this.cameraRigMode = _Camera.RIG_MODE_NONE;
        this.ignoreCameraMaxZ = false;
        this.customRenderTargets = [];
        this.outputRenderTarget = null;
        this.onViewMatrixChangedObservable = new Observable();
        this.onProjectionMatrixChangedObservable = new Observable();
        this.onAfterCheckInputsObservable = new Observable();
        this.onRestoreStateObservable = new Observable();
        this.isRigCamera = false;
        this._hasMoved = false;
        this._rigCameras = new Array();
        this._skipRendering = false;
        this._projectionMatrix = new Matrix();
        this._postProcesses = new Array();
        this._activeMeshes = new SmartArray(256);
        this._globalPosition = Vector3.Zero();
        this._computedViewMatrix = Matrix.Identity();
        this._doNotComputeProjectionMatrix = false;
        this._transformMatrix = Matrix.Zero();
        this._refreshFrustumPlanes = true;
        this._absoluteRotation = Quaternion.Identity();
        this._isCamera = true;
        this._isLeftCamera = false;
        this._isRightCamera = false;
        this.getScene().addCamera(this);
        if (setActiveOnSceneIfNoneActive && !this.getScene().activeCamera) {
          this.getScene().activeCamera = this;
        }
        this.position = position;
        this.renderPassId = this.getScene().getEngine().createRenderPassId(`Camera ${name}`);
      }
      /**
       * Store current camera state (fov, position, etc..)
       * @returns the camera
       */
      storeState() {
        this._stateStored = true;
        this._storedFov = this.fov;
        return this;
      }
      /**
       * Returns true if a state has been stored by calling storeState method.
       * @returns true if state has been stored.
       */
      hasStateStored() {
        return !!this._stateStored;
      }
      /**
       * Restores the camera state values if it has been stored. You must call storeState() first
       * @returns true if restored and false otherwise
       */
      _restoreStateValues() {
        if (!this._stateStored) {
          return false;
        }
        this.fov = this._storedFov;
        return true;
      }
      /**
       * Restored camera state. You must call storeState() first.
       * @returns true if restored and false otherwise
       */
      restoreState() {
        if (this._restoreStateValues()) {
          this.onRestoreStateObservable.notifyObservers(this);
          return true;
        }
        return false;
      }
      /**
       * Gets the class name of the camera.
       * @returns the class name
       */
      getClassName() {
        return "Camera";
      }
      /**
       * Gets a string representation of the camera useful for debug purpose.
       * @param fullDetails Defines that a more verbose level of logging is required
       * @returns the string representation
       */
      toString(fullDetails) {
        let ret = "Name: " + this.name;
        ret += ", type: " + this.getClassName();
        if (this.animations) {
          for (let i = 0; i < this.animations.length; i++) {
            ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
          }
        }
        return ret;
      }
      /**
       * Automatically tilts the projection plane, using `projectionPlaneTilt`, to correct the perspective effect on vertical lines.
       */
      applyVerticalCorrection() {
        const rot = this.absoluteRotation.toEulerAngles();
        this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -rot.x : rot.x;
      }
      /**
       * Gets the current world space position of the camera.
       */
      get globalPosition() {
        return this._globalPosition;
      }
      /**
       * Gets the list of active meshes this frame (meshes no culled or excluded by lod s in the frame)
       * @returns the active meshe list
       */
      getActiveMeshes() {
        return this._activeMeshes;
      }
      /**
       * Check whether a mesh is part of the current active mesh list of the camera
       * @param mesh Defines the mesh to check
       * @returns true if active, false otherwise
       */
      isActiveMesh(mesh) {
        return this._activeMeshes.indexOf(mesh) !== -1;
      }
      /**
       * Is this camera ready to be used/rendered
       * @param completeCheck defines if a complete check (including post processes) has to be done (false by default)
       * @returns true if the camera is ready
       */
      isReady(completeCheck = false) {
        if (completeCheck) {
          for (const pp of this._postProcesses) {
            if (pp && !pp.isReady()) {
              return false;
            }
          }
        }
        return super.isReady(completeCheck);
      }
      /** @internal */
      _initCache() {
        super._initCache();
        this._cache.position = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.upVector = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.mode = void 0;
        this._cache.minZ = void 0;
        this._cache.maxZ = void 0;
        this._cache.fov = void 0;
        this._cache.fovMode = void 0;
        this._cache.aspectRatio = void 0;
        this._cache.orthoLeft = void 0;
        this._cache.orthoRight = void 0;
        this._cache.orthoBottom = void 0;
        this._cache.orthoTop = void 0;
        this._cache.obliqueAngle = void 0;
        this._cache.obliqueLength = void 0;
        this._cache.obliqueOffset = void 0;
        this._cache.renderWidth = void 0;
        this._cache.renderHeight = void 0;
      }
      /**
       * @internal
       */
      _updateCache(ignoreParentClass) {
        if (!ignoreParentClass) {
          super._updateCache();
        }
        this._cache.position.copyFrom(this.position);
        this._cache.upVector.copyFrom(this.upVector);
      }
      /** @internal */
      _isSynchronized() {
        return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();
      }
      /** @internal */
      _isSynchronizedViewMatrix() {
        if (!super._isSynchronized()) {
          return false;
        }
        return this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent();
      }
      /** @internal */
      _isSynchronizedProjectionMatrix() {
        const maxZ = this.ignoreCameraMaxZ ? 0 : this.maxZ;
        let isSynchronized = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === maxZ;
        if (!isSynchronized) {
          return false;
        }
        const engine = this.getEngine();
        if (this.mode === _Camera.PERSPECTIVE_CAMERA) {
          isSynchronized = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === engine.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt;
        } else {
          isSynchronized = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === engine.getRenderWidth() && this._cache.renderHeight === engine.getRenderHeight();
          if (this.oblique) {
            isSynchronized = isSynchronized && this._cache.obliqueAngle === this.oblique.angle && this._cache.obliqueLength === this.oblique.length && this._cache.obliqueOffset === this.oblique.offset;
          }
        }
        return isSynchronized;
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       * This function is here because typescript removes the typing of the last function.
       * @param _ignored defines an ignored parameter kept for backward compatibility.
       * @param _noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(_ignored, _noPreventDefault) {
      }
      /**
       * Detach the current controls from the specified dom element.
       * This function is here because typescript removes the typing of the last function.
       * @param _ignored defines an ignored parameter kept for backward compatibility.
       */
      detachControl(_ignored) {
      }
      /**
       * Update the camera state according to the different inputs gathered during the frame.
       */
      update() {
        this._hasMoved = false;
        this._checkInputs();
        if (this.cameraRigMode !== _Camera.RIG_MODE_NONE) {
          this._updateRigCameras();
        }
        this.getViewMatrix();
        this.getProjectionMatrix();
      }
      /** @internal */
      _checkInputs() {
        this.onAfterCheckInputsObservable.notifyObservers(this);
      }
      /** @internal */
      get rigCameras() {
        return this._rigCameras;
      }
      /**
       * Gets the post process used by the rig cameras
       */
      get rigPostProcess() {
        return this._rigPostProcess;
      }
      /**
       * Internal, gets the first post process.
       * @returns the first post process to be run on this camera.
       */
      _getFirstPostProcess() {
        for (let ppIndex = 0; ppIndex < this._postProcesses.length; ppIndex++) {
          if (this._postProcesses[ppIndex] !== null) {
            return this._postProcesses[ppIndex];
          }
        }
        return null;
      }
      _cascadePostProcessesToRigCams() {
        const firstPostProcess = this._getFirstPostProcess();
        if (firstPostProcess) {
          firstPostProcess.markTextureDirty();
        }
        for (let i = 0, len = this._rigCameras.length; i < len; i++) {
          const cam = this._rigCameras[i];
          const rigPostProcess = cam._rigPostProcess;
          if (rigPostProcess) {
            const isPass = rigPostProcess.getEffectName() === "pass";
            if (isPass) {
              cam.isIntermediate = this._postProcesses.length === 0;
            }
            cam._postProcesses = this._postProcesses.slice(0).concat(rigPostProcess);
            rigPostProcess.markTextureDirty();
          } else {
            cam._postProcesses = this._postProcesses.slice(0);
          }
        }
      }
      /**
       * Attach a post process to the camera.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#attach-postprocess
       * @param postProcess The post process to attach to the camera
       * @param insertAt The position of the post process in case several of them are in use in the scene
       * @returns the position the post process has been inserted at
       */
      attachPostProcess(postProcess, insertAt = null) {
        if (!postProcess.isReusable() && this._postProcesses.indexOf(postProcess) > -1) {
          Logger.Error("You're trying to reuse a post process not defined as reusable.");
          return 0;
        }
        if (insertAt == null || insertAt < 0) {
          this._postProcesses.push(postProcess);
        } else if (this._postProcesses[insertAt] === null) {
          this._postProcesses[insertAt] = postProcess;
        } else {
          this._postProcesses.splice(insertAt, 0, postProcess);
        }
        this._cascadePostProcessesToRigCams();
        if (this._scene.prePassRenderer) {
          this._scene.prePassRenderer.markAsDirty();
        }
        return this._postProcesses.indexOf(postProcess);
      }
      /**
       * Detach a post process to the camera.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#attach-postprocess
       * @param postProcess The post process to detach from the camera
       */
      detachPostProcess(postProcess) {
        const idx = this._postProcesses.indexOf(postProcess);
        if (idx !== -1) {
          this._postProcesses[idx] = null;
        }
        if (this._scene.prePassRenderer) {
          this._scene.prePassRenderer.markAsDirty();
        }
        this._cascadePostProcessesToRigCams();
      }
      /**
       * Gets the current world matrix of the camera
       * @returns the world matrix
       */
      getWorldMatrix() {
        if (this._isSynchronizedViewMatrix()) {
          return this._worldMatrix;
        }
        this.getViewMatrix();
        return this._worldMatrix;
      }
      /** @internal */
      _getViewMatrix() {
        return Matrix.Identity();
      }
      /**
       * Gets the current view matrix of the camera.
       * @param force forces the camera to recompute the matrix without looking at the cached state
       * @returns the view matrix
       */
      getViewMatrix(force) {
        if (!force && this._isSynchronizedViewMatrix()) {
          return this._computedViewMatrix;
        }
        this._hasMoved = true;
        this.updateCache();
        this._computedViewMatrix = this._getViewMatrix();
        this._currentRenderId = this.getScene().getRenderId();
        this._childUpdateId++;
        this._refreshFrustumPlanes = true;
        if (this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix) {
          this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix);
        }
        if (this.parent && this.parent.onViewMatrixChangedObservable) {
          this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent);
        }
        this.onViewMatrixChangedObservable.notifyObservers(this);
        this._computedViewMatrix.invertToRef(this._worldMatrix);
        this._worldMatrix.getTranslationToRef(this._globalPosition);
        return this._computedViewMatrix;
      }
      /**
       * Freeze the projection matrix.
       * It will prevent the cache check of the camera projection compute and can speed up perf
       * if no parameter of the camera are meant to change
       * @param projection Defines manually a projection if necessary
       */
      freezeProjectionMatrix(projection) {
        this._doNotComputeProjectionMatrix = true;
        if (projection !== void 0) {
          this._projectionMatrix = projection;
        }
      }
      /**
       * Unfreeze the projection matrix if it has previously been freezed by freezeProjectionMatrix.
       */
      unfreezeProjectionMatrix() {
        this._doNotComputeProjectionMatrix = false;
      }
      /**
       * Gets the current projection matrix of the camera.
       * @param force forces the camera to recompute the matrix without looking at the cached state
       * @returns the projection matrix
       */
      getProjectionMatrix(force) {
        if (this._doNotComputeProjectionMatrix || !force && this._isSynchronizedProjectionMatrix()) {
          return this._projectionMatrix;
        }
        const maxZ = this.ignoreCameraMaxZ ? 0 : this.maxZ;
        this._cache.mode = this.mode;
        this._cache.minZ = this.minZ;
        this._cache.maxZ = maxZ;
        this._refreshFrustumPlanes = true;
        const engine = this.getEngine();
        const scene = this.getScene();
        const reverseDepth = engine.useReverseDepthBuffer;
        if (this.mode === _Camera.PERSPECTIVE_CAMERA) {
          this._cache.fov = this.fov;
          this._cache.fovMode = this.fovMode;
          this._cache.aspectRatio = engine.getAspectRatio(this);
          this._cache.projectionPlaneTilt = this.projectionPlaneTilt;
          if (this.minZ <= 0) {
            this.minZ = 0.1;
          }
          let getProjectionMatrix;
          if (scene.useRightHandedSystem) {
            getProjectionMatrix = Matrix.PerspectiveFovRHToRef;
          } else {
            getProjectionMatrix = Matrix.PerspectiveFovLHToRef;
          }
          getProjectionMatrix(this.fov, engine.getAspectRatio(this), reverseDepth ? maxZ : this.minZ, reverseDepth ? this.minZ : maxZ, this._projectionMatrix, this.fovMode === _Camera.FOVMODE_VERTICAL_FIXED, engine.isNDCHalfZRange, this.projectionPlaneTilt, reverseDepth);
        } else {
          const halfWidth = engine.getRenderWidth() / 2;
          const halfHeight = engine.getRenderHeight() / 2;
          if (scene.useRightHandedSystem) {
            if (this.oblique) {
              Matrix.ObliqueOffCenterRHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? maxZ : this.minZ, reverseDepth ? this.minZ : maxZ, this.oblique.length, this.oblique.angle, this._computeObliqueDistance(this.oblique.offset), this._projectionMatrix, engine.isNDCHalfZRange);
            } else {
              Matrix.OrthoOffCenterRHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? maxZ : this.minZ, reverseDepth ? this.minZ : maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
            }
          } else {
            if (this.oblique) {
              Matrix.ObliqueOffCenterLHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? maxZ : this.minZ, reverseDepth ? this.minZ : maxZ, this.oblique.length, this.oblique.angle, this._computeObliqueDistance(this.oblique.offset), this._projectionMatrix, engine.isNDCHalfZRange);
            } else {
              Matrix.OrthoOffCenterLHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? maxZ : this.minZ, reverseDepth ? this.minZ : maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
            }
          }
          this._cache.orthoLeft = this.orthoLeft;
          this._cache.orthoRight = this.orthoRight;
          this._cache.orthoBottom = this.orthoBottom;
          this._cache.orthoTop = this.orthoTop;
          this._cache.obliqueAngle = this.oblique?.angle;
          this._cache.obliqueLength = this.oblique?.length;
          this._cache.obliqueOffset = this.oblique?.offset;
          this._cache.renderWidth = engine.getRenderWidth();
          this._cache.renderHeight = engine.getRenderHeight();
        }
        this.onProjectionMatrixChangedObservable.notifyObservers(this);
        return this._projectionMatrix;
      }
      /**
       * Gets the transformation matrix (ie. the multiplication of view by projection matrices)
       * @returns a Matrix
       */
      getTransformationMatrix() {
        this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
        return this._transformMatrix;
      }
      _computeObliqueDistance(offset) {
        const arcRotateCamera = this;
        const targetCamera = this;
        return (arcRotateCamera.radius || (targetCamera.target ? Vector3.Distance(this.position, targetCamera.target) : this.position.length())) + offset;
      }
      /** @internal */
      _updateFrustumPlanes() {
        if (!this._refreshFrustumPlanes) {
          return;
        }
        this.getTransformationMatrix();
        if (!this._frustumPlanes) {
          this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
        } else {
          Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
        }
        this._refreshFrustumPlanes = false;
      }
      /**
       * Checks if a cullable object (mesh...) is in the camera frustum
       * This checks the bounding box center. See isCompletelyInFrustum for a full bounding check
       * @param target The object to check
       * @param checkRigCameras If the rig cameras should be checked (eg. with VR camera both eyes should be checked) (Default: false)
       * @returns true if the object is in frustum otherwise false
       */
      isInFrustum(target, checkRigCameras = false) {
        this._updateFrustumPlanes();
        if (checkRigCameras && this.rigCameras.length > 0) {
          let result = false;
          for (const cam of this.rigCameras) {
            cam._updateFrustumPlanes();
            result = result || target.isInFrustum(cam._frustumPlanes);
          }
          return result;
        } else {
          return target.isInFrustum(this._frustumPlanes);
        }
      }
      /**
       * Checks if a cullable object (mesh...) is in the camera frustum
       * Unlike isInFrustum this checks the full bounding box
       * @param target The object to check
       * @returns true if the object is in frustum otherwise false
       */
      isCompletelyInFrustum(target) {
        this._updateFrustumPlanes();
        return target.isCompletelyInFrustum(this._frustumPlanes);
      }
      // eslint-disable-next-line jsdoc/require-returns-check
      /**
       * Gets a ray in the forward direction from the camera.
       * @param length Defines the length of the ray to create
       * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a world space ray
       * @param origin Defines the start point of the ray which defaults to the camera position
       * @returns the forward ray
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getForwardRay(length = 100, transform, origin) {
        throw _WarnImport("Ray");
      }
      // eslint-disable-next-line jsdoc/require-returns-check
      /**
       * Gets a ray in the forward direction from the camera.
       * @param refRay the ray to (re)use when setting the values
       * @param length Defines the length of the ray to create
       * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a world space ray
       * @param origin Defines the start point of the ray which defaults to the camera position
       * @returns the forward ray
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getForwardRayToRef(refRay, length = 100, transform, origin) {
        throw _WarnImport("Ray");
      }
      /**
       * Releases resources associated with this node.
       * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
       * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
       */
      dispose(doNotRecurse, disposeMaterialAndTextures = false) {
        this.onViewMatrixChangedObservable.clear();
        this.onProjectionMatrixChangedObservable.clear();
        this.onAfterCheckInputsObservable.clear();
        this.onRestoreStateObservable.clear();
        if (this.inputs) {
          this.inputs.clear();
        }
        this.getScene().stopAnimation(this);
        this.getScene().removeCamera(this);
        while (this._rigCameras.length > 0) {
          const camera = this._rigCameras.pop();
          if (camera) {
            camera.dispose();
          }
        }
        if (this._parentContainer) {
          const index = this._parentContainer.cameras.indexOf(this);
          if (index > -1) {
            this._parentContainer.cameras.splice(index, 1);
          }
          this._parentContainer = null;
        }
        if (this._rigPostProcess) {
          this._rigPostProcess.dispose(this);
          this._rigPostProcess = null;
          this._postProcesses.length = 0;
        } else if (this.cameraRigMode !== _Camera.RIG_MODE_NONE) {
          this._rigPostProcess = null;
          this._postProcesses.length = 0;
        } else {
          let i2 = this._postProcesses.length;
          while (--i2 >= 0) {
            const postProcess = this._postProcesses[i2];
            if (postProcess) {
              postProcess.dispose(this);
            }
          }
        }
        let i = this.customRenderTargets.length;
        while (--i >= 0) {
          this.customRenderTargets[i].dispose();
        }
        this.customRenderTargets.length = 0;
        this._activeMeshes.dispose();
        this.getScene().getEngine().releaseRenderPassId(this.renderPassId);
        super.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
      /**
       * Gets the left camera of a rig setup in case of Rigged Camera
       */
      get isLeftCamera() {
        return this._isLeftCamera;
      }
      /**
       * Gets the right camera of a rig setup in case of Rigged Camera
       */
      get isRightCamera() {
        return this._isRightCamera;
      }
      /**
       * Gets the left camera of a rig setup in case of Rigged Camera
       */
      get leftCamera() {
        if (this._rigCameras.length < 1) {
          return null;
        }
        return this._rigCameras[0];
      }
      /**
       * Gets the right camera of a rig setup in case of Rigged Camera
       */
      get rightCamera() {
        if (this._rigCameras.length < 2) {
          return null;
        }
        return this._rigCameras[1];
      }
      /**
       * Gets the left camera target of a rig setup in case of Rigged Camera
       * @returns the target position
       */
      getLeftTarget() {
        if (this._rigCameras.length < 1) {
          return null;
        }
        return this._rigCameras[0].getTarget();
      }
      /**
       * Gets the right camera target of a rig setup in case of Rigged Camera
       * @returns the target position
       */
      getRightTarget() {
        if (this._rigCameras.length < 2) {
          return null;
        }
        return this._rigCameras[1].getTarget();
      }
      /**
       * @internal
       */
      setCameraRigMode(mode, rigParams) {
        if (this.cameraRigMode === mode) {
          return;
        }
        while (this._rigCameras.length > 0) {
          const camera = this._rigCameras.pop();
          if (camera) {
            camera.dispose();
          }
        }
        this.cameraRigMode = mode;
        this._cameraRigParams = {};
        this._cameraRigParams.interaxialDistance = rigParams.interaxialDistance || 0.0637;
        this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637);
        if (this.cameraRigMode !== _Camera.RIG_MODE_NONE) {
          const leftCamera = this.createRigCamera(this.name + "_L", 0);
          if (leftCamera) {
            leftCamera._isLeftCamera = true;
          }
          const rightCamera = this.createRigCamera(this.name + "_R", 1);
          if (rightCamera) {
            rightCamera._isRightCamera = true;
          }
          if (leftCamera && rightCamera) {
            this._rigCameras.push(leftCamera);
            this._rigCameras.push(rightCamera);
          }
        }
        this._setRigMode(rigParams);
        this._cascadePostProcessesToRigCams();
        this.update();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _setRigMode(rigParams) {
      }
      /** @internal */
      _getVRProjectionMatrix() {
        Matrix.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.ignoreCameraMaxZ ? 0 : this.maxZ, this._cameraRigParams.vrWorkMatrix, true, this.getEngine().isNDCHalfZRange);
        this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix);
        return this._projectionMatrix;
      }
      /**
       * @internal
       */
      setCameraRigParameter(name, value) {
        if (!this._cameraRigParams) {
          this._cameraRigParams = {};
        }
        this._cameraRigParams[name] = value;
        if (name === "interaxialDistance") {
          this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(value / 0.0637);
        }
      }
      /**
       * needs to be overridden by children so sub has required properties to be copied
       * @internal
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      createRigCamera(name, cameraIndex) {
        return null;
      }
      /**
       * May need to be overridden by children
       * @internal
       */
      _updateRigCameras() {
        for (let i = 0; i < this._rigCameras.length; i++) {
          this._rigCameras[i].minZ = this.minZ;
          this._rigCameras[i].maxZ = this.ignoreCameraMaxZ ? 0 : this.maxZ;
          this._rigCameras[i].fov = this.fov;
          this._rigCameras[i].upVector.copyFrom(this.upVector);
        }
        if (this.cameraRigMode === _Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH) {
          this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport;
        }
      }
      /** @internal */
      _setupInputs() {
      }
      /**
       * Serialiaze the camera setup to a json representation
       * @returns the JSON representation
       */
      serialize() {
        const serializationObject = SerializationHelper.Serialize(this);
        serializationObject.uniqueId = this.uniqueId;
        serializationObject.type = this.getClassName();
        if (this.parent) {
          this.parent._serializeAsParent(serializationObject);
        }
        if (this.inputs) {
          this.inputs.serialize(serializationObject);
        }
        SerializationHelper.AppendSerializedAnimations(this, serializationObject);
        serializationObject.ranges = this.serializeAnimationRanges();
        serializationObject.isEnabled = this.isEnabled();
        return serializationObject;
      }
      /**
       * Clones the current camera.
       * @param name The cloned camera name
       * @param newParent The cloned camera's new parent (none by default)
       * @returns the cloned camera
       */
      clone(name, newParent = null) {
        const camera = SerializationHelper.Clone(_Camera.GetConstructorFromName(this.getClassName(), name, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);
        camera.name = name;
        camera.parent = newParent;
        this.onClonedObservable.notifyObservers(camera);
        return camera;
      }
      /**
       * Gets the direction of the camera relative to a given local axis.
       * @param localAxis Defines the reference axis to provide a relative direction.
       * @returns the direction
       */
      getDirection(localAxis) {
        const result = Vector3.Zero();
        this.getDirectionToRef(localAxis, result);
        return result;
      }
      /**
       * Returns the current camera absolute rotation
       */
      get absoluteRotation() {
        this.getWorldMatrix().decompose(void 0, this._absoluteRotation);
        return this._absoluteRotation;
      }
      /**
       * Gets the direction of the camera relative to a given local axis into a passed vector.
       * @param localAxis Defines the reference axis to provide a relative direction.
       * @param result Defines the vector to store the result in
       */
      getDirectionToRef(localAxis, result) {
        Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
      }
      /**
       * Gets a camera constructor for a given camera type
       * @param type The type of the camera to construct (should be equal to one of the camera class name)
       * @param name The name of the camera the result will be able to instantiate
       * @param scene The scene the result will construct the camera in
       * @param interaxial_distance In case of stereoscopic setup, the distance between both eyes
       * @param isStereoscopicSideBySide In case of stereoscopic setup, should the sereo be side b side
       * @returns a factory method to construct the camera
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      static GetConstructorFromName(type, name, scene, interaxial_distance = 0, isStereoscopicSideBySide = true) {
        const constructorFunc = Node.Construct(type, name, scene, {
          // eslint-disable-next-line @typescript-eslint/naming-convention
          interaxial_distance,
          isStereoscopicSideBySide
        });
        if (constructorFunc) {
          return constructorFunc;
        }
        return () => _Camera._CreateDefaultParsedCamera(name, scene);
      }
      /**
       * Compute the world  matrix of the camera.
       * @returns the camera world matrix
       */
      computeWorldMatrix() {
        return this.getWorldMatrix();
      }
      /**
       * Parse a JSON and creates the camera from the parsed information
       * @param parsedCamera The JSON to parse
       * @param scene The scene to instantiate the camera in
       * @returns the newly constructed camera
       */
      static Parse(parsedCamera, scene) {
        const type = parsedCamera.type;
        const construct = _Camera.GetConstructorFromName(type, parsedCamera.name, scene, parsedCamera.interaxial_distance, parsedCamera.isStereoscopicSideBySide);
        const camera = SerializationHelper.Parse(construct, parsedCamera, scene);
        if (parsedCamera.parentId !== void 0) {
          camera._waitingParentId = parsedCamera.parentId;
        }
        if (parsedCamera.parentInstanceIndex !== void 0) {
          camera._waitingParentInstanceIndex = parsedCamera.parentInstanceIndex;
        }
        if (camera.inputs) {
          camera.inputs.parse(parsedCamera);
          camera._setupInputs();
        }
        if (parsedCamera.upVector) {
          camera.upVector = Vector3.FromArray(parsedCamera.upVector);
        }
        if (camera.setPosition) {
          camera.position.copyFromFloats(0, 0, 0);
          camera.setPosition(Vector3.FromArray(parsedCamera.position));
        }
        if (parsedCamera.target) {
          if (camera.setTarget) {
            camera.setTarget(Vector3.FromArray(parsedCamera.target));
          }
        }
        if (parsedCamera.cameraRigMode) {
          const rigParams = parsedCamera.interaxial_distance ? { interaxialDistance: parsedCamera.interaxial_distance } : {};
          camera.setCameraRigMode(parsedCamera.cameraRigMode, rigParams);
        }
        if (parsedCamera.animations) {
          for (let animationIndex = 0; animationIndex < parsedCamera.animations.length; animationIndex++) {
            const parsedAnimation = parsedCamera.animations[animationIndex];
            const internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              camera.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          Node.ParseAnimationRanges(camera, parsedCamera, scene);
        }
        if (parsedCamera.autoAnimate) {
          scene.beginAnimation(camera, parsedCamera.autoAnimateFrom, parsedCamera.autoAnimateTo, parsedCamera.autoAnimateLoop, parsedCamera.autoAnimateSpeed || 1);
        }
        if (parsedCamera.isEnabled !== void 0) {
          camera.setEnabled(parsedCamera.isEnabled);
        }
        return camera;
      }
      /** @internal */
      _calculateHandednessMultiplier() {
        let handednessMultiplier = this.getScene().useRightHandedSystem ? -1 : 1;
        if (this.parent && this.parent._getWorldMatrixDeterminant() < 0) {
          handednessMultiplier *= -1;
        }
        return handednessMultiplier;
      }
    };
    Camera._CreateDefaultParsedCamera = (name, scene) => {
      throw _WarnImport("UniversalCamera");
    };
    Camera.PERSPECTIVE_CAMERA = 0;
    Camera.ORTHOGRAPHIC_CAMERA = 1;
    Camera.FOVMODE_VERTICAL_FIXED = 0;
    Camera.FOVMODE_HORIZONTAL_FIXED = 1;
    Camera.RIG_MODE_NONE = 0;
    Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
    Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
    Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
    Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
    Camera.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
    Camera.RIG_MODE_VR = 20;
    Camera.RIG_MODE_CUSTOM = 22;
    Camera.ForceAttachControlToAlwaysPreventDefault = false;
    __decorate([
      serializeAsVector3("position")
    ], Camera.prototype, "_position", void 0);
    __decorate([
      serializeAsVector3("upVector")
    ], Camera.prototype, "_upVector", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "orthoLeft", null);
    __decorate([
      serialize()
    ], Camera.prototype, "orthoRight", null);
    __decorate([
      serialize()
    ], Camera.prototype, "orthoBottom", null);
    __decorate([
      serialize()
    ], Camera.prototype, "orthoTop", null);
    __decorate([
      serialize()
    ], Camera.prototype, "fov", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "projectionPlaneTilt", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "minZ", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "maxZ", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "inertia", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "mode", null);
    __decorate([
      serialize()
    ], Camera.prototype, "layerMask", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "fovMode", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "cameraRigMode", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "interaxialDistance", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "isStereoscopicSideBySide", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "ignoreCameraMaxZ", void 0);
  }
});

// node_modules/@babylonjs/core/Loading/sceneLoaderFlags.js
var SceneLoaderFlags;
var init_sceneLoaderFlags = __esm({
  "node_modules/@babylonjs/core/Loading/sceneLoaderFlags.js"() {
    SceneLoaderFlags = class _SceneLoaderFlags {
      /**
       * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data
       */
      static get ForceFullSceneLoadingForIncremental() {
        return _SceneLoaderFlags._ForceFullSceneLoadingForIncremental;
      }
      static set ForceFullSceneLoadingForIncremental(value) {
        _SceneLoaderFlags._ForceFullSceneLoadingForIncremental = value;
      }
      /**
       * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene
       */
      static get ShowLoadingScreen() {
        return _SceneLoaderFlags._ShowLoadingScreen;
      }
      static set ShowLoadingScreen(value) {
        _SceneLoaderFlags._ShowLoadingScreen = value;
      }
      /**
       * Defines the current logging level (while loading the scene)
       * @ignorenaming
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      static get loggingLevel() {
        return _SceneLoaderFlags._LoggingLevel;
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      static set loggingLevel(value) {
        _SceneLoaderFlags._LoggingLevel = value;
      }
      /**
       * Gets or set a boolean indicating if matrix weights must be cleaned upon loading
       */
      static get CleanBoneMatrixWeights() {
        return _SceneLoaderFlags._CleanBoneMatrixWeights;
      }
      static set CleanBoneMatrixWeights(value) {
        _SceneLoaderFlags._CleanBoneMatrixWeights = value;
      }
    };
    SceneLoaderFlags._ForceFullSceneLoadingForIncremental = false;
    SceneLoaderFlags._ShowLoadingScreen = true;
    SceneLoaderFlags._CleanBoneMatrixWeights = false;
    SceneLoaderFlags._LoggingLevel = 0;
  }
});

// node_modules/@babylonjs/core/Meshes/geometry.js
var Geometry;
var init_geometry = __esm({
  "node_modules/@babylonjs/core/Meshes/geometry.js"() {
    init_math_vector();
    init_math_color();
    init_mesh_vertexData();
    init_buffer();
    init_subMesh();
    init_sceneLoaderFlags();
    init_boundingInfo();
    init_tools();
    init_tags();
    init_math_functions();
    init_engineStore();
    init_compatibilityOptions();
    init_bufferUtils();
    Geometry = class _Geometry {
      /**
       *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y
       */
      get boundingBias() {
        return this._boundingBias;
      }
      /**
       *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y
       */
      set boundingBias(value) {
        if (this._boundingBias) {
          this._boundingBias.copyFrom(value);
        } else {
          this._boundingBias = value.clone();
        }
        this._updateBoundingInfo(true, null);
      }
      /**
       * Static function used to attach a new empty geometry to a mesh
       * @param mesh defines the mesh to attach the geometry to
       * @returns the new Geometry
       */
      static CreateGeometryForMesh(mesh) {
        const geometry = new _Geometry(_Geometry.RandomId(), mesh.getScene());
        geometry.applyToMesh(mesh);
        return geometry;
      }
      /** Get the list of meshes using this geometry */
      get meshes() {
        return this._meshes;
      }
      /**
       * Creates a new geometry
       * @param id defines the unique ID
       * @param scene defines the hosting scene
       * @param vertexData defines the VertexData used to get geometry data
       * @param updatable defines if geometry must be updatable (false by default)
       * @param mesh defines the mesh that will be associated with the geometry
       * @param totalVertices defines the total number of vertices (optional)
       */
      constructor(id, scene, vertexData, updatable = false, mesh = null, totalVertices = null) {
        this.delayLoadState = 0;
        this._totalVertices = 0;
        this._isDisposed = false;
        this._extend = {
          minimum: new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE),
          maximum: new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)
        };
        this._indexBufferIsUpdatable = false;
        this._positionsCache = [];
        this._parentContainer = null;
        this.useBoundingInfoFromGeometry = false;
        this._scene = scene || EngineStore.LastCreatedScene;
        if (!this._scene) {
          return;
        }
        this.id = id;
        this.uniqueId = this._scene.getUniqueId();
        this._engine = this._scene.getEngine();
        this._meshes = [];
        this._vertexBuffers = {};
        this._indices = [];
        this._updatable = updatable;
        if (totalVertices !== null) {
          this._totalVertices = totalVertices;
        }
        if (vertexData) {
          this.setAllVerticesData(vertexData, updatable);
        } else if (totalVertices === null) {
          this._totalVertices = 0;
        }
        if (this._engine.getCaps().vertexArrayObject) {
          this._vertexArrayObjects = {};
        }
        if (mesh) {
          this.applyToMesh(mesh);
          mesh.computeWorldMatrix(true);
        }
      }
      /**
       * Gets the current extend of the geometry
       */
      get extend() {
        return this._extend;
      }
      /**
       * Gets the hosting scene
       * @returns the hosting Scene
       */
      getScene() {
        return this._scene;
      }
      /**
       * Gets the hosting engine
       * @returns the hosting Engine
       */
      getEngine() {
        return this._engine;
      }
      /**
       * Defines if the geometry is ready to use
       * @returns true if the geometry is ready to be used
       */
      isReady() {
        return this.delayLoadState === 1 || this.delayLoadState === 0;
      }
      /**
       * Gets a value indicating that the geometry should not be serialized
       */
      get doNotSerialize() {
        for (let index = 0; index < this._meshes.length; index++) {
          if (!this._meshes[index].doNotSerialize) {
            return false;
          }
        }
        return true;
      }
      /** @internal */
      _rebuild() {
        if (this._vertexArrayObjects) {
          this._vertexArrayObjects = {};
        }
        if (this._meshes.length !== 0 && this._indices) {
          this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable, "Geometry_" + this.id + "_IndexBuffer");
        }
        const buffers = /* @__PURE__ */ new Set();
        for (const key in this._vertexBuffers) {
          buffers.add(this._vertexBuffers[key].getWrapperBuffer());
        }
        buffers.forEach((buffer) => {
          buffer._rebuild();
        });
      }
      /**
       * Affects all geometry data in one call
       * @param vertexData defines the geometry data
       * @param updatable defines if the geometry must be flagged as updatable (false as default)
       */
      setAllVerticesData(vertexData, updatable) {
        vertexData.applyToGeometry(this, updatable);
        this._notifyUpdate();
      }
      /**
       * Set specific vertex data
       * @param kind defines the data kind (Position, normal, etc...)
       * @param data defines the vertex data to use
       * @param updatable defines if the vertex must be flagged as updatable (false as default)
       * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified
       */
      setVerticesData(kind, data, updatable = false, stride) {
        if (updatable && Array.isArray(data)) {
          data = new Float32Array(data);
        }
        const buffer = new VertexBuffer(this._engine, data, kind, {
          updatable,
          postponeInternalCreation: this._meshes.length === 0,
          stride,
          label: "Geometry_" + this.id + "_" + kind
        });
        this.setVerticesBuffer(buffer);
      }
      /**
       * Removes a specific vertex data
       * @param kind defines the data kind (Position, normal, etc...)
       */
      removeVerticesData(kind) {
        if (this._vertexBuffers[kind]) {
          this._vertexBuffers[kind].dispose();
          delete this._vertexBuffers[kind];
        }
        if (this._vertexArrayObjects) {
          this._disposeVertexArrayObjects();
        }
      }
      /**
       * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data
       * @param buffer defines the vertex buffer to use
       * @param totalVertices defines the total number of vertices for position kind (could be null)
       * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)
       */
      setVerticesBuffer(buffer, totalVertices = null, disposeExistingBuffer = true) {
        const kind = buffer.getKind();
        if (this._vertexBuffers[kind] && disposeExistingBuffer) {
          this._vertexBuffers[kind].dispose();
        }
        if (buffer._buffer && buffer._ownsBuffer) {
          buffer._buffer._increaseReferences();
        }
        this._vertexBuffers[kind] = buffer;
        const meshes = this._meshes;
        const numOfMeshes = meshes.length;
        if (kind === VertexBuffer.PositionKind) {
          this._totalVertices = totalVertices ?? buffer._maxVerticesCount;
          this._updateExtend(this.useBoundingInfoFromGeometry && this._boundingInfo ? null : buffer.getFloatData(this._totalVertices));
          this._resetPointsArrayCache();
          const minimum = this._extend && this._extend.minimum || new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
          const maximum = this._extend && this._extend.maximum || new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
          for (let index = 0; index < numOfMeshes; index++) {
            const mesh = meshes[index];
            mesh.buildBoundingInfo(minimum, maximum);
            mesh._createGlobalSubMesh(mesh.isUnIndexed);
            mesh.computeWorldMatrix(true);
            mesh.synchronizeInstances();
          }
        }
        this._notifyUpdate(kind);
      }
      /**
       * Update a specific vertex buffer
       * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array
       * It will do nothing if the buffer is not updatable
       * @param kind defines the data kind (Position, normal, etc...)
       * @param data defines the data to use
       * @param offset defines the offset in the target buffer where to store the data
       * @param useBytes set to true if the offset is in bytes
       */
      updateVerticesDataDirectly(kind, data, offset, useBytes = false) {
        const vertexBuffer = this.getVertexBuffer(kind);
        if (!vertexBuffer) {
          return;
        }
        vertexBuffer.updateDirectly(data, offset, useBytes);
        this._notifyUpdate(kind);
      }
      /**
       * Update a specific vertex buffer
       * This function will create a new buffer if the current one is not updatable
       * @param kind defines the data kind (Position, normal, etc...)
       * @param data defines the data to use
       * @param updateExtends defines if the geometry extends must be recomputed (false by default)
       */
      updateVerticesData(kind, data, updateExtends = false) {
        const vertexBuffer = this.getVertexBuffer(kind);
        if (!vertexBuffer) {
          return;
        }
        vertexBuffer.update(data);
        if (kind === VertexBuffer.PositionKind) {
          this._updateBoundingInfo(updateExtends, data);
        }
        this._notifyUpdate(kind);
      }
      _updateBoundingInfo(updateExtends, data) {
        if (updateExtends) {
          this._updateExtend(data);
        }
        this._resetPointsArrayCache();
        if (updateExtends) {
          const meshes = this._meshes;
          for (const mesh of meshes) {
            if (mesh.hasBoundingInfo) {
              mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);
            } else {
              mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
            }
            const subMeshes = mesh.subMeshes;
            for (const subMesh of subMeshes) {
              subMesh.refreshBoundingInfo();
            }
          }
        }
      }
      /**
       * @internal
       */
      _bind(effect, indexToBind, overrideVertexBuffers, overrideVertexArrayObjects) {
        if (!effect) {
          return;
        }
        if (indexToBind === void 0) {
          indexToBind = this._indexBuffer;
        }
        const vbs = this.getVertexBuffers();
        if (!vbs) {
          return;
        }
        if (indexToBind != this._indexBuffer || !this._vertexArrayObjects && !overrideVertexArrayObjects) {
          this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);
          return;
        }
        const vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects;
        const engine = this._engine;
        if (!vaos[effect.key]) {
          vaos[effect.key] = engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);
        }
        engine.bindVertexArrayObject(vaos[effect.key], indexToBind);
      }
      /**
       * Gets total number of vertices
       * @returns the total number of vertices
       */
      getTotalVertices() {
        if (!this.isReady()) {
          return 0;
        }
        return this._totalVertices;
      }
      /**
       * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.
       * @param kind defines the data kind (Position, normal, etc...)
       * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes
       * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
       * @returns a float array containing vertex data
       */
      getVerticesData(kind, copyWhenShared, forceCopy) {
        const vertexBuffer = this.getVertexBuffer(kind);
        if (!vertexBuffer) {
          return null;
        }
        return vertexBuffer.getFloatData(this._totalVertices, forceCopy || copyWhenShared && this._meshes.length !== 1);
      }
      /**
       * Copies the requested vertex data kind into the given vertex data map. Float data is constructed if the map doesn't have the data.
       * @param kind defines the data kind (Position, normal, etc...)
       * @param vertexData defines the map that stores the resulting data
       */
      copyVerticesData(kind, vertexData) {
        const vertexBuffer = this.getVertexBuffer(kind);
        if (!vertexBuffer) {
          return;
        }
        vertexData[kind] || (vertexData[kind] = new Float32Array(this._totalVertices * vertexBuffer.getSize()));
        const data = vertexBuffer.getData();
        if (data) {
          CopyFloatData(data, vertexBuffer.getSize(), vertexBuffer.type, vertexBuffer.byteOffset, vertexBuffer.byteStride, vertexBuffer.normalized, this._totalVertices, vertexData[kind]);
        }
      }
      /**
       * Returns a boolean defining if the vertex data for the requested `kind` is updatable
       * @param kind defines the data kind (Position, normal, etc...)
       * @returns true if the vertex buffer with the specified kind is updatable
       */
      isVertexBufferUpdatable(kind) {
        const vb = this._vertexBuffers[kind];
        if (!vb) {
          return false;
        }
        return vb.isUpdatable();
      }
      /**
       * Gets a specific vertex buffer
       * @param kind defines the data kind (Position, normal, etc...)
       * @returns a VertexBuffer
       */
      getVertexBuffer(kind) {
        if (!this.isReady()) {
          return null;
        }
        return this._vertexBuffers[kind];
      }
      /**
       * Returns all vertex buffers
       * @returns an object holding all vertex buffers indexed by kind
       */
      getVertexBuffers() {
        if (!this.isReady()) {
          return null;
        }
        return this._vertexBuffers;
      }
      /**
       * Gets a boolean indicating if specific vertex buffer is present
       * @param kind defines the data kind (Position, normal, etc...)
       * @returns true if data is present
       */
      isVerticesDataPresent(kind) {
        if (!this._vertexBuffers) {
          if (this._delayInfo) {
            return this._delayInfo.indexOf(kind) !== -1;
          }
          return false;
        }
        return this._vertexBuffers[kind] !== void 0;
      }
      /**
       * Gets a list of all attached data kinds (Position, normal, etc...)
       * @returns a list of string containing all kinds
       */
      getVerticesDataKinds() {
        const result = [];
        let kind;
        if (!this._vertexBuffers && this._delayInfo) {
          for (kind in this._delayInfo) {
            result.push(kind);
          }
        } else {
          for (kind in this._vertexBuffers) {
            result.push(kind);
          }
        }
        return result;
      }
      /**
       * Update index buffer
       * @param indices defines the indices to store in the index buffer
       * @param offset defines the offset in the target buffer where to store the data
       * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)
       */
      updateIndices(indices, offset, gpuMemoryOnly = false) {
        if (!this._indexBuffer) {
          return;
        }
        if (!this._indexBufferIsUpdatable) {
          this.setIndices(indices, null, true);
        } else {
          const needToUpdateSubMeshes = indices.length !== this._indices.length;
          if (!gpuMemoryOnly) {
            this._indices = indices.slice();
          }
          this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);
          if (needToUpdateSubMeshes) {
            for (const mesh of this._meshes) {
              mesh._createGlobalSubMesh(true);
            }
          }
        }
      }
      /**
       * Sets the index buffer for this geometry.
       * @param indexBuffer Defines the index buffer to use for this geometry
       * @param totalVertices Defines the total number of vertices used by the buffer
       * @param totalIndices Defines the total number of indices in the index buffer
       * @param is32Bits Defines if the indices are 32 bits. If null (default), the value is guessed from the number of vertices
       */
      setIndexBuffer(indexBuffer, totalVertices, totalIndices, is32Bits = null) {
        this._indices = [];
        this._indexBufferIsUpdatable = false;
        this._indexBuffer = indexBuffer;
        this._totalVertices = totalVertices;
        this._totalIndices = totalIndices;
        if (is32Bits === null) {
          indexBuffer.is32Bits = totalVertices > 65535;
        } else {
          indexBuffer.is32Bits = is32Bits;
        }
        for (const mesh of this._meshes) {
          mesh._createGlobalSubMesh(true);
          mesh.synchronizeInstances();
        }
        this._notifyUpdate();
      }
      /**
       * Creates a new index buffer
       * @param indices defines the indices to store in the index buffer
       * @param totalVertices defines the total number of vertices (could be null)
       * @param updatable defines if the index buffer must be flagged as updatable (false by default)
       * @param dontForceSubMeshRecreation defines a boolean indicating that we don't want to force the recreation of sub-meshes if we don't have to (false by default)
       */
      setIndices(indices, totalVertices = null, updatable = false, dontForceSubMeshRecreation = false) {
        if (this._indexBuffer) {
          this._engine._releaseBuffer(this._indexBuffer);
        }
        this._indices = indices;
        this._indexBufferIsUpdatable = updatable;
        if (this._meshes.length !== 0 && this._indices) {
          this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable, "Geometry_" + this.id + "_IndexBuffer");
        }
        if (totalVertices != void 0) {
          this._totalVertices = totalVertices;
        }
        for (const mesh of this._meshes) {
          mesh._createGlobalSubMesh(!dontForceSubMeshRecreation);
          mesh.synchronizeInstances();
        }
        this._notifyUpdate();
      }
      /**
       * Return the total number of indices
       * @returns the total number of indices
       */
      getTotalIndices() {
        if (!this.isReady()) {
          return 0;
        }
        return this._totalIndices !== void 0 ? this._totalIndices : this._indices.length;
      }
      /**
       * Gets the index buffer array
       * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes
       * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
       * @returns the index buffer array
       */
      getIndices(copyWhenShared, forceCopy) {
        if (!this.isReady()) {
          return null;
        }
        const orig = this._indices;
        if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {
          return orig;
        } else {
          return orig.slice();
        }
      }
      /**
       * Gets the index buffer
       * @returns the index buffer
       */
      getIndexBuffer() {
        if (!this.isReady()) {
          return null;
        }
        return this._indexBuffer;
      }
      /**
       * @internal
       */
      _releaseVertexArrayObject(effect = null) {
        if (!effect || !this._vertexArrayObjects) {
          return;
        }
        if (this._vertexArrayObjects[effect.key]) {
          this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);
          delete this._vertexArrayObjects[effect.key];
        }
      }
      /**
       * Release the associated resources for a specific mesh
       * @param mesh defines the source mesh
       * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it
       */
      releaseForMesh(mesh, shouldDispose) {
        const meshes = this._meshes;
        const index = meshes.indexOf(mesh);
        if (index === -1) {
          return;
        }
        meshes.splice(index, 1);
        if (this._vertexArrayObjects) {
          mesh._invalidateInstanceVertexArrayObject();
        }
        mesh._geometry = null;
        if (meshes.length === 0 && shouldDispose) {
          this.dispose();
        }
      }
      /**
       * Apply current geometry to a given mesh
       * @param mesh defines the mesh to apply geometry to
       */
      applyToMesh(mesh) {
        if (mesh._geometry === this) {
          return;
        }
        const previousGeometry = mesh._geometry;
        if (previousGeometry) {
          previousGeometry.releaseForMesh(mesh);
        }
        if (this._vertexArrayObjects) {
          mesh._invalidateInstanceVertexArrayObject();
        }
        const meshes = this._meshes;
        mesh._geometry = this;
        mesh._internalAbstractMeshDataInfo._positions = null;
        this._scene.pushGeometry(this);
        meshes.push(mesh);
        if (this.isReady()) {
          this._applyToMesh(mesh);
        } else if (this._boundingInfo) {
          mesh.setBoundingInfo(this._boundingInfo);
        }
      }
      _updateExtend(data = null) {
        if (this.useBoundingInfoFromGeometry && this._boundingInfo) {
          this._extend = {
            minimum: this._boundingInfo.minimum.clone(),
            maximum: this._boundingInfo.maximum.clone()
          };
        } else {
          if (!data) {
            data = this.getVerticesData(VertexBuffer.PositionKind);
            if (!data) {
              return;
            }
          }
          this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);
        }
      }
      _applyToMesh(mesh) {
        for (const kind in this._vertexBuffers) {
          const vertexBuffer = this._vertexBuffers[kind];
          if (!vertexBuffer._buffer.getBuffer()) {
            vertexBuffer.create();
          }
          if (kind === VertexBuffer.PositionKind) {
            if (!this._extend) {
              this._updateExtend();
            }
            mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
            mesh._createGlobalSubMesh(mesh.isUnIndexed);
            mesh._updateBoundingInfo();
          }
        }
        if (!this._indexBuffer && this._indices && this._indices.length > 0) {
          this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable, "Geometry_" + this.id + "_IndexBuffer");
        }
        mesh._syncGeometryWithMorphTargetManager();
        mesh.synchronizeInstances();
      }
      _notifyUpdate(kind) {
        if (this.onGeometryUpdated) {
          this.onGeometryUpdated(this, kind);
        }
        if (this._vertexArrayObjects) {
          this._disposeVertexArrayObjects();
        }
        for (const mesh of this._meshes) {
          mesh._markSubMeshesAsAttributesDirty();
        }
      }
      /**
       * Load the geometry if it was flagged as delay loaded
       * @param scene defines the hosting scene
       * @param onLoaded defines a callback called when the geometry is loaded
       */
      load(scene, onLoaded) {
        if (this.delayLoadState === 2) {
          return;
        }
        if (this.isReady()) {
          if (onLoaded) {
            onLoaded();
          }
          return;
        }
        this.delayLoadState = 2;
        this._queueLoad(scene, onLoaded);
      }
      _queueLoad(scene, onLoaded) {
        if (!this.delayLoadingFile) {
          return;
        }
        scene.addPendingData(this);
        scene._loadFile(this.delayLoadingFile, (data) => {
          if (!this._delayLoadingFunction) {
            return;
          }
          this._delayLoadingFunction(JSON.parse(data), this);
          this.delayLoadState = 1;
          this._delayInfo = [];
          scene.removePendingData(this);
          const meshes = this._meshes;
          const numOfMeshes = meshes.length;
          for (let index = 0; index < numOfMeshes; index++) {
            this._applyToMesh(meshes[index]);
          }
          if (onLoaded) {
            onLoaded();
          }
        }, void 0, true);
      }
      /**
       * Invert the geometry to move from a right handed system to a left handed one.
       */
      toLeftHanded() {
        const tIndices = this.getIndices(false);
        if (tIndices != null && tIndices.length > 0) {
          for (let i = 0; i < tIndices.length; i += 3) {
            const tTemp = tIndices[i + 0];
            tIndices[i + 0] = tIndices[i + 2];
            tIndices[i + 2] = tTemp;
          }
          this.setIndices(tIndices);
        }
        const tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);
        if (tPositions != null && tPositions.length > 0) {
          for (let i = 0; i < tPositions.length; i += 3) {
            tPositions[i + 2] = -tPositions[i + 2];
          }
          this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);
        }
        const tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);
        if (tNormals != null && tNormals.length > 0) {
          for (let i = 0; i < tNormals.length; i += 3) {
            tNormals[i + 2] = -tNormals[i + 2];
          }
          this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);
        }
      }
      // Cache
      /** @internal */
      _resetPointsArrayCache() {
        this._positions = null;
      }
      /** @internal */
      _generatePointsArray() {
        if (this._positions) {
          return true;
        }
        const data = this.getVerticesData(VertexBuffer.PositionKind);
        if (!data || data.length === 0) {
          return false;
        }
        for (let index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {
          this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);
        }
        for (let index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {
          this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);
        }
        this._positionsCache.length = data.length / 3;
        this._positions = this._positionsCache;
        return true;
      }
      /**
       * Gets a value indicating if the geometry is disposed
       * @returns true if the geometry was disposed
       */
      isDisposed() {
        return this._isDisposed;
      }
      _disposeVertexArrayObjects() {
        if (this._vertexArrayObjects) {
          for (const kind in this._vertexArrayObjects) {
            this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);
          }
          this._vertexArrayObjects = {};
          const meshes = this._meshes;
          const numOfMeshes = meshes.length;
          for (let index = 0; index < numOfMeshes; index++) {
            meshes[index]._invalidateInstanceVertexArrayObject();
          }
        }
      }
      /**
       * Free all associated resources
       */
      dispose() {
        const meshes = this._meshes;
        const numOfMeshes = meshes.length;
        let index;
        for (index = 0; index < numOfMeshes; index++) {
          this.releaseForMesh(meshes[index]);
        }
        this._meshes.length = 0;
        this._disposeVertexArrayObjects();
        for (const kind in this._vertexBuffers) {
          this._vertexBuffers[kind].dispose();
        }
        this._vertexBuffers = {};
        this._totalVertices = 0;
        if (this._indexBuffer) {
          this._engine._releaseBuffer(this._indexBuffer);
        }
        this._indexBuffer = null;
        this._indices = [];
        this.delayLoadState = 0;
        this.delayLoadingFile = null;
        this._delayLoadingFunction = null;
        this._delayInfo = [];
        this._boundingInfo = null;
        this._scene.removeGeometry(this);
        if (this._parentContainer) {
          const index2 = this._parentContainer.geometries.indexOf(this);
          if (index2 > -1) {
            this._parentContainer.geometries.splice(index2, 1);
          }
          this._parentContainer = null;
        }
        this._isDisposed = true;
      }
      /**
       * Clone the current geometry into a new geometry
       * @param id defines the unique ID of the new geometry
       * @returns a new geometry object
       */
      copy(id) {
        const geometry = new _Geometry(id, this._scene);
        const indices = this.getIndices(void 0, true);
        if (indices) {
          geometry.setIndices(indices);
        }
        let updatable = false;
        let kind;
        for (kind in this._vertexBuffers) {
          const vb = this.getVertexBuffer(kind);
          const bufferData = vb.getData();
          if (!bufferData) {
            continue;
          }
          const isUpdatable = vb.isUpdatable();
          const size = vb.getSize();
          const { type, byteOffset, byteStride, normalized } = vb;
          updatable = updatable || isUpdatable;
          let numElements = this._totalVertices;
          if (vb.getIsInstanced()) {
            let bufferDataByteSize = 0;
            if (bufferData instanceof Array) {
              bufferDataByteSize = bufferData.length * 4;
            } else {
              bufferDataByteSize = bufferData.byteLength;
            }
            numElements = bufferDataByteSize / byteStride;
          }
          const copy = GetTypedArrayData(bufferData, size, type, byteOffset, byteStride, numElements, true);
          const newVb = new VertexBuffer(this._engine, copy, kind, {
            updatable: isUpdatable,
            useBytes: false,
            stride: size,
            // Copy is tightly-packed, so stride = size
            size,
            // Component size stays the same
            offset: 0,
            // Copy starts at beginning of its own buffer
            type,
            normalized,
            takeBufferOwnership: true,
            instanced: vb.getIsInstanced()
          });
          geometry.setVerticesBuffer(newVb, numElements);
        }
        geometry._updatable = updatable;
        geometry.delayLoadState = this.delayLoadState;
        geometry.delayLoadingFile = this.delayLoadingFile;
        geometry._delayLoadingFunction = this._delayLoadingFunction;
        for (kind in this._delayInfo) {
          geometry._delayInfo = geometry._delayInfo || [];
          geometry._delayInfo.push(kind);
        }
        geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);
        return geometry;
      }
      /**
       * Serialize the current geometry info (and not the vertices data) into a JSON object
       * @returns a JSON representation of the current geometry data (without the vertices data)
       */
      serialize() {
        const serializationObject = {};
        serializationObject.id = this.id;
        serializationObject.uniqueId = this.uniqueId;
        serializationObject.updatable = this._updatable;
        if (Tags && Tags.HasTags(this)) {
          serializationObject.tags = Tags.GetTags(this);
        }
        return serializationObject;
      }
      _toNumberArray(origin) {
        if (Array.isArray(origin)) {
          return origin;
        } else {
          return Array.prototype.slice.call(origin);
        }
      }
      /**
       * Release any memory retained by the cached data on the Geometry.
       *
       * Call this function to reduce memory footprint of the mesh.
       * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)
       */
      clearCachedData() {
        this._totalIndices = this._indices.length;
        this._indices = [];
        this._resetPointsArrayCache();
        for (const vbName in this._vertexBuffers) {
          if (!Object.prototype.hasOwnProperty.call(this._vertexBuffers, vbName)) {
            continue;
          }
          this._vertexBuffers[vbName]._buffer._data = null;
        }
      }
      /**
       * Serialize all vertices data into a JSON object
       * @returns a JSON representation of the current geometry data
       */
      serializeVerticeData() {
        const serializationObject = this.serialize();
        if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
          serializationObject.positions = this._toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {
            serializationObject.positionsUpdatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          serializationObject.normals = this._toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {
            serializationObject.normalsUpdatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {
          serializationObject.tangents = this._toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {
            serializationObject.tangentsUpdatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {
          serializationObject.uvs = this._toNumberArray(this.getVerticesData(VertexBuffer.UVKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {
            serializationObject.uvsUpdatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
          serializationObject.uvs2 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {
            serializationObject.uvs2Updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {
          serializationObject.uvs3 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {
            serializationObject.uvs3Updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {
          serializationObject.uvs4 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {
            serializationObject.uvs4Updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {
          serializationObject.uvs5 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {
            serializationObject.uvs5Updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {
          serializationObject.uvs6 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {
            serializationObject.uvs6Updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {
          serializationObject.colors = this._toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {
            serializationObject.colorsUpdatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
          serializationObject.matricesIndices = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));
          serializationObject.matricesIndicesExpanded = true;
          if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {
            serializationObject.matricesIndicesUpdatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
          serializationObject.matricesWeights = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {
            serializationObject.matricesWeightsUpdatable = true;
          }
        }
        serializationObject.indices = this._toNumberArray(this.getIndices());
        return serializationObject;
      }
      // Statics
      /**
       * Extracts a clone of a mesh geometry
       * @param mesh defines the source mesh
       * @param id defines the unique ID of the new geometry object
       * @returns the new geometry object
       */
      static ExtractFromMesh(mesh, id) {
        const geometry = mesh._geometry;
        if (!geometry) {
          return null;
        }
        return geometry.copy(id);
      }
      /**
       * You should now use Tools.RandomId(), this method is still here for legacy reasons.
       * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
       * Be aware Math.random() could cause collisions, but:
       * "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
       * @returns a string containing a new GUID
       */
      static RandomId() {
        return Tools.RandomId();
      }
      static _GetGeometryByLoadedUniqueId(uniqueId, scene) {
        for (let index = 0; index < scene.geometries.length; index++) {
          if (scene.geometries[index]._loadedUniqueId === uniqueId) {
            return scene.geometries[index];
          }
        }
        return null;
      }
      /**
       * @internal
       */
      static _ImportGeometry(parsedGeometry, mesh) {
        const scene = mesh.getScene();
        const geometryUniqueId = parsedGeometry.geometryUniqueId;
        const geometryId = parsedGeometry.geometryId;
        if (geometryUniqueId || geometryId) {
          const geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);
          if (geometry) {
            geometry.applyToMesh(mesh);
          }
        } else if (parsedGeometry instanceof ArrayBuffer) {
          const binaryInfo = mesh._binaryInfo;
          if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {
            const positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);
            mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);
          }
          if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {
            const normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);
            mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);
          }
          if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {
            const tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);
            mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);
          }
          if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {
            const uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);
            if (useOpenGLOrientationForUV) {
              for (let index = 1; index < uvsData.length; index += 2) {
                uvsData[index] = 1 - uvsData[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);
          }
          if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {
            const uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);
            if (useOpenGLOrientationForUV) {
              for (let index = 1; index < uvs2Data.length; index += 2) {
                uvs2Data[index] = 1 - uvs2Data[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);
          }
          if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {
            const uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);
            if (useOpenGLOrientationForUV) {
              for (let index = 1; index < uvs3Data.length; index += 2) {
                uvs3Data[index] = 1 - uvs3Data[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);
          }
          if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {
            const uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);
            if (useOpenGLOrientationForUV) {
              for (let index = 1; index < uvs4Data.length; index += 2) {
                uvs4Data[index] = 1 - uvs4Data[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);
          }
          if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {
            const uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);
            if (useOpenGLOrientationForUV) {
              for (let index = 1; index < uvs5Data.length; index += 2) {
                uvs5Data[index] = 1 - uvs5Data[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);
          }
          if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {
            const uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);
            if (useOpenGLOrientationForUV) {
              for (let index = 1; index < uvs6Data.length; index += 2) {
                uvs6Data[index] = 1 - uvs6Data[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);
          }
          if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {
            const colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);
            mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);
          }
          if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {
            const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);
            const floatIndices = [];
            for (let i = 0; i < matricesIndicesData.length; i++) {
              const index = matricesIndicesData[i];
              floatIndices.push(index & 255);
              floatIndices.push((index & 65280) >> 8);
              floatIndices.push((index & 16711680) >> 16);
              floatIndices.push(index >> 24 & 255);
            }
            mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);
          }
          if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {
            const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);
            const floatIndices = [];
            for (let i = 0; i < matricesIndicesData.length; i++) {
              const index = matricesIndicesData[i];
              floatIndices.push(index & 255);
              floatIndices.push((index & 65280) >> 8);
              floatIndices.push((index & 16711680) >> 16);
              floatIndices.push(index >> 24 & 255);
            }
            mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);
          }
          if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {
            const matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);
            mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);
          }
          if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {
            const indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);
            mesh.setIndices(indicesData, null);
          }
          if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {
            const subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);
            mesh.subMeshes = [];
            for (let i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {
              const materialIndex = subMeshesData[i * 5 + 0];
              const verticesStart = subMeshesData[i * 5 + 1];
              const verticesCount = subMeshesData[i * 5 + 2];
              const indexStart = subMeshesData[i * 5 + 3];
              const indexCount = subMeshesData[i * 5 + 4];
              SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);
            }
          }
        } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {
          mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable || parsedGeometry.positionsUpdatable);
          mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable || parsedGeometry.normalsUpdatable);
          if (parsedGeometry.tangents) {
            mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable || parsedGeometry.tangentsUpdatable);
          }
          if (parsedGeometry.uvs) {
            mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable || parsedGeometry.uvsUpdatable);
          }
          if (parsedGeometry.uvs2) {
            mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable || parsedGeometry.uvs2Updatable);
          }
          if (parsedGeometry.uvs3) {
            mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable || parsedGeometry.uvs3Updatable);
          }
          if (parsedGeometry.uvs4) {
            mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable || parsedGeometry.uvs4Updatable);
          }
          if (parsedGeometry.uvs5) {
            mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable || parsedGeometry.uvs5Updatable);
          }
          if (parsedGeometry.uvs6) {
            mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable || parsedGeometry.uvs6Updatable);
          }
          if (parsedGeometry.colors) {
            mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);
          }
          if (parsedGeometry.matricesIndices) {
            if (!parsedGeometry.matricesIndices._isExpanded && !parsedGeometry.matricesIndicesExpanded) {
              const floatIndices = [];
              for (let i = 0; i < parsedGeometry.matricesIndices.length; i++) {
                const matricesIndex = parsedGeometry.matricesIndices[i];
                floatIndices.push(matricesIndex & 255);
                floatIndices.push((matricesIndex & 65280) >> 8);
                floatIndices.push((matricesIndex & 16711680) >> 16);
                floatIndices.push(matricesIndex >> 24 & 255);
              }
              mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable || parsedGeometry.matricesIndicesUpdatable);
            } else {
              delete parsedGeometry.matricesIndices._isExpanded;
              delete parsedGeometry.matricesIndicesExpanded;
              mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable || parsedGeometry.matricesIndicesUpdatable);
            }
          }
          if (parsedGeometry.matricesIndicesExtra) {
            if (!(parsedGeometry.matricesIndicesExtraExpanded || parsedGeometry.matricesIndicesExtra._isExpanded)) {
              const floatIndices = [];
              for (let i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {
                const matricesIndex = parsedGeometry.matricesIndicesExtra[i];
                floatIndices.push(matricesIndex & 255);
                floatIndices.push((matricesIndex & 65280) >> 8);
                floatIndices.push((matricesIndex & 16711680) >> 16);
                floatIndices.push(matricesIndex >> 24 & 255);
              }
              mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable || parsedGeometry.matricesIndicesExtraUpdatable);
            } else {
              delete parsedGeometry.matricesIndices._isExpanded;
              delete parsedGeometry.matricesIndicesExtraExpanded;
              mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable || parsedGeometry.matricesIndicesExtraUpdatable);
            }
          }
          if (parsedGeometry.matricesWeights) {
            _Geometry._CleanMatricesWeights(parsedGeometry, mesh);
            mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);
          }
          if (parsedGeometry.matricesWeightsExtra) {
            mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);
          }
          mesh.setIndices(parsedGeometry.indices, null);
        }
        if (parsedGeometry.subMeshes) {
          mesh.subMeshes = [];
          for (let subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {
            const parsedSubMesh = parsedGeometry.subMeshes[subIndex];
            SubMesh.AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);
          }
        }
        if (mesh._shouldGenerateFlatShading) {
          mesh.convertToFlatShadedMesh();
          mesh._shouldGenerateFlatShading = false;
        }
        mesh.computeWorldMatrix(true);
        scene.onMeshImportedObservable.notifyObservers(mesh);
      }
      static _CleanMatricesWeights(parsedGeometry, mesh) {
        const epsilon = 1e-3;
        if (!SceneLoaderFlags.CleanBoneMatrixWeights) {
          return;
        }
        let noInfluenceBoneIndex = 0;
        if (parsedGeometry.skeletonId > -1) {
          const skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);
          if (!skeleton) {
            return;
          }
          noInfluenceBoneIndex = skeleton.bones.length;
        } else {
          return;
        }
        const matricesIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);
        const matricesIndicesExtra = mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);
        const matricesWeights = parsedGeometry.matricesWeights;
        const matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;
        const influencers = parsedGeometry.numBoneInfluencer;
        const size = matricesWeights.length;
        for (let i = 0; i < size; i += 4) {
          let weight = 0;
          let firstZeroWeight = -1;
          for (let j = 0; j < 4; j++) {
            const w = matricesWeights[i + j];
            weight += w;
            if (w < epsilon && firstZeroWeight < 0) {
              firstZeroWeight = j;
            }
          }
          if (matricesWeightsExtra) {
            for (let j = 0; j < 4; j++) {
              const w = matricesWeightsExtra[i + j];
              weight += w;
              if (w < epsilon && firstZeroWeight < 0) {
                firstZeroWeight = j + 4;
              }
            }
          }
          if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {
            firstZeroWeight = influencers - 1;
          }
          if (weight > epsilon) {
            const mweight = 1 / weight;
            for (let j = 0; j < 4; j++) {
              matricesWeights[i + j] *= mweight;
            }
            if (matricesWeightsExtra) {
              for (let j = 0; j < 4; j++) {
                matricesWeightsExtra[i + j] *= mweight;
              }
            }
          } else {
            if (firstZeroWeight >= 4) {
              matricesWeightsExtra[i + firstZeroWeight - 4] = 1 - weight;
              matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;
            } else {
              matricesWeights[i + firstZeroWeight] = 1 - weight;
              matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;
            }
          }
        }
        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);
        if (parsedGeometry.matricesWeightsExtra) {
          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);
        }
      }
      /**
       * Create a new geometry from persisted data (Using .babylon file format)
       * @param parsedVertexData defines the persisted data
       * @param scene defines the hosting scene
       * @param rootUrl defines the root url to use to load assets (like delayed data)
       * @returns the new geometry object
       */
      static Parse(parsedVertexData, scene, rootUrl) {
        const geometry = new _Geometry(parsedVertexData.id, scene, void 0, parsedVertexData.updatable);
        geometry._loadedUniqueId = parsedVertexData.uniqueId;
        if (Tags) {
          Tags.AddTagsTo(geometry, parsedVertexData.tags);
        }
        if (parsedVertexData.delayLoadingFile) {
          geometry.delayLoadState = 4;
          geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;
          geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));
          geometry._delayInfo = [];
          if (parsedVertexData.hasUVs) {
            geometry._delayInfo.push(VertexBuffer.UVKind);
          }
          if (parsedVertexData.hasUVs2) {
            geometry._delayInfo.push(VertexBuffer.UV2Kind);
          }
          if (parsedVertexData.hasUVs3) {
            geometry._delayInfo.push(VertexBuffer.UV3Kind);
          }
          if (parsedVertexData.hasUVs4) {
            geometry._delayInfo.push(VertexBuffer.UV4Kind);
          }
          if (parsedVertexData.hasUVs5) {
            geometry._delayInfo.push(VertexBuffer.UV5Kind);
          }
          if (parsedVertexData.hasUVs6) {
            geometry._delayInfo.push(VertexBuffer.UV6Kind);
          }
          if (parsedVertexData.hasColors) {
            geometry._delayInfo.push(VertexBuffer.ColorKind);
          }
          if (parsedVertexData.hasMatricesIndices) {
            geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);
          }
          if (parsedVertexData.hasMatricesWeights) {
            geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);
          }
          geometry._delayLoadingFunction = VertexData.ImportVertexData;
        } else {
          VertexData.ImportVertexData(parsedVertexData, geometry);
        }
        scene.pushGeometry(geometry, true);
        return geometry;
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/multiMaterial.js
var MultiMaterial;
var init_multiMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/multiMaterial.js"() {
    init_material();
    init_tags();
    init_typeStore();
    MultiMaterial = class _MultiMaterial extends Material {
      /**
       * Gets or Sets the list of Materials used within the multi material.
       * They need to be ordered according to the submeshes order in the associated mesh
       */
      get subMaterials() {
        return this._subMaterials;
      }
      set subMaterials(value) {
        this._subMaterials = value;
        this._hookArray(value);
      }
      /**
       * Function used to align with Node.getChildren()
       * @returns the list of Materials used within the multi material
       */
      getChildren() {
        return this.subMaterials;
      }
      /**
       * Instantiates a new Multi Material
       * A multi-material is used to apply different materials to different parts of the same object without the need of
       * separate meshes. This can be use to improve performances.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/multiMaterials
       * @param name Define the name in the scene
       * @param scene Define the scene the material belongs to
       */
      constructor(name, scene) {
        super(name, scene, true);
        this._waitingSubMaterialsUniqueIds = [];
        this.getScene().addMultiMaterial(this);
        this.subMaterials = [];
        this._storeEffectOnSubMeshes = true;
      }
      _hookArray(array) {
        const oldPush = array.push;
        array.push = (...items) => {
          const result = oldPush.apply(array, items);
          this._markAllSubMeshesAsTexturesDirty();
          return result;
        };
        const oldSplice = array.splice;
        array.splice = (index, deleteCount) => {
          const deleted = oldSplice.apply(array, [index, deleteCount]);
          this._markAllSubMeshesAsTexturesDirty();
          return deleted;
        };
      }
      /**
       * Get one of the submaterial by its index in the submaterials array
       * @param index The index to look the sub material at
       * @returns The Material if the index has been defined
       */
      getSubMaterial(index) {
        if (index < 0 || index >= this.subMaterials.length) {
          return this.getScene().defaultMaterial;
        }
        return this.subMaterials[index];
      }
      /**
       * Get the list of active textures for the whole sub materials list.
       * @returns All the textures that will be used during the rendering
       */
      getActiveTextures() {
        return super.getActiveTextures().concat(...this.subMaterials.map((subMaterial) => {
          if (subMaterial) {
            return subMaterial.getActiveTextures();
          } else {
            return [];
          }
        }));
      }
      /**
       * Specifies if any sub-materials of this multi-material use a given texture.
       * @param texture Defines the texture to check against this multi-material's sub-materials.
       * @returns A boolean specifying if any sub-material of this multi-material uses the texture.
       */
      hasTexture(texture) {
        if (super.hasTexture(texture)) {
          return true;
        }
        for (let i = 0; i < this.subMaterials.length; i++) {
          if (this.subMaterials[i]?.hasTexture(texture)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Gets the current class name of the material e.g. "MultiMaterial"
       * Mainly use in serialization.
       * @returns the class name
       */
      getClassName() {
        return "MultiMaterial";
      }
      /**
       * Checks if the material is ready to render the requested sub mesh
       * @param mesh Define the mesh the submesh belongs to
       * @param subMesh Define the sub mesh to look readiness for
       * @param useInstances Define whether or not the material is used with instances
       * @returns true if ready, otherwise false
       */
      isReadyForSubMesh(mesh, subMesh, useInstances) {
        for (let index = 0; index < this.subMaterials.length; index++) {
          const subMaterial = this.subMaterials[index];
          if (subMaterial) {
            if (subMaterial._storeEffectOnSubMeshes) {
              if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {
                return false;
              }
              continue;
            }
            if (!subMaterial.isReady(mesh)) {
              return false;
            }
          }
        }
        return true;
      }
      /**
       * Clones the current material and its related sub materials
       * @param name Define the name of the newly cloned material
       * @param cloneChildren Define if submaterial will be cloned or shared with the parent instance
       * @returns the cloned material
       */
      clone(name, cloneChildren) {
        const newMultiMaterial = new _MultiMaterial(name, this.getScene());
        for (let index = 0; index < this.subMaterials.length; index++) {
          let subMaterial = null;
          const current = this.subMaterials[index];
          if (cloneChildren && current) {
            subMaterial = current.clone(name + "-" + current.name);
          } else {
            subMaterial = this.subMaterials[index];
          }
          newMultiMaterial.subMaterials.push(subMaterial);
        }
        return newMultiMaterial;
      }
      /**
       * Serializes the materials into a JSON representation.
       * @returns the JSON representation
       */
      serialize() {
        const serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.id = this.id;
        serializationObject.uniqueId = this.uniqueId;
        if (Tags) {
          serializationObject.tags = Tags.GetTags(this);
        }
        serializationObject.materialsUniqueIds = [];
        serializationObject.materials = [];
        for (let matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {
          const subMat = this.subMaterials[matIndex];
          if (subMat) {
            serializationObject.materialsUniqueIds.push(subMat.uniqueId);
            serializationObject.materials.push(subMat.id);
          } else {
            serializationObject.materialsUniqueIds.push(null);
            serializationObject.materials.push(null);
          }
        }
        return serializationObject;
      }
      /**
       * Dispose the material and release its associated resources
       * @param forceDisposeEffect Define if we want to force disposing the associated effect (if false the shader is not released and could be reuse later on)
       * @param forceDisposeTextures Define if we want to force disposing the associated textures (if false, they will not be disposed and can still be use elsewhere in the app)
       * @param forceDisposeChildren Define if we want to force disposing the associated submaterials (if false, they will not be disposed and can still be use elsewhere in the app)
       */
      dispose(forceDisposeEffect, forceDisposeTextures, forceDisposeChildren) {
        const scene = this.getScene();
        if (!scene) {
          return;
        }
        if (forceDisposeChildren) {
          for (let index2 = 0; index2 < this.subMaterials.length; index2++) {
            const subMaterial = this.subMaterials[index2];
            if (subMaterial) {
              subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);
            }
          }
        }
        const index = scene.multiMaterials.indexOf(this);
        if (index >= 0) {
          scene.multiMaterials.splice(index, 1);
        }
        super.dispose(forceDisposeEffect, forceDisposeTextures);
      }
      /**
       * Creates a MultiMaterial from parsed MultiMaterial data.
       * @param parsedMultiMaterial defines parsed MultiMaterial data.
       * @param scene defines the hosting scene
       * @returns a new MultiMaterial
       */
      static ParseMultiMaterial(parsedMultiMaterial, scene) {
        const multiMaterial = new _MultiMaterial(parsedMultiMaterial.name, scene);
        multiMaterial.id = parsedMultiMaterial.id;
        multiMaterial._loadedUniqueId = parsedMultiMaterial.uniqueId;
        if (Tags) {
          Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);
        }
        if (parsedMultiMaterial.materialsUniqueIds) {
          multiMaterial._waitingSubMaterialsUniqueIds = parsedMultiMaterial.materialsUniqueIds;
        } else {
          for (const subMatId of parsedMultiMaterial.materials) {
            multiMaterial.subMaterials.push(scene.getLastMaterialById(subMatId));
          }
        }
        return multiMaterial;
      }
    };
    RegisterClass("BABYLON.MultiMaterial", MultiMaterial);
  }
});

// node_modules/@babylonjs/core/Meshes/meshLODLevel.js
var MeshLODLevel;
var init_meshLODLevel = __esm({
  "node_modules/@babylonjs/core/Meshes/meshLODLevel.js"() {
    MeshLODLevel = class {
      /**
       * Creates a new LOD level
       * @param distanceOrScreenCoverage defines either the distance or the screen coverage where this level should start being displayed
       * @param mesh defines the mesh to use to render this level
       */
      constructor(distanceOrScreenCoverage, mesh) {
        this.distanceOrScreenCoverage = distanceOrScreenCoverage;
        this.mesh = mesh;
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/mesh.js
var _CreationDataStorage, _InstanceDataStorageRenderPass, _InstanceDataStorage, _InstancesBatch, _ThinInstanceDataStorage, _InternalMeshDataInfo, MeshCreationOptions, Mesh;
var init_mesh = __esm({
  "node_modules/@babylonjs/core/Meshes/mesh.js"() {
    init_observable();
    init_tools();
    init_deepCopier();
    init_tags();
    init_coroutine();
    init_camera();
    init_math_vector();
    init_math_color();
    init_node();
    init_buffer();
    init_mesh_vertexData();
    init_geometry();
    init_abstractMesh();
    init_subMesh();
    init_material();
    init_multiMaterial();
    init_sceneLoaderFlags();
    init_decorators_serialization();
    init_logger();
    init_typeStore();
    init_devTools();
    init_sceneComponent();
    init_meshLODLevel();
    _CreationDataStorage = class {
    };
    _InstanceDataStorageRenderPass = class {
      constructor() {
        this.batchCache = new _InstancesBatch(this);
        this.batchCacheReplacementModeInFrozenMode = new _InstancesBatch(this);
        this.instancesBufferSize = 32 * 16 * 4;
      }
    };
    _InstanceDataStorage = class {
      constructor() {
        this.renderPasses = {};
      }
    };
    _InstancesBatch = class {
      constructor(parent) {
        this.parent = parent;
        this.mustReturn = false;
        this.visibleInstances = new Array();
        this.renderSelf = [];
        this.hardwareInstancedRendering = [];
      }
    };
    _ThinInstanceDataStorage = class {
      constructor() {
        this.instancesCount = 0;
        this.matrixBuffer = null;
        this.previousMatrixBuffer = null;
        this.matrixBufferSize = 32 * 16;
        this.matrixData = null;
        this.boundingVectors = [];
        this.worldMatrices = null;
      }
    };
    _InternalMeshDataInfo = class {
      constructor() {
        this._areNormalsFrozen = false;
        this._source = null;
        this.meshMap = null;
        this._preActivateId = -1;
        this._LODLevels = new Array();
        this._useLODScreenCoverage = false;
        this._effectiveMaterial = null;
        this._forcedInstanceCount = 0;
        this._overrideRenderingFillMode = null;
      }
    };
    MeshCreationOptions = {
      source: null,
      parent: null,
      doNotCloneChildren: false,
      clonePhysicsImpostor: true,
      cloneThinInstances: false
    };
    Mesh = class _Mesh extends AbstractMesh {
      /**
       * Gets the default side orientation.
       * @param orientation the orientation to value to attempt to get
       * @returns the default orientation
       * @internal
       */
      static _GetDefaultSideOrientation(orientation) {
        return orientation || _Mesh.FRONTSIDE;
      }
      /**
       * Determines if the LOD levels are intended to be calculated using screen coverage (surface area ratio) instead of distance.
       */
      get useLODScreenCoverage() {
        return this._internalMeshDataInfo._useLODScreenCoverage;
      }
      set useLODScreenCoverage(value) {
        this._internalMeshDataInfo._useLODScreenCoverage = value;
        this._sortLODLevels();
      }
      get computeBonesUsingShaders() {
        return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
      }
      set computeBonesUsingShaders(value) {
        if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {
          return;
        }
        if (value && this._internalMeshDataInfo._sourcePositions) {
          this.setVerticesData(VertexBuffer.PositionKind, this._internalMeshDataInfo._sourcePositions, true);
          if (this._internalMeshDataInfo._sourceNormals) {
            this.setVerticesData(VertexBuffer.NormalKind, this._internalMeshDataInfo._sourceNormals, true);
          }
          this._internalMeshDataInfo._sourcePositions = null;
          this._internalMeshDataInfo._sourceNormals = null;
        }
        this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;
        this._markSubMeshesAsAttributesDirty();
      }
      /**
       * An event triggered before rendering the mesh
       */
      get onBeforeRenderObservable() {
        if (!this._internalMeshDataInfo._onBeforeRenderObservable) {
          this._internalMeshDataInfo._onBeforeRenderObservable = new Observable();
        }
        return this._internalMeshDataInfo._onBeforeRenderObservable;
      }
      /**
       * An event triggered before binding the mesh
       */
      get onBeforeBindObservable() {
        if (!this._internalMeshDataInfo._onBeforeBindObservable) {
          this._internalMeshDataInfo._onBeforeBindObservable = new Observable();
        }
        return this._internalMeshDataInfo._onBeforeBindObservable;
      }
      /**
       * An event triggered after rendering the mesh
       */
      get onAfterRenderObservable() {
        if (!this._internalMeshDataInfo._onAfterRenderObservable) {
          this._internalMeshDataInfo._onAfterRenderObservable = new Observable();
        }
        return this._internalMeshDataInfo._onAfterRenderObservable;
      }
      /**
       * An event triggeredbetween rendering pass when using separateCullingPass = true
       */
      get onBetweenPassObservable() {
        if (!this._internalMeshDataInfo._onBetweenPassObservable) {
          this._internalMeshDataInfo._onBetweenPassObservable = new Observable();
        }
        return this._internalMeshDataInfo._onBetweenPassObservable;
      }
      /**
       * An event triggered before drawing the mesh
       */
      get onBeforeDrawObservable() {
        if (!this._internalMeshDataInfo._onBeforeDrawObservable) {
          this._internalMeshDataInfo._onBeforeDrawObservable = new Observable();
        }
        return this._internalMeshDataInfo._onBeforeDrawObservable;
      }
      /**
       * Sets a callback to call before drawing the mesh. It is recommended to use onBeforeDrawObservable instead
       */
      set onBeforeDraw(callback) {
        if (this._onBeforeDrawObserver) {
          this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver);
        }
        this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(callback);
      }
      get hasInstances() {
        return this.instances.length > 0;
      }
      get hasThinInstances() {
        return (this.forcedInstanceCount || this._thinInstanceDataStorage.instancesCount || 0) > 0;
      }
      /**
       * Gets or sets the forced number of instances to display.
       * If 0 (default value), the number of instances is not forced and depends on the draw type
       * (regular / instance / thin instances mesh)
       */
      get forcedInstanceCount() {
        return this._internalMeshDataInfo._forcedInstanceCount;
      }
      set forcedInstanceCount(count) {
        this._internalMeshDataInfo._forcedInstanceCount = count;
      }
      /**
       * Use this property to change the original side orientation defined at construction time
       * Material.sideOrientation will override this value if set
       * User will still be able to change the material sideOrientation afterwards if they really need it
       */
      get sideOrientation() {
        return this._internalMeshDataInfo._sideOrientation;
      }
      set sideOrientation(value) {
        this._internalMeshDataInfo._sideOrientation = value;
        this._internalAbstractMeshDataInfo._sideOrientationHint = this._scene.useRightHandedSystem && value === 1 || !this._scene.useRightHandedSystem && value === 0;
      }
      /** @internal */
      get _effectiveSideOrientation() {
        return this._internalMeshDataInfo._effectiveSideOrientation;
      }
      /**
       * @deprecated Please use sideOrientation instead.
       * @see https://doc.babylonjs.com/breaking-changes#7110
       */
      get overrideMaterialSideOrientation() {
        return this.sideOrientation;
      }
      set overrideMaterialSideOrientation(value) {
        this.sideOrientation = value;
        if (this.material) {
          this.material.sideOrientation = null;
        }
      }
      /**
       * Use this property to override the Material's fillMode value
       */
      get overrideRenderingFillMode() {
        return this._internalMeshDataInfo._overrideRenderingFillMode;
      }
      set overrideRenderingFillMode(fillMode) {
        this._internalMeshDataInfo._overrideRenderingFillMode = fillMode;
      }
      get material() {
        return this._internalAbstractMeshDataInfo._material;
      }
      set material(value) {
        if (value && (this.material && this.material.sideOrientation === null || this._internalAbstractMeshDataInfo._sideOrientationHint)) {
          value.sideOrientation = null;
        }
        this._setMaterial(value);
      }
      /**
       * Gets the source mesh (the one used to clone this one from)
       */
      get source() {
        return this._internalMeshDataInfo._source;
      }
      /**
       * Gets the list of clones of this mesh
       * The scene must have been constructed with useClonedMeshMap=true for this to work!
       * Note that useClonedMeshMap=true is the default setting
       */
      get cloneMeshMap() {
        return this._internalMeshDataInfo.meshMap;
      }
      /**
       * Gets or sets a boolean indicating that this mesh does not use index buffer
       */
      get isUnIndexed() {
        return this._unIndexed;
      }
      set isUnIndexed(value) {
        if (this._unIndexed !== value) {
          this._unIndexed = value;
          this._markSubMeshesAsAttributesDirty();
        }
      }
      /** Gets the array buffer used to store the instanced buffer used for instances' world matrices */
      get worldMatrixInstancedBuffer() {
        const instanceDataStorage = this._instanceDataStorage.renderPasses[this._instanceDataStorage.engine.isWebGPU ? this._instanceDataStorage.engine.currentRenderPassId : 0];
        return instanceDataStorage ? instanceDataStorage.instancesData : void 0;
      }
      /** Gets the array buffer used to store the instanced buffer used for instances' previous world matrices */
      get previousWorldMatrixInstancedBuffer() {
        const instanceDataStorage = this._instanceDataStorage.renderPasses[this._instanceDataStorage.engine.isWebGPU ? this._instanceDataStorage.engine.currentRenderPassId : 0];
        return instanceDataStorage ? instanceDataStorage.instancesPreviousData : void 0;
      }
      /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */
      get manualUpdateOfWorldMatrixInstancedBuffer() {
        return this._instanceDataStorage.manualUpdate;
      }
      set manualUpdateOfWorldMatrixInstancedBuffer(value) {
        this._instanceDataStorage.manualUpdate = value;
      }
      /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */
      get manualUpdateOfPreviousWorldMatrixInstancedBuffer() {
        return this._instanceDataStorage.previousManualUpdate;
      }
      set manualUpdateOfPreviousWorldMatrixInstancedBuffer(value) {
        this._instanceDataStorage.previousManualUpdate = value;
      }
      /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices must be performed in all cases (and notably even in frozen mode) */
      get forceWorldMatrixInstancedBufferUpdate() {
        return this._instanceDataStorage.forceMatrixUpdates;
      }
      set forceWorldMatrixInstancedBufferUpdate(value) {
        this._instanceDataStorage.forceMatrixUpdates = value;
      }
      _copySource(source, doNotCloneChildren, clonePhysicsImpostor = true, cloneThinInstances = false) {
        const scene = this.getScene();
        if (source._geometry) {
          source._geometry.applyToMesh(this);
        }
        DeepCopier.DeepCopy(source, this, [
          "name",
          "material",
          "skeleton",
          "instances",
          "parent",
          "uniqueId",
          "source",
          "metadata",
          "morphTargetManager",
          "hasInstances",
          "worldMatrixInstancedBuffer",
          "previousWorldMatrixInstancedBuffer",
          "hasLODLevels",
          "geometry",
          "isBlocked",
          "areNormalsFrozen",
          "facetNb",
          "isFacetDataEnabled",
          "lightSources",
          "useBones",
          "isAnInstance",
          "collider",
          "edgesRenderer",
          "forward",
          "up",
          "right",
          "absolutePosition",
          "absoluteScaling",
          "absoluteRotationQuaternion",
          "isWorldMatrixFrozen",
          "nonUniformScaling",
          "behaviors",
          "worldMatrixFromCache",
          "hasThinInstances",
          "cloneMeshMap",
          "hasBoundingInfo",
          "physicsBody",
          "physicsImpostor"
        ], ["_poseMatrix"]);
        this._internalMeshDataInfo._source = source;
        if (scene.useClonedMeshMap) {
          if (!source._internalMeshDataInfo.meshMap) {
            source._internalMeshDataInfo.meshMap = {};
          }
          source._internalMeshDataInfo.meshMap[this.uniqueId] = this;
        }
        this._originalBuilderSideOrientation = source._originalBuilderSideOrientation;
        this._creationDataStorage = source._creationDataStorage;
        if (source._ranges) {
          const ranges = source._ranges;
          for (const name in ranges) {
            if (!Object.prototype.hasOwnProperty.call(ranges, name)) {
              continue;
            }
            if (!ranges[name]) {
              continue;
            }
            this.createAnimationRange(name, ranges[name].from, ranges[name].to);
          }
        }
        if (source.metadata && source.metadata.clone) {
          this.metadata = source.metadata.clone();
        } else {
          this.metadata = source.metadata;
        }
        this._internalMetadata = source._internalMetadata;
        if (Tags && Tags.HasTags(source)) {
          Tags.AddTagsTo(this, Tags.GetTags(source, true));
        }
        this.setEnabled(source.isEnabled(false));
        this.parent = source.parent;
        this.setPivotMatrix(source.getPivotMatrix(), this._postMultiplyPivotMatrix);
        this.id = this.name + "." + source.id;
        this.material = source.material;
        if (!doNotCloneChildren) {
          const directDescendants = source.getDescendants(true);
          for (let index = 0; index < directDescendants.length; index++) {
            const child = directDescendants[index];
            if (child._isMesh) {
              MeshCreationOptions.parent = this;
              MeshCreationOptions.doNotCloneChildren = doNotCloneChildren;
              MeshCreationOptions.clonePhysicsImpostor = clonePhysicsImpostor;
              MeshCreationOptions.cloneThinInstances = cloneThinInstances;
              child.clone(this.name + "." + child.name, MeshCreationOptions);
            } else if (child.clone) {
              child.clone(this.name + "." + child.name, this);
            }
          }
        }
        if (source.morphTargetManager) {
          this.morphTargetManager = source.morphTargetManager;
        }
        if (scene.getPhysicsEngine) {
          const physicsEngine = scene.getPhysicsEngine();
          if (clonePhysicsImpostor && physicsEngine) {
            if (physicsEngine.getPluginVersion() === 1) {
              const impostor = physicsEngine.getImpostorForPhysicsObject(source);
              if (impostor) {
                this.physicsImpostor = impostor.clone(this);
              }
            } else if (physicsEngine.getPluginVersion() === 2) {
              if (source.physicsBody) {
                source.physicsBody.clone(this);
              }
            }
          }
        }
        for (let index = 0; index < scene.particleSystems.length; index++) {
          const system = scene.particleSystems[index];
          if (system.emitter === source) {
            system.clone(system.name, this);
          }
        }
        this.skeleton = source.skeleton;
        if (cloneThinInstances) {
          if (source._thinInstanceDataStorage.matrixData) {
            this.thinInstanceSetBuffer("matrix", new Float32Array(source._thinInstanceDataStorage.matrixData), 16, !source._thinInstanceDataStorage.matrixBuffer.isUpdatable());
            this._thinInstanceDataStorage.matrixBufferSize = source._thinInstanceDataStorage.matrixBufferSize;
            this._thinInstanceDataStorage.instancesCount = source._thinInstanceDataStorage.instancesCount;
          } else {
            this._thinInstanceDataStorage.matrixBufferSize = source._thinInstanceDataStorage.matrixBufferSize;
          }
          if (source._userThinInstanceBuffersStorage) {
            const userThinInstance = source._userThinInstanceBuffersStorage;
            for (const kind in userThinInstance.data) {
              this.thinInstanceSetBuffer(kind, new Float32Array(userThinInstance.data[kind]), userThinInstance.strides[kind], !userThinInstance.vertexBuffers?.[kind]?.isUpdatable());
              this._userThinInstanceBuffersStorage.sizes[kind] = userThinInstance.sizes[kind];
            }
          }
        }
        this.refreshBoundingInfo(true, true);
        this.computeWorldMatrix(true);
      }
      /** @internal */
      constructor(name, scene = null, parentOrOptions = null, source = null, doNotCloneChildren, clonePhysicsImpostor = true) {
        super(name, scene);
        this._internalMeshDataInfo = new _InternalMeshDataInfo();
        this.delayLoadState = 0;
        this.instances = [];
        this._creationDataStorage = null;
        this._geometry = null;
        this._thinInstanceDataStorage = new _ThinInstanceDataStorage();
        this._shouldGenerateFlatShading = false;
        this._originalBuilderSideOrientation = _Mesh.DEFAULTSIDE;
        this.ignoreCameraMaxZ = false;
        scene = this.getScene();
        this._instanceDataStorage = new _InstanceDataStorage();
        this._instanceDataStorage.engine = scene.getEngine();
        if (this._scene.useRightHandedSystem) {
          this.sideOrientation = 0;
        } else {
          this.sideOrientation = 1;
        }
        this._onBeforeDraw = (isInstance, world, effectiveMaterial) => {
          if (isInstance && effectiveMaterial) {
            if (this._uniformBuffer) {
              this.transferToEffect(world);
            } else {
              effectiveMaterial.bindOnlyWorldMatrix(world);
            }
          }
        };
        let parent = null;
        let cloneThinInstances = false;
        if (parentOrOptions && parentOrOptions._addToSceneRootNodes === void 0) {
          const options = parentOrOptions;
          parent = options.parent ?? null;
          source = options.source ?? null;
          doNotCloneChildren = options.doNotCloneChildren ?? false;
          clonePhysicsImpostor = options.clonePhysicsImpostor ?? true;
          cloneThinInstances = options.cloneThinInstances ?? false;
        } else {
          parent = parentOrOptions;
        }
        if (source) {
          this._copySource(source, doNotCloneChildren, clonePhysicsImpostor, cloneThinInstances);
        }
        if (parent !== null) {
          this.parent = parent;
        }
        this._instanceDataStorage.hardwareInstancedRendering = this.getEngine().getCaps().instancedArrays;
        this._internalMeshDataInfo._onMeshReadyObserverAdded = (observer) => {
          observer.unregisterOnNextCall = true;
          if (this.isReady(true)) {
            this.onMeshReadyObservable.notifyObservers(this);
          } else {
            if (!this._internalMeshDataInfo._checkReadinessObserver) {
              this._internalMeshDataInfo._checkReadinessObserver = this._scene.onBeforeRenderObservable.add(() => {
                if (this.isReady(true)) {
                  this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);
                  this._internalMeshDataInfo._checkReadinessObserver = null;
                  this.onMeshReadyObservable.notifyObservers(this);
                }
              });
            }
          }
        };
        this.onMeshReadyObservable = new Observable(this._internalMeshDataInfo._onMeshReadyObserverAdded);
        if (source) {
          source.onClonedObservable.notifyObservers(this);
        }
      }
      instantiateHierarchy(newParent = null, options, onNewNodeCreated) {
        const instance = this.getTotalVertices() === 0 || options && options.doNotInstantiate && (options.doNotInstantiate === true || options.doNotInstantiate(this)) ? this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true) : this.createInstance("instance of " + (this.name || this.id));
        instance.parent = newParent || this.parent;
        instance.position = this.position.clone();
        instance.scaling = this.scaling.clone();
        if (this.rotationQuaternion) {
          instance.rotationQuaternion = this.rotationQuaternion.clone();
        } else {
          instance.rotation = this.rotation.clone();
        }
        if (onNewNodeCreated) {
          onNewNodeCreated(this, instance);
        }
        for (const child of this.getChildTransformNodes(true)) {
          if (child.getClassName() === "InstancedMesh" && instance.getClassName() === "Mesh" && child.sourceMesh === this) {
            child.instantiateHierarchy(instance, {
              doNotInstantiate: options && options.doNotInstantiate || false,
              newSourcedMesh: instance
            }, onNewNodeCreated);
          } else {
            child.instantiateHierarchy(instance, options, onNewNodeCreated);
          }
        }
        return instance;
      }
      /**
       * Gets the class name
       * @returns the string "Mesh".
       */
      getClassName() {
        return "Mesh";
      }
      /** @internal */
      get _isMesh() {
        return true;
      }
      /**
       * Returns a description of this mesh
       * @param fullDetails define if full details about this mesh must be used
       * @returns a descriptive string representing this mesh
       */
      toString(fullDetails) {
        let ret = super.toString(fullDetails);
        ret += ", n vertices: " + this.getTotalVertices();
        ret += ", parent: " + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : "NONE");
        if (this.animations) {
          for (let i = 0; i < this.animations.length; i++) {
            ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
          }
        }
        if (fullDetails) {
          if (this._geometry) {
            const ib = this.getIndices();
            const vb = this.getVerticesData(VertexBuffer.PositionKind);
            if (vb && ib) {
              ret += ", flat shading: " + (vb.length / 3 === ib.length ? "YES" : "NO");
            }
          } else {
            ret += ", flat shading: UNKNOWN";
          }
        }
        return ret;
      }
      /** @internal */
      _unBindEffect() {
        super._unBindEffect();
        for (const instance of this.instances) {
          instance._unBindEffect();
        }
      }
      /**
       * Gets a boolean indicating if this mesh has LOD
       */
      get hasLODLevels() {
        return this._internalMeshDataInfo._LODLevels.length > 0;
      }
      /**
       * Gets the list of MeshLODLevel associated with the current mesh
       * @returns an array of MeshLODLevel
       */
      getLODLevels() {
        return this._internalMeshDataInfo._LODLevels;
      }
      _sortLODLevels() {
        const sortingOrderFactor = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;
        this._internalMeshDataInfo._LODLevels.sort((a, b) => {
          if (a.distanceOrScreenCoverage < b.distanceOrScreenCoverage) {
            return sortingOrderFactor;
          }
          if (a.distanceOrScreenCoverage > b.distanceOrScreenCoverage) {
            return -sortingOrderFactor;
          }
          return 0;
        });
      }
      /**
       * Add a mesh as LOD level triggered at the given distance.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD
       * @param distanceOrScreenCoverage Either distance from the center of the object to show this level or the screen coverage if `useScreenCoverage` is set to `true`.
       * If screen coverage, value is a fraction of the screen's total surface, between 0 and 1.
       * Example Playground for distance https://playground.babylonjs.com/#QE7KM#197
       * Example Playground for screen coverage https://playground.babylonjs.com/#QE7KM#196
       * @param mesh The mesh to be added as LOD level (can be null)
       * @returns This mesh (for chaining)
       */
      addLODLevel(distanceOrScreenCoverage, mesh) {
        if (mesh && mesh._masterMesh) {
          Logger.Warn("You cannot use a mesh as LOD level twice");
          return this;
        }
        const level = new MeshLODLevel(distanceOrScreenCoverage, mesh);
        this._internalMeshDataInfo._LODLevels.push(level);
        if (mesh) {
          mesh._masterMesh = this;
        }
        this._sortLODLevels();
        return this;
      }
      /**
       * Returns the LOD level mesh at the passed distance or null if not found.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD
       * @param distance The distance from the center of the object to show this level
       * @returns a Mesh or `null`
       */
      getLODLevelAtDistance(distance) {
        const internalDataInfo = this._internalMeshDataInfo;
        for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {
          const level = internalDataInfo._LODLevels[index];
          if (level.distanceOrScreenCoverage === distance) {
            return level.mesh;
          }
        }
        return null;
      }
      /**
       * Remove a mesh from the LOD array
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD
       * @param mesh defines the mesh to be removed
       * @returns This mesh (for chaining)
       */
      removeLODLevel(mesh) {
        const internalDataInfo = this._internalMeshDataInfo;
        for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {
          if (internalDataInfo._LODLevels[index].mesh === mesh) {
            internalDataInfo._LODLevels.splice(index, 1);
            if (mesh) {
              mesh._masterMesh = null;
            }
          }
        }
        this._sortLODLevels();
        return this;
      }
      /**
       * Returns the registered LOD mesh distant from the parameter `camera` position if any, else returns the current mesh.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD
       * @param camera defines the camera to use to compute distance
       * @param boundingSphere defines a custom bounding sphere to use instead of the one from this mesh
       * @returns This mesh (for chaining)
       */
      getLOD(camera, boundingSphere) {
        const internalDataInfo = this._internalMeshDataInfo;
        if (!internalDataInfo._LODLevels || internalDataInfo._LODLevels.length === 0) {
          return this;
        }
        const bSphere = boundingSphere || this.getBoundingInfo().boundingSphere;
        const distanceToCamera = camera.mode === Camera.ORTHOGRAPHIC_CAMERA ? camera.minZ : bSphere.centerWorld.subtract(camera.globalPosition).length();
        let compareValue = distanceToCamera;
        let compareSign = 1;
        if (internalDataInfo._useLODScreenCoverage) {
          const screenArea = camera.screenArea;
          let meshArea = bSphere.radiusWorld * camera.minZ / distanceToCamera;
          meshArea = meshArea * meshArea * Math.PI;
          compareValue = meshArea / screenArea;
          compareSign = -1;
        }
        if (compareSign * internalDataInfo._LODLevels[internalDataInfo._LODLevels.length - 1].distanceOrScreenCoverage > compareSign * compareValue) {
          if (this.onLODLevelSelection) {
            this.onLODLevelSelection(compareValue, this, this);
          }
          return this;
        }
        for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {
          const level = internalDataInfo._LODLevels[index];
          if (compareSign * level.distanceOrScreenCoverage < compareSign * compareValue) {
            if (level.mesh) {
              if (level.mesh.delayLoadState === 4) {
                level.mesh._checkDelayState();
                return this;
              }
              if (level.mesh.delayLoadState === 2) {
                return this;
              }
              level.mesh._preActivate();
              level.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
            }
            if (this.onLODLevelSelection) {
              this.onLODLevelSelection(compareValue, this, level.mesh);
            }
            return level.mesh;
          }
        }
        if (this.onLODLevelSelection) {
          this.onLODLevelSelection(compareValue, this, this);
        }
        return this;
      }
      /**
       * Gets the mesh internal Geometry object
       */
      get geometry() {
        return this._geometry;
      }
      /**
       * Returns the total number of vertices within the mesh geometry or zero if the mesh has no geometry.
       * @returns the total number of vertices
       */
      getTotalVertices() {
        if (this._geometry === null || this._geometry === void 0) {
          return 0;
        }
        return this._geometry.getTotalVertices();
      }
      /**
       * Returns the content of an associated vertex buffer
       * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :
       * - VertexBuffer.PositionKind
       * - VertexBuffer.UVKind
       * - VertexBuffer.UV2Kind
       * - VertexBuffer.UV3Kind
       * - VertexBuffer.UV4Kind
       * - VertexBuffer.UV5Kind
       * - VertexBuffer.UV6Kind
       * - VertexBuffer.ColorKind
       * - VertexBuffer.MatricesIndicesKind
       * - VertexBuffer.MatricesIndicesExtraKind
       * - VertexBuffer.MatricesWeightsKind
       * - VertexBuffer.MatricesWeightsExtraKind
       * @param copyWhenShared defines a boolean indicating that if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one
       * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is
       * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false
       * @returns a FloatArray or null if the mesh has no geometry or no vertex buffer for this kind.
       */
      getVerticesData(kind, copyWhenShared, forceCopy, bypassInstanceData) {
        if (!this._geometry) {
          return null;
        }
        let data = bypassInstanceData ? void 0 : this._userInstancedBuffersStorage?.vertexBuffers[kind]?.getFloatData(
          this.instances.length + 1,
          // +1 because the master mesh is not included in the instances array
          forceCopy || copyWhenShared && this._geometry.meshes.length !== 1
        );
        if (!data) {
          data = this._geometry.getVerticesData(kind, copyWhenShared, forceCopy);
        }
        return data;
      }
      copyVerticesData(kind, vertexData) {
        if (this._geometry) {
          this._geometry.copyVerticesData(kind, vertexData);
        }
      }
      getVertexBuffer(kind, bypassInstanceData) {
        if (!this._geometry) {
          return null;
        }
        return (bypassInstanceData ? void 0 : this._userInstancedBuffersStorage?.vertexBuffers[kind]) ?? this._geometry.getVertexBuffer(kind);
      }
      /**
       * Tests if a specific vertex buffer is associated with this mesh
       * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :
       * - VertexBuffer.PositionKind
       * - VertexBuffer.NormalKind
       * - VertexBuffer.UVKind
       * - VertexBuffer.UV2Kind
       * - VertexBuffer.UV3Kind
       * - VertexBuffer.UV4Kind
       * - VertexBuffer.UV5Kind
       * - VertexBuffer.UV6Kind
       * - VertexBuffer.ColorKind
       * - VertexBuffer.MatricesIndicesKind
       * - VertexBuffer.MatricesIndicesExtraKind
       * - VertexBuffer.MatricesWeightsKind
       * - VertexBuffer.MatricesWeightsExtraKind
       * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false
       * @returns a boolean
       */
      isVerticesDataPresent(kind, bypassInstanceData) {
        if (!this._geometry) {
          if (this._delayInfo) {
            return this._delayInfo.indexOf(kind) !== -1;
          }
          return false;
        }
        return !bypassInstanceData && this._userInstancedBuffersStorage?.vertexBuffers[kind] !== void 0 || this._geometry.isVerticesDataPresent(kind);
      }
      /**
       * Returns a boolean defining if the vertex data for the requested `kind` is updatable.
       * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :
       * - VertexBuffer.PositionKind
       * - VertexBuffer.UVKind
       * - VertexBuffer.UV2Kind
       * - VertexBuffer.UV3Kind
       * - VertexBuffer.UV4Kind
       * - VertexBuffer.UV5Kind
       * - VertexBuffer.UV6Kind
       * - VertexBuffer.ColorKind
       * - VertexBuffer.MatricesIndicesKind
       * - VertexBuffer.MatricesIndicesExtraKind
       * - VertexBuffer.MatricesWeightsKind
       * - VertexBuffer.MatricesWeightsExtraKind
       * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false
       * @returns a boolean
       */
      isVertexBufferUpdatable(kind, bypassInstanceData) {
        if (!this._geometry) {
          if (this._delayInfo) {
            return this._delayInfo.indexOf(kind) !== -1;
          }
          return false;
        }
        if (!bypassInstanceData) {
          const buffer = this._userInstancedBuffersStorage?.vertexBuffers[kind];
          if (buffer) {
            return buffer.isUpdatable();
          }
        }
        return this._geometry.isVertexBufferUpdatable(kind);
      }
      /**
       * Returns a string which contains the list of existing `kinds` of Vertex Data associated with this mesh.
       * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false
       * @returns an array of strings
       */
      getVerticesDataKinds(bypassInstanceData) {
        if (!this._geometry) {
          const result = [];
          if (this._delayInfo) {
            for (const kind of this._delayInfo) {
              result.push(kind);
            }
          }
          return result;
        }
        const kinds = this._geometry.getVerticesDataKinds();
        if (!bypassInstanceData && this._userInstancedBuffersStorage) {
          for (const kind in this._userInstancedBuffersStorage.vertexBuffers) {
            if (kinds.indexOf(kind) === -1) {
              kinds.push(kind);
            }
          }
        }
        return kinds;
      }
      /**
       * Returns a positive integer : the total number of indices in this mesh geometry.
       * @returns the number of indices or zero if the mesh has no geometry.
       */
      getTotalIndices() {
        if (!this._geometry) {
          return 0;
        }
        return this._geometry.getTotalIndices();
      }
      /**
       * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.
       * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
       * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it
       * @returns the indices array or an empty array if the mesh has no geometry
       */
      getIndices(copyWhenShared, forceCopy) {
        if (!this._geometry) {
          return [];
        }
        return this._geometry.getIndices(copyWhenShared, forceCopy);
      }
      get isBlocked() {
        return this._masterMesh !== null && this._masterMesh !== void 0;
      }
      /**
       * Determine if the current mesh is ready to be rendered
       * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
       * @param forceInstanceSupport will check if the mesh will be ready when used with instances (false by default)
       * @returns true if all associated assets are ready (material, textures, shaders)
       */
      isReady(completeCheck = false, forceInstanceSupport = false) {
        if (this.delayLoadState === 2) {
          return false;
        }
        if (!super.isReady(completeCheck)) {
          return false;
        }
        if (!this.subMeshes || this.subMeshes.length === 0) {
          return true;
        }
        if (!completeCheck) {
          return true;
        }
        const engine = this.getEngine();
        const scene = this.getScene();
        const hardwareInstancedRendering = forceInstanceSupport || engine.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);
        this.computeWorldMatrix();
        const mat = this.material || scene.defaultMaterial;
        if (mat) {
          if (mat._storeEffectOnSubMeshes) {
            for (const subMesh of this.subMeshes) {
              const effectiveMaterial = subMesh.getMaterial();
              if (effectiveMaterial) {
                if (effectiveMaterial._storeEffectOnSubMeshes) {
                  if (!effectiveMaterial.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {
                    return false;
                  }
                } else {
                  if (!effectiveMaterial.isReady(this, hardwareInstancedRendering)) {
                    return false;
                  }
                }
              }
            }
          } else {
            if (!mat.isReady(this, hardwareInstancedRendering)) {
              return false;
            }
          }
        }
        const currentRenderPassId = engine.currentRenderPassId;
        for (const light of this.lightSources) {
          const generators = light.getShadowGenerators();
          if (!generators) {
            continue;
          }
          const iterator = generators.values();
          for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
            const generator = key.value;
            if (generator && (!generator.getShadowMap()?.renderList || generator.getShadowMap()?.renderList && generator.getShadowMap()?.renderList?.indexOf(this) !== -1)) {
              const shadowMap = generator.getShadowMap();
              const renderPassIds = shadowMap.renderPassIds ?? [engine.currentRenderPassId];
              for (let p = 0; p < renderPassIds.length; ++p) {
                engine.currentRenderPassId = renderPassIds[p];
                for (const subMesh of this.subMeshes) {
                  if (!generator.isReady(subMesh, hardwareInstancedRendering, subMesh.getMaterial()?.needAlphaBlendingForMesh(this) ?? false)) {
                    engine.currentRenderPassId = currentRenderPassId;
                    return false;
                  }
                }
              }
              engine.currentRenderPassId = currentRenderPassId;
            }
          }
        }
        for (const lod of this._internalMeshDataInfo._LODLevels) {
          if (lod.mesh && !lod.mesh.isReady(hardwareInstancedRendering)) {
            return false;
          }
        }
        return true;
      }
      /**
       * Gets a boolean indicating if the normals aren't to be recomputed on next mesh `positions` array update. This property is pertinent only for updatable parametric shapes.
       */
      get areNormalsFrozen() {
        return this._internalMeshDataInfo._areNormalsFrozen;
      }
      /**
       * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It prevents the mesh normals from being recomputed on next `positions` array update.
       * @returns the current mesh
       */
      freezeNormals() {
        this._internalMeshDataInfo._areNormalsFrozen = true;
        return this;
      }
      /**
       * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It reactivates the mesh normals computation if it was previously frozen
       * @returns the current mesh
       */
      unfreezeNormals() {
        this._internalMeshDataInfo._areNormalsFrozen = false;
        return this;
      }
      /**
       * Sets a value overriding the instance count. Only applicable when custom instanced InterleavedVertexBuffer are used rather than InstancedMeshs
       */
      set overridenInstanceCount(count) {
        this._instanceDataStorage.overridenInstanceCount = count;
      }
      /** @internal */
      _getInstanceDataStorage() {
        const renderPassId = this._instanceDataStorage.engine.isWebGPU ? this._instanceDataStorage.engine.currentRenderPassId : 0;
        let instanceDataStorage = this._instanceDataStorage.renderPasses[renderPassId];
        if (!instanceDataStorage) {
          instanceDataStorage = new _InstanceDataStorageRenderPass();
          this._instanceDataStorage.renderPasses[renderPassId] = instanceDataStorage;
        }
        return instanceDataStorage;
      }
      // Methods
      /** @internal */
      _preActivate() {
        const internalDataInfo = this._internalMeshDataInfo;
        const sceneRenderId = this.getScene().getRenderId();
        if (internalDataInfo._preActivateId === sceneRenderId) {
          return this;
        }
        internalDataInfo._preActivateId = sceneRenderId;
        this._getInstanceDataStorage().visibleInstances = null;
        return this;
      }
      /**
       * @internal
       */
      _preActivateForIntermediateRendering(renderId) {
        const instanceDataStorage = this._getInstanceDataStorage();
        if (instanceDataStorage.visibleInstances) {
          instanceDataStorage.visibleInstances.intermediateDefaultRenderId = renderId;
        }
        return this;
      }
      /**
       * @internal
       */
      _registerInstanceForRenderId(instance, renderId) {
        const instanceDataStorage = this._getInstanceDataStorage();
        if (!instanceDataStorage.visibleInstances) {
          instanceDataStorage.visibleInstances = {
            defaultRenderId: renderId,
            selfDefaultRenderId: this._renderId,
            intermediateDefaultRenderId: -1
          };
        }
        if (!instanceDataStorage.visibleInstances[renderId]) {
          if (instanceDataStorage.previousRenderId !== void 0 && this._instanceDataStorage.isFrozen) {
            instanceDataStorage.visibleInstances[instanceDataStorage.previousRenderId] = null;
          }
          instanceDataStorage.previousRenderId = renderId;
          instanceDataStorage.visibleInstances[renderId] = new Array();
        }
        instanceDataStorage.visibleInstances[renderId].push(instance);
        return this;
      }
      _afterComputeWorldMatrix() {
        super._afterComputeWorldMatrix();
        if (!this.hasThinInstances) {
          return;
        }
        if (!this.doNotSyncBoundingInfo) {
          this.thinInstanceRefreshBoundingInfo(false);
        }
      }
      /** @internal */
      _postActivate() {
        if (this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup) {
          this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer);
          this.edgesRenderer.customInstances.push(this.getWorldMatrix());
        }
      }
      /**
       * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.
       * This means the mesh underlying bounding box and sphere are recomputed.
       * @param applySkeletonOrOptions defines whether to apply the skeleton before computing the bounding info or a set of options
       * @param applyMorph defines whether to apply the morph target before computing the bounding info
       * @returns the current mesh
       */
      refreshBoundingInfo(applySkeletonOrOptions = false, applyMorph = false) {
        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {
          return this;
        }
        let options;
        if (typeof applySkeletonOrOptions === "object") {
          options = applySkeletonOrOptions;
        } else {
          options = {
            applySkeleton: applySkeletonOrOptions,
            applyMorph
          };
        }
        const bias = this.geometry ? this.geometry.boundingBias : null;
        this._refreshBoundingInfo(this._getData(options, null, VertexBuffer.PositionKind), bias);
        return this;
      }
      /**
       * @internal
       */
      _createGlobalSubMesh(force) {
        const totalVertices = this.getTotalVertices();
        if (!totalVertices || !this.getIndices()) {
          return null;
        }
        if (this.subMeshes && this.subMeshes.length > 0) {
          const ib = this.getIndices();
          if (!ib) {
            return null;
          }
          const totalIndices = ib.length;
          let needToRecreate = false;
          if (force) {
            needToRecreate = true;
          } else {
            for (const submesh of this.subMeshes) {
              if (submesh.indexStart + submesh.indexCount > totalIndices) {
                needToRecreate = true;
                break;
              }
              if (submesh.verticesStart + submesh.verticesCount > totalVertices) {
                needToRecreate = true;
                break;
              }
            }
          }
          if (!needToRecreate) {
            return this.subMeshes[0];
          }
        }
        this.releaseSubMeshes();
        return new SubMesh(0, 0, totalVertices, 0, this.getTotalIndices() || (this.isUnIndexed ? totalVertices : 0), this);
      }
      /**
       * This function will subdivide the mesh into multiple submeshes
       * @param count defines the expected number of submeshes
       */
      subdivide(count) {
        if (count < 1) {
          return;
        }
        const totalIndices = this.getTotalIndices();
        let subdivisionSize = totalIndices / count | 0;
        let offset = 0;
        while (subdivisionSize % 3 !== 0) {
          subdivisionSize++;
        }
        this.releaseSubMeshes();
        for (let index = 0; index < count; index++) {
          if (offset >= totalIndices) {
            break;
          }
          SubMesh.CreateFromIndices(0, offset, index === count - 1 ? totalIndices - offset : subdivisionSize, this, void 0, false);
          offset += subdivisionSize;
        }
        this.refreshBoundingInfo();
        this.synchronizeInstances();
      }
      /**
       * Copy a FloatArray into a specific associated vertex buffer
       * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :
       * - VertexBuffer.PositionKind
       * - VertexBuffer.UVKind
       * - VertexBuffer.UV2Kind
       * - VertexBuffer.UV3Kind
       * - VertexBuffer.UV4Kind
       * - VertexBuffer.UV5Kind
       * - VertexBuffer.UV6Kind
       * - VertexBuffer.ColorKind
       * - VertexBuffer.MatricesIndicesKind
       * - VertexBuffer.MatricesIndicesExtraKind
       * - VertexBuffer.MatricesWeightsKind
       * - VertexBuffer.MatricesWeightsExtraKind
       * @param data defines the data source
       * @param updatable defines if the updated vertex buffer must be flagged as updatable
       * @param stride defines the data stride size (can be null)
       * @returns the current mesh
       */
      setVerticesData(kind, data, updatable = false, stride) {
        if (!this._geometry) {
          const vertexData = new VertexData();
          vertexData.set(data, kind);
          const scene = this.getScene();
          new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);
        } else {
          this._geometry.setVerticesData(kind, data, updatable, stride);
        }
        return this;
      }
      /**
       * Delete a vertex buffer associated with this mesh
       * @param kind defines which buffer to delete (positions, indices, normals, etc). Possible `kind` values :
       * - VertexBuffer.PositionKind
       * - VertexBuffer.UVKind
       * - VertexBuffer.UV2Kind
       * - VertexBuffer.UV3Kind
       * - VertexBuffer.UV4Kind
       * - VertexBuffer.UV5Kind
       * - VertexBuffer.UV6Kind
       * - VertexBuffer.ColorKind
       * - VertexBuffer.MatricesIndicesKind
       * - VertexBuffer.MatricesIndicesExtraKind
       * - VertexBuffer.MatricesWeightsKind
       * - VertexBuffer.MatricesWeightsExtraKind
       */
      removeVerticesData(kind) {
        if (!this._geometry) {
          return;
        }
        this._geometry.removeVerticesData(kind);
      }
      /**
       * Flags an associated vertex buffer as updatable
       * @param kind defines which buffer to use (positions, indices, normals, etc). Possible `kind` values :
       * - VertexBuffer.PositionKind
       * - VertexBuffer.UVKind
       * - VertexBuffer.UV2Kind
       * - VertexBuffer.UV3Kind
       * - VertexBuffer.UV4Kind
       * - VertexBuffer.UV5Kind
       * - VertexBuffer.UV6Kind
       * - VertexBuffer.ColorKind
       * - VertexBuffer.MatricesIndicesKind
       * - VertexBuffer.MatricesIndicesExtraKind
       * - VertexBuffer.MatricesWeightsKind
       * - VertexBuffer.MatricesWeightsExtraKind
       * @param updatable defines if the updated vertex buffer must be flagged as updatable
       */
      markVerticesDataAsUpdatable(kind, updatable = true) {
        const vb = this.getVertexBuffer(kind);
        if (!vb || vb.isUpdatable() === updatable) {
          return;
        }
        this.setVerticesData(kind, this.getVerticesData(kind), updatable);
      }
      /**
       * Sets the mesh global Vertex Buffer
       * @param buffer defines the buffer to use
       * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)
       * @param totalVertices defines the total number of vertices for position kind (could be null)
       * @returns the current mesh
       */
      setVerticesBuffer(buffer, disposeExistingBuffer = true, totalVertices = null) {
        if (!this._geometry) {
          this._geometry = Geometry.CreateGeometryForMesh(this);
        }
        this._geometry.setVerticesBuffer(buffer, totalVertices, disposeExistingBuffer);
        return this;
      }
      /**
       * Update a specific associated vertex buffer
       * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :
       * - VertexBuffer.PositionKind
       * - VertexBuffer.UVKind
       * - VertexBuffer.UV2Kind
       * - VertexBuffer.UV3Kind
       * - VertexBuffer.UV4Kind
       * - VertexBuffer.UV5Kind
       * - VertexBuffer.UV6Kind
       * - VertexBuffer.ColorKind
       * - VertexBuffer.MatricesIndicesKind
       * - VertexBuffer.MatricesIndicesExtraKind
       * - VertexBuffer.MatricesWeightsKind
       * - VertexBuffer.MatricesWeightsExtraKind
       * @param data defines the data source
       * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for "position" kind
       * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)
       * @returns the current mesh
       */
      updateVerticesData(kind, data, updateExtends, makeItUnique) {
        if (!this._geometry) {
          return this;
        }
        if (!makeItUnique) {
          this._geometry.updateVerticesData(kind, data, updateExtends);
        } else {
          this.makeGeometryUnique();
          this.updateVerticesData(kind, data, updateExtends, false);
        }
        return this;
      }
      /**
       * This method updates the vertex positions of an updatable mesh according to the `positionFunction` returned values.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#other-shapes-updatemeshpositions
       * @param positionFunction is a simple JS function what is passed the mesh `positions` array. It doesn't need to return anything
       * @param computeNormals is a boolean (default true) to enable/disable the mesh normal recomputation after the vertex position update
       * @returns the current mesh
       */
      updateMeshPositions(positionFunction, computeNormals = true) {
        const positions = this.getVerticesData(VertexBuffer.PositionKind);
        if (!positions) {
          return this;
        }
        positionFunction(positions);
        this.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
        if (computeNormals) {
          const indices = this.getIndices();
          const normals = this.getVerticesData(VertexBuffer.NormalKind);
          if (!normals) {
            return this;
          }
          VertexData.ComputeNormals(positions, indices, normals);
          this.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);
        }
        return this;
      }
      /**
       * Creates a un-shared specific occurence of the geometry for the mesh.
       * @returns the current mesh
       */
      makeGeometryUnique() {
        if (!this._geometry) {
          return this;
        }
        if (this._geometry.meshes.length === 1) {
          return this;
        }
        const oldGeometry = this._geometry;
        const geometry = this._geometry.copy(Geometry.RandomId());
        oldGeometry.releaseForMesh(this, true);
        geometry.applyToMesh(this);
        return this;
      }
      /**
       * Sets the index buffer of this mesh.
       * @param indexBuffer Defines the index buffer to use for this mesh
       * @param totalVertices Defines the total number of vertices used by the buffer
       * @param totalIndices Defines the total number of indices in the index buffer
       * @param is32Bits Defines if the indices are 32 bits. If null (default), the value is guessed from the number of vertices
       */
      setIndexBuffer(indexBuffer, totalVertices, totalIndices, is32Bits = null) {
        let geometry = this._geometry;
        if (!geometry) {
          geometry = new Geometry(Geometry.RandomId(), this.getScene(), void 0, void 0, this);
        }
        geometry.setIndexBuffer(indexBuffer, totalVertices, totalIndices, is32Bits);
      }
      /**
       * Set the index buffer of this mesh
       * @param indices defines the source data
       * @param totalVertices defines the total number of vertices referenced by this index data (can be null)
       * @param updatable defines if the updated index buffer must be flagged as updatable (default is false)
       * @param dontForceSubMeshRecreation defines a boolean indicating that we don't want to force the recreation of sub-meshes if we don't have to (false by default)
       * @returns the current mesh
       */
      setIndices(indices, totalVertices = null, updatable = false, dontForceSubMeshRecreation = false) {
        if (!this._geometry) {
          const vertexData = new VertexData();
          vertexData.indices = indices;
          const scene = this.getScene();
          new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this, totalVertices);
        } else {
          this._geometry.setIndices(indices, totalVertices, updatable, dontForceSubMeshRecreation);
        }
        return this;
      }
      /**
       * Update the current index buffer
       * @param indices defines the source data
       * @param offset defines the offset in the index buffer where to store the new data (can be null)
       * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)
       * @returns the current mesh
       */
      updateIndices(indices, offset, gpuMemoryOnly = false) {
        if (!this._geometry) {
          return this;
        }
        this._geometry.updateIndices(indices, offset, gpuMemoryOnly);
        return this;
      }
      /**
       * Invert the geometry to move from a right handed system to a left handed one.
       * @returns the current mesh
       */
      toLeftHanded() {
        if (!this._geometry) {
          return this;
        }
        this._geometry.toLeftHanded();
        return this;
      }
      /**
       * @internal
       */
      _bind(subMesh, effect, fillMode, allowInstancedRendering = true) {
        if (!this._geometry) {
          return this;
        }
        const engine = this.getScene().getEngine();
        let indexToBind;
        if (this._unIndexed) {
          switch (this._getRenderingFillMode(fillMode)) {
            case Material.WireFrameFillMode:
              indexToBind = subMesh._getLinesIndexBuffer(this.getIndices(), engine);
              break;
            default:
              indexToBind = null;
              break;
          }
        } else {
          switch (this._getRenderingFillMode(fillMode)) {
            case Material.PointFillMode:
              indexToBind = null;
              break;
            case Material.WireFrameFillMode:
              indexToBind = subMesh._getLinesIndexBuffer(this.getIndices(), engine);
              break;
            default:
            case Material.TriangleFillMode:
              indexToBind = this._geometry.getIndexBuffer();
              break;
          }
        }
        return this._bindDirect(effect, indexToBind, allowInstancedRendering);
      }
      /**
       * @internal
       */
      _bindDirect(effect, indexToBind, allowInstancedRendering = true) {
        if (!this._geometry) {
          return this;
        }
        if (this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets) {
          this.morphTargetManager._bind(effect);
        }
        if (!allowInstancedRendering || !this._userInstancedBuffersStorage || this.hasThinInstances) {
          this._geometry._bind(effect, indexToBind);
        } else {
          if (this._instanceDataStorage.engine.isWebGPU && this._userInstancedBuffersStorage.renderPasses && this._userInstancedBuffersStorage.renderPasses[this._instanceDataStorage.engine.currentRenderPassId]) {
            const vertexBuffers = this._userInstancedBuffersStorage.renderPasses[this._instanceDataStorage.engine.currentRenderPassId];
            for (const kind in vertexBuffers) {
              this._userInstancedBuffersStorage.vertexBuffers[kind] = vertexBuffers[kind];
            }
          }
          this._geometry._bind(effect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);
        }
        return this;
      }
      /**
       * @internal
       */
      _draw(subMesh, fillMode, instancesCount) {
        if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
          return this;
        }
        if (this._internalMeshDataInfo._onBeforeDrawObservable) {
          this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);
        }
        const scene = this.getScene();
        const engine = scene.getEngine();
        const currentMaterialContext = engine._currentMaterialContext;
        const useVertexPulling = currentMaterialContext && currentMaterialContext.useVertexPulling;
        if (this._unIndexed && fillMode !== Material.WireFrameFillMode || fillMode == Material.PointFillMode) {
          engine.drawArraysType(fillMode, subMesh.verticesStart, subMesh.verticesCount, this.forcedInstanceCount || instancesCount);
        } else if (fillMode == Material.WireFrameFillMode) {
          engine.drawElementsType(fillMode, 0, subMesh._linesIndexCount, this.forcedInstanceCount || instancesCount);
        } else if (useVertexPulling) {
          engine.drawArraysType(fillMode, subMesh.indexStart, subMesh.indexCount, this.forcedInstanceCount || instancesCount);
        } else {
          engine.drawElementsType(fillMode, subMesh.indexStart, subMesh.indexCount, this.forcedInstanceCount || instancesCount);
        }
        return this;
      }
      /**
       * Registers for this mesh a javascript function called just before the rendering process
       * @param func defines the function to call before rendering this mesh
       * @returns the current mesh
       */
      registerBeforeRender(func) {
        this.onBeforeRenderObservable.add(func);
        return this;
      }
      /**
       * Disposes a previously registered javascript function called before the rendering
       * @param func defines the function to remove
       * @returns the current mesh
       */
      unregisterBeforeRender(func) {
        this.onBeforeRenderObservable.removeCallback(func);
        return this;
      }
      /**
       * Registers for this mesh a javascript function called just after the rendering is complete
       * @param func defines the function to call after rendering this mesh
       * @returns the current mesh
       */
      registerAfterRender(func) {
        this.onAfterRenderObservable.add(func);
        return this;
      }
      /**
       * Disposes a previously registered javascript function called after the rendering.
       * @param func defines the function to remove
       * @returns the current mesh
       */
      unregisterAfterRender(func) {
        this.onAfterRenderObservable.removeCallback(func);
        return this;
      }
      /**
       * @internal
       */
      _getInstancesRenderList(subMeshId, isReplacementMode = false) {
        const instanceDataStorage = this._getInstanceDataStorage();
        if (this._instanceDataStorage.isFrozen) {
          if (isReplacementMode) {
            instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[subMeshId] = false;
            instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[subMeshId] = true;
            return instanceDataStorage.batchCacheReplacementModeInFrozenMode;
          }
          if (instanceDataStorage.previousBatch) {
            return instanceDataStorage.previousBatch;
          }
        }
        const scene = this.getScene();
        const isInIntermediateRendering = scene._isInIntermediateRendering();
        const onlyForInstances = isInIntermediateRendering ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances;
        const batchCache = instanceDataStorage.batchCache;
        batchCache.mustReturn = false;
        batchCache.renderSelf[subMeshId] = isReplacementMode || !onlyForInstances && this.isEnabled() && this.isVisible;
        batchCache.visibleInstances[subMeshId] = null;
        if (instanceDataStorage.visibleInstances && !isReplacementMode) {
          const visibleInstances = instanceDataStorage.visibleInstances;
          const currentRenderId = scene.getRenderId();
          const defaultRenderId = isInIntermediateRendering ? visibleInstances.intermediateDefaultRenderId : visibleInstances.defaultRenderId;
          batchCache.visibleInstances[subMeshId] = visibleInstances[currentRenderId];
          if (!batchCache.visibleInstances[subMeshId] && defaultRenderId) {
            batchCache.visibleInstances[subMeshId] = visibleInstances[defaultRenderId];
          }
        }
        batchCache.hardwareInstancedRendering[subMeshId] = !isReplacementMode && this._instanceDataStorage.hardwareInstancedRendering && batchCache.visibleInstances[subMeshId] !== null && batchCache.visibleInstances[subMeshId] !== void 0;
        instanceDataStorage.previousBatch = batchCache;
        return batchCache;
      }
      /**
       * This method will also draw the instances if fillMode and effect are passed
       * @internal
       */
      _updateInstancedBuffers(subMesh, batch, currentInstancesBufferSize, engine, fillMode, effect) {
        const visibleInstances = batch.visibleInstances[subMesh._id];
        const visibleInstanceCount = visibleInstances ? visibleInstances.length : 0;
        const instanceStorage = batch.parent;
        const instanceDataStorage = this._instanceDataStorage;
        let instancesBuffer = instanceStorage.instancesBuffer;
        let instancesPreviousBuffer = instanceStorage.instancesPreviousBuffer;
        let offset = 0;
        let instancesCount = 0;
        const renderSelf = batch.renderSelf[subMesh._id];
        const floatingOriginOffset = this._scene.floatingOriginOffset;
        const needUpdateBuffer = !instancesBuffer || currentInstancesBufferSize !== instanceStorage.instancesBufferSize || this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousBuffer;
        if (!this._instanceDataStorage.manualUpdate && (!instanceDataStorage.isFrozen || needUpdateBuffer)) {
          const world = this.getWorldMatrix();
          if (renderSelf) {
            if (this._scene.needsPreviousWorldMatrices) {
              if (!instanceDataStorage.masterMeshPreviousWorldMatrix) {
                instanceDataStorage.masterMeshPreviousWorldMatrix = world.clone();
                instanceDataStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
              } else {
                instanceDataStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
                instanceDataStorage.masterMeshPreviousWorldMatrix.copyFrom(world);
              }
            }
            world.copyToArray(instanceStorage.instancesData, offset);
            instanceStorage.instancesData[offset + 12] -= floatingOriginOffset.x;
            instanceStorage.instancesData[offset + 13] -= floatingOriginOffset.y;
            instanceStorage.instancesData[offset + 14] -= floatingOriginOffset.z;
            offset += 16;
            instancesCount++;
          }
          if (visibleInstances) {
            if (_Mesh.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && subMesh.getMaterial()?.needAlphaBlendingForMesh(subMesh.getRenderingMesh())) {
              const cameraPosition = this._scene.activeCamera.globalPosition;
              for (let instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {
                const instanceMesh = visibleInstances[instanceIndex];
                instanceMesh._distanceToCamera = Vector3.Distance(instanceMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);
              }
              visibleInstances.sort((m1, m2) => {
                return m1._distanceToCamera > m2._distanceToCamera ? -1 : m1._distanceToCamera < m2._distanceToCamera ? 1 : 0;
              });
            }
            for (let instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {
              const instance = visibleInstances[instanceIndex];
              const matrix = instance.getWorldMatrix();
              matrix.copyToArray(instanceStorage.instancesData, offset);
              if (this._scene.needsPreviousWorldMatrices) {
                if (!instance._previousWorldMatrix) {
                  instance._previousWorldMatrix = matrix.clone();
                  instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
                } else {
                  instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
                  instance._previousWorldMatrix.copyFrom(matrix);
                }
              }
              instanceStorage.instancesData[offset + 12] -= floatingOriginOffset.x;
              instanceStorage.instancesData[offset + 13] -= floatingOriginOffset.y;
              instanceStorage.instancesData[offset + 14] -= floatingOriginOffset.z;
              offset += 16;
              instancesCount++;
            }
          }
        } else {
          instancesCount = (renderSelf ? 1 : 0) + visibleInstanceCount;
        }
        if (needUpdateBuffer) {
          if (instancesBuffer) {
            instancesBuffer.dispose();
          }
          if (instancesPreviousBuffer) {
            instancesPreviousBuffer.dispose();
          }
          instancesBuffer = new Buffer(engine, instanceStorage.instancesData, true, 16, false, true);
          instanceStorage.instancesBuffer = instancesBuffer;
          if (!this._userInstancedBuffersStorage) {
            this._userInstancedBuffersStorage = {
              data: {},
              vertexBuffers: {},
              strides: {},
              sizes: {},
              vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
            };
          }
          let vertexAndArrayObjectBuffers;
          if (this._instanceDataStorage.engine.isWebGPU) {
            if (!this._userInstancedBuffersStorage.renderPasses) {
              this._userInstancedBuffersStorage.renderPasses = {};
            }
            const currentRenderPassId = this._instanceDataStorage.engine.currentRenderPassId;
            vertexAndArrayObjectBuffers = this._userInstancedBuffersStorage.renderPasses[currentRenderPassId];
            if (!vertexAndArrayObjectBuffers) {
              this._userInstancedBuffersStorage.renderPasses[currentRenderPassId] = vertexAndArrayObjectBuffers = {};
            }
          } else {
            vertexAndArrayObjectBuffers = this._userInstancedBuffersStorage.vertexBuffers;
          }
          vertexAndArrayObjectBuffers["world0"] = instancesBuffer.createVertexBuffer("world0", 0, 4);
          vertexAndArrayObjectBuffers["world1"] = instancesBuffer.createVertexBuffer("world1", 4, 4);
          vertexAndArrayObjectBuffers["world2"] = instancesBuffer.createVertexBuffer("world2", 8, 4);
          vertexAndArrayObjectBuffers["world3"] = instancesBuffer.createVertexBuffer("world3", 12, 4);
          if (this._scene.needsPreviousWorldMatrices) {
            instancesPreviousBuffer = new Buffer(engine, instanceStorage.instancesPreviousData, true, 16, false, true);
            instanceStorage.instancesPreviousBuffer = instancesPreviousBuffer;
            vertexAndArrayObjectBuffers["previousWorld0"] = instancesPreviousBuffer.createVertexBuffer("previousWorld0", 0, 4);
            vertexAndArrayObjectBuffers["previousWorld1"] = instancesPreviousBuffer.createVertexBuffer("previousWorld1", 4, 4);
            vertexAndArrayObjectBuffers["previousWorld2"] = instancesPreviousBuffer.createVertexBuffer("previousWorld2", 8, 4);
            vertexAndArrayObjectBuffers["previousWorld3"] = instancesPreviousBuffer.createVertexBuffer("previousWorld3", 12, 4);
          }
          this._invalidateInstanceVertexArrayObject();
        } else {
          if (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) {
            instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);
            if (this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate)) {
              instancesPreviousBuffer.updateDirectly(instanceStorage.instancesPreviousData, 0, instancesCount);
            }
          }
        }
        this._processInstancedBuffers(visibleInstances, renderSelf);
        if (effect && fillMode !== void 0) {
          this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);
          if (engine._currentDrawContext) {
            engine._currentDrawContext.useInstancing = true;
          }
          this._bind(subMesh, effect, fillMode);
          this._draw(subMesh, fillMode, instancesCount);
        }
        if (this._scene.needsPreviousWorldMatrices && !needUpdateBuffer && this._instanceDataStorage.manualUpdate && (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) && !this._instanceDataStorage.previousManualUpdate) {
          instancesPreviousBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);
        }
      }
      /**
       * @internal
       */
      _renderWithInstances(subMesh, fillMode, batch, effect, engine) {
        const visibleInstances = batch.visibleInstances[subMesh._id];
        const visibleInstanceCount = visibleInstances ? visibleInstances.length : 0;
        const instanceStorage = batch.parent;
        const currentInstancesBufferSize = instanceStorage.instancesBufferSize;
        const matricesCount = visibleInstanceCount + 1;
        const bufferSize = matricesCount * 16 * 4;
        while (instanceStorage.instancesBufferSize < bufferSize) {
          instanceStorage.instancesBufferSize *= 2;
        }
        if (!instanceStorage.instancesData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {
          instanceStorage.instancesData = new Float32Array(instanceStorage.instancesBufferSize / 4);
        }
        if (this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {
          instanceStorage.instancesPreviousData = new Float32Array(instanceStorage.instancesBufferSize / 4);
        }
        this._updateInstancedBuffers(subMesh, batch, currentInstancesBufferSize, engine, fillMode, effect);
        engine.unbindInstanceAttributes();
        return this;
      }
      /**
       * @internal
       */
      _renderWithThinInstances(subMesh, fillMode, effect, engine) {
        const instancesCount = this._thinInstanceDataStorage?.instancesCount ?? 0;
        this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);
        if (engine._currentDrawContext) {
          engine._currentDrawContext.useInstancing = true;
        }
        this._bind(subMesh, effect, fillMode);
        this._draw(subMesh, fillMode, instancesCount);
        if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData) {
          if (!this._thinInstanceDataStorage.previousMatrixBuffer) {
            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.matrixData, false);
          } else {
            this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, instancesCount);
          }
        }
        engine.unbindInstanceAttributes();
      }
      /**
       * @internal
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _processInstancedBuffers(visibleInstances, renderSelf) {
      }
      /**
       * @internal
       */
      _processRendering(renderingMesh, subMesh, effect, fillMode, batch, hardwareInstancedRendering, onBeforeDraw, effectiveMaterial) {
        const scene = this.getScene();
        const engine = scene.getEngine();
        fillMode = this._getRenderingFillMode(fillMode);
        if (hardwareInstancedRendering && subMesh.getRenderingMesh().hasThinInstances) {
          this._renderWithThinInstances(subMesh, fillMode, effect, engine);
          return this;
        }
        if (hardwareInstancedRendering) {
          this._renderWithInstances(subMesh, fillMode, batch, effect, engine);
        } else {
          if (engine._currentDrawContext) {
            engine._currentDrawContext.useInstancing = false;
          }
          let instanceCount = 0;
          if (batch.renderSelf[subMesh._id]) {
            if (onBeforeDraw) {
              onBeforeDraw(false, renderingMesh.getWorldMatrix(), effectiveMaterial);
            }
            instanceCount++;
            this._draw(subMesh, fillMode, this._instanceDataStorage.overridenInstanceCount);
          }
          const visibleInstancesForSubMesh = batch.visibleInstances[subMesh._id];
          if (visibleInstancesForSubMesh) {
            const visibleInstanceCount = visibleInstancesForSubMesh.length;
            instanceCount += visibleInstanceCount;
            for (let instanceIndex = 0; instanceIndex < visibleInstanceCount; instanceIndex++) {
              const instance = visibleInstancesForSubMesh[instanceIndex];
              const world = instance.getWorldMatrix();
              if (onBeforeDraw) {
                onBeforeDraw(true, world, effectiveMaterial);
              }
              this._draw(subMesh, fillMode);
            }
          }
          scene._activeIndices.addCount(subMesh.indexCount * instanceCount, false);
        }
        return this;
      }
      /**
       * @internal
       */
      _rebuild(dispose = false) {
        for (const renderPassId in this._instanceDataStorage.renderPasses) {
          const instanceDataStorage = this._instanceDataStorage.renderPasses[renderPassId];
          if (instanceDataStorage.instancesBuffer) {
            if (dispose) {
              instanceDataStorage.instancesBuffer.dispose();
            }
            instanceDataStorage.instancesBuffer = null;
          }
        }
        if (this._userInstancedBuffersStorage) {
          for (const kind in this._userInstancedBuffersStorage.vertexBuffers) {
            const buffer = this._userInstancedBuffersStorage.vertexBuffers[kind];
            if (buffer) {
              if (dispose) {
                buffer.dispose();
              }
              this._userInstancedBuffersStorage.vertexBuffers[kind] = null;
            }
          }
          if (this._userInstancedBuffersStorage.vertexArrayObjects) {
            this._userInstancedBuffersStorage.vertexArrayObjects = {};
          }
        }
        this._internalMeshDataInfo._effectiveMaterial = null;
        super._rebuild(dispose);
      }
      /** @internal */
      _freeze() {
        if (!this.subMeshes) {
          return;
        }
        for (let index = 0; index < this.subMeshes.length; index++) {
          this._getInstancesRenderList(index);
        }
        this._internalMeshDataInfo._effectiveMaterial = null;
        this._instanceDataStorage.isFrozen = true;
      }
      /** @internal */
      _unFreeze() {
        this._instanceDataStorage.isFrozen = false;
        for (const renderPassId in this._instanceDataStorage.renderPasses) {
          const instanceDataStorage = this._instanceDataStorage.renderPasses[renderPassId];
          instanceDataStorage.previousBatch = null;
        }
      }
      /**
       * Triggers the draw call for the mesh (or a submesh), for a specific render pass id
       * @param renderPassId defines the render pass id to use to draw the mesh / submesh. If not provided, use the current renderPassId of the engine.
       * @param enableAlphaMode defines if alpha mode can be changed (default: false)
       * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering (default: undefined)
       * @param subMesh defines the subMesh to render. If not provided, draw all mesh submeshes (default: undefined)
       * @param checkFrustumCulling defines if frustum culling must be checked (default: true). If you know the mesh is in the frustum (or if you don't care!), you can pass false to optimize.
       * @returns the current mesh
       */
      renderWithRenderPassId(renderPassId, enableAlphaMode, effectiveMeshReplacement, subMesh, checkFrustumCulling = true) {
        const engine = this._scene.getEngine();
        const currentRenderPassId = engine.currentRenderPassId;
        if (renderPassId !== void 0) {
          engine.currentRenderPassId = renderPassId;
        }
        if (subMesh) {
          if (!checkFrustumCulling || checkFrustumCulling && subMesh.isInFrustum(this._scene._frustumPlanes)) {
            this.render(subMesh, !!enableAlphaMode, effectiveMeshReplacement);
          }
        } else {
          for (let s = 0; s < this.subMeshes.length; s++) {
            const subMesh2 = this.subMeshes[s];
            if (!checkFrustumCulling || checkFrustumCulling && subMesh2.isInFrustum(this._scene._frustumPlanes)) {
              this.render(subMesh2, !!enableAlphaMode, effectiveMeshReplacement);
            }
          }
        }
        if (renderPassId !== void 0) {
          engine.currentRenderPassId = currentRenderPassId;
        }
        return this;
      }
      /**
       * Render a complete mesh by going through all submeshes
       * @returns the current mesh
       * @see [simple test](https://playground.babylonjs.com/#5SPY1V#2)
       * @see [perf test](https://playground.babylonjs.com/#5SPY1V#5)
       */
      directRender() {
        if (!this.subMeshes) {
          return this;
        }
        for (const submesh of this.subMeshes) {
          this.render(submesh, false);
        }
        return this;
      }
      /**
       * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager
       * @param subMesh defines the subMesh to render
       * @param enableAlphaMode defines if alpha mode can be changed
       * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering
       * @returns the current mesh
       */
      render(subMesh, enableAlphaMode, effectiveMeshReplacement) {
        const scene = this.getScene();
        if (this._internalAbstractMeshDataInfo._isActiveIntermediate) {
          this._internalAbstractMeshDataInfo._isActiveIntermediate = false;
        } else {
          this._internalAbstractMeshDataInfo._isActive = false;
        }
        const numActiveCameras = scene.activeCameras?.length ?? 0;
        const canCheckOcclusionQuery = numActiveCameras > 1 && scene.activeCamera === scene.activeCameras[0] || numActiveCameras <= 1;
        if (canCheckOcclusionQuery && this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded) {
          return this;
        }
        const batch = this._getInstancesRenderList(subMesh._id, !!effectiveMeshReplacement);
        if (batch.mustReturn) {
          return this;
        }
        if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
          return this;
        }
        const engine = scene.getEngine();
        let oldCameraMaxZ = 0;
        let oldCamera = null;
        if (this.ignoreCameraMaxZ && scene.activeCamera && !scene._isInIntermediateRendering()) {
          oldCameraMaxZ = scene.activeCamera.maxZ;
          oldCamera = scene.activeCamera;
          scene.activeCamera.maxZ = 0;
          scene.updateTransformMatrix(true);
        }
        if (this._internalMeshDataInfo._onBeforeRenderObservable) {
          this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);
        }
        const renderingMesh = subMesh.getRenderingMesh();
        const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances || !!this._userInstancedBuffersStorage && !subMesh.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh;
        const instanceDataStorage = this._instanceDataStorage;
        const material = subMesh.getMaterial();
        if (!material) {
          if (oldCamera) {
            oldCamera.maxZ = oldCameraMaxZ;
            scene.updateTransformMatrix(true);
          }
          return this;
        }
        if (!instanceDataStorage.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== material) {
          if (material._storeEffectOnSubMeshes) {
            if (!material.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {
              if (oldCamera) {
                oldCamera.maxZ = oldCameraMaxZ;
                scene.updateTransformMatrix(true);
              }
              return this;
            }
          } else if (!material.isReady(this, hardwareInstancedRendering)) {
            if (oldCamera) {
              oldCamera.maxZ = oldCameraMaxZ;
              scene.updateTransformMatrix(true);
            }
            return this;
          }
          this._internalMeshDataInfo._effectiveMaterial = material;
        } else if (material._storeEffectOnSubMeshes && !subMesh._drawWrapper?._wasPreviouslyReady || !material._storeEffectOnSubMeshes && !material._getDrawWrapper()._wasPreviouslyReady) {
          if (oldCamera) {
            oldCamera.maxZ = oldCameraMaxZ;
            scene.updateTransformMatrix(true);
          }
          return this;
        }
        if (enableAlphaMode) {
          const effectiveMaterial2 = this._internalMeshDataInfo._effectiveMaterial;
          if (effectiveMaterial2.alphaModes.length === 1) {
            engine.setAlphaMode(effectiveMaterial2.alphaMode);
          } else {
            for (let i = 0; i < effectiveMaterial2.alphaModes.length; i++) {
              const alphaMode = effectiveMaterial2.alphaModes[i];
              engine.setAlphaMode(alphaMode !== void 0 ? alphaMode : 2, false, i);
            }
          }
        }
        let drawWrapper;
        if (this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes) {
          drawWrapper = subMesh._drawWrapper;
        } else {
          drawWrapper = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();
        }
        const effect = drawWrapper?.effect ?? null;
        for (const step of scene._beforeRenderingMeshStage) {
          step.action(this, subMesh, batch, effect);
        }
        if (!drawWrapper || !effect) {
          if (oldCamera) {
            oldCamera.maxZ = oldCameraMaxZ;
            scene.updateTransformMatrix(true);
          }
          return this;
        }
        const effectiveMesh = effectiveMeshReplacement || this;
        let sideOrientation;
        if (!instanceDataStorage.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this._internalMeshDataInfo._effectiveMaterial.sideOrientation !== null || this._internalMeshDataInfo._effectiveMaterial._twoSidedLighting)) {
          const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();
          sideOrientation = this._internalMeshDataInfo._effectiveMaterial._getEffectiveOrientation(this);
          if (mainDeterminant < 0) {
            sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
          }
          this._internalMeshDataInfo._effectiveSideOrientation = sideOrientation;
        } else {
          sideOrientation = this._internalMeshDataInfo._effectiveSideOrientation;
        }
        const reverse = this._internalMeshDataInfo._effectiveMaterial._preBind(drawWrapper, this._internalMeshDataInfo._effectiveSideOrientation);
        if (this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite) {
          engine.setDepthWrite(true);
        }
        const effectiveMaterial = this._internalMeshDataInfo._effectiveMaterial;
        const fillMode = effectiveMaterial.fillMode;
        if (this._internalMeshDataInfo._onBeforeBindObservable) {
          this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this);
        }
        if (!hardwareInstancedRendering) {
          this._bind(subMesh, effect, fillMode, false);
        }
        const world = effectiveMesh.getWorldMatrix();
        if (effectiveMaterial._storeEffectOnSubMeshes) {
          effectiveMaterial.bindForSubMesh(world, this, subMesh);
        } else {
          effectiveMaterial.bind(world, this);
        }
        if (!effectiveMaterial.backFaceCulling && effectiveMaterial.separateCullingPass) {
          engine.setState(true, effectiveMaterial.zOffset, false, !reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);
          this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);
          engine.setState(true, effectiveMaterial.zOffset, false, reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);
          if (this._internalMeshDataInfo._onBetweenPassObservable) {
            this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(subMesh);
          }
        }
        this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);
        this._internalMeshDataInfo._effectiveMaterial.unbind();
        for (const step of scene._afterRenderingMeshStage) {
          step.action(this, subMesh, batch, effect);
        }
        if (this._internalMeshDataInfo._onAfterRenderObservable) {
          this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this);
        }
        if (oldCamera) {
          oldCamera.maxZ = oldCameraMaxZ;
          scene.updateTransformMatrix(true);
        }
        if (scene.performancePriority === 2 && !instanceDataStorage.isFrozen) {
          this._freeze();
        }
        return this;
      }
      /**
       *   Renormalize the mesh and patch it up if there are no weights
       *   Similar to normalization by adding the weights compute the reciprocal and multiply all elements, this wil ensure that everything adds to 1.
       *   However in the case of zero weights then we set just a single influence to 1.
       *   We check in the function for extra's present and if so we use the normalizeSkinWeightsWithExtras rather than the FourWeights version.
       */
      cleanMatrixWeights() {
        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
          if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {
            this._normalizeSkinWeightsAndExtra();
          } else {
            this._normalizeSkinFourWeights();
          }
        }
      }
      // faster 4 weight version.
      _normalizeSkinFourWeights() {
        const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
        const numWeights = matricesWeights.length;
        for (let a = 0; a < numWeights; a += 4) {
          const t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];
          if (t === 0) {
            matricesWeights[a] = 1;
          } else {
            const recip = 1 / t;
            matricesWeights[a] *= recip;
            matricesWeights[a + 1] *= recip;
            matricesWeights[a + 2] *= recip;
            matricesWeights[a + 3] *= recip;
          }
        }
        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);
      }
      // handle special case of extra verts.  (in theory gltf can handle 12 influences)
      _normalizeSkinWeightsAndExtra() {
        const matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);
        const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
        const numWeights = matricesWeights.length;
        for (let a = 0; a < numWeights; a += 4) {
          let t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];
          t += matricesWeightsExtra[a] + matricesWeightsExtra[a + 1] + matricesWeightsExtra[a + 2] + matricesWeightsExtra[a + 3];
          if (t === 0) {
            matricesWeights[a] = 1;
          } else {
            const recip = 1 / t;
            matricesWeights[a] *= recip;
            matricesWeights[a + 1] *= recip;
            matricesWeights[a + 2] *= recip;
            matricesWeights[a + 3] *= recip;
            matricesWeightsExtra[a] *= recip;
            matricesWeightsExtra[a + 1] *= recip;
            matricesWeightsExtra[a + 2] *= recip;
            matricesWeightsExtra[a + 3] *= recip;
          }
        }
        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);
        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsExtra);
      }
      /**
       * ValidateSkinning is used to determine that a mesh has valid skinning data along with skin metrics, if missing weights,
       * or not normalized it is returned as invalid mesh the string can be used for console logs, or on screen messages to let
       * the user know there was an issue with importing the mesh
       * @returns a validation object with skinned, valid and report string
       */
      validateSkinning() {
        const matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);
        const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
        if (matricesWeights === null || this.skeleton == null) {
          return { skinned: false, valid: true, report: "not skinned" };
        }
        const numWeights = matricesWeights.length;
        let numberNotSorted = 0;
        let missingWeights = 0;
        let maxUsedWeights = 0;
        let numberNotNormalized = 0;
        const numInfluences = matricesWeightsExtra === null ? 4 : 8;
        const usedWeightCounts = [];
        for (let a = 0; a <= numInfluences; a++) {
          usedWeightCounts[a] = 0;
        }
        const toleranceEpsilon = 1e-3;
        for (let a = 0; a < numWeights; a += 4) {
          let lastWeight = matricesWeights[a];
          let t = lastWeight;
          let usedWeights = t === 0 ? 0 : 1;
          for (let b = 1; b < numInfluences; b++) {
            const d = b < 4 ? matricesWeights[a + b] : matricesWeightsExtra[a + b - 4];
            if (d > lastWeight) {
              numberNotSorted++;
            }
            if (d !== 0) {
              usedWeights++;
            }
            t += d;
            lastWeight = d;
          }
          usedWeightCounts[usedWeights]++;
          if (usedWeights > maxUsedWeights) {
            maxUsedWeights = usedWeights;
          }
          if (t === 0) {
            missingWeights++;
          } else {
            const recip = 1 / t;
            let tolerance = 0;
            for (let b = 0; b < numInfluences; b++) {
              if (b < 4) {
                tolerance += Math.abs(matricesWeights[a + b] - matricesWeights[a + b] * recip);
              } else {
                tolerance += Math.abs(matricesWeightsExtra[a + b - 4] - matricesWeightsExtra[a + b - 4] * recip);
              }
            }
            if (tolerance > toleranceEpsilon) {
              numberNotNormalized++;
            }
          }
        }
        const numBones = this.skeleton.bones.length;
        const matricesIndices = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
        const matricesIndicesExtra = this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);
        let numBadBoneIndices = 0;
        for (let a = 0; a < numWeights; a += 4) {
          for (let b = 0; b < numInfluences; b++) {
            const index = b < 4 ? matricesIndices[a + b] : matricesIndicesExtra[a + b - 4];
            if (index >= numBones || index < 0) {
              numBadBoneIndices++;
            }
          }
        }
        const output = "Number of Weights = " + numWeights / 4 + "\nMaximum influences = " + maxUsedWeights + "\nMissing Weights = " + missingWeights + "\nNot Sorted = " + numberNotSorted + "\nNot Normalized = " + numberNotNormalized + "\nWeightCounts = [" + usedWeightCounts + "]\nNumber of bones = " + numBones + "\nBad Bone Indices = " + numBadBoneIndices;
        return { skinned: true, valid: missingWeights === 0 && numberNotNormalized === 0 && numBadBoneIndices === 0, report: output };
      }
      /** @internal */
      _checkDelayState() {
        const scene = this.getScene();
        if (this._geometry) {
          this._geometry.load(scene);
        } else if (this.delayLoadState === 4) {
          this.delayLoadState = 2;
          this._queueLoad(scene);
        }
        return this;
      }
      _queueLoad(scene) {
        scene.addPendingData(this);
        const getBinaryData = this.delayLoadingFile.indexOf(".babylonbinarymeshdata") !== -1;
        Tools.LoadFile(this.delayLoadingFile, (data) => {
          if (data instanceof ArrayBuffer) {
            this._delayLoadingFunction(data, this);
          } else {
            this._delayLoadingFunction(JSON.parse(data), this);
          }
          for (const instance of this.instances) {
            instance.refreshBoundingInfo();
            instance._syncSubMeshes();
          }
          this.delayLoadState = 1;
          scene.removePendingData(this);
        }, () => {
        }, scene.offlineProvider, getBinaryData);
        return this;
      }
      /**
       * Returns `true` if the mesh is within the frustum defined by the passed array of planes.
       * A mesh is in the frustum if its bounding box intersects the frustum
       * @param frustumPlanes defines the frustum to test
       * @returns true if the mesh is in the frustum planes
       */
      isInFrustum(frustumPlanes) {
        if (this.delayLoadState === 2) {
          return false;
        }
        if (!super.isInFrustum(frustumPlanes)) {
          return false;
        }
        this._checkDelayState();
        return true;
      }
      /**
       * Sets the mesh material by the material or multiMaterial `id` property
       * @param id is a string identifying the material or the multiMaterial
       * @returns the current mesh
       */
      setMaterialById(id) {
        const materials = this.getScene().materials;
        let index;
        for (index = materials.length - 1; index > -1; index--) {
          if (materials[index].id === id) {
            this.material = materials[index];
            return this;
          }
        }
        const multiMaterials = this.getScene().multiMaterials;
        for (index = multiMaterials.length - 1; index > -1; index--) {
          if (multiMaterials[index].id === id) {
            this.material = multiMaterials[index];
            return this;
          }
        }
        return this;
      }
      /**
       * Returns as a new array populated with the mesh material and/or skeleton, if any.
       * @returns an array of IAnimatable
       */
      getAnimatables() {
        const results = [];
        if (this.material) {
          results.push(this.material);
        }
        if (this.skeleton) {
          results.push(this.skeleton);
        }
        return results;
      }
      /**
       * Modifies the mesh geometry according to the passed transformation matrix.
       * This method returns nothing, but it really modifies the mesh even if it's originally not set as updatable.
       * The mesh normals are modified using the same transformation.
       * Note that, under the hood, this method sets a new VertexBuffer each call.
       * @param transform defines the transform matrix to use
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/bakingTransforms
       * @returns the current mesh
       */
      bakeTransformIntoVertices(transform) {
        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
          return this;
        }
        const submeshes = this.subMeshes.splice(0);
        this._resetPointsArrayCache();
        let data = this.getVerticesData(VertexBuffer.PositionKind);
        const temp = Vector3.Zero();
        let index;
        for (index = 0; index < data.length; index += 3) {
          Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], transform, temp).toArray(data, index);
        }
        this.setVerticesData(VertexBuffer.PositionKind, data, this.getVertexBuffer(VertexBuffer.PositionKind).isUpdatable());
        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          data = this.getVerticesData(VertexBuffer.NormalKind);
          for (index = 0; index < data.length; index += 3) {
            Vector3.TransformNormalFromFloatsToRef(data[index], data[index + 1], data[index + 2], transform, temp).normalize().toArray(data, index);
          }
          this.setVerticesData(VertexBuffer.NormalKind, data, this.getVertexBuffer(VertexBuffer.NormalKind).isUpdatable());
        }
        if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {
          data = this.getVerticesData(VertexBuffer.TangentKind);
          for (index = 0; index < data.length; index += 4) {
            Vector3.TransformNormalFromFloatsToRef(data[index], data[index + 1], data[index + 2], transform, temp).normalize().toArray(data, index);
          }
          this.setVerticesData(VertexBuffer.TangentKind, data, this.getVertexBuffer(VertexBuffer.TangentKind).isUpdatable());
        }
        if (transform.determinant() < 0) {
          this.flipFaces();
        }
        this.releaseSubMeshes();
        this.subMeshes = submeshes;
        return this;
      }
      /**
       * Modifies the mesh geometry according to its own current World Matrix.
       * The mesh World Matrix is then reset.
       * This method returns nothing but really modifies the mesh even if it's originally not set as updatable.
       * Note that, under the hood, this method sets a new VertexBuffer each call.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/bakingTransforms
       * @param bakeIndependentlyOfChildren indicates whether to preserve all child nodes' World Matrix during baking
       * @param forceUnique indicates whether to force the mesh geometry to be unique
       * @returns the current mesh
       */
      bakeCurrentTransformIntoVertices(bakeIndependentlyOfChildren = true, forceUnique = false) {
        if (forceUnique) {
          this.makeGeometryUnique();
        }
        this.bakeTransformIntoVertices(this.computeWorldMatrix(true));
        this.resetLocalMatrix(bakeIndependentlyOfChildren);
        return this;
      }
      // Cache
      /** @internal */
      get _positions() {
        return this._internalAbstractMeshDataInfo._positions || this._geometry && this._geometry._positions || null;
      }
      /** @internal */
      _resetPointsArrayCache() {
        if (this._geometry) {
          this._geometry._resetPointsArrayCache();
        }
        return this;
      }
      /** @internal */
      _generatePointsArray() {
        if (this._geometry) {
          return this._geometry._generatePointsArray();
        }
        return false;
      }
      /**
       * Returns a new Mesh object generated from the current mesh properties.
       * This method must not get confused with createInstance()
       * @param name is a string, the name given to the new mesh
       * @param newParent can be any Node object (default `null`) or an instance of MeshCloneOptions. If the latter, doNotCloneChildren and clonePhysicsImpostor are unused.
       * @param doNotCloneChildren allows/denies the recursive cloning of the original mesh children if any (default `false`)
       * @param clonePhysicsImpostor allows/denies the cloning in the same time of the original mesh `body` used by the physics engine, if any (default `true`)
       * @returns a new mesh
       */
      clone(name = "", newParent = null, doNotCloneChildren, clonePhysicsImpostor = true) {
        if (newParent && newParent._addToSceneRootNodes === void 0) {
          const cloneOptions = newParent;
          MeshCreationOptions.source = this;
          MeshCreationOptions.doNotCloneChildren = cloneOptions.doNotCloneChildren;
          MeshCreationOptions.clonePhysicsImpostor = cloneOptions.clonePhysicsImpostor;
          MeshCreationOptions.cloneThinInstances = cloneOptions.cloneThinInstances;
          return new _Mesh(name, this.getScene(), MeshCreationOptions);
        }
        return new _Mesh(name, this.getScene(), newParent, this, doNotCloneChildren, clonePhysicsImpostor);
      }
      /**
       * Releases resources associated with this mesh.
       * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
       * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
       */
      dispose(doNotRecurse, disposeMaterialAndTextures = false) {
        this.morphTargetManager = null;
        if (this._geometry) {
          this._geometry.releaseForMesh(this, true);
        }
        const internalDataInfo = this._internalMeshDataInfo;
        if (internalDataInfo._onBeforeDrawObservable) {
          internalDataInfo._onBeforeDrawObservable.clear();
        }
        if (internalDataInfo._onBeforeBindObservable) {
          internalDataInfo._onBeforeBindObservable.clear();
        }
        if (internalDataInfo._onBeforeRenderObservable) {
          internalDataInfo._onBeforeRenderObservable.clear();
        }
        if (internalDataInfo._onAfterRenderObservable) {
          internalDataInfo._onAfterRenderObservable.clear();
        }
        if (internalDataInfo._onBetweenPassObservable) {
          internalDataInfo._onBetweenPassObservable.clear();
        }
        if (this._scene.useClonedMeshMap) {
          if (internalDataInfo.meshMap) {
            for (const uniqueId in internalDataInfo.meshMap) {
              const mesh = internalDataInfo.meshMap[uniqueId];
              if (mesh) {
                mesh._internalMeshDataInfo._source = null;
                internalDataInfo.meshMap[uniqueId] = void 0;
              }
            }
          }
          if (internalDataInfo._source && internalDataInfo._source._internalMeshDataInfo.meshMap) {
            internalDataInfo._source._internalMeshDataInfo.meshMap[this.uniqueId] = void 0;
          }
        } else {
          const meshes = this.getScene().meshes;
          for (const abstractMesh of meshes) {
            const mesh = abstractMesh;
            if (mesh._internalMeshDataInfo && mesh._internalMeshDataInfo._source && mesh._internalMeshDataInfo._source === this) {
              mesh._internalMeshDataInfo._source = null;
            }
          }
        }
        internalDataInfo._source = null;
        this._disposeInstanceSpecificData();
        this._disposeThinInstanceSpecificData();
        if (this._internalMeshDataInfo._checkReadinessObserver) {
          this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);
        }
        super.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
      /** @internal */
      _disposeInstanceSpecificData() {
      }
      /** @internal */
      _disposeThinInstanceSpecificData() {
      }
      /** @internal */
      _invalidateInstanceVertexArrayObject() {
      }
      /**
       * Modifies the mesh geometry according to a displacement map.
       * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.
       * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.
       * @param url is a string, the URL from the image file is to be downloaded.
       * @param minHeight is the lower limit of the displacement.
       * @param maxHeight is the upper limit of the displacement.
       * @param onSuccess is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.
       * @param uvOffset is an optional vector2 used to offset UV.
       * @param uvScale is an optional vector2 used to scale UV.
       * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.
       * @param onError defines a callback called when an error occurs during the processing of the request.
       * @returns the Mesh.
       */
      applyDisplacementMap(url, minHeight, maxHeight, onSuccess, uvOffset, uvScale, forceUpdate = false, onError) {
        const scene = this.getScene();
        const onload = (img) => {
          const heightMapWidth = img.width;
          const heightMapHeight = img.height;
          const canvas = this.getEngine().createCanvas(heightMapWidth, heightMapHeight);
          const context = canvas.getContext("2d");
          context.drawImage(img, 0, 0);
          const buffer = context.getImageData(0, 0, heightMapWidth, heightMapHeight).data;
          this.applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate);
          if (onSuccess) {
            onSuccess(this);
          }
        };
        Tools.LoadImage(url, onload, onError ? onError : () => {
        }, scene.offlineProvider);
        return this;
      }
      /**
       * Modifies the mesh geometry according to a displacementMap buffer.
       * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.
       * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.
       * @param buffer is a `Uint8Array` buffer containing series of `Uint8` lower than 255, the red, green, blue and alpha values of each successive pixel.
       * @param heightMapWidth is the width of the buffer image.
       * @param heightMapHeight is the height of the buffer image.
       * @param minHeight is the lower limit of the displacement.
       * @param maxHeight is the upper limit of the displacement.
       * @param uvOffset is an optional vector2 used to offset UV.
       * @param uvScale is an optional vector2 used to scale UV.
       * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.
       * @returns the Mesh.
       */
      applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate = false) {
        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind) || !this.isVerticesDataPresent(VertexBuffer.NormalKind) || !this.isVerticesDataPresent(VertexBuffer.UVKind)) {
          Logger.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing");
          return this;
        }
        const positions = this.getVerticesData(VertexBuffer.PositionKind, true, true);
        const normals = this.getVerticesData(VertexBuffer.NormalKind);
        const uvs = this.getVerticesData(VertexBuffer.UVKind);
        let position = Vector3.Zero();
        const normal = Vector3.Zero();
        const uv = Vector2.Zero();
        uvOffset = uvOffset || Vector2.Zero();
        uvScale = uvScale || new Vector2(1, 1);
        for (let index = 0; index < positions.length; index += 3) {
          Vector3.FromArrayToRef(positions, index, position);
          Vector3.FromArrayToRef(normals, index, normal);
          Vector2.FromArrayToRef(uvs, index / 3 * 2, uv);
          const u = Math.abs(uv.x * uvScale.x + uvOffset.x % 1) * (heightMapWidth - 1) % heightMapWidth | 0;
          const v = Math.abs(uv.y * uvScale.y + uvOffset.y % 1) * (heightMapHeight - 1) % heightMapHeight | 0;
          const pos = (u + v * heightMapWidth) * 4;
          const r = buffer[pos] / 255;
          const g = buffer[pos + 1] / 255;
          const b = buffer[pos + 2] / 255;
          const gradient = r * 0.3 + g * 0.59 + b * 0.11;
          normal.normalize();
          normal.scaleInPlace(minHeight + (maxHeight - minHeight) * gradient);
          position = position.add(normal);
          position.toArray(positions, index);
        }
        VertexData.ComputeNormals(positions, this.getIndices(), normals);
        if (forceUpdate) {
          this.setVerticesData(VertexBuffer.PositionKind, positions);
          this.setVerticesData(VertexBuffer.NormalKind, normals);
          this.setVerticesData(VertexBuffer.UVKind, uvs);
        } else {
          this.updateVerticesData(VertexBuffer.PositionKind, positions);
          this.updateVerticesData(VertexBuffer.NormalKind, normals);
        }
        return this;
      }
      _getFlattenedNormals(indices, positions) {
        const normals = new Float32Array(indices.length * 3);
        let normalsCount = 0;
        const flipNormalGeneration = this.sideOrientation === (this._scene.useRightHandedSystem ? 1 : 0);
        for (let index = 0; index < indices.length; index += 3) {
          const p1 = Vector3.FromArray(positions, indices[index] * 3);
          const p2 = Vector3.FromArray(positions, indices[index + 1] * 3);
          const p3 = Vector3.FromArray(positions, indices[index + 2] * 3);
          const p1p2 = p1.subtract(p2);
          const p3p2 = p3.subtract(p2);
          const normal = Vector3.Normalize(Vector3.Cross(p1p2, p3p2));
          if (flipNormalGeneration) {
            normal.scaleInPlace(-1);
          }
          for (let localIndex = 0; localIndex < 3; localIndex++) {
            normals[normalsCount++] = normal.x;
            normals[normalsCount++] = normal.y;
            normals[normalsCount++] = normal.z;
          }
        }
        return normals;
      }
      _convertToUnIndexedMesh(flattenNormals = false) {
        const kinds = this.getVerticesDataKinds().filter((kind) => !this.getVertexBuffer(kind)?.getIsInstanced());
        const indices = this.getIndices(false, true);
        const data = {};
        const separateVertices = (data2, size) => {
          const newData = new Float32Array(indices.length * size);
          let count = 0;
          for (let index = 0; index < indices.length; index++) {
            for (let offset = 0; offset < size; offset++) {
              newData[count++] = data2[indices[index] * size + offset];
            }
          }
          return newData;
        };
        const meshBoundingInfo = this.getBoundingInfo();
        const previousSubmeshes = this.geometry ? this.subMeshes.slice(0) : [];
        for (const kind of kinds) {
          data[kind] = this.getVerticesData(kind);
        }
        for (const kind of kinds) {
          const vertexBuffer = this.getVertexBuffer(kind);
          const size = vertexBuffer.getSize();
          if (flattenNormals && kind === VertexBuffer.NormalKind) {
            const normals = this._getFlattenedNormals(indices, data[VertexBuffer.PositionKind]);
            this.setVerticesData(VertexBuffer.NormalKind, normals, vertexBuffer.isUpdatable(), size);
          } else {
            this.setVerticesData(kind, separateVertices(data[kind], size), vertexBuffer.isUpdatable(), size);
          }
        }
        if (this.morphTargetManager) {
          for (let targetIndex = 0; targetIndex < this.morphTargetManager.numTargets; targetIndex++) {
            const target = this.morphTargetManager.getTarget(targetIndex);
            const positions = target.getPositions();
            target.setPositions(separateVertices(positions, 3));
            const normals = target.getNormals();
            if (normals) {
              target.setNormals(flattenNormals ? this._getFlattenedNormals(indices, positions) : separateVertices(normals, 3));
            }
            const tangents = target.getTangents();
            if (tangents) {
              target.setTangents(separateVertices(tangents, 3));
            }
            const uvs = target.getUVs();
            if (uvs) {
              target.setUVs(separateVertices(uvs, 2));
            }
            const colors = target.getColors();
            if (colors) {
              target.setColors(separateVertices(colors, 4));
            }
          }
          this.morphTargetManager.synchronize();
        }
        for (let index = 0; index < indices.length; index++) {
          indices[index] = index;
        }
        this.setIndices(indices);
        this._unIndexed = true;
        this.releaseSubMeshes();
        for (const previousOne of previousSubmeshes) {
          const boundingInfo = previousOne.getBoundingInfo();
          const subMesh = SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);
          subMesh.setBoundingInfo(boundingInfo);
        }
        this.setBoundingInfo(meshBoundingInfo);
        this.synchronizeInstances();
        return this;
      }
      /**
       * Modify the mesh to get a flat shading rendering.
       * This means each mesh facet will then have its own normals. Usually new vertices are added in the mesh geometry to get this result.
       * Warning : the mesh is really modified even if not set originally as updatable and, under the hood, a new VertexBuffer is allocated.
       * @returns current mesh
       */
      convertToFlatShadedMesh() {
        return this._convertToUnIndexedMesh(true);
      }
      /**
       * This method removes all the mesh indices and add new vertices (duplication) in order to unfold facets into buffers.
       * In other words, more vertices, no more indices and a single bigger VBO.
       * The mesh is really modified even if not set originally as updatable. Under the hood, a new VertexBuffer is allocated.
       * @returns current mesh
       */
      convertToUnIndexedMesh() {
        return this._convertToUnIndexedMesh();
      }
      /**
       * Inverses facet orientations.
       * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.
       * @param flipNormals will also inverts the normals
       * @returns current mesh
       */
      flipFaces(flipNormals = false) {
        const vertexData = VertexData.ExtractFromMesh(this);
        let i;
        if (flipNormals && this.isVerticesDataPresent(VertexBuffer.NormalKind) && vertexData.normals) {
          for (i = 0; i < vertexData.normals.length; i++) {
            vertexData.normals[i] *= -1;
          }
          this.setVerticesData(VertexBuffer.NormalKind, vertexData.normals, this.isVertexBufferUpdatable(VertexBuffer.NormalKind));
        }
        if (vertexData.indices) {
          let temp;
          for (i = 0; i < vertexData.indices.length; i += 3) {
            temp = vertexData.indices[i + 1];
            vertexData.indices[i + 1] = vertexData.indices[i + 2];
            vertexData.indices[i + 2] = temp;
          }
          this.setIndices(vertexData.indices, null, this.isVertexBufferUpdatable(VertexBuffer.PositionKind), true);
        }
        return this;
      }
      /**
       * Increase the number of facets and hence vertices in a mesh
       * Vertex normals are interpolated from existing vertex normals
       * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.
       * @param numberPerEdge the number of new vertices to add to each edge of a facet, optional default 1
       */
      increaseVertices(numberPerEdge = 1) {
        const vertexData = VertexData.ExtractFromMesh(this);
        const currentIndices = vertexData.indices && !Array.isArray(vertexData.indices) && Array.from ? Array.from(vertexData.indices) : vertexData.indices;
        const positions = vertexData.positions && !Array.isArray(vertexData.positions) && Array.from ? Array.from(vertexData.positions) : vertexData.positions;
        const uvs = vertexData.uvs && !Array.isArray(vertexData.uvs) && Array.from ? Array.from(vertexData.uvs) : vertexData.uvs;
        const normals = vertexData.normals && !Array.isArray(vertexData.normals) && Array.from ? Array.from(vertexData.normals) : vertexData.normals;
        if (!currentIndices || !positions) {
          Logger.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions");
        } else {
          vertexData.indices = currentIndices;
          vertexData.positions = positions;
          if (uvs) {
            vertexData.uvs = uvs;
          }
          if (normals) {
            vertexData.normals = normals;
          }
          const segments = numberPerEdge + 1;
          const tempIndices = [];
          for (let i = 0; i < segments + 1; i++) {
            tempIndices[i] = [];
          }
          let a;
          let b;
          const deltaPosition = new Vector3(0, 0, 0);
          const deltaNormal = new Vector3(0, 0, 0);
          const deltaUV = new Vector2(0, 0);
          const indices = [];
          const vertexIndex = [];
          const side = [];
          let len;
          let positionPtr = positions.length;
          let uvPtr;
          if (uvs) {
            uvPtr = uvs.length;
          }
          let normalsPtr;
          if (normals) {
            normalsPtr = normals.length;
          }
          for (let i = 0; i < currentIndices.length; i += 3) {
            vertexIndex[0] = currentIndices[i];
            vertexIndex[1] = currentIndices[i + 1];
            vertexIndex[2] = currentIndices[i + 2];
            for (let j = 0; j < 3; j++) {
              a = vertexIndex[j];
              b = vertexIndex[(j + 1) % 3];
              if (side[a] === void 0 && side[b] === void 0) {
                side[a] = [];
                side[b] = [];
              } else {
                if (side[a] === void 0) {
                  side[a] = [];
                }
                if (side[b] === void 0) {
                  side[b] = [];
                }
              }
              if (side[a][b] === void 0 && side[b][a] === void 0) {
                side[a][b] = [];
                deltaPosition.x = (positions[3 * b] - positions[3 * a]) / segments;
                deltaPosition.y = (positions[3 * b + 1] - positions[3 * a + 1]) / segments;
                deltaPosition.z = (positions[3 * b + 2] - positions[3 * a + 2]) / segments;
                if (normals) {
                  deltaNormal.x = (normals[3 * b] - normals[3 * a]) / segments;
                  deltaNormal.y = (normals[3 * b + 1] - normals[3 * a + 1]) / segments;
                  deltaNormal.z = (normals[3 * b + 2] - normals[3 * a + 2]) / segments;
                }
                if (uvs) {
                  deltaUV.x = (uvs[2 * b] - uvs[2 * a]) / segments;
                  deltaUV.y = (uvs[2 * b + 1] - uvs[2 * a + 1]) / segments;
                }
                side[a][b].push(a);
                for (let k = 1; k < segments; k++) {
                  side[a][b].push(positions.length / 3);
                  positions[positionPtr++] = positions[3 * a] + k * deltaPosition.x;
                  positions[positionPtr++] = positions[3 * a + 1] + k * deltaPosition.y;
                  positions[positionPtr++] = positions[3 * a + 2] + k * deltaPosition.z;
                  if (normals) {
                    normals[normalsPtr++] = normals[3 * a] + k * deltaNormal.x;
                    normals[normalsPtr++] = normals[3 * a + 1] + k * deltaNormal.y;
                    normals[normalsPtr++] = normals[3 * a + 2] + k * deltaNormal.z;
                  }
                  if (uvs) {
                    uvs[uvPtr++] = uvs[2 * a] + k * deltaUV.x;
                    uvs[uvPtr++] = uvs[2 * a + 1] + k * deltaUV.y;
                  }
                }
                side[a][b].push(b);
                side[b][a] = [];
                len = side[a][b].length;
                for (let idx = 0; idx < len; idx++) {
                  side[b][a][idx] = side[a][b][len - 1 - idx];
                }
              }
            }
            tempIndices[0][0] = currentIndices[i];
            tempIndices[1][0] = side[currentIndices[i]][currentIndices[i + 1]][1];
            tempIndices[1][1] = side[currentIndices[i]][currentIndices[i + 2]][1];
            for (let k = 2; k < segments; k++) {
              tempIndices[k][0] = side[currentIndices[i]][currentIndices[i + 1]][k];
              tempIndices[k][k] = side[currentIndices[i]][currentIndices[i + 2]][k];
              deltaPosition.x = (positions[3 * tempIndices[k][k]] - positions[3 * tempIndices[k][0]]) / k;
              deltaPosition.y = (positions[3 * tempIndices[k][k] + 1] - positions[3 * tempIndices[k][0] + 1]) / k;
              deltaPosition.z = (positions[3 * tempIndices[k][k] + 2] - positions[3 * tempIndices[k][0] + 2]) / k;
              if (normals) {
                deltaNormal.x = (normals[3 * tempIndices[k][k]] - normals[3 * tempIndices[k][0]]) / k;
                deltaNormal.y = (normals[3 * tempIndices[k][k] + 1] - normals[3 * tempIndices[k][0] + 1]) / k;
                deltaNormal.z = (normals[3 * tempIndices[k][k] + 2] - normals[3 * tempIndices[k][0] + 2]) / k;
              }
              if (uvs) {
                deltaUV.x = (uvs[2 * tempIndices[k][k]] - uvs[2 * tempIndices[k][0]]) / k;
                deltaUV.y = (uvs[2 * tempIndices[k][k] + 1] - uvs[2 * tempIndices[k][0] + 1]) / k;
              }
              for (let j = 1; j < k; j++) {
                tempIndices[k][j] = positions.length / 3;
                positions[positionPtr++] = positions[3 * tempIndices[k][0]] + j * deltaPosition.x;
                positions[positionPtr++] = positions[3 * tempIndices[k][0] + 1] + j * deltaPosition.y;
                positions[positionPtr++] = positions[3 * tempIndices[k][0] + 2] + j * deltaPosition.z;
                if (normals) {
                  normals[normalsPtr++] = normals[3 * tempIndices[k][0]] + j * deltaNormal.x;
                  normals[normalsPtr++] = normals[3 * tempIndices[k][0] + 1] + j * deltaNormal.y;
                  normals[normalsPtr++] = normals[3 * tempIndices[k][0] + 2] + j * deltaNormal.z;
                }
                if (uvs) {
                  uvs[uvPtr++] = uvs[2 * tempIndices[k][0]] + j * deltaUV.x;
                  uvs[uvPtr++] = uvs[2 * tempIndices[k][0] + 1] + j * deltaUV.y;
                }
              }
            }
            tempIndices[segments] = side[currentIndices[i + 1]][currentIndices[i + 2]];
            indices.push(tempIndices[0][0], tempIndices[1][0], tempIndices[1][1]);
            for (let k = 1; k < segments; k++) {
              let j;
              for (j = 0; j < k; j++) {
                indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);
                indices.push(tempIndices[k][j], tempIndices[k + 1][j + 1], tempIndices[k][j + 1]);
              }
              indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);
            }
          }
          vertexData.indices = indices;
          vertexData.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
        }
      }
      /**
       * Force adjacent facets to share vertices and remove any facets that have all vertices in a line
       * This will undo any application of covertToFlatShadedMesh
       * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.
       */
      forceSharedVertices() {
        const vertexData = VertexData.ExtractFromMesh(this);
        const currentUVs = vertexData.uvs;
        const currentIndices = vertexData.indices;
        const currentPositions = vertexData.positions;
        const currentColors = vertexData.colors;
        const currentMatrixIndices = vertexData.matricesIndices;
        const currentMatrixWeights = vertexData.matricesWeights;
        const currentMatrixIndicesExtra = vertexData.matricesIndicesExtra;
        const currentMatrixWeightsExtra = vertexData.matricesWeightsExtra;
        if (currentIndices === void 0 || currentPositions === void 0 || currentIndices === null || currentPositions === null) {
          Logger.Warn("VertexData contains empty entries");
        } else {
          const positions = [];
          const indices = [];
          const uvs = [];
          const colors = [];
          const matrixIndices = [];
          const matrixWeights = [];
          const matrixIndicesExtra = [];
          const matrixWeightsExtra = [];
          let pstring = [];
          let indexPtr = 0;
          const uniquePositions = {};
          let ptr;
          let facet;
          for (let i = 0; i < currentIndices.length; i += 3) {
            facet = [currentIndices[i], currentIndices[i + 1], currentIndices[i + 2]];
            pstring = [];
            for (let j = 0; j < 3; j++) {
              pstring[j] = "";
              for (let k = 0; k < 3; k++) {
                if (Math.abs(currentPositions[3 * facet[j] + k]) < 1e-8) {
                  currentPositions[3 * facet[j] + k] = 0;
                }
                pstring[j] += currentPositions[3 * facet[j] + k] + "|";
              }
            }
            if (!(pstring[0] == pstring[1] || pstring[0] == pstring[2] || pstring[1] == pstring[2])) {
              for (let j = 0; j < 3; j++) {
                ptr = uniquePositions[pstring[j]];
                if (ptr === void 0) {
                  uniquePositions[pstring[j]] = indexPtr;
                  ptr = indexPtr++;
                  for (let k = 0; k < 3; k++) {
                    positions.push(currentPositions[3 * facet[j] + k]);
                  }
                  if (currentColors !== null && currentColors !== void 0) {
                    for (let k = 0; k < 4; k++) {
                      colors.push(currentColors[4 * facet[j] + k]);
                    }
                  }
                  if (currentUVs !== null && currentUVs !== void 0) {
                    for (let k = 0; k < 2; k++) {
                      uvs.push(currentUVs[2 * facet[j] + k]);
                    }
                  }
                  if (currentMatrixIndices !== null && currentMatrixIndices !== void 0) {
                    for (let k = 0; k < 4; k++) {
                      matrixIndices.push(currentMatrixIndices[4 * facet[j] + k]);
                    }
                  }
                  if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {
                    for (let k = 0; k < 4; k++) {
                      matrixWeights.push(currentMatrixWeights[4 * facet[j] + k]);
                    }
                  }
                  if (currentMatrixIndicesExtra !== null && currentMatrixIndicesExtra !== void 0) {
                    for (let k = 0; k < 4; k++) {
                      matrixIndicesExtra.push(currentMatrixIndicesExtra[4 * facet[j] + k]);
                    }
                  }
                  if (currentMatrixWeightsExtra !== null && currentMatrixWeightsExtra !== void 0) {
                    for (let k = 0; k < 4; k++) {
                      matrixWeightsExtra.push(currentMatrixWeightsExtra[4 * facet[j] + k]);
                    }
                  }
                }
                indices.push(ptr);
              }
            }
          }
          const normals = [];
          VertexData.ComputeNormals(positions, indices, normals);
          vertexData.positions = positions;
          vertexData.indices = indices;
          vertexData.normals = normals;
          if (currentUVs !== null && currentUVs !== void 0) {
            vertexData.uvs = uvs;
          }
          if (currentColors !== null && currentColors !== void 0) {
            vertexData.colors = colors;
          }
          if (currentMatrixIndices !== null && currentMatrixIndices !== void 0) {
            vertexData.matricesIndices = matrixIndices;
          }
          if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {
            vertexData.matricesWeights = matrixWeights;
          }
          if (currentMatrixIndicesExtra !== null && currentMatrixIndicesExtra !== void 0) {
            vertexData.matricesIndicesExtra = matrixIndicesExtra;
          }
          if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {
            vertexData.matricesWeightsExtra = matrixWeightsExtra;
          }
          vertexData.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
        }
      }
      // Instances
      /**
       * @internal
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/naming-convention
      static _instancedMeshFactory(name, mesh) {
        throw _WarnImport("InstancedMesh");
      }
      /**
       * @internal
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      static _PhysicsImpostorParser(scene, physicObject, jsonObject) {
        throw _WarnImport("PhysicsImpostor");
      }
      /**
       * Creates a new InstancedMesh object from the mesh model.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances
       * @param name defines the name of the new instance
       * @returns a new InstancedMesh
       */
      createInstance(name) {
        const instance = _Mesh._instancedMeshFactory(name, this);
        instance.parent = this.parent;
        return instance;
      }
      /**
       * Synchronises all the mesh instance submeshes to the current mesh submeshes, if any.
       * After this call, all the mesh instances have the same submeshes than the current mesh.
       * @returns the current mesh
       */
      synchronizeInstances() {
        for (let instanceIndex = 0; instanceIndex < this.instances.length; instanceIndex++) {
          const instance = this.instances[instanceIndex];
          instance._syncSubMeshes();
        }
        return this;
      }
      /**
       * Optimization of the mesh's indices, in case a mesh has duplicated vertices.
       * The function will only reorder the indices and will not remove unused vertices to avoid problems with submeshes.
       * This should be used together with the simplification to avoid disappearing triangles.
       * @param successCallback an optional success callback to be called after the optimization finished.
       * @returns the current mesh
       */
      optimizeIndices(successCallback) {
        const indices = this.getIndices();
        const positions = this.getVerticesData(VertexBuffer.PositionKind);
        if (!positions || !indices) {
          return this;
        }
        const vectorPositions = [];
        for (let pos = 0; pos < positions.length; pos = pos + 3) {
          vectorPositions.push(Vector3.FromArray(positions, pos));
        }
        const dupes = [];
        AsyncLoop.SyncAsyncForLoop(vectorPositions.length, 40, (iteration) => {
          const realPos = vectorPositions.length - 1 - iteration;
          const testedPosition = vectorPositions[realPos];
          for (let j = 0; j < realPos; ++j) {
            const againstPosition = vectorPositions[j];
            if (testedPosition.equals(againstPosition)) {
              dupes[realPos] = j;
              break;
            }
          }
        }, () => {
          for (let i = 0; i < indices.length; ++i) {
            indices[i] = dupes[indices[i]] || indices[i];
          }
          const originalSubMeshes = this.subMeshes.slice(0);
          this.setIndices(indices);
          this.subMeshes = originalSubMeshes;
          if (successCallback) {
            successCallback(this);
          }
        });
        return this;
      }
      /**
       * Serialize current mesh
       * @param serializationObject defines the object which will receive the serialization data
       * @returns the serialized object
       */
      serialize(serializationObject = {}) {
        serializationObject.name = this.name;
        serializationObject.id = this.id;
        serializationObject.uniqueId = this.uniqueId;
        serializationObject.type = this.getClassName();
        if (Tags && Tags.HasTags(this)) {
          serializationObject.tags = Tags.GetTags(this);
        }
        serializationObject.position = this.position.asArray();
        if (this.rotationQuaternion) {
          serializationObject.rotationQuaternion = this.rotationQuaternion.asArray();
        } else if (this.rotation) {
          serializationObject.rotation = this.rotation.asArray();
        }
        serializationObject.scaling = this.scaling.asArray();
        if (this._postMultiplyPivotMatrix) {
          serializationObject.pivotMatrix = this.getPivotMatrix().asArray();
        } else {
          serializationObject.localMatrix = this.getPivotMatrix().asArray();
        }
        serializationObject.isEnabled = this.isEnabled(false);
        serializationObject.isVisible = this.isVisible;
        serializationObject.infiniteDistance = this.infiniteDistance;
        serializationObject.pickable = this.isPickable;
        serializationObject.receiveShadows = this.receiveShadows;
        serializationObject.billboardMode = this.billboardMode;
        serializationObject.visibility = this.visibility;
        serializationObject.alwaysSelectAsActiveMesh = this.alwaysSelectAsActiveMesh;
        serializationObject.checkCollisions = this.checkCollisions;
        serializationObject.ellipsoid = this.ellipsoid.asArray();
        serializationObject.ellipsoidOffset = this.ellipsoidOffset.asArray();
        serializationObject.doNotSyncBoundingInfo = this.doNotSyncBoundingInfo;
        serializationObject.isBlocker = this.isBlocker;
        serializationObject.sideOrientation = this.sideOrientation;
        if (this.parent) {
          this.parent._serializeAsParent(serializationObject);
        }
        serializationObject.isUnIndexed = this.isUnIndexed;
        const geometry = this._geometry;
        if (geometry && this.subMeshes) {
          serializationObject.geometryUniqueId = geometry.uniqueId;
          serializationObject.geometryId = geometry.id;
          serializationObject.subMeshes = [];
          for (let subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {
            const subMesh = this.subMeshes[subIndex];
            serializationObject.subMeshes.push({
              materialIndex: subMesh.materialIndex,
              verticesStart: subMesh.verticesStart,
              verticesCount: subMesh.verticesCount,
              indexStart: subMesh.indexStart,
              indexCount: subMesh.indexCount
            });
          }
        }
        if (this.material) {
          if (!this.material.doNotSerialize) {
            serializationObject.materialUniqueId = this.material.uniqueId;
            serializationObject.materialId = this.material.id;
          }
        } else {
          this.material = null;
          serializationObject.materialUniqueId = this._scene.defaultMaterial.uniqueId;
          serializationObject.materialId = this._scene.defaultMaterial.id;
        }
        if (this.morphTargetManager) {
          serializationObject.morphTargetManagerId = this.morphTargetManager.uniqueId;
        }
        if (this.skeleton) {
          serializationObject.skeletonId = this.skeleton.id;
          serializationObject.numBoneInfluencers = this.numBoneInfluencers;
        }
        if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {
          const impostor = this.getPhysicsImpostor();
          if (impostor) {
            serializationObject.physicsMass = impostor.getParam("mass");
            serializationObject.physicsFriction = impostor.getParam("friction");
            serializationObject.physicsRestitution = impostor.getParam("mass");
            serializationObject.physicsImpostor = impostor.type;
          }
        }
        if (this.metadata) {
          serializationObject.metadata = this.metadata;
        }
        serializationObject.instances = [];
        for (let index = 0; index < this.instances.length; index++) {
          const instance = this.instances[index];
          if (instance.doNotSerialize) {
            continue;
          }
          const serializationInstance = {
            name: instance.name,
            id: instance.id,
            isEnabled: instance.isEnabled(false),
            isVisible: instance.isVisible,
            isPickable: instance.isPickable,
            checkCollisions: instance.checkCollisions,
            position: instance.position.asArray(),
            scaling: instance.scaling.asArray()
          };
          if (instance.parent) {
            instance.parent._serializeAsParent(serializationInstance);
          }
          if (instance.rotationQuaternion) {
            serializationInstance.rotationQuaternion = instance.rotationQuaternion.asArray();
          } else if (instance.rotation) {
            serializationInstance.rotation = instance.rotation.asArray();
          }
          if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {
            const impostor = instance.getPhysicsImpostor();
            if (impostor) {
              serializationInstance.physicsMass = impostor.getParam("mass");
              serializationInstance.physicsFriction = impostor.getParam("friction");
              serializationInstance.physicsRestitution = impostor.getParam("mass");
              serializationInstance.physicsImpostor = impostor.type;
            }
          }
          if (instance.metadata) {
            serializationInstance.metadata = instance.metadata;
          }
          if (instance.actionManager) {
            serializationInstance.actions = instance.actionManager.serialize(instance.name);
          }
          serializationObject.instances.push(serializationInstance);
          SerializationHelper.AppendSerializedAnimations(instance, serializationInstance);
          serializationInstance.ranges = instance.serializeAnimationRanges();
        }
        if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData) {
          serializationObject.thinInstances = {
            instancesCount: this._thinInstanceDataStorage.instancesCount,
            matrixData: Array.from(this._thinInstanceDataStorage.matrixData),
            matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,
            enablePicking: this.thinInstanceEnablePicking
          };
          if (this._userThinInstanceBuffersStorage) {
            const userThinInstance = {
              data: {},
              sizes: {},
              strides: {}
            };
            for (const kind in this._userThinInstanceBuffersStorage.data) {
              userThinInstance.data[kind] = Array.from(this._userThinInstanceBuffersStorage.data[kind]);
              userThinInstance.sizes[kind] = this._userThinInstanceBuffersStorage.sizes[kind];
              userThinInstance.strides[kind] = this._userThinInstanceBuffersStorage.strides[kind];
            }
            serializationObject.thinInstances.userThinInstance = userThinInstance;
          }
        }
        SerializationHelper.AppendSerializedAnimations(this, serializationObject);
        serializationObject.ranges = this.serializeAnimationRanges();
        serializationObject.layerMask = this.layerMask;
        serializationObject.alphaIndex = this.alphaIndex;
        serializationObject.hasVertexAlpha = this.hasVertexAlpha;
        serializationObject.overlayAlpha = this.overlayAlpha;
        serializationObject.overlayColor = this.overlayColor.asArray();
        serializationObject.renderOverlay = this.renderOverlay;
        serializationObject.applyFog = this.applyFog;
        if (this.actionManager) {
          serializationObject.actions = this.actionManager.serialize(this.name);
        }
        return serializationObject;
      }
      /** @internal */
      _syncGeometryWithMorphTargetManager() {
        if (!this.geometry) {
          return;
        }
        this._markSubMeshesAsAttributesDirty();
        const morphTargetManager = this._internalAbstractMeshDataInfo._morphTargetManager;
        if (morphTargetManager && morphTargetManager.vertexCount) {
          if (morphTargetManager.vertexCount !== this.getTotalVertices()) {
            Logger.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.");
            this.morphTargetManager = null;
            return;
          }
          if (morphTargetManager.isUsingTextureForTargets) {
            return;
          }
          for (let index = 0; index < morphTargetManager.numInfluencers; index++) {
            const morphTarget = morphTargetManager.getActiveTarget(index);
            const positions = morphTarget.getPositions();
            if (!positions) {
              Logger.Error("Invalid morph target. Target must have positions.");
              return;
            }
            this.geometry.setVerticesData(VertexBuffer.PositionKind + index, positions, false, 3);
            const normals = morphTarget.getNormals();
            if (normals) {
              this.geometry.setVerticesData(VertexBuffer.NormalKind + index, normals, false, 3);
            }
            const tangents = morphTarget.getTangents();
            if (tangents) {
              this.geometry.setVerticesData(VertexBuffer.TangentKind + index, tangents, false, 3);
            }
            const uvs = morphTarget.getUVs();
            if (uvs) {
              this.geometry.setVerticesData(VertexBuffer.UVKind + "_" + index, uvs, false, 2);
            }
            const uv2s = morphTarget.getUV2s();
            if (uv2s) {
              this.geometry.setVerticesData(VertexBuffer.UV2Kind + "_" + index, uv2s, false, 2);
            }
            const colors = morphTarget.getColors();
            if (colors) {
              this.geometry.setVerticesData(VertexBuffer.ColorKind + index, colors, false, 4);
            }
          }
        } else {
          let index = 0;
          while (this.geometry.isVerticesDataPresent(VertexBuffer.PositionKind + index)) {
            this.geometry.removeVerticesData(VertexBuffer.PositionKind + index);
            if (this.geometry.isVerticesDataPresent(VertexBuffer.NormalKind + index)) {
              this.geometry.removeVerticesData(VertexBuffer.NormalKind + index);
            }
            if (this.geometry.isVerticesDataPresent(VertexBuffer.TangentKind + index)) {
              this.geometry.removeVerticesData(VertexBuffer.TangentKind + index);
            }
            if (this.geometry.isVerticesDataPresent(VertexBuffer.UVKind + index)) {
              this.geometry.removeVerticesData(VertexBuffer.UVKind + "_" + index);
            }
            if (this.geometry.isVerticesDataPresent(VertexBuffer.UV2Kind + index)) {
              this.geometry.removeVerticesData(VertexBuffer.UV2Kind + "_" + index);
            }
            if (this.geometry.isVerticesDataPresent(VertexBuffer.ColorKind + index)) {
              this.geometry.removeVerticesData(VertexBuffer.ColorKind + index);
            }
            index++;
          }
        }
      }
      /**
       * Returns a new Mesh object parsed from the source provided.
       * @param parsedMesh is the source
       * @param scene defines the hosting scene
       * @param rootUrl is the root URL to prefix the `delayLoadingFile` property with
       * @returns a new Mesh
       */
      static Parse(parsedMesh, scene, rootUrl) {
        let mesh;
        if (parsedMesh.type && parsedMesh.type === "LinesMesh") {
          mesh = _Mesh._LinesMeshParser(parsedMesh, scene);
        } else if (parsedMesh.type && parsedMesh.type === "GroundMesh") {
          mesh = _Mesh._GroundMeshParser(parsedMesh, scene);
        } else if (parsedMesh.type && parsedMesh.type === "GoldbergMesh") {
          mesh = _Mesh._GoldbergMeshParser(parsedMesh, scene);
        } else if (parsedMesh.type && parsedMesh.type === "GreasedLineMesh") {
          mesh = _Mesh._GreasedLineMeshParser(parsedMesh, scene);
        } else if (parsedMesh.type && parsedMesh.type === "TrailMesh") {
          mesh = _Mesh._TrailMeshParser(parsedMesh, scene);
        } else {
          mesh = new _Mesh(parsedMesh.name, scene);
        }
        mesh.id = parsedMesh.id;
        mesh._waitingParsedUniqueId = parsedMesh.uniqueId;
        if (Tags) {
          Tags.AddTagsTo(mesh, parsedMesh.tags);
        }
        mesh.position = Vector3.FromArray(parsedMesh.position);
        if (parsedMesh.metadata !== void 0) {
          mesh.metadata = parsedMesh.metadata;
        }
        if (parsedMesh.rotationQuaternion) {
          mesh.rotationQuaternion = Quaternion.FromArray(parsedMesh.rotationQuaternion);
        } else if (parsedMesh.rotation) {
          mesh.rotation = Vector3.FromArray(parsedMesh.rotation);
        }
        mesh.scaling = Vector3.FromArray(parsedMesh.scaling);
        if (parsedMesh.localMatrix) {
          mesh.setPreTransformMatrix(Matrix.FromArray(parsedMesh.localMatrix));
        } else if (parsedMesh.pivotMatrix) {
          mesh.setPivotMatrix(Matrix.FromArray(parsedMesh.pivotMatrix));
        }
        mesh.setEnabled(parsedMesh.isEnabled);
        mesh.isVisible = parsedMesh.isVisible;
        mesh.infiniteDistance = parsedMesh.infiniteDistance;
        mesh.alwaysSelectAsActiveMesh = !!parsedMesh.alwaysSelectAsActiveMesh;
        mesh.showBoundingBox = parsedMesh.showBoundingBox;
        mesh.showSubMeshesBoundingBox = parsedMesh.showSubMeshesBoundingBox;
        if (parsedMesh.applyFog !== void 0) {
          mesh.applyFog = parsedMesh.applyFog;
        }
        if (parsedMesh.pickable !== void 0) {
          mesh.isPickable = parsedMesh.pickable;
        }
        if (parsedMesh.alphaIndex !== void 0) {
          mesh.alphaIndex = parsedMesh.alphaIndex;
        }
        mesh.receiveShadows = parsedMesh.receiveShadows;
        if (parsedMesh.billboardMode !== void 0) {
          mesh.billboardMode = parsedMesh.billboardMode;
        }
        if (parsedMesh.visibility !== void 0) {
          mesh.visibility = parsedMesh.visibility;
        }
        mesh.checkCollisions = parsedMesh.checkCollisions;
        mesh.doNotSyncBoundingInfo = !!parsedMesh.doNotSyncBoundingInfo;
        if (parsedMesh.ellipsoid) {
          mesh.ellipsoid = Vector3.FromArray(parsedMesh.ellipsoid);
        }
        if (parsedMesh.ellipsoidOffset) {
          mesh.ellipsoidOffset = Vector3.FromArray(parsedMesh.ellipsoidOffset);
        }
        if (parsedMesh.overrideMaterialSideOrientation != null) {
          mesh.sideOrientation = parsedMesh.overrideMaterialSideOrientation;
        }
        if (parsedMesh.sideOrientation !== void 0) {
          mesh.sideOrientation = parsedMesh.sideOrientation;
        }
        if (parsedMesh.isBlocker !== void 0) {
          mesh.isBlocker = parsedMesh.isBlocker;
        }
        mesh._shouldGenerateFlatShading = parsedMesh.useFlatShading;
        if (parsedMesh.freezeWorldMatrix) {
          mesh._waitingData.freezeWorldMatrix = parsedMesh.freezeWorldMatrix;
        }
        if (parsedMesh.parentId !== void 0) {
          mesh._waitingParentId = parsedMesh.parentId;
        }
        if (parsedMesh.parentInstanceIndex !== void 0) {
          mesh._waitingParentInstanceIndex = parsedMesh.parentInstanceIndex;
        }
        if (parsedMesh.actions !== void 0) {
          mesh._waitingData.actions = parsedMesh.actions;
        }
        if (parsedMesh.overlayAlpha !== void 0) {
          mesh.overlayAlpha = parsedMesh.overlayAlpha;
        }
        if (parsedMesh.overlayColor !== void 0) {
          mesh.overlayColor = Color3.FromArray(parsedMesh.overlayColor);
        }
        if (parsedMesh.renderOverlay !== void 0) {
          mesh.renderOverlay = parsedMesh.renderOverlay;
        }
        mesh.isUnIndexed = !!parsedMesh.isUnIndexed;
        mesh.hasVertexAlpha = parsedMesh.hasVertexAlpha;
        if (parsedMesh.delayLoadingFile) {
          mesh.delayLoadState = 4;
          mesh.delayLoadingFile = rootUrl + parsedMesh.delayLoadingFile;
          mesh.buildBoundingInfo(Vector3.FromArray(parsedMesh.boundingBoxMinimum), Vector3.FromArray(parsedMesh.boundingBoxMaximum));
          if (parsedMesh._binaryInfo) {
            mesh._binaryInfo = parsedMesh._binaryInfo;
          }
          mesh._delayInfo = [];
          if (parsedMesh.hasUVs) {
            mesh._delayInfo.push(VertexBuffer.UVKind);
          }
          if (parsedMesh.hasUVs2) {
            mesh._delayInfo.push(VertexBuffer.UV2Kind);
          }
          if (parsedMesh.hasUVs3) {
            mesh._delayInfo.push(VertexBuffer.UV3Kind);
          }
          if (parsedMesh.hasUVs4) {
            mesh._delayInfo.push(VertexBuffer.UV4Kind);
          }
          if (parsedMesh.hasUVs5) {
            mesh._delayInfo.push(VertexBuffer.UV5Kind);
          }
          if (parsedMesh.hasUVs6) {
            mesh._delayInfo.push(VertexBuffer.UV6Kind);
          }
          if (parsedMesh.hasColors) {
            mesh._delayInfo.push(VertexBuffer.ColorKind);
          }
          if (parsedMesh.hasMatricesIndices) {
            mesh._delayInfo.push(VertexBuffer.MatricesIndicesKind);
          }
          if (parsedMesh.hasMatricesWeights) {
            mesh._delayInfo.push(VertexBuffer.MatricesWeightsKind);
          }
          mesh._delayLoadingFunction = Geometry._ImportGeometry;
          if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {
            mesh._checkDelayState();
          }
        } else {
          Geometry._ImportGeometry(parsedMesh, mesh);
        }
        if (parsedMesh.materialUniqueId) {
          mesh._waitingMaterialId = parsedMesh.materialUniqueId;
        } else if (parsedMesh.materialId) {
          mesh._waitingMaterialId = parsedMesh.materialId;
        }
        if (parsedMesh.morphTargetManagerId > -1) {
          mesh._waitingMorphTargetManagerId = parsedMesh.morphTargetManagerId;
        }
        if (parsedMesh.skeletonId !== void 0 && parsedMesh.skeletonId !== null) {
          mesh.skeleton = scene.getLastSkeletonById(parsedMesh.skeletonId);
          if (parsedMesh.numBoneInfluencers) {
            mesh.numBoneInfluencers = parsedMesh.numBoneInfluencers;
          }
        }
        if (parsedMesh.animations) {
          for (let animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {
            const parsedAnimation = parsedMesh.animations[animationIndex];
            const internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              mesh.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          Node.ParseAnimationRanges(mesh, parsedMesh, scene);
        }
        if (parsedMesh.autoAnimate) {
          scene.beginAnimation(mesh, parsedMesh.autoAnimateFrom, parsedMesh.autoAnimateTo, parsedMesh.autoAnimateLoop, parsedMesh.autoAnimateSpeed || 1);
        }
        if (parsedMesh.layerMask && !isNaN(parsedMesh.layerMask)) {
          mesh.layerMask = Math.abs(parseInt(parsedMesh.layerMask));
        } else {
          mesh.layerMask = 268435455;
        }
        if (parsedMesh.physicsImpostor) {
          mesh.physicsImpostor = _Mesh._PhysicsImpostorParser(scene, mesh, parsedMesh);
        }
        if (parsedMesh.lodMeshIds) {
          mesh._waitingData.lods = {
            ids: parsedMesh.lodMeshIds,
            distances: parsedMesh.lodDistances ? parsedMesh.lodDistances : null,
            coverages: parsedMesh.lodCoverages ? parsedMesh.lodCoverages : null
          };
        }
        if (parsedMesh.instances) {
          for (let index = 0; index < parsedMesh.instances.length; index++) {
            const parsedInstance = parsedMesh.instances[index];
            const instance = mesh.createInstance(parsedInstance.name);
            if (parsedInstance.id) {
              instance.id = parsedInstance.id;
            }
            if (Tags) {
              if (parsedInstance.tags) {
                Tags.AddTagsTo(instance, parsedInstance.tags);
              } else {
                Tags.AddTagsTo(instance, parsedMesh.tags);
              }
            }
            instance.position = Vector3.FromArray(parsedInstance.position);
            if (parsedInstance.metadata !== void 0) {
              instance.metadata = parsedInstance.metadata;
            }
            if (parsedInstance.parentId !== void 0) {
              instance._waitingParentId = parsedInstance.parentId;
            }
            if (parsedInstance.parentInstanceIndex !== void 0) {
              instance._waitingParentInstanceIndex = parsedInstance.parentInstanceIndex;
            }
            if (parsedInstance.isEnabled !== void 0 && parsedInstance.isEnabled !== null) {
              instance.setEnabled(parsedInstance.isEnabled);
            }
            if (parsedInstance.isVisible !== void 0 && parsedInstance.isVisible !== null) {
              instance.isVisible = parsedInstance.isVisible;
            }
            if (parsedInstance.isPickable !== void 0 && parsedInstance.isPickable !== null) {
              instance.isPickable = parsedInstance.isPickable;
            }
            if (parsedInstance.rotationQuaternion) {
              instance.rotationQuaternion = Quaternion.FromArray(parsedInstance.rotationQuaternion);
            } else if (parsedInstance.rotation) {
              instance.rotation = Vector3.FromArray(parsedInstance.rotation);
            }
            instance.scaling = Vector3.FromArray(parsedInstance.scaling);
            if (parsedInstance.checkCollisions != void 0 && parsedInstance.checkCollisions != null) {
              instance.checkCollisions = parsedInstance.checkCollisions;
            }
            if (parsedInstance.pickable != void 0 && parsedInstance.pickable != null) {
              instance.isPickable = parsedInstance.pickable;
            }
            if (parsedInstance.showBoundingBox != void 0 && parsedInstance.showBoundingBox != null) {
              instance.showBoundingBox = parsedInstance.showBoundingBox;
            }
            if (parsedInstance.showSubMeshesBoundingBox != void 0 && parsedInstance.showSubMeshesBoundingBox != null) {
              instance.showSubMeshesBoundingBox = parsedInstance.showSubMeshesBoundingBox;
            }
            if (parsedInstance.alphaIndex != void 0 && parsedInstance.showSubMeshesBoundingBox != null) {
              instance.alphaIndex = parsedInstance.alphaIndex;
            }
            if (parsedInstance.physicsImpostor) {
              instance.physicsImpostor = _Mesh._PhysicsImpostorParser(scene, instance, parsedInstance);
            }
            if (parsedInstance.actions !== void 0) {
              instance._waitingData.actions = parsedInstance.actions;
            }
            if (parsedInstance.animations) {
              for (let animationIndex = 0; animationIndex < parsedInstance.animations.length; animationIndex++) {
                const parsedAnimation = parsedInstance.animations[animationIndex];
                const internalClass = GetClass("BABYLON.Animation");
                if (internalClass) {
                  instance.animations.push(internalClass.Parse(parsedAnimation));
                }
              }
              Node.ParseAnimationRanges(instance, parsedInstance, scene);
              if (parsedInstance.autoAnimate) {
                scene.beginAnimation(instance, parsedInstance.autoAnimateFrom, parsedInstance.autoAnimateTo, parsedInstance.autoAnimateLoop, parsedInstance.autoAnimateSpeed || 1);
              }
            }
          }
        }
        if (parsedMesh.thinInstances) {
          const thinInstances = parsedMesh.thinInstances;
          mesh.thinInstanceEnablePicking = !!thinInstances.enablePicking;
          if (thinInstances.matrixData) {
            mesh.thinInstanceSetBuffer("matrix", new Float32Array(thinInstances.matrixData), 16, false);
            mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;
            mesh._thinInstanceDataStorage.instancesCount = thinInstances.instancesCount;
          } else {
            mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;
          }
          if (parsedMesh.thinInstances.userThinInstance) {
            const userThinInstance = parsedMesh.thinInstances.userThinInstance;
            for (const kind in userThinInstance.data) {
              mesh.thinInstanceSetBuffer(kind, new Float32Array(userThinInstance.data[kind]), userThinInstance.strides[kind], false);
              mesh._userThinInstanceBuffersStorage.sizes[kind] = userThinInstance.sizes[kind];
            }
          }
        }
        return mesh;
      }
      // Skeletons
      /**
       * Prepare internal position array for software CPU skinning
       * @returns original positions used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh
       */
      setPositionsForCPUSkinning() {
        const internalDataInfo = this._internalMeshDataInfo;
        if (!internalDataInfo._sourcePositions) {
          const source = this.getVerticesData(VertexBuffer.PositionKind);
          if (!source) {
            return internalDataInfo._sourcePositions;
          }
          internalDataInfo._sourcePositions = new Float32Array(source);
          if (!this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {
            this.setVerticesData(VertexBuffer.PositionKind, source, true);
          }
        }
        return internalDataInfo._sourcePositions;
      }
      /**
       * Prepare internal normal array for software CPU skinning
       * @returns original normals used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh.
       */
      setNormalsForCPUSkinning() {
        const internalDataInfo = this._internalMeshDataInfo;
        if (!internalDataInfo._sourceNormals) {
          const source = this.getVerticesData(VertexBuffer.NormalKind);
          if (!source) {
            return internalDataInfo._sourceNormals;
          }
          internalDataInfo._sourceNormals = new Float32Array(source);
          if (!this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {
            this.setVerticesData(VertexBuffer.NormalKind, source, true);
          }
        }
        return internalDataInfo._sourceNormals;
      }
      /**
       * Updates the vertex buffer by applying transformation from the bones
       * @param skeleton defines the skeleton to apply to current mesh
       * @returns the current mesh
       */
      applySkeleton(skeleton) {
        if (!this.geometry) {
          return this;
        }
        if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) {
          return this;
        }
        this.geometry._softwareSkinningFrameId = this.getScene().getFrameId();
        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
          return this;
        }
        if (!this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
          return this;
        }
        if (!this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
          return this;
        }
        const hasNormals = this.isVerticesDataPresent(VertexBuffer.NormalKind);
        const internalDataInfo = this._internalMeshDataInfo;
        if (!internalDataInfo._sourcePositions) {
          const submeshes = this.subMeshes.slice();
          this.setPositionsForCPUSkinning();
          this.subMeshes = submeshes;
        }
        if (hasNormals && !internalDataInfo._sourceNormals) {
          this.setNormalsForCPUSkinning();
        }
        let positionsData = this.getVerticesData(VertexBuffer.PositionKind);
        if (!positionsData) {
          return this;
        }
        if (!(positionsData instanceof Float32Array)) {
          positionsData = new Float32Array(positionsData);
        }
        let normalsData = this.getVerticesData(VertexBuffer.NormalKind);
        if (hasNormals) {
          if (!normalsData) {
            return this;
          }
          if (!(normalsData instanceof Float32Array)) {
            normalsData = new Float32Array(normalsData);
          }
        }
        const matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
        const matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
        if (!matricesWeightsData || !matricesIndicesData) {
          return this;
        }
        const needExtras = this.numBoneInfluencers > 4;
        const matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;
        const matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;
        const skeletonMatrices = skeleton.getTransformMatrices(this);
        const tempVector3 = Vector3.Zero();
        const finalMatrix = new Matrix();
        const tempMatrix = new Matrix();
        let matWeightIdx = 0;
        let inf;
        for (let index = 0; index < positionsData.length; index += 3, matWeightIdx += 4) {
          let weight;
          for (inf = 0; inf < 4; inf++) {
            weight = matricesWeightsData[matWeightIdx + inf];
            if (weight > 0) {
              Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);
              finalMatrix.addToSelf(tempMatrix);
            }
          }
          if (needExtras) {
            for (inf = 0; inf < 4; inf++) {
              weight = matricesWeightsExtraData[matWeightIdx + inf];
              if (weight > 0) {
                Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);
                finalMatrix.addToSelf(tempMatrix);
              }
            }
          }
          Vector3.TransformCoordinatesFromFloatsToRef(internalDataInfo._sourcePositions[index], internalDataInfo._sourcePositions[index + 1], internalDataInfo._sourcePositions[index + 2], finalMatrix, tempVector3);
          tempVector3.toArray(positionsData, index);
          if (hasNormals) {
            Vector3.TransformNormalFromFloatsToRef(internalDataInfo._sourceNormals[index], internalDataInfo._sourceNormals[index + 1], internalDataInfo._sourceNormals[index + 2], finalMatrix, tempVector3);
            tempVector3.toArray(normalsData, index);
          }
          finalMatrix.reset();
        }
        this.updateVerticesData(VertexBuffer.PositionKind, positionsData);
        if (hasNormals) {
          this.updateVerticesData(VertexBuffer.NormalKind, normalsData);
        }
        return this;
      }
      // Tools
      /**
       * Returns an object containing a min and max Vector3 which are the minimum and maximum vectors of each mesh bounding box from the passed array, in the world coordinates
       * @param meshes defines the list of meshes to scan
       * @returns an object `{min:` Vector3`, max:` Vector3`}`
       */
      static MinMax(meshes) {
        let minVector = null;
        let maxVector = null;
        for (const mesh of meshes) {
          const boundingInfo = mesh.getBoundingInfo();
          const boundingBox = boundingInfo.boundingBox;
          if (!minVector || !maxVector) {
            minVector = boundingBox.minimumWorld.clone();
            maxVector = boundingBox.maximumWorld.clone();
          } else {
            minVector.minimizeInPlace(boundingBox.minimumWorld);
            maxVector.maximizeInPlace(boundingBox.maximumWorld);
          }
        }
        if (!minVector || !maxVector) {
          return {
            min: Vector3.Zero(),
            max: Vector3.Zero()
          };
        }
        return {
          min: minVector,
          max: maxVector
        };
      }
      /**
       * Returns the center of the `{min:` Vector3`, max:` Vector3`}` or the center of MinMax vector3 computed from a mesh array
       * @param meshesOrMinMaxVector could be an array of meshes or a `{min:` Vector3`, max:` Vector3`}` object
       * @returns a vector3
       */
      static Center(meshesOrMinMaxVector) {
        const minMaxVector = meshesOrMinMaxVector instanceof Array ? _Mesh.MinMax(meshesOrMinMaxVector) : meshesOrMinMaxVector;
        return Vector3.Center(minMaxVector.min, minMaxVector.max);
      }
      /**
       * Merge the array of meshes into a single mesh for performance reasons.
       * @param meshes array of meshes with the vertices to merge. Entries cannot be empty meshes.
       * @param disposeSource when true (default), dispose of the vertices from the source meshes.
       * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true.
       * @param meshSubclass (optional) can be set to a Mesh where the merged vertices will be inserted.
       * @param subdivideWithSubMeshes when true (false default), subdivide mesh into subMeshes.
       * @param multiMultiMaterials when true (false default), subdivide mesh into subMeshes with multiple materials, ignores subdivideWithSubMeshes.
       * @returns a new mesh
       */
      static MergeMeshes(meshes, disposeSource = true, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {
        return runCoroutineSync(_Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, false));
      }
      /**
       * Merge the array of meshes into a single mesh for performance reasons.
       * @param meshes array of meshes with the vertices to merge. Entries cannot be empty meshes.
       * @param disposeSource when true (default), dispose of the vertices from the source meshes.
       * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true.
       * @param meshSubclass (optional) can be set to a Mesh where the merged vertices will be inserted.
       * @param subdivideWithSubMeshes when true (false default), subdivide mesh into subMeshes.
       * @param multiMultiMaterials when true (false default), subdivide mesh into subMeshes with multiple materials, ignores subdivideWithSubMeshes.
       * @returns a new mesh
       */
      static async MergeMeshesAsync(meshes, disposeSource = true, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {
        return await runCoroutineAsync(_Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, true), createYieldingScheduler());
      }
      static *_MergeMeshesCoroutine(meshes, disposeSource = true, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, isAsync) {
        meshes = meshes.filter(Boolean);
        if (meshes.length === 0) {
          return null;
        }
        let index;
        if (!allow32BitsIndices) {
          let totalVertices = 0;
          for (index = 0; index < meshes.length; index++) {
            totalVertices += meshes[index].getTotalVertices();
            if (totalVertices >= 65536) {
              Logger.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices");
              return null;
            }
          }
        }
        if (multiMultiMaterials) {
          subdivideWithSubMeshes = false;
        }
        const materialArray = new Array();
        const materialIndexArray = new Array();
        const indiceArray = new Array();
        const currentsideOrientation = meshes[0].sideOrientation;
        for (index = 0; index < meshes.length; index++) {
          const mesh = meshes[index];
          if (mesh.isAnInstance) {
            Logger.Warn("Cannot merge instance meshes.");
            return null;
          }
          if (currentsideOrientation !== mesh.sideOrientation) {
            Logger.Warn("Cannot merge meshes with different sideOrientation values.");
            return null;
          }
          if (subdivideWithSubMeshes || multiMultiMaterials) {
            const indexOffset = indiceArray.reduce((accumulator, currentValue) => {
              return Math.max(accumulator, currentValue.start + currentValue.count);
            }, 0);
            if (multiMultiMaterials) {
              if (mesh.material) {
                const material = mesh.material;
                if (material instanceof MultiMaterial) {
                  for (let matIndex = 0; matIndex < material.subMaterials.length; matIndex++) {
                    if (materialArray.indexOf(material.subMaterials[matIndex]) < 0) {
                      materialArray.push(material.subMaterials[matIndex]);
                    }
                  }
                  for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                    materialIndexArray.push(materialArray.indexOf(material.subMaterials[mesh.subMeshes[subIndex].materialIndex]));
                    indiceArray.push({ start: indexOffset + mesh.subMeshes[subIndex].indexStart, count: mesh.subMeshes[subIndex].indexCount });
                  }
                } else {
                  if (materialArray.indexOf(material) < 0) {
                    materialArray.push(material);
                  }
                  for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                    materialIndexArray.push(materialArray.indexOf(material));
                    indiceArray.push({ start: indexOffset + mesh.subMeshes[subIndex].indexStart, count: mesh.subMeshes[subIndex].indexCount });
                  }
                }
              } else {
                for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                  materialIndexArray.push(0);
                  indiceArray.push({ start: indexOffset + mesh.subMeshes[subIndex].indexStart, count: mesh.subMeshes[subIndex].indexCount });
                }
              }
            } else {
              indiceArray.push({ start: indexOffset, count: mesh.getTotalIndices() });
            }
          }
        }
        const source = meshes[0];
        const getVertexDataFromMesh = (mesh) => {
          const wm = mesh.computeWorldMatrix(true);
          const vertexData2 = VertexData.ExtractFromMesh(mesh, false, false);
          return { vertexData: vertexData2, transform: wm };
        };
        const { vertexData: sourceVertexData, transform: sourceTransform } = getVertexDataFromMesh(source);
        if (isAsync) {
          yield;
        }
        const meshVertexDatas = new Array(meshes.length - 1);
        for (let i = 1; i < meshes.length; i++) {
          meshVertexDatas[i - 1] = getVertexDataFromMesh(meshes[i]);
          if (isAsync) {
            yield;
          }
        }
        const mergeCoroutine = sourceVertexData._mergeCoroutine(sourceTransform, meshVertexDatas, allow32BitsIndices, isAsync, !disposeSource);
        let mergeCoroutineStep = mergeCoroutine.next();
        while (!mergeCoroutineStep.done) {
          if (isAsync) {
            yield;
          }
          mergeCoroutineStep = mergeCoroutine.next();
        }
        const vertexData = mergeCoroutineStep.value;
        if (!meshSubclass) {
          meshSubclass = new _Mesh(source.name + "_merged", source.getScene());
        }
        const applyToCoroutine = vertexData._applyToCoroutine(meshSubclass, void 0, isAsync);
        let applyToCoroutineStep = applyToCoroutine.next();
        while (!applyToCoroutineStep.done) {
          if (isAsync) {
            yield;
          }
          applyToCoroutineStep = applyToCoroutine.next();
        }
        meshSubclass.checkCollisions = source.checkCollisions;
        meshSubclass.sideOrientation = source.sideOrientation;
        if (disposeSource) {
          for (index = 0; index < meshes.length; index++) {
            meshes[index].dispose();
          }
        }
        if (subdivideWithSubMeshes || multiMultiMaterials) {
          meshSubclass.releaseSubMeshes();
          index = 0;
          while (index < indiceArray.length) {
            SubMesh.CreateFromIndices(0, indiceArray[index].start, indiceArray[index].count, meshSubclass, void 0, false);
            index++;
          }
          for (const subMesh of meshSubclass.subMeshes) {
            subMesh.refreshBoundingInfo();
          }
          meshSubclass.computeWorldMatrix(true);
        }
        if (multiMultiMaterials) {
          const newMultiMaterial = new MultiMaterial(source.name + "_merged", source.getScene());
          newMultiMaterial.subMaterials = materialArray;
          for (let subIndex = 0; subIndex < meshSubclass.subMeshes.length; subIndex++) {
            meshSubclass.subMeshes[subIndex].materialIndex = materialIndexArray[subIndex];
          }
          meshSubclass.material = newMultiMaterial;
        } else {
          meshSubclass.material = source.material;
        }
        return meshSubclass;
      }
      /**
       * @internal
       */
      addInstance(instance) {
        instance._indexInSourceMeshInstanceArray = this.instances.length;
        this.instances.push(instance);
      }
      /**
       * @internal
       */
      removeInstance(instance) {
        const index = instance._indexInSourceMeshInstanceArray;
        if (index != -1) {
          if (index !== this.instances.length - 1) {
            const last = this.instances[this.instances.length - 1];
            this.instances[index] = last;
            last._indexInSourceMeshInstanceArray = index;
          }
          instance._indexInSourceMeshInstanceArray = -1;
          this.instances.pop();
        }
      }
      /** @internal */
      _shouldConvertRHS() {
        return this._scene.useRightHandedSystem && this.sideOrientation === Material.CounterClockWiseSideOrientation;
      }
      /** @internal */
      _getRenderingFillMode(fillMode) {
        const scene = this.getScene();
        if (scene.forcePointsCloud) {
          return Material.PointFillMode;
        }
        if (scene.forceWireframe) {
          return Material.WireFrameFillMode;
        }
        return this.overrideRenderingFillMode ?? fillMode;
      }
      // deprecated methods
      /**
       * Sets the mesh material by the material or multiMaterial `id` property
       * @param id is a string identifying the material or the multiMaterial
       * @returns the current mesh
       * @deprecated Please use MeshBuilder instead Please use setMaterialById instead
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      setMaterialByID(id) {
        return this.setMaterialById(id);
      }
      /**
       * Creates a ribbon mesh.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param
       * @param name defines the name of the mesh to create
       * @param pathArray is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry.
       * @param closeArray creates a seam between the first and the last paths of the path array (default is false)
       * @param closePath creates a seam between the first and the last points of each path of the path array
       * @param offset is taken in account only if the `pathArray` is containing a single path
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation)
       * @param instance defines an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#ribbon)
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateRibbon(name, pathArray, closeArray, closePath, offset, scene, updatable, sideOrientation, instance) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a plane polygonal mesh.  By default, this is a disc.
       * @param name defines the name of the mesh to create
       * @param radius sets the radius size (float) of the polygon (default 0.5)
       * @param tessellation sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation)
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateDisc(name, radius, tessellation, scene, updatable, sideOrientation) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a box mesh.
       * @param name defines the name of the mesh to create
       * @param size sets the size (float) of each box side (default 1)
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation)
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateBox(name, size, scene, updatable, sideOrientation) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a sphere mesh.
       * @param name defines the name of the mesh to create
       * @param segments sets the sphere number of horizontal stripes (positive integer, default 32)
       * @param diameter sets the diameter size (float) of the sphere (default 1)
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation)
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateSphere(name, segments, diameter, scene, updatable, sideOrientation) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a hemisphere mesh.
       * @param name defines the name of the mesh to create
       * @param segments sets the sphere number of horizontal stripes (positive integer, default 32)
       * @param diameter sets the diameter size (float) of the sphere (default 1)
       * @param scene defines the hosting scene
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateHemisphere(name, segments, diameter, scene) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a cylinder or a cone mesh.
       * @param name defines the name of the mesh to create
       * @param height sets the height size (float) of the cylinder/cone (float, default 2)
       * @param diameterTop set the top cap diameter (floats, default 1)
       * @param diameterBottom set the bottom cap diameter (floats, default 1). This value can't be zero
       * @param tessellation sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance
       * @param subdivisions sets the number of rings along the cylinder height (positive integer, default 1)
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation)
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateCylinder(name, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      // Torus  (Code from SharpDX.org)
      /**
       * Creates a torus mesh.
       * @param name defines the name of the mesh to create
       * @param diameter sets the diameter size (float) of the torus (default 1)
       * @param thickness sets the diameter size of the tube of the torus (float, default 0.5)
       * @param tessellation sets the number of torus sides (positive integer, default 16)
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation)
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateTorus(name, diameter, thickness, tessellation, scene, updatable, sideOrientation) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a torus knot mesh.
       * @param name defines the name of the mesh to create
       * @param radius sets the global radius size (float) of the torus knot (default 2)
       * @param tube sets the diameter size of the tube of the torus (float, default 0.5)
       * @param radialSegments sets the number of sides on each tube segments (positive integer, default 32)
       * @param tubularSegments sets the number of tubes to decompose the knot into (positive integer, default 32)
       * @param p the number of windings on X axis (positive integers, default 2)
       * @param q the number of windings on Y axis (positive integers, default 3)
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation)
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateTorusKnot(name, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a line mesh..
       * @param name defines the name of the mesh to create
       * @param points is an array successive Vector3
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @param instance is an instance of an existing LineMesh object to be updated with the passed `points` parameter (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#lines-and-dashedlines).
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateLines(name, points, scene, updatable, instance) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a dashed line mesh.
       * @param name defines the name of the mesh to create
       * @param points is an array successive Vector3
       * @param dashSize is the size of the dashes relatively the dash number (positive float, default 3)
       * @param gapSize is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)
       * @param dashNb is the intended total number of dashes (positive integer, default 200)
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @param instance is an instance of an existing LineMesh object to be updated with the passed `points` parameter (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#lines-and-dashedlines)
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateDashedLines(name, points, dashSize, gapSize, dashNb, scene, updatable, instance) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a polygon mesh.Please consider using the same method from the MeshBuilder class instead
       * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh.
       * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors.
       * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
       * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
       * Remember you can only change the shape positions, not their number when updating a polygon.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#non-regular-polygon
       * @param name defines the name of the mesh to create
       * @param shape is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
       * @param scene defines the hosting scene
       * @param holes is a required array of arrays of successive Vector3 used to defines holes in the polygon
       * @param updatable defines if the mesh must be flagged as updatable
       * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation)
       * @param earcutInjection can be used to inject your own earcut reference
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreatePolygon(name, shape, scene, holes, updatable, sideOrientation, earcutInjection) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates an extruded polygon mesh, with depth in the Y direction..
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#extruded-non-regular-polygon
       * @param name defines the name of the mesh to create
       * @param shape is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
       * @param depth defines the height of extrusion
       * @param scene defines the hosting scene
       * @param holes is a required array of arrays of successive Vector3 used to defines holes in the polygon
       * @param updatable defines if the mesh must be flagged as updatable
       * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation)
       * @param earcutInjection can be used to inject your own earcut reference
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static ExtrudePolygon(name, shape, depth, scene, holes, updatable, sideOrientation, earcutInjection) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates an extruded shape mesh.
       * The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#extruded-shapes
       * @param name defines the name of the mesh to create
       * @param shape is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis
       * @param path is a required array of successive Vector3. This is the axis curve the shape is extruded along
       * @param scale is the value to scale the shape
       * @param rotation is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve
       * @param cap sets the way the extruded shape is capped. Possible values : Mesh.NO_CAP (default), Mesh.CAP_START, Mesh.CAP_END, Mesh.CAP_ALL
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation)
       * @param instance is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#extruded-shape)
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static ExtrudeShape(name, shape, path, scale, rotation, cap, scene, updatable, sideOrientation, instance) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates an custom extruded shape mesh.
       * The custom extrusion is a parametric shape.
       * It has no predefined shape. Its final shape will depend on the input parameters.
       *
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#extruded-shapes
       * @param name defines the name of the mesh to create
       * @param shape is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis
       * @param path is a required array of successive Vector3. This is the axis curve the shape is extruded along
       * @param scaleFunction is a custom Javascript function called on each path point
       * @param rotationFunction is a custom Javascript function called on each path point
       * @param ribbonCloseArray forces the extrusion underlying ribbon to close all the paths in its `pathArray`
       * @param ribbonClosePath forces the extrusion underlying ribbon to close its `pathArray`
       * @param cap sets the way the extruded shape is capped. Possible values : Mesh.NO_CAP (default), Mesh.CAP_START, Mesh.CAP_END, Mesh.CAP_ALL
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation)
       * @param instance is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters (https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#extruded-shape)
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static ExtrudeShapeCustom(name, shape, path, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, scene, updatable, sideOrientation, instance) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates lathe mesh.
       * The lathe is a shape with a symmetry axis : a 2D model shape is rotated around this axis to design the lathe.
       * @param name defines the name of the mesh to create
       * @param shape is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero
       * @param radius is the radius value of the lathe
       * @param tessellation is the side number of the lathe.
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation)
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateLathe(name, shape, radius, tessellation, scene, updatable, sideOrientation) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a plane mesh.
       * @param name defines the name of the mesh to create
       * @param size sets the size (float) of both sides of the plane at once (default 1)
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation)
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreatePlane(name, size, scene, updatable, sideOrientation) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a ground mesh.
       * @param name defines the name of the mesh to create
       * @param width set the width of the ground
       * @param height set the height of the ground
       * @param subdivisions sets the number of subdivisions per side
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateGround(name, width, height, subdivisions, scene, updatable) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a tiled ground mesh.
       * @param name defines the name of the mesh to create
       * @param xmin set the ground minimum X coordinate
       * @param zmin set the ground minimum Y coordinate
       * @param xmax set the ground maximum X coordinate
       * @param zmax set the ground maximum Z coordinate
       * @param subdivisions is an object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile
       * @param precision is an object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateTiledGround(name, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a ground mesh from a height map.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/height_map
       * @param name defines the name of the mesh to create
       * @param url sets the URL of the height map image resource
       * @param width set the ground width size
       * @param height set the ground height size
       * @param subdivisions sets the number of subdivision per side
       * @param minHeight is the minimum altitude on the ground
       * @param maxHeight is the maximum altitude on the ground
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @param onReady  is a callback function that will be called  once the mesh is built (the height map download can last some time)
       * @param alphaFilter will filter any data where the alpha channel is below this value, defaults 0 (all data visible)
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateGroundFromHeightMap(name, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a tube mesh.
       * The tube is a parametric shape.
       * It has no predefined shape. Its final shape will depend on the input parameters.
       *
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param
       * @param name defines the name of the mesh to create
       * @param path is a required array of successive Vector3. It is the curve used as the axis of the tube
       * @param radius sets the tube radius size
       * @param tessellation is the number of sides on the tubular surface
       * @param radiusFunction is a custom function. If it is not null, it overrides the parameter `radius`. This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path
       * @param cap sets the way the extruded shape is capped. Possible values : Mesh.NO_CAP (default), Mesh.CAP_START, Mesh.CAP_END, Mesh.CAP_ALL
       * @param scene defines the hosting scene
       * @param updatable defines if the mesh must be flagged as updatable
       * @param sideOrientation defines the mesh side orientation (https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation)
       * @param instance is an instance of an existing Tube object to be updated with the passed `pathArray` parameter (https://doc.babylonjs.com/how_to/How_to_dynamically_morph_a_mesh#tube)
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateTube(name, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a polyhedron mesh.
       *.
       * * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embedded types. Please refer to the type sheet in the tutorial to choose the wanted type
       * * The parameter `size` (positive float, default 1) sets the polygon size
       * * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)
       * * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`
       * * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
       * * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)
       * * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace
       * * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored
       * * You can also set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
       * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation
       * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
       * @param name defines the name of the mesh to create
       * @param options defines the options used to create the mesh
       * @param scene defines the hosting scene
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreatePolyhedron(name, options, scene) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided
       * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)
       * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value than `radius`)
       * * The parameter `subdivisions` sets the number of subdivisions (positive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size
       * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface
       * * You can also set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE
       * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation
       * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra#icosphere
       * @param name defines the name of the mesh
       * @param options defines the options used to create the mesh
       * @param scene defines the hosting scene
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateIcoSphere(name, options, scene) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Creates a decal mesh.
       *.
       * A decal is a mesh usually applied as a model onto the surface of another mesh
       * @param name  defines the name of the mesh
       * @param sourceMesh defines the mesh receiving the decal
       * @param position sets the position of the decal in world coordinates
       * @param normal sets the normal of the mesh where the decal is applied onto in world coordinates
       * @param size sets the decal scaling
       * @param angle sets the angle to rotate the decal
       * @returns a new Mesh
       * @deprecated Please use MeshBuilder instead
       */
      static CreateDecal(name, sourceMesh, position, normal, size, angle) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /** Creates a Capsule Mesh
       * @param name defines the name of the mesh.
       * @param options the constructors options used to shape the mesh.
       * @param scene defines the scene the mesh is scoped to.
       * @returns the capsule mesh
       * @see https://doc.babylonjs.com/how_to/capsule_shape
       * @deprecated Please use MeshBuilder instead
       */
      static CreateCapsule(name, options, scene) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      /**
       * Extends a mesh to a Goldberg mesh
       * Warning  the mesh to convert MUST be an import of a perviously exported Goldberg mesh
       * @param mesh the mesh to convert
       * @returns the extended mesh
       * @deprecated Please use ExtendMeshToGoldberg instead
       */
      static ExtendToGoldberg(mesh) {
        throw new Error("Import MeshBuilder to populate this function");
      }
    };
    Mesh.FRONTSIDE = VertexData.FRONTSIDE;
    Mesh.BACKSIDE = VertexData.BACKSIDE;
    Mesh.DOUBLESIDE = VertexData.DOUBLESIDE;
    Mesh.DEFAULTSIDE = VertexData.DEFAULTSIDE;
    Mesh.NO_CAP = 0;
    Mesh.CAP_START = 1;
    Mesh.CAP_END = 2;
    Mesh.CAP_ALL = 3;
    Mesh.NO_FLIP = 0;
    Mesh.FLIP_TILE = 1;
    Mesh.ROTATE_TILE = 2;
    Mesh.FLIP_ROW = 3;
    Mesh.ROTATE_ROW = 4;
    Mesh.FLIP_N_ROTATE_TILE = 5;
    Mesh.FLIP_N_ROTATE_ROW = 6;
    Mesh.CENTER = 0;
    Mesh.LEFT = 1;
    Mesh.RIGHT = 2;
    Mesh.TOP = 3;
    Mesh.BOTTOM = 4;
    Mesh.INSTANCEDMESH_SORT_TRANSPARENT = false;
    Mesh._GroundMeshParser = (parsedMesh, scene) => {
      throw _WarnImport("GroundMesh");
    };
    Mesh._GoldbergMeshParser = (parsedMesh, scene) => {
      throw _WarnImport("GoldbergMesh");
    };
    Mesh._LinesMeshParser = (parsedMesh, scene) => {
      throw _WarnImport("LinesMesh");
    };
    Mesh._GreasedLineMeshParser = (parsedMesh, scene) => {
      throw _WarnImport("GreasedLineMesh");
    };
    Mesh._GreasedLineRibbonMeshParser = (parsedMesh, scene) => {
      throw _WarnImport("GreasedLineRibbonMesh");
    };
    Mesh._TrailMeshParser = (parsedMesh, scene) => {
      throw _WarnImport("TrailMesh");
    };
    RegisterClass("BABYLON.Mesh", Mesh);
  }
});

// node_modules/@babylonjs/core/Meshes/instancedMesh.js
var InstancedMesh;
var init_instancedMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/instancedMesh.js"() {
    init_math_vector();
    init_logger();
    init_abstractMesh();
    init_mesh();
    init_deepCopier();
    init_transformNode();
    init_buffer();
    init_tools();
    init_typeStore();
    Mesh._instancedMeshFactory = (name, mesh) => {
      const instance = new InstancedMesh(name, mesh);
      if (mesh.instancedBuffers) {
        instance.instancedBuffers = {};
        for (const key in mesh.instancedBuffers) {
          instance.instancedBuffers[key] = mesh.instancedBuffers[key];
        }
      }
      return instance;
    };
    InstancedMesh = class extends AbstractMesh {
      /**
       * Creates a new InstancedMesh object from the mesh source.
       * @param name defines the name of the instance
       * @param source the mesh to create the instance from
       */
      constructor(name, source) {
        super(name, source.getScene());
        this._indexInSourceMeshInstanceArray = -1;
        this._distanceToCamera = 0;
        source.addInstance(this);
        this._sourceMesh = source;
        this._unIndexed = source._unIndexed;
        this.position.copyFrom(source.position);
        this.rotation.copyFrom(source.rotation);
        this.scaling.copyFrom(source.scaling);
        if (source.rotationQuaternion) {
          this.rotationQuaternion = source.rotationQuaternion.clone();
        }
        this.animations = source.animations.slice();
        for (const range of source.getAnimationRanges()) {
          if (range != null) {
            this.createAnimationRange(range.name, range.from, range.to);
          }
        }
        this.infiniteDistance = source.infiniteDistance;
        this.setPivotMatrix(source.getPivotMatrix());
        if (!source.skeleton && !source.morphTargetManager && source.hasBoundingInfo) {
          const boundingInfo = source.getBoundingInfo();
          this.buildBoundingInfo(boundingInfo.minimum, boundingInfo.maximum);
        } else {
          this.refreshBoundingInfo(true, true);
        }
        this._syncSubMeshes();
      }
      /**
       * @returns the string "InstancedMesh".
       */
      getClassName() {
        return "InstancedMesh";
      }
      /** Gets the list of lights affecting that mesh */
      get lightSources() {
        return this._sourceMesh._lightSources;
      }
      _resyncLightSources() {
      }
      _resyncLightSource() {
      }
      _removeLightSource() {
      }
      // Methods
      /**
       * If the source mesh receives shadows
       */
      get receiveShadows() {
        return this._sourceMesh.receiveShadows;
      }
      set receiveShadows(_value) {
        if (this._sourceMesh?.receiveShadows !== _value) {
          Tools.Warn("Setting receiveShadows on an instanced mesh has no effect");
        }
      }
      /**
       * The material of the source mesh
       */
      get material() {
        return this._sourceMesh.material;
      }
      set material(_value) {
        if (this._sourceMesh?.material !== _value) {
          Tools.Warn("Setting material on an instanced mesh has no effect");
        }
      }
      /**
       * Visibility of the source mesh
       */
      get visibility() {
        return this._sourceMesh.visibility;
      }
      set visibility(_value) {
        if (this._sourceMesh?.visibility !== _value) {
          Tools.Warn("Setting visibility on an instanced mesh has no effect");
        }
      }
      /**
       * Skeleton of the source mesh
       */
      get skeleton() {
        return this._sourceMesh.skeleton;
      }
      set skeleton(_value) {
        if (this._sourceMesh?.skeleton !== _value) {
          Tools.Warn("Setting skeleton on an instanced mesh has no effect");
        }
      }
      /**
       * Rendering ground id of the source mesh
       */
      get renderingGroupId() {
        return this._sourceMesh.renderingGroupId;
      }
      set renderingGroupId(value) {
        if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {
          return;
        }
        Logger.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene");
      }
      /**
       * @returns the total number of vertices (integer).
       */
      getTotalVertices() {
        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;
      }
      /**
       * Returns a positive integer : the total number of indices in this mesh geometry.
       * @returns the number of indices or zero if the mesh has no geometry.
       */
      getTotalIndices() {
        return this._sourceMesh.getTotalIndices();
      }
      /**
       * The source mesh of the instance
       */
      get sourceMesh() {
        return this._sourceMesh;
      }
      /**
       * Gets the mesh internal Geometry object
       */
      get geometry() {
        return this._sourceMesh._geometry;
      }
      /**
       * Creates a new InstancedMesh object from the mesh model.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances
       * @param name defines the name of the new instance
       * @returns a new InstancedMesh
       */
      createInstance(name) {
        return this._sourceMesh.createInstance(name);
      }
      /**
       * Is this node ready to be used/rendered
       * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
       * @returns {boolean} is it ready
       */
      isReady(completeCheck = false) {
        return this._sourceMesh.isReady(completeCheck, true);
      }
      /**
       * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.
       * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)
       * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
       * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is
       * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.
       */
      getVerticesData(kind, copyWhenShared, forceCopy) {
        return this._sourceMesh.getVerticesData(kind, copyWhenShared, forceCopy);
      }
      copyVerticesData(kind, vertexData) {
        this._sourceMesh.copyVerticesData(kind, vertexData);
      }
      getVertexBuffer(kind, bypassInstanceData) {
        return this._sourceMesh.getVertexBuffer(kind, bypassInstanceData);
      }
      /**
       * Sets the vertex data of the mesh geometry for the requested `kind`.
       * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
       * The `data` are either a numeric array either a Float32Array.
       * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.
       * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).
       * Note that a new underlying VertexBuffer object is created each call.
       * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
       *
       * Possible `kind` values :
       * - VertexBuffer.PositionKind
       * - VertexBuffer.UVKind
       * - VertexBuffer.UV2Kind
       * - VertexBuffer.UV3Kind
       * - VertexBuffer.UV4Kind
       * - VertexBuffer.UV5Kind
       * - VertexBuffer.UV6Kind
       * - VertexBuffer.ColorKind
       * - VertexBuffer.MatricesIndicesKind
       * - VertexBuffer.MatricesIndicesExtraKind
       * - VertexBuffer.MatricesWeightsKind
       * - VertexBuffer.MatricesWeightsExtraKind
       *
       * Returns the Mesh.
       * @param kind defines vertex data kind
       * @param data defines the data source
       * @param updatable defines if the data must be flagged as updatable (false as default)
       * @param stride defines the vertex stride (optional)
       * @returns the current mesh
       */
      setVerticesData(kind, data, updatable, stride) {
        if (this.sourceMesh) {
          this.sourceMesh.setVerticesData(kind, data, updatable, stride);
        }
        return this.sourceMesh;
      }
      /**
       * Updates the existing vertex data of the mesh geometry for the requested `kind`.
       * If the mesh has no geometry, it is simply returned as it is.
       * The `data` are either a numeric array either a Float32Array.
       * No new underlying VertexBuffer object is created.
       * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
       * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.
       *
       * Possible `kind` values :
       * - VertexBuffer.PositionKind
       * - VertexBuffer.UVKind
       * - VertexBuffer.UV2Kind
       * - VertexBuffer.UV3Kind
       * - VertexBuffer.UV4Kind
       * - VertexBuffer.UV5Kind
       * - VertexBuffer.UV6Kind
       * - VertexBuffer.ColorKind
       * - VertexBuffer.MatricesIndicesKind
       * - VertexBuffer.MatricesIndicesExtraKind
       * - VertexBuffer.MatricesWeightsKind
       * - VertexBuffer.MatricesWeightsExtraKind
       *
       * Returns the Mesh.
       * @param kind defines vertex data kind
       * @param data defines the data source
       * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for "position" kind
       * @param makeItUnique defines it the updated vertex buffer must be flagged as unique (false by default)
       * @returns the source mesh
       */
      updateVerticesData(kind, data, updateExtends, makeItUnique) {
        if (this.sourceMesh) {
          this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);
        }
        return this.sourceMesh;
      }
      /**
       * Sets the mesh indices.
       * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).
       * If the mesh has no geometry, a new Geometry object is created and set to the mesh.
       * This method creates a new index buffer each call.
       * Returns the Mesh.
       * @param indices the source data
       * @param totalVertices defines the total number of vertices referenced by indices (could be null)
       * @returns source mesh
       */
      setIndices(indices, totalVertices = null) {
        if (this.sourceMesh) {
          this.sourceMesh.setIndices(indices, totalVertices);
        }
        return this.sourceMesh;
      }
      /**
       * Boolean : True if the mesh owns the requested kind of data.
       * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :
       * - VertexBuffer.PositionKind
       * - VertexBuffer.UVKind
       * - VertexBuffer.UV2Kind
       * - VertexBuffer.UV3Kind
       * - VertexBuffer.UV4Kind
       * - VertexBuffer.UV5Kind
       * - VertexBuffer.UV6Kind
       * - VertexBuffer.ColorKind
       * - VertexBuffer.MatricesIndicesKind
       * - VertexBuffer.MatricesIndicesExtraKind
       * - VertexBuffer.MatricesWeightsKind
       * - VertexBuffer.MatricesWeightsExtraKind
       * @returns true if data kind is present
       */
      isVerticesDataPresent(kind) {
        return this._sourceMesh.isVerticesDataPresent(kind);
      }
      /**
       * @returns an array of indices (IndicesArray).
       */
      getIndices() {
        return this._sourceMesh.getIndices();
      }
      get _positions() {
        return this._sourceMesh._positions;
      }
      refreshBoundingInfo(applySkeletonOrOptions = false, applyMorph = false) {
        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {
          return this;
        }
        let options;
        if (typeof applySkeletonOrOptions === "object") {
          options = applySkeletonOrOptions;
        } else {
          options = {
            applySkeleton: applySkeletonOrOptions,
            applyMorph
          };
        }
        const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;
        this._refreshBoundingInfo(this._sourceMesh._getData(options, null, VertexBuffer.PositionKind), bias);
        return this;
      }
      /** @internal */
      _preActivate() {
        if (this._currentLOD) {
          this._currentLOD._preActivate();
        }
        return this;
      }
      /**
       * @internal
       */
      _activate(renderId, intermediateRendering) {
        super._activate(renderId, intermediateRendering);
        if (!this._sourceMesh.subMeshes) {
          Logger.Warn("Instances should only be created for meshes with geometry.");
        }
        if (this._currentLOD) {
          const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;
          if (differentSign) {
            this._internalAbstractMeshDataInfo._actAsRegularMesh = true;
            return true;
          }
          this._internalAbstractMeshDataInfo._actAsRegularMesh = false;
          this._currentLOD._registerInstanceForRenderId(this, renderId);
          if (intermediateRendering) {
            if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {
              this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;
              return true;
            }
          } else {
            if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {
              this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;
              return true;
            }
          }
        }
        return false;
      }
      /** @internal */
      _postActivate() {
        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
          this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);
          this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());
        } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
          this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);
        }
      }
      getWorldMatrix() {
        if (this._currentLOD && this._currentLOD !== this._sourceMesh && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {
          if (!this._billboardWorldMatrix) {
            this._billboardWorldMatrix = new Matrix();
          }
          const tempMaster = this._currentLOD._masterMesh;
          this._currentLOD._masterMesh = this;
          TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);
          this._currentLOD.position.set(0, 0, 0);
          this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));
          this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);
          this._currentLOD._masterMesh = tempMaster;
          return this._billboardWorldMatrix;
        }
        return super.getWorldMatrix();
      }
      get isAnInstance() {
        return true;
      }
      /**
       * Returns the current associated LOD AbstractMesh.
       * @param camera defines the camera to use to pick the LOD level
       * @returns a Mesh or `null` if no LOD is associated with the AbstractMesh
       */
      getLOD(camera) {
        if (!camera) {
          return this;
        }
        const sourceMeshLODLevels = this.sourceMesh.getLODLevels();
        if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {
          this._currentLOD = this.sourceMesh;
        } else {
          const boundingInfo = this.getBoundingInfo();
          this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);
        }
        return this._currentLOD;
      }
      /**
       * @internal
       */
      _preActivateForIntermediateRendering(renderId) {
        return this.sourceMesh._preActivateForIntermediateRendering(renderId);
      }
      /** @internal */
      _syncSubMeshes() {
        this.releaseSubMeshes();
        if (this._sourceMesh.subMeshes) {
          for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {
            this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);
          }
        }
        return this;
      }
      /** @internal */
      _generatePointsArray() {
        return this._sourceMesh._generatePointsArray();
      }
      /** @internal */
      _updateBoundingInfo() {
        if (this.hasBoundingInfo) {
          this.getBoundingInfo().update(this.worldMatrixFromCache);
        } else {
          this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);
        }
        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
        return this;
      }
      /**
       * Creates a new InstancedMesh from the current mesh.
       *
       * Returns the clone.
       * @param name the cloned mesh name
       * @param newParent the optional Node to parent the clone to.
       * @param doNotCloneChildren if `true` the model children aren't cloned.
       * @param newSourceMesh if set this mesh will be used as the source mesh instead of ths instance's one
       * @returns the clone
       */
      clone(name, newParent = null, doNotCloneChildren, newSourceMesh) {
        const result = (newSourceMesh || this._sourceMesh).createInstance(name);
        DeepCopier.DeepCopy(this, result, [
          "name",
          "subMeshes",
          "uniqueId",
          "parent",
          "lightSources",
          "receiveShadows",
          "material",
          "visibility",
          "skeleton",
          "sourceMesh",
          "isAnInstance",
          "facetNb",
          "isFacetDataEnabled",
          "isBlocked",
          "useBones",
          "hasInstances",
          "collider",
          "edgesRenderer",
          "forward",
          "up",
          "right",
          "absolutePosition",
          "absoluteScaling",
          "absoluteRotationQuaternion",
          "isWorldMatrixFrozen",
          "nonUniformScaling",
          "behaviors",
          "worldMatrixFromCache",
          "hasThinInstances",
          "hasBoundingInfo",
          "geometry"
        ], []);
        if (newParent) {
          result.parent = newParent;
        }
        if (!doNotCloneChildren) {
          for (let index = 0; index < this.getScene().meshes.length; index++) {
            const mesh = this.getScene().meshes[index];
            if (mesh.parent === this) {
              mesh.clone(mesh.name, result);
            }
          }
        }
        result.computeWorldMatrix(true);
        this.onClonedObservable.notifyObservers(result);
        return result;
      }
      /**
       * Disposes the InstancedMesh.
       * Returns nothing.
       * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
       * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
       */
      dispose(doNotRecurse, disposeMaterialAndTextures = false) {
        this._sourceMesh.removeInstance(this);
        super.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
      /**
       * @internal
       */
      _serializeAsParent(serializationObject) {
        super._serializeAsParent(serializationObject);
        serializationObject.parentId = this._sourceMesh.uniqueId;
        serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;
      }
      /**
       * Instantiate (when possible) or clone that node with its hierarchy
       * @param newParent defines the new parent to use for the instance (or clone)
       * @param options defines options to configure how copy is done
       * @param options.doNotInstantiate defines if the model must be instantiated or just cloned
       * @param options.newSourcedMesh newSourcedMesh the new source mesh for the instance (or clone)
       * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created
       * @returns an instance (or a clone) of the current node with its hierarchy
       */
      instantiateHierarchy(newParent = null, options, onNewNodeCreated) {
        const clone = this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);
        if (clone) {
          if (onNewNodeCreated) {
            onNewNodeCreated(this, clone);
          }
        }
        for (const child of this.getChildTransformNodes(true)) {
          child.instantiateHierarchy(clone, options, onNewNodeCreated);
        }
        return clone;
      }
    };
    Mesh.prototype.registerInstancedBuffer = function(kind, stride) {
      this._userInstancedBuffersStorage?.vertexBuffers[kind]?.dispose();
      if (!this.instancedBuffers) {
        this.instancedBuffers = {};
        for (const instance of this.instances) {
          instance.instancedBuffers = {};
        }
      }
      if (!this._userInstancedBuffersStorage) {
        this._userInstancedBuffersStorage = {
          data: {},
          vertexBuffers: {},
          strides: {},
          sizes: {},
          vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
        };
      }
      this.instancedBuffers[kind] = null;
      this._userInstancedBuffersStorage.strides[kind] = stride;
      this._userInstancedBuffersStorage.sizes[kind] = stride * 32;
      this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);
      this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
      for (const instance of this.instances) {
        instance.instancedBuffers[kind] = null;
      }
      this._invalidateInstanceVertexArrayObject();
      this._markSubMeshesAsAttributesDirty();
    };
    Mesh.prototype._processInstancedBuffers = function(visibleInstances, renderSelf) {
      const instanceCount = visibleInstances ? visibleInstances.length : 0;
      for (const kind in this.instancedBuffers) {
        let size = this._userInstancedBuffersStorage.sizes[kind];
        const stride = this._userInstancedBuffersStorage.strides[kind];
        const expectedSize = (instanceCount + 1) * stride;
        while (size < expectedSize) {
          size *= 2;
        }
        if (this._userInstancedBuffersStorage.data[kind].length != size) {
          this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);
          this._userInstancedBuffersStorage.sizes[kind] = size;
          if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
            this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
            this._userInstancedBuffersStorage.vertexBuffers[kind] = null;
          }
        }
        const data = this._userInstancedBuffersStorage.data[kind];
        let offset = 0;
        if (renderSelf) {
          const value = this.instancedBuffers[kind];
          if (value.toArray) {
            value.toArray(data, offset);
          } else if (value.copyToArray) {
            value.copyToArray(data, offset);
          } else {
            data[offset] = value;
          }
          offset += stride;
        }
        for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {
          const instance = visibleInstances[instanceIndex];
          const value = instance.instancedBuffers[kind];
          if (value.toArray) {
            value.toArray(data, offset);
          } else if (value.copyToArray) {
            value.copyToArray(data, offset);
          } else {
            data[offset] = value;
          }
          offset += stride;
        }
        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {
          this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
          this._invalidateInstanceVertexArrayObject();
        } else {
          this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);
        }
      }
    };
    Mesh.prototype._invalidateInstanceVertexArrayObject = function() {
      if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === void 0) {
        return;
      }
      for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {
        this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);
      }
      this._userInstancedBuffersStorage.vertexArrayObjects = {};
    };
    Mesh.prototype._disposeInstanceSpecificData = function() {
      for (const renderPassId in this._instanceDataStorage.renderPasses) {
        this._instanceDataStorage.renderPasses[renderPassId].instancesBuffer?.dispose();
      }
      this._instanceDataStorage.renderPasses = {};
      while (this.instances.length) {
        this.instances[0].dispose();
      }
      for (const kind in this.instancedBuffers) {
        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
          this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
        }
      }
      this._invalidateInstanceVertexArrayObject();
      this.instancedBuffers = {};
    };
    RegisterClass("BABYLON.InstancedMesh", InstancedMesh);
  }
});

// node_modules/@babylonjs/core/Lights/light.js
var Light;
var init_light = __esm({
  "node_modules/@babylonjs/core/Lights/light.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_math_color();
    init_node();
    init_uniformBuffer();
    init_typeStore();
    init_lightConstants();
    init_decorators_serialization();
    Light = class _Light extends Node {
      /**
       * Defines how far from the source the light is impacting in scene units.
       * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
       */
      get range() {
        return this._range;
      }
      /**
       * Defines how far from the source the light is impacting in scene units.
       * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
       */
      set range(value) {
        this._range = value;
        this._inverseSquaredRange = 1 / (this.range * this.range);
      }
      /**
       * Gets the photometric scale used to interpret the intensity.
       * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
       */
      get intensityMode() {
        return this._intensityMode;
      }
      /**
       * Sets the photometric scale used to interpret the intensity.
       * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
       */
      set intensityMode(value) {
        this._intensityMode = value;
        this._computePhotometricScale();
      }
      /**
       * Gets the light radius used by PBR Materials to simulate soft area lights.
       */
      get radius() {
        return this._radius;
      }
      /**
       * sets the light radius used by PBR Materials to simulate soft area lights.
       */
      set radius(value) {
        this._radius = value;
        this._computePhotometricScale();
      }
      /**
       * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
       * the current shadow generator.
       */
      get shadowEnabled() {
        return this._shadowEnabled;
      }
      /**
       * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
       * the current shadow generator.
       */
      set shadowEnabled(value) {
        if (this._shadowEnabled === value) {
          return;
        }
        this._shadowEnabled = value;
        this._markMeshesAsLightDirty();
      }
      /**
       * Gets the only meshes impacted by this light.
       */
      get includedOnlyMeshes() {
        return this._includedOnlyMeshes;
      }
      /**
       * Sets the only meshes impacted by this light.
       */
      set includedOnlyMeshes(value) {
        this._includedOnlyMeshes = value;
        this._hookArrayForIncludedOnly(value);
      }
      /**
       * Gets the meshes not impacted by this light.
       */
      get excludedMeshes() {
        return this._excludedMeshes;
      }
      /**
       * Sets the meshes not impacted by this light.
       */
      set excludedMeshes(value) {
        this._excludedMeshes = value;
        this._hookArrayForExcluded(value);
      }
      /**
       * Gets the layer id use to find what meshes are not impacted by the light.
       * Inactive if 0
       */
      get excludeWithLayerMask() {
        return this._excludeWithLayerMask;
      }
      /**
       * Sets the layer id use to find what meshes are not impacted by the light.
       * Inactive if 0
       */
      set excludeWithLayerMask(value) {
        this._excludeWithLayerMask = value;
        this._resyncMeshes();
      }
      /**
       * Gets the layer id use to find what meshes are impacted by the light.
       * Inactive if 0
       */
      get includeOnlyWithLayerMask() {
        return this._includeOnlyWithLayerMask;
      }
      /**
       * Sets the layer id use to find what meshes are impacted by the light.
       * Inactive if 0
       */
      set includeOnlyWithLayerMask(value) {
        this._includeOnlyWithLayerMask = value;
        this._resyncMeshes();
      }
      /**
       * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
       */
      get lightmapMode() {
        return this._lightmapMode;
      }
      /**
       * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
       */
      set lightmapMode(value) {
        if (this._lightmapMode === value) {
          return;
        }
        this._lightmapMode = value;
        this._markMeshesAsLightDirty();
      }
      /**
       * Returns the view matrix.
       * @param _faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.
       * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
       */
      getViewMatrix(_faceIndex) {
        return null;
      }
      /**
       * Returns the projection matrix.
       * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).
       * @param _viewMatrix The view transform matrix of the light (optional).
       * @param _renderList The list of meshes to take into account when calculating the projection matrix (optional).
       * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
       */
      getProjectionMatrix(_viewMatrix, _renderList) {
        return null;
      }
      /**
       * Creates a Light object in the scene.
       * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
       * @param name The friendly name of the light
       * @param scene The scene the light belongs too
       * @param dontAddToScene True to not add the light to the scene
       */
      constructor(name, scene, dontAddToScene) {
        super(name, scene, false);
        this.diffuse = new Color3(1, 1, 1);
        this.specular = new Color3(1, 1, 1);
        this.falloffType = _Light.FALLOFF_DEFAULT;
        this.intensity = 1;
        this._range = Number.MAX_VALUE;
        this._inverseSquaredRange = 0;
        this._photometricScale = 1;
        this._intensityMode = _Light.INTENSITYMODE_AUTOMATIC;
        this._radius = 1e-5;
        this.renderPriority = 0;
        this._shadowEnabled = true;
        this._excludeWithLayerMask = 0;
        this._includeOnlyWithLayerMask = 0;
        this._lightmapMode = 0;
        this._shadowGenerators = null;
        this._excludedMeshesIds = new Array();
        this._includedOnlyMeshesIds = new Array();
        this._currentViewDepth = 0;
        this._isLight = true;
        if (!dontAddToScene) {
          this.getScene().addLight(this);
        }
        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), void 0, void 0, name);
        this._buildUniformLayout();
        this.includedOnlyMeshes = [];
        this.excludedMeshes = [];
        if (!dontAddToScene) {
          this._resyncMeshes();
        }
      }
      /**
       * Sets the passed Effect "effect" with the Light textures.
       * @param effect The effect to update
       * @param lightIndex The index of the light in the effect to update
       * @returns The light
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      transferTexturesToEffect(effect, lightIndex) {
        return this;
      }
      /**
       * Binds the lights information from the scene to the effect for the given mesh.
       * @param lightIndex Light index
       * @param scene The scene where the light belongs to
       * @param effect The effect we are binding the data to
       * @param useSpecular Defines if specular is supported
       * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows
       */
      _bindLight(lightIndex, scene, effect, useSpecular, receiveShadows = true) {
        const iAsString = lightIndex.toString();
        let needUpdate = false;
        this._uniformBuffer.bindToEffect(effect, "Light" + iAsString);
        if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {
          this._renderId = scene.getRenderId();
          this._lastUseSpecular = useSpecular;
          const scaledIntensity = this.getScaledIntensity();
          this.transferToEffect(effect, iAsString);
          this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);
          this._uniformBuffer.updateColor4("vLightDiffuse", TmpColors.Color3[0], this.range, iAsString);
          if (useSpecular) {
            this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);
            this._uniformBuffer.updateColor4("vLightSpecular", TmpColors.Color3[1], this.radius, iAsString);
          }
          needUpdate = true;
        }
        this.transferTexturesToEffect(effect, iAsString);
        if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {
          const shadowGenerator = this.getShadowGenerator(scene.activeCamera) ?? this.getShadowGenerator();
          if (shadowGenerator) {
            shadowGenerator.bindShadowLight(iAsString, effect);
            needUpdate = true;
          }
        }
        if (needUpdate) {
          this._uniformBuffer.update();
        } else {
          this._uniformBuffer.bindUniformBuffer();
        }
      }
      /**
       * Returns the string "Light".
       * @returns the class name
       */
      getClassName() {
        return "Light";
      }
      /**
       * Converts the light information to a readable string for debug purpose.
       * @param fullDetails Supports for multiple levels of logging within scene loading
       * @returns the human readable light info
       */
      toString(fullDetails) {
        let ret = "Name: " + this.name;
        ret += ", type: " + ["Point", "Directional", "Spot", "Hemispheric", "Clustered"][this.getTypeID()];
        if (this.animations) {
          for (let i = 0; i < this.animations.length; i++) {
            ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
          }
        }
        return ret;
      }
      /** @internal */
      _syncParentEnabledState() {
        super._syncParentEnabledState();
        if (!this.isDisposed()) {
          this._resyncMeshes();
        }
      }
      /**
       * Set the enabled state of this node.
       * @param value - the new enabled state
       */
      setEnabled(value) {
        super.setEnabled(value);
        this._resyncMeshes();
      }
      /**
       * Returns the Light associated shadow generator if any.
       * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator
       * @returns the associated shadow generator.
       */
      getShadowGenerator(camera = null) {
        if (this._shadowGenerators === null) {
          return null;
        }
        return this._shadowGenerators.get(camera) ?? null;
      }
      /**
       * Returns all the shadow generators associated to this light
       * @returns
       */
      getShadowGenerators() {
        return this._shadowGenerators;
      }
      /**
       * Returns a Vector3, the absolute light position in the World.
       * @returns the world space position of the light
       */
      getAbsolutePosition() {
        return Vector3.Zero();
      }
      /**
       * Specifies if the light will affect the passed mesh.
       * @param mesh The mesh to test against the light
       * @returns true the mesh is affected otherwise, false.
       */
      canAffectMesh(mesh) {
        if (!mesh) {
          return true;
        }
        if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {
          return false;
        }
        if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {
          return false;
        }
        if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {
          return false;
        }
        if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {
          return false;
        }
        return true;
      }
      /**
       * Releases resources associated with this node.
       * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
       * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
       */
      dispose(doNotRecurse, disposeMaterialAndTextures = false) {
        if (this._shadowGenerators) {
          const iterator = this._shadowGenerators.values();
          for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
            const shadowGenerator = key.value;
            shadowGenerator.dispose();
          }
          this._shadowGenerators = null;
        }
        this.getScene().stopAnimation(this);
        if (this._parentContainer) {
          const index = this._parentContainer.lights.indexOf(this);
          if (index > -1) {
            this._parentContainer.lights.splice(index, 1);
          }
          this._parentContainer = null;
        }
        for (const mesh of this.getScene().meshes) {
          mesh._removeLightSource(this, true);
        }
        this._uniformBuffer.dispose();
        this.getScene().removeLight(this);
        super.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
      /**
       * Returns the light type ID (integer).
       * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      getTypeID() {
        return 0;
      }
      /**
       * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.
       * @returns the scaled intensity in intensity mode unit
       */
      getScaledIntensity() {
        return this._photometricScale * this.intensity;
      }
      /**
       * Returns a new Light object, named "name", from the current one.
       * @param name The name of the cloned light
       * @param newParent The parent of this light, if it has one
       * @returns the new created light
       */
      clone(name, newParent = null) {
        const constructor = _Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());
        if (!constructor) {
          return null;
        }
        const clonedLight = SerializationHelper.Clone(constructor, this);
        if (name) {
          clonedLight.name = name;
        }
        if (newParent) {
          clonedLight.parent = newParent;
        }
        clonedLight.setEnabled(this.isEnabled());
        this.onClonedObservable.notifyObservers(clonedLight);
        return clonedLight;
      }
      /**
       * Serializes the current light into a Serialization object.
       * @returns the serialized object.
       */
      serialize() {
        const serializationObject = SerializationHelper.Serialize(this);
        serializationObject.uniqueId = this.uniqueId;
        serializationObject.type = this.getTypeID();
        if (this.parent) {
          this.parent._serializeAsParent(serializationObject);
        }
        if (this.excludedMeshes.length > 0) {
          serializationObject.excludedMeshesIds = [];
          for (const mesh of this.excludedMeshes) {
            serializationObject.excludedMeshesIds.push(mesh.id);
          }
        }
        if (this.includedOnlyMeshes.length > 0) {
          serializationObject.includedOnlyMeshesIds = [];
          for (const mesh of this.includedOnlyMeshes) {
            serializationObject.includedOnlyMeshesIds.push(mesh.id);
          }
        }
        SerializationHelper.AppendSerializedAnimations(this, serializationObject);
        serializationObject.ranges = this.serializeAnimationRanges();
        serializationObject.isEnabled = this.isEnabled();
        return serializationObject;
      }
      /**
       * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.
       * This new light is named "name" and added to the passed scene.
       * @param type Type according to the types available in Light.LIGHTTYPEID_x
       * @param name The friendly name of the light
       * @param scene The scene the new light will belong to
       * @returns the constructor function
       */
      static GetConstructorFromName(type, name, scene) {
        const constructorFunc = Node.Construct("Light_Type_" + type, name, scene);
        if (constructorFunc) {
          return constructorFunc;
        }
        return null;
      }
      /**
       * Parses the passed "parsedLight" and returns a new instanced Light from this parsing.
       * @param parsedLight The JSON representation of the light
       * @param scene The scene to create the parsed light in
       * @returns the created light after parsing
       */
      static Parse(parsedLight, scene) {
        const constructor = _Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);
        if (!constructor) {
          return null;
        }
        const light = SerializationHelper.Parse(constructor, parsedLight, scene);
        if (parsedLight.excludedMeshesIds) {
          light._excludedMeshesIds = parsedLight.excludedMeshesIds;
        }
        if (parsedLight.includedOnlyMeshesIds) {
          light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;
        }
        if (parsedLight.parentId !== void 0) {
          light._waitingParentId = parsedLight.parentId;
        }
        if (parsedLight.parentInstanceIndex !== void 0) {
          light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;
        }
        if (parsedLight.falloffType !== void 0) {
          light.falloffType = parsedLight.falloffType;
        }
        if (parsedLight.lightmapMode !== void 0) {
          light.lightmapMode = parsedLight.lightmapMode;
        }
        if (parsedLight.animations) {
          for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {
            const parsedAnimation = parsedLight.animations[animationIndex];
            const internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              light.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          Node.ParseAnimationRanges(light, parsedLight, scene);
        }
        if (parsedLight.autoAnimate) {
          scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1);
        }
        if (parsedLight.isEnabled !== void 0) {
          light.setEnabled(parsedLight.isEnabled);
        }
        return light;
      }
      _hookArrayForExcluded(array) {
        const oldPush = array.push;
        array.push = (...items) => {
          const result = oldPush.apply(array, items);
          for (const item of items) {
            item._resyncLightSource(this);
          }
          return result;
        };
        const oldSplice = array.splice;
        array.splice = (index, deleteCount) => {
          const deleted = oldSplice.apply(array, [index, deleteCount]);
          for (const item of deleted) {
            item._resyncLightSource(this);
          }
          return deleted;
        };
        for (const item of array) {
          item._resyncLightSource(this);
        }
      }
      _hookArrayForIncludedOnly(array) {
        const oldPush = array.push;
        array.push = (...items) => {
          const result = oldPush.apply(array, items);
          this._resyncMeshes();
          return result;
        };
        const oldSplice = array.splice;
        array.splice = (index, deleteCount) => {
          const deleted = oldSplice.apply(array, [index, deleteCount]);
          this._resyncMeshes();
          return deleted;
        };
        this._resyncMeshes();
      }
      _resyncMeshes() {
        for (const mesh of this.getScene().meshes) {
          mesh._resyncLightSource(this);
        }
      }
      /**
       * Forces the meshes to update their light related information in their rendering used effects
       * @internal Internal Use Only
       */
      _markMeshesAsLightDirty() {
        for (const mesh of this.getScene().meshes) {
          if (mesh.lightSources.indexOf(this) !== -1) {
            mesh._markSubMeshesAsLightDirty();
          }
        }
      }
      /**
       * Recomputes the cached photometric scale if needed.
       */
      _computePhotometricScale() {
        this._photometricScale = this._getPhotometricScale();
        this.getScene().resetCachedMaterial();
      }
      /**
       * @returns the Photometric Scale according to the light type and intensity mode.
       */
      _getPhotometricScale() {
        let photometricScale = 0;
        const lightTypeID = this.getTypeID();
        let photometricMode = this.intensityMode;
        if (photometricMode === _Light.INTENSITYMODE_AUTOMATIC) {
          if (lightTypeID === _Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
            photometricMode = _Light.INTENSITYMODE_ILLUMINANCE;
          } else {
            photometricMode = _Light.INTENSITYMODE_LUMINOUSINTENSITY;
          }
        }
        switch (lightTypeID) {
          case _Light.LIGHTTYPEID_POINTLIGHT:
          case _Light.LIGHTTYPEID_SPOTLIGHT:
            switch (photometricMode) {
              case _Light.INTENSITYMODE_LUMINOUSPOWER:
                photometricScale = 1 / (4 * Math.PI);
                break;
              case _Light.INTENSITYMODE_LUMINOUSINTENSITY:
                photometricScale = 1;
                break;
              case _Light.INTENSITYMODE_LUMINANCE:
                photometricScale = this.radius * this.radius;
                break;
            }
            break;
          case _Light.LIGHTTYPEID_DIRECTIONALLIGHT:
            switch (photometricMode) {
              case _Light.INTENSITYMODE_ILLUMINANCE:
                photometricScale = 1;
                break;
              case _Light.INTENSITYMODE_LUMINANCE: {
                let apexAngleRadians = this.radius;
                apexAngleRadians = Math.max(apexAngleRadians, 1e-3);
                const solidAngle = 2 * Math.PI * (1 - Math.cos(apexAngleRadians));
                photometricScale = solidAngle;
                break;
              }
            }
            break;
          case _Light.LIGHTTYPEID_HEMISPHERICLIGHT:
            photometricScale = 1;
            break;
        }
        return photometricScale;
      }
      /**
       * Reorder the light in the scene according to their defined priority.
       * @internal Internal Use Only
       */
      _reorderLightsInScene() {
        const scene = this.getScene();
        if (this._renderPriority != 0) {
          scene.requireLightSorting = true;
        }
        this.getScene().sortLightsByPriority();
      }
      /**
       * @internal
       */
      _isReady() {
        return true;
      }
    };
    Light.FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;
    Light.FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;
    Light.FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;
    Light.FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;
    Light.LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;
    Light.LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;
    Light.LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;
    Light.INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;
    Light.INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;
    Light.INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;
    Light.INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;
    Light.INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;
    Light.LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;
    Light.LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;
    Light.LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;
    Light.LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;
    Light.LIGHTTYPEID_RECT_AREALIGHT = LightConstants.LIGHTTYPEID_RECT_AREALIGHT;
    __decorate([
      serializeAsColor3()
    ], Light.prototype, "diffuse", void 0);
    __decorate([
      serializeAsColor3()
    ], Light.prototype, "specular", void 0);
    __decorate([
      serialize()
    ], Light.prototype, "falloffType", void 0);
    __decorate([
      serialize()
    ], Light.prototype, "intensity", void 0);
    __decorate([
      serialize()
    ], Light.prototype, "range", null);
    __decorate([
      serialize()
    ], Light.prototype, "intensityMode", null);
    __decorate([
      serialize()
    ], Light.prototype, "radius", null);
    __decorate([
      serialize()
    ], Light.prototype, "_renderPriority", void 0);
    __decorate([
      expandToProperty("_reorderLightsInScene")
    ], Light.prototype, "renderPriority", void 0);
    __decorate([
      serialize("shadowEnabled")
    ], Light.prototype, "_shadowEnabled", void 0);
    __decorate([
      serialize("excludeWithLayerMask")
    ], Light.prototype, "_excludeWithLayerMask", void 0);
    __decorate([
      serialize("includeOnlyWithLayerMask")
    ], Light.prototype, "_includeOnlyWithLayerMask", void 0);
    __decorate([
      serialize("lightmapMode")
    ], Light.prototype, "_lightmapMode", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/Textures/rawTexture.js
var RawTexture;
var init_rawTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/rawTexture.js"() {
    init_texture();
    RawTexture = class _RawTexture extends Texture {
      /**
       * Instantiates a new RawTexture.
       * Raw texture can help creating a texture directly from an array of data.
       * This can be super useful if you either get the data from an uncompressed source or
       * if you wish to create your texture pixel by pixel.
       * @param data define the array of data to use to create the texture (null to create an empty texture)
       * @param width define the width of the texture
       * @param height define the height of the texture
       * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)
       * @param sceneOrEngine defines the scene or engine the texture will belong to
       * @param generateMipMaps define whether mip maps should be generated or not
       * @param invertY define if the data should be flipped on Y when uploaded to the GPU
       * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
       * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
       * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
       * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
       * @param waitDataToBeReady If set to true Rawtexture will wait data to be set in order to be flaged as ready.
       * @param mipLevelCount defines the number of mip levels to allocate for the texture
       */
      constructor(data, width, height, format, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags, useSRGBBuffer, waitDataToBeReady, mipLevelCount) {
        super(null, sceneOrEngine, !generateMipMaps, invertY, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, creationFlags);
        this.format = format;
        if (!this._engine) {
          return;
        }
        if (!this._engine._caps.textureFloatLinearFiltering && type === 1) {
          samplingMode = 1;
        }
        if (!this._engine._caps.textureHalfFloatLinearFiltering && type === 2) {
          samplingMode = 1;
        }
        this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags ?? 0, useSRGBBuffer ?? false, mipLevelCount);
        this.wrapU = Texture.CLAMP_ADDRESSMODE;
        this.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._waitingForData = !!waitDataToBeReady && !data;
      }
      /**
       * Updates the texture underlying data.
       * @param data Define the new data of the texture
       */
      update(data) {
        this.updateMipLevel(data, 0);
      }
      /**
       * Updates a specific mip level of the texture.
       * @param data The new data for the mip level
       * @param mipLevel The mip level to update (0 is the base level)
       */
      updateMipLevel(data, mipLevel) {
        this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type, this._texture._useSRGBBuffer, mipLevel);
        this._waitingForData = false;
      }
      /**
       * Clones the texture.
       * @returns the cloned texture
       */
      clone() {
        if (!this._texture) {
          return super.clone();
        }
        const rawTexture = new _RawTexture(null, this.getSize().width, this.getSize().height, this.format, this.getScene(), this._texture.generateMipMaps, this._invertY, this.samplingMode, this._texture.type, this._texture._creationFlags, this._useSRGBBuffer);
        rawTexture._texture = this._texture;
        this._texture.incrementReferences();
        return rawTexture;
      }
      isReady() {
        return super.isReady() && !this._waitingForData;
      }
      /**
       * Creates a luminance texture from some data.
       * @param data Define the texture data
       * @param width Define the width of the texture
       * @param height Define the height of the texture
       * @param sceneOrEngine defines the scene or engine the texture will belong to
       * @param generateMipMaps Define whether or not to create mip maps for the texture
       * @param invertY define if the data should be flipped on Y when uploaded to the GPU
       * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
       * @returns the luminance texture
       */
      static CreateLuminanceTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
        return new _RawTexture(data, width, height, 1, sceneOrEngine, generateMipMaps, invertY, samplingMode);
      }
      /**
       * Creates a luminance alpha texture from some data.
       * @param data Define the texture data
       * @param width Define the width of the texture
       * @param height Define the height of the texture
       * @param sceneOrEngine defines the scene or engine the texture will belong to
       * @param generateMipMaps Define whether or not to create mip maps for the texture
       * @param invertY define if the data should be flipped on Y when uploaded to the GPU
       * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
       * @returns the luminance alpha texture
       */
      static CreateLuminanceAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
        return new _RawTexture(data, width, height, 2, sceneOrEngine, generateMipMaps, invertY, samplingMode);
      }
      /**
       * Creates an alpha texture from some data.
       * @param data Define the texture data
       * @param width Define the width of the texture
       * @param height Define the height of the texture
       * @param sceneOrEngine defines the scene or engine the texture will belong to
       * @param generateMipMaps Define whether or not to create mip maps for the texture
       * @param invertY define if the data should be flipped on Y when uploaded to the GPU
       * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
       * @returns the alpha texture
       */
      static CreateAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
        return new _RawTexture(data, width, height, 0, sceneOrEngine, generateMipMaps, invertY, samplingMode);
      }
      /**
       * Creates a RGB texture from some data.
       * @param data Define the texture data
       * @param width Define the width of the texture
       * @param height Define the height of the texture
       * @param sceneOrEngine defines the scene or engine the texture will belong to
       * @param generateMipMaps Define whether or not to create mip maps for the texture
       * @param invertY define if the data should be flipped on Y when uploaded to the GPU
       * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
       * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
       * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
       * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
       * @returns the RGB alpha texture
       */
      static CreateRGBTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false) {
        return new _RawTexture(data, width, height, 4, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);
      }
      /**
       * Creates a RGBA texture from some data.
       * @param data Define the texture data
       * @param width Define the width of the texture
       * @param height Define the height of the texture
       * @param sceneOrEngine defines the scene or engine the texture will belong to
       * @param generateMipMaps Define whether or not to create mip maps for the texture
       * @param invertY define if the data should be flipped on Y when uploaded to the GPU
       * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
       * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
       * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
       * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
       * @param waitDataToBeReady if set to true this will force texture to wait for data to be set before it is considered ready.
       * @returns the RGBA texture
       */
      static CreateRGBATexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false, waitDataToBeReady = false) {
        return new _RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer, waitDataToBeReady);
      }
      /**
       * Creates a RGBA storage texture from some data.
       * @param data Define the texture data
       * @param width Define the width of the texture
       * @param height Define the height of the texture
       * @param sceneOrEngine defines the scene or engine the texture will belong to
       * @param generateMipMaps Define whether or not to create mip maps for the texture
       * @param invertY define if the data should be flipped on Y when uploaded to the GPU
       * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
       * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
       * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
       * @returns the RGBA texture
       */
      static CreateRGBAStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, useSRGBBuffer = false) {
        return new _RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1, useSRGBBuffer);
      }
      /**
       * Creates a R texture from some data.
       * @param data Define the texture data
       * @param width Define the width of the texture
       * @param height Define the height of the texture
       * @param sceneOrEngine defines the scene or engine the texture will belong to
       * @param generateMipMaps Define whether or not to create mip maps for the texture
       * @param invertY define if the data should be flipped on Y when uploaded to the GPU
       * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
       * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
       * @returns the R texture
       */
      static CreateRTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {
        return new _RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);
      }
      /**
       * Creates a R storage texture from some data.
       * @param data Define the texture data
       * @param width Define the width of the texture
       * @param height Define the height of the texture
       * @param sceneOrEngine defines the scene or engine the texture will belong to
       * @param generateMipMaps Define whether or not to create mip maps for the texture
       * @param invertY define if the data should be flipped on Y when uploaded to the GPU
       * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
       * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
       * @returns the R texture
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      static CreateRStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {
        return new _RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1);
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/targetCamera.js
var TmpMatrix, TmpQuaternion, TargetCamera;
var init_targetCamera = __esm({
  "node_modules/@babylonjs/core/Cameras/targetCamera.js"() {
    init_tslib_es6();
    init_decorators();
    init_camera();
    init_math_vector();
    init_math_constants();
    init_math_axis();
    init_node();
    Node.AddNodeConstructor("TargetCamera", (name, scene) => {
      return () => new TargetCamera(name, Vector3.Zero(), scene);
    });
    TmpMatrix = Matrix.Zero();
    TmpQuaternion = Quaternion.Identity();
    TargetCamera = class _TargetCamera extends Camera {
      /**
       * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.
       * This is the base of the follow, arc rotate cameras and Free camera
       * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras
       * @param name Defines the name of the camera in the scene
       * @param position Defines the start position of the camera in the scene
       * @param scene Defines the scene the camera belongs to
       * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined
       */
      constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {
        super(name, position, scene, setActiveOnSceneIfNoneActive);
        this.cameraDirection = new Vector3(0, 0, 0);
        this.cameraRotation = new Vector2(0, 0);
        this.updateUpVectorFromRotation = false;
        this.speed = 2;
        this.noRotationConstraint = false;
        this.invertRotation = false;
        this.inverseRotationSpeed = 0.2;
        this._panningEpsilon = Epsilon;
        this._rotationEpsilon = Epsilon;
        this.lockedTarget = null;
        this._currentTarget = Vector3.Zero();
        this._initialFocalDistance = 1;
        this._viewMatrix = Matrix.Zero();
        this._cameraTransformMatrix = Matrix.Zero();
        this._cameraRotationMatrix = Matrix.Zero();
        this._transformedReferencePoint = Vector3.Zero();
        this._deferredPositionUpdate = new Vector3();
        this._deferredRotationQuaternionUpdate = new Quaternion();
        this._deferredRotationUpdate = new Vector3();
        this._deferredUpdated = false;
        this._deferOnly = false;
        this._cachedRotationZ = 0;
        this._cachedQuaternionRotationZ = 0;
        this._referencePoint = Vector3.Forward(this.getScene().useRightHandedSystem);
        this.rotation = new Vector3(0, this.getScene().useRightHandedSystem ? Math.PI : 0, 0);
      }
      /**
       * Gets the position in front of the camera at a given distance.
       * @param distance The distance from the camera we want the position to be
       * @returns the position
       */
      getFrontPosition(distance) {
        this.getWorldMatrix();
        const worldForward = TmpVectors.Vector3[0];
        const localForward = TmpVectors.Vector3[1];
        localForward.set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
        this.getDirectionToRef(localForward, worldForward);
        worldForward.scaleInPlace(distance);
        return this.globalPosition.add(worldForward);
      }
      /** @internal */
      _getLockedTargetPosition() {
        if (!this.lockedTarget) {
          return null;
        }
        if (this.lockedTarget.absolutePosition) {
          const lockedTarget = this.lockedTarget;
          const m = lockedTarget.computeWorldMatrix();
          m.getTranslationToRef(lockedTarget.absolutePosition);
        }
        return this.lockedTarget.absolutePosition || this.lockedTarget;
      }
      /**
       * Store current camera state of the camera (fov, position, rotation, etc..)
       * @returns the camera
       */
      storeState() {
        this._storedPosition = this.position.clone();
        this._storedRotation = this.rotation.clone();
        if (this.rotationQuaternion) {
          this._storedRotationQuaternion = this.rotationQuaternion.clone();
        }
        return super.storeState();
      }
      /**
       * Restored camera state. You must call storeState() first
       * @returns whether it was successful or not
       * @internal
       */
      _restoreStateValues() {
        if (!super._restoreStateValues()) {
          return false;
        }
        this.position = this._storedPosition.clone();
        this.rotation = this._storedRotation.clone();
        if (this.rotationQuaternion && this._storedRotationQuaternion) {
          this.rotationQuaternion = this._storedRotationQuaternion.clone();
        }
        this.cameraDirection.copyFromFloats(0, 0, 0);
        this.cameraRotation.copyFromFloats(0, 0);
        return true;
      }
      /** @internal */
      _initCache() {
        super._initCache();
        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      }
      /**
       * @internal
       */
      _updateCache(ignoreParentClass) {
        if (!ignoreParentClass) {
          super._updateCache();
        }
        const lockedTargetPosition = this._getLockedTargetPosition();
        if (!lockedTargetPosition) {
          this._cache.lockedTarget = null;
        } else {
          if (!this._cache.lockedTarget) {
            this._cache.lockedTarget = lockedTargetPosition.clone();
          } else {
            this._cache.lockedTarget.copyFrom(lockedTargetPosition);
          }
        }
        this._cache.rotation.copyFrom(this.rotation);
        if (this.rotationQuaternion) {
          this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);
        }
      }
      // Synchronized
      /** @internal */
      _isSynchronizedViewMatrix() {
        if (!super._isSynchronizedViewMatrix()) {
          return false;
        }
        const lockedTargetPosition = this._getLockedTargetPosition();
        return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));
      }
      // Methods
      /** @internal */
      _computeLocalCameraSpeed() {
        const engine = this.getEngine();
        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100));
      }
      // Target
      /**
       * Defines the target the camera should look at.
       * @param target Defines the new target as a Vector
       */
      setTarget(target) {
        this.upVector.normalize();
        this._initialFocalDistance = target.subtract(this.position).length();
        if (this.position.z === target.z) {
          this.position.z += Epsilon;
        }
        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);
        if (this.getScene().useRightHandedSystem) {
          Matrix.LookAtRHToRef(this.position, target, Vector3.UpReadOnly, TmpMatrix);
        } else {
          Matrix.LookAtLHToRef(this.position, target, Vector3.UpReadOnly, TmpMatrix);
        }
        TmpMatrix.invert();
        const rotationQuaternion = this.rotationQuaternion || TmpQuaternion;
        Quaternion.FromRotationMatrixToRef(TmpMatrix, rotationQuaternion);
        rotationQuaternion.toEulerAnglesToRef(this.rotation);
        this.rotation.z = 0;
      }
      /**
       * Defines the target point of the camera.
       * The camera looks towards it form the radius distance.
       */
      get target() {
        return this.getTarget();
      }
      set target(value) {
        this.setTarget(value);
      }
      /**
       * Return the current target position of the camera. This value is expressed in local space.
       * @returns the target position
       */
      getTarget() {
        return this._currentTarget;
      }
      /** @internal */
      _decideIfNeedsToMove() {
        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
      }
      /** @internal */
      _updatePosition() {
        if (this.parent) {
          this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);
          Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);
          this._deferredPositionUpdate.addInPlace(TmpVectors.Vector3[0]);
          if (!this._deferOnly) {
            this.position.copyFrom(this._deferredPositionUpdate);
          } else {
            this._deferredUpdated = true;
          }
          return;
        }
        this._deferredPositionUpdate.addInPlace(this.cameraDirection);
        if (!this._deferOnly) {
          this.position.copyFrom(this._deferredPositionUpdate);
        } else {
          this._deferredUpdated = true;
        }
      }
      /** @internal */
      _checkInputs() {
        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1;
        const needToMove = this._decideIfNeedsToMove();
        const needToRotate = this.cameraRotation.x || this.cameraRotation.y;
        this._deferredUpdated = false;
        this._deferredRotationUpdate.copyFrom(this.rotation);
        this._deferredPositionUpdate.copyFrom(this.position);
        if (this.rotationQuaternion) {
          this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion);
        }
        if (needToMove) {
          this._updatePosition();
        }
        if (needToRotate) {
          if (this.rotationQuaternion) {
            this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate);
          }
          this._deferredRotationUpdate.x += this.cameraRotation.x * directionMultiplier;
          this._deferredRotationUpdate.y += this.cameraRotation.y * directionMultiplier;
          if (!this.noRotationConstraint) {
            const limit = 1.570796;
            if (this._deferredRotationUpdate.x > limit) {
              this._deferredRotationUpdate.x = limit;
            }
            if (this._deferredRotationUpdate.x < -limit) {
              this._deferredRotationUpdate.x = -limit;
            }
          }
          if (!this._deferOnly) {
            this.rotation.copyFrom(this._deferredRotationUpdate);
          } else {
            this._deferredUpdated = true;
          }
          if (this.rotationQuaternion) {
            const len = this._deferredRotationUpdate.lengthSquared();
            if (len) {
              Quaternion.RotationYawPitchRollToRef(this._deferredRotationUpdate.y, this._deferredRotationUpdate.x, this._deferredRotationUpdate.z, this._deferredRotationQuaternionUpdate);
              if (!this._deferOnly) {
                this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);
              } else {
                this._deferredUpdated = true;
              }
            }
          }
        }
        const inertialPanningLimit = this.speed * this._panningEpsilon;
        const inertialRotationLimit = this.speed * this._rotationEpsilon;
        if (needToMove) {
          if (Math.abs(this.cameraDirection.x) < inertialPanningLimit) {
            this.cameraDirection.x = 0;
          }
          if (Math.abs(this.cameraDirection.y) < inertialPanningLimit) {
            this.cameraDirection.y = 0;
          }
          if (Math.abs(this.cameraDirection.z) < inertialPanningLimit) {
            this.cameraDirection.z = 0;
          }
          this.cameraDirection.scaleInPlace(this.inertia);
        }
        if (needToRotate) {
          if (Math.abs(this.cameraRotation.x) < inertialRotationLimit) {
            this.cameraRotation.x = 0;
          }
          if (Math.abs(this.cameraRotation.y) < inertialRotationLimit) {
            this.cameraRotation.y = 0;
          }
          this.cameraRotation.scaleInPlace(this.inertia);
        }
        super._checkInputs();
      }
      _updateCameraRotationMatrix() {
        if (this.rotationQuaternion) {
          this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);
        } else {
          Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);
        }
      }
      /**
       * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)
       * @returns the current camera
       */
      _rotateUpVectorWithCameraRotationMatrix() {
        Vector3.TransformNormalToRef(Vector3.UpReadOnly, this._cameraRotationMatrix, this.upVector);
        return this;
      }
      /** @internal */
      _getViewMatrix() {
        if (this.lockedTarget) {
          this.setTarget(this._getLockedTargetPosition());
        }
        this._updateCameraRotationMatrix();
        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {
          this._rotateUpVectorWithCameraRotationMatrix();
          this._cachedQuaternionRotationZ = this.rotationQuaternion.z;
        } else if (this._cachedRotationZ !== this.rotation.z) {
          this._rotateUpVectorWithCameraRotationMatrix();
          this._cachedRotationZ = this.rotation.z;
        }
        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);
        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);
        if (this.updateUpVectorFromRotation) {
          if (this.rotationQuaternion) {
            Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);
          } else {
            Quaternion.FromEulerVectorToRef(this.rotation, TmpQuaternion);
            Axis.Y.rotateByQuaternionToRef(TmpQuaternion, this.upVector);
          }
        }
        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);
        return this._viewMatrix;
      }
      _computeViewMatrix(position, target, up) {
        if (this.getScene().useRightHandedSystem) {
          Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);
        } else {
          Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);
        }
        if (this.parent) {
          const parentWorldMatrix = this.parent.getWorldMatrix();
          this._viewMatrix.invert();
          this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);
          this._viewMatrix.invert();
          this._markSyncedWithParent();
        }
      }
      /**
       * @internal
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      createRigCamera(name, cameraIndex) {
        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {
          const rigCamera = new _TargetCamera(name, this.position.clone(), this.getScene());
          rigCamera.isRigCamera = true;
          rigCamera.rigParent = this;
          if (this.cameraRigMode === Camera.RIG_MODE_VR) {
            if (!this.rotationQuaternion) {
              this.rotationQuaternion = new Quaternion();
            }
            rigCamera._cameraRigParams = {};
            rigCamera.rotationQuaternion = new Quaternion();
          }
          rigCamera.mode = this.mode;
          rigCamera.orthoLeft = this.orthoLeft;
          rigCamera.orthoRight = this.orthoRight;
          rigCamera.orthoTop = this.orthoTop;
          rigCamera.orthoBottom = this.orthoBottom;
          return rigCamera;
        }
        return null;
      }
      /**
       * @internal
       */
      _updateRigCameras() {
        const camLeft = this._rigCameras[0];
        const camRight = this._rigCameras[1];
        this.computeWorldMatrix();
        switch (this.cameraRigMode) {
          case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
          case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
          case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
          case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
          case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {
            const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;
            const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;
            this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);
            this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);
            break;
          }
          case Camera.RIG_MODE_VR:
            if (camLeft.rotationQuaternion && camRight.rotationQuaternion && this.rotationQuaternion) {
              camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);
              camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);
            } else {
              camLeft.rotation.copyFrom(this.rotation);
              camRight.rotation.copyFrom(this.rotation);
            }
            camLeft.position.copyFrom(this.position);
            camRight.position.copyFrom(this.position);
            break;
        }
        super._updateRigCameras();
      }
      _getRigCamPositionAndTarget(halfSpace, rigCamera) {
        const target = this.getTarget();
        target.subtractToRef(this.position, _TargetCamera._TargetFocalPoint);
        _TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);
        const newFocalTarget = _TargetCamera._TargetFocalPoint.addInPlace(this.position);
        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, _TargetCamera._TargetTransformMatrix);
        _TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), _TargetCamera._RigCamTransformMatrix);
        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, _TargetCamera._TargetTransformMatrix);
        _TargetCamera._RigCamTransformMatrix.multiplyToRef(_TargetCamera._TargetTransformMatrix, _TargetCamera._RigCamTransformMatrix);
        Vector3.TransformCoordinatesToRef(this.position, _TargetCamera._RigCamTransformMatrix, rigCamera.position);
        rigCamera.setTarget(newFocalTarget);
      }
      /**
       * Gets the current object class name.
       * @returns the class name
       */
      getClassName() {
        return "TargetCamera";
      }
    };
    TargetCamera._RigCamTransformMatrix = new Matrix();
    TargetCamera._TargetTransformMatrix = new Matrix();
    TargetCamera._TargetFocalPoint = new Vector3();
    __decorate([
      serialize()
    ], TargetCamera.prototype, "updateUpVectorFromRotation", void 0);
    __decorate([
      serializeAsVector3()
    ], TargetCamera.prototype, "rotation", void 0);
    __decorate([
      serialize()
    ], TargetCamera.prototype, "speed", void 0);
    __decorate([
      serializeAsMeshReference("lockedTargetId")
    ], TargetCamera.prototype, "lockedTarget", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/materialPluginManager.js
function RegisterMaterialPlugin(pluginName, factory) {
  if (!Inited) {
    MaterialObserver = Material.OnEventObservable.add(
      (material) => {
        for (const [, factory2] of Plugins) {
          factory2(material);
        }
      },
      1
      /* MaterialPluginEvent.Created */
    );
    Inited = true;
  }
  const existing = Plugins.filter(([name, _factory]) => name === pluginName);
  if (existing.length > 0) {
    existing[0][1] = factory;
  } else {
    Plugins.push([pluginName, factory]);
  }
}
function UnregisterMaterialPlugin(pluginName) {
  for (let i = 0; i < Plugins.length; ++i) {
    if (Plugins[i][0] === pluginName) {
      Plugins.splice(i, 1);
      if (Plugins.length === 0) {
        UnregisterAllMaterialPlugins();
      }
      return true;
    }
  }
  return false;
}
function UnregisterAllMaterialPlugins() {
  Plugins.length = 0;
  Inited = false;
  Material.OnEventObservable.remove(MaterialObserver);
  MaterialObserver = null;
}
var RxOption, MaterialPluginManager, Plugins, Inited, MaterialObserver;
var init_materialPluginManager = __esm({
  "node_modules/@babylonjs/core/Materials/materialPluginManager.js"() {
    init_material();
    init_engineStore();
    init_shaderProcessor();
    init_shaderStore();
    RxOption = new RegExp("^([gimus]+)!");
    MaterialPluginManager = class _MaterialPluginManager {
      /**
       * Creates a new instance of the plugin manager
       * @param material material that this manager will manage the plugins for
       */
      constructor(material) {
        this._plugins = [];
        this._activePlugins = [];
        this._activePluginsForExtraEvents = [];
        this._material = material;
        this._scene = material.getScene();
        this._engine = this._scene.getEngine();
      }
      /**
       * @internal
       */
      _addPlugin(plugin) {
        for (let i = 0; i < this._plugins.length; ++i) {
          if (this._plugins[i].name === plugin.name) {
            return false;
          }
        }
        if (this._material._uniformBufferLayoutBuilt) {
          this._material.resetDrawCache();
          this._material._createUniformBuffer();
        }
        if (!plugin.isCompatible(this._material.shaderLanguage)) {
          throw `The plugin "${plugin.name}" can't be added to the material "${this._material.name}" because the plugin is not compatible with the shader language of the material.`;
        }
        const pluginClassName = plugin.getClassName();
        if (!_MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]) {
          _MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName] = "MATERIALPLUGIN_" + ++_MaterialPluginManager._MaterialPluginCounter;
        }
        this._material._callbackPluginEventGeneric = (id, info) => this._handlePluginEvent(id, info);
        this._plugins.push(plugin);
        this._plugins.sort((a, b) => a.priority - b.priority);
        this._codeInjectionPoints = {};
        const defineNamesFromPlugins = {};
        defineNamesFromPlugins[_MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]] = {
          type: "boolean",
          default: true
        };
        for (const plugin2 of this._plugins) {
          plugin2.collectDefines(defineNamesFromPlugins);
          this._collectPointNames("vertex", plugin2.getCustomCode("vertex", this._material.shaderLanguage));
          this._collectPointNames("fragment", plugin2.getCustomCode("fragment", this._material.shaderLanguage));
        }
        this._defineNamesFromPlugins = defineNamesFromPlugins;
        return true;
      }
      /**
       * @internal
       */
      _activatePlugin(plugin) {
        if (this._activePlugins.indexOf(plugin) === -1) {
          this._activePlugins.push(plugin);
          this._activePlugins.sort((a, b) => a.priority - b.priority);
          this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this);
          this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this);
          this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this);
          this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this);
          if (plugin.registerForExtraEvents) {
            this._activePluginsForExtraEvents.push(plugin);
            this._activePluginsForExtraEvents.sort((a, b) => a.priority - b.priority);
            this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this);
            this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this);
            this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this);
          }
        }
      }
      /**
       * Gets a plugin from the list of plugins managed by this manager
       * @param name name of the plugin
       * @returns the plugin if found, else null
       */
      getPlugin(name) {
        for (let i = 0; i < this._plugins.length; ++i) {
          if (this._plugins[i].name === name) {
            return this._plugins[i];
          }
        }
        return null;
      }
      _handlePluginEventIsReadyForSubMesh(eventData) {
        let isReady = true;
        for (const plugin of this._activePlugins) {
          isReady = isReady && plugin.isReadyForSubMesh(eventData.defines, this._scene, this._engine, eventData.subMesh);
        }
        eventData.isReadyForSubMesh = isReady;
      }
      _handlePluginEventPrepareDefinesBeforeAttributes(eventData) {
        for (const plugin of this._activePlugins) {
          plugin.prepareDefinesBeforeAttributes(eventData.defines, this._scene, eventData.mesh);
        }
      }
      _handlePluginEventPrepareDefines(eventData) {
        for (const plugin of this._activePlugins) {
          plugin.prepareDefines(eventData.defines, this._scene, eventData.mesh);
        }
      }
      _handlePluginEventHardBindForSubMesh(eventData) {
        for (const plugin of this._activePluginsForExtraEvents) {
          plugin.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);
        }
      }
      _handlePluginEventBindForSubMesh(eventData) {
        for (const plugin of this._activePlugins) {
          plugin.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);
        }
      }
      _handlePluginEventHasRenderTargetTextures(eventData) {
        let hasRenderTargetTextures = false;
        for (const plugin of this._activePluginsForExtraEvents) {
          hasRenderTargetTextures = plugin.hasRenderTargetTextures();
          if (hasRenderTargetTextures) {
            break;
          }
        }
        eventData.hasRenderTargetTextures = hasRenderTargetTextures;
      }
      _handlePluginEventFillRenderTargetTextures(eventData) {
        for (const plugin of this._activePluginsForExtraEvents) {
          plugin.fillRenderTargetTextures(eventData.renderTargets);
        }
      }
      _handlePluginEvent(id, info) {
        switch (id) {
          case 512: {
            const eventData = info;
            for (const plugin of this._activePlugins) {
              plugin.getActiveTextures(eventData.activeTextures);
            }
            break;
          }
          case 256: {
            const eventData = info;
            for (const plugin of this._activePlugins) {
              plugin.getAnimatables(eventData.animatables);
            }
            break;
          }
          case 1024: {
            const eventData = info;
            let hasTexture = false;
            for (const plugin of this._activePlugins) {
              hasTexture = plugin.hasTexture(eventData.texture);
              if (hasTexture) {
                break;
              }
            }
            eventData.hasTexture = hasTexture;
            break;
          }
          case 2: {
            const eventData = info;
            for (const plugin of this._plugins) {
              plugin.dispose(eventData.forceDisposeTextures);
            }
            break;
          }
          case 4: {
            const eventData = info;
            eventData.defineNames = this._defineNamesFromPlugins;
            break;
          }
          case 128: {
            const eventData = info;
            for (const plugin of this._activePlugins) {
              eventData.fallbackRank = plugin.addFallbacks(eventData.defines, eventData.fallbacks, eventData.fallbackRank);
              plugin.getAttributes(eventData.attributes, this._scene, eventData.mesh);
            }
            if (this._uniformList.length > 0) {
              eventData.uniforms.push(...this._uniformList);
            }
            if (this._samplerList.length > 0) {
              eventData.samplers.push(...this._samplerList);
            }
            if (this._uboList.length > 0) {
              eventData.uniformBuffersNames.push(...this._uboList);
            }
            eventData.customCode = this._injectCustomCode(eventData, eventData.customCode);
            break;
          }
          case 8: {
            const eventData = info;
            this._uboDeclaration = "";
            this._vertexDeclaration = "";
            this._fragmentDeclaration = "";
            this._uniformList = [];
            this._samplerList = [];
            this._uboList = [];
            const isWebGPU = this._material.shaderLanguage === 1;
            for (const plugin of this._plugins) {
              const uniforms = plugin.getUniforms(this._material.shaderLanguage);
              if (uniforms) {
                if (uniforms.ubo) {
                  for (const uniform of uniforms.ubo) {
                    if (uniform.size && uniform.type) {
                      const arraySize = uniform.arraySize ?? 0;
                      eventData.ubo.addUniform(uniform.name, uniform.size, arraySize);
                      if (isWebGPU) {
                        let type;
                        switch (uniform.type) {
                          case "mat4":
                            type = "mat4x4f";
                            break;
                          case "float":
                            type = "f32";
                            break;
                          default:
                            type = `${uniform.type}f`;
                            break;
                        }
                        if (arraySize > 0) {
                          this._uboDeclaration += `uniform ${uniform.name}: array<${type}, ${arraySize}>;
`;
                        } else {
                          this._uboDeclaration += `uniform ${uniform.name}: ${type};
`;
                        }
                      } else {
                        this._uboDeclaration += `${uniform.type} ${uniform.name}${arraySize > 0 ? `[${arraySize}]` : ""};
`;
                      }
                    }
                    this._uniformList.push(uniform.name);
                  }
                }
                if (uniforms.vertex) {
                  this._vertexDeclaration += uniforms.vertex + "\n";
                }
                if (uniforms.fragment) {
                  this._fragmentDeclaration += uniforms.fragment + "\n";
                }
                if (uniforms.externalUniforms) {
                  this._uniformList.push(...uniforms.externalUniforms);
                }
              }
              plugin.getSamplers(this._samplerList);
              plugin.getUniformBuffersNames(this._uboList);
            }
            break;
          }
        }
      }
      _collectPointNames(shaderType, customCode) {
        if (!customCode) {
          return;
        }
        for (const pointName in customCode) {
          if (!this._codeInjectionPoints[shaderType]) {
            this._codeInjectionPoints[shaderType] = {};
          }
          this._codeInjectionPoints[shaderType][pointName] = true;
        }
      }
      _injectCustomCode(eventData, existingCallback) {
        return (shaderType, code) => {
          if (existingCallback) {
            code = existingCallback(shaderType, code);
          }
          if (this._uboDeclaration) {
            code = code.replace("#define ADDITIONAL_UBO_DECLARATION", this._uboDeclaration);
          }
          if (this._vertexDeclaration) {
            code = code.replace("#define ADDITIONAL_VERTEX_DECLARATION", this._vertexDeclaration);
          }
          if (this._fragmentDeclaration) {
            code = code.replace("#define ADDITIONAL_FRAGMENT_DECLARATION", this._fragmentDeclaration);
          }
          const points = this._codeInjectionPoints?.[shaderType];
          if (!points) {
            return code;
          }
          let processorOptions = null;
          for (let pointName in points) {
            let injectedCode = "";
            for (const plugin of this._activePlugins) {
              const shaderLanguage = this._material.shaderLanguage;
              let customCode = plugin.getCustomCode(shaderType, shaderLanguage)?.[pointName];
              if (!customCode) {
                continue;
              }
              if (plugin.resolveIncludes) {
                if (processorOptions === null) {
                  processorOptions = {
                    defines: [],
                    // not used by _ProcessIncludes
                    indexParameters: eventData.indexParameters,
                    isFragment: false,
                    shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
                    processor: void 0,
                    // not used by _ProcessIncludes
                    supportsUniformBuffers: this._engine.supportsUniformBuffers,
                    shadersRepository: ShaderStore.GetShadersRepository(shaderLanguage),
                    includesShadersStore: ShaderStore.GetIncludesShadersStore(shaderLanguage),
                    version: void 0,
                    // not used by _ProcessIncludes
                    platformName: this._engine.shaderPlatformName,
                    processingContext: void 0,
                    // not used by _ProcessIncludes
                    isNDCHalfZRange: this._engine.isNDCHalfZRange,
                    useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
                    processCodeAfterIncludes: void 0
                    // not used by _ProcessIncludes
                  };
                }
                processorOptions.isFragment = shaderType === "fragment";
                ProcessIncludes(customCode, processorOptions, (code2) => customCode = code2);
              }
              injectedCode += customCode + "\n";
            }
            if (injectedCode.length > 0) {
              if (pointName.charAt(0) === "!") {
                pointName = pointName.substring(1);
                let regexFlags = "g";
                if (pointName.charAt(0) === "!") {
                  regexFlags = "";
                  pointName = pointName.substring(1);
                } else {
                  const matchOption = RxOption.exec(pointName);
                  if (matchOption && matchOption.length >= 2) {
                    regexFlags = matchOption[1];
                    pointName = pointName.substring(regexFlags.length + 1);
                  }
                }
                if (regexFlags.indexOf("g") < 0) {
                  regexFlags += "g";
                }
                const sourceCode = code;
                const rx = new RegExp(pointName, regexFlags);
                let match = rx.exec(sourceCode);
                while (match !== null) {
                  let newCode = injectedCode;
                  for (let i = 0; i < match.length; ++i) {
                    newCode = newCode.replace("$" + i, match[i]);
                  }
                  code = code.replace(match[0], newCode);
                  match = rx.exec(sourceCode);
                }
              } else {
                const fullPointName = "#define " + pointName;
                code = code.replace(fullPointName, "\n" + injectedCode + "\n" + fullPointName);
              }
            }
          }
          return code;
        };
      }
    };
    MaterialPluginManager._MaterialPluginClassToMainDefine = {};
    MaterialPluginManager._MaterialPluginCounter = 0;
    (() => {
      EngineStore.OnEnginesDisposedObservable.add(() => {
        UnregisterAllMaterialPlugins();
      });
    })();
    Plugins = [];
    Inited = false;
    MaterialObserver = null;
  }
});

// node_modules/@babylonjs/core/Materials/materialPluginBase.js
var MaterialPluginBase;
var init_materialPluginBase = __esm({
  "node_modules/@babylonjs/core/Materials/materialPluginBase.js"() {
    init_tslib_es6();
    init_decorators();
    init_materialPluginManager();
    init_decorators_serialization();
    init_typeStore();
    MaterialPluginBase = class {
      /**
       * Gets a boolean indicating that the plugin is compatible with a given shader language.
       * @param shaderLanguage The shader language to use.
       * @returns true if the plugin is compatible with the shader language
       */
      isCompatible(shaderLanguage) {
        switch (shaderLanguage) {
          case 0:
            return true;
          default:
            return false;
        }
      }
      _enable(enable) {
        if (enable) {
          this._pluginManager._activatePlugin(this);
        }
      }
      /**
       * Creates a new material plugin
       * @param material parent material of the plugin
       * @param name name of the plugin
       * @param priority priority of the plugin
       * @param defines list of defines used by the plugin. The value of the property is the default value for this property
       * @param addToPluginList true to add the plugin to the list of plugins managed by the material plugin manager of the material (default: true)
       * @param enable true to enable the plugin (it is handy if the plugin does not handle properties to switch its current activation)
       * @param resolveIncludes Indicates that any #include directive in the plugin code must be replaced by the corresponding code (default: false)
       */
      constructor(material, name, priority, defines, addToPluginList = true, enable = false, resolveIncludes = false) {
        this.priority = 500;
        this.resolveIncludes = false;
        this.registerForExtraEvents = false;
        this.doNotSerialize = false;
        this._material = material;
        this.name = name;
        this.priority = priority;
        this.resolveIncludes = resolveIncludes;
        if (!material.pluginManager) {
          material.pluginManager = new MaterialPluginManager(material);
          material.onDisposeObservable.add(() => {
            material.pluginManager = void 0;
          });
        }
        this._pluginDefineNames = defines;
        this._pluginManager = material.pluginManager;
        if (addToPluginList) {
          this._pluginManager._addPlugin(this);
        }
        if (enable) {
          this._enable(true);
        }
        this.markAllDefinesAsDirty = material._dirtyCallbacks[127];
      }
      /**
       * Gets the current class name useful for serialization or dynamic coding.
       * @returns The class name.
       */
      getClassName() {
        return "MaterialPluginBase";
      }
      /**
       * Specifies that the submesh is ready to be used.
       * @param _defines the list of "defines" to update.
       * @param _scene defines the scene the material belongs to.
       * @param _engine the engine this scene belongs to.
       * @param _subMesh the submesh to check for readiness
       * @returns - boolean indicating that the submesh is ready or not.
       */
      isReadyForSubMesh(_defines, _scene, _engine, _subMesh) {
        return true;
      }
      /**
       * Binds the material data (this function is called even if mustRebind() returns false)
       * @param _uniformBuffer defines the Uniform buffer to fill in.
       * @param _scene defines the scene the material belongs to.
       * @param _engine defines the engine the material belongs to.
       * @param _subMesh the submesh to bind data for
       */
      hardBindForSubMesh(_uniformBuffer, _scene, _engine, _subMesh) {
      }
      /**
       * Binds the material data.
       * @param _uniformBuffer defines the Uniform buffer to fill in.
       * @param _scene defines the scene the material belongs to.
       * @param _engine the engine this scene belongs to.
       * @param _subMesh the submesh to bind data for
       */
      bindForSubMesh(_uniformBuffer, _scene, _engine, _subMesh) {
      }
      /**
       * Disposes the resources of the material.
       * @param _forceDisposeTextures - Forces the disposal of all textures.
       */
      dispose(_forceDisposeTextures) {
      }
      /**
       * Returns a list of custom shader code fragments to customize the shader.
       * @param _shaderType "vertex" or "fragment"
       * @param _shaderLanguage The shader language to use.
       * @returns null if no code to be added, or a list of pointName =\> code.
       * Note that `pointName` can also be a regular expression if it starts with a `!`.
       * In that case, the string found by the regular expression (if any) will be
       * replaced by the code provided.
       */
      getCustomCode(_shaderType, _shaderLanguage = 0) {
        return null;
      }
      /**
       * Collects all defines.
       * @param defines The object to append to.
       */
      collectDefines(defines) {
        if (!this._pluginDefineNames) {
          return;
        }
        for (const key of Object.keys(this._pluginDefineNames)) {
          if (key[0] === "_") {
            continue;
          }
          const type = typeof this._pluginDefineNames[key];
          defines[key] = {
            type: type === "number" ? "number" : type === "string" ? "string" : type === "boolean" ? "boolean" : "object",
            default: this._pluginDefineNames[key]
          };
        }
      }
      /**
       * Sets the defines for the next rendering. Called before PrepareDefinesForAttributes is called.
       * @param _defines the list of "defines" to update.
       * @param _scene defines the scene to the material belongs to.
       * @param _mesh the mesh being rendered
       */
      prepareDefinesBeforeAttributes(_defines, _scene, _mesh) {
      }
      /**
       * Sets the defines for the next rendering
       * @param _defines the list of "defines" to update.
       * @param _scene defines the scene to the material belongs to.
       * @param _mesh the mesh being rendered
       */
      prepareDefines(_defines, _scene, _mesh) {
      }
      /**
       * Checks to see if a texture is used in the material.
       * @param _texture - Base texture to use.
       * @returns - Boolean specifying if a texture is used in the material.
       */
      hasTexture(_texture) {
        return false;
      }
      /**
       * Gets a boolean indicating that current material needs to register RTT
       * @returns true if this uses a render target otherwise false.
       */
      hasRenderTargetTextures() {
        return false;
      }
      /**
       * Fills the list of render target textures.
       * @param _renderTargets the list of render targets to update
       */
      fillRenderTargetTextures(_renderTargets) {
      }
      /**
       * Returns an array of the actively used textures.
       * @param _activeTextures Array of BaseTextures
       */
      getActiveTextures(_activeTextures) {
      }
      /**
       * Returns the animatable textures.
       * @param _animatables Array of animatable textures.
       */
      getAnimatables(_animatables) {
      }
      /**
       * Add fallbacks to the effect fallbacks list.
       * @param defines defines the Base texture to use.
       * @param fallbacks defines the current fallback list.
       * @param currentRank defines the current fallback rank.
       * @returns the new fallback rank.
       */
      addFallbacks(defines, fallbacks, currentRank) {
        return currentRank;
      }
      /**
       * Gets the samplers used by the plugin.
       * @param _samplers list that the sampler names should be added to.
       */
      getSamplers(_samplers) {
      }
      /**
       * Gets the attributes used by the plugin.
       * @param _attributes list that the attribute names should be added to.
       * @param _scene the scene that the material belongs to.
       * @param _mesh the mesh being rendered.
       */
      getAttributes(_attributes, _scene, _mesh) {
      }
      /**
       * Gets the uniform buffers names added by the plugin.
       * @param _ubos list that the ubo names should be added to.
       */
      getUniformBuffersNames(_ubos) {
      }
      /**
       * Gets the description of the uniforms to add to the ubo (if engine supports ubos) or to inject directly in the vertex/fragment shaders (if engine does not support ubos)
       * @param _shaderLanguage The shader language to use.
       * @returns the description of the uniforms
       */
      getUniforms(_shaderLanguage = 0) {
        return {};
      }
      /**
       * Makes a duplicate of the current configuration into another one.
       * @param plugin define the config where to copy the info
       */
      copyTo(plugin) {
        SerializationHelper.Clone(() => plugin, this);
      }
      /**
       * Serializes this plugin configuration.
       * @returns - An object with the serialized config.
       */
      serialize() {
        return SerializationHelper.Serialize(this);
      }
      /**
       * Parses a plugin configuration from a serialized object.
       * @param source - Serialized object.
       * @param scene Defines the scene we are parsing for
       * @param rootUrl Defines the rootUrl to load from
       */
      parse(source, scene, rootUrl) {
        SerializationHelper.Parse(() => this, source, scene, rootUrl);
      }
    };
    __decorate([
      serialize()
    ], MaterialPluginBase.prototype, "name", void 0);
    __decorate([
      serialize()
    ], MaterialPluginBase.prototype, "priority", void 0);
    __decorate([
      serialize()
    ], MaterialPluginBase.prototype, "resolveIncludes", void 0);
    __decorate([
      serialize()
    ], MaterialPluginBase.prototype, "registerForExtraEvents", void 0);
    RegisterClass("BABYLON.MaterialPluginBase", MaterialPluginBase);
  }
});

// node_modules/@babylonjs/core/Materials/material.detailMapConfiguration.js
var MaterialDetailMapDefines, DetailMapConfiguration;
var init_material_detailMapConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/material.detailMapConfiguration.js"() {
    init_tslib_es6();
    init_material();
    init_decorators();
    init_materialFlags();
    init_materialDefines();
    init_materialPluginBase();
    init_materialHelper_functions();
    MaterialDetailMapDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.DETAIL = false;
        this.DETAILDIRECTUV = 0;
        this.DETAIL_NORMALBLENDMETHOD = 0;
      }
    };
    DetailMapConfiguration = class extends MaterialPluginBase {
      /** @internal */
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      /**
       * Gets a boolean indicating that the plugin is compatible with a given shader language.
       * @returns true if the plugin is compatible with the shader language
       */
      isCompatible() {
        return true;
      }
      constructor(material, addToPluginList = true) {
        super(material, "DetailMap", 140, new MaterialDetailMapDefines(), addToPluginList);
        this._texture = null;
        this.diffuseBlendLevel = 1;
        this.roughnessBlendLevel = 1;
        this.bumpLevel = 1;
        this._normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;
        this._isEnabled = false;
        this.isEnabled = false;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
      }
      isReadyForSubMesh(defines, scene, engine) {
        if (!this._isEnabled) {
          return true;
        }
        if (defines._areTexturesDirty && scene.texturesEnabled) {
          if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {
            if (!this._texture.isReady()) {
              return false;
            }
          }
        }
        return true;
      }
      prepareDefines(defines, scene) {
        if (this._isEnabled) {
          defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
          const engine = scene.getEngine();
          if (defines._areTexturesDirty) {
            if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {
              PrepareDefinesForMergedUV(this._texture, defines, "DETAIL");
              defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
            } else {
              defines.DETAIL = false;
            }
          }
        } else {
          defines.DETAIL = false;
        }
      }
      bindForSubMesh(uniformBuffer, scene) {
        if (!this._isEnabled) {
          return;
        }
        const isFrozen = this._material.isFrozen;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (this._texture && MaterialFlags.DetailTextureEnabled) {
            uniformBuffer.updateFloat4("vDetailInfos", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);
            BindTextureMatrix(this._texture, uniformBuffer, "detail");
          }
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.DetailTextureEnabled) {
            uniformBuffer.setTexture("detailSampler", this._texture);
          }
        }
      }
      hasTexture(texture) {
        if (this._texture === texture) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
      }
      getAnimatables(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
      }
      dispose(forceDisposeTextures) {
        if (forceDisposeTextures) {
          this._texture?.dispose();
        }
      }
      getClassName() {
        return "DetailMapConfiguration";
      }
      getSamplers(samplers) {
        samplers.push("detailSampler");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vDetailInfos", size: 4, type: "vec4" },
            { name: "detailMatrix", size: 16, type: "mat4" }
          ]
        };
      }
    };
    __decorate([
      serializeAsTexture("detailTexture"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], DetailMapConfiguration.prototype, "texture", void 0);
    __decorate([
      serialize()
    ], DetailMapConfiguration.prototype, "diffuseBlendLevel", void 0);
    __decorate([
      serialize()
    ], DetailMapConfiguration.prototype, "roughnessBlendLevel", void 0);
    __decorate([
      serialize()
    ], DetailMapConfiguration.prototype, "bumpLevel", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], DetailMapConfiguration.prototype, "normalBlendMethod", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], DetailMapConfiguration.prototype, "isEnabled", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/materialHelper.geometryrendering.js
var GeometryRenderingTextureClearType, MaterialHelperGeometryRendering;
var init_materialHelper_geometryrendering = __esm({
  "node_modules/@babylonjs/core/Materials/materialHelper.geometryrendering.js"() {
    init_math_vector();
    (function(GeometryRenderingTextureClearType2) {
      GeometryRenderingTextureClearType2[GeometryRenderingTextureClearType2["Zero"] = 0] = "Zero";
      GeometryRenderingTextureClearType2[GeometryRenderingTextureClearType2["One"] = 1] = "One";
      GeometryRenderingTextureClearType2[GeometryRenderingTextureClearType2["MaxViewZ"] = 2] = "MaxViewZ";
      GeometryRenderingTextureClearType2[GeometryRenderingTextureClearType2["NoClear"] = 3] = "NoClear";
    })(GeometryRenderingTextureClearType || (GeometryRenderingTextureClearType = {}));
    MaterialHelperGeometryRendering = class _MaterialHelperGeometryRendering {
      /**
       * Creates a new geometry rendering configuration.
       * @param renderPassId Render pass id the configuration is created for.
       * @returns The created configuration.
       */
      static CreateConfiguration(renderPassId) {
        _MaterialHelperGeometryRendering._Configurations[renderPassId] = {
          defines: {},
          previousWorldMatrices: {},
          previousViewProjection: Matrix.Zero(),
          currentViewProjection: Matrix.Zero(),
          previousBones: {},
          lastUpdateFrameId: -1,
          excludedSkinnedMesh: [],
          reverseCulling: false
        };
        return _MaterialHelperGeometryRendering._Configurations[renderPassId];
      }
      /**
       * Deletes a geometry rendering configuration.
       * @param renderPassId The render pass id of the configuration to delete.
       */
      static DeleteConfiguration(renderPassId) {
        delete _MaterialHelperGeometryRendering._Configurations[renderPassId];
      }
      /**
       * Gets a geometry rendering configuration.
       * @param renderPassId The render pass id of the configuration to get.
       * @returns The configuration.
       */
      static GetConfiguration(renderPassId) {
        return _MaterialHelperGeometryRendering._Configurations[renderPassId];
      }
      /**
       * Adds uniforms and samplers for geometry rendering.
       * @param uniforms The array of uniforms to add to.
       * @param _samplers The array of samplers to add to.
       */
      static AddUniformsAndSamplers(uniforms, _samplers) {
        uniforms.push("previousWorld", "previousViewProjection", "mPreviousBones");
      }
      /**
       * Marks a list of meshes as dirty for geometry rendering.
       * @param renderPassId The render pass id the meshes are marked as dirty for.
       * @param meshes The list of meshes to mark as dirty.
       */
      static MarkAsDirty(renderPassId, meshes) {
        for (const mesh of meshes) {
          if (!mesh.subMeshes) {
            continue;
          }
          for (const subMesh of mesh.subMeshes) {
            subMesh._removeDrawWrapper(renderPassId);
          }
        }
      }
      /**
       * Prepares defines for geometry rendering.
       * @param renderPassId The render pass id the defines are prepared for.
       * @param mesh The mesh the defines are prepared for.
       * @param defines The defines to update according to the geometry rendering configuration.
       */
      static PrepareDefines(renderPassId, mesh, defines) {
        if (!defines._arePrePassDirty) {
          return;
        }
        const configuration = _MaterialHelperGeometryRendering._Configurations[renderPassId];
        if (!configuration) {
          return;
        }
        defines["PREPASS"] = true;
        let numMRT = 0;
        for (let i = 0; i < _MaterialHelperGeometryRendering.GeometryTextureDescriptions.length; i++) {
          const geometryTextureDescription = _MaterialHelperGeometryRendering.GeometryTextureDescriptions[i];
          const defineName = geometryTextureDescription.define;
          const defineIndex = geometryTextureDescription.defineIndex;
          const index = configuration.defines[defineIndex];
          if (index !== void 0) {
            defines[defineName] = true;
            defines[defineIndex] = index;
            numMRT++;
          } else {
            defines[defineName] = false;
            delete defines[defineIndex];
          }
        }
        defines["SCENE_MRT_COUNT"] = numMRT;
        defines["BONES_VELOCITY_ENABLED"] = mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton && !mesh.skeleton.isUsingTextureForMatrices && configuration.excludedSkinnedMesh.indexOf(mesh) === -1;
      }
      /**
       * Binds geometry rendering data for a mesh.
       * @param renderPassId The render pass id the geometry rendering data is bound for.
       * @param effect The effect to bind the geometry rendering data to.
       * @param mesh The mesh to bind the geometry rendering data for.
       * @param world The world matrix of the mesh.
       * @param material The material of the mesh.
       */
      static Bind(renderPassId, effect, mesh, world, material) {
        const configuration = _MaterialHelperGeometryRendering._Configurations[renderPassId];
        if (!configuration) {
          return;
        }
        const scene = mesh.getScene();
        const engine = scene.getEngine();
        if (configuration.reverseCulling) {
          engine.setStateCullFaceType(scene._mirroredCameraPosition ? material.cullBackFaces : !material.cullBackFaces);
        }
        if (configuration.defines["PREPASS_VELOCITY_INDEX"] !== void 0 || configuration.defines["PREPASS_VELOCITY_LINEAR_INDEX"] !== void 0) {
          if (!configuration.previousWorldMatrices[mesh.uniqueId]) {
            configuration.previousWorldMatrices[mesh.uniqueId] = world.clone();
          }
          if (!configuration.previousViewProjection) {
            configuration.previousViewProjection = scene.getTransformMatrix().clone();
            configuration.currentViewProjection = scene.getTransformMatrix().clone();
          }
          if (configuration.currentViewProjection.updateFlag !== scene.getTransformMatrix().updateFlag) {
            configuration.lastUpdateFrameId = engine.frameId;
            configuration.previousViewProjection.copyFrom(configuration.currentViewProjection);
            configuration.currentViewProjection.copyFrom(scene.getTransformMatrix());
          } else if (configuration.lastUpdateFrameId !== engine.frameId) {
            configuration.lastUpdateFrameId = engine.frameId;
            configuration.previousViewProjection.copyFrom(configuration.currentViewProjection);
          }
          effect.setMatrix("previousWorld", configuration.previousWorldMatrices[mesh.uniqueId]);
          effect.setMatrix("previousViewProjection", configuration.previousViewProjection);
          configuration.previousWorldMatrices[mesh.uniqueId] = world.clone();
          if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
            const skeleton = mesh.skeleton;
            if (!skeleton.isUsingTextureForMatrices || effect.getUniformIndex("boneTextureWidth") === -1) {
              const matrices = skeleton.getTransformMatrices(mesh);
              if (matrices) {
                if (!configuration.previousBones[mesh.uniqueId]) {
                  configuration.previousBones[mesh.uniqueId] = matrices.slice();
                }
                effect.setMatrices("mPreviousBones", configuration.previousBones[mesh.uniqueId]);
                configuration.previousBones[mesh.uniqueId].set(matrices);
              }
            }
          }
        }
      }
    };
    MaterialHelperGeometryRendering.GeometryTextureDescriptions = [
      {
        type: 0,
        name: "Irradiance",
        clearType: 0,
        define: "PREPASS_IRRADIANCE",
        defineIndex: "PREPASS_IRRADIANCE_INDEX"
      },
      {
        type: 1,
        name: "WorldPosition",
        clearType: 0,
        define: "PREPASS_POSITION",
        defineIndex: "PREPASS_POSITION_INDEX"
      },
      {
        type: 2,
        name: "Velocity",
        clearType: 0,
        define: "PREPASS_VELOCITY",
        defineIndex: "PREPASS_VELOCITY_INDEX"
      },
      {
        type: 3,
        name: "Reflectivity",
        clearType: 0,
        define: "PREPASS_REFLECTIVITY",
        defineIndex: "PREPASS_REFLECTIVITY_INDEX"
      },
      {
        type: 5,
        name: "ViewDepth",
        clearType: 2,
        define: "PREPASS_DEPTH",
        defineIndex: "PREPASS_DEPTH_INDEX"
      },
      {
        type: 6,
        name: "ViewNormal",
        clearType: 0,
        define: "PREPASS_NORMAL",
        defineIndex: "PREPASS_NORMAL_INDEX"
      },
      {
        type: 7,
        name: "AlbedoSqrt",
        clearType: 0,
        define: "PREPASS_ALBEDO_SQRT",
        defineIndex: "PREPASS_ALBEDO_SQRT_INDEX"
      },
      {
        type: 8,
        name: "WorldNormal",
        clearType: 0,
        define: "PREPASS_WORLD_NORMAL",
        defineIndex: "PREPASS_WORLD_NORMAL_INDEX"
      },
      {
        type: 9,
        name: "LocalPosition",
        clearType: 0,
        define: "PREPASS_LOCAL_POSITION",
        defineIndex: "PREPASS_LOCAL_POSITION_INDEX"
      },
      {
        type: 10,
        name: "ScreenDepth",
        clearType: 1,
        define: "PREPASS_SCREENSPACE_DEPTH",
        defineIndex: "PREPASS_SCREENSPACE_DEPTH_INDEX"
      },
      {
        type: 11,
        name: "LinearVelocity",
        clearType: 0,
        define: "PREPASS_VELOCITY_LINEAR",
        defineIndex: "PREPASS_VELOCITY_LINEAR_INDEX"
      },
      {
        type: 12,
        name: "Albedo",
        clearType: 0,
        define: "PREPASS_ALBEDO",
        defineIndex: "PREPASS_ALBEDO_INDEX"
      },
      {
        type: 13,
        name: "NormalizedViewDepth",
        clearType: 1,
        define: "PREPASS_NORMALIZED_VIEW_DEPTH",
        defineIndex: "PREPASS_NORMALIZED_VIEW_DEPTH_INDEX"
      },
      {
        type: 4,
        name: "Color",
        clearType: 3,
        define: "PREPASS_COLOR",
        defineIndex: "PREPASS_COLOR_INDEX"
      }
    ];
    MaterialHelperGeometryRendering._Configurations = {};
  }
});

// node_modules/@babylonjs/core/Materials/uv.defines.js
function UVDefinesMixin(base) {
  return class extends base {
    constructor() {
      super(...arguments);
      this.MAINUV1 = false;
      this.MAINUV2 = false;
      this.MAINUV3 = false;
      this.MAINUV4 = false;
      this.MAINUV5 = false;
      this.MAINUV6 = false;
      this.UV1 = false;
      this.UV2 = false;
      this.UV3 = false;
      this.UV4 = false;
      this.UV5 = false;
      this.UV6 = false;
    }
  };
}
var init_uv_defines = __esm({
  "node_modules/@babylonjs/core/Materials/uv.defines.js"() {
  }
});

// node_modules/@babylonjs/core/Materials/imageProcessing.js
function ImageProcessingMixin(base) {
  return class extends base {
    /**
     * Constructor for the ImageProcessingMixin.
     * @param args - arguments to pass to the base class constructor
     */
    constructor(...args) {
      super(...args);
      serializeAsImageProcessingConfiguration.call(this, this, "_imageProcessingConfiguration");
    }
    /**
     * Gets the image processing configuration used either in this material.
     */
    get imageProcessingConfiguration() {
      return this._imageProcessingConfiguration;
    }
    /**
     * Sets the Default image processing configuration used either in the this material.
     *
     * If sets to null, the scene one is in use.
     */
    set imageProcessingConfiguration(value) {
      this._attachImageProcessingConfiguration(value);
      if (this._markAllSubMeshesAsImageProcessingDirty) {
        this._markAllSubMeshesAsImageProcessingDirty();
      }
    }
    /**
     * Attaches a new image processing configuration to the Standard Material.
     * @param configuration
     */
    _attachImageProcessingConfiguration(configuration) {
      if (configuration === this._imageProcessingConfiguration) {
        return;
      }
      if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
        this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
      }
      if (!configuration && this.getScene) {
        this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
      } else if (configuration) {
        this._imageProcessingConfiguration = configuration;
      }
      if (this._imageProcessingConfiguration) {
        this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
          if (this._markAllSubMeshesAsImageProcessingDirty) {
            this._markAllSubMeshesAsImageProcessingDirty();
          }
        });
      }
    }
    /**
     * Gets whether the color curves effect is enabled.
     */
    get cameraColorCurvesEnabled() {
      return this.imageProcessingConfiguration.colorCurvesEnabled;
    }
    /**
     * Sets whether the color curves effect is enabled.
     */
    set cameraColorCurvesEnabled(value) {
      this.imageProcessingConfiguration.colorCurvesEnabled = value;
    }
    /**
     * Gets whether the color grading effect is enabled.
     */
    get cameraColorGradingEnabled() {
      return this.imageProcessingConfiguration.colorGradingEnabled;
    }
    /**
     * Gets whether the color grading effect is enabled.
     */
    set cameraColorGradingEnabled(value) {
      this.imageProcessingConfiguration.colorGradingEnabled = value;
    }
    /**
     * Gets whether tonemapping is enabled or not.
     */
    get cameraToneMappingEnabled() {
      return this._imageProcessingConfiguration.toneMappingEnabled;
    }
    /**
     * Sets whether tonemapping is enabled or not
     */
    set cameraToneMappingEnabled(value) {
      this._imageProcessingConfiguration.toneMappingEnabled = value;
    }
    /**
     * The camera exposure used on this material.
     * This property is here and not in the camera to allow controlling exposure without full screen post process.
     * This corresponds to a photographic exposure.
     */
    get cameraExposure() {
      return this._imageProcessingConfiguration.exposure;
    }
    /**
     * The camera exposure used on this material.
     * This property is here and not in the camera to allow controlling exposure without full screen post process.
     * This corresponds to a photographic exposure.
     */
    set cameraExposure(value) {
      this._imageProcessingConfiguration.exposure = value;
    }
    /**
     * Gets The camera contrast used on this material.
     */
    get cameraContrast() {
      return this._imageProcessingConfiguration.contrast;
    }
    /**
     * Sets The camera contrast used on this material.
     */
    set cameraContrast(value) {
      this._imageProcessingConfiguration.contrast = value;
    }
    /**
     * Gets the Color Grading 2D Lookup Texture.
     */
    get cameraColorGradingTexture() {
      return this._imageProcessingConfiguration.colorGradingTexture;
    }
    /**
     * Sets the Color Grading 2D Lookup Texture.
     */
    set cameraColorGradingTexture(value) {
      this._imageProcessingConfiguration.colorGradingTexture = value;
    }
    /**
     * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
     * corresponding to low luminance, medium luminance, and high luminance areas respectively.
     */
    get cameraColorCurves() {
      return this._imageProcessingConfiguration.colorCurves;
    }
    /**
     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).
     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
     * corresponding to low luminance, medium luminance, and high luminance areas respectively.
     */
    set cameraColorCurves(value) {
      this._imageProcessingConfiguration.colorCurves = value;
    }
  };
}
var init_imageProcessing = __esm({
  "node_modules/@babylonjs/core/Materials/imageProcessing.js"() {
    init_decorators();
  }
});

// node_modules/@babylonjs/core/Materials/prePassConfiguration.js
var PrePassConfiguration;
var init_prePassConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/prePassConfiguration.js"() {
    PrePassConfiguration = class {
      constructor() {
        this.previousWorldMatrices = {};
        this.previousBones = {};
      }
      /**
       * Add the required uniforms to the current list.
       * @param uniforms defines the current uniform list.
       */
      static AddUniforms(uniforms) {
        uniforms.push("previousWorld", "previousViewProjection", "mPreviousBones");
      }
      /**
       * Add the required samplers to the current list.
       * @param samplers defines the current sampler list.
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      static AddSamplers(samplers) {
      }
      /**
       * Binds the material data.
       * @param effect defines the effect to update
       * @param scene defines the scene the material belongs to.
       * @param mesh The mesh
       * @param world World matrix of this mesh
       * @param isFrozen Is the material frozen
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      bindForSubMesh(effect, scene, mesh, world, isFrozen) {
        if (scene.prePassRenderer && scene.prePassRenderer.enabled && scene.prePassRenderer.currentRTisSceneRT) {
          if (scene.prePassRenderer.getIndex(2) !== -1 || scene.prePassRenderer.getIndex(11) !== -1) {
            if (!this.previousWorldMatrices[mesh.uniqueId]) {
              this.previousWorldMatrices[mesh.uniqueId] = world.clone();
            }
            if (!this.previousViewProjection) {
              this.previousViewProjection = scene.getTransformMatrix().clone();
              this.currentViewProjection = scene.getTransformMatrix().clone();
            }
            const engine = scene.getEngine();
            if (this.currentViewProjection.updateFlag !== scene.getTransformMatrix().updateFlag) {
              this._lastUpdateFrameId = engine.frameId;
              this.previousViewProjection.copyFrom(this.currentViewProjection);
              this.currentViewProjection.copyFrom(scene.getTransformMatrix());
            } else if (this._lastUpdateFrameId !== engine.frameId) {
              this._lastUpdateFrameId = engine.frameId;
              this.previousViewProjection.copyFrom(this.currentViewProjection);
            }
            effect.setMatrix("previousWorld", this.previousWorldMatrices[mesh.uniqueId]);
            effect.setMatrix("previousViewProjection", this.previousViewProjection);
            this.previousWorldMatrices[mesh.uniqueId] = world.clone();
          }
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.defines.js
function ImageProcessingDefinesMixin(base) {
  return class extends base {
    constructor() {
      super(...arguments);
      this.IMAGEPROCESSING = false;
      this.VIGNETTE = false;
      this.VIGNETTEBLENDMODEMULTIPLY = false;
      this.VIGNETTEBLENDMODEOPAQUE = false;
      this.TONEMAPPING = 0;
      this.CONTRAST = false;
      this.COLORCURVES = false;
      this.COLORGRADING = false;
      this.COLORGRADING3D = false;
      this.SAMPLER3DGREENDEPTH = false;
      this.SAMPLER3DBGRMAP = false;
      this.DITHER = false;
      this.IMAGEPROCESSINGPOSTPROCESS = false;
      this.SKIPFINALCOLORCLAMP = false;
      this.EXPOSURE = false;
    }
  };
}
var ImageProcessingConfigurationDefines;
var init_imageProcessingConfiguration_defines = __esm({
  "node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.defines.js"() {
    init_materialDefines();
    ImageProcessingConfigurationDefines = class extends MaterialDefines {
      constructor() {
        super();
        this.IMAGEPROCESSING = false;
        this.VIGNETTE = false;
        this.VIGNETTEBLENDMODEMULTIPLY = false;
        this.VIGNETTEBLENDMODEOPAQUE = false;
        this.TONEMAPPING = 0;
        this.CONTRAST = false;
        this.COLORCURVES = false;
        this.COLORGRADING = false;
        this.COLORGRADING3D = false;
        this.SAMPLER3DGREENDEPTH = false;
        this.SAMPLER3DBGRMAP = false;
        this.DITHER = false;
        this.IMAGEPROCESSINGPOSTPROCESS = false;
        this.EXPOSURE = false;
        this.SKIPFINALCOLORCLAMP = false;
        this.rebuild();
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/standardMaterial.js
var onCreatedEffectParameters, StandardMaterialDefinesBase, StandardMaterialDefines, StandardMaterialBase, StandardMaterial;
var init_standardMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/standardMaterial.js"() {
    init_tslib_es6();
    init_decorators();
    init_smartArray();
    init_scene();
    init_math_color();
    init_buffer();
    init_prePassConfiguration();
    init_imageProcessingConfiguration_defines();
    init_imageProcessingConfiguration();
    init_material();
    init_materialDefines();
    init_pushMaterial();
    init_typeStore();
    init_materialFlags();
    init_effectFallbacks();
    init_material_detailMapConfiguration();
    init_clipPlaneMaterialHelper();
    init_materialHelper_functions();
    init_decorators_serialization();
    init_materialHelper_geometryrendering();
    init_uv_defines();
    init_imageProcessing();
    onCreatedEffectParameters = { effect: null, subMesh: null };
    StandardMaterialDefinesBase = class extends UVDefinesMixin(MaterialDefines) {
    };
    StandardMaterialDefines = class extends ImageProcessingDefinesMixin(StandardMaterialDefinesBase) {
      /**
       * Initializes the Standard Material defines.
       * @param externalProperties The external properties
       */
      constructor(externalProperties) {
        super(externalProperties);
        this.DIFFUSE = false;
        this.DIFFUSEDIRECTUV = 0;
        this.BAKED_VERTEX_ANIMATION_TEXTURE = false;
        this.AMBIENT = false;
        this.AMBIENTDIRECTUV = 0;
        this.OPACITY = false;
        this.OPACITYDIRECTUV = 0;
        this.OPACITYRGB = false;
        this.REFLECTION = false;
        this.EMISSIVE = false;
        this.EMISSIVEDIRECTUV = 0;
        this.SPECULAR = false;
        this.SPECULARDIRECTUV = 0;
        this.BUMP = false;
        this.BUMPDIRECTUV = 0;
        this.PARALLAX = false;
        this.PARALLAX_RHS = false;
        this.PARALLAXOCCLUSION = false;
        this.SPECULAROVERALPHA = false;
        this.CLIPPLANE = false;
        this.CLIPPLANE2 = false;
        this.CLIPPLANE3 = false;
        this.CLIPPLANE4 = false;
        this.CLIPPLANE5 = false;
        this.CLIPPLANE6 = false;
        this.ALPHATEST = false;
        this.DEPTHPREPASS = false;
        this.ALPHAFROMDIFFUSE = false;
        this.POINTSIZE = false;
        this.FOG = false;
        this.SPECULARTERM = false;
        this.DIFFUSEFRESNEL = false;
        this.OPACITYFRESNEL = false;
        this.REFLECTIONFRESNEL = false;
        this.REFRACTIONFRESNEL = false;
        this.EMISSIVEFRESNEL = false;
        this.FRESNEL = false;
        this.NORMAL = false;
        this.TANGENT = false;
        this.VERTEXCOLOR = false;
        this.VERTEXALPHA = false;
        this.NUM_BONE_INFLUENCERS = 0;
        this.BonesPerMesh = 0;
        this.BONETEXTURE = false;
        this.BONES_VELOCITY_ENABLED = false;
        this.INSTANCES = false;
        this.THIN_INSTANCES = false;
        this.INSTANCESCOLOR = false;
        this.GLOSSINESS = false;
        this.ROUGHNESS = false;
        this.EMISSIVEASILLUMINATION = false;
        this.LINKEMISSIVEWITHDIFFUSE = false;
        this.REFLECTIONFRESNELFROMSPECULAR = false;
        this.LIGHTMAP = false;
        this.LIGHTMAPDIRECTUV = 0;
        this.OBJECTSPACE_NORMALMAP = false;
        this.USELIGHTMAPASSHADOWMAP = false;
        this.REFLECTIONMAP_3D = false;
        this.REFLECTIONMAP_SPHERICAL = false;
        this.REFLECTIONMAP_PLANAR = false;
        this.REFLECTIONMAP_CUBIC = false;
        this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
        this.USE_LOCAL_REFRACTIONMAP_CUBIC = false;
        this.REFLECTIONMAP_PROJECTION = false;
        this.REFLECTIONMAP_SKYBOX = false;
        this.REFLECTIONMAP_EXPLICIT = false;
        this.REFLECTIONMAP_EQUIRECTANGULAR = false;
        this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
        this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
        this.REFLECTIONMAP_OPPOSITEZ = false;
        this.INVERTCUBICMAP = false;
        this.LOGARITHMICDEPTH = false;
        this.REFRACTION = false;
        this.REFRACTIONMAP_3D = false;
        this.REFLECTIONOVERALPHA = false;
        this.TWOSIDEDLIGHTING = false;
        this.SHADOWFLOAT = false;
        this.MORPHTARGETS = false;
        this.MORPHTARGETS_POSITION = false;
        this.MORPHTARGETS_NORMAL = false;
        this.MORPHTARGETS_TANGENT = false;
        this.MORPHTARGETS_UV = false;
        this.MORPHTARGETS_UV2 = false;
        this.MORPHTARGETS_COLOR = false;
        this.MORPHTARGETTEXTURE_HASPOSITIONS = false;
        this.MORPHTARGETTEXTURE_HASNORMALS = false;
        this.MORPHTARGETTEXTURE_HASTANGENTS = false;
        this.MORPHTARGETTEXTURE_HASUVS = false;
        this.MORPHTARGETTEXTURE_HASUV2S = false;
        this.MORPHTARGETTEXTURE_HASCOLORS = false;
        this.NUM_MORPH_INFLUENCERS = 0;
        this.MORPHTARGETS_TEXTURE = false;
        this.NONUNIFORMSCALING = false;
        this.PREMULTIPLYALPHA = false;
        this.ALPHATEST_AFTERALLALPHACOMPUTATIONS = false;
        this.ALPHABLEND = true;
        this.PREPASS = false;
        this.PREPASS_COLOR = false;
        this.PREPASS_COLOR_INDEX = -1;
        this.PREPASS_IRRADIANCE = false;
        this.PREPASS_IRRADIANCE_INDEX = -1;
        this.PREPASS_ALBEDO = false;
        this.PREPASS_ALBEDO_INDEX = -1;
        this.PREPASS_ALBEDO_SQRT = false;
        this.PREPASS_ALBEDO_SQRT_INDEX = -1;
        this.PREPASS_DEPTH = false;
        this.PREPASS_DEPTH_INDEX = -1;
        this.PREPASS_SCREENSPACE_DEPTH = false;
        this.PREPASS_SCREENSPACE_DEPTH_INDEX = -1;
        this.PREPASS_NORMALIZED_VIEW_DEPTH = false;
        this.PREPASS_NORMALIZED_VIEW_DEPTH_INDEX = -1;
        this.PREPASS_NORMAL = false;
        this.PREPASS_NORMAL_INDEX = -1;
        this.PREPASS_NORMAL_WORLDSPACE = false;
        this.PREPASS_WORLD_NORMAL = false;
        this.PREPASS_WORLD_NORMAL_INDEX = -1;
        this.PREPASS_POSITION = false;
        this.PREPASS_POSITION_INDEX = -1;
        this.PREPASS_LOCAL_POSITION = false;
        this.PREPASS_LOCAL_POSITION_INDEX = -1;
        this.PREPASS_VELOCITY = false;
        this.PREPASS_VELOCITY_INDEX = -1;
        this.PREPASS_VELOCITY_LINEAR = false;
        this.PREPASS_VELOCITY_LINEAR_INDEX = -1;
        this.PREPASS_REFLECTIVITY = false;
        this.PREPASS_REFLECTIVITY_INDEX = -1;
        this.SCENE_MRT_COUNT = 0;
        this.RGBDLIGHTMAP = false;
        this.RGBDREFLECTION = false;
        this.RGBDREFRACTION = false;
        this.MULTIVIEW = false;
        this.ORDER_INDEPENDENT_TRANSPARENCY = false;
        this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;
        this.CAMERA_ORTHOGRAPHIC = false;
        this.CAMERA_PERSPECTIVE = false;
        this.AREALIGHTSUPPORTED = true;
        this.USE_VERTEX_PULLING = false;
        this.RIGHT_HANDED = false;
        this.CLUSTLIGHT_SLICES = 0;
        this.CLUSTLIGHT_BATCH = 0;
        this.IS_REFLECTION_LINEAR = false;
        this.IS_REFRACTION_LINEAR = false;
        this.DECAL_AFTER_DETAIL = false;
        this.rebuild();
      }
    };
    StandardMaterialBase = class extends ImageProcessingMixin(PushMaterial) {
    };
    StandardMaterial = class _StandardMaterial extends StandardMaterialBase {
      /**
       * Can this material render to prepass
       */
      get isPrePassCapable() {
        return !this.disableDepthWrite;
      }
      /**
       * Can this material render to several textures at once
       */
      get canRenderToMRT() {
        return true;
      }
      /**
       * Instantiates a new standard material.
       * This is the default material used in Babylon. It is the best trade off between quality
       * and performances.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction
       * @param name Define the name of the material in the scene
       * @param scene Define the scene the material belong to
       * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
       */
      constructor(name, scene, forceGLSL = false) {
        super(name, scene, void 0, forceGLSL || _StandardMaterial.ForceGLSL);
        this._diffuseTexture = null;
        this._ambientTexture = null;
        this._opacityTexture = null;
        this._reflectionTexture = null;
        this._emissiveTexture = null;
        this._specularTexture = null;
        this._bumpTexture = null;
        this._lightmapTexture = null;
        this._refractionTexture = null;
        this.ambientColor = new Color3(0, 0, 0);
        this.diffuseColor = new Color3(1, 1, 1);
        this.specularColor = new Color3(1, 1, 1);
        this.emissiveColor = new Color3(0, 0, 0);
        this.specularPower = 64;
        this._useAlphaFromDiffuseTexture = false;
        this._useEmissiveAsIllumination = false;
        this._linkEmissiveWithDiffuse = false;
        this._useSpecularOverAlpha = false;
        this._useReflectionOverAlpha = false;
        this._disableLighting = false;
        this._useObjectSpaceNormalMap = false;
        this._useParallax = false;
        this._useParallaxOcclusion = false;
        this.parallaxScaleBias = 0.05;
        this._roughness = 0;
        this.indexOfRefraction = 0.98;
        this.invertRefractionY = true;
        this.alphaCutOff = 0.4;
        this._useLightmapAsShadowmap = false;
        this._useReflectionFresnelFromSpecular = false;
        this._useGlossinessFromSpecularMapAlpha = false;
        this._maxSimultaneousLights = 4;
        this._invertNormalMapX = false;
        this._invertNormalMapY = false;
        this._twoSidedLighting = false;
        this._applyDecalMapAfterDetailMap = false;
        this._shadersLoaded = false;
        this._renderTargets = new SmartArray(16);
        this._globalAmbientColor = new Color3(0, 0, 0);
        this._cacheHasRenderTargetTextures = false;
        this.detailMap = new DetailMapConfiguration(this);
        this._attachImageProcessingConfiguration(null);
        this.prePassConfiguration = new PrePassConfiguration();
        this.getRenderTargetTextures = () => {
          this._renderTargets.reset();
          if (_StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
            this._renderTargets.push(this._reflectionTexture);
          }
          if (_StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
            this._renderTargets.push(this._refractionTexture);
          }
          this._eventInfo.renderTargets = this._renderTargets;
          this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);
          return this._renderTargets;
        };
      }
      /**
       * Gets a boolean indicating that current material needs to register RTT
       */
      get hasRenderTargetTextures() {
        if (_StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
          return true;
        }
        if (_StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
          return true;
        }
        return this._cacheHasRenderTargetTextures;
      }
      /**
       * Gets the current class name of the material e.g. "StandardMaterial"
       * Mainly use in serialization.
       * @returns the class name
       */
      getClassName() {
        return "StandardMaterial";
      }
      /**
       * Specifies if the material will require alpha blending
       * @returns a boolean specifying if alpha blending is needed
       */
      needAlphaBlending() {
        if (this._hasTransparencyMode) {
          return this._transparencyModeIsBlend;
        }
        if (this._disableAlphaBlending) {
          return false;
        }
        return this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
      }
      /**
       * Specifies if this material should be rendered in alpha test mode
       * @returns a boolean specifying if an alpha test is needed.
       */
      needAlphaTesting() {
        if (this._hasTransparencyMode) {
          return this._transparencyModeIsTest;
        }
        return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === Material.MATERIAL_ALPHATEST);
      }
      /**
       * @returns whether or not the alpha value of the diffuse texture should be used for alpha blending.
       */
      _shouldUseAlphaFromDiffuseTexture() {
        return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Material.MATERIAL_OPAQUE;
      }
      /**
       * @returns whether or not there is a usable alpha channel for transparency.
       */
      _hasAlphaChannel() {
        return this._diffuseTexture != null && this._diffuseTexture.hasAlpha || this._opacityTexture != null;
      }
      /**
       * Get the texture used for alpha test purpose.
       * @returns the diffuse texture in case of the standard material.
       */
      getAlphaTestTexture() {
        return this._diffuseTexture;
      }
      /**
       * Get if the submesh is ready to be used and all its information available.
       * Child classes can use it to update shaders
       * @param mesh defines the mesh to check
       * @param subMesh defines which submesh to check
       * @param useInstances specifies that instances should be used
       * @returns a boolean indicating that the submesh is ready or not
       */
      isReadyForSubMesh(mesh, subMesh, useInstances = false) {
        if (!this._uniformBufferLayoutBuilt) {
          this.buildUniformLayout();
        }
        const drawWrapper = subMesh._drawWrapper;
        if (drawWrapper.effect && this.isFrozen) {
          if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
            return true;
          }
        }
        if (!subMesh.materialDefines) {
          this._callbackPluginEventGeneric(4, this._eventInfo);
          subMesh.materialDefines = new StandardMaterialDefines(this._eventInfo.defineNames);
        }
        const scene = this.getScene();
        const defines = subMesh.materialDefines;
        if (this._isReadyForSubMesh(subMesh)) {
          return true;
        }
        const engine = scene.getEngine();
        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
        PrepareDefinesForMultiview(scene, defines);
        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
        PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);
        PrepareDefinesForOIT(scene, defines, oit);
        MaterialHelperGeometryRendering.PrepareDefines(engine.currentRenderPassId, mesh, defines);
        if (defines._areTexturesDirty) {
          this._eventInfo.hasRenderTargetTextures = false;
          this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
          this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;
          defines._needUVs = false;
          for (let i = 1; i <= 6; ++i) {
            defines["MAINUV" + i] = false;
          }
          if (scene.texturesEnabled) {
            defines.DIFFUSEDIRECTUV = 0;
            defines.BUMPDIRECTUV = 0;
            defines.AMBIENTDIRECTUV = 0;
            defines.OPACITYDIRECTUV = 0;
            defines.EMISSIVEDIRECTUV = 0;
            defines.SPECULARDIRECTUV = 0;
            defines.LIGHTMAPDIRECTUV = 0;
            if (this._diffuseTexture && _StandardMaterial.DiffuseTextureEnabled) {
              if (!this._diffuseTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                PrepareDefinesForMergedUV(this._diffuseTexture, defines, "DIFFUSE");
              }
            } else {
              defines.DIFFUSE = false;
            }
            if (this._ambientTexture && _StandardMaterial.AmbientTextureEnabled) {
              if (!this._ambientTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                PrepareDefinesForMergedUV(this._ambientTexture, defines, "AMBIENT");
              }
            } else {
              defines.AMBIENT = false;
            }
            if (this._opacityTexture && _StandardMaterial.OpacityTextureEnabled) {
              if (!this._opacityTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                PrepareDefinesForMergedUV(this._opacityTexture, defines, "OPACITY");
                defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
              }
            } else {
              defines.OPACITY = false;
            }
            if (this._reflectionTexture && _StandardMaterial.ReflectionTextureEnabled) {
              defines.ROUGHNESS = this._roughness > 0;
              defines.REFLECTIONOVERALPHA = this._useReflectionOverAlpha;
            } else {
              defines.ROUGHNESS = false;
              defines.REFLECTIONOVERALPHA = false;
            }
            if (!PrepareDefinesForIBL(scene, this._reflectionTexture, defines)) {
              return false;
            }
            if (this._emissiveTexture && _StandardMaterial.EmissiveTextureEnabled) {
              if (!this._emissiveTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                PrepareDefinesForMergedUV(this._emissiveTexture, defines, "EMISSIVE");
              }
            } else {
              defines.EMISSIVE = false;
            }
            if (this._lightmapTexture && _StandardMaterial.LightmapTextureEnabled) {
              if (!this._lightmapTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                PrepareDefinesForMergedUV(this._lightmapTexture, defines, "LIGHTMAP");
                defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;
                defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
              }
            } else {
              defines.LIGHTMAP = false;
            }
            if (this._specularTexture && _StandardMaterial.SpecularTextureEnabled) {
              if (!this._specularTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                PrepareDefinesForMergedUV(this._specularTexture, defines, "SPECULAR");
                defines.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;
              }
            } else {
              defines.SPECULAR = false;
            }
            if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && _StandardMaterial.BumpTextureEnabled) {
              if (!this._bumpTexture.isReady()) {
                return false;
              } else {
                PrepareDefinesForMergedUV(this._bumpTexture, defines, "BUMP");
                defines.PARALLAX = this._useParallax;
                defines.PARALLAX_RHS = scene.useRightHandedSystem;
                defines.PARALLAXOCCLUSION = this._useParallaxOcclusion;
              }
              defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
            } else {
              defines.BUMP = false;
              defines.PARALLAX = false;
              defines.PARALLAX_RHS = false;
              defines.PARALLAXOCCLUSION = false;
            }
            if (this._refractionTexture && _StandardMaterial.RefractionTextureEnabled) {
              if (!this._refractionTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                defines._needUVs = true;
                defines.REFRACTION = true;
                defines.REFRACTIONMAP_3D = this._refractionTexture.isCube;
                defines.RGBDREFRACTION = this._refractionTexture.isRGBD;
                defines.USE_LOCAL_REFRACTIONMAP_CUBIC = this._refractionTexture.boundingBoxSize ? true : false;
              }
            } else {
              defines.REFRACTION = false;
            }
            defines.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;
          } else {
            defines.DIFFUSE = false;
            defines.AMBIENT = false;
            defines.OPACITY = false;
            defines.REFLECTION = false;
            defines.EMISSIVE = false;
            defines.LIGHTMAP = false;
            defines.BUMP = false;
            defines.REFRACTION = false;
          }
          defines.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture();
          defines.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination;
          defines.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse;
          defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;
          defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
          defines.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null;
          defines.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(mesh);
        }
        this._eventInfo.isReadyForSubMesh = true;
        this._eventInfo.defines = defines;
        this._eventInfo.subMesh = subMesh;
        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
        if (!this._eventInfo.isReadyForSubMesh) {
          return false;
        }
        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
          if (!this._imageProcessingConfiguration.isReady()) {
            return false;
          }
          this._imageProcessingConfiguration.prepareDefines(defines);
          defines.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace;
          defines.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;
        }
        if (defines._areFresnelDirty) {
          if (_StandardMaterial.FresnelEnabled) {
            if (this._diffuseFresnelParameters || this._opacityFresnelParameters || this._emissiveFresnelParameters || this._refractionFresnelParameters || this._reflectionFresnelParameters) {
              defines.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled;
              defines.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
              defines.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled;
              defines.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular;
              defines.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled;
              defines.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled;
              defines._needNormals = true;
              defines.FRESNEL = true;
            }
          } else {
            defines.FRESNEL = false;
          }
        }
        if (defines["AREALIGHTUSED"] || defines["CLUSTLIGHT_BATCH"]) {
          for (let index = 0; index < mesh.lightSources.length; index++) {
            if (!mesh.lightSources[index]._isReady()) {
              return false;
            }
          }
        }
        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines, this._applyDecalMapAfterDetailMap, this._useVertexPulling, subMesh.getRenderingMesh(), this._isVertexOutputInvariant);
        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);
        this._eventInfo.defines = defines;
        this._eventInfo.mesh = mesh;
        this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);
        PrepareDefinesForAttributes(mesh, defines, true, true, true);
        this._callbackPluginEventPrepareDefines(this._eventInfo);
        let forceWasNotReadyPreviously = false;
        if (defines.isDirty) {
          const lightDisposed = defines._areLightsDisposed;
          defines.markAsProcessed();
          const fallbacks = new EffectFallbacks();
          if (defines.REFLECTION) {
            fallbacks.addFallback(0, "REFLECTION");
          }
          if (defines.SPECULAR) {
            fallbacks.addFallback(0, "SPECULAR");
          }
          if (defines.BUMP) {
            fallbacks.addFallback(0, "BUMP");
          }
          if (defines.PARALLAX) {
            fallbacks.addFallback(1, "PARALLAX");
          }
          if (defines.PARALLAX_RHS) {
            fallbacks.addFallback(1, "PARALLAX_RHS");
          }
          if (defines.PARALLAXOCCLUSION) {
            fallbacks.addFallback(0, "PARALLAXOCCLUSION");
          }
          if (defines.SPECULAROVERALPHA) {
            fallbacks.addFallback(0, "SPECULAROVERALPHA");
          }
          if (defines.FOG) {
            fallbacks.addFallback(1, "FOG");
          }
          if (defines.POINTSIZE) {
            fallbacks.addFallback(0, "POINTSIZE");
          }
          if (defines.LOGARITHMICDEPTH) {
            fallbacks.addFallback(0, "LOGARITHMICDEPTH");
          }
          HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);
          if (defines.SPECULARTERM) {
            fallbacks.addFallback(0, "SPECULARTERM");
          }
          if (defines.DIFFUSEFRESNEL) {
            fallbacks.addFallback(1, "DIFFUSEFRESNEL");
          }
          if (defines.OPACITYFRESNEL) {
            fallbacks.addFallback(2, "OPACITYFRESNEL");
          }
          if (defines.REFLECTIONFRESNEL) {
            fallbacks.addFallback(3, "REFLECTIONFRESNEL");
          }
          if (defines.EMISSIVEFRESNEL) {
            fallbacks.addFallback(4, "EMISSIVEFRESNEL");
          }
          if (defines.FRESNEL) {
            fallbacks.addFallback(4, "FRESNEL");
          }
          if (defines.MULTIVIEW) {
            fallbacks.addFallback(0, "MULTIVIEW");
          }
          const attribs = [VertexBuffer.PositionKind];
          if (defines.NORMAL) {
            attribs.push(VertexBuffer.NormalKind);
          }
          if (defines.TANGENT) {
            attribs.push(VertexBuffer.TangentKind);
          }
          for (let i = 1; i <= 6; ++i) {
            if (defines["UV" + i]) {
              attribs.push(`uv${i === 1 ? "" : i}`);
            }
          }
          if (defines.VERTEXCOLOR) {
            attribs.push(VertexBuffer.ColorKind);
          }
          PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
          PrepareAttributesForInstances(attribs, defines);
          PrepareAttributesForMorphTargets(attribs, mesh, defines);
          PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
          let shaderName = "default";
          const uniforms = [
            "world",
            "view",
            "viewProjection",
            "vEyePosition",
            "vLightsType",
            "vAmbientColor",
            "vDiffuseColor",
            "vSpecularColor",
            "vEmissiveColor",
            "visibility",
            "vFogInfos",
            "vFogColor",
            "pointSize",
            "vDiffuseInfos",
            "vAmbientInfos",
            "vOpacityInfos",
            "vEmissiveInfos",
            "vSpecularInfos",
            "vBumpInfos",
            "vLightmapInfos",
            "vRefractionInfos",
            "mBones",
            "diffuseMatrix",
            "ambientMatrix",
            "opacityMatrix",
            "emissiveMatrix",
            "specularMatrix",
            "bumpMatrix",
            "normalMatrix",
            "lightmapMatrix",
            "refractionMatrix",
            "diffuseLeftColor",
            "diffuseRightColor",
            "opacityParts",
            "reflectionLeftColor",
            "reflectionRightColor",
            "emissiveLeftColor",
            "emissiveRightColor",
            "refractionLeftColor",
            "refractionRightColor",
            "vRefractionPosition",
            "vRefractionSize",
            "logarithmicDepthConstant",
            "vTangentSpaceParams",
            "alphaCutOff",
            "boneTextureWidth",
            "morphTargetTextureInfo",
            "morphTargetTextureIndices",
            "cameraInfo"
          ];
          const samplers = [
            "diffuseSampler",
            "ambientSampler",
            "opacitySampler",
            "reflectionCubeSampler",
            "reflection2DSampler",
            "emissiveSampler",
            "specularSampler",
            "bumpSampler",
            "lightmapSampler",
            "refractionCubeSampler",
            "refraction2DSampler",
            "boneSampler",
            "morphTargets",
            "oitDepthSampler",
            "oitFrontColorSampler",
            "areaLightsLTC1Sampler",
            "areaLightsLTC2Sampler"
          ];
          PrepareUniformsAndSamplersForIBL(uniforms, samplers, false);
          const uniformBuffers = ["Material", "Scene", "Mesh"];
          const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };
          this._eventInfo.fallbacks = fallbacks;
          this._eventInfo.fallbackRank = 0;
          this._eventInfo.defines = defines;
          this._eventInfo.uniforms = uniforms;
          this._eventInfo.attributes = attribs;
          this._eventInfo.samplers = samplers;
          this._eventInfo.uniformBuffersNames = uniformBuffers;
          this._eventInfo.customCode = void 0;
          this._eventInfo.mesh = mesh;
          this._eventInfo.indexParameters = indexParameters;
          this._callbackPluginEventGeneric(128, this._eventInfo);
          MaterialHelperGeometryRendering.AddUniformsAndSamplers(uniforms, samplers);
          PrePassConfiguration.AddUniforms(uniforms);
          PrePassConfiguration.AddSamplers(samplers);
          if (ImageProcessingConfiguration) {
            ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
            ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
          }
          PrepareUniformsAndSamplersList({
            uniformsNames: uniforms,
            uniformBuffersNames: uniformBuffers,
            samplers,
            defines,
            maxSimultaneousLights: this._maxSimultaneousLights
          });
          AddClipPlaneUniforms(uniforms);
          const csnrOptions = {};
          if (this.customShaderNameResolve) {
            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
          }
          const join = defines.toString();
          const previousEffect = subMesh.effect;
          let effect = scene.getEngine().createEffect(shaderName, {
            attributes: attribs,
            uniformsNames: uniforms,
            uniformBuffersNames: uniformBuffers,
            samplers,
            defines: join,
            fallbacks,
            onCompiled: this.onCompiled,
            onError: this.onError,
            indexParameters,
            processFinalCode: csnrOptions.processFinalCode,
            processCodeAfterIncludes: this._eventInfo.customCode,
            multiTarget: defines.PREPASS,
            shaderLanguage: this._shaderLanguage,
            extraInitializationsAsync: this._shadersLoaded ? void 0 : async () => {
              if (this._shaderLanguage === 1) {
                await Promise.all([import("./default.vertex-X3STB7VW.js"), import("./default.fragment-WQ3PHRY6.js")]);
              } else {
                await Promise.all([import("./default.vertex-64QL6URA.js"), import("./default.fragment-3CJ55TYI.js")]);
              }
              this._shadersLoaded = true;
            }
          }, engine);
          this._eventInfo.customCode = void 0;
          if (effect) {
            if (this._onEffectCreatedObservable) {
              onCreatedEffectParameters.effect = effect;
              onCreatedEffectParameters.subMesh = subMesh;
              this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
            }
            if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
              effect = previousEffect;
              defines.markAsUnprocessed();
              forceWasNotReadyPreviously = this.isFrozen;
              if (lightDisposed) {
                defines._areLightsDisposed = true;
                return false;
              }
            } else {
              scene.resetCachedMaterial();
              subMesh.setEffect(effect, defines, this._materialContext);
            }
          }
        }
        if (!subMesh.effect || !subMesh.effect.isReady()) {
          return false;
        }
        defines._renderId = scene.getRenderId();
        drawWrapper._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;
        drawWrapper._wasPreviouslyUsingInstances = useInstances;
        this._checkScenePerformancePriority();
        return true;
      }
      /**
       * Builds the material UBO layouts.
       * Used internally during the effect preparation.
       */
      buildUniformLayout() {
        const ubo = this._uniformBuffer;
        ubo.addUniform("diffuseLeftColor", 4);
        ubo.addUniform("diffuseRightColor", 4);
        ubo.addUniform("opacityParts", 4);
        ubo.addUniform("reflectionLeftColor", 4);
        ubo.addUniform("reflectionRightColor", 4);
        ubo.addUniform("refractionLeftColor", 4);
        ubo.addUniform("refractionRightColor", 4);
        ubo.addUniform("emissiveLeftColor", 4);
        ubo.addUniform("emissiveRightColor", 4);
        ubo.addUniform("vDiffuseInfos", 2);
        ubo.addUniform("vAmbientInfos", 2);
        ubo.addUniform("vOpacityInfos", 2);
        ubo.addUniform("vEmissiveInfos", 2);
        ubo.addUniform("vLightmapInfos", 2);
        ubo.addUniform("vSpecularInfos", 2);
        ubo.addUniform("vBumpInfos", 3);
        ubo.addUniform("diffuseMatrix", 16);
        ubo.addUniform("ambientMatrix", 16);
        ubo.addUniform("opacityMatrix", 16);
        ubo.addUniform("emissiveMatrix", 16);
        ubo.addUniform("lightmapMatrix", 16);
        ubo.addUniform("specularMatrix", 16);
        ubo.addUniform("bumpMatrix", 16);
        ubo.addUniform("vTangentSpaceParams", 2);
        ubo.addUniform("pointSize", 1);
        ubo.addUniform("alphaCutOff", 1);
        ubo.addUniform("refractionMatrix", 16);
        ubo.addUniform("vRefractionInfos", 4);
        ubo.addUniform("vRefractionPosition", 3);
        ubo.addUniform("vRefractionSize", 3);
        ubo.addUniform("vSpecularColor", 4);
        ubo.addUniform("vEmissiveColor", 3);
        ubo.addUniform("vDiffuseColor", 4);
        ubo.addUniform("vAmbientColor", 3);
        ubo.addUniform("cameraInfo", 4);
        PrepareUniformLayoutForIBL(ubo, false, true);
        super.buildUniformLayout();
      }
      /**
       * Binds the submesh to this material by preparing the effect and shader to draw
       * @param world defines the world transformation matrix
       * @param mesh defines the mesh containing the submesh
       * @param subMesh defines the submesh to bind the material to
       */
      bindForSubMesh(world, mesh, subMesh) {
        const scene = this.getScene();
        const defines = subMesh.materialDefines;
        if (!defines) {
          return;
        }
        const effect = subMesh.effect;
        if (!effect) {
          return;
        }
        this._activeEffect = effect;
        mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
        mesh.transferToEffect(world);
        this._uniformBuffer.bindToEffect(effect, "Material");
        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
        MaterialHelperGeometryRendering.Bind(scene.getEngine().currentRenderPassId, this._activeEffect, mesh, world, this);
        const camera = scene.activeCamera;
        if (camera) {
          this._uniformBuffer.updateFloat4("cameraInfo", camera.minZ, camera.maxZ, 0, 0);
        } else {
          this._uniformBuffer.updateFloat4("cameraInfo", 0, 0, 0, 0);
        }
        this._eventInfo.subMesh = subMesh;
        this._callbackPluginEventHardBindForSubMesh(this._eventInfo);
        if (defines.OBJECTSPACE_NORMALMAP) {
          world.toNormalMatrix(this._normalMatrix);
          this.bindOnlyNormalMatrix(this._normalMatrix);
        }
        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
        BindBonesParameters(mesh, effect);
        const ubo = this._uniformBuffer;
        if (mustRebind) {
          this.bindViewProjection(effect);
          if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || subMesh._drawWrapper._forceRebindOnNextCall) {
            if (_StandardMaterial.FresnelEnabled && defines.FRESNEL) {
              if (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled) {
                ubo.updateColor4("diffuseLeftColor", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power);
                ubo.updateColor4("diffuseRightColor", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias);
              }
              if (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled) {
                ubo.updateColor4("opacityParts", new Color3(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power);
              }
              if (this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled) {
                ubo.updateColor4("reflectionLeftColor", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power);
                ubo.updateColor4("reflectionRightColor", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias);
              }
              if (this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled) {
                ubo.updateColor4("refractionLeftColor", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power);
                ubo.updateColor4("refractionRightColor", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias);
              }
              if (this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled) {
                ubo.updateColor4("emissiveLeftColor", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power);
                ubo.updateColor4("emissiveRightColor", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias);
              }
            }
            if (scene.texturesEnabled) {
              if (this._diffuseTexture && _StandardMaterial.DiffuseTextureEnabled) {
                ubo.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);
                BindTextureMatrix(this._diffuseTexture, ubo, "diffuse");
              }
              if (this._ambientTexture && _StandardMaterial.AmbientTextureEnabled) {
                ubo.updateFloat2("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level);
                BindTextureMatrix(this._ambientTexture, ubo, "ambient");
              }
              if (this._opacityTexture && _StandardMaterial.OpacityTextureEnabled) {
                ubo.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
                BindTextureMatrix(this._opacityTexture, ubo, "opacity");
              }
              if (this._hasAlphaChannel()) {
                ubo.updateFloat("alphaCutOff", this.alphaCutOff);
              }
              BindIBLParameters(scene, defines, ubo, Color3.White(), this._reflectionTexture, false, false, true, false, false, false, this.roughness);
              if (!this._reflectionTexture || !_StandardMaterial.ReflectionTextureEnabled) {
                ubo.updateFloat2("vReflectionInfos", 0, this.roughness);
              }
              if (this._emissiveTexture && _StandardMaterial.EmissiveTextureEnabled) {
                ubo.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);
                BindTextureMatrix(this._emissiveTexture, ubo, "emissive");
              }
              if (this._lightmapTexture && _StandardMaterial.LightmapTextureEnabled) {
                ubo.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);
                BindTextureMatrix(this._lightmapTexture, ubo, "lightmap");
              }
              if (this._specularTexture && _StandardMaterial.SpecularTextureEnabled) {
                ubo.updateFloat2("vSpecularInfos", this._specularTexture.coordinatesIndex, this._specularTexture.level);
                BindTextureMatrix(this._specularTexture, ubo, "specular");
              }
              if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && _StandardMaterial.BumpTextureEnabled) {
                ubo.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, 1 / this._bumpTexture.level, this.parallaxScaleBias);
                BindTextureMatrix(this._bumpTexture, ubo, "bump");
                if (scene._mirroredCameraPosition) {
                  ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
                } else {
                  ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
                }
              }
              if (this._refractionTexture && _StandardMaterial.RefractionTextureEnabled) {
                let depth = 1;
                if (!this._refractionTexture.isCube) {
                  ubo.updateMatrix("refractionMatrix", this._refractionTexture.getReflectionTextureMatrix());
                  if (this._refractionTexture.depth) {
                    depth = this._refractionTexture.depth;
                  }
                }
                ubo.updateFloat4("vRefractionInfos", this._refractionTexture.level, this.indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);
                if (this._refractionTexture.boundingBoxSize) {
                  const cubeTexture = this._refractionTexture;
                  ubo.updateVector3("vRefractionPosition", cubeTexture.boundingBoxPosition);
                  ubo.updateVector3("vRefractionSize", cubeTexture.boundingBoxSize);
                }
              }
            }
            if (this.pointsCloud) {
              ubo.updateFloat("pointSize", this.pointSize);
            }
            ubo.updateColor4("vSpecularColor", this.specularColor, this.specularPower);
            ubo.updateColor3("vEmissiveColor", _StandardMaterial.EmissiveTextureEnabled ? this.emissiveColor : Color3.BlackReadOnly);
            ubo.updateColor4("vDiffuseColor", this.diffuseColor, this.alpha);
            scene.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor);
            ubo.updateColor3("vAmbientColor", this._globalAmbientColor);
          }
          if (scene.texturesEnabled) {
            if (this._diffuseTexture && _StandardMaterial.DiffuseTextureEnabled) {
              effect.setTexture("diffuseSampler", this._diffuseTexture);
            }
            if (this._ambientTexture && _StandardMaterial.AmbientTextureEnabled) {
              effect.setTexture("ambientSampler", this._ambientTexture);
            }
            if (this._opacityTexture && _StandardMaterial.OpacityTextureEnabled) {
              effect.setTexture("opacitySampler", this._opacityTexture);
            }
            if (this._reflectionTexture && _StandardMaterial.ReflectionTextureEnabled) {
              if (this._reflectionTexture.isCube) {
                effect.setTexture("reflectionCubeSampler", this._reflectionTexture);
              } else {
                effect.setTexture("reflection2DSampler", this._reflectionTexture);
              }
            }
            if (this._emissiveTexture && _StandardMaterial.EmissiveTextureEnabled) {
              effect.setTexture("emissiveSampler", this._emissiveTexture);
            }
            if (this._lightmapTexture && _StandardMaterial.LightmapTextureEnabled) {
              effect.setTexture("lightmapSampler", this._lightmapTexture);
            }
            if (this._specularTexture && _StandardMaterial.SpecularTextureEnabled) {
              effect.setTexture("specularSampler", this._specularTexture);
            }
            if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && _StandardMaterial.BumpTextureEnabled) {
              effect.setTexture("bumpSampler", this._bumpTexture);
            }
            if (this._refractionTexture && _StandardMaterial.RefractionTextureEnabled) {
              if (this._refractionTexture.isCube) {
                effect.setTexture("refractionCubeSampler", this._refractionTexture);
              } else {
                effect.setTexture("refraction2DSampler", this._refractionTexture);
              }
            }
          }
          if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {
            this.getScene().depthPeelingRenderer.bind(effect);
          }
          this._eventInfo.subMesh = subMesh;
          this._callbackPluginEventBindForSubMesh(this._eventInfo);
          BindClipPlane(effect, this, scene);
          this.bindEyePosition(effect);
        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
          this._needToBindSceneUbo = true;
        }
        if (mustRebind || !this.isFrozen) {
          if (scene.lightsEnabled && !this._disableLighting) {
            BindLights(scene, mesh, effect, defines, this._maxSimultaneousLights);
          }
          if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture || mesh.receiveShadows || defines.PREPASS || defines["CLUSTLIGHT_BATCH"]) {
            this.bindView(effect);
          }
          BindFogParameters(scene, mesh, effect);
          if (defines.NUM_MORPH_INFLUENCERS) {
            BindMorphTargetParameters(mesh, effect);
          }
          if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {
            mesh.bakedVertexAnimationManager?.bind(effect, defines.INSTANCES);
          }
          if (this.useLogarithmicDepth) {
            BindLogDepth(defines, effect, scene);
          }
          if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
            this._imageProcessingConfiguration.bind(this._activeEffect);
          }
        }
        this._afterBind(mesh, this._activeEffect, subMesh);
        ubo.update();
      }
      /**
       * Get the list of animatables in the material.
       * @returns the list of animatables object used in the material
       */
      getAnimatables() {
        const results = super.getAnimatables();
        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {
          results.push(this._diffuseTexture);
        }
        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {
          results.push(this._ambientTexture);
        }
        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
          results.push(this._opacityTexture);
        }
        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {
          results.push(this._reflectionTexture);
        }
        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {
          results.push(this._emissiveTexture);
        }
        if (this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0) {
          results.push(this._specularTexture);
        }
        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
          results.push(this._bumpTexture);
        }
        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {
          results.push(this._lightmapTexture);
        }
        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {
          results.push(this._refractionTexture);
        }
        return results;
      }
      /**
       * Gets the active textures from the material
       * @returns an array of textures
       */
      getActiveTextures() {
        const activeTextures = super.getActiveTextures();
        if (this._diffuseTexture) {
          activeTextures.push(this._diffuseTexture);
        }
        if (this._ambientTexture) {
          activeTextures.push(this._ambientTexture);
        }
        if (this._opacityTexture) {
          activeTextures.push(this._opacityTexture);
        }
        if (this._reflectionTexture) {
          activeTextures.push(this._reflectionTexture);
        }
        if (this._emissiveTexture) {
          activeTextures.push(this._emissiveTexture);
        }
        if (this._specularTexture) {
          activeTextures.push(this._specularTexture);
        }
        if (this._bumpTexture) {
          activeTextures.push(this._bumpTexture);
        }
        if (this._lightmapTexture) {
          activeTextures.push(this._lightmapTexture);
        }
        if (this._refractionTexture) {
          activeTextures.push(this._refractionTexture);
        }
        return activeTextures;
      }
      /**
       * Specifies if the material uses a texture
       * @param texture defines the texture to check against the material
       * @returns a boolean specifying if the material uses the texture
       */
      hasTexture(texture) {
        if (super.hasTexture(texture)) {
          return true;
        }
        if (this._diffuseTexture === texture) {
          return true;
        }
        if (this._ambientTexture === texture) {
          return true;
        }
        if (this._opacityTexture === texture) {
          return true;
        }
        if (this._reflectionTexture === texture) {
          return true;
        }
        if (this._emissiveTexture === texture) {
          return true;
        }
        if (this._specularTexture === texture) {
          return true;
        }
        if (this._bumpTexture === texture) {
          return true;
        }
        if (this._lightmapTexture === texture) {
          return true;
        }
        if (this._refractionTexture === texture) {
          return true;
        }
        return false;
      }
      /**
       * Disposes the material
       * @param forceDisposeEffect specifies if effects should be forcefully disposed
       * @param forceDisposeTextures specifies if textures should be forcefully disposed
       */
      dispose(forceDisposeEffect, forceDisposeTextures) {
        if (forceDisposeTextures) {
          this._diffuseTexture?.dispose();
          this._ambientTexture?.dispose();
          this._opacityTexture?.dispose();
          this._reflectionTexture?.dispose();
          this._emissiveTexture?.dispose();
          this._specularTexture?.dispose();
          this._bumpTexture?.dispose();
          this._lightmapTexture?.dispose();
          this._refractionTexture?.dispose();
        }
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        super.dispose(forceDisposeEffect, forceDisposeTextures);
      }
      /**
       * Makes a duplicate of the material, and gives it a new name
       * @param name defines the new name for the duplicated material
       * @param cloneTexturesOnlyOnce - if a texture is used in more than one channel (e.g diffuse and opacity), only clone it once and reuse it on the other channels. Default false.
       * @param rootUrl defines the root URL to use to load textures
       * @returns the cloned material
       */
      clone(name, cloneTexturesOnlyOnce = true, rootUrl = "") {
        const result = SerializationHelper.Clone(() => new _StandardMaterial(name, this.getScene()), this, { cloneTexturesOnlyOnce });
        result.name = name;
        result.id = name;
        this.stencil.copyTo(result.stencil);
        this._clonePlugins(result, rootUrl);
        return result;
      }
      /**
       * Creates a standard material from parsed material data
       * @param source defines the JSON representation of the material
       * @param scene defines the hosting scene
       * @param rootUrl defines the root URL to use to load textures and relative dependencies
       * @returns a new standard material
       */
      static Parse(source, scene, rootUrl) {
        const material = SerializationHelper.Parse(() => new _StandardMaterial(source.name, scene), source, scene, rootUrl);
        if (source.stencil) {
          material.stencil.parse(source.stencil, scene, rootUrl);
        }
        Material._ParsePlugins(source, material, scene, rootUrl);
        return material;
      }
      // Flags used to enable or disable a type of texture for all Standard Materials
      /**
       * Are diffuse textures enabled in the application.
       */
      static get DiffuseTextureEnabled() {
        return MaterialFlags.DiffuseTextureEnabled;
      }
      static set DiffuseTextureEnabled(value) {
        MaterialFlags.DiffuseTextureEnabled = value;
      }
      /**
       * Are detail textures enabled in the application.
       */
      static get DetailTextureEnabled() {
        return MaterialFlags.DetailTextureEnabled;
      }
      static set DetailTextureEnabled(value) {
        MaterialFlags.DetailTextureEnabled = value;
      }
      /**
       * Are ambient textures enabled in the application.
       */
      static get AmbientTextureEnabled() {
        return MaterialFlags.AmbientTextureEnabled;
      }
      static set AmbientTextureEnabled(value) {
        MaterialFlags.AmbientTextureEnabled = value;
      }
      /**
       * Are opacity textures enabled in the application.
       */
      static get OpacityTextureEnabled() {
        return MaterialFlags.OpacityTextureEnabled;
      }
      static set OpacityTextureEnabled(value) {
        MaterialFlags.OpacityTextureEnabled = value;
      }
      /**
       * Are reflection textures enabled in the application.
       */
      static get ReflectionTextureEnabled() {
        return MaterialFlags.ReflectionTextureEnabled;
      }
      static set ReflectionTextureEnabled(value) {
        MaterialFlags.ReflectionTextureEnabled = value;
      }
      /**
       * Are emissive textures enabled in the application.
       */
      static get EmissiveTextureEnabled() {
        return MaterialFlags.EmissiveTextureEnabled;
      }
      static set EmissiveTextureEnabled(value) {
        MaterialFlags.EmissiveTextureEnabled = value;
      }
      /**
       * Are specular textures enabled in the application.
       */
      static get SpecularTextureEnabled() {
        return MaterialFlags.SpecularTextureEnabled;
      }
      static set SpecularTextureEnabled(value) {
        MaterialFlags.SpecularTextureEnabled = value;
      }
      /**
       * Are bump textures enabled in the application.
       */
      static get BumpTextureEnabled() {
        return MaterialFlags.BumpTextureEnabled;
      }
      static set BumpTextureEnabled(value) {
        MaterialFlags.BumpTextureEnabled = value;
      }
      /**
       * Are lightmap textures enabled in the application.
       */
      static get LightmapTextureEnabled() {
        return MaterialFlags.LightmapTextureEnabled;
      }
      static set LightmapTextureEnabled(value) {
        MaterialFlags.LightmapTextureEnabled = value;
      }
      /**
       * Are refraction textures enabled in the application.
       */
      static get RefractionTextureEnabled() {
        return MaterialFlags.RefractionTextureEnabled;
      }
      static set RefractionTextureEnabled(value) {
        MaterialFlags.RefractionTextureEnabled = value;
      }
      /**
       * Are color grading textures enabled in the application.
       */
      static get ColorGradingTextureEnabled() {
        return MaterialFlags.ColorGradingTextureEnabled;
      }
      static set ColorGradingTextureEnabled(value) {
        MaterialFlags.ColorGradingTextureEnabled = value;
      }
      /**
       * Are fresnels enabled in the application.
       */
      static get FresnelEnabled() {
        return MaterialFlags.FresnelEnabled;
      }
      static set FresnelEnabled(value) {
        MaterialFlags.FresnelEnabled = value;
      }
    };
    StandardMaterial.ForceGLSL = false;
    __decorate([
      serializeAsTexture("diffuseTexture")
    ], StandardMaterial.prototype, "_diffuseTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], StandardMaterial.prototype, "diffuseTexture", void 0);
    __decorate([
      serializeAsTexture("ambientTexture")
    ], StandardMaterial.prototype, "_ambientTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "ambientTexture", void 0);
    __decorate([
      serializeAsTexture("opacityTexture")
    ], StandardMaterial.prototype, "_opacityTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], StandardMaterial.prototype, "opacityTexture", void 0);
    __decorate([
      serializeAsTexture("reflectionTexture")
    ], StandardMaterial.prototype, "_reflectionTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "reflectionTexture", void 0);
    __decorate([
      serializeAsTexture("emissiveTexture")
    ], StandardMaterial.prototype, "_emissiveTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "emissiveTexture", void 0);
    __decorate([
      serializeAsTexture("specularTexture")
    ], StandardMaterial.prototype, "_specularTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "specularTexture", void 0);
    __decorate([
      serializeAsTexture("bumpTexture")
    ], StandardMaterial.prototype, "_bumpTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "bumpTexture", void 0);
    __decorate([
      serializeAsTexture("lightmapTexture")
    ], StandardMaterial.prototype, "_lightmapTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "lightmapTexture", void 0);
    __decorate([
      serializeAsTexture("refractionTexture")
    ], StandardMaterial.prototype, "_refractionTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "refractionTexture", void 0);
    __decorate([
      serializeAsColor3("ambient")
    ], StandardMaterial.prototype, "ambientColor", void 0);
    __decorate([
      serializeAsColor3("diffuse")
    ], StandardMaterial.prototype, "diffuseColor", void 0);
    __decorate([
      serializeAsColor3("specular")
    ], StandardMaterial.prototype, "specularColor", void 0);
    __decorate([
      serializeAsColor3("emissive")
    ], StandardMaterial.prototype, "emissiveColor", void 0);
    __decorate([
      serialize()
    ], StandardMaterial.prototype, "specularPower", void 0);
    __decorate([
      serialize("useAlphaFromDiffuseTexture")
    ], StandardMaterial.prototype, "_useAlphaFromDiffuseTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], StandardMaterial.prototype, "useAlphaFromDiffuseTexture", void 0);
    __decorate([
      serialize("useEmissiveAsIllumination")
    ], StandardMaterial.prototype, "_useEmissiveAsIllumination", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "useEmissiveAsIllumination", void 0);
    __decorate([
      serialize("linkEmissiveWithDiffuse")
    ], StandardMaterial.prototype, "_linkEmissiveWithDiffuse", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "linkEmissiveWithDiffuse", void 0);
    __decorate([
      serialize("useSpecularOverAlpha")
    ], StandardMaterial.prototype, "_useSpecularOverAlpha", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "useSpecularOverAlpha", void 0);
    __decorate([
      serialize("useReflectionOverAlpha")
    ], StandardMaterial.prototype, "_useReflectionOverAlpha", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "useReflectionOverAlpha", void 0);
    __decorate([
      serialize("disableLighting")
    ], StandardMaterial.prototype, "_disableLighting", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], StandardMaterial.prototype, "disableLighting", void 0);
    __decorate([
      serialize("useObjectSpaceNormalMap")
    ], StandardMaterial.prototype, "_useObjectSpaceNormalMap", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "useObjectSpaceNormalMap", void 0);
    __decorate([
      serialize("useParallax")
    ], StandardMaterial.prototype, "_useParallax", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "useParallax", void 0);
    __decorate([
      serialize("useParallaxOcclusion")
    ], StandardMaterial.prototype, "_useParallaxOcclusion", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "useParallaxOcclusion", void 0);
    __decorate([
      serialize()
    ], StandardMaterial.prototype, "parallaxScaleBias", void 0);
    __decorate([
      serialize("roughness")
    ], StandardMaterial.prototype, "_roughness", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "roughness", void 0);
    __decorate([
      serialize()
    ], StandardMaterial.prototype, "indexOfRefraction", void 0);
    __decorate([
      serialize()
    ], StandardMaterial.prototype, "invertRefractionY", void 0);
    __decorate([
      serialize()
    ], StandardMaterial.prototype, "alphaCutOff", void 0);
    __decorate([
      serialize("useLightmapAsShadowmap")
    ], StandardMaterial.prototype, "_useLightmapAsShadowmap", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "useLightmapAsShadowmap", void 0);
    __decorate([
      serializeAsFresnelParameters("diffuseFresnelParameters")
    ], StandardMaterial.prototype, "_diffuseFresnelParameters", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsFresnelDirty")
    ], StandardMaterial.prototype, "diffuseFresnelParameters", void 0);
    __decorate([
      serializeAsFresnelParameters("opacityFresnelParameters")
    ], StandardMaterial.prototype, "_opacityFresnelParameters", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsFresnelAndMiscDirty")
    ], StandardMaterial.prototype, "opacityFresnelParameters", void 0);
    __decorate([
      serializeAsFresnelParameters("reflectionFresnelParameters")
    ], StandardMaterial.prototype, "_reflectionFresnelParameters", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsFresnelDirty")
    ], StandardMaterial.prototype, "reflectionFresnelParameters", void 0);
    __decorate([
      serializeAsFresnelParameters("refractionFresnelParameters")
    ], StandardMaterial.prototype, "_refractionFresnelParameters", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsFresnelDirty")
    ], StandardMaterial.prototype, "refractionFresnelParameters", void 0);
    __decorate([
      serializeAsFresnelParameters("emissiveFresnelParameters")
    ], StandardMaterial.prototype, "_emissiveFresnelParameters", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsFresnelDirty")
    ], StandardMaterial.prototype, "emissiveFresnelParameters", void 0);
    __decorate([
      serialize("useReflectionFresnelFromSpecular")
    ], StandardMaterial.prototype, "_useReflectionFresnelFromSpecular", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsFresnelDirty")
    ], StandardMaterial.prototype, "useReflectionFresnelFromSpecular", void 0);
    __decorate([
      serialize("useGlossinessFromSpecularMapAlpha")
    ], StandardMaterial.prototype, "_useGlossinessFromSpecularMapAlpha", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "useGlossinessFromSpecularMapAlpha", void 0);
    __decorate([
      serialize("maxSimultaneousLights")
    ], StandardMaterial.prototype, "_maxSimultaneousLights", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], StandardMaterial.prototype, "maxSimultaneousLights", void 0);
    __decorate([
      serialize("invertNormalMapX")
    ], StandardMaterial.prototype, "_invertNormalMapX", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "invertNormalMapX", void 0);
    __decorate([
      serialize("invertNormalMapY")
    ], StandardMaterial.prototype, "_invertNormalMapY", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "invertNormalMapY", void 0);
    __decorate([
      serialize("twoSidedLighting")
    ], StandardMaterial.prototype, "_twoSidedLighting", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "twoSidedLighting", void 0);
    __decorate([
      serialize("applyDecalMapAfterDetailMap")
    ], StandardMaterial.prototype, "_applyDecalMapAfterDetailMap", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], StandardMaterial.prototype, "applyDecalMapAfterDetailMap", void 0);
    RegisterClass("BABYLON.StandardMaterial", StandardMaterial);
    Scene.DefaultMaterialFactory = (scene) => {
      return new StandardMaterial("default material", scene);
    };
  }
});

// node_modules/@babylonjs/core/Materials/vertexPullingHelper.functions.js
function PrepareVertexPullingUniforms(geometry) {
  const vertexBuffers = geometry.getVertexBuffers();
  if (!vertexBuffers) {
    return null;
  }
  let metadata = _VertexPullingMetadataCache.get(geometry);
  if (!metadata) {
    metadata = /* @__PURE__ */ new Map();
    _VertexPullingMetadataCache.set(geometry, metadata);
  } else {
    let needsUpdate = false;
    for (const vb in vertexBuffers) {
      if (!metadata.has(vb)) {
        needsUpdate = true;
        break;
      }
    }
    if (!needsUpdate) {
      return metadata;
    }
  }
  for (const vb in vertexBuffers) {
    const vertexBuffer = vertexBuffers[vb];
    if (vertexBuffer) {
      const offset = vertexBuffer.byteOffset;
      const stride = vertexBuffer.byteStride;
      const type = vertexBuffer.type;
      metadata.set(vb, {
        offset,
        stride,
        type
      });
    }
  }
  return metadata;
}
function BindVertexPullingUniforms(effect, metadata) {
  metadata.forEach((data, attribute) => {
    const uniformName = `vp_${attribute}_info`;
    effect.setFloat3(uniformName, data.offset, data.stride, data.type);
  });
}
var _VertexPullingMetadataCache;
var init_vertexPullingHelper_functions = __esm({
  "node_modules/@babylonjs/core/Materials/vertexPullingHelper.functions.js"() {
    _VertexPullingMetadataCache = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@babylonjs/core/Materials/shaderMaterial.js
var OnCreatedEffectParameters, ShaderMaterial;
var init_shaderMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/shaderMaterial.js"() {
    init_decorators_serialization();
    init_scene();
    init_math_vector();
    init_buffer();
    init_texture();
    init_typeStore();
    init_effectFallbacks();
    init_webRequest();
    init_pushMaterial();
    init_engineStore();
    init_clipPlaneMaterialHelper();
    init_materialHelper_functions();
    init_vertexPullingHelper_functions();
    OnCreatedEffectParameters = { effect: null, subMesh: null };
    ShaderMaterial = class _ShaderMaterial extends PushMaterial {
      /**
       * Instantiate a new shader material.
       * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.
       * This returned material effects how the mesh will look based on the code in the shaders.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial
       * @param name Define the name of the material in the scene
       * @param scene Define the scene the material belongs to
       * @param shaderPath Defines  the route to the shader code.
       * @param options Define the options used to create the shader
       * @param storeEffectOnSubMeshes true to store effect on submeshes, false to store the effect directly in the material class.
       */
      constructor(name, scene, shaderPath, options = {}, storeEffectOnSubMeshes = true) {
        super(name, scene, storeEffectOnSubMeshes);
        this._textures = {};
        this._internalTextures = {};
        this._textureArrays = {};
        this._externalTextures = {};
        this._floats = {};
        this._ints = {};
        this._uints = {};
        this._floatsArrays = {};
        this._colors3 = {};
        this._colors3Arrays = {};
        this._colors4 = {};
        this._colors4Arrays = {};
        this._vectors2 = {};
        this._vectors3 = {};
        this._vectors4 = {};
        this._quaternions = {};
        this._quaternionsArrays = {};
        this._matrices = {};
        this._matrixArrays = {};
        this._matrices3x3 = {};
        this._matrices2x2 = {};
        this._vectors2Arrays = {};
        this._vectors3Arrays = {};
        this._vectors4Arrays = {};
        this._uniformBuffers = {};
        this._textureSamplers = {};
        this._storageBuffers = {};
        this._cachedWorldViewMatrix = new Matrix();
        this._cachedWorldViewProjectionMatrix = new Matrix();
        this._multiview = false;
        this._vertexPullingMetadata = null;
        this._materialHelperNeedsPreviousMatrices = false;
        this._shaderPath = shaderPath;
        this._options = {
          needAlphaBlending: false,
          needAlphaTesting: false,
          attributes: ["position", "normal", "uv"],
          uniforms: ["worldViewProjection"],
          uniformBuffers: [],
          samplers: [],
          externalTextures: [],
          samplerObjects: [],
          storageBuffers: [],
          defines: [],
          useClipPlane: false,
          ...options
        };
      }
      /**
       * Gets the shader path used to define the shader code
       * It can be modified to trigger a new compilation
       */
      get shaderPath() {
        return this._shaderPath;
      }
      /**
       * Sets the shader path used to define the shader code
       * It can be modified to trigger a new compilation
       */
      set shaderPath(shaderPath) {
        this._shaderPath = shaderPath;
      }
      /**
       * Gets the options used to compile the shader.
       * They can be modified to trigger a new compilation
       */
      get options() {
        return this._options;
      }
      /**
       * is multiview set to true?
       */
      get isMultiview() {
        return this._multiview;
      }
      /**
       * Gets the current class name of the material e.g. "ShaderMaterial"
       * Mainly use in serialization.
       * @returns the class name
       */
      getClassName() {
        return "ShaderMaterial";
      }
      /**
       * Specifies if the material will require alpha blending
       * @returns a boolean specifying if alpha blending is needed
       */
      needAlphaBlending() {
        return this.alpha < 1 || this._options.needAlphaBlending;
      }
      /**
       * Specifies if this material should be rendered in alpha test mode
       * @returns a boolean specifying if an alpha test is needed.
       */
      needAlphaTesting() {
        return this._options.needAlphaTesting;
      }
      _checkUniform(uniformName) {
        if (this._options.uniforms.indexOf(uniformName) === -1) {
          this._options.uniforms.push(uniformName);
        }
      }
      /**
       * Set a texture in the shader.
       * @param name Define the name of the uniform samplers as defined in the shader
       * @param texture Define the texture to bind to this sampler
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setTexture(name, texture) {
        if (this._options.samplers.indexOf(name) === -1) {
          this._options.samplers.push(name);
        }
        this._textures[name] = texture;
        return this;
      }
      /**
       * Set an internal texture in the shader.
       * @param name Define the name of the uniform samplers as defined in the shader
       * @param texture Define the texture to bind to this sampler
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setInternalTexture(name, texture) {
        if (this._options.samplers.indexOf(name) === -1) {
          this._options.samplers.push(name);
        }
        this._internalTextures[name] = texture;
        return this;
      }
      /**
       * Remove a texture from the material.
       * @param name Define the name of the texture to remove
       */
      removeTexture(name) {
        delete this._textures[name];
      }
      /**
       * Set a texture array in the shader.
       * @param name Define the name of the uniform sampler array as defined in the shader
       * @param textures Define the list of textures to bind to this sampler
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setTextureArray(name, textures) {
        if (this._options.samplers.indexOf(name) === -1) {
          this._options.samplers.push(name);
        }
        this._checkUniform(name);
        this._textureArrays[name] = textures;
        return this;
      }
      /**
       * Set an internal texture in the shader.
       * @param name Define the name of the uniform samplers as defined in the shader
       * @param texture Define the texture to bind to this sampler
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setExternalTexture(name, texture) {
        if (this._options.externalTextures.indexOf(name) === -1) {
          this._options.externalTextures.push(name);
        }
        this._externalTextures[name] = texture;
        return this;
      }
      /**
       * Set a float in the shader.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setFloat(name, value) {
        this._checkUniform(name);
        this._floats[name] = value;
        return this;
      }
      /**
       * Set a int in the shader.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setInt(name, value) {
        this._checkUniform(name);
        this._ints[name] = value;
        return this;
      }
      /**
       * Set a unsigned int in the shader.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setUInt(name, value) {
        this._checkUniform(name);
        this._uints[name] = value;
        return this;
      }
      /**
       * Set an array of floats in the shader.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setFloats(name, value) {
        this._checkUniform(name);
        this._floatsArrays[name] = value;
        return this;
      }
      /**
       * Set a vec3 in the shader from a Color3.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setColor3(name, value) {
        this._checkUniform(name);
        this._colors3[name] = value;
        return this;
      }
      /**
       * Set a vec3 array in the shader from a IColor3Like array.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setColor3Array(name, value) {
        this._checkUniform(name);
        this._colors3Arrays[name] = value.reduce((arr, color) => {
          arr.push(color.r, color.g, color.b);
          return arr;
        }, []);
        return this;
      }
      /**
       * Set a vec4 in the shader from a Color4.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setColor4(name, value) {
        this._checkUniform(name);
        this._colors4[name] = value;
        return this;
      }
      /**
       * Set a vec4 array in the shader from a IColor4Like array.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setColor4Array(name, value) {
        this._checkUniform(name);
        this._colors4Arrays[name] = value.reduce((arr, color) => {
          arr.push(color.r, color.g, color.b, color.a);
          return arr;
        }, []);
        return this;
      }
      /**
       * Set a vec2 in the shader from a Vector2.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setVector2(name, value) {
        this._checkUniform(name);
        this._vectors2[name] = value;
        return this;
      }
      /**
       * Set a vec3 in the shader from a Vector3.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setVector3(name, value) {
        this._checkUniform(name);
        this._vectors3[name] = value;
        return this;
      }
      /**
       * Set a vec4 in the shader from a Vector4.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setVector4(name, value) {
        this._checkUniform(name);
        this._vectors4[name] = value;
        return this;
      }
      /**
       * Set a vec4 in the shader from a Quaternion.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setQuaternion(name, value) {
        this._checkUniform(name);
        this._quaternions[name] = value;
        return this;
      }
      /**
       * Set a vec4 array in the shader from a Quaternion array.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setQuaternionArray(name, value) {
        this._checkUniform(name);
        this._quaternionsArrays[name] = value.reduce((arr, quaternion) => {
          quaternion.toArray(arr, arr.length);
          return arr;
        }, []);
        return this;
      }
      /**
       * Set a mat4 in the shader from a Matrix.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setMatrix(name, value) {
        this._checkUniform(name);
        this._matrices[name] = value;
        return this;
      }
      /**
       * Set a float32Array in the shader from a matrix array.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setMatrices(name, value) {
        this._checkUniform(name);
        const float32Array = new Float32Array(value.length * 16);
        for (let index = 0; index < value.length; index++) {
          const matrix = value[index];
          matrix.copyToArray(float32Array, index * 16);
        }
        this._matrixArrays[name] = float32Array;
        return this;
      }
      /**
       * Set a mat3 in the shader from a Float32Array.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setMatrix3x3(name, value) {
        this._checkUniform(name);
        this._matrices3x3[name] = value;
        return this;
      }
      /**
       * Set a mat2 in the shader from a Float32Array.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setMatrix2x2(name, value) {
        this._checkUniform(name);
        this._matrices2x2[name] = value;
        return this;
      }
      /**
       * Set a vec2 array in the shader from a number array.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setArray2(name, value) {
        this._checkUniform(name);
        this._vectors2Arrays[name] = value;
        return this;
      }
      /**
       * Set a vec3 array in the shader from a number array.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setArray3(name, value) {
        this._checkUniform(name);
        this._vectors3Arrays[name] = value;
        return this;
      }
      /**
       * Set a vec4 array in the shader from a number array.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setArray4(name, value) {
        this._checkUniform(name);
        this._vectors4Arrays[name] = value;
        return this;
      }
      /**
       * Set a uniform buffer in the shader
       * @param name Define the name of the uniform as defined in the shader
       * @param buffer Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setUniformBuffer(name, buffer) {
        if (this._options.uniformBuffers.indexOf(name) === -1) {
          this._options.uniformBuffers.push(name);
        }
        this._uniformBuffers[name] = buffer;
        return this;
      }
      /**
       * Set a texture sampler in the shader
       * @param name Define the name of the uniform as defined in the shader
       * @param sampler Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setTextureSampler(name, sampler) {
        if (this._options.samplerObjects.indexOf(name) === -1) {
          this._options.samplerObjects.push(name);
        }
        this._textureSamplers[name] = sampler;
        return this;
      }
      /**
       * Set a storage buffer in the shader
       * @param name Define the name of the storage buffer as defined in the shader
       * @param buffer Define the value to give to the uniform
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setStorageBuffer(name, buffer) {
        if (this._options.storageBuffers.indexOf(name) === -1) {
          this._options.storageBuffers.push(name);
        }
        this._storageBuffers[name] = buffer;
        return this;
      }
      /**
       * Adds, removes, or replaces the specified shader define and value.
       * * setDefine("MY_DEFINE", true); // enables a boolean define
       * * setDefine("MY_DEFINE", "0.5"); // adds "#define MY_DEFINE 0.5" to the shader (or sets and replaces the value of any existing define with that name)
       * * setDefine("MY_DEFINE", false); // disables and removes the define
       * Note if the active defines do change, the shader will be recompiled and this can be expensive.
       * @param define the define name e.g., "OUTPUT_TO_SRGB" or "#define OUTPUT_TO_SRGB". If the define was passed into the constructor already, the version used should match that, and in either case, it should not include any appended value.
       * @param value either the value of the define (e.g. a numerical value) or for booleans, true if the define should be enabled or false if it should be disabled
       * @returns the material itself allowing "fluent" like uniform updates
       */
      setDefine(define, value) {
        const defineName = define.trimEnd() + " ";
        const existingDefineIdx = this.options.defines.findIndex((x) => x === define || x.startsWith(defineName));
        if (existingDefineIdx >= 0) {
          this.options.defines.splice(existingDefineIdx, 1);
        }
        if (typeof value !== "boolean" || value) {
          this.options.defines.push(defineName + value);
        }
        return this;
      }
      /**
       * Specifies that the submesh is ready to be used
       * @param mesh defines the mesh to check
       * @param subMesh defines which submesh to check
       * @param useInstances specifies that instances should be used
       * @returns a boolean indicating that the submesh is ready or not
       */
      isReadyForSubMesh(mesh, subMesh, useInstances) {
        return this.isReady(mesh, useInstances, subMesh);
      }
      /**
       * Checks if the material is ready to render the requested mesh
       * @param mesh Define the mesh to render
       * @param useInstances Define whether or not the material is used with instances
       * @param subMesh defines which submesh to render
       * @returns true if ready, otherwise false
       */
      isReady(mesh, useInstances, subMesh) {
        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;
        if (this.isFrozen) {
          const drawWrapper2 = storeEffectOnSubMeshes ? subMesh._drawWrapper : this._drawWrapper;
          if (drawWrapper2.effect && drawWrapper2._wasPreviouslyReady && drawWrapper2._wasPreviouslyUsingInstances === useInstances) {
            return true;
          }
        }
        const scene = this.getScene();
        const engine = scene.getEngine();
        const defines = [];
        const attribs = [];
        let fallbacks = null;
        let shaderName = this._shaderPath, uniforms = this._options.uniforms, uniformBuffers = this._options.uniformBuffers, samplers = this._options.samplers;
        if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {
          this._multiview = true;
          defines.push("#define MULTIVIEW");
          if (uniforms.indexOf("viewProjection") !== -1 && uniforms.indexOf("viewProjectionR") === -1) {
            uniforms.push("viewProjectionR");
          }
        }
        for (let index = 0; index < this._options.defines.length; index++) {
          const defineToAdd = this._options.defines[index].indexOf("#define") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;
          defines.push(defineToAdd);
        }
        for (let index = 0; index < this._options.attributes.length; index++) {
          attribs.push(this._options.attributes[index]);
        }
        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {
          if (attribs.indexOf(VertexBuffer.ColorKind) === -1) {
            attribs.push(VertexBuffer.ColorKind);
          }
          defines.push("#define VERTEXCOLOR");
        }
        if (useInstances) {
          defines.push("#define INSTANCES");
          PushAttributesForInstances(attribs, this._materialHelperNeedsPreviousMatrices);
          if (mesh?.hasThinInstances) {
            defines.push("#define THIN_INSTANCES");
            if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {
              attribs.push(VertexBuffer.ColorInstanceKind);
              defines.push("#define INSTANCESCOLOR");
            }
          }
        }
        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
          attribs.push(VertexBuffer.MatricesIndicesKind);
          attribs.push(VertexBuffer.MatricesWeightsKind);
          if (mesh.numBoneInfluencers > 4) {
            attribs.push(VertexBuffer.MatricesIndicesExtraKind);
            attribs.push(VertexBuffer.MatricesWeightsExtraKind);
          }
          const skeleton = mesh.skeleton;
          defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
          fallbacks = new EffectFallbacks();
          fallbacks.addCPUSkinningFallback(0, mesh);
          if (skeleton.isUsingTextureForMatrices) {
            defines.push("#define BONETEXTURE");
            if (uniforms.indexOf("boneTextureWidth") === -1) {
              uniforms.push("boneTextureWidth");
            }
            if (this._options.samplers.indexOf("boneSampler") === -1) {
              this._options.samplers.push("boneSampler");
            }
          } else {
            defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
            if (uniforms.indexOf("mBones") === -1) {
              uniforms.push("mBones");
            }
          }
        } else {
          defines.push("#define NUM_BONE_INFLUENCERS 0");
        }
        let numInfluencers = 0;
        const manager = mesh ? mesh.morphTargetManager : null;
        if (manager) {
          const uv = defines.indexOf("#define UV1") !== -1;
          const uv2 = defines.indexOf("#define UV2") !== -1;
          const tangent = defines.indexOf("#define TANGENT") !== -1;
          const normal = defines.indexOf("#define NORMAL") !== -1;
          const color = defines.indexOf("#define VERTEXCOLOR") !== -1;
          numInfluencers = PrepareDefinesAndAttributesForMorphTargets(
            manager,
            defines,
            attribs,
            mesh,
            true,
            // usePositionMorph
            normal,
            // useNormalMorph
            tangent,
            // useTangentMorph
            uv,
            // useUVMorph
            uv2,
            // useUV2Morph
            color
            // useColorMorph
          );
          if (manager.isUsingTextureForTargets) {
            if (uniforms.indexOf("morphTargetTextureIndices") === -1) {
              uniforms.push("morphTargetTextureIndices");
            }
            if (this._options.samplers.indexOf("morphTargets") === -1) {
              this._options.samplers.push("morphTargets");
            }
          }
          if (numInfluencers > 0) {
            uniforms = uniforms.slice();
            uniforms.push("morphTargetInfluences");
            uniforms.push("morphTargetCount");
            uniforms.push("morphTargetTextureInfo");
            uniforms.push("morphTargetTextureIndices");
          }
        } else {
          defines.push("#define NUM_MORPH_INFLUENCERS 0");
        }
        if (mesh) {
          const bvaManager = mesh.bakedVertexAnimationManager;
          if (bvaManager && bvaManager.isEnabled) {
            defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
            if (uniforms.indexOf("bakedVertexAnimationSettings") === -1) {
              uniforms.push("bakedVertexAnimationSettings");
            }
            if (uniforms.indexOf("bakedVertexAnimationTextureSizeInverted") === -1) {
              uniforms.push("bakedVertexAnimationTextureSizeInverted");
            }
            if (uniforms.indexOf("bakedVertexAnimationTime") === -1) {
              uniforms.push("bakedVertexAnimationTime");
            }
            if (this._options.samplers.indexOf("bakedVertexAnimationTexture") === -1) {
              this._options.samplers.push("bakedVertexAnimationTexture");
            }
            if (useInstances) {
              attribs.push("bakedVertexAnimationSettingsInstanced");
            }
          }
        }
        for (const name in this._textures) {
          if (!this._textures[name].isReady()) {
            return false;
          }
        }
        for (const name in this._internalTextures) {
          if (!this._internalTextures[name].isReady) {
            return false;
          }
        }
        if (mesh && this.needAlphaTestingForMesh(mesh)) {
          defines.push("#define ALPHATEST");
        }
        if (this._options.useClipPlane !== false) {
          AddClipPlaneUniforms(uniforms);
          PrepareStringDefinesForClipPlanes(this, scene, defines);
        }
        if (scene.fogEnabled && mesh?.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
          defines.push("#define FOG");
          if (uniforms.indexOf("view") === -1) {
            uniforms.push("view");
          }
          if (uniforms.indexOf("vFogInfos") === -1) {
            uniforms.push("vFogInfos");
          }
          if (uniforms.indexOf("vFogColor") === -1) {
            uniforms.push("vFogColor");
          }
        }
        if (this._useLogarithmicDepth) {
          defines.push("#define LOGARITHMICDEPTH");
          if (uniforms.indexOf("logarithmicDepthConstant") === -1) {
            uniforms.push("logarithmicDepthConstant");
          }
        }
        const renderingMesh = subMesh ? subMesh.getRenderingMesh() : mesh;
        if (renderingMesh && this.useVertexPulling) {
          const geometry = renderingMesh.geometry;
          if (geometry) {
            this._vertexPullingMetadata = PrepareVertexPullingUniforms(geometry);
            if (this._vertexPullingMetadata) {
              this._vertexPullingMetadata.forEach((_, attribute) => {
                uniforms.push(`vp_${attribute}_info`);
              });
            }
          }
          defines.push("#define USE_VERTEX_PULLING");
          const indexBuffer = renderingMesh.geometry?.getIndexBuffer();
          if (indexBuffer && !renderingMesh.isUnIndexed) {
            defines.push("#define VERTEX_PULLING_USE_INDEX_BUFFER");
            if (indexBuffer.is32Bits) {
              defines.push("#define VERTEX_PULLING_INDEX_BUFFER_32BITS");
            }
          }
        }
        if (this.customShaderNameResolve) {
          uniforms = uniforms.slice();
          uniformBuffers = uniformBuffers.slice();
          samplers = samplers.slice();
          shaderName = this.customShaderNameResolve(this.name, uniforms, uniformBuffers, samplers, defines, attribs);
        }
        const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper(void 0, true) : this._drawWrapper;
        const previousEffect = drawWrapper?.effect ?? null;
        const previousDefines = drawWrapper?.defines ?? null;
        const join = defines.join("\n");
        let effect = previousEffect;
        if (previousDefines !== join) {
          effect = engine.createEffect(shaderName, {
            attributes: attribs,
            uniformsNames: uniforms,
            uniformBuffersNames: uniformBuffers,
            samplers,
            defines: join,
            fallbacks,
            onCompiled: this.onCompiled,
            onError: this.onError,
            indexParameters: { maxSimultaneousMorphTargets: numInfluencers },
            shaderLanguage: this._options.shaderLanguage,
            extraInitializationsAsync: this._options.extraInitializationsAsync
          }, engine);
          if (storeEffectOnSubMeshes) {
            subMesh.setEffect(effect, join, this._materialContext);
          } else if (drawWrapper) {
            drawWrapper.setEffect(effect, join);
          }
          if (this._onEffectCreatedObservable) {
            OnCreatedEffectParameters.effect = effect;
            OnCreatedEffectParameters.subMesh = subMesh ?? mesh?.subMeshes[0] ?? null;
            this._onEffectCreatedObservable.notifyObservers(OnCreatedEffectParameters);
          }
        }
        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
        if (!effect?.isReady()) {
          return false;
        }
        if (previousEffect !== effect) {
          scene.resetCachedMaterial();
        }
        drawWrapper._wasPreviouslyReady = true;
        return true;
      }
      /**
       * Binds the world matrix to the material
       * @param world defines the world transformation matrix
       * @param effectOverride - If provided, use this effect instead of internal effect
       */
      bindOnlyWorldMatrix(world, effectOverride) {
        const effect = effectOverride ?? this.getEffect();
        if (!effect) {
          return;
        }
        const uniforms = this._options.uniforms;
        if (uniforms.indexOf("world") !== -1) {
          effect.setMatrix("world", world);
        }
        const scene = this.getScene();
        if (uniforms.indexOf("worldView") !== -1) {
          world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);
          effect.setMatrix("worldView", this._cachedWorldViewMatrix);
        }
        if (uniforms.indexOf("worldViewProjection") !== -1) {
          world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);
          effect.setMatrix("worldViewProjection", this._cachedWorldViewProjectionMatrix);
        }
        if (uniforms.indexOf("view") !== -1) {
          effect.setMatrix("view", scene.getViewMatrix());
        }
      }
      /**
       * Binds the submesh to this material by preparing the effect and shader to draw
       * @param world defines the world transformation matrix
       * @param mesh defines the mesh containing the submesh
       * @param subMesh defines the submesh to bind the material to
       */
      bindForSubMesh(world, mesh, subMesh) {
        this.bind(world, mesh, subMesh._drawWrapperOverride?.effect, subMesh);
      }
      /**
       * Binds the material to the mesh
       * @param world defines the world transformation matrix
       * @param mesh defines the mesh to bind the material to
       * @param effectOverride - If provided, use this effect instead of internal effect
       * @param subMesh defines the submesh to bind the material to
       */
      bind(world, mesh, effectOverride, subMesh) {
        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;
        const effect = effectOverride ?? (storeEffectOnSubMeshes ? subMesh.effect : this.getEffect());
        if (!effect) {
          return;
        }
        const scene = this.getScene();
        this._activeEffect = effect;
        this.bindOnlyWorldMatrix(world, effectOverride);
        const uniformBuffers = this._options.uniformBuffers;
        let useSceneUBO = false;
        if (effect && uniformBuffers && uniformBuffers.length > 0 && scene.getEngine().supportsUniformBuffers) {
          for (let i = 0; i < uniformBuffers.length; ++i) {
            const bufferName = uniformBuffers[i];
            switch (bufferName) {
              case "Mesh":
                if (mesh) {
                  mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
                  mesh.transferToEffect(world);
                }
                break;
              case "Scene":
                BindSceneUniformBuffer(effect, scene.getSceneUniformBuffer());
                scene.finalizeSceneUbo();
                useSceneUBO = true;
                break;
            }
          }
        }
        const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(scene, effect, subMesh, mesh.visibility) : scene.getCachedMaterial() !== this;
        if (effect && mustRebind) {
          if (!useSceneUBO && this._options.uniforms.indexOf("view") !== -1) {
            effect.setMatrix("view", scene.getViewMatrix());
          }
          if (!useSceneUBO && this._options.uniforms.indexOf("projection") !== -1) {
            effect.setMatrix("projection", scene.getProjectionMatrix());
          }
          if (!useSceneUBO && this._options.uniforms.indexOf("viewProjection") !== -1) {
            effect.setMatrix("viewProjection", scene.getTransformMatrix());
            if (this._multiview) {
              effect.setMatrix("viewProjectionR", scene._transformMatrixR);
            }
          }
          if (scene.activeCamera && this._options.uniforms.indexOf("cameraPosition") !== -1) {
            effect.setVector3("cameraPosition", scene.activeCamera.globalPosition);
          }
          BindBonesParameters(mesh, effect);
          BindClipPlane(effect, this, scene);
          if (this._vertexPullingMetadata) {
            BindVertexPullingUniforms(effect, this._vertexPullingMetadata);
          }
          if (this._useLogarithmicDepth) {
            BindLogDepth(storeEffectOnSubMeshes ? subMesh.materialDefines : effect.defines, effect, scene);
          }
          if (mesh) {
            BindFogParameters(scene, mesh, effect);
          }
          let name;
          for (name in this._textures) {
            effect.setTexture(name, this._textures[name]);
          }
          for (name in this._internalTextures) {
            effect._bindTexture(name, this._internalTextures[name]);
          }
          for (name in this._textureArrays) {
            effect.setTextureArray(name, this._textureArrays[name]);
          }
          for (name in this._ints) {
            effect.setInt(name, this._ints[name]);
          }
          for (name in this._uints) {
            effect.setUInt(name, this._uints[name]);
          }
          for (name in this._floats) {
            effect.setFloat(name, this._floats[name]);
          }
          for (name in this._floatsArrays) {
            effect.setArray(name, this._floatsArrays[name]);
          }
          for (name in this._colors3) {
            effect.setColor3(name, this._colors3[name]);
          }
          for (name in this._colors3Arrays) {
            effect.setArray3(name, this._colors3Arrays[name]);
          }
          for (name in this._colors4) {
            const color = this._colors4[name];
            effect.setFloat4(name, color.r, color.g, color.b, color.a);
          }
          for (name in this._colors4Arrays) {
            effect.setArray4(name, this._colors4Arrays[name]);
          }
          for (name in this._vectors2) {
            effect.setVector2(name, this._vectors2[name]);
          }
          for (name in this._vectors3) {
            effect.setVector3(name, this._vectors3[name]);
          }
          for (name in this._vectors4) {
            effect.setVector4(name, this._vectors4[name]);
          }
          for (name in this._quaternions) {
            effect.setQuaternion(name, this._quaternions[name]);
          }
          for (name in this._matrices) {
            effect.setMatrix(name, this._matrices[name]);
          }
          for (name in this._matrixArrays) {
            effect.setMatrices(name, this._matrixArrays[name]);
          }
          for (name in this._matrices3x3) {
            effect.setMatrix3x3(name, this._matrices3x3[name]);
          }
          for (name in this._matrices2x2) {
            effect.setMatrix2x2(name, this._matrices2x2[name]);
          }
          for (name in this._vectors2Arrays) {
            effect.setArray2(name, this._vectors2Arrays[name]);
          }
          for (name in this._vectors3Arrays) {
            effect.setArray3(name, this._vectors3Arrays[name]);
          }
          for (name in this._vectors4Arrays) {
            effect.setArray4(name, this._vectors4Arrays[name]);
          }
          for (name in this._quaternionsArrays) {
            effect.setArray4(name, this._quaternionsArrays[name]);
          }
          for (name in this._uniformBuffers) {
            const buffer = this._uniformBuffers[name].getBuffer();
            if (buffer) {
              effect.bindUniformBuffer(buffer, name);
            }
          }
          const engineWebGPU = scene.getEngine();
          const setExternalTexture = engineWebGPU.setExternalTexture;
          if (setExternalTexture) {
            for (name in this._externalTextures) {
              setExternalTexture.call(engineWebGPU, name, this._externalTextures[name]);
            }
          }
          const setTextureSampler = engineWebGPU.setTextureSampler;
          if (setTextureSampler) {
            for (name in this._textureSamplers) {
              setTextureSampler.call(engineWebGPU, name, this._textureSamplers[name]);
            }
          }
          const setStorageBuffer = engineWebGPU.setStorageBuffer;
          if (setStorageBuffer) {
            for (name in this._storageBuffers) {
              setStorageBuffer.call(engineWebGPU, name, this._storageBuffers[name]);
            }
          }
        }
        if (effect && mesh && (mustRebind || !this.isFrozen)) {
          BindMorphTargetParameters(mesh, effect);
          if (mesh.morphTargetManager && mesh.morphTargetManager.isUsingTextureForTargets) {
            mesh.morphTargetManager._bind(effect);
          }
          const bvaManager = mesh.bakedVertexAnimationManager;
          if (bvaManager && bvaManager.isEnabled) {
            const drawWrapper = storeEffectOnSubMeshes ? subMesh._drawWrapper : this._drawWrapper;
            mesh.bakedVertexAnimationManager?.bind(effect, !!drawWrapper._wasPreviouslyUsingInstances);
          }
        }
        this._afterBind(mesh, effect, subMesh);
      }
      /**
       * Gets the active textures from the material
       * @returns an array of textures
       */
      getActiveTextures() {
        const activeTextures = super.getActiveTextures();
        for (const name in this._textures) {
          activeTextures.push(this._textures[name]);
        }
        for (const name in this._textureArrays) {
          const array = this._textureArrays[name];
          for (let index = 0; index < array.length; index++) {
            activeTextures.push(array[index]);
          }
        }
        return activeTextures;
      }
      /**
       * Specifies if the material uses a texture
       * @param texture defines the texture to check against the material
       * @returns a boolean specifying if the material uses the texture
       */
      hasTexture(texture) {
        if (super.hasTexture(texture)) {
          return true;
        }
        for (const name in this._textures) {
          if (this._textures[name] === texture) {
            return true;
          }
        }
        const internalTexture = texture.getInternalTexture();
        for (const name in this._internalTextures) {
          if (this._internalTextures[name] === internalTexture) {
            return true;
          }
        }
        for (const name in this._textureArrays) {
          const array = this._textureArrays[name];
          for (let index = 0; index < array.length; index++) {
            if (array[index] === texture) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Makes a duplicate of the material, and gives it a new name
       * @param name defines the new name for the duplicated material
       * @returns the cloned material
       */
      clone(name) {
        const result = SerializationHelper.Clone(() => new _ShaderMaterial(name, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);
        result.name = name;
        result.id = name;
        if (typeof result._shaderPath === "object") {
          result._shaderPath = { ...result._shaderPath };
        }
        this._options = { ...this._options };
        const keys = Object.keys(this._options);
        for (const propName of keys) {
          const propValue = this._options[propName];
          if (Array.isArray(propValue)) {
            this._options[propName] = propValue.slice(0);
          }
        }
        this.stencil.copyTo(result.stencil);
        for (const key in this._textures) {
          result.setTexture(key, this._textures[key]);
        }
        for (const key in this._internalTextures) {
          result.setInternalTexture(key, this._internalTextures[key]);
        }
        for (const key in this._textureArrays) {
          result.setTextureArray(key, this._textureArrays[key]);
        }
        for (const key in this._externalTextures) {
          result.setExternalTexture(key, this._externalTextures[key]);
        }
        for (const key in this._ints) {
          result.setInt(key, this._ints[key]);
        }
        for (const key in this._uints) {
          result.setUInt(key, this._uints[key]);
        }
        for (const key in this._floats) {
          result.setFloat(key, this._floats[key]);
        }
        for (const key in this._floatsArrays) {
          result.setFloats(key, this._floatsArrays[key]);
        }
        for (const key in this._colors3) {
          result.setColor3(key, this._colors3[key]);
        }
        for (const key in this._colors3Arrays) {
          result._colors3Arrays[key] = this._colors3Arrays[key];
        }
        for (const key in this._colors4) {
          result.setColor4(key, this._colors4[key]);
        }
        for (const key in this._colors4Arrays) {
          result._colors4Arrays[key] = this._colors4Arrays[key];
        }
        for (const key in this._vectors2) {
          result.setVector2(key, this._vectors2[key]);
        }
        for (const key in this._vectors3) {
          result.setVector3(key, this._vectors3[key]);
        }
        for (const key in this._vectors4) {
          result.setVector4(key, this._vectors4[key]);
        }
        for (const key in this._quaternions) {
          result.setQuaternion(key, this._quaternions[key]);
        }
        for (const key in this._quaternionsArrays) {
          result._quaternionsArrays[key] = this._quaternionsArrays[key];
        }
        for (const key in this._matrices) {
          result.setMatrix(key, this._matrices[key]);
        }
        for (const key in this._matrixArrays) {
          result._matrixArrays[key] = this._matrixArrays[key].slice();
        }
        for (const key in this._matrices3x3) {
          result.setMatrix3x3(key, this._matrices3x3[key]);
        }
        for (const key in this._matrices2x2) {
          result.setMatrix2x2(key, this._matrices2x2[key]);
        }
        for (const key in this._vectors2Arrays) {
          result.setArray2(key, this._vectors2Arrays[key]);
        }
        for (const key in this._vectors3Arrays) {
          result.setArray3(key, this._vectors3Arrays[key]);
        }
        for (const key in this._vectors4Arrays) {
          result.setArray4(key, this._vectors4Arrays[key]);
        }
        for (const key in this._uniformBuffers) {
          result.setUniformBuffer(key, this._uniformBuffers[key]);
        }
        for (const key in this._textureSamplers) {
          result.setTextureSampler(key, this._textureSamplers[key]);
        }
        for (const key in this._storageBuffers) {
          result.setStorageBuffer(key, this._storageBuffers[key]);
        }
        return result;
      }
      /**
       * Disposes the material
       * @param forceDisposeEffect specifies if effects should be forcefully disposed
       * @param forceDisposeTextures specifies if textures should be forcefully disposed
       * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
       */
      dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
        if (forceDisposeTextures) {
          let name;
          for (name in this._textures) {
            this._textures[name].dispose();
          }
          for (name in this._internalTextures) {
            this._internalTextures[name].dispose();
          }
          for (name in this._textureArrays) {
            const array = this._textureArrays[name];
            for (let index = 0; index < array.length; index++) {
              array[index].dispose();
            }
          }
        }
        this._textures = {};
        this._internalTextures = {};
        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);
      }
      /**
       * Serializes this material in a JSON representation
       * @returns the serialized material object
       */
      serialize() {
        const serializationObject = SerializationHelper.Serialize(this);
        serializationObject.customType = "BABYLON.ShaderMaterial";
        serializationObject.uniqueId = this.uniqueId;
        serializationObject.options = this._options;
        serializationObject.shaderPath = this._shaderPath;
        serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;
        let name;
        serializationObject.stencil = this.stencil.serialize();
        serializationObject.textures = {};
        for (name in this._textures) {
          serializationObject.textures[name] = this._textures[name].serialize();
        }
        serializationObject.textureArrays = {};
        for (name in this._textureArrays) {
          serializationObject.textureArrays[name] = [];
          const array = this._textureArrays[name];
          for (let index = 0; index < array.length; index++) {
            serializationObject.textureArrays[name].push(array[index].serialize());
          }
        }
        serializationObject.ints = {};
        for (name in this._ints) {
          serializationObject.ints[name] = this._ints[name];
        }
        serializationObject.uints = {};
        for (name in this._uints) {
          serializationObject.uints[name] = this._uints[name];
        }
        serializationObject.floats = {};
        for (name in this._floats) {
          serializationObject.floats[name] = this._floats[name];
        }
        serializationObject.floatsArrays = {};
        for (name in this._floatsArrays) {
          serializationObject.floatsArrays[name] = this._floatsArrays[name];
        }
        serializationObject.colors3 = {};
        for (name in this._colors3) {
          const color3 = this._colors3[name];
          serializationObject.colors3[name] = [color3.r, color3.g, color3.b];
        }
        serializationObject.colors3Arrays = {};
        for (name in this._colors3Arrays) {
          serializationObject.colors3Arrays[name] = this._colors3Arrays[name];
        }
        serializationObject.colors4 = {};
        for (name in this._colors4) {
          const color4 = this._colors4[name];
          serializationObject.colors4[name] = [color4.r, color4.g, color4.b, color4.a];
        }
        serializationObject.colors4Arrays = {};
        for (name in this._colors4Arrays) {
          serializationObject.colors4Arrays[name] = this._colors4Arrays[name];
        }
        serializationObject.vectors2 = {};
        for (name in this._vectors2) {
          const v2 = this._vectors2[name];
          serializationObject.vectors2[name] = [v2.x, v2.y];
        }
        serializationObject.vectors3 = {};
        for (name in this._vectors3) {
          const v3 = this._vectors3[name];
          serializationObject.vectors3[name] = [v3.x, v3.y, v3.z];
        }
        serializationObject.vectors4 = {};
        for (name in this._vectors4) {
          const v4 = this._vectors4[name];
          serializationObject.vectors4[name] = [v4.x, v4.y, v4.z, v4.w];
        }
        serializationObject.quaternions = {};
        for (name in this._quaternions) {
          serializationObject.quaternions[name] = this._quaternions[name].asArray();
        }
        serializationObject.matrices = {};
        for (name in this._matrices) {
          serializationObject.matrices[name] = this._matrices[name].asArray();
        }
        serializationObject.matrixArray = {};
        for (name in this._matrixArrays) {
          serializationObject.matrixArray[name] = this._matrixArrays[name];
        }
        serializationObject.matrices3x3 = {};
        for (name in this._matrices3x3) {
          serializationObject.matrices3x3[name] = this._matrices3x3[name];
        }
        serializationObject.matrices2x2 = {};
        for (name in this._matrices2x2) {
          serializationObject.matrices2x2[name] = this._matrices2x2[name];
        }
        serializationObject.vectors2Arrays = {};
        for (name in this._vectors2Arrays) {
          serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];
        }
        serializationObject.vectors3Arrays = {};
        for (name in this._vectors3Arrays) {
          serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];
        }
        serializationObject.vectors4Arrays = {};
        for (name in this._vectors4Arrays) {
          serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];
        }
        serializationObject.quaternionsArrays = {};
        for (name in this._quaternionsArrays) {
          serializationObject.quaternionsArrays[name] = this._quaternionsArrays[name];
        }
        return serializationObject;
      }
      /**
       * Creates a shader material from parsed shader material data
       * @param source defines the JSON representation of the material
       * @param scene defines the hosting scene
       * @param rootUrl defines the root URL to use to load textures and relative dependencies
       * @returns a new material
       */
      static Parse(source, scene, rootUrl) {
        const material = SerializationHelper.Parse(() => new _ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes), source, scene, rootUrl);
        let name;
        if (source.stencil) {
          material.stencil.parse(source.stencil, scene, rootUrl);
        }
        for (name in source.textures) {
          material.setTexture(name, Texture.Parse(source.textures[name], scene, rootUrl));
        }
        for (name in source.textureArrays) {
          const array = source.textureArrays[name];
          const textureArray = [];
          for (let index = 0; index < array.length; index++) {
            textureArray.push(Texture.Parse(array[index], scene, rootUrl));
          }
          material.setTextureArray(name, textureArray);
        }
        for (name in source.ints) {
          material.setInt(name, source.ints[name]);
        }
        for (name in source.uints) {
          material.setUInt(name, source.uints[name]);
        }
        for (name in source.floats) {
          material.setFloat(name, source.floats[name]);
        }
        for (name in source.floatsArrays) {
          material.setFloats(name, source.floatsArrays[name]);
        }
        for (name in source.colors3) {
          const color = source.colors3[name];
          material.setColor3(name, { r: color[0], g: color[1], b: color[2] });
        }
        for (name in source.colors3Arrays) {
          const colors = source.colors3Arrays[name].reduce((arr, num, i) => {
            if (i % 3 === 0) {
              arr.push([num]);
            } else {
              arr[arr.length - 1].push(num);
            }
            return arr;
          }, []).map((color) => ({ r: color[0], g: color[1], b: color[2] }));
          material.setColor3Array(name, colors);
        }
        for (name in source.colors4) {
          const color = source.colors4[name];
          material.setColor4(name, { r: color[0], g: color[1], b: color[2], a: color[3] });
        }
        for (name in source.colors4Arrays) {
          const colors = source.colors4Arrays[name].reduce((arr, num, i) => {
            if (i % 4 === 0) {
              arr.push([num]);
            } else {
              arr[arr.length - 1].push(num);
            }
            return arr;
          }, []).map((color) => ({ r: color[0], g: color[1], b: color[2], a: color[3] }));
          material.setColor4Array(name, colors);
        }
        for (name in source.vectors2) {
          const vector = source.vectors2[name];
          material.setVector2(name, { x: vector[0], y: vector[1] });
        }
        for (name in source.vectors3) {
          const vector = source.vectors3[name];
          material.setVector3(name, { x: vector[0], y: vector[1], z: vector[2] });
        }
        for (name in source.vectors4) {
          const vector = source.vectors4[name];
          material.setVector4(name, { x: vector[0], y: vector[1], z: vector[2], w: vector[3] });
        }
        for (name in source.quaternions) {
          material.setQuaternion(name, Quaternion.FromArray(source.quaternions[name]));
        }
        for (name in source.matrices) {
          material.setMatrix(name, Matrix.FromArray(source.matrices[name]));
        }
        for (name in source.matrixArray) {
          material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);
        }
        for (name in source.matrices3x3) {
          material.setMatrix3x3(name, source.matrices3x3[name]);
        }
        for (name in source.matrices2x2) {
          material.setMatrix2x2(name, source.matrices2x2[name]);
        }
        for (name in source.vectors2Arrays) {
          material.setArray2(name, source.vectors2Arrays[name]);
        }
        for (name in source.vectors3Arrays) {
          material.setArray3(name, source.vectors3Arrays[name]);
        }
        for (name in source.vectors4Arrays) {
          material.setArray4(name, source.vectors4Arrays[name]);
        }
        for (name in source.quaternionsArrays) {
          material.setArray4(name, source.quaternionsArrays[name]);
        }
        return material;
      }
      /**
       * Creates a new ShaderMaterial from a snippet saved in a remote file
       * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)
       * @param url defines the url to load from
       * @param scene defines the hosting scene
       * @param rootUrl defines the root URL to use to load textures and relative dependencies
       * @returns a promise that will resolve to the new ShaderMaterial
       */
      static async ParseFromFileAsync(name, url, scene, rootUrl = "") {
        return await new Promise((resolve, reject) => {
          const request = new WebRequest();
          request.addEventListener("readystatechange", () => {
            if (request.readyState == 4) {
              if (request.status == 200) {
                const serializationObject = JSON.parse(request.responseText);
                const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
                if (name) {
                  output.name = name;
                }
                resolve(output);
              } else {
                reject("Unable to load the ShaderMaterial");
              }
            }
          });
          request.open("GET", url);
          request.send();
        });
      }
      /**
       * Creates a ShaderMaterial from a snippet saved by the Inspector
       * @param snippetId defines the snippet to load
       * @param scene defines the hosting scene
       * @param rootUrl defines the root URL to use to load textures and relative dependencies
       * @returns a promise that will resolve to the new ShaderMaterial
       */
      static async ParseFromSnippetAsync(snippetId, scene, rootUrl = "") {
        return await new Promise((resolve, reject) => {
          const request = new WebRequest();
          request.addEventListener("readystatechange", () => {
            if (request.readyState == 4) {
              if (request.status == 200) {
                const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
                const serializationObject = JSON.parse(snippet.shaderMaterial);
                const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
                output.snippetId = snippetId;
                resolve(output);
              } else {
                reject("Unable to load the snippet " + snippetId);
              }
            }
          });
          request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
          request.send();
        });
      }
    };
    ShaderMaterial.SnippetUrl = `https://snippet.babylonjs.com`;
    ShaderMaterial.CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;
    RegisterClass("BABYLON.ShaderMaterial", ShaderMaterial);
  }
});

// node_modules/@babylonjs/core/Meshes/linesMesh.js
var LinesMesh, InstancedLinesMesh;
var init_linesMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/linesMesh.js"() {
    init_math_color();
    init_buffer();
    init_mesh();
    init_instancedMesh();
    init_material();
    init_shaderMaterial();
    Mesh._LinesMeshParser = (parsedMesh, scene) => {
      return LinesMesh.Parse(parsedMesh, scene);
    };
    LinesMesh = class _LinesMesh extends Mesh {
      _isShaderMaterial(shader) {
        if (!shader) {
          return false;
        }
        return shader.getClassName() === "ShaderMaterial";
      }
      /**
       * Creates a new LinesMesh
       * @param name defines the name
       * @param scene defines the hosting scene
       * @param parent defines the parent mesh if any
       * @param source defines the optional source LinesMesh used to clone data from
       * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.
       * When false, achieved by calling a clone(), also passing False.
       * This will make creation of children, recursive.
       * @param useVertexColor defines if this LinesMesh supports vertex color
       * @param useVertexAlpha defines if this LinesMesh supports vertex alpha
       * @param material material to use to draw the line. If not provided, will create a new one
       */
      constructor(name, scene = null, parent = null, source = null, doNotCloneChildren, useVertexColor, useVertexAlpha, material) {
        super(name, scene, parent, source, doNotCloneChildren);
        this.useVertexColor = useVertexColor;
        this.useVertexAlpha = useVertexAlpha;
        this.color = new Color3(1, 1, 1);
        this.alpha = 1;
        this._shaderLanguage = 0;
        this._ownsMaterial = false;
        if (source) {
          this.color = source.color.clone();
          this.alpha = source.alpha;
          this.useVertexColor = source.useVertexColor;
          this.useVertexAlpha = source.useVertexAlpha;
        }
        this.intersectionThreshold = 0.1;
        const defines = [];
        const options = {
          attributes: [VertexBuffer.PositionKind],
          uniforms: ["world", "viewProjection"],
          needAlphaBlending: true,
          defines,
          useClipPlane: null,
          shaderLanguage: 0
        };
        if (!this.useVertexAlpha) {
          options.needAlphaBlending = false;
        } else {
          options.defines.push("#define VERTEXALPHA");
        }
        if (!this.useVertexColor) {
          options.uniforms.push("color");
          this._color4 = new Color4();
        } else {
          options.defines.push("#define VERTEXCOLOR");
          options.attributes.push(VertexBuffer.ColorKind);
        }
        if (material) {
          this.material = material;
        } else {
          const engine = this.getScene().getEngine();
          if (engine.isWebGPU && !_LinesMesh.ForceGLSL) {
            this._shaderLanguage = 1;
          }
          options.shaderLanguage = this._shaderLanguage;
          options.extraInitializationsAsync = async () => {
            if (this._shaderLanguage === 1) {
              await Promise.all([import("./color.vertex-HMRNWAAI.js"), import("./color.fragment-EU75OYY4.js")]);
            } else {
              await Promise.all([import("./color.vertex-4CSFYBWD.js"), import("./color.fragment-4MNQCN2U.js")]);
            }
          };
          const material2 = new ShaderMaterial("colorShader", this.getScene(), "color", options, false);
          material2.doNotSerialize = true;
          this._ownsMaterial = true;
          this._setInternalMaterial(material2);
        }
      }
      /**
       * @returns the string "LineMesh"
       */
      getClassName() {
        return "LinesMesh";
      }
      /**
       * @internal
       */
      get material() {
        return this._internalAbstractMeshDataInfo._material;
      }
      /**
       * @internal
       */
      set material(value) {
        const currentMaterial = this.material;
        if (currentMaterial === value) {
          return;
        }
        const shouldDispose = currentMaterial && this._ownsMaterial;
        this._ownsMaterial = false;
        this._setInternalMaterial(value);
        if (shouldDispose) {
          currentMaterial?.dispose();
        }
      }
      _setInternalMaterial(material) {
        this._setMaterial(material);
        if (this.material) {
          this.material.fillMode = Material.LineListDrawMode;
          this.material.disableLighting = true;
        }
      }
      /**
       * @internal
       */
      get checkCollisions() {
        return false;
      }
      set checkCollisions(value) {
      }
      /**
       * @internal
       */
      _bind(_subMesh, colorEffect) {
        if (!this._geometry) {
          return this;
        }
        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();
        if (!this._userInstancedBuffersStorage || this.hasThinInstances) {
          this._geometry._bind(colorEffect, indexToBind);
        } else {
          this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);
        }
        if (!this.useVertexColor && this._isShaderMaterial(this.material)) {
          const { r, g, b } = this.color;
          this._color4.set(r, g, b, this.alpha);
          this.material.setColor4("color", this._color4);
        }
        return this;
      }
      /**
       * @internal
       */
      _draw(subMesh, fillMode, instancesCount) {
        if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
          return this;
        }
        const engine = this.getScene().getEngine();
        if (this._unIndexed) {
          engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);
        } else {
          engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);
        }
        return this;
      }
      /**
       * Disposes of the line mesh (this disposes of the automatically created material if not instructed otherwise).
       * @param doNotRecurse If children should be disposed
       * @param disposeMaterialAndTextures This parameter is used to force disposing the material in case it is not the default one
       * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material might be disposed)
       */
      dispose(doNotRecurse, disposeMaterialAndTextures = false, doNotDisposeMaterial) {
        if (!doNotDisposeMaterial) {
          if (this._ownsMaterial) {
            this.material?.dispose(false, false, true);
          } else if (disposeMaterialAndTextures) {
            this.material?.dispose(false, false, true);
          }
        }
        super.dispose(doNotRecurse);
      }
      /**
       * Returns a new LineMesh object cloned from the current one.
       * @param name defines the cloned mesh name
       * @param newParent defines the new mesh parent
       * @param doNotCloneChildren if set to true, none of the mesh children are cloned (false by default)
       * @returns the new mesh
       */
      clone(name, newParent = null, doNotCloneChildren) {
        if (newParent && newParent._addToSceneRootNodes === void 0) {
          const createOptions = newParent;
          createOptions.source = this;
          return new _LinesMesh(name, this.getScene(), createOptions.parent, createOptions.source, createOptions.doNotCloneChildren);
        }
        return new _LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);
      }
      /**
       * Creates a new InstancedLinesMesh object from the mesh model.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances
       * @param name defines the name of the new instance
       * @returns a new InstancedLinesMesh
       */
      createInstance(name) {
        const instance = new InstancedLinesMesh(name, this);
        if (this.instancedBuffers) {
          instance.instancedBuffers = {};
          for (const key in this.instancedBuffers) {
            instance.instancedBuffers[key] = this.instancedBuffers[key];
          }
        }
        return instance;
      }
      /**
       * Serializes this ground mesh
       * @param serializationObject object to write serialization to
       */
      serialize(serializationObject) {
        super.serialize(serializationObject);
        serializationObject.color = this.color.asArray();
        serializationObject.alpha = this.alpha;
      }
      /**
       * Parses a serialized ground mesh
       * @param parsedMesh the serialized mesh
       * @param scene the scene to create the ground mesh in
       * @returns the created ground mesh
       */
      static Parse(parsedMesh, scene) {
        const result = new _LinesMesh(parsedMesh.name, scene);
        result.color = Color3.FromArray(parsedMesh.color);
        result.alpha = parsedMesh.alpha;
        return result;
      }
    };
    LinesMesh.ForceGLSL = false;
    InstancedLinesMesh = class extends InstancedMesh {
      constructor(name, source) {
        super(name, source);
        this.intersectionThreshold = source.intersectionThreshold;
      }
      /**
       * @returns the string "InstancedLinesMesh".
       */
      getClassName() {
        return "InstancedLinesMesh";
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/polygonMesh.js
var IndexedVector2, PolygonPoints, Polygon, PolygonMeshBuilder;
var init_polygonMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/polygonMesh.js"() {
    init_logger();
    init_math_vector();
    init_buffer();
    init_mesh();
    init_mesh_vertexData();
    init_math_path();
    init_math_constants();
    init_engineStore();
    IndexedVector2 = class extends Vector2 {
      constructor(original, index) {
        super(original.x, original.y);
        this.index = index;
      }
    };
    PolygonPoints = class {
      constructor() {
        this.elements = [];
      }
      add(originalPoints) {
        const result = [];
        for (const point of originalPoints) {
          const newPoint = new IndexedVector2(point, this.elements.length);
          result.push(newPoint);
          this.elements.push(newPoint);
        }
        return result;
      }
      computeBounds() {
        const lmin = new Vector2(this.elements[0].x, this.elements[0].y);
        const lmax = new Vector2(this.elements[0].x, this.elements[0].y);
        for (const point of this.elements) {
          if (point.x < lmin.x) {
            lmin.x = point.x;
          } else if (point.x > lmax.x) {
            lmax.x = point.x;
          }
          if (point.y < lmin.y) {
            lmin.y = point.y;
          } else if (point.y > lmax.y) {
            lmax.y = point.y;
          }
        }
        return {
          min: lmin,
          max: lmax,
          width: lmax.x - lmin.x,
          height: lmax.y - lmin.y
        };
      }
    };
    Polygon = class {
      /**
       * Creates a rectangle
       * @param xmin bottom X coord
       * @param ymin bottom Y coord
       * @param xmax top X coord
       * @param ymax top Y coord
       * @returns points that make the resulting rectangle
       */
      static Rectangle(xmin, ymin, xmax, ymax) {
        return [new Vector2(xmin, ymin), new Vector2(xmax, ymin), new Vector2(xmax, ymax), new Vector2(xmin, ymax)];
      }
      /**
       * Creates a circle
       * @param radius radius of circle
       * @param cx scale in x
       * @param cy scale in y
       * @param numberOfSides number of sides that make up the circle
       * @returns points that make the resulting circle
       */
      static Circle(radius, cx = 0, cy = 0, numberOfSides = 32) {
        const result = [];
        let angle = 0;
        const increment = Math.PI * 2 / numberOfSides;
        for (let i = 0; i < numberOfSides; i++) {
          result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));
          angle -= increment;
        }
        return result;
      }
      /**
       * Creates a polygon from input string
       * @param input Input polygon data
       * @returns the parsed points
       */
      static Parse(input) {
        const floats = input.split(/[^-+eE.\d]+/).map(parseFloat).filter((val) => !isNaN(val));
        let i;
        const result = [];
        for (i = 0; i < (floats.length & 2147483646); i += 2) {
          result.push(new Vector2(floats[i], floats[i + 1]));
        }
        return result;
      }
      /**
       * Starts building a polygon from x and y coordinates
       * @param x x coordinate
       * @param y y coordinate
       * @returns the started path2
       */
      static StartingAt(x, y) {
        return Path2.StartingAt(x, y);
      }
    };
    PolygonMeshBuilder = class {
      _addToepoint(points) {
        for (const p of points) {
          this._epoints.push(p.x, p.y);
        }
      }
      /**
       * Creates a PolygonMeshBuilder
       * @param name name of the builder
       * @param contours Path of the polygon
       * @param scene scene to add to when creating the mesh
       * @param earcutInjection can be used to inject your own earcut reference
       */
      constructor(name, contours, scene, earcutInjection = earcut) {
        this._points = new PolygonPoints();
        this._outlinepoints = new PolygonPoints();
        this._holes = new Array();
        this._epoints = new Array();
        this._eholes = new Array();
        this.bjsEarcut = earcutInjection;
        this._name = name;
        this._scene = scene || EngineStore.LastCreatedScene;
        let points;
        if (contours instanceof Path2) {
          points = contours.getPoints();
        } else {
          points = contours;
        }
        this._addToepoint(points);
        this._points.add(points);
        this._outlinepoints.add(points);
        if (typeof this.bjsEarcut === "undefined") {
          Logger.Warn("Earcut was not found, the polygon will not be built.");
        }
      }
      /**
       * Adds a hole within the polygon
       * @param hole Array of points defining the hole
       * @returns this
       */
      addHole(hole) {
        this._points.add(hole);
        const holepoints = new PolygonPoints();
        holepoints.add(hole);
        this._holes.push(holepoints);
        this._eholes.push(this._epoints.length / 2);
        this._addToepoint(hole);
        return this;
      }
      /**
       * Creates the polygon
       * @param updatable If the mesh should be updatable
       * @param depth The depth of the mesh created
       * @param smoothingThreshold Dot product threshold for smoothed normals
       * @returns the created mesh
       */
      build(updatable = false, depth = 0, smoothingThreshold = 2) {
        const result = new Mesh(this._name, this._scene);
        const vertexData = this.buildVertexData(depth, smoothingThreshold);
        result.setVerticesData(VertexBuffer.PositionKind, vertexData.positions, updatable);
        result.setVerticesData(VertexBuffer.NormalKind, vertexData.normals, updatable);
        result.setVerticesData(VertexBuffer.UVKind, vertexData.uvs, updatable);
        result.setIndices(vertexData.indices);
        return result;
      }
      /**
       * Creates the polygon
       * @param depth The depth of the mesh created
       * @param smoothingThreshold Dot product threshold for smoothed normals
       * @returns the created VertexData
       */
      buildVertexData(depth = 0, smoothingThreshold = 2) {
        const result = new VertexData();
        const normals = [];
        const positions = [];
        const uvs = [];
        const bounds = this._points.computeBounds();
        for (const p of this._points.elements) {
          normals.push(0, 1, 0);
          positions.push(p.x, 0, p.y);
          uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);
        }
        const indices = [];
        const res = this.bjsEarcut(this._epoints, this._eholes, 2);
        for (let i = 0; i < res.length; i++) {
          indices.push(res[i]);
        }
        if (depth > 0) {
          const positionscount = positions.length / 3;
          for (const p of this._points.elements) {
            normals.push(0, -1, 0);
            positions.push(p.x, -depth, p.y);
            uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);
          }
          const totalCount = indices.length;
          for (let i = 0; i < totalCount; i += 3) {
            const i0 = indices[i + 0];
            const i1 = indices[i + 1];
            const i2 = indices[i + 2];
            indices.push(i2 + positionscount);
            indices.push(i1 + positionscount);
            indices.push(i0 + positionscount);
          }
          this._addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false, smoothingThreshold);
          for (const hole of this._holes) {
            this._addSide(positions, normals, uvs, indices, bounds, hole, depth, true, smoothingThreshold);
          }
        }
        result.indices = indices;
        result.positions = positions;
        result.normals = normals;
        result.uvs = uvs;
        return result;
      }
      /**
       * Adds a side to the polygon
       * @param positions points that make the polygon
       * @param normals normals of the polygon
       * @param uvs uvs of the polygon
       * @param indices indices of the polygon
       * @param bounds bounds of the polygon
       * @param points points of the polygon
       * @param depth depth of the polygon
       * @param flip flip of the polygon
       * @param smoothingThreshold
       */
      _addSide(positions, normals, uvs, indices, bounds, points, depth, flip, smoothingThreshold) {
        let startIndex = positions.length / 3;
        let ulength = 0;
        for (let i = 0; i < points.elements.length; i++) {
          const p = points.elements[i];
          const p1 = points.elements[(i + 1) % points.elements.length];
          positions.push(p.x, 0, p.y);
          positions.push(p.x, -depth, p.y);
          positions.push(p1.x, 0, p1.y);
          positions.push(p1.x, -depth, p1.y);
          const p0 = points.elements[(i + points.elements.length - 1) % points.elements.length];
          const p2 = points.elements[(i + 2) % points.elements.length];
          let vc = new Vector3(-(p1.y - p.y), 0, p1.x - p.x);
          let vp = new Vector3(-(p.y - p0.y), 0, p.x - p0.x);
          let vn = new Vector3(-(p2.y - p1.y), 0, p2.x - p1.x);
          if (!flip) {
            vc = vc.scale(-1);
            vp = vp.scale(-1);
            vn = vn.scale(-1);
          }
          const vcNorm = vc.normalizeToNew();
          let vpNorm = vp.normalizeToNew();
          let vnNorm = vn.normalizeToNew();
          const dotp = Vector3.Dot(vpNorm, vcNorm);
          if (dotp > smoothingThreshold) {
            if (dotp < Epsilon - 1) {
              vpNorm = new Vector3(p.x, 0, p.y).subtract(new Vector3(p1.x, 0, p1.y)).normalize();
            } else {
              vpNorm = vp.add(vc).normalize();
            }
          } else {
            vpNorm = vcNorm;
          }
          const dotn = Vector3.Dot(vn, vc);
          if (dotn > smoothingThreshold) {
            if (dotn < Epsilon - 1) {
              vnNorm = new Vector3(p1.x, 0, p1.y).subtract(new Vector3(p.x, 0, p.y)).normalize();
            } else {
              vnNorm = vn.add(vc).normalize();
            }
          } else {
            vnNorm = vcNorm;
          }
          uvs.push(ulength / bounds.width, 0);
          uvs.push(ulength / bounds.width, 1);
          ulength += vc.length();
          uvs.push(ulength / bounds.width, 0);
          uvs.push(ulength / bounds.width, 1);
          normals.push(vpNorm.x, vpNorm.y, vpNorm.z);
          normals.push(vpNorm.x, vpNorm.y, vpNorm.z);
          normals.push(vnNorm.x, vnNorm.y, vnNorm.z);
          normals.push(vnNorm.x, vnNorm.y, vnNorm.z);
          if (!flip) {
            indices.push(startIndex);
            indices.push(startIndex + 1);
            indices.push(startIndex + 2);
            indices.push(startIndex + 1);
            indices.push(startIndex + 3);
            indices.push(startIndex + 2);
          } else {
            indices.push(startIndex);
            indices.push(startIndex + 2);
            indices.push(startIndex + 1);
            indices.push(startIndex + 1);
            indices.push(startIndex + 2);
            indices.push(startIndex + 3);
          }
          startIndex += 4;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/polygonBuilder.js
function CreatePolygonVertexData(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrp) {
  const faceUV = fUV || new Array(3);
  const faceColors = fColors;
  const colors = [];
  const wrap = wrp || false;
  for (let f = 0; f < 3; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  const positions = polygon.getVerticesData(VertexBuffer.PositionKind);
  const normals = polygon.getVerticesData(VertexBuffer.NormalKind);
  const uvs = polygon.getVerticesData(VertexBuffer.UVKind);
  const indices = polygon.getIndices();
  const startIndex = positions.length / 9;
  let disp = 0;
  let distX = 0;
  let distZ = 0;
  let dist = 0;
  let totalLen = 0;
  const cumulate = [0];
  if (wrap) {
    for (let idx2 = startIndex; idx2 < positions.length / 3; idx2 += 4) {
      distX = positions[3 * (idx2 + 2)] - positions[3 * idx2];
      distZ = positions[3 * (idx2 + 2) + 2] - positions[3 * idx2 + 2];
      dist = Math.sqrt(distX * distX + distZ * distZ);
      totalLen += dist;
      cumulate.push(totalLen);
    }
  }
  let idx = 0;
  let face = 0;
  for (let index = 0; index < normals.length; index += 3) {
    if (Math.abs(normals[index + 1]) < 1e-3) {
      face = 1;
    }
    if (Math.abs(normals[index + 1] - 1) < 1e-3) {
      face = 0;
    }
    if (Math.abs(normals[index + 1] + 1) < 1e-3) {
      face = 2;
    }
    idx = index / 3;
    if (face === 1) {
      disp = idx - startIndex;
      if (disp % 4 < 1.5) {
        if (wrap) {
          uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4)] / totalLen;
        } else {
          uvs[2 * idx] = faceUV[face].x;
        }
      } else {
        if (wrap) {
          uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4) + 1] / totalLen;
        } else {
          uvs[2 * idx] = faceUV[face].z;
        }
      }
      if (disp % 2 === 0) {
        uvs[2 * idx + 1] = useOpenGLOrientationForUV ? 1 - faceUV[face].w : faceUV[face].w;
      } else {
        uvs[2 * idx + 1] = useOpenGLOrientationForUV ? 1 - faceUV[face].y : faceUV[face].y;
      }
    } else {
      uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;
      uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;
      if (useOpenGLOrientationForUV) {
        uvs[2 * idx + 1] = 1 - uvs[2 * idx + 1];
      }
    }
    if (faceColors) {
      colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
}
function CreatePolygon(name, options, scene = null, earcutInjection = earcut) {
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  const shape = options.shape;
  const holes = options.holes || [];
  const depth = options.depth || 0;
  const smoothingThreshold = options.smoothingThreshold || 2;
  const contours = [];
  let hole = [];
  for (let i = 0; i < shape.length; i++) {
    contours[i] = new Vector2(shape[i].x, shape[i].z);
  }
  const epsilon = 1e-8;
  if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {
    contours.pop();
  }
  const polygonTriangulation = new PolygonMeshBuilder(name, contours, scene || EngineStore.LastCreatedScene, earcutInjection);
  for (let hNb = 0; hNb < holes.length; hNb++) {
    hole = [];
    for (let hPoint = 0; hPoint < holes[hNb].length; hPoint++) {
      hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));
    }
    polygonTriangulation.addHole(hole);
  }
  const polygon = polygonTriangulation.build(false, depth, smoothingThreshold);
  polygon._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreatePolygonVertexData(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs, options.wrap);
  vertexData.applyToMesh(polygon, options.updatable);
  return polygon;
}
function ExtrudePolygon(name, options, scene = null, earcutInjection = earcut) {
  return CreatePolygon(name, options, scene, earcutInjection);
}
var PolygonBuilder;
var init_polygonBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/polygonBuilder.js"() {
    init_math_vector();
    init_math_color();
    init_mesh();
    init_mesh_vertexData();
    init_polygonMesh();
    init_buffer();
    init_engineStore();
    init_compatibilityOptions();
    PolygonBuilder = {
      ExtrudePolygon,
      CreatePolygon
    };
    VertexData.CreatePolygon = CreatePolygonVertexData;
    Mesh.CreatePolygon = (name, shape, scene, holes, updatable, sideOrientation, earcutInjection = earcut) => {
      const options = {
        shape,
        holes,
        updatable,
        sideOrientation
      };
      return CreatePolygon(name, options, scene, earcutInjection);
    };
    Mesh.ExtrudePolygon = (name, shape, depth, scene, holes, updatable, sideOrientation, earcutInjection = earcut) => {
      const options = {
        shape,
        holes,
        depth,
        updatable,
        sideOrientation
      };
      return ExtrudePolygon(name, options, scene, earcutInjection);
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/textBuilder.js
function CreateShapePath(char, scale, offsetX, offsetY, resolution, fontData) {
  const glyph = fontData.glyphs[char] || fontData.glyphs["?"];
  if (!glyph) {
    return null;
  }
  const shapePath = new ShapePath(resolution);
  if (glyph.o) {
    const outline = glyph.o.split(" ");
    for (let i = 0, l = outline.length; i < l; ) {
      const action = outline[i++];
      switch (action) {
        case "m": {
          const x = parseInt(outline[i++]) * scale + offsetX;
          const y = parseInt(outline[i++]) * scale + offsetY;
          shapePath.moveTo(x, y);
          break;
        }
        case "l": {
          const x = parseInt(outline[i++]) * scale + offsetX;
          const y = parseInt(outline[i++]) * scale + offsetY;
          shapePath.lineTo(x, y);
          break;
        }
        case "q": {
          const cpx = parseInt(outline[i++]) * scale + offsetX;
          const cpy = parseInt(outline[i++]) * scale + offsetY;
          const cpx1 = parseInt(outline[i++]) * scale + offsetX;
          const cpy1 = parseInt(outline[i++]) * scale + offsetY;
          shapePath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        }
        case "b": {
          const cpx = parseInt(outline[i++]) * scale + offsetX;
          const cpy = parseInt(outline[i++]) * scale + offsetY;
          const cpx1 = parseInt(outline[i++]) * scale + offsetX;
          const cpy1 = parseInt(outline[i++]) * scale + offsetY;
          const cpx2 = parseInt(outline[i++]) * scale + offsetX;
          const cpy2 = parseInt(outline[i++]) * scale + offsetY;
          shapePath.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
        }
      }
    }
  }
  shapePath.extractHoles();
  return { offsetX: glyph.ha * scale, shapePath };
}
function CreateTextShapePaths(text, size, resolution, fontData) {
  const chars = Array.from(text);
  const scale = size / fontData.resolution;
  const lineHeight = (fontData.boundingBox.yMax - fontData.boundingBox.yMin + fontData.underlineThickness) * scale;
  const shapePaths = [];
  let offsetX = 0, offsetY = 0;
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= lineHeight;
    } else {
      const ret = CreateShapePath(char, scale, offsetX, offsetY, resolution, fontData);
      if (ret) {
        offsetX += ret.offsetX;
        shapePaths.push(ret.shapePath);
      }
    }
  }
  return shapePaths;
}
function CreateText(name, text, fontData, options = {
  size: 50,
  resolution: 8,
  depth: 1
}, scene = null, earcutInjection = earcut) {
  const shapePaths = CreateTextShapePaths(text, options.size || 50, options.resolution || 8, fontData);
  const meshes = [];
  let letterIndex = 0;
  for (const shapePath of shapePaths) {
    if (!shapePath.paths.length) {
      continue;
    }
    const holes = shapePath.holes.slice();
    for (const path of shapePath.paths) {
      const holeVectors = [];
      const shapeVectors = [];
      const points = path.getPoints();
      for (const point of points) {
        shapeVectors.push(new Vector3(point.x, 0, point.y));
      }
      const localHolesCopy = holes.slice();
      for (const hole of localHolesCopy) {
        const points2 = hole.getPoints();
        let found = false;
        for (const point of points2) {
          if (path.isPointInside(point)) {
            found = true;
            break;
          }
        }
        if (!found) {
          continue;
        }
        const holePoints = [];
        for (const point of points2) {
          holePoints.push(new Vector3(point.x, 0, point.y));
        }
        holeVectors.push(holePoints);
        holes.splice(holes.indexOf(hole), 1);
      }
      if (!holeVectors.length && holes.length) {
        for (const hole of holes) {
          const points2 = hole.getPoints();
          const holePoints = [];
          for (const point of points2) {
            holePoints.push(new Vector3(point.x, 0, point.y));
          }
          holeVectors.push(holePoints);
        }
      }
      const mesh = ExtrudePolygon(name, {
        shape: shapeVectors,
        holes: holeVectors.length ? holeVectors : void 0,
        depth: options.depth || 1,
        faceUV: options.faceUV || options.perLetterFaceUV?.(letterIndex),
        faceColors: options.faceColors || options.perLetterFaceColors?.(letterIndex),
        sideOrientation: Mesh._GetDefaultSideOrientation(options.sideOrientation || Mesh.DOUBLESIDE)
      }, scene, earcutInjection);
      meshes.push(mesh);
      letterIndex++;
    }
  }
  const newMesh = Mesh.MergeMeshes(meshes, true, true);
  if (newMesh) {
    const bbox = newMesh.getBoundingInfo().boundingBox;
    newMesh.position.x += -(bbox.minimumWorld.x + bbox.maximumWorld.x) / 2;
    newMesh.position.y += -(bbox.minimumWorld.y + bbox.maximumWorld.y) / 2;
    newMesh.position.z += -(bbox.minimumWorld.z + bbox.maximumWorld.z) / 2 + bbox.extendSize.z;
    newMesh.name = name;
    const pivot = new TransformNode("pivot", scene);
    pivot.rotation.x = -Math.PI / 2;
    newMesh.parent = pivot;
    newMesh.bakeCurrentTransformIntoVertices();
    newMesh.parent = null;
    pivot.dispose();
  }
  return newMesh;
}
var ShapePath;
var init_textBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/textBuilder.js"() {
    init_math_path();
    init_math_vector();
    init_mesh();
    init_transformNode();
    init_polygonBuilder();
    ShapePath = class {
      /** Create the ShapePath used to support glyphs
       * @param resolution defines the resolution used to determine the number of points per curve (default is 4)
       */
      constructor(resolution) {
        this._paths = [];
        this._tempPaths = [];
        this._holes = [];
        this._resolution = resolution;
      }
      /** Move the virtual cursor to a coordinate
       * @param x defines the x coordinate
       * @param y defines the y coordinate
       */
      moveTo(x, y) {
        this._currentPath = new Path2(x, y);
        this._tempPaths.push(this._currentPath);
      }
      /** Draw a line from the virtual cursor to a given coordinate
       * @param x defines the x coordinate
       * @param y defines the y coordinate
       */
      lineTo(x, y) {
        this._currentPath.addLineTo(x, y);
      }
      /** Create a quadratic curve from the virtual cursor to a given coordinate
       * @param cpx defines the x coordinate of the control point
       * @param cpy defines the y coordinate of the control point
       * @param x defines the x coordinate of the end point
       * @param y defines the y coordinate of the end point
       */
      quadraticCurveTo(cpx, cpy, x, y) {
        this._currentPath.addQuadraticCurveTo(cpx, cpy, x, y, this._resolution);
      }
      /**
       * Create a bezier curve from the virtual cursor to a given coordinate
       * @param cpx1 defines the x coordinate of the first control point
       * @param cpy1 defines the y coordinate of the first control point
       * @param cpx2 defines the x coordinate of the second control point
       * @param cpy2 defines the y coordinate of the second control point
       * @param x defines the x coordinate of the end point
       * @param y defines the y coordinate of the end point
       */
      bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y) {
        this._currentPath.addBezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y, this._resolution);
      }
      /** Extract holes based on CW / CCW */
      extractHoles() {
        for (const path of this._tempPaths) {
          if (path.area() > 0) {
            this._holes.push(path);
          } else {
            this._paths.push(path);
          }
        }
        if (!this._paths.length && this._holes.length) {
          const temp = this._holes;
          this._holes = this._paths;
          this._paths = temp;
        }
        this._tempPaths.length = 0;
      }
      /** Gets the list of paths */
      get paths() {
        return this._paths;
      }
      /** Gets the list of holes */
      get holes() {
        return this._holes;
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/constants.js
var Constants;
var init_constants = __esm({
  "node_modules/@babylonjs/core/Engines/constants.js"() {
    Constants = class {
    };
    Constants.AUTOSAMPLERSUFFIX = "Sampler";
    Constants.DISABLEUA = "#define DISABLE_UNIFORMITY_ANALYSIS";
    Constants.ALPHA_DISABLE = 0;
    Constants.ALPHA_ADD = 1;
    Constants.ALPHA_COMBINE = 2;
    Constants.ALPHA_SUBTRACT = 3;
    Constants.ALPHA_MULTIPLY = 4;
    Constants.ALPHA_MAXIMIZED = 5;
    Constants.ALPHA_ONEONE = 6;
    Constants.ALPHA_PREMULTIPLIED = 7;
    Constants.ALPHA_PREMULTIPLIED_PORTERDUFF = 8;
    Constants.ALPHA_INTERPOLATE = 9;
    Constants.ALPHA_SCREENMODE = 10;
    Constants.ALPHA_ONEONE_ONEONE = 11;
    Constants.ALPHA_ALPHATOCOLOR = 12;
    Constants.ALPHA_REVERSEONEMINUS = 13;
    Constants.ALPHA_SRC_DSTONEMINUSSRCALPHA = 14;
    Constants.ALPHA_ONEONE_ONEZERO = 15;
    Constants.ALPHA_EXCLUSION = 16;
    Constants.ALPHA_LAYER_ACCUMULATE = 17;
    Constants.ALPHA_MIN = 18;
    Constants.ALPHA_MAX = 19;
    Constants.ALPHA_DUAL_SRC0_ADD_SRC1xDST = 20;
    Constants.ALPHA_EQUATION_ADD = 0;
    Constants.ALPHA_EQUATION_SUBSTRACT = 1;
    Constants.ALPHA_EQUATION_REVERSE_SUBTRACT = 2;
    Constants.ALPHA_EQUATION_MAX = 3;
    Constants.ALPHA_EQUATION_MIN = 4;
    Constants.ALPHA_EQUATION_DARKEN = 5;
    Constants.DELAYLOADSTATE_NONE = 0;
    Constants.DELAYLOADSTATE_LOADED = 1;
    Constants.DELAYLOADSTATE_LOADING = 2;
    Constants.DELAYLOADSTATE_NOTLOADED = 4;
    Constants.NEVER = 512;
    Constants.ALWAYS = 519;
    Constants.LESS = 513;
    Constants.EQUAL = 514;
    Constants.LEQUAL = 515;
    Constants.GREATER = 516;
    Constants.GEQUAL = 518;
    Constants.NOTEQUAL = 517;
    Constants.KEEP = 7680;
    Constants.ZERO = 0;
    Constants.REPLACE = 7681;
    Constants.INCR = 7682;
    Constants.DECR = 7683;
    Constants.INVERT = 5386;
    Constants.INCR_WRAP = 34055;
    Constants.DECR_WRAP = 34056;
    Constants.TEXTURE_CLAMP_ADDRESSMODE = 0;
    Constants.TEXTURE_WRAP_ADDRESSMODE = 1;
    Constants.TEXTURE_MIRROR_ADDRESSMODE = 2;
    Constants.TEXTURE_CREATIONFLAG_STORAGE = 1;
    Constants.TEXTUREFORMAT_ALPHA = 0;
    Constants.TEXTUREFORMAT_LUMINANCE = 1;
    Constants.TEXTUREFORMAT_LUMINANCE_ALPHA = 2;
    Constants.TEXTUREFORMAT_RGB = 4;
    Constants.TEXTUREFORMAT_RGBA = 5;
    Constants.TEXTUREFORMAT_RED = 6;
    Constants.TEXTUREFORMAT_R = 6;
    Constants.TEXTUREFORMAT_R16_UNORM = 33322;
    Constants.TEXTUREFORMAT_RG16_UNORM = 33324;
    Constants.TEXTUREFORMAT_RGB16_UNORM = 32852;
    Constants.TEXTUREFORMAT_RGBA16_UNORM = 32859;
    Constants.TEXTUREFORMAT_R16_SNORM = 36760;
    Constants.TEXTUREFORMAT_RG16_SNORM = 36761;
    Constants.TEXTUREFORMAT_RGB16_SNORM = 36762;
    Constants.TEXTUREFORMAT_RGBA16_SNORM = 36763;
    Constants.TEXTUREFORMAT_RG = 7;
    Constants.TEXTUREFORMAT_RED_INTEGER = 8;
    Constants.TEXTUREFORMAT_R_INTEGER = 8;
    Constants.TEXTUREFORMAT_RG_INTEGER = 9;
    Constants.TEXTUREFORMAT_RGB_INTEGER = 10;
    Constants.TEXTUREFORMAT_RGBA_INTEGER = 11;
    Constants.TEXTUREFORMAT_BGRA = 12;
    Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 = 13;
    Constants.TEXTUREFORMAT_DEPTH32_FLOAT = 14;
    Constants.TEXTUREFORMAT_DEPTH16 = 15;
    Constants.TEXTUREFORMAT_DEPTH24 = 16;
    Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 = 17;
    Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8 = 18;
    Constants.TEXTUREFORMAT_STENCIL8 = 19;
    Constants.TEXTUREFORMAT_UNDEFINED = 4294967295;
    Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM = 36492;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM = 36493;
    Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = 36495;
    Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT = 36494;
    Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5 = 33779;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919;
    Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3 = 33778;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918;
    Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1 = 33777;
    Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1 = 33776;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916;
    Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4 = 37808;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840;
    Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL = 36196;
    Constants.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2 = 37492;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2 = 37493;
    Constants.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495;
    Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC = 37496;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497;
    Constants.TEXTURETYPE_UNSIGNED_BYTE = 0;
    Constants.TEXTURETYPE_UNSIGNED_INT = 0;
    Constants.TEXTURETYPE_FLOAT = 1;
    Constants.TEXTURETYPE_HALF_FLOAT = 2;
    Constants.TEXTURETYPE_BYTE = 3;
    Constants.TEXTURETYPE_SHORT = 4;
    Constants.TEXTURETYPE_UNSIGNED_SHORT = 5;
    Constants.TEXTURETYPE_INT = 6;
    Constants.TEXTURETYPE_UNSIGNED_INTEGER = 7;
    Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;
    Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;
    Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;
    Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;
    Constants.TEXTURETYPE_UNSIGNED_INT_24_8 = 12;
    Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;
    Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;
    Constants.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;
    Constants.TEXTURETYPE_UNDEFINED = 16;
    Constants.TEXTURE_2D = 3553;
    Constants.TEXTURE_2D_ARRAY = 35866;
    Constants.TEXTURE_CUBE_MAP = 34067;
    Constants.TEXTURE_CUBE_MAP_ARRAY = 3735928559;
    Constants.TEXTURE_3D = 32879;
    Constants.TEXTURE_NEAREST_SAMPLINGMODE = 1;
    Constants.TEXTURE_NEAREST_NEAREST = 1;
    Constants.TEXTURE_BILINEAR_SAMPLINGMODE = 2;
    Constants.TEXTURE_LINEAR_LINEAR = 2;
    Constants.TEXTURE_TRILINEAR_SAMPLINGMODE = 3;
    Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;
    Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;
    Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;
    Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;
    Constants.TEXTURE_NEAREST_LINEAR = 7;
    Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;
    Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;
    Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;
    Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;
    Constants.TEXTURE_LINEAR_NEAREST = 12;
    Constants.TEXTURE_EXPLICIT_MODE = 0;
    Constants.TEXTURE_SPHERICAL_MODE = 1;
    Constants.TEXTURE_PLANAR_MODE = 2;
    Constants.TEXTURE_CUBIC_MODE = 3;
    Constants.TEXTURE_PROJECTION_MODE = 4;
    Constants.TEXTURE_SKYBOX_MODE = 5;
    Constants.TEXTURE_INVCUBIC_MODE = 6;
    Constants.TEXTURE_EQUIRECTANGULAR_MODE = 7;
    Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;
    Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
    Constants.TEXTURE_FILTERING_QUALITY_OFFLINE = 4096;
    Constants.TEXTURE_FILTERING_QUALITY_HIGH = 64;
    Constants.TEXTURE_FILTERING_QUALITY_MEDIUM = 16;
    Constants.TEXTURE_FILTERING_QUALITY_LOW = 8;
    Constants.SCALEMODE_FLOOR = 1;
    Constants.SCALEMODE_NEAREST = 2;
    Constants.SCALEMODE_CEILING = 3;
    Constants.MATERIAL_TextureDirtyFlag = 1;
    Constants.MATERIAL_LightDirtyFlag = 2;
    Constants.MATERIAL_FresnelDirtyFlag = 4;
    Constants.MATERIAL_AttributesDirtyFlag = 8;
    Constants.MATERIAL_MiscDirtyFlag = 16;
    Constants.MATERIAL_PrePassDirtyFlag = 32;
    Constants.MATERIAL_ImageProcessingDirtyFlag = 64;
    Constants.MATERIAL_AllDirtyFlag = 127;
    Constants.MATERIAL_TriangleFillMode = 0;
    Constants.MATERIAL_WireFrameFillMode = 1;
    Constants.MATERIAL_PointFillMode = 2;
    Constants.MATERIAL_PointListDrawMode = 3;
    Constants.MATERIAL_LineListDrawMode = 4;
    Constants.MATERIAL_LineLoopDrawMode = 5;
    Constants.MATERIAL_LineStripDrawMode = 6;
    Constants.MATERIAL_TriangleStripDrawMode = 7;
    Constants.MATERIAL_TriangleFanDrawMode = 8;
    Constants.MATERIAL_ClockWiseSideOrientation = 0;
    Constants.MATERIAL_CounterClockWiseSideOrientation = 1;
    Constants.MATERIAL_DIFFUSE_MODEL_E_OREN_NAYAR = 0;
    Constants.MATERIAL_DIFFUSE_MODEL_BURLEY = 1;
    Constants.MATERIAL_DIFFUSE_MODEL_LAMBERT = 2;
    Constants.MATERIAL_DIFFUSE_MODEL_LEGACY = 3;
    Constants.MATERIAL_DIELECTRIC_SPECULAR_MODEL_GLTF = 0;
    Constants.MATERIAL_DIELECTRIC_SPECULAR_MODEL_OPENPBR = 1;
    Constants.MATERIAL_CONDUCTOR_SPECULAR_MODEL_GLTF = 0;
    Constants.MATERIAL_CONDUCTOR_SPECULAR_MODEL_OPENPBR = 1;
    Constants.ACTION_NothingTrigger = 0;
    Constants.ACTION_OnPickTrigger = 1;
    Constants.ACTION_OnLeftPickTrigger = 2;
    Constants.ACTION_OnRightPickTrigger = 3;
    Constants.ACTION_OnCenterPickTrigger = 4;
    Constants.ACTION_OnPickDownTrigger = 5;
    Constants.ACTION_OnDoublePickTrigger = 6;
    Constants.ACTION_OnPickUpTrigger = 7;
    Constants.ACTION_OnPickOutTrigger = 16;
    Constants.ACTION_OnLongPressTrigger = 8;
    Constants.ACTION_OnPointerOverTrigger = 9;
    Constants.ACTION_OnPointerOutTrigger = 10;
    Constants.ACTION_OnEveryFrameTrigger = 11;
    Constants.ACTION_OnIntersectionEnterTrigger = 12;
    Constants.ACTION_OnIntersectionExitTrigger = 13;
    Constants.ACTION_OnKeyDownTrigger = 14;
    Constants.ACTION_OnKeyUpTrigger = 15;
    Constants.PARTICLES_BILLBOARDMODE_Y = 2;
    Constants.PARTICLES_BILLBOARDMODE_ALL = 7;
    Constants.PARTICLES_BILLBOARDMODE_STRETCHED = 8;
    Constants.PARTICLES_BILLBOARDMODE_STRETCHED_LOCAL = 9;
    Constants.MESHES_CULLINGSTRATEGY_STANDARD = 0;
    Constants.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;
    Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;
    Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;
    Constants.SCENELOADER_NO_LOGGING = 0;
    Constants.SCENELOADER_MINIMAL_LOGGING = 1;
    Constants.SCENELOADER_SUMMARY_LOGGING = 2;
    Constants.SCENELOADER_DETAILED_LOGGING = 3;
    Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE = 0;
    Constants.PREPASS_POSITION_TEXTURE_TYPE = 1;
    Constants.PREPASS_VELOCITY_TEXTURE_TYPE = 2;
    Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE = 3;
    Constants.PREPASS_COLOR_TEXTURE_TYPE = 4;
    Constants.PREPASS_DEPTH_TEXTURE_TYPE = 5;
    Constants.PREPASS_NORMAL_TEXTURE_TYPE = 6;
    Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE = 7;
    Constants.PREPASS_WORLD_NORMAL_TEXTURE_TYPE = 8;
    Constants.PREPASS_LOCAL_POSITION_TEXTURE_TYPE = 9;
    Constants.PREPASS_SCREENSPACE_DEPTH_TEXTURE_TYPE = 10;
    Constants.PREPASS_VELOCITY_LINEAR_TEXTURE_TYPE = 11;
    Constants.PREPASS_ALBEDO_TEXTURE_TYPE = 12;
    Constants.PREPASS_NORMALIZED_VIEW_DEPTH_TEXTURE_TYPE = 13;
    Constants.BUFFER_CREATIONFLAG_READ = 1;
    Constants.BUFFER_CREATIONFLAG_WRITE = 2;
    Constants.BUFFER_CREATIONFLAG_READWRITE = 3;
    Constants.BUFFER_CREATIONFLAG_UNIFORM = 4;
    Constants.BUFFER_CREATIONFLAG_VERTEX = 8;
    Constants.BUFFER_CREATIONFLAG_INDEX = 16;
    Constants.BUFFER_CREATIONFLAG_STORAGE = 32;
    Constants.BUFFER_CREATIONFLAG_INDIRECT = 64;
    Constants.RENDERPASS_MAIN = 0;
    Constants.INPUT_ALT_KEY = 18;
    Constants.INPUT_CTRL_KEY = 17;
    Constants.INPUT_META_KEY1 = 91;
    Constants.INPUT_META_KEY2 = 92;
    Constants.INPUT_META_KEY3 = 93;
    Constants.INPUT_SHIFT_KEY = 16;
    Constants.SNAPSHOTRENDERING_STANDARD = 0;
    Constants.SNAPSHOTRENDERING_FAST = 1;
    Constants.PERSPECTIVE_CAMERA = 0;
    Constants.ORTHOGRAPHIC_CAMERA = 1;
    Constants.FOVMODE_VERTICAL_FIXED = 0;
    Constants.FOVMODE_HORIZONTAL_FIXED = 1;
    Constants.RIG_MODE_NONE = 0;
    Constants.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
    Constants.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
    Constants.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
    Constants.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
    Constants.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
    Constants.RIG_MODE_VR = 20;
    Constants.RIG_MODE_CUSTOM = 22;
    Constants.MAX_SUPPORTED_UV_SETS = 6;
    Constants.GL_ALPHA_EQUATION_ADD = 32774;
    Constants.GL_ALPHA_EQUATION_MIN = 32775;
    Constants.GL_ALPHA_EQUATION_MAX = 32776;
    Constants.GL_ALPHA_EQUATION_SUBTRACT = 32778;
    Constants.GL_ALPHA_EQUATION_REVERSE_SUBTRACT = 32779;
    Constants.GL_ALPHA_FUNCTION_SRC = 768;
    Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR = 769;
    Constants.GL_ALPHA_FUNCTION_SRC_ALPHA = 770;
    Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA = 771;
    Constants.GL_ALPHA_FUNCTION_DST_ALPHA = 772;
    Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA = 773;
    Constants.GL_ALPHA_FUNCTION_DST_COLOR = 774;
    Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR = 775;
    Constants.GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED = 776;
    Constants.GL_ALPHA_FUNCTION_CONSTANT_COLOR = 32769;
    Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR = 32770;
    Constants.GL_ALPHA_FUNCTION_CONSTANT_ALPHA = 32771;
    Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA = 32772;
    Constants.GL_ALPHA_FUNCTION_SRC1_COLOR = 35065;
    Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC1_COLOR = 35066;
    Constants.GL_ALPHA_FUNCTION_SRC1_ALPHA = 34185;
    Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC1_ALPHA = 35067;
    Constants.SnippetUrl = "https://snippet.babylonjs.com";
    Constants.FOGMODE_NONE = 0;
    Constants.FOGMODE_EXP = 1;
    Constants.FOGMODE_EXP2 = 2;
    Constants.FOGMODE_LINEAR = 3;
    Constants.BYTE = 5120;
    Constants.UNSIGNED_BYTE = 5121;
    Constants.SHORT = 5122;
    Constants.UNSIGNED_SHORT = 5123;
    Constants.INT = 5124;
    Constants.UNSIGNED_INT = 5125;
    Constants.FLOAT = 5126;
    Constants.PositionKind = "position";
    Constants.NormalKind = "normal";
    Constants.TangentKind = "tangent";
    Constants.UVKind = "uv";
    Constants.UV2Kind = "uv2";
    Constants.UV3Kind = "uv3";
    Constants.UV4Kind = "uv4";
    Constants.UV5Kind = "uv5";
    Constants.UV6Kind = "uv6";
    Constants.ColorKind = "color";
    Constants.ColorInstanceKind = "instanceColor";
    Constants.MatricesIndicesKind = "matricesIndices";
    Constants.MatricesWeightsKind = "matricesWeights";
    Constants.MatricesIndicesExtraKind = "matricesIndicesExtra";
    Constants.MatricesWeightsExtraKind = "matricesWeightsExtra";
    Constants.ANIMATIONTYPE_FLOAT = 0;
    Constants.ANIMATIONTYPE_VECTOR3 = 1;
    Constants.ANIMATIONTYPE_QUATERNION = 2;
    Constants.ANIMATIONTYPE_MATRIX = 3;
    Constants.ANIMATIONTYPE_COLOR3 = 4;
    Constants.ANIMATIONTYPE_COLOR4 = 7;
    Constants.ANIMATIONTYPE_VECTOR2 = 5;
    Constants.ANIMATIONTYPE_SIZE = 6;
    Constants.ShadowMinZ = 0;
    Constants.ShadowMaxZ = 1e4;
  }
});

// node_modules/@babylonjs/core/Misc/brdfTextureTools.js
var _environmentBRDFBase64Texture, _environmentFuzzBRDFBase64Texture, InstanceNumber, loadBRDFTexture, GetEnvironmentBRDFTexture, GetEnvironmentFuzzBRDFTexture, BRDFTextureTools;
var init_brdfTextureTools = __esm({
  "node_modules/@babylonjs/core/Misc/brdfTextureTools.js"() {
    init_texture();
    init_rgbdTextureTools();
    _environmentBRDFBase64Texture = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAgAElEQVR42u29yY5tWXIlZnbuiSaTbZFUkZRKrCKhElASQA0EoQABgn6hJvoXzfUP+gP9hWb6Bg00IgRoQJaKqUxmZmTEe8/v0uB2u7Fm2T7HIyIrnz88uPvt3f2a2WrMbOvf/u3PvvzP/sUf/N6//i8vf/lv/3v5H//d//Sb//Uq/5u8yf8hV/m/5Cp/L1f5hVzlG7nKJ7mKyJuIXN/hPwqXI/g++zq6rPI5u8z+WqfLre+zy7PrVv9L8brsMiGvk8XLmM/sdfHXal4e3ad6GXPdyu2ij8u/+uv/5cuf/OSLfdtEfvUr+dnf/d0X//t3H/7bf/hP//N/928h/0Yg/4VA/kogfyGQP5Wr/IFAvhbIlwK5CGQTPP+9z5uPeePJSW+yo2+s/GtN30Rnv1E+f5zxof9R/lSXv/nr//mrr3+i+5dfyX7ZZQP07Tffys//8R/l/9TtX7790T/7r/8G8pdy+/8XAvnnAvkzgfwzgfyxQP5AIL8vkJ8K5KsmMVzu1U7p5PA5AXxOAJ8TwPf7sX/51ZeXfcemqnp9w/W77/S7X/6T/vzf/7383RWCX3/z05/9i3/13/0PX//eX/2FyP8tIv+PiPy9iPy/IvIzEfm5iPxCRH4lIt/c/393//9BRD6KyKf7f488fP74/PH544dJAF9cLl98IZfLBZtuqterXr/7Dt9982v95S9+Lv+gF/3i7Spv/8lf/vnf/vGf/dF/JfKnIvLnIvLvReQ/NEngn0TklyLy6/v/34jIt00iGJOBlxAsdvv54/PH5493SQCXy9t2ueh2ueimKorrFbjq9eNH+fDtb+TXv/ol/vHyhX4Fxfbx7euPf/Lnf/PfiPyeiPyhiPxxkwB+fk8AvxzQgJcIrGTwFsiAEXH4/PH54/PHUgLY7whgu2C7bLqpQgHB2xvePn6SDx8+6G9+84384vKF/IPu8iVU9Y/+7C/+jWxffiHytYj8VER+X0T+oEEBvxqQwCMJeIngo5EI3goIwVMIPn98/vj8ESaAbbtu2ybbvl8u2ybbdtluSECA65u8ffqIDx8+6G++/VZ/efkV/sO261dQXP7wT/7kX8vl8qXIFyLylbySwe/dE0CLAr65B/9vGn0gQwRMMqgmhM/J4fPH548eAezbZd/lsm3YtssNAYiqiogAAkCvb5/k46cP8u2HD/rrb7+R/2/b9Wu9yJe//8d/9Ney6S5yEZFdRL68/38khG/uKOCnAwoYkcCoEXwkEgGDDq7CeQfyOTl8/vhd1QCum26ybZtu2yabbrKpQvXue1yvuF6v+vbpTT5+/CDffviAX1++1V9sO77WXb/66R/+4V/dgkbllQi+aBLBV/dE8LWRALwkYCWCNyMZXElkwLTMeMkga/P4/PH547ccAVwuctkvdxSw6bbdtYDbTfSZBN7e8PHTR/3u4wf55vKd/nL7DX6mu3791U9//5+/gkNFZGuSgZUQvnKowKgLWLTAQgRtEniTuEfwaELw0MJvf3LQzynud+53uG+X6y3gN9kul+2y6XVT1U27JCDAFVc8ksAn/e7jR/nN5YP+avtWfq6Xy9f7Vz/9w1dgRYngiyYhfNkkgzYBWHTg44AEMmqQUYQKOmDaiCIa8TmsfmzB+DnZDQjgcpGLbti2y3bZHjRAdRMVvb/dcYU8kcDbPQlsH/CrbddfbF98+RPZfvLFnAQeieCRDC5DMvju/vmD4JkEvjRQgKULeGggowdHkAHTYxihg89vu88I5UeGAPSOAFTlrgPopiqbKPSmCKreUoAAkCcSePukHz590m8vH+WbD9/JP335k6/+tA86KxFchv8jMvhiogE4JQm8XhfKqOAqx5qRPyeGzx8/cgSwbXcUoLJtim27C4Oi93+4v6VxQwKAvl2v+Hj9pB8+fZJvt4/yzfbF9lPdv/wJnsE2BogmyeCRED40tGFvksIXiSbgiYSRRpDNDZ6BDI6ghM+J4fPHeyKAO+zX7cb9t4tedMMNAQju5V+f1uAtBSiu1zsduMrHy5t8ePsk3376KN98sX/xE5FPAnm7/782o0DiUINXMkCXCB7/P94/e87AWUmARQWVvgMuKej9t1RLBp+Tw+ePgwngsutFFdu26WXbbl+rSvdfbnqAiuA23QcBgCugV1zl7e1NPm5v+LC96XfbJ/1W9y++fgXjA3bDYXV+MuhRwSPwL3JLMFYC+HS/LU8HYrGwIhwyNOF12SvgM4SgztdifP85MXz+KGsA2C6X7aJ6bXSAOwrY5OYIqGy3d5uq4P5GhABXuV6veLvRAf10fZMPb2/y3b7vX7+g+9v98/WOBq7GG7RNAlYy+Dgkhhb+Xxp0sE8IAC4SGAP/TbgVJK/PoJPBnAiwPKxsXfbbnRg+i3s/JAK4Q/4b9NfLtomBAqCickMBjy7BuywAUVyv8na94tMjCVzf9KNcLl/0SeA6oAEYb1i9g+FtSALb/bKL8/+t+wxXFMyswqiHoK4ToIgKqslgpg1qUC0QoYbvJZg/B/q5v4szHmPX7YEAsD0CX25OwEUVm9xag1+agKg+nxQArnKjAtDr9U0+Xd/k4/UqH7bL5YsewrcBBiMJZPRAp6TwQgWfjM9vgRbgUYGL8AvLWH2gqhesCokeUmCSwPsnhs8fP2YNYMO2XeSmAWxy2VQaXeDmDIhApf33rD4PTUCuV+DtCn27XuXT5ir8VmCJ2G5BpBM8/r/dEcJb8/0lEQMtJHA5TAlqNuLRhJChhEpSqFabH3di+G1AGj+W1/dyAR4IYJNNnuLf6+tWC9CHHiAtFhAIFLjK2/Uqn65X+SS67aK+3QeTDoy/IG2ogQ7fb/dAtz5vBgrYGqrwNtCHsVfgIvwK07OTQBURVNCBFpKCOjqCHn5L/67TgTN+fpySAC56nwSUi256kXsSuFGAVyLoUIDo8/Pz7fdoErr/v17lk162HbgHvFpIYDfoAJJfW4sGPjkU4VNAF8ZEcLmLhdc7kljdY1y1Dq9yLiI4IiRqcLujb138KIPn80ejATwRwIbtBvn1cqv+2J78/5EI5N4cJA8qIPcmwRsKAHDF9WYP6mV7VmrgLuTpxYTcMEW0LAmoQxFsuvAI8tv/a/C5fV2ZMMiKg++FCM7RDPRu8ebWY7VG6VJi+Bzk35MI2LsAckMAgwvQ0gC5DQjd3ABg2HQLAPpEAlZ1Bu7VV7MGHDFRAbo3VKsTbAY9sPWC/uvx86gBbDK3D1eEQS8pbAeSgSwmhepnJb6uBv/o/PzHLzxWA/X7TH77De5j6AGQi6o0CUGfCOD2X7cXAlCFQABtEsGLDtxuOyQB2UTQBKZe5GUPXgkUYCUAbZJRhBDeuq8xBf+bgwbehDm+BFQi2IJksOocvA8ysIMfxluVcRsY/eB3JzH8GFDAXQO48X/dcIf9jyDHptIigDsFkEe066tBSETQUYF7ElDdYEBytN4+rk9UcBPfrKaZqFHWcw3i4J8/X4ev2//bSXqAhwTay6OEIPLD2Ipt8OtAGzxkwLw9WVFRjTc/qC6H3+YK/b1oAA0KuOizHfieCLaHHiAb5NYTIC9EMEbZrVEQt1xwhVy1UfBh8PUOquMizwaap3tQXfY5B//tea/NZdfhsvbz+PURQTDSGWB87VX/7WSd4KxjUqrIgE0IUkoKGnhIvwvawpGf6eECXJ7tv4qbA7DJgwpsKthEmmYgfaAAffYF3HLxo0vwNjJ0SwRWMG4db4eh1gPNm18vQ+us/0eGmxDemu/fnM/X4evq/8342ksGHgLY5LyT/zg0wM8lcMjgGFXwqIOVFJBQw99eCvF9oZL9Mfl3QwAvIXDsBRC9R+fz8x0FPBLB0xJEpwUobrfAkARgIAF41h3wQgP6QAmX5E/7eI43IxGwwf/moIkRyWRJQIPgt9CA9b39nzt4bYUWjAlCjWDPgv8IEjgLJfzuaAsrv9VdVG4OwOXW/fdoA35qAdL0BDwvf6AAUVHd8LIEu94A3K+Q+2YxaB84MOH62P//qoo38fCRDERE2zf0JfmDa+MieElAjcDPKz+mRKCOtdgGtXaBjgNJ4H2owSpNeAW/rRH4CaHSpMwnBYYycjgSJwfie9CR6mPu20Uv8kABF206AvXlBMiIBPSlB9wjBW1fwEuSb94296VCqgMaGCt/G1BbExi3IG+r3a3J6P48Gv/J0YmEYoiGY7V/SxwFCwGoE/xa0AJ0CEiV9QPCJb1OJ5F1VTjEY2/MO9AEJvj1BJTQpqLfTlGwjABuzT962e4IoKnyrdh3+/6mzDVJ4PHOxj0JqGKoy20+wBMN6D1gLWi9NQHfVP5MEEPzjGYy8BMAOnTAJgEr8HUIejRo5xrA5xkR5AngmiSHs+zDDAmMgWzTg55GSJEmHE8IvWPAoYTfhWak/Wn/bQ0CGLSAjv83SUEfKp5q24LXuQICpzrjrgWoza8xVE00CQCORdhMJuTUT/rjuls0gO4Iby8BIEgK6gS7BsGuTtDrScH/fR68biUHNVGBnxjeNyHEvQe/ve3LZQqgG3rof6cEclsNflG9J4KtaQ8WHcVBHS1BtHE4QP9OBMS98mpbKTeDW7dJwRsnHpMBTFJpV4I+b0kY/NqInVFSyBLANbnMSgBM8F+Fqfxq/h657/Up+GaBnwV9hRqc9bZ/vA6vu+T9E8KPJWns94UfTeCj2QXwCHS9dNL8Xf3Ho/rfewSeFODGDV69AU0y6NFAE1DP3qK++rdB7/1HRxf86gT376zOr99T/h/ioBiXWQkgQgVeIrCC/WomhDmQK+hASI2ARQZKooHMLdCJwGEBBXC3+uERwg+VOHZ9ioAt9H80AI06wGgJ3nQA3BoCut6AhxYwgcPOFnxuFnrphk+NIKIGrWPQtgz3b0i7Y6D5rs1GKqTop0nQX52vmQC4BkjA+r4a7Kx9WLENGeegkhSETBCrNXIMdi/444Rw1n6E96ry7OPuj8UfLxtQ78NA2iSBbg7gIiIbdDLsb5agPhLC3RkYKv8NDbS2YGsatNRAG2oQwf9ZIOydgy1MAzBkAw8UwEEIDzSAqdPQ6za0PkeJAMH3Z0wXniUSZoHvBXU2mcjQgv56TedIKglCpIoQfgwCIjOytd8WgN0bfxoR8Fn9Gx0Aj5Zgq0lIZbsH/ibSJoFnS+C98g9ooHEELI3gliy25yONIiE6pb0NfBlyNEYyENoodkKwgl6I6s8kARgJ4ZoEfuYWHLEJa0LhSBXm7kImGeSfVdoJ1DO2G7WXsehAptupSOoyrCSF904k+6vt98X/ZcM98Hsd4JYIXhQAIg3/f9AAUYhsLQKAtkHVBnzjCKhOoYl2ym+iBtvzDzQ2DLXJ4PUmbJHAVnBQX4jkxfvHhNDqAdHXGQJgv0aSDGItgOseHIU+K9hXnIJzkoGlEKzNHagTdJ6VWEUH4iCKH4fd2AwDPaYBm4Wgng4gQ9V/CoGiuNmD04AQtNGMGzSAAQ2I2pzfogY9LRh7BrbOh4+D30sAencljFu2CUFrwY8UAWRfWwGvVOVfbx2uIILM0pwDv082dUTw8hYs8L+uIWiHGpWgClnAa1lMPJogovvvbePPs/q3Xr++kgCsfgB5oQF9WYKPJqEn6G+OE3i5AqouF59FQOmahQC8rlPLj38kg1c2f30vw+XaoIX24/pMGIgSBoZqoH3wo0sIIGlA9PWcCPrAtpPB8eBf6x1o6cHra+2+tpIFP4PgBfxZtZUJfo4qxELT948D9ucK8Mt9+ccjIQw6QJcEbrD/1g340ATuDgDkFfx6twSf1f9xvuBECYxq/7ythQQGm+5JDx6Brw4CkMGT3wgscCUoQ4sU2t6DR2ciBjTgtcpenQoZVX9NuL4Owc+dVaDursYVkVALX+shjSBKBuvCYDUZjE5BdNkxdHAUBexyHwB6NP7Iyw7sxUDViwge1t+mz8B/LAvVx/c3PeBBCToB8IUGOgqA3iV4yUg6UAOxaUFHDx6CYS8SorMOue0CCJGAf5YfRhoAI+A1CvwxqNkAY5yAIx2EQmkFfeWOXi+nEdSQQA0ZHMEItiagJArQxDXIrj8nCfQi4HZPAttrIahso9oPQ/2/JwV5JQU8zw+7I4D7/sBn4EO6rjw0FR+i3Z9fHtahzsFvJgM0X+tmVH5vaYiNDGAigewAz+gyNLThnjCURQFR1b9d3lZvnVqmj9mEPDKIUIC4KCCjBXywS4N+otp/Hk3QVthOkwEKlV9PQwXjT7s/zwF4Qf9toAAzFdjuaEB6S7D1//U5FIQu2MevO0rQQH8ZmoXE6B/IkgE60XCjVoq8gt2iCG0S8L5GdxkM1cGsfsCMArSCAnrr7dzAZxCEEpepvB8tqHJ/q+bmJGGts/AcAXFOMMeTwC7Pw0B6CtCtA2vWgonqBQJFSwH0JQK29OB2kvgj2HHXAoyeAIsCQO0kMNECAhFMqCBf8mElAkyBbX1tJQP2RJ/ha0gpAfS9l+/5n00CkrQpq0MZbOdAuxmMvHswog62jZj7BnYQe19b14kxNq2D/ehX/p68HEcF+x3yP7z/V/A/q/5DA3i5A/dzA5pdgbKp3v3/wQF4Bb70WkCTHGRAA6+KL0bFl6FJaFw0ImZwm6igSwbbwPn9RMBWf3sN2JgA/BVh/Rg0kQBgePf6HglAHLFQwqQQOwDjbdVxNZjR4iM6Qa3WxwvNxh0JFb3g/WzFQQS8b/ttKcDWoABtUMAd8j9hf0MB2uDXhzX4CHj03L9DBU3Qjz0C0l4mLSLQPicOOwZoVCB6P6dA7nDbGkVuxcNr8PU2JQO4wX5trEqmccZaHU4q8oCDFOpzAnOwqyMIMktNNNAHouDGxO37DgArQZzlmp/14W1QlqHTMaIIx7SCx0+5yza7AKJ3IXBrNAHVDcMZAU/BT/vgv/ULPOA+XiLggAREDF2g0ci6xNDRglegd7P7TWWH5oJfayliEg7bScQRBVgI4Ookg/F6rvpLWP29swREqA3CaG8/FpKqS8DTAV4TiBqIqtxfzaQRLys5I0XEFIFrPbZRQb+16Fgi2LvJv8EFUPW1gGfQv1T/F/d/HBnccP7rAwnIIyHI4ArgWeGbU4eHy6Tx/EeTZIb5bo/BsMBjmjBE08f/RB0PHYBd9eVRAGY7cHRwiBf8WeCPHY1bgBTa9xKTELzEkQX9CPtl0gJiqsAmCT7I8xbjivh3JGFI+D2nBcSJQJ8agDX+O9iBL7UfG4bzAkcaICrbtYHz1ycSmGmAjJfL3CMgT3tQpmrfB7gxSzC1DnvdhQMieG47u75+kTouKNkM8c/+vq/Q7ZYjO/hhVvRq8F/9gGfhP8aqE9EIdR6LTwJ1h0BItyDqB8iFwuNqASscRnYioxOg9ApvnYA35f8e9Ohbfe8J4rknoFkO0lmA2gmAG0YK0DkB4ieEjiLoMD8wBzom27ANZkzIoU8EMHk/uo1mzeVoEoRWKn8L/62EYAX/lsB7D/LXg74uAMr9oGivJ0CNJCGD6i9DhZdQF+gtOp4S+NODRzsDVbhdgv4BqTMNyIL9SCKwL9/FGPp5oQKxIf8A/UX6r231H7YIqLML0Ae2GtrADOvRQH5b/MPE9dt9BGLNG8jVTAQvIaK5TtvvvWQgDvyXIClUA78S9Nfg7VtIBlO7cbsEYkQDMot+ygQ7QwmOawTHnAM2XUSnJvPIYRYMmYPS+sv3J+cfP3d04JYIXsF/EwMbBKB9Q9AY+BiSwFj9mzrSXmcJhFPVHySTbgHJCPvRQ/z7G/SVUETsg0ZF+i3CRoCjhf7y1A9mOiDD7TwdwEoEXjLwAv+avLE2B7Jnb+OqDpBoAchoQJskxKnss0vu7Q2YhcDv4ySeLOg9GsCKiUIihP7yfW7zbTsBh0TQfN0iAWn9f72Z56/Ax9P7j5OAH/Qvv3/QxKfk0DgDuP+R3USg3bzBC7bO/QT9Eeh9QvDPG7glBQzJwK740lAFFgFk8P88CqDGAa223YckWYhr+c0BPdwetl2ocnsfzePAWcVnnAIp6gDVhDLyfV4nqFEDPxHsbWD3k4BDkN+pARqKMLYBPzYEvxp9xmCHQQdgWH/9EtH2TIFpu3AH/cdGydv1j0TQbRrq+D/mLcX3ZACZ15bF378CG0My6Kq/zoGOQwhASDFwFbxyNGBuSxbCEhQ/uEPe/6gAERWQObCVVfjPpQX+rexxYhYFxIkgpgX7Y/vPs+Pvxf9vwt8kAs7i32t3QCP+3SPaTwIytQXP38u0PESm+YER+o9B3vr8mETAUfDrEkPI80ck0FZ0dXh9U+HRbhey0cAc2H7A4y4egoD6y8JfkBiigLdFP8v2W00E8deT2IeAKujZ/QAVKpAtKI20gLWksHedfgPcb+0+NEHefd9vB9rayi8h7J91gBbaw20MsnWAF5xHkyDUCOoXp+yrOwwxcKj0aL6fFppaaKDv6OpHR5sgx5BAlK/+fYhuP1D196o8e7lFBaKqv5YIMnFQpd0FGVR35RJCnCDaABaXBtgbiSwtICMtalKC+1JQ6bx/PLcDPQL91QFodQNKpwOgF/9eqcBxBBqRcKAAVk+ArQOMx1RYGgB6naDhlK+uQQwJYx4meQbxtNnYQwMjt/d4f3M9ZE4UOld1LAh99fbfzOxiEkKFCkTJIUIMUeVnJ/9sDt8/e1NEJOi9oVHDGYhgnSLss9DX2IAqw1zALUncKcDr0FB5NP+0cBQNrEezDiyiADPkt9qGpwoPdL0AGPx/NOKeyf3b9WJNdfcFv6bKd2cLMJVfJ6Y3B6wB9WFUfWWEwKMfGiQL+3bz9XGQz2EHKhF41GCtZyDi/gUCsNhYoAr3UNJ58YidHKqnMb/6AB5J4N73/4L+t7mAkeeP3P+1LNSB/l0SkMEd8DcEuUlguEw6t2AU/PCE/q++Akw6QFf1u6SBrj1ZnnhG50AfkoGIdf7gJv1KcSfgzWWkQ9U33Z3tHXYASKJ9e/YhU90rvD+q9Ej69/wxYJVs506Eg/r3DkMDzEdDBRGgcZay49XihLA30P+l8N+hf1f57/0AoxbQbwYaan/rBMirE9Dk+sBzTkC8JNDEUlv5McB8PP19Y01Gayep+hC/2zvQ/2HGLAurowsNGlA1cnqGGzeH5weiYLZm7h3QQC4O2tXdhvMMk1ZS5ebpgI8eMrPvPGkwaxayk8Yc6PMOBPEdC1XZ+2UfbfOPtxLMQQAG9BcZFoF0gp/RKjxe7+oAw9T7ZPWhgedodgz0gf5KBtrtIZhQAZpAV1Bi36w6t98qVfH7hqGI318lLCjLCUFlxRHwqYEH9a2qb4XjWvDT7kBwfbZA5P0+PNuRuW1yf4yNQH3zzwv6b70QOJ0G9OT/dhoYRUGT15uQH/71MjQLtQlxfDuiCXrtM+SkA+icQdH6sU/xz7Ze7FlubV4TpoTQ2osdpaEjtqADmEU7OkBEFoLeC3IWFFeswJXKXzkboNL+wzcFHU8hTGKIboO7CLi1/P+5F+gydQhuvRbwEgxvtACmANikhLTbj0gCYk8KdlYgmj+4Ymaod7TwahwadICuX0Cm2fE5iNHPK0x/CDV66Kyg1MnqjNFBnhBoLQCgUULfaVe5nq/6EQWY67bXCszUb+7232fVPz51iGB12owK9peyP1T4raMFF/OEYJP792mgXYfZ04GHMAhBkCSmSj+dKqRPgVFGHbpLEGMiGFeQWfSgrY52VxaeDUPSNJI0P7NoisG729HHl78z6hxfs9rV3m4JjgM/lsui2qmThjCfDFSb+I9vwUqG5wwL55U7C+6ot8B+7N2o6r3q37T9trfpjgmTvv7PSQATLLeRAOZhIJHBQfDQQJPBdUwEbVW3+L08EcEE/9G4ANrCeWcnPKRHDupbNynMx5AA9IRYLmrc/YLSiD5EaEBS/s/TgnU9ILcH19n+CpHwegLejx7Mn/d25fdN+e9U/1vgb7bqf08MOtf8EXxaoh+GY8L6gDfhvs4i6HQ7seYI2sv1GchdMsBIG3xlvxcCRzdgCPTn+6q/TW00VE8Q9FaFv+R2VlOM1vm/hhjhDCdgNflVKME5B47I9xT8z0YgPAJ8myb/LqHy36j/Mwqw9AALxuO1JVjiuQAYLcFzIhiEPe05fk8tRjGw7yWQbsfuLAT2VqOId1osnr0F49VM8INACPHDoBz4B5mqqSnUgyh3ArjXxfQH5BbgUS8gP7aU+w0zHD9GGD0CGHf+P1p/DeivlhU4BbxR9a2kYFR58YaDZCUR2P0DMmgED2eg77puegy6PgDphEB0CwlG/i9d+/Hs34pBEQrBn0W51mqGnJAk3ACCHeiqkQ1XFQA5AlKH7Lk8yJKWY3/nym14h2C3JvxeMwD9ZVMz0BPMi1n1RbKl1cYhIVblF3G0ATsRiCMUvoK9//OgcwYMoe+ZKOLlC6/Xk50br9NFz9fanqA8UIYSpCwlBO4kHc4WLLBfBHVaKwKgLQjmP4Un61Vq+3s7Bsyi0WztmLjJwJwFeE0I2vD/1Q6MVwefxfUf32skCPbCnxQqf+QMPEUDHZ7vGeyj020JgkPXXwsldA7SYR1RE3h94NvNtugswcgxXEkIcBPCGZ1rmrgDC0A4K88nm2fn/eTnpQtWyZfybRoK8Dro4zYDIMGsf7saTBzvX0SMbkAD6o9CYbsfMK38cJKD9l2FJt9/VGs0h5Gib33pxMKWNsigFUh3G2un+/N1WUglI/EEx8fq27vUNnwsiOoKecL7kQS8VnWAGCFUgn6dBtQhv40CmIYggwK0uwDHRGAuBXVdfwzHUjZzATLMAoyJ4FmBhzaWBlrHld9CCWpPHRqofBqMReMGTJ78q9rDes1Tv7/0m0v0AFHXNR6P6g30SHivin7V1BOhh3iWPwvps/yE836L2XiwnUT8x2iHgfqhnwn667QHEE8oLQjEvtEW7GYBZDrDVkwNIO4G5GiBDf9fGoFM6n+vbEtzXwP6u9AduaWnGYSLAlVdl/AU+ikrSeEIKgwdaZ4AACAASURBVKj4/wtgHcHtdO2nWKcBkPfxcvnNQvsj2Me9f02r76T8q0IBn9OLKfz1HX8yVXQYGoAB/2UeBQ5/5kCL6+H/OGGoRnLSwdd3oH8r7KkGTbgIxEwVWvnF8KOpHnyzfF9Jod5Px+IF1h8owyitDw/XEgRb5bPqbt1uvn7qBIQ16vtS/u+DP3cR7CH0WWJgd5mTJKYgNzoGjQrfvu99NDBC+bnyW1x/qhTatv2OaMKgJWPvv5kwnMgxHYGFRtJW8VMl3uP+MgoqSZyWFKr7+KIDw1d6+IiOgZI4+d5iYL3imzbgyO+tph9t2oSBxOM3ugHtPoFZ1LM0hF4kXNEBssvVgPdjdXZWK7uKvyS3q1Xb1WQwtVDqSUggq+Vw3t56JA2cz7PXOwGNW1ecwxPhfe3QEUsDsFaAz8jg0nf+iZMAHNg/XSazDuC18Iq1HBRrOsAQ8NLB+16g614jmuSgs3bROxE55D+WDDQNA4ivdMJ9M1b309UqknaDU8ObV9/PwmMPATvTMAxpABLBzugUtV9bLdhNDQA+7B9tQJ06/7QNDHGSwtgZOCIA47InIoDdROQGtt0U1HI3GaoUnCnC/rzBMQJteN17+VaAzYNA7e+PFqHQUyXPUYB7iQYa5ZFjq1Zqpx8Uqu/XT7+6BWC1Xaj0GlBIwMoHu7UzcI/6/Acb8KIq+hzmGWmAYnADrIpvKP7TZeLaf0LAeQkGgebbq9FToI44p654F47tekKkI0L5PQNZPsDwPBpy/ni+wKMN76Vav4+2cFZFf8+JwAraMt0DFB7beA/u4Zz/a+RXx0M/ct4/jwaNAS8G17eSwmta0Fhx0VRxJkHMivso+onMXr+YwdWKbgioy1jp4x4AzIKg5lEA7wvHEYCRmdx11TAuT6lDLVl4KvXkAET9P4RT8H2u+lg9EPQIpw+/NpJ7RwE8HaDv/Mu4f3OdNkq/EfAiEiOANjEALvcWL9gfFV4NZbgbQc6qPky4Pm35QZxtH1f4j+P/jXuaYPcWwIEH/fmEPBoAO4m4LGxV3txOQqDU+dXgey+UwSzuqP++uImO/u/6ogCb7wTc1n61sL+vZi87rxnrNas+giTg6QLzaUCjIp6JfhwtGI7AjBBB9JjDY4ePYVR6ZPgN4owVv6Q2N5hhVHwNeYrM+w6dN6K1sMHZm/Ce7bHe3dzKr1xw1w4JrSQMZtgnoQHlr18fzunAszD4qurNUg/TDqzx/lfCaO6t4tACMUQ6P6htWjDPC1hCoZ8kpODzJ70MUR9AODcgwyqyPhmE+wfHYB/hvSqt6qeXUShhXH+d9SR8DzrDaZZdpSp/HxqLMQuATgDU/qDPRgOIeT8cvz/h/XC6BtE7ACLOWPE0KIS4UUjmZaJ2grBphiWgT41BUVWZfP3AnEIT6OrfoF122l2rMycBoU5i/OXoUZ4/aglsXwLzHNU++FVF3qikOj5HXm2PBitT1WuvJRAB+6O//W0/PY8vQH5IrAsMs/WuVmAdHBrQgrbOxJShXwRSsu08h8JMBpo0+aDTALwV4tbswgzHrftG/dJKIAQb5h9KCssWIMeto+GYqG12/HWGjx8kzqNJaa0noMWOr2KwW01AMwJoNvhMQda2/RKQP/3ecABM3g9uD6BY68Ntz9+nDOMb5iV+hIE+dP/Zs/wwJhJ9mgBnohBuStABUXjugF3hkXF9ZZJAjefKdHZCc389LoStKvIl7QIEb1d9RyciQgFDI9Cjyccc/23Aam7/PZJBhgDgin5CtQvbCzX8ip9YgIFtOAt+w0owp/hOiCWgEGbVHuYjRigPGR/YOnEoqPDoV5z5YqB3mRq2ox5ICmSSgAP1Ne+XV2NE+/vuFbCTRADxtS70VRBCjgBk2OyDUQiUgfl77b7DwaHm2rAZ7osRSOOUoHgKfNBSLI767+oDYrfwZvqChSpGfj3pFwZFsCJg2jeIQQBUiyI4WgD68ww4qO8khuWkkIuDrxWv2nv+UTBpJYiPd0KemTA8qqFiuUF1jWS3BoG6pADJq751JqBI0wvAVPyMQvjcX1zbELltKK+zBiXRFiRxG+b7q3M9xuLdzR8g0gCGNzSM5gNYfqGO9CBT8OHct6oB3KsSDBisUnwsFuISQaRHxDSv0vptt2oeLHMERfRn/FG/Cx01EpgIQG8LP+/i37PKw53xn6sYCM4/JwSRrCnIeB1ZkLsawDhaPKv/njU3wnZ/dBdGE8+YTHSG8+ofGgIjsC19YnwdM/KAnTSsqj6ig7uGgIPw3nYFzhhIIvriAxFP9CQd4HSlnzgxONIdrE7A8ZDPx9fjib8ifgegNIliRgdx95+E1T7+3nQVNNhEzDgGA3T2rEDLduwtPpuuouPcs8swwXFjdTaMKt+jA5gUAQPcf95KJQxYU0cYxEDvsBSmYuukp7AwnqniC9Afa5z8vboI68ImT0t26CvwBzSggkj447r9IojvCn7U92J/Hw0QSdwZKNNjxPCfSxRqnATkdwpOwh88oc4J8KTSm/wdbZjrc+4iFP8YO0/5JJDCfaijK5xVXevqfg6zGRrQf83chvX4aRfAE//6vv5+6490U4ADdO7QgM/5bcHP/n4OtCQhBEFeDWSvos8DPq8/IwzLzjpa8/U6MMSkBklDm8e0mn3QIY7XG1Om8wzN48y7HwhOK3P0/ZwUQHHv4psbdoVeb9VlAjChBCdtDDpOKTh9ZfcagOYq31RFjN4/gwBYzp8lAwYNwBELhZoxECeZxMlAzWGdCRV0fQWGHo8+8Kx+AAxnCIzowAxy9KvNepWfsfp4RR9kUrD88CPVTuXRybhqqTHcnxEGndsgub1Gdug8yz9fHt3Hpl57x/mfCOC29FOSQ7/noAZR5W3Ob24UMpuPYAYiQrQgk1gnFoUIKr4vKFpV15pHUJO3Y5rfH3UFHU4bGkU+NKJ9f2hJyOMxDBDpjAgwiYqvk5TqNl9EH2Arb6fA3yaA4cBtPWewhkEcIQJBlGzYp6zRmr1v+e3Fv27xpzvyI44NGDkCIi7CGNV9Dw0M8NtHC2vUwHINumCGNG8erxOwtQINsW88Tlwdoc+F85nI559ngEDpt2F/Uu3hiXYrkN/pBFS26hYDAkFgErMK67y9mGBA3L5ore5izf8b3n805MOq/t7XU4WHv1DUF/5gugCSOAIW/59uMwl6CHWAib8bvfxWl9/rBGEMTTwDfG+ezEYG4yk6FvRPuPwE+wvc39IRjENWM+/cm5b0W4Pf4WuKUnw/vD6eDbB1ETs5vl77Dhnm/51g6wPWwQAqxnivgQaeS3gy/u/1H4hpTPrIgHAN0mSgXUX13YP5PMIuQAfBr/f70cdeE+QoCX3i8nFMLcAjInBoAIYqt1LhC1WdtvmSab28AYffaeivCB+ohdYQgfUa/WS4ToMsNLHLc9nnvPZLwn1/EefPVf+U/xvnCVSEQEkEQEnEQJO7S7RvYDxNeNYKrG7DKMhtsQ8cMmhgPKKKj+F7CiHYFR5KIIPxOmg5IVAtu3ACQSPh7CzUQOgAej5CWEkIe3vgxz0ROGO//qYfz/dnLT+ZxDr4QW0eNCJBorCFOVC312Ec2TiY5Bk0cAaQmiA1VH1MOwDHQ0kHdEDDf+2UTWhS4Z8diQMicLx8MLBfverLcP/jQzF0P8EJj5+NGK9RCz755S6F/f1+X/gxeP+Wsedv+vF8/54aSPJYFjIQd624MDz/UDLQnr8HU3ztKHRf8Qeno1vyAQJBaLcMtTV3cvgP56COCqd/QP9xLgBkH4BxO13n4hNUDtACC6G1S3zqooZ6Ba4lp/zcAFb7iERKQwQcF39IFJjdXECGADw0IE4gg674pYAnk4HoHPx54tD5daO5vxrugSkMjgiiqc7TVKAT6AT8R4ckbHEQCYR/IZBxJgA+XZjsR7vaoRpIxWqeqfXuGC2CxwudicwePEB1kNkaZCuwyF0DuKv/4sz9mzP/Qxdg3BDkBTMC8Q+loD6UGBzx0Kz6eAX/KArOQTlPHFoI4vVtf4rNuLrca9edRn4xBP7k8w+9AgZCgBfEUZWfEs8iFNZ3UO7TqmkjCO/rWdgco/yIqHcQWaC2EGTzgz5y/iXQAvyx3riyxxV/JeBriaGB9OrTA5g9/eokM+37GszqfA/UZk9iW5UnCtBqBl3XoNN6Ag/+zy6A5evPAp+TIFDn15gQw9rjrOzFX0s2JBVAxa/nP1a6AsNWYGjPNGPLTQgBsNUFvOA3Ht9o/rGDN0tWOCcxJGp+f7++kkP7PxcGv1+GjkaLt/fawpwwerQxBJNW4b+PJsYEgiAYYdEAGIlDNaAbRkIgK3ut0jKByp+8yz23X6GttmBmjwDvChgiYLP5V/zhH6/110sGcKo5CkggCngxnIPoPja0j2B+1BRkiYJiviaLJqghDI63G2nAgAxMCuDdnoD0wIQm+urMB3VuAwbBrFGgGgnhAFqg9+ujKsLxB3qGCQNEEtPinIQlAj4WgIw7/iXc9V/x/yUWFs2KH504bAh4aYWf4TrTLGTy9YbftyLeVOWNfYNyt/ji29mQnqMAltU3ioTtbX343yv/1u0YPUBz6zB702tQucnX0gWaFh6DgPdmhXaapGotw0SFz1qDiTMdd8h45HfcqCPRUhA3+NmKz1l9teCPaMd4urGaewRitNBDdahR5c3AfQmDCFT9vmtQEwqAYXX4XI2n23Z9B/Yb1FL+LWox6wHGbZSo6FR1LzyG+3hriSZvWT6jfXhl2cmQZJDrAbuYAqAHo1GA/EOgD8eGcU7A8eDvH4fQBuAhBL/Zp/vamPTrRENDGLTV/7E1WEPLDlP/PwzU4YhusIMUgfIPAr6Dhv5R4y2r8ldFwiFoYHnmr8TAHbhRQSZOctH598ZYhqt6wP7q/ouqe77RJxvzFYaji/z4vna4v5cUMDXqDAJ5ytktqtBDckyjvJg04hl16LB0xFfyMfD77PZjErGQRRjYIfSvoAXntks0ok8MsUC4KARWnYPlJBeIgLeFrUgDOHYCag0/XNAbWgRwQuLAsaQwIhC1g7+jCNKuT38JfnYSyTi+QQEwwHeT4/dWHYxJPxfOj5oAnRQqgU3YgGZSOaDyK3n/qkDYBKptzR3oD6B4fyRKjp2AzSl80YR/3P+/1vBjX18Jbu+YsrMRgbqPP8zrDLTAaupphfeZtyPs9BPztpLSBZjowF3woYRwBwOWaqbev15b7X4RWsiqYiY6ZkFEIoUwUA2OrkeEQE8HYNyD/rl3m88jCGgO/nPW3xy8x4Q/HBcM1dYg5q8N+B/SBSYhtD0EY1PRGLDoKIBHF3yLz4H/gSYQJRETgqeB2d4vC8L2NVnQn4PoVJJAcP0inahAfdXVI8CFszjRagCTtRdV7Sr895NBpRKXIT64RMFw/iw5eChhEvmmyUIH+k+Qu3cLzOAN6ILlFvgWnx3YWFDz0f38ze9GlfP6UQ3ojEY0gtqRIEbA5/WgQFhsEuIeL75uTzvqHktAWfj/OD6sQXssROcGiRgFn0QVkld7OznMDT7CJKzhMIqxW9B+LCOQdH4uyxIcE49VTSeLj0wKjzcp2oDXQA8YoDEGBLMW0BJw+eAxXejPV/IXd59/tp5rVyYXDw5BlRetSpQAcvgfOwVM8ObzBq/AQ2wX4lwkQV3vNhYFfn2LFgaoDU1ogqsfqGkJYmrj9Tr22KQwBLzbLuzDeA9yzyJjVRfwegWq0H+FThDPA6ZhZwX2M2Kh4waovCzAWJTzD/qY00c+6PM8coz08VNqglzx54LfHuTJK7z2rwX35ABLg1DzsZ7Qv7l/f2yXDlbf4C/irg0MJ0aCuD0wP74MrxfdFlX7tq+vtRdCpvt599EG9Yz3V+P+Oj/n4zLruZHcJ7oMt/MNp9eD6HEeFb6/TMfbWo85Pb79HJo8t3371/PuIAZqMvjPC34nVV6ZB4hEuA7AzA5cfU0y2n6ux89D/35/n2/vWY5Bf0qwf3tPLISO1Tap9qzFB6eap/beqI94NCCbGwgqOItY3CGl446CaQ8i2Q9g0AvmgJOnBoAA0gu17tsKtKS7D4udgCYERy2QIceCX/P7mBW+g/7D9S6Mn50CS0eAoQPDcBjopIA5+EcxEjLweRjXq0UbLIjcBxsGx2IZvlf0ATjz/6qypAmY7bhrk4ahsIis6ccXKHdueAfUgk+RWPCLh42c6zEeKyJpRTdRAOqBbl/Wq/uT+q+Fx3FoTIuCzc6+hN8j4veGjuAnhSE5gKnco3A3XwYlq2sq+lmP4yEOpqEoG0M+mGDYuYT0pKCFHgLHKt3T7T9p8GcWH+n1UwGa8X6kQt2x4CeqPexegT6o/Z4Cr313PHdgrsS2ZReLfpKIf+IMFnmVmwxQ9AhithYT73+p2s+JIVfrjwiHnpAZrSsr9CMstQXP1+1+510N/q8E/YoekMN9OMFvi5LvkRDsy9rgFCOoPdpgaQIWBZjf5KCSQszZJ1ivTvLokpen6tsJAVND0NFqb6GUGg2Im4Dyx9Pn7/0dm4pADAslJzTv+dKNrAPQ0wyySm7bj1RQgbAXsRa4R+mBJzpaQmHLmy0BLoL+Nh2ZRca8uUc6P37k97n451fvTieAE8BdZ2ItqFEK6oOJIYPsiU4woo140Oh+H/UC++gatHYcOFT+2y3AYvD1rM/fpxdUcsAi70c0OxAEP45X/hymE9XeoC0zfYhbcqfbhs09HpwnKMDR6g0mmYyKth/UcLl9ITGQ8N1S6s+gA1HvQCc2pluPvN2Br8SyZyfyxPP/VhCi1L1HWX2CQCuAE8TIq/sBYdANZmTIwqq0sb0HIzhhugBeUpBZLFyA8y+EErsBUYDZHYN9QAAooQwOws+uQlhdESSSqk5Qsh8LSYI6LDS1AbmOvLlRBqQIeITvM36+TP63VfE5hFClCTr9zEyVFwS3STQBy66DMHB+PJWIrfgGnYBx2dTboPa2X49GaBVlePA7CFx4iaGi4ns0aLVjMGvtPTDtmO4XEE8E5Kb/8qYai+NHl60LgAICcUCoJPVeiYG6Pxw/X9VFNVbFn9FNPzXoIRDTyzcpREYB5Fm1EQQn3KRi9wKApR8Tz48SwxnV3qM0q7ZhpdKvr0zfY+gO4oQf+EGPFYW/Xf5hwWsUgxiBbShGoGIx+D2eH1h2EeR3UQMH4zMaUKr4033nzkSkfQADelFbLOQCalxdxvN8mInhPas9bxtGJw29Fx3Y8429MAS0fL33Oeo7qFZeiToCC3B/VSNYuU0fgDnkhxGgMFdxiYEY7MYel+OHPH30IMeVFK1C79l+QdXVpFqHlMAXEf3EYDyfkkGdNvJ8f3RAXU0jpgM7jMNA5yCrtfzOicKG/M9bgEkEjqqPPDEcDfqVwGZv6zcO9avDfOhf4OmLFd9OLBHHdxp51HvOBlnAoQksYjASA1xnIhPsapTCPjbsGB2YevpPpgM73EYeSYIftgPgte6CWesVBB9QEgfnWYMgoeC8ql69bWoRIqYHvSIv/u26bj/jdqZ9KSGk74JRo6QS9PuTiSHm6Z62kLUGH0UO4rwWrhtRETkR4iKRdI8giJ2D2nUCMjsA0TXiVDb98NAf/rCMlajA9wesWHZrAe1dlwRyVI2jx4KkyUHSx7YDe6YD4tOC6XW01puEdAJwaEJzf1uATHi6ZlSCpBQscsh6C1xRcWEG4bCFeKcAVhVlDu54JQIkTT21hptIT/Afk0kMcS9BKfjBJozcDXCrtgbWXxbMAw3INQIxtQJPAGwXmYaBbYh4SCsuKwLOAQ5awKskCMmRg8P3xwlBfbosQaDqyZqBkyQe1CLQACoTgN4qbyHsPwkTiF2pYaj6MAXBmUosQHnUEYCsBL3MW39SNKMJ5PfoBsT33DVJCEbFnBCMOkHfvj6Xq8uw+dgRIhGgAiUqf5QgKDFyhe8nnYrlqn9sG1GoAfirubygX4H+8IM1CmQrMFAJ5ExzKIp54nPoVU2Auh6eBShDlTV4u5c4HE/fVvjFrsII0Ik6QX+Iq68jB19ziLoKC27FYe0gC+j1RSS+BgB7AvAM3m8HLdy5fV60C8RMVuhD1ieQB32MCCq0QPJuvuw5IHF/geMKwOPdpmsxBwVEfGEOgeincJqNmuSFIPhPq/xM81CWIIi+gCFBqDX3QPYd2OcCRo6GZBoA3AM+00aesAOQ7/2Pe/vBCXoguD4OBD1WfPwClzcui12AuH+gC0gEwW72KfjBCQRBr05D0IQc7N8PzOCMehPWK384MPVDJQim7yDdoiRTItzzFV/ZOX9sYFetP0fsQzb6O7wOoFjxk89YoQXv+BmSN+yYHYO+BsDRAXHhuJXsEFbdIEGZQWUkNVNzGA9NZUVBIQL7jASR0AclE4Pb7JN3BO72mG92+o8UG3nybj+mASh0FsLKn9GPxDrEcS2Au35BzHO1BksriIJdpqWjKR1wlpR4fN977rZqI+XbYjYDgVDpcYQalOYKMiuQbB3G6Pu/HlMbi9a0EMkksXtjvvXTfgMKAEZRN/i/O7yD8Da2S2Bdh3ICWfp8yuMkYl5a4df4vVWt4UF0yyqEnaT6swYyWB8/j111Y1ERS9oB0SLMtBGDEBD1PEHwtdjUEAHnqmoHU4wCDAoAS+lHwtu9eQLUAgmxVvAuMB9cELMV3m8EUtcBYYI9nkNIEEJYrQeUHfnzzRyC39j8CgSkir/E0P2odnAmAqDnDIhqrtV9BDNS2POjv/0pwKr6z1h/PMz3uf9ykFYq9TtoAXSwpz0HljdvBCVAPY6t7osv6gFhMpkX13rcfXQMIpuTsfTibkfOPRAC2meLRipI4mDPwMD5x+v3+Ey+qEfACwoUEkKQSMZxYJDz9R68PyP43yvo2aYf881rNQbZgRU/jp80QnW/hdXqJxMvCFxXQSNHpE8QiF4XI+wFfQcw7VL2Md7RRajsKgh2D+6SLAKPF356+/7yXYBTUgFy/38StUjFHweD+iiHh8/LV/i/TSvGk4L5x7F6AsIKbgb4C0YjgdGRIToGUx7cgS3JKP8pRcgak95BJGQbjaJdBYQ1qHYnYHL8F45QgHx2gLMQ2cDxBD/4SeR0LSDi5XzPQNjM4ySE/HGG6g+ugltLNSARn281BPtNO72eJLjdX4ITSEgpQvJYFEUg24f1qAYQNQdxx6Q/RcB85j9f+03zf2QV33IDPHegNgPABTfqFR8cZK9TA7/ll0EQbUUHW8Gr1d+MSadia+LRHwhunv87yWoJ3h/pRDwJAbDNQQFd2P2mH4kP/wDT/ZeN3CK3+ZjvgVpw4r20AMafb58j4N1UMknuj6iCx883PU9g2VHVH5JX2eEcPghSgRBCKPzK0Q3fknwPN0Hk0CyC0zBkz//7duEetgFjVtypASDI4CsknYJgYDhqsBxxy29+eyxrAZX75EEf8f+CkOcijMDDHx4ASYGGu8WHgPwpHJc0qOG8FgFTuVk0cRZVePFwHEIUEu8xSHoL5qWg4I7/HgOKXe2dcnu2SSdCGIDTA+AcxY1zYL6Q6AAFu+/1GvjKPSeEoJV3NiM4Dz9C6oWkEav+NWjPWXNOIkKgNTi2I8LeBgaZHJxqrC4oNXoB9pzzMws/OW3ghSyQJgjbygOVEDhoj4nHLld8HPD6UUMFVLIgKrTL7cFoBRLQgEdXIseZ2/HhFPKbk4d5tYWwwR0nIFQSD2P5gQhs6meVfB+Bkyz2fOIvX/zxqsSODuAGIOLtPNnmIPCrv6Kqvgz3q4tCwNl9lWYfnsdHj2HTgQw5IBHwULmfSu1jEV3gDFSxTBmqSEVqiYK2IkWcRiAkwV/cyW9YhqHXDw9dkNQAcO6HFNJT7oChfrPUYc3KY17zAd+evAwF2w5SCKLV4EuCEKsKfjBVWHu9Q9Arh4CoBqEMWYBsNX7YgKP/69uC3M7/mOOz232QT+ox4iCyJGEFP4oBHd+GVvXBwX35nqp7qeIbV6L6tdZub3ueJ+gBIKgC6S5gOQFxDoGr+Bv2nzqbknd7ph/EmXzO0o+kZdc/wqvQkAOUffVMzKtYgx5Vob1/+HAfCdzHSiXHenX35/2JTr3KZ9Ruj2lYiMhLIFoNyMq9hFroeYMTE0bSLbhb4l3YlFPa6hMd2jk8dmrDgdQCnC4/+ANFlYTB6ATlx2GDGXP1rvL+SnWHw+cJes5/rRWt4H2pw9GklD4uSMpwasIQiaYR92gIyFX5S8dtRZt/nCAH48VXW3hRE/HKOsGquj8EM85Q9cfeAV4XwNGAlmIFIwPYrfLKuxV476RRetzcdeAsRSZhiHizCKEIOHn3EMOWy5X4uIJnXX6sFiBFLaBm/THOQAkVJK9j6TKwiSDTBWpwHkSPQJX7U959uAkoaTUuug6oQCBz1Zlxm0OJSIoIw04M+7zCGuYiznCfHww9AN6Ir+HXA7lfn2oBSJ2FOOh8SzINfmcAyITq8JX/sOMPx6A9LeYtVfwgCBZhdu25OB9/XmWWNPUEPD5dUuJ68wd1AqD2+w1PI9KxE9BW5t3z/igdYGWiL7L+wPv9jgVY8f0ZcbCKCuLAHN+c5wa69Zpr0J9t2KnpAGzyiAIPiFalJ8/xXrrA6Y+/8NoDnWCPNwFJzf5DpVkHte8hx76P+HU1+HEytEeSEIzAsu5r6wPJGu6oLz8VrKofXLce+ywIHhNa/Dmw8LrptWXZ4NKZm4pr/QQ7Qk8ehMrPtAF7PQCD309QgRgRZMKgAbFREAfBBXNalbHA9cEHMo4IgIUuPjjBWEUFEQpYTkhVO43eRiynJw9Jjj8TOUIlJExK+0wA4gWgQvcFBHAc7P4/u78/Ff4CC5ATB3P3oUwFClYgcALcxzp/B9Ez4DUV8RjBbsCBrMH4dLNwIDaCGhA6o3pXksdBvYBsktrXDgNJKAFy1Z+ZGIy5NXgXoBT8a3ZgVSPIUAMV6DjLxhsV8wX4n4ibbONObHNyCr8Z4FinNFjg8ziiF5zSV8A99u7Zdf5OisvVaAAAG3VJREFU/kIPAJLWX3hUIFD6o7MD4WkHIMXBk4IftSrPNBJVk0OoC7ice8HGS8XBKDoz/YFBLaQi392lGpCMJfhD9xVkx5Xbj73P9V4m1j0v73x9FjDDPlYvATkgFAVWcdNvJBamliOjAwRV0EpeRymAe717kMYRyy/j5FwFBX0fP7Dyx8gq8wn2ZXi8GfGYR+lFcGJSxa3Y84WgzBHetlU4cvKY44Ps4iP9fsgsPGEhQTAcHqwwGCj61SoPexKwasXFqtxq8qhD9SixoBBYcJEDNzmIoi3J7QkoJActVHocTVpPBCDhElAvMDK1PT/Sq3DwB/ygmyB9GNhYDH4so4Foy48kkPtZfZEv1PQTxYpyX0EI3Bu+/5krcN8fgwVdwWu2JNVNWAk+PcOOPMNdGFyAZ5Aj6gicgzNfwuHZg0HrLxBWfjSRl88fVCo/apX/IBrIvf65ZxtEoK9Bec4KZIPLe76osQns46NwW0pUPCPAyMc4A/KXOwZzFLGbAqD5xhhbgBcWfoJBAlarcCSQgdQJ+Movnih4gjZQTw51rz588y/ZgxVUEAQ8soCfX8OR26JwujCLGFAMsOjnwGrlPuQw9D/PPv8BYVR7pG/eeFtQpsLzR2KFI8SwKj9KlX++HeLOPuSBKrKeHBi7L4b+Kx184+ptAp4Trcscv69oARVYzWgaK01H1X0K3zNSmARKtxXYHvwJuT+8gLGGWgpHcWOmBeljFB2Ckg6wiAYOqfxEK3GMCAj6kIiTWdCBCXhkjUKMgJcLk271N9uLSbtvvK0S69OXAvoA5z94VsFubbmZvx4QAnXgBnJxENyQjy38wef81uPhxMpPJIQzr5ckuUTKe0wZyN57iFTWga8GvCwlh5UqvYgmaNV9XSxEVWs40kkosFwA70RgNOu8mLZfR6wDiwRa35y7j08NksqPQhcfkRBK/J8R75Iz+9C8gJpqzwiIeZII3QnYOkJWbVEI5jNuA+o2BwK82ifwnpSgHwaC+GNAdmW2VXfC+vPu6wR6lBj84C9WfvivZyUhZMJlJhjSukDlFJ3g4AvGJfC1iEpQJ/CaEd7G9wds7p71+odruKrHip/C7RdsxeVjzIxhoNkFGOW/+sk/YVAGtltfzZAIfzix8gcHhZCXpcGN2u69qWqD9OlRFAy7x2fQBhHUiETB+DocqvArYt98f+AEAXApsEmEcNLC0t2uPHCqPQIXwHYDfI4/9+8LMpchqr5HK39MJSrBXwnutNqjovjHFdq+fcHLp7YLR4mGgduW5hFpAXUoL4cTTuW5HJSkB5PC0S7A+8c+837DyoM1J9iv/po/o3BunlDqPjOSO/YbLFd+FGy9sxKFeT8b+nLNPrkAyD53FtT27yUS32yqUaEGTMBiASGcZ0FmK8nWxbvjC1q6WQC4VdWdAcBY8eFoAzIrC0b7Wt8wlPcIdE1FhUWeKU1Igv8Q/0dl4k/NnYSxdlDon8diUDeuQB4c8XVzcahRgyyZmNC+LAgeCfSVALde8/t1DCYawNoePGT83wlOpFUdOZKwxn89OsMEf0X8CxJCBN/dwKbFwkSMgx0ACJJDJD4iC1JEYh6XcEqVHpx4+J4I4UiAl26r5x64sttvSlAn3LBuQCz6edU8C+J5epBrC4YP52EFDgHrCw1B0eU9bOaTgh3wmYvQV3Oqqcf53XnVNXUBELX1xtSgFrirlII5d3HFulxBCNEfZx0h7K2f34XwdHpuYQcguN189Ow/nPXclaUcqMH5leCXjKOjbv3F0a7i2ZaRHmBe5zwnhA9S736ZC8AH8LHkg/T5znYgmES1dtuzGo92qwHIquiWX+4KgVLd8utv9Ml1BQNhEJW/FOgweiTguCUoQHkEwYhjfQIgm8eAzPKzHqAG5xGiiPyxeGRRaYetUpDVpHVC1T9bHGyaknb/TQTnuG7rDYwYCUT7/cMjtILzA+Go/FPw581F/mWeTkDuBsBCAK8ki+A29nMzPn4Rzjv6QV7xWW4fzQFUxb9jQQ1qc28kMi4mDl1NBr4usIsz5ltZqNm7AeJXfuTHd7nioLEyPBISU+8/tP1AC4Il/n+YGmjg2NiBRdl6yCw//zG5ph7bqaBuz8B4VMU/TqSsNPbwCeZA1cdxyG9SgKzRZPL+GXFOiH1/SFZ9wX8M3zUgvH8a4rMBjZj/h1W9MrwTiN6MlsCKiI4gycBzgV/xUaQGjGDHwHiYi0VIzeEAasCpNuL76AC7BIEl7i4AIxnAfoMxk35eJbZ68wWEUChs8IPz/EEE9BkUoNA4RCWSLJkY1h0Y/dG9bVCtUVPe7QRhtStXG4nOECDfUxc4Uw/Ik8JkA9o9+a83IrfHH11EdFUWc4phNgVFWkPsIHBnCvCCYBSgqEN9qtoXuwHhByYoJJA7BxIkkRwpDGgAHo+vQ3ZGOwCFJCJKUAx4MBpFZWvReeLgtBBkDDQu2OJxXa7SE/P4ZiUPHABjY1DsFIhPAaygWewiXK72hHjow/k8gCL6gKES8qcDZ7A+EhYlWCPGCX1wXIwzkQEKt8cP6iqkC0FEhFj/ZYtvXCtwuBLcDT5wXN+9H6ZEIkTwV/x/s78fXFX3siWHEKrC3tw7EFZ31Ll7ttknQyEMGgAqCaVe1bGk8r8nFWCQQR0h7CY0dsU/mIeIuA1AGCo02Q0YVXxub36sG1Qgfo0CBBUXxap+ECFEycQVyViBEBFPt14TK9rZHB9EwMG7DPXOv0OVHkdtx7OSCXfb3av4CFZGTwQBwT7/hKPHE4PzpJ4L4+FM9r1n8B+B+9R9I4Fu9brYUZgCunZWNxdQgIs8mASBQ4F8hJpEiaf4GPihk8FdAxin/kybjZjTj+mAQy6ihZ9whDvHAWB6BKrBXQr+5SBfqPaINwiz12UIwoTmbPACZY/fshBBBKNlW8ZCHwH/cVKSOZMm4Mxk4OwE9JeB+EFkn1IzcPQoiSB4vGgNeJSoik1A7m0TCmE/HrggB+/1M12C1Z18ACGoIeH1pH2IhAqFWgBq+kDFEWAvA3X8tpW0cnSD5WAOriOHhnYraF1eLTkS8P/QsHUBdtMPnOrMaANJE9AZiaKWII5Ue/8PTHn/UcCSTgIF2xN4zdmAQYIAKeBFl6FiO0aKfq5jcImHfPwTxcEdRmD3LcFoAva1Hdjm9UgGggI9YOoPkOBYLsT8HlG3nucMDGkOOJ8CkNOELdSO7D5qqAeJYBb2GpABgRi2gxLITgrOQ9C937HgB+0i7MeRx3gfPWCXLtgbLJAu/gCFBPzRX8eADJqCvA3FViC/BlOQC4LZyrBq8BdQAOUKoKjqR7v7EFfVFMojPgEoSlJesNIePyLHwW9NRgq7E6HvUN8A0yj0wyWDHRZ3J2A1jHdMyu3hCGwSDwdRir7h9VP7AKLgPoMCgKziOFLtrUm8aIFHlgxYfz8WBYUU55iAXauo+evJaIK/NTgRJM9sUcZRzcCnMdNKMJc7usnAyrpxHYkTRHK+n1HxS01LheAHqRWwKIDqLvQC0+PupHZgBawfVGsiniTVHwZHRqbUI/D4Cd+ftgyLAR1ehkIiqaKFw7MJEwUIuK5zsu4svoFYCFKgBJZACBuppOId2RDkPZas8H9kULcA9a0KTCQDGtpnzT+RMJiOGseHl4BQ1C29AWUXIIf/OIwwqoNEK3SCuA7FRiBrE9B4/PcrGJ1OQNj83F4Xbol/TgVHfMiIZLAdcaVkgh8sLrd+liNQH/FqsNTfj15m1J0X+ffZuq/gTY7QnvIfJz6UzBJLs83ItQpt3RfZz5iuGfNPajpngUm0R8DoA5jDlzsOTAwZjzsC3Jjxg7H914PjlcskGdghgx9HG4OOQH34uwQyzz61/0qiYNQjXxECuWYbGM/DrjtPH/Mw/K+gBLLSA+cEfPr4MroArzcDuybbr8Zc72i2UnzeHnTgzD4Ug78SzIvCoARVOQxaFFR3TzWnkkHUVFShEuqKxZnKz4p4YYcf8ZhYhuu8wFgSHcuuwCJagI4bgchJQK/qe9c/RT6nGcg6KGREJpb+MI0EY/b0jcsni3AJBeCQNsBOFVYoApcM2Aom4VFgIRdHpeIG8D3YaxBD+qCiQ+rBOSVnci8hzkAG1t/pgHA4uwDzmu8xFKkkkIqCfkIRs204r/hiDgutoAAcowBMZ9+KS0CcXVBOHCvJw2jMQSJyeoeExF2DuTuRcuWAo9sefyUQ6/oBaIjPtiRH1KvQKvygAHb171d+vc4GRMDPoxN/kL5pwlVh1mBQ1quQJAJ5j0TgOAis+h8d3mnC8xTKE34+8sDNjyVXE6nFMN+H39TQDmocHScENvN74LoGScGU4f7g6IG3n3C3qnG6JBS+Z5tHOOzRYQx+u7MZmAl0OSsRLAS/VIKfRAWU92+12aaVPksGDBWQuCMvgNy2M2Mt8EwqbjosZAec5xLEAmXmcFTHiOWARWglpNpjdEtBQRxJJU5VL5/7F1X86XntXgUK4q+KggsUoIIK8oA+kgy4+zLaACqQGTVOX6MBWdehL6BxHn+tlyBMDGAqufd7WOX5WTJwKYDfXJJP2GXDPk7Tj5Ed7BOG7DMFaBRAJgI/+H2Ngeb2SKb0zkoGlQBHkefDr7xMA5HZeJPtKIzyApI9gmnPgf1c3mulfhe0gFekDCdNFnrOwi4Gs6eTACNjB+Uegcgojog4V25P8bctRYY6RL8AJklE9ACFAGZdBEahd4d4CmghFhbzcwaXYH5qTlS6DY+KfNH5Avzjo2JJ0poDkSCMxLn73H/eB+ifvgvyIFCWAji7BWC8hd0qj0FziMdrS70BlVbgamIgcmotGZDNPwm0L9l5iHv7WRoAFx57ScFS2r2iwot8oKu8l+TOCOg2mZ2nFdjTgOFQENzKkJ8OjEnsE8f6AzyXwT6MNF3RDRnuj0Lwo6wTlBMDIyqaz6G+RiLJMg/KUrQV/rh9uH0tWduwoxmky0kSMQ+rnXxZsGadgnxfgk1pCnsIsGYltvfdzTOBIclIsN8MLAGcz5gBwj94AE8DuC9Molip/JGwB57nRyJiyD3pyk6q5ij+3TzRLohcqyqCEQBTepF15+WVmW8SEr5jMUUkx3oMIsrH3ndwAQganKzyMpOJNxMQooGBYwcByw7axIhgPRGEr6GSGJhkAELoQ1YRg+dPeD5IIRDIqq5PA2Jh0Rq0YcS8XBi0ghGRFpCtWTdum5+yLOsQf2EuYY8AfnbQZDgCjHxBSKwTGpt8QCIDVH3/4H5OwEvldhliINwAFLsEyyIfGKV+vm3eEehVqKTdNxtDiPoLHCRiuwTJxCECxMDqDjTvZ63KaPKvRgV2i/F3ohm88V8LN8hgJcXD5pVGIPPNn9EBqSQC0I4AMxBUcQNCkarkFgSn/oCs9GCVep4eUG5BRAOcQOCWlGSc3If0IFqRfURQGRrKewPKEJ9sLnIowKCcw+f48N6UHjqYtgInaCCkBbPSj8VEkCr2g8U43wY1xX/BNkwreQrzg+oaJghOCGTU8RBxuIp6VFOGoEXgEsBLIgV6gBgxoLSI5CgiYNT+GBHsU01GthrceiMUtv9KgAYktgVNeGrBbtiOQVi9x8WjiAW7UNUnm4Vet7WtsFgDCDYEwQ/EVL1PnQf/xCDLTowTh4c4HPRDoQaiwhKIAae4B7xgCBydI/CDPOrevK0FR4p6w3VfoXgQiB3T1N8Y1PCD0X19JqcHGfzB5WkQE4p/kdeXBcEVUXEIFqSij82lMyrWq/7c+LFHA7z5/dwOHHg8s/Y8C2CmhbmALtare+4UWLfb25BmXABKABTniC8gRAP2yvDAiUAsElnrxFzITQa/sAFecAOY7zPV/8jMQHSbWAiUPGkQNABhw85xrSCv+mMSzFR8+7mjw01A8f4F8S/td4jnDHYxpT8/OEyV3gz2+GTfdAeAszswfJNGlQhEIjB0Bls0BKn4Iw7WKu9f1gmSagmvqleEwJwnZwjO7npz1HdCJ1hS/mlBcRXyF3i/M7NxqJFoeH27z7nnJaBmpUZKHsTbGUc1ALEoIGsGYl9ixS50gjAT/VhB8IzvGTrBVfWEz1MzAkRFTtecW731VdjNQPukVdhdn0Y8d/a7WYH6i/TBPBzUFwAlHwtGHOQISrgb1AMUgDETTA3+THAdeRJhg59V/Ektofa9I8wxVICkC7QQSAd2O3cftzPzdMK6aA4iZI4ILfYRbb9RgqICt2AxVnYZ4kkBvHOBxT/zN9ybHx/f5Ql2fkGCX6ANm6F8WCfqAS+Eq5AGcHJd2IFHagTMHAAj+mWBnDXuc81CjhsAi5dL2K8QCYI1aJ/PJtSSxEFXASv7C2I3ZB9/a0j/7nDn/j1pHsz9Jr8fNpxPBUAUUYD4wz5GBlmyAiORjtAIGDFwzSUwqiNZ1d1tPiB7/Q9VeI9KeJU16/knkEeQJEALjY4rkp74fCZiMDSA/PgvT/aT2gYgp5E/P29AKBQAo6TRth5T4VesQFb0i4K7RA2MZpgyFXCEQHCOixuYMPgy2L7+45ezSSKt2oUkURlpXkEMOLSiXPuDQZjk63N5bmzOSxQdLHX7AhwUEA0BAeQPJIQzkAuFlOK/GtyLdiGDKEBdllQ7YouxV2Xdwza9So4Kp5Z0yAgUhTlJgFzSFrznIHYIwKcCu2/L3LsCg6UI1b1/CA+ApIV5/32HqOIjdQusE4azip5Wc1b0q/QGIAlaWEJbXP3r/L+AEipw/+BtkQVY9fIM2i/ZhgVEgJO6DZ1ksVtlYdoQAPhVO0oKmYBmnAYco4DRCRB3TwCziptaE0auER9/VzRqKNOEYINOQg2m1l9GpGNQAhh1v6UmxNQh2M4+LmlUzll0OTjYQOaGlZAEMCrdhmBphaMBwBADrSQQc3//He8KgFETT7p6BHnjj2X9EXsDjrgBS6ihoAmcSQVYmE4JgYWFpp1waAQRoqDzxDhU+HxSnZHz/9JEY6Y5MJA+cwoWrt99+U3Mc/9g/NQTFaigAEtwB1yBzwzucZSX7RZEILhR1d5GDCsBLVUdIQvsldZfEJt5i/MHx2hGJZFkVVyK242iFeh58oBUFqIQbkfp2DV2X0CkAYgv1sU+P+I/HmBu8nErugdRnUWhfp+A/ddlbEH3uQlBsNobUEMHasK1HOYn8BEEvCUaiuigXRIKj+sGOPA4KAWz9/s7WxcgB4+a6/fI2osEwv4yOENAiPf+wQhbc/5f0gGisWuQaRFmGoIqguARWsBQgTTocDLMT5OJUQnhqdCEig+/EShKSEgTVV0MBMnz04BcshPnLk/+OaV0/dwKzB4QUt1NB6uTDfGOP+cNm9mEsBAFiM7AQh9AKVEU75vy68jeOxrUC4mDEuYO0oLqoSdHaEF2eXYYSm0V+oEOwpLmYFOF3Z4CmAeBTIGueiIw2xoKPzDBJVBXQ5g5O8/twwA+QguIjJt3+g0NQEcDfUXgO5gsqlTBLkQLdl86K3CWneitQ8sg/5oWAUJP2C3V3RoEyji5n4b9lB4t9pz2CA+cAFn1Z9I/uzYsU/ELtEBOCHYQQqGcFejV+yeuRJX31zsKV5IGjway9z6PLDxKwNEPsBuOEiqw57jGgOtZ1Y++T50AuMFl7hPIbhskiOwsATtRoc7rS7dXrpcgrMCGJca6ELJo+Y0be0BW5ZKGcFz4y8W9BduwcDnK9iO5fagsKpp9ANnvDPxeP8THNyIVFo1AMas8Qk5v2Ytm0LCCYAXqn+wQsPTBh/5Bcnne14Os3uCQt28vsK1WUESJFviBgAW//3u9PLxusXchcCR2WsNzv/ImvgZzzkUByDUAIrjTvmSHAowpJBQE4SUlxMxnARlQbIqkArVAJ6pBBvELCCKlkyCDAP45BYfEPfcUpfMch3Vn4bheYK4E66BxAxHSVd5INgEPgU/NBCDfNQ8Ho1CoINAPQAW/QT8OCIZlNFCB84XhoDChFByHGjx35v9BLgyhmojqHYb5QYXnuAecvua0hZe6BV9f7v4ibvgvamrmAc1TmaEir0LQ9h97eYAYVoM/nWA60i8Q3Ifezha9BqaaL3zvqd6IAuwwLSCCuCLuJWch4h30giPtyiAphKEBcCu9BV5wwzkMxID8rhMwdwMhcSFgrBT3RUTQboAUg3+p+Qe1IGarOioVnazmefV3lHpwA0AcLWCahUiXwePHWJsP+GH1gnp/we5KfOhJAbsj0H/BIEb04TbrTPsAyb2LLu93KwfCvn5PLAwrOXAa72eEQRo1CNdw5IprsAZ3hApy9zlcITG2vpCihsRSYxNS+J4vdBZ6B52eqRcQ/QXmSjAWSfa/5GA5qEg4iJFtm624AqXLrSA2gx8p1Mdqcghv41S0lSp/xAYs9gakQc4Ie2RTUYwYgt748mV+FU1Xgp14eW3XYZ6cdqGTNHwHICTwEeTPl0jEZwIgP9gDEaogeg5IHWCF+1eoAhvEKPB/EAeTRsM/pSAP5wjWEUMM1/NJRhwJbpJSgK7S7zF3EOsI5jBQBK9DV80Z8Y0COzvmWzJXgDl40KEC6cqvqgi4OB5cpgLFYK/1CvDiItXqC6/S87wfAUfPtxqfGNzlYaOjlf1IsHPPvffHgDAoEeEST4ZLZUd/RSo91/BjXY5ggWgQ4In3fyj4mUqPrInHOCLKO3wUwRsfyXpt1nEIRLrqcWeTuk7bigsbid1zD4iDRQtnIdQsyIXnFCn1I9D7ADgxEhOvR5AJosoUbu1FkJyYCi9OhQERoIx+4AX/YqUXQhtYEwKN4Cy1HntLMmtaAQpqfrT/UCoLSxeswjA5UWPPi0mjajUWxMTdVusNvt/ChMdmILK5IRMFu90BMEzFYHdg2GAgeYVHMMJIBTA7EFTx/5fpgTFXz9w/en0ZjD8kCDoKPNGwlB01BmoWQbh+AxR689mBponGJOr9OwmMu3dtJ/ylW1Tik4ElUPmR9RqII+pVhD9ychABMQ51gOIZg+/G+5mGIzLB1JJC5WhzYjhJ7IWmLDpA8jzsAafUPkB2WnFBF4iSxkq1ty7f25rv/+EQLOxs2oUdTSA9HIR9swdBlCcFe9owPC3XWDDC0ISVzsEVbSCF/sWdA5Fu4HJqankp2SeQCYYrImNalfmhpVxYrGkUS4LeSUjg8dD7+D7w/ybIfy7vlB9/HJ978zr7/45Qgajzj+4EjIK/ULHPRAOlKr/aG0AFcqCyu0GcW45Igh6JMJmhA49/U+cEssHNJhtXDC1MOya3j/sAiAGcrEtqtgjBD6wEzSDc7D8o6C8rIqAZyPk+NQoNLAZ1hR64Yl1FBY648smUYKnSg1Xwk/0DyRyArByMUobyByhCcPnOaPyoegREFS4jNfYAw+IHCjdC1J2WDZBke/OyN85J24WiXwDYPoJyYuCD238ulvuzwt6KgHf0shWKsqCFFGjB/w8HU8eeTED9wAAAAABJRU5ErkJggg==";
    _environmentFuzzBRDFBase64Texture = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAF9UlEQVR4nGWVy64eVxGF16X27u7/HMcyuZGYAINwmTBigngBXoc34El4B0ZMGDJjFCExQUIKiRKZYBITHdvn/L1rF4P+c+yEUqmH9WmtrrWLkdB4C1/91h/9yn947D8+8CfdlBeGGAMtqwNd6K7VWAJrw9qwLtw2nDaernh6wKuHPD3S1Vs6vaPT97W9r/Wx1seKUWj7Uzz6vX79T//wF/Gbx/7rw/jsFB/39nlrX7q99LKrp5bJZXAtrqW1uJIncbNOXafBU+o0tZW28got0AJ3KACsE4OfYvmzfvDMb/+4//Td9snD9rfr9vHWnyz9361/1fpNLLde0mt5pTZ7a9pCm32SrqQTfZI3aqNXHAwvcAB4BPwnk/oMEcqX8eaz1t9cHjxs7133f5z6p2v/Ylme9eWmLbexjlhnrPBirz3WxWv30rw0L/Yi96PpDrcDcPMEfq+qvQCfsFF1blcv2js3vb2xLNd9O/XT1p8u/Vlfnvd+25bResXC6BFLj2WJpUdv7uEe0exGByPoOAC//BH+cgNqUjfkU4mOEetde+O2vf+y8br71Nva+9q/XpYXvZ97z9ardUXrra3RerQWrUU4myLk4AzYiADwJ+NRQ41i7MSNEBIcM5YR1+f21rnlXcPWtbVYW1/a7dL21mZvbK211lv01lpEtIi0MxTmFGzMAABAN6gF1CTPxI1gkXa5Z5xGPNrbfo6xB/bQubW9nXvkHtXDPfqIJd2bI+1mpZjmNK17QFuxDzhBJued8Fy0KLvcp7fpNzJuM3JE7daIWGKMqAylW0bLiHQ0e1ppTXEK8Qrwkzv8fUIua6oG553wQpRIme7lbfpBxm3GnoEMZ+wZlYGMlu6pNh1pT3nqALCEugCeAB2ohKqYk9hZd4JFS5ThDm/lB9N305nGtKfnNKZiqk23qZhySZOcYhHFewXfI54UMCBDOYlU3TMkSaYWaCtdwXu5yprOKUxrqk9FyUWXNKXiBfCNgucGboGAUBwUJzFYO3G+MCwFtdAn6K6UZZSyXCXBAUVdGCoS5IVxAcQNujAHKCiLLHJqDtWZh1GHV0Et8EYNqOABTUhglKJoyKBBgSwCBC6Ajz7Azz+GiJbwhFTkZCXnEM6EJcuHDmmlztCkBE2IkMGAAhQoSCBBvgYA0G6xN4DgLE5IU5iqZA1hJ8zDqCY2qktJHfEnZSpIk6bE++kEXwHUEBMCmBBBFzE5UzNZuyBRshlSSF0aEg6MaDHIgyFCPAqvA/YdIjTgQ3WBLNZkpWoQPnRIUljdGiIkHd9jumgeO0ESEI97cNTPJj6Z4ISOZh1JUSVLwiAs7pRp02aTypRUhwIzjvhfPCKF1wH/BTqwA5pQlnYyipgs6dDBQVncZatZaZUlsUxZYVq0jyfm8kNeBzz/Gu0ETrjABAURAoTJOVVJpDAoM3ZOc5olfmMK42CYMrRTAr6tIK6QiSA84VtIIEosslSTNYUkUxyS5aEDQ6tMmQ7YDMOmjziYx8E56oPEl8DdDgM2/BLeIJVw9CRSTClZg97ZrDl0BF6m49V0GTIZQL4CvNuxFj47w4ASmqUkAalYU+DBoIbK8hAG506aZTLonWFG0IMa1AAHXlegW9wFGuAJG97hhFkqiuCxUZyqSSWR5GCZHKxB7nSwDcZADHiACQ4eJ/Oot9+BvsaLQD2Hby9RUEEs1cUlcdKpmWKSQ2VyqAY56J0RiEEPOqHxXYv2W4yJuANWxBkBOKEGFcwyjlhMYdLJSjLJpA8FAxqMwXZRQA0wgdQ94Hcf4nqDFnQhBDcY5YJUIqSSpnxpRqone6ol+2Af7Il2MJJxnN/8lgIA8yWQUKItaBMRsGEdDIrQoYNTnGSyBqdZQSY16IEYaANOOKn/A+htXH+OdgLOiB1BBOEGCz5ejmO6JpGEeexVJTmohJNORqIlnVDyO4CvvsT2AGm0BVEHo0IMHeEooeQipzDFY5eSNcigLgwoGYlIKHF/ky9Z+xD/WrCfoQUuRCGAKBhlwIBRQvmSuykkMYHkqx7EAPK+/wdqEbWmfB0bfwAAAABJRU5ErkJggg==";
    InstanceNumber = 0;
    loadBRDFTexture = (scene, textureData, textureProperty, textureName) => {
      if (!scene[textureProperty]) {
        const useDelayedTextureLoading = scene.useDelayedTextureLoading;
        scene.useDelayedTextureLoading = false;
        const previousState = scene._blockEntityCollection;
        scene._blockEntityCollection = false;
        const texture = Texture.CreateFromBase64String(textureData, textureName + InstanceNumber++, scene, true, false, Texture.BILINEAR_SAMPLINGMODE);
        scene._blockEntityCollection = previousState;
        const texturesCache = scene.getEngine().getLoadedTexturesCache();
        const index = texturesCache.indexOf(texture.getInternalTexture());
        if (index !== -1) {
          texturesCache.splice(index, 1);
        }
        texture.isRGBD = true;
        texture.wrapU = Texture.CLAMP_ADDRESSMODE;
        texture.wrapV = Texture.CLAMP_ADDRESSMODE;
        scene[textureProperty] = texture;
        scene.useDelayedTextureLoading = useDelayedTextureLoading;
        RGBDTextureTools.ExpandRGBDTexture(texture);
        const observer = scene.getEngine().onContextRestoredObservable.add(() => {
          texture.isRGBD = true;
          const oo = scene.onBeforeRenderObservable.add(() => {
            if (texture.isReady()) {
              scene.onBeforeRenderObservable.remove(oo);
              RGBDTextureTools.ExpandRGBDTexture(texture);
            }
          });
        });
        scene.onDisposeObservable.add(() => {
          scene.getEngine().onContextRestoredObservable.remove(observer);
        });
      }
      return scene[textureProperty];
    };
    GetEnvironmentBRDFTexture = (scene) => {
      return loadBRDFTexture(scene, _environmentBRDFBase64Texture, "environmentBRDFTexture", "EnvironmentBRDFTexture");
    };
    GetEnvironmentFuzzBRDFTexture = (scene) => {
      return loadBRDFTexture(scene, _environmentFuzzBRDFBase64Texture, "environmentFuzzBRDFTexture", "EnvironmentFuzzBRDFTexture");
    };
    BRDFTextureTools = {
      /**
       * Gets a default environment BRDF for MS-BRDF Height Correlated BRDF
       * @param scene defines the hosting scene
       * @returns the environment BRDF texture
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      GetEnvironmentBRDFTexture,
      /**
       * Gets a default environment fuzz BRDF texture
       * @param scene defines the hosting scene
       * @returns the environment fuzz BRDF texture
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      GetEnvironmentFuzzBRDFTexture
    };
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrBRDFConfiguration.js
var MaterialBRDFDefines, PBRBRDFConfiguration;
var init_pbrBRDFConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrBRDFConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_materialDefines();
    init_materialPluginBase();
    MaterialBRDFDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.BRDF_V_HEIGHT_CORRELATED = false;
        this.MS_BRDF_ENERGY_CONSERVATION = false;
        this.SPHERICAL_HARMONICS = false;
        this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = false;
        this.MIX_IBL_RADIANCE_WITH_IRRADIANCE = true;
        this.LEGACY_SPECULAR_ENERGY_CONSERVATION = false;
        this.BASE_DIFFUSE_MODEL = 0;
        this.DIELECTRIC_SPECULAR_MODEL = 0;
        this.CONDUCTOR_SPECULAR_MODEL = 0;
      }
    };
    PBRBRDFConfiguration = class _PBRBRDFConfiguration extends MaterialPluginBase {
      /** @internal */
      _markAllSubMeshesAsMiscDirty() {
        this._internalMarkAllSubMeshesAsMiscDirty();
      }
      /**
       * Gets a boolean indicating that the plugin is compatible with a given shader language.
       * @returns true if the plugin is compatible with the shader language
       */
      isCompatible() {
        return true;
      }
      constructor(material, addToPluginList = true) {
        super(material, "PBRBRDF", 90, new MaterialBRDFDefines(), addToPluginList);
        this._useEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;
        this.useEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;
        this._useSmithVisibilityHeightCorrelated = _PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
        this.useSmithVisibilityHeightCorrelated = _PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
        this._useSphericalHarmonics = _PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;
        this.useSphericalHarmonics = _PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;
        this._useSpecularGlossinessInputEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
        this.useSpecularGlossinessInputEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
        this._mixIblRadianceWithIrradiance = _PBRBRDFConfiguration.DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE;
        this.mixIblRadianceWithIrradiance = _PBRBRDFConfiguration.DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE;
        this._useLegacySpecularEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_LEGACY_SPECULAR_ENERGY_CONSERVATION;
        this.useLegacySpecularEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_LEGACY_SPECULAR_ENERGY_CONSERVATION;
        this._baseDiffuseModel = _PBRBRDFConfiguration.DEFAULT_DIFFUSE_MODEL;
        this.baseDiffuseModel = _PBRBRDFConfiguration.DEFAULT_DIFFUSE_MODEL;
        this._dielectricSpecularModel = _PBRBRDFConfiguration.DEFAULT_DIELECTRIC_SPECULAR_MODEL;
        this.dielectricSpecularModel = _PBRBRDFConfiguration.DEFAULT_DIELECTRIC_SPECULAR_MODEL;
        this._conductorSpecularModel = _PBRBRDFConfiguration.DEFAULT_CONDUCTOR_SPECULAR_MODEL;
        this.conductorSpecularModel = _PBRBRDFConfiguration.DEFAULT_CONDUCTOR_SPECULAR_MODEL;
        this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];
        this._enable(true);
      }
      prepareDefines(defines) {
        defines.BRDF_V_HEIGHT_CORRELATED = this._useSmithVisibilityHeightCorrelated;
        defines.MS_BRDF_ENERGY_CONSERVATION = this._useEnergyConservation && this._useSmithVisibilityHeightCorrelated;
        defines.SPHERICAL_HARMONICS = this._useSphericalHarmonics;
        defines.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = this._useSpecularGlossinessInputEnergyConservation;
        defines.MIX_IBL_RADIANCE_WITH_IRRADIANCE = this._mixIblRadianceWithIrradiance;
        defines.LEGACY_SPECULAR_ENERGY_CONSERVATION = this._useLegacySpecularEnergyConservation;
        defines.BASE_DIFFUSE_MODEL = this._baseDiffuseModel;
        defines.DIELECTRIC_SPECULAR_MODEL = this._dielectricSpecularModel;
        defines.CONDUCTOR_SPECULAR_MODEL = this._conductorSpecularModel;
      }
      getClassName() {
        return "PBRBRDFConfiguration";
      }
    };
    PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION = true;
    PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED = true;
    PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS = true;
    PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION = true;
    PBRBRDFConfiguration.DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE = true;
    PBRBRDFConfiguration.DEFAULT_USE_LEGACY_SPECULAR_ENERGY_CONSERVATION = true;
    PBRBRDFConfiguration.DEFAULT_DIFFUSE_MODEL = 0;
    PBRBRDFConfiguration.DEFAULT_DIELECTRIC_SPECULAR_MODEL = 0;
    PBRBRDFConfiguration.DEFAULT_CONDUCTOR_SPECULAR_MODEL = 0;
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "useEnergyConservation", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "useSmithVisibilityHeightCorrelated", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "useSphericalHarmonics", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "useSpecularGlossinessInputEnergyConservation", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "mixIblRadianceWithIrradiance", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "useLegacySpecularEnergyConservation", void 0);
    __decorate([
      serialize("baseDiffuseModel"),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "baseDiffuseModel", void 0);
    __decorate([
      serialize("dielectricSpecularModel"),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "dielectricSpecularModel", void 0);
    __decorate([
      serialize("conductorSpecularModel"),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "conductorSpecularModel", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrClearCoatConfiguration.js
var MaterialClearCoatDefines, PBRClearCoatConfiguration;
var init_pbrClearCoatConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrClearCoatConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_color();
    init_materialFlags();
    init_materialPluginBase();
    init_materialDefines();
    init_materialHelper_functions();
    MaterialClearCoatDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.CLEARCOAT = false;
        this.CLEARCOAT_DEFAULTIOR = false;
        this.CLEARCOAT_TEXTURE = false;
        this.CLEARCOAT_TEXTURE_ROUGHNESS = false;
        this.CLEARCOAT_TEXTUREDIRECTUV = 0;
        this.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;
        this.CLEARCOAT_BUMP = false;
        this.CLEARCOAT_BUMPDIRECTUV = 0;
        this.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
        this.CLEARCOAT_REMAP_F0 = false;
        this.CLEARCOAT_TINT = false;
        this.CLEARCOAT_TINT_TEXTURE = false;
        this.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;
        this.CLEARCOAT_TINT_GAMMATEXTURE = false;
      }
    };
    PBRClearCoatConfiguration = class _PBRClearCoatConfiguration extends MaterialPluginBase {
      /** @internal */
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      /**
       * Gets a boolean indicating that the plugin is compatible with a given shader language.
       * @returns true if the plugin is compatible with the shader language
       */
      isCompatible() {
        return true;
      }
      constructor(material, addToPluginList = true) {
        super(material, "PBRClearCoat", 100, new MaterialClearCoatDefines(), addToPluginList);
        this._isEnabled = false;
        this.isEnabled = false;
        this.intensity = 1;
        this.roughness = 0;
        this._indexOfRefraction = _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
        this.indexOfRefraction = _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
        this._texture = null;
        this.texture = null;
        this._useRoughnessFromMainTexture = true;
        this.useRoughnessFromMainTexture = true;
        this._textureRoughness = null;
        this.textureRoughness = null;
        this._remapF0OnInterfaceChange = true;
        this.remapF0OnInterfaceChange = true;
        this._bumpTexture = null;
        this.bumpTexture = null;
        this._isTintEnabled = false;
        this.isTintEnabled = false;
        this.tintColor = Color3.White();
        this.tintColorAtDistance = 1;
        this.tintThickness = 1;
        this._tintTexture = null;
        this.tintTexture = null;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
      }
      isReadyForSubMesh(defines, scene, engine) {
        if (!this._isEnabled) {
          return true;
        }
        const disableBumpMap = this._material._disableBumpMap;
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
              if (!this._texture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
              if (!this._textureRoughness.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
              if (!this._bumpTexture.isReady()) {
                return false;
              }
            }
            if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
              if (!this._tintTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      }
      prepareDefinesBeforeAttributes(defines, scene) {
        if (this._isEnabled) {
          defines.CLEARCOAT = true;
          defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
          defines.CLEARCOAT_REMAP_F0 = this._remapF0OnInterfaceChange;
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
                PrepareDefinesForMergedUV(this._texture, defines, "CLEARCOAT_TEXTURE");
              } else {
                defines.CLEARCOAT_TEXTURE = false;
              }
              if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
                PrepareDefinesForMergedUV(this._textureRoughness, defines, "CLEARCOAT_TEXTURE_ROUGHNESS");
              } else {
                defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
              }
              if (this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled) {
                PrepareDefinesForMergedUV(this._bumpTexture, defines, "CLEARCOAT_BUMP");
              } else {
                defines.CLEARCOAT_BUMP = false;
              }
              defines.CLEARCOAT_DEFAULTIOR = this._indexOfRefraction === _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
              if (this._isTintEnabled) {
                defines.CLEARCOAT_TINT = true;
                if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
                  PrepareDefinesForMergedUV(this._tintTexture, defines, "CLEARCOAT_TINT_TEXTURE");
                  defines.CLEARCOAT_TINT_GAMMATEXTURE = this._tintTexture.gammaSpace;
                } else {
                  defines.CLEARCOAT_TINT_TEXTURE = false;
                }
              } else {
                defines.CLEARCOAT_TINT = false;
                defines.CLEARCOAT_TINT_TEXTURE = false;
              }
            }
          }
        } else {
          defines.CLEARCOAT = false;
          defines.CLEARCOAT_TEXTURE = false;
          defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
          defines.CLEARCOAT_BUMP = false;
          defines.CLEARCOAT_TINT = false;
          defines.CLEARCOAT_TINT_TEXTURE = false;
          defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
          defines.CLEARCOAT_DEFAULTIOR = false;
          defines.CLEARCOAT_TEXTUREDIRECTUV = 0;
          defines.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;
          defines.CLEARCOAT_BUMPDIRECTUV = 0;
          defines.CLEARCOAT_REMAP_F0 = false;
          defines.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;
          defines.CLEARCOAT_TINT_GAMMATEXTURE = false;
        }
      }
      bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
        if (!this._isEnabled) {
          return;
        }
        const defines = subMesh.materialDefines;
        const isFrozen = this._material.isFrozen;
        const disableBumpMap = this._material._disableBumpMap;
        const invertNormalMapX = this._material._invertNormalMapX;
        const invertNormalMapY = this._material._invertNormalMapY;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if ((this._texture || this._textureRoughness) && MaterialFlags.ClearCoatTextureEnabled) {
            uniformBuffer.updateFloat4("vClearCoatInfos", this._texture?.coordinatesIndex ?? 0, this._texture?.level ?? 0, this._textureRoughness?.coordinatesIndex ?? 0, this._textureRoughness?.level ?? 0);
            if (this._texture) {
              BindTextureMatrix(this._texture, uniformBuffer, "clearCoat");
            }
            if (this._textureRoughness && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE) {
              BindTextureMatrix(this._textureRoughness, uniformBuffer, "clearCoatRoughness");
            }
          }
          if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatTextureEnabled && !disableBumpMap) {
            uniformBuffer.updateFloat2("vClearCoatBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level);
            BindTextureMatrix(this._bumpTexture, uniformBuffer, "clearCoatBump");
            if (scene._mirroredCameraPosition) {
              uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? 1 : -1, invertNormalMapY ? 1 : -1);
            } else {
              uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? -1 : 1, invertNormalMapY ? -1 : 1);
            }
          }
          if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
            uniformBuffer.updateFloat2("vClearCoatTintInfos", this._tintTexture.coordinatesIndex, this._tintTexture.level);
            BindTextureMatrix(this._tintTexture, uniformBuffer, "clearCoatTint");
          }
          uniformBuffer.updateFloat2("vClearCoatParams", this.intensity, this.roughness);
          const a = 1 - this._indexOfRefraction;
          const b = 1 + this._indexOfRefraction;
          const f0 = Math.pow(-a / b, 2);
          const eta = 1 / this._indexOfRefraction;
          uniformBuffer.updateFloat4("vClearCoatRefractionParams", f0, eta, a, b);
          if (this._isTintEnabled) {
            uniformBuffer.updateFloat4("vClearCoatTintParams", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintThickness));
            uniformBuffer.updateFloat("clearCoatColorAtDistance", Math.max(1e-5, this.tintColorAtDistance));
          }
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
            uniformBuffer.setTexture("clearCoatSampler", this._texture);
          }
          if (this._textureRoughness && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.ClearCoatTextureEnabled) {
            uniformBuffer.setTexture("clearCoatRoughnessSampler", this._textureRoughness);
          }
          if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
            uniformBuffer.setTexture("clearCoatBumpSampler", this._bumpTexture);
          }
          if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
            uniformBuffer.setTexture("clearCoatTintSampler", this._tintTexture);
          }
        }
      }
      hasTexture(texture) {
        if (this._texture === texture) {
          return true;
        }
        if (this._textureRoughness === texture) {
          return true;
        }
        if (this._bumpTexture === texture) {
          return true;
        }
        if (this._tintTexture === texture) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
        if (this._textureRoughness) {
          activeTextures.push(this._textureRoughness);
        }
        if (this._bumpTexture) {
          activeTextures.push(this._bumpTexture);
        }
        if (this._tintTexture) {
          activeTextures.push(this._tintTexture);
        }
      }
      getAnimatables(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
          animatables.push(this._textureRoughness);
        }
        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
          animatables.push(this._bumpTexture);
        }
        if (this._tintTexture && this._tintTexture.animations && this._tintTexture.animations.length > 0) {
          animatables.push(this._tintTexture);
        }
      }
      dispose(forceDisposeTextures) {
        if (forceDisposeTextures) {
          this._texture?.dispose();
          this._textureRoughness?.dispose();
          this._bumpTexture?.dispose();
          this._tintTexture?.dispose();
        }
      }
      getClassName() {
        return "PBRClearCoatConfiguration";
      }
      addFallbacks(defines, fallbacks, currentRank) {
        if (defines.CLEARCOAT_BUMP) {
          fallbacks.addFallback(currentRank++, "CLEARCOAT_BUMP");
        }
        if (defines.CLEARCOAT_TINT) {
          fallbacks.addFallback(currentRank++, "CLEARCOAT_TINT");
        }
        if (defines.CLEARCOAT) {
          fallbacks.addFallback(currentRank++, "CLEARCOAT");
        }
        return currentRank;
      }
      getSamplers(samplers) {
        samplers.push("clearCoatSampler", "clearCoatRoughnessSampler", "clearCoatBumpSampler", "clearCoatTintSampler");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vClearCoatParams", size: 2, type: "vec2" },
            { name: "vClearCoatRefractionParams", size: 4, type: "vec4" },
            { name: "vClearCoatInfos", size: 4, type: "vec4" },
            { name: "clearCoatMatrix", size: 16, type: "mat4" },
            { name: "clearCoatRoughnessMatrix", size: 16, type: "mat4" },
            { name: "vClearCoatBumpInfos", size: 2, type: "vec2" },
            { name: "vClearCoatTangentSpaceParams", size: 2, type: "vec2" },
            { name: "clearCoatBumpMatrix", size: 16, type: "mat4" },
            { name: "vClearCoatTintParams", size: 4, type: "vec4" },
            { name: "clearCoatColorAtDistance", size: 1, type: "float" },
            { name: "vClearCoatTintInfos", size: 2, type: "vec2" },
            { name: "clearCoatTintMatrix", size: 16, type: "mat4" }
          ]
        };
      }
    };
    PBRClearCoatConfiguration._DefaultIndexOfRefraction = 1.5;
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "isEnabled", void 0);
    __decorate([
      serialize()
    ], PBRClearCoatConfiguration.prototype, "intensity", void 0);
    __decorate([
      serialize()
    ], PBRClearCoatConfiguration.prototype, "roughness", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "indexOfRefraction", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "texture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "useRoughnessFromMainTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "textureRoughness", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "remapF0OnInterfaceChange", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "bumpTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "isTintEnabled", void 0);
    __decorate([
      serializeAsColor3()
    ], PBRClearCoatConfiguration.prototype, "tintColor", void 0);
    __decorate([
      serialize()
    ], PBRClearCoatConfiguration.prototype, "tintColorAtDistance", void 0);
    __decorate([
      serialize()
    ], PBRClearCoatConfiguration.prototype, "tintThickness", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "tintTexture", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrIridescenceConfiguration.js
var MaterialIridescenceDefines, PBRIridescenceConfiguration;
var init_pbrIridescenceConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrIridescenceConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_materialFlags();
    init_materialPluginBase();
    init_materialDefines();
    init_materialHelper_functions();
    MaterialIridescenceDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.IRIDESCENCE = false;
        this.IRIDESCENCE_TEXTURE = false;
        this.IRIDESCENCE_TEXTUREDIRECTUV = 0;
        this.IRIDESCENCE_THICKNESS_TEXTURE = false;
        this.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;
      }
    };
    PBRIridescenceConfiguration = class _PBRIridescenceConfiguration extends MaterialPluginBase {
      /** @internal */
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      /**
       * Gets a boolean indicating that the plugin is compatible with a given shader language.
       * @returns true if the plugin is compatible with the shader language
       */
      isCompatible() {
        return true;
      }
      constructor(material, addToPluginList = true) {
        super(material, "PBRIridescence", 110, new MaterialIridescenceDefines(), addToPluginList);
        this._isEnabled = false;
        this.isEnabled = false;
        this.intensity = 1;
        this.minimumThickness = _PBRIridescenceConfiguration._DefaultMinimumThickness;
        this.maximumThickness = _PBRIridescenceConfiguration._DefaultMaximumThickness;
        this.indexOfRefraction = _PBRIridescenceConfiguration._DefaultIndexOfRefraction;
        this._texture = null;
        this.texture = null;
        this._thicknessTexture = null;
        this.thicknessTexture = null;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
      }
      isReadyForSubMesh(defines, scene) {
        if (!this._isEnabled) {
          return true;
        }
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
              if (!this._texture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
              if (!this._thicknessTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      }
      prepareDefinesBeforeAttributes(defines, scene) {
        if (this._isEnabled) {
          defines.IRIDESCENCE = true;
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
                PrepareDefinesForMergedUV(this._texture, defines, "IRIDESCENCE_TEXTURE");
              } else {
                defines.IRIDESCENCE_TEXTURE = false;
              }
              if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
                PrepareDefinesForMergedUV(this._thicknessTexture, defines, "IRIDESCENCE_THICKNESS_TEXTURE");
              } else {
                defines.IRIDESCENCE_THICKNESS_TEXTURE = false;
              }
            }
          }
        } else {
          defines.IRIDESCENCE = false;
          defines.IRIDESCENCE_TEXTURE = false;
          defines.IRIDESCENCE_THICKNESS_TEXTURE = false;
          defines.IRIDESCENCE_TEXTUREDIRECTUV = 0;
          defines.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;
        }
      }
      bindForSubMesh(uniformBuffer, scene) {
        if (!this._isEnabled) {
          return;
        }
        const isFrozen = this._material.isFrozen;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if ((this._texture || this._thicknessTexture) && MaterialFlags.IridescenceTextureEnabled) {
            uniformBuffer.updateFloat4("vIridescenceInfos", this._texture?.coordinatesIndex ?? 0, this._texture?.level ?? 0, this._thicknessTexture?.coordinatesIndex ?? 0, this._thicknessTexture?.level ?? 0);
            if (this._texture) {
              BindTextureMatrix(this._texture, uniformBuffer, "iridescence");
            }
            if (this._thicknessTexture) {
              BindTextureMatrix(this._thicknessTexture, uniformBuffer, "iridescenceThickness");
            }
          }
          uniformBuffer.updateFloat4("vIridescenceParams", this.intensity, this.indexOfRefraction, this.minimumThickness, this.maximumThickness);
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
            uniformBuffer.setTexture("iridescenceSampler", this._texture);
          }
          if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
            uniformBuffer.setTexture("iridescenceThicknessSampler", this._thicknessTexture);
          }
        }
      }
      hasTexture(texture) {
        if (this._texture === texture) {
          return true;
        }
        if (this._thicknessTexture === texture) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
        if (this._thicknessTexture) {
          activeTextures.push(this._thicknessTexture);
        }
      }
      getAnimatables(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
          animatables.push(this._thicknessTexture);
        }
      }
      dispose(forceDisposeTextures) {
        if (forceDisposeTextures) {
          this._texture?.dispose();
          this._thicknessTexture?.dispose();
        }
      }
      getClassName() {
        return "PBRIridescenceConfiguration";
      }
      addFallbacks(defines, fallbacks, currentRank) {
        if (defines.IRIDESCENCE) {
          fallbacks.addFallback(currentRank++, "IRIDESCENCE");
        }
        return currentRank;
      }
      getSamplers(samplers) {
        samplers.push("iridescenceSampler", "iridescenceThicknessSampler");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vIridescenceParams", size: 4, type: "vec4" },
            { name: "vIridescenceInfos", size: 4, type: "vec4" },
            { name: "iridescenceMatrix", size: 16, type: "mat4" },
            { name: "iridescenceThicknessMatrix", size: 16, type: "mat4" }
          ]
        };
      }
    };
    PBRIridescenceConfiguration._DefaultMinimumThickness = 100;
    PBRIridescenceConfiguration._DefaultMaximumThickness = 400;
    PBRIridescenceConfiguration._DefaultIndexOfRefraction = 1.3;
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRIridescenceConfiguration.prototype, "isEnabled", void 0);
    __decorate([
      serialize()
    ], PBRIridescenceConfiguration.prototype, "intensity", void 0);
    __decorate([
      serialize()
    ], PBRIridescenceConfiguration.prototype, "minimumThickness", void 0);
    __decorate([
      serialize()
    ], PBRIridescenceConfiguration.prototype, "maximumThickness", void 0);
    __decorate([
      serialize()
    ], PBRIridescenceConfiguration.prototype, "indexOfRefraction", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRIridescenceConfiguration.prototype, "texture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRIridescenceConfiguration.prototype, "thicknessTexture", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrAnisotropicConfiguration.js
var MaterialAnisotropicDefines, PBRAnisotropicConfiguration;
var init_pbrAnisotropicConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrAnisotropicConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_buffer();
    init_math_vector();
    init_materialFlags();
    init_materialPluginBase();
    init_materialDefines();
    init_materialHelper_functions();
    MaterialAnisotropicDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.ANISOTROPIC = false;
        this.ANISOTROPIC_TEXTURE = false;
        this.ANISOTROPIC_TEXTUREDIRECTUV = 0;
        this.ANISOTROPIC_LEGACY = false;
        this.MAINUV1 = false;
      }
    };
    PBRAnisotropicConfiguration = class extends MaterialPluginBase {
      /**
       * Sets the anisotropy direction as an angle.
       */
      set angle(value) {
        this.direction.x = Math.cos(value);
        this.direction.y = Math.sin(value);
      }
      /**
       * Gets the anisotropy angle value in radians.
       * @returns the anisotropy angle value in radians.
       */
      get angle() {
        return Math.atan2(this.direction.y, this.direction.x);
      }
      /** @internal */
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      /** @internal */
      _markAllSubMeshesAsMiscDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsMiscDirty();
      }
      /**
       * Gets a boolean indicating that the plugin is compatible with a given shader language.
       * @returns true if the plugin is compatible with the shader language
       */
      isCompatible() {
        return true;
      }
      constructor(material, addToPluginList = true) {
        super(material, "PBRAnisotropic", 110, new MaterialAnisotropicDefines(), addToPluginList);
        this._isEnabled = false;
        this.isEnabled = false;
        this.intensity = 1;
        this.direction = new Vector2(1, 0);
        this._texture = null;
        this.texture = null;
        this._legacy = false;
        this.legacy = false;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
        this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];
      }
      isReadyForSubMesh(defines, scene) {
        if (!this._isEnabled) {
          return true;
        }
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
              if (!this._texture.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      }
      prepareDefinesBeforeAttributes(defines, scene, mesh) {
        if (this._isEnabled) {
          defines.ANISOTROPIC = this._isEnabled;
          if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
            defines._needUVs = true;
            defines.MAINUV1 = true;
          }
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
                PrepareDefinesForMergedUV(this._texture, defines, "ANISOTROPIC_TEXTURE");
              } else {
                defines.ANISOTROPIC_TEXTURE = false;
              }
            }
          }
          if (defines._areMiscDirty) {
            defines.ANISOTROPIC_LEGACY = this._legacy;
          }
        } else {
          defines.ANISOTROPIC = false;
          defines.ANISOTROPIC_TEXTURE = false;
          defines.ANISOTROPIC_TEXTUREDIRECTUV = 0;
          defines.ANISOTROPIC_LEGACY = false;
        }
      }
      bindForSubMesh(uniformBuffer, scene) {
        if (!this._isEnabled) {
          return;
        }
        const isFrozen = this._material.isFrozen;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
            uniformBuffer.updateFloat2("vAnisotropyInfos", this._texture.coordinatesIndex, this._texture.level);
            BindTextureMatrix(this._texture, uniformBuffer, "anisotropy");
          }
          uniformBuffer.updateFloat3("vAnisotropy", this.direction.x, this.direction.y, this.intensity);
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
            uniformBuffer.setTexture("anisotropySampler", this._texture);
          }
        }
      }
      hasTexture(texture) {
        if (this._texture === texture) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
      }
      getAnimatables(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
      }
      dispose(forceDisposeTextures) {
        if (forceDisposeTextures) {
          if (this._texture) {
            this._texture.dispose();
          }
        }
      }
      getClassName() {
        return "PBRAnisotropicConfiguration";
      }
      addFallbacks(defines, fallbacks, currentRank) {
        if (defines.ANISOTROPIC) {
          fallbacks.addFallback(currentRank++, "ANISOTROPIC");
        }
        return currentRank;
      }
      getSamplers(samplers) {
        samplers.push("anisotropySampler");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vAnisotropy", size: 3, type: "vec3" },
            { name: "vAnisotropyInfos", size: 2, type: "vec2" },
            { name: "anisotropyMatrix", size: 16, type: "mat4" }
          ]
        };
      }
      /**
       * Parses a anisotropy Configuration from a serialized object.
       * @param source - Serialized object.
       * @param scene Defines the scene we are parsing for
       * @param rootUrl Defines the rootUrl to load from
       */
      parse(source, scene, rootUrl) {
        super.parse(source, scene, rootUrl);
        if (source.legacy === void 0) {
          this.legacy = true;
        }
      }
    };
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRAnisotropicConfiguration.prototype, "isEnabled", void 0);
    __decorate([
      serialize()
    ], PBRAnisotropicConfiguration.prototype, "intensity", void 0);
    __decorate([
      serializeAsVector2()
    ], PBRAnisotropicConfiguration.prototype, "direction", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRAnisotropicConfiguration.prototype, "texture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRAnisotropicConfiguration.prototype, "legacy", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrSheenConfiguration.js
var MaterialSheenDefines, PBRSheenConfiguration;
var init_pbrSheenConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrSheenConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_color();
    init_materialFlags();
    init_materialPluginBase();
    init_materialDefines();
    init_materialHelper_functions();
    MaterialSheenDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.SHEEN = false;
        this.SHEEN_TEXTURE = false;
        this.SHEEN_GAMMATEXTURE = false;
        this.SHEEN_TEXTURE_ROUGHNESS = false;
        this.SHEEN_TEXTUREDIRECTUV = 0;
        this.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;
        this.SHEEN_LINKWITHALBEDO = false;
        this.SHEEN_ROUGHNESS = false;
        this.SHEEN_ALBEDOSCALING = false;
        this.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
      }
    };
    PBRSheenConfiguration = class extends MaterialPluginBase {
      /** @internal */
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      /**
       * Gets a boolean indicating that the plugin is compatible with a given shader language.
       * @returns true if the plugin is compatible with the shader language
       */
      isCompatible() {
        return true;
      }
      constructor(material, addToPluginList = true) {
        super(material, "Sheen", 120, new MaterialSheenDefines(), addToPluginList);
        this._isEnabled = false;
        this.isEnabled = false;
        this._linkSheenWithAlbedo = false;
        this.linkSheenWithAlbedo = false;
        this.intensity = 1;
        this.color = Color3.White();
        this._texture = null;
        this.texture = null;
        this._useRoughnessFromMainTexture = true;
        this.useRoughnessFromMainTexture = true;
        this._roughness = null;
        this.roughness = null;
        this._textureRoughness = null;
        this.textureRoughness = null;
        this._albedoScaling = false;
        this.albedoScaling = false;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
      }
      isReadyForSubMesh(defines, scene) {
        if (!this._isEnabled) {
          return true;
        }
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._texture && MaterialFlags.SheenTextureEnabled) {
              if (!this._texture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
              if (!this._textureRoughness.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      }
      prepareDefinesBeforeAttributes(defines, scene) {
        if (this._isEnabled) {
          defines.SHEEN = true;
          defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;
          defines.SHEEN_ROUGHNESS = this._roughness !== null;
          defines.SHEEN_ALBEDOSCALING = this._albedoScaling;
          defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._texture && MaterialFlags.SheenTextureEnabled) {
                PrepareDefinesForMergedUV(this._texture, defines, "SHEEN_TEXTURE");
                defines.SHEEN_GAMMATEXTURE = this._texture.gammaSpace;
              } else {
                defines.SHEEN_TEXTURE = false;
              }
              if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
                PrepareDefinesForMergedUV(this._textureRoughness, defines, "SHEEN_TEXTURE_ROUGHNESS");
              } else {
                defines.SHEEN_TEXTURE_ROUGHNESS = false;
              }
            }
          }
        } else {
          defines.SHEEN = false;
          defines.SHEEN_TEXTURE = false;
          defines.SHEEN_TEXTURE_ROUGHNESS = false;
          defines.SHEEN_LINKWITHALBEDO = false;
          defines.SHEEN_ROUGHNESS = false;
          defines.SHEEN_ALBEDOSCALING = false;
          defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
          defines.SHEEN_GAMMATEXTURE = false;
          defines.SHEEN_TEXTUREDIRECTUV = 0;
          defines.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;
        }
      }
      bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
        if (!this._isEnabled) {
          return;
        }
        const defines = subMesh.materialDefines;
        const isFrozen = this._material.isFrozen;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {
            uniformBuffer.updateFloat4("vSheenInfos", this._texture?.coordinatesIndex ?? 0, this._texture?.level ?? 0, this._textureRoughness?.coordinatesIndex ?? 0, this._textureRoughness?.level ?? 0);
            if (this._texture) {
              BindTextureMatrix(this._texture, uniformBuffer, "sheen");
            }
            if (this._textureRoughness && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {
              BindTextureMatrix(this._textureRoughness, uniformBuffer, "sheenRoughness");
            }
          }
          uniformBuffer.updateFloat4("vSheenColor", this.color.r, this.color.g, this.color.b, this.intensity);
          if (this._roughness !== null) {
            uniformBuffer.updateFloat("vSheenRoughness", this._roughness);
          }
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.SheenTextureEnabled) {
            uniformBuffer.setTexture("sheenSampler", this._texture);
          }
          if (this._textureRoughness && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {
            uniformBuffer.setTexture("sheenRoughnessSampler", this._textureRoughness);
          }
        }
      }
      hasTexture(texture) {
        if (this._texture === texture) {
          return true;
        }
        if (this._textureRoughness === texture) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
        if (this._textureRoughness) {
          activeTextures.push(this._textureRoughness);
        }
      }
      getAnimatables(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
          animatables.push(this._textureRoughness);
        }
      }
      dispose(forceDisposeTextures) {
        if (forceDisposeTextures) {
          this._texture?.dispose();
          this._textureRoughness?.dispose();
        }
      }
      getClassName() {
        return "PBRSheenConfiguration";
      }
      addFallbacks(defines, fallbacks, currentRank) {
        if (defines.SHEEN) {
          fallbacks.addFallback(currentRank++, "SHEEN");
        }
        return currentRank;
      }
      getSamplers(samplers) {
        samplers.push("sheenSampler", "sheenRoughnessSampler");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vSheenColor", size: 4, type: "vec4" },
            { name: "vSheenRoughness", size: 1, type: "float" },
            { name: "vSheenInfos", size: 4, type: "vec4" },
            { name: "sheenMatrix", size: 16, type: "mat4" },
            { name: "sheenRoughnessMatrix", size: 16, type: "mat4" }
          ]
        };
      }
    };
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "isEnabled", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "linkSheenWithAlbedo", void 0);
    __decorate([
      serialize()
    ], PBRSheenConfiguration.prototype, "intensity", void 0);
    __decorate([
      serializeAsColor3()
    ], PBRSheenConfiguration.prototype, "color", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "texture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "useRoughnessFromMainTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "roughness", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "textureRoughness", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "albedoScaling", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrSubSurfaceConfiguration.js
var MaterialSubSurfaceDefines, PBRSubSurfaceConfiguration;
var init_pbrSubSurfaceConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrSubSurfaceConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_color();
    init_materialFlags();
    init_math_vector();
    init_materialPluginBase();
    init_materialDefines();
    init_materialHelper_functions();
    MaterialSubSurfaceDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.SUBSURFACE = false;
        this.SS_REFRACTION = false;
        this.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;
        this.SS_TRANSLUCENCY = false;
        this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;
        this.SS_SCATTERING = false;
        this.SS_DISPERSION = false;
        this.SS_THICKNESSANDMASK_TEXTURE = false;
        this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;
        this.SS_HAS_THICKNESS = false;
        this.SS_REFRACTIONINTENSITY_TEXTURE = false;
        this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;
        this.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
        this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;
        this.SS_TRANSLUCENCYCOLOR_TEXTURE = false;
        this.SS_TRANSLUCENCYCOLOR_TEXTUREDIRECTUV = 0;
        this.SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = false;
        this.SS_REFRACTIONMAP_3D = false;
        this.SS_REFRACTIONMAP_OPPOSITEZ = false;
        this.SS_LODINREFRACTIONALPHA = false;
        this.SS_GAMMAREFRACTION = false;
        this.SS_RGBDREFRACTION = false;
        this.SS_LINEARSPECULARREFRACTION = false;
        this.SS_LINKREFRACTIONTOTRANSPARENCY = false;
        this.SS_ALBEDOFORREFRACTIONTINT = false;
        this.SS_ALBEDOFORTRANSLUCENCYTINT = false;
        this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
        this.SS_USE_THICKNESS_AS_DEPTH = false;
        this.SS_USE_GLTF_TEXTURES = false;
        this.SS_APPLY_ALBEDO_AFTER_SUBSURFACE = false;
        this.SS_TRANSLUCENCY_LEGACY = false;
      }
    };
    PBRSubSurfaceConfiguration = class _PBRSubSurfaceConfiguration extends MaterialPluginBase {
      /**
       * Diffusion profile for subsurface scattering.
       * Useful for better scattering in the skins or foliages.
       */
      get scatteringDiffusionProfile() {
        if (!this._scene.subSurfaceConfiguration) {
          return null;
        }
        return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];
      }
      set scatteringDiffusionProfile(c) {
        if (!this._scene.enableSubSurfaceForPrePass()) {
          return;
        }
        if (c) {
          this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(c);
        }
      }
      /**
       * Index of refraction of the material's volume.
       * https://en.wikipedia.org/wiki/List_of_refractive_indices
       *
       * This ONLY impacts refraction. If not provided or given a non-valid value,
       * the volume will use the same IOR as the surface.
       */
      get volumeIndexOfRefraction() {
        if (this._volumeIndexOfRefraction >= 1) {
          return this._volumeIndexOfRefraction;
        }
        return this._indexOfRefraction;
      }
      set volumeIndexOfRefraction(value) {
        if (value >= 1) {
          this._volumeIndexOfRefraction = value;
        } else {
          this._volumeIndexOfRefraction = -1;
        }
      }
      /**
       * Keeping for backward compatibility... Should not be used anymore. It has been replaced by
       * the property with the correct spelling.
       * @see legacyTranslucency
       */
      get legacyTransluceny() {
        return this.legacyTranslucency;
      }
      set legacyTransluceny(value) {
        this.legacyTranslucency = value;
      }
      /** @internal */
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      /** @internal */
      _markScenePrePassDirty() {
        this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
        this._internalMarkScenePrePassDirty();
      }
      /**
       * Gets a boolean indicating that the plugin is compatible with a given shader language.
       * @returns true if the plugin is compatible with the shader language
       */
      isCompatible() {
        return true;
      }
      constructor(material, addToPluginList = true) {
        super(material, "PBRSubSurface", 130, new MaterialSubSurfaceDefines(), addToPluginList);
        this._isRefractionEnabled = false;
        this.isRefractionEnabled = false;
        this._isTranslucencyEnabled = false;
        this.isTranslucencyEnabled = false;
        this._isDispersionEnabled = false;
        this.isDispersionEnabled = false;
        this._isScatteringEnabled = false;
        this.isScatteringEnabled = false;
        this._scatteringDiffusionProfileIndex = 0;
        this.refractionIntensity = 1;
        this.translucencyIntensity = 1;
        this._useAlbedoToTintRefraction = false;
        this.useAlbedoToTintRefraction = false;
        this._useAlbedoToTintTranslucency = false;
        this.useAlbedoToTintTranslucency = false;
        this._thicknessTexture = null;
        this.thicknessTexture = null;
        this._refractionTexture = null;
        this.refractionTexture = null;
        this._indexOfRefraction = 1.5;
        this.indexOfRefraction = 1.5;
        this._volumeIndexOfRefraction = -1;
        this._invertRefractionY = false;
        this.invertRefractionY = false;
        this._linkRefractionWithTransparency = false;
        this.linkRefractionWithTransparency = false;
        this.minimumThickness = 0;
        this.maximumThickness = 1;
        this.useThicknessAsDepth = false;
        this.tintColor = Color3.White();
        this.tintColorAtDistance = 1;
        this.dispersion = 0;
        this.diffusionDistance = Color3.White();
        this._useMaskFromThicknessTexture = false;
        this.useMaskFromThicknessTexture = false;
        this._refractionIntensityTexture = null;
        this.refractionIntensityTexture = null;
        this._translucencyIntensityTexture = null;
        this.translucencyIntensityTexture = null;
        this.translucencyColor = null;
        this._translucencyColorTexture = null;
        this.translucencyColorTexture = null;
        this._useGltfStyleTextures = true;
        this.useGltfStyleTextures = true;
        this.applyAlbedoAfterSubSurface = _PBRSubSurfaceConfiguration.DEFAULT_APPLY_ALBEDO_AFTERSUBSURFACE;
        this.legacyTranslucency = _PBRSubSurfaceConfiguration.DEFAULT_LEGACY_TRANSLUCENCY;
        this._scene = material.getScene();
        this.registerForExtraEvents = true;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
        this._internalMarkScenePrePassDirty = material._dirtyCallbacks[32];
      }
      isReadyForSubMesh(defines, scene) {
        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
          return true;
        }
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
              if (!this._thicknessTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled) {
              if (!this._refractionIntensityTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled) {
              if (!this._translucencyColorTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled) {
              if (!this._translucencyIntensityTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            const refractionTexture = this._getRefractionTexture(scene);
            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
              if (!refractionTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      }
      prepareDefinesBeforeAttributes(defines, scene) {
        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
          defines.SUBSURFACE = false;
          defines.SS_DISPERSION = false;
          defines.SS_TRANSLUCENCY = false;
          defines.SS_SCATTERING = false;
          defines.SS_REFRACTION = false;
          defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;
          defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;
          defines.SS_THICKNESSANDMASK_TEXTURE = false;
          defines.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;
          defines.SS_HAS_THICKNESS = false;
          defines.SS_REFRACTIONINTENSITY_TEXTURE = false;
          defines.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;
          defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
          defines.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;
          defines.SS_REFRACTIONMAP_3D = false;
          defines.SS_REFRACTIONMAP_OPPOSITEZ = false;
          defines.SS_LODINREFRACTIONALPHA = false;
          defines.SS_GAMMAREFRACTION = false;
          defines.SS_RGBDREFRACTION = false;
          defines.SS_LINEARSPECULARREFRACTION = false;
          defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;
          defines.SS_ALBEDOFORREFRACTIONTINT = false;
          defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;
          defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
          defines.SS_USE_THICKNESS_AS_DEPTH = false;
          defines.SS_USE_GLTF_TEXTURES = false;
          defines.SS_TRANSLUCENCYCOLOR_TEXTURE = false;
          defines.SS_TRANSLUCENCYCOLOR_TEXTUREDIRECTUV = 0;
          defines.SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = false;
          defines.SS_APPLY_ALBEDO_AFTER_SUBSURFACE = false;
          return;
        }
        if (defines._areTexturesDirty) {
          defines.SUBSURFACE = true;
          defines.SS_DISPERSION = this._isDispersionEnabled;
          defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;
          defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;
          defines.SS_TRANSLUCENCY_LEGACY = this.legacyTranslucency;
          defines.SS_SCATTERING = this._isScatteringEnabled;
          defines.SS_THICKNESSANDMASK_TEXTURE = false;
          defines.SS_REFRACTIONINTENSITY_TEXTURE = false;
          defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
          defines.SS_HAS_THICKNESS = false;
          defines.SS_USE_GLTF_TEXTURES = false;
          defines.SS_REFRACTION = false;
          defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;
          defines.SS_REFRACTIONMAP_3D = false;
          defines.SS_GAMMAREFRACTION = false;
          defines.SS_RGBDREFRACTION = false;
          defines.SS_LINEARSPECULARREFRACTION = false;
          defines.SS_REFRACTIONMAP_OPPOSITEZ = false;
          defines.SS_LODINREFRACTIONALPHA = false;
          defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;
          defines.SS_ALBEDOFORREFRACTIONTINT = false;
          defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;
          defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
          defines.SS_USE_THICKNESS_AS_DEPTH = false;
          defines.SS_TRANSLUCENCYCOLOR_TEXTURE = false;
          defines.SS_APPLY_ALBEDO_AFTER_SUBSURFACE = this.applyAlbedoAfterSubSurface;
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
                PrepareDefinesForMergedUV(this._thicknessTexture, defines, "SS_THICKNESSANDMASK_TEXTURE");
              }
              if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled) {
                PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, "SS_REFRACTIONINTENSITY_TEXTURE");
              }
              if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled) {
                PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, "SS_TRANSLUCENCYINTENSITY_TEXTURE");
              }
              if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled) {
                PrepareDefinesForMergedUV(this._translucencyColorTexture, defines, "SS_TRANSLUCENCYCOLOR_TEXTURE");
                defines.SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = this._translucencyColorTexture.gammaSpace;
              }
            }
          }
          defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0;
          defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;
          defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = this._useMaskFromThicknessTexture && !this._refractionIntensityTexture;
          defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = this._useMaskFromThicknessTexture && !this._translucencyIntensityTexture;
          if (this._isRefractionEnabled) {
            if (scene.texturesEnabled) {
              const refractionTexture = this._getRefractionTexture(scene);
              if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
                defines.SS_REFRACTION = true;
                defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;
                defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;
                defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;
                defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;
                defines.SS_REFRACTIONMAP_OPPOSITEZ = this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ;
                defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;
                defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;
                defines.SS_ALBEDOFORREFRACTIONTINT = this._useAlbedoToTintRefraction;
                defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && refractionTexture.boundingBoxSize;
                defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;
              }
            }
          }
          if (this._isTranslucencyEnabled) {
            defines.SS_ALBEDOFORTRANSLUCENCYTINT = this._useAlbedoToTintTranslucency;
          }
        }
      }
      /**
       * Binds the material data (this function is called even if mustRebind() returns false)
       * @param uniformBuffer defines the Uniform buffer to fill in.
       * @param scene defines the scene the material belongs to.
       * @param engine defines the engine the material belongs to.
       * @param subMesh the submesh to bind data for
       */
      hardBindForSubMesh(uniformBuffer, scene, engine, subMesh) {
        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
          return;
        }
        if (this.maximumThickness === 0 && this.minimumThickness === 0) {
          uniformBuffer.updateFloat2("vThicknessParam", 0, 0);
        } else {
          subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);
          const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));
          uniformBuffer.updateFloat2("vThicknessParam", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);
        }
      }
      bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
          return;
        }
        const defines = subMesh.materialDefines;
        const isFrozen = this._material.isFrozen;
        const realTimeFiltering = this._material.realTimeFiltering;
        const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;
        const refractionTexture = this._getRefractionTexture(scene);
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
            uniformBuffer.updateFloat2("vThicknessInfos", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);
            BindTextureMatrix(this._thicknessTexture, uniformBuffer, "thickness");
          }
          if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {
            uniformBuffer.updateFloat2("vRefractionIntensityInfos", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);
            BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, "refractionIntensity");
          }
          if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled && defines.SS_TRANSLUCENCYCOLOR_TEXTURE) {
            uniformBuffer.updateFloat2("vTranslucencyColorInfos", this._translucencyColorTexture.coordinatesIndex, this._translucencyColorTexture.level);
            BindTextureMatrix(this._translucencyColorTexture, uniformBuffer, "translucencyColor");
          }
          if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {
            uniformBuffer.updateFloat2("vTranslucencyIntensityInfos", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);
            BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, "translucencyIntensity");
          }
          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
            uniformBuffer.updateMatrix("refractionMatrix", refractionTexture.getRefractionTextureMatrix());
            let depth = 1;
            if (!refractionTexture.isCube) {
              if (refractionTexture.depth) {
                depth = refractionTexture.depth;
              }
            }
            const width = refractionTexture.getSize().width;
            const refractionIor = this.volumeIndexOfRefraction;
            uniformBuffer.updateFloat4("vRefractionInfos", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);
            uniformBuffer.updateFloat4("vRefractionMicrosurfaceInfos", width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1 / this.indexOfRefraction);
            if (realTimeFiltering) {
              uniformBuffer.updateFloat2("vRefractionFilteringInfo", width, Math.log2(width));
            }
            if (refractionTexture.boundingBoxSize) {
              const cubeTexture = refractionTexture;
              uniformBuffer.updateVector3("vRefractionPosition", cubeTexture.boundingBoxPosition);
              uniformBuffer.updateVector3("vRefractionSize", cubeTexture.boundingBoxSize);
            }
          }
          if (this._isScatteringEnabled) {
            uniformBuffer.updateFloat("scatteringDiffusionProfile", this._scatteringDiffusionProfileIndex);
          }
          uniformBuffer.updateColor3("vDiffusionDistance", this.diffusionDistance);
          uniformBuffer.updateFloat4("vTintColor", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintColorAtDistance));
          uniformBuffer.updateColor4("vTranslucencyColor", this.translucencyColor ?? this.tintColor, 0);
          uniformBuffer.updateFloat3("vSubSurfaceIntensity", this.refractionIntensity, this.translucencyIntensity, 0);
          uniformBuffer.updateFloat("dispersion", this.dispersion);
        }
        if (scene.texturesEnabled) {
          if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
            uniformBuffer.setTexture("thicknessSampler", this._thicknessTexture);
          }
          if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {
            uniformBuffer.setTexture("refractionIntensitySampler", this._refractionIntensityTexture);
          }
          if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {
            uniformBuffer.setTexture("translucencyIntensitySampler", this._translucencyIntensityTexture);
          }
          if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled && defines.SS_TRANSLUCENCYCOLOR_TEXTURE) {
            uniformBuffer.setTexture("translucencyColorSampler", this._translucencyColorTexture);
          }
          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
            if (lodBasedMicrosurface) {
              uniformBuffer.setTexture("refractionSampler", refractionTexture);
            } else {
              uniformBuffer.setTexture("refractionSampler", refractionTexture._lodTextureMid || refractionTexture);
              uniformBuffer.setTexture("refractionSamplerLow", refractionTexture._lodTextureLow || refractionTexture);
              uniformBuffer.setTexture("refractionSamplerHigh", refractionTexture._lodTextureHigh || refractionTexture);
            }
          }
        }
      }
      /**
       * Returns the texture used for refraction or null if none is used.
       * @param scene defines the scene the material belongs to.
       * @returns - Refraction texture if present.  If no refraction texture and refraction
       * is linked with transparency, returns environment texture.  Otherwise, returns null.
       */
      _getRefractionTexture(scene) {
        if (this._refractionTexture) {
          return this._refractionTexture;
        }
        if (this._isRefractionEnabled) {
          return scene.environmentTexture;
        }
        return null;
      }
      /**
       * Returns true if alpha blending should be disabled.
       */
      get disableAlphaBlending() {
        return this._isRefractionEnabled && this._linkRefractionWithTransparency;
      }
      /**
       * Fills the list of render target textures.
       * @param renderTargets the list of render targets to update
       */
      fillRenderTargetTextures(renderTargets) {
        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
          renderTargets.push(this._refractionTexture);
        }
      }
      hasTexture(texture) {
        if (this._thicknessTexture === texture) {
          return true;
        }
        if (this._refractionTexture === texture) {
          return true;
        }
        if (this._refractionIntensityTexture === texture) {
          return true;
        }
        if (this._translucencyIntensityTexture === texture) {
          return true;
        }
        if (this._translucencyColorTexture === texture) {
          return true;
        }
        return false;
      }
      hasRenderTargetTextures() {
        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._thicknessTexture) {
          activeTextures.push(this._thicknessTexture);
        }
        if (this._refractionTexture) {
          activeTextures.push(this._refractionTexture);
        }
        if (this._refractionIntensityTexture) {
          activeTextures.push(this._refractionIntensityTexture);
        }
        if (this._translucencyColorTexture) {
          activeTextures.push(this._translucencyColorTexture);
        }
        if (this._translucencyIntensityTexture) {
          activeTextures.push(this._translucencyIntensityTexture);
        }
      }
      getAnimatables(animatables) {
        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
          animatables.push(this._thicknessTexture);
        }
        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {
          animatables.push(this._refractionTexture);
        }
        if (this._refractionIntensityTexture && this._refractionIntensityTexture.animations && this._refractionIntensityTexture.animations.length > 0) {
          animatables.push(this._refractionIntensityTexture);
        }
        if (this._translucencyColorTexture && this._translucencyColorTexture.animations && this._translucencyColorTexture.animations.length > 0) {
          animatables.push(this._translucencyColorTexture);
        }
        if (this._translucencyIntensityTexture && this._translucencyIntensityTexture.animations && this._translucencyIntensityTexture.animations.length > 0) {
          animatables.push(this._translucencyIntensityTexture);
        }
      }
      dispose(forceDisposeTextures) {
        if (forceDisposeTextures) {
          if (this._thicknessTexture) {
            this._thicknessTexture.dispose();
          }
          if (this._refractionTexture) {
            this._refractionTexture.dispose();
          }
          if (this._refractionIntensityTexture) {
            this._refractionIntensityTexture.dispose();
          }
          if (this._translucencyColorTexture) {
            this._translucencyColorTexture.dispose();
          }
          if (this._translucencyIntensityTexture) {
            this._translucencyIntensityTexture.dispose();
          }
        }
      }
      getClassName() {
        return "PBRSubSurfaceConfiguration";
      }
      addFallbacks(defines, fallbacks, currentRank) {
        if (defines.SS_SCATTERING) {
          fallbacks.addFallback(currentRank++, "SS_SCATTERING");
        }
        if (defines.SS_TRANSLUCENCY) {
          fallbacks.addFallback(currentRank++, "SS_TRANSLUCENCY");
        }
        return currentRank;
      }
      getSamplers(samplers) {
        samplers.push("thicknessSampler", "refractionIntensitySampler", "translucencyIntensitySampler", "refractionSampler", "refractionSamplerLow", "refractionSamplerHigh", "translucencyColorSampler");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vRefractionMicrosurfaceInfos", size: 4, type: "vec4" },
            { name: "vRefractionFilteringInfo", size: 2, type: "vec2" },
            { name: "vTranslucencyIntensityInfos", size: 2, type: "vec2" },
            { name: "vRefractionInfos", size: 4, type: "vec4" },
            { name: "refractionMatrix", size: 16, type: "mat4" },
            { name: "vThicknessInfos", size: 2, type: "vec2" },
            { name: "vRefractionIntensityInfos", size: 2, type: "vec2" },
            { name: "thicknessMatrix", size: 16, type: "mat4" },
            { name: "refractionIntensityMatrix", size: 16, type: "mat4" },
            { name: "translucencyIntensityMatrix", size: 16, type: "mat4" },
            { name: "vThicknessParam", size: 2, type: "vec2" },
            { name: "vDiffusionDistance", size: 3, type: "vec3" },
            { name: "vTintColor", size: 4, type: "vec4" },
            { name: "vSubSurfaceIntensity", size: 3, type: "vec3" },
            { name: "vRefractionPosition", size: 3, type: "vec3" },
            { name: "vRefractionSize", size: 3, type: "vec3" },
            { name: "scatteringDiffusionProfile", size: 1, type: "float" },
            { name: "dispersion", size: 1, type: "float" },
            { name: "vTranslucencyColor", size: 4, type: "vec4" },
            { name: "vTranslucencyColorInfos", size: 2, type: "vec2" },
            { name: "translucencyColorMatrix", size: 16, type: "mat4" }
          ]
        };
      }
    };
    PBRSubSurfaceConfiguration.DEFAULT_APPLY_ALBEDO_AFTERSUBSURFACE = false;
    PBRSubSurfaceConfiguration.DEFAULT_LEGACY_TRANSLUCENCY = false;
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "isRefractionEnabled", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "isTranslucencyEnabled", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "isDispersionEnabled", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markScenePrePassDirty")
    ], PBRSubSurfaceConfiguration.prototype, "isScatteringEnabled", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "_scatteringDiffusionProfileIndex", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "refractionIntensity", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "translucencyIntensity", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "useAlbedoToTintRefraction", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "useAlbedoToTintTranslucency", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "thicknessTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "refractionTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "indexOfRefraction", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "_volumeIndexOfRefraction", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "volumeIndexOfRefraction", null);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "invertRefractionY", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "linkRefractionWithTransparency", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "minimumThickness", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "maximumThickness", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "useThicknessAsDepth", void 0);
    __decorate([
      serializeAsColor3()
    ], PBRSubSurfaceConfiguration.prototype, "tintColor", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "tintColorAtDistance", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "dispersion", void 0);
    __decorate([
      serializeAsColor3()
    ], PBRSubSurfaceConfiguration.prototype, "diffusionDistance", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "useMaskFromThicknessTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "refractionIntensityTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "translucencyIntensityTexture", void 0);
    __decorate([
      serializeAsColor3()
    ], PBRSubSurfaceConfiguration.prototype, "translucencyColor", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "translucencyColorTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "useGltfStyleTextures", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "applyAlbedoAfterSubSurface", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "legacyTranslucency", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrBaseMaterial.js
var onCreatedEffectParameters2, PBRMaterialDefinesBase, PBRMaterialDefines, PBRBaseMaterialBase, PBRBaseMaterial;
var init_pbrBaseMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrBaseMaterial.js"() {
    init_tslib_es6();
    init_decorators();
    init_logger();
    init_smartArray();
    init_brdfTextureTools();
    init_scene();
    init_math_vector();
    init_buffer();
    init_pbrBRDFConfiguration();
    init_prePassConfiguration();
    init_math_color();
    init_imageProcessingConfiguration_defines();
    init_imageProcessingConfiguration();
    init_material();
    init_materialDefines();
    init_pushMaterial();
    init_materialFlags();
    init_baseTexture_polynomial();
    init_effectFallbacks();
    init_pbrClearCoatConfiguration();
    init_pbrIridescenceConfiguration();
    init_pbrAnisotropicConfiguration();
    init_pbrSheenConfiguration();
    init_pbrSubSurfaceConfiguration();
    init_material_detailMapConfiguration();
    init_clipPlaneMaterialHelper();
    init_materialHelper_functions();
    init_materialHelper_geometryrendering();
    init_uv_defines();
    init_imageProcessing();
    onCreatedEffectParameters2 = { effect: null, subMesh: null };
    PBRMaterialDefinesBase = class extends UVDefinesMixin(MaterialDefines) {
    };
    PBRMaterialDefines = class extends ImageProcessingDefinesMixin(PBRMaterialDefinesBase) {
      /**
       * Initializes the PBR Material defines.
       * @param externalProperties The external properties
       */
      constructor(externalProperties) {
        super(externalProperties);
        this.PBR = true;
        this.NUM_SAMPLES = "0";
        this.REALTIME_FILTERING = false;
        this.IBL_CDF_FILTERING = false;
        this.ALBEDO = false;
        this.GAMMAALBEDO = false;
        this.ALBEDODIRECTUV = 0;
        this.VERTEXCOLOR = false;
        this.BASE_WEIGHT = false;
        this.BASE_WEIGHTDIRECTUV = 0;
        this.BASE_DIFFUSE_ROUGHNESS = false;
        this.BASE_DIFFUSE_ROUGHNESSDIRECTUV = 0;
        this.BAKED_VERTEX_ANIMATION_TEXTURE = false;
        this.AMBIENT = false;
        this.AMBIENTDIRECTUV = 0;
        this.AMBIENTINGRAYSCALE = false;
        this.OPACITY = false;
        this.VERTEXALPHA = false;
        this.OPACITYDIRECTUV = 0;
        this.OPACITYRGB = false;
        this.ALPHATEST = false;
        this.DEPTHPREPASS = false;
        this.ALPHABLEND = false;
        this.ALPHAFROMALBEDO = false;
        this.ALPHATESTVALUE = "0.5";
        this.SPECULAROVERALPHA = false;
        this.RADIANCEOVERALPHA = false;
        this.ALPHAFRESNEL = false;
        this.LINEARALPHAFRESNEL = false;
        this.PREMULTIPLYALPHA = false;
        this.EMISSIVE = false;
        this.EMISSIVEDIRECTUV = 0;
        this.GAMMAEMISSIVE = false;
        this.REFLECTIVITY = false;
        this.REFLECTIVITY_GAMMA = false;
        this.REFLECTIVITYDIRECTUV = 0;
        this.SPECULARTERM = false;
        this.MICROSURFACEFROMREFLECTIVITYMAP = false;
        this.MICROSURFACEAUTOMATIC = false;
        this.LODBASEDMICROSFURACE = false;
        this.MICROSURFACEMAP = false;
        this.MICROSURFACEMAPDIRECTUV = 0;
        this.METALLICWORKFLOW = false;
        this.ROUGHNESSSTOREINMETALMAPALPHA = false;
        this.ROUGHNESSSTOREINMETALMAPGREEN = false;
        this.METALLNESSSTOREINMETALMAPBLUE = false;
        this.AOSTOREINMETALMAPRED = false;
        this.METALLIC_REFLECTANCE = false;
        this.METALLIC_REFLECTANCE_GAMMA = false;
        this.METALLIC_REFLECTANCEDIRECTUV = 0;
        this.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = false;
        this.REFLECTANCE = false;
        this.REFLECTANCE_GAMMA = false;
        this.REFLECTANCEDIRECTUV = 0;
        this.ENVIRONMENTBRDF = false;
        this.ENVIRONMENTBRDF_RGBD = false;
        this.NORMAL = false;
        this.TANGENT = false;
        this.BUMP = false;
        this.BUMPDIRECTUV = 0;
        this.OBJECTSPACE_NORMALMAP = false;
        this.PARALLAX = false;
        this.PARALLAX_RHS = false;
        this.PARALLAXOCCLUSION = false;
        this.NORMALXYSCALE = true;
        this.LIGHTMAP = false;
        this.LIGHTMAPDIRECTUV = 0;
        this.USELIGHTMAPASSHADOWMAP = false;
        this.GAMMALIGHTMAP = false;
        this.RGBDLIGHTMAP = false;
        this.REFLECTION = false;
        this.REFLECTIONMAP_3D = false;
        this.REFLECTIONMAP_SPHERICAL = false;
        this.REFLECTIONMAP_PLANAR = false;
        this.REFLECTIONMAP_CUBIC = false;
        this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
        this.REFLECTIONMAP_PROJECTION = false;
        this.REFLECTIONMAP_SKYBOX = false;
        this.REFLECTIONMAP_EXPLICIT = false;
        this.REFLECTIONMAP_EQUIRECTANGULAR = false;
        this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
        this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
        this.INVERTCUBICMAP = false;
        this.USESPHERICALFROMREFLECTIONMAP = false;
        this.USEIRRADIANCEMAP = false;
        this.USE_IRRADIANCE_DOMINANT_DIRECTION = false;
        this.USESPHERICALINVERTEX = false;
        this.REFLECTIONMAP_OPPOSITEZ = false;
        this.LODINREFLECTIONALPHA = false;
        this.GAMMAREFLECTION = false;
        this.RGBDREFLECTION = false;
        this.LINEARSPECULARREFLECTION = false;
        this.RADIANCEOCCLUSION = false;
        this.HORIZONOCCLUSION = false;
        this.INSTANCES = false;
        this.THIN_INSTANCES = false;
        this.INSTANCESCOLOR = false;
        this.PREPASS = false;
        this.PREPASS_COLOR = false;
        this.PREPASS_COLOR_INDEX = -1;
        this.PREPASS_IRRADIANCE = false;
        this.PREPASS_IRRADIANCE_INDEX = -1;
        this.PREPASS_ALBEDO = false;
        this.PREPASS_ALBEDO_INDEX = -1;
        this.PREPASS_ALBEDO_SQRT = false;
        this.PREPASS_ALBEDO_SQRT_INDEX = -1;
        this.PREPASS_DEPTH = false;
        this.PREPASS_DEPTH_INDEX = -1;
        this.PREPASS_SCREENSPACE_DEPTH = false;
        this.PREPASS_SCREENSPACE_DEPTH_INDEX = -1;
        this.PREPASS_NORMALIZED_VIEW_DEPTH = false;
        this.PREPASS_NORMALIZED_VIEW_DEPTH_INDEX = -1;
        this.PREPASS_NORMAL = false;
        this.PREPASS_NORMAL_INDEX = -1;
        this.PREPASS_NORMAL_WORLDSPACE = false;
        this.PREPASS_WORLD_NORMAL = false;
        this.PREPASS_WORLD_NORMAL_INDEX = -1;
        this.PREPASS_POSITION = false;
        this.PREPASS_POSITION_INDEX = -1;
        this.PREPASS_LOCAL_POSITION = false;
        this.PREPASS_LOCAL_POSITION_INDEX = -1;
        this.PREPASS_VELOCITY = false;
        this.PREPASS_VELOCITY_INDEX = -1;
        this.PREPASS_VELOCITY_LINEAR = false;
        this.PREPASS_VELOCITY_LINEAR_INDEX = -1;
        this.PREPASS_REFLECTIVITY = false;
        this.PREPASS_REFLECTIVITY_INDEX = -1;
        this.SCENE_MRT_COUNT = 0;
        this.NUM_BONE_INFLUENCERS = 0;
        this.BonesPerMesh = 0;
        this.BONETEXTURE = false;
        this.BONES_VELOCITY_ENABLED = false;
        this.NONUNIFORMSCALING = false;
        this.MORPHTARGETS = false;
        this.MORPHTARGETS_POSITION = false;
        this.MORPHTARGETS_NORMAL = false;
        this.MORPHTARGETS_TANGENT = false;
        this.MORPHTARGETS_UV = false;
        this.MORPHTARGETS_UV2 = false;
        this.MORPHTARGETS_COLOR = false;
        this.MORPHTARGETTEXTURE_HASPOSITIONS = false;
        this.MORPHTARGETTEXTURE_HASNORMALS = false;
        this.MORPHTARGETTEXTURE_HASTANGENTS = false;
        this.MORPHTARGETTEXTURE_HASUVS = false;
        this.MORPHTARGETTEXTURE_HASUV2S = false;
        this.MORPHTARGETTEXTURE_HASCOLORS = false;
        this.NUM_MORPH_INFLUENCERS = 0;
        this.MORPHTARGETS_TEXTURE = false;
        this.MULTIVIEW = false;
        this.ORDER_INDEPENDENT_TRANSPARENCY = false;
        this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;
        this.USEPHYSICALLIGHTFALLOFF = false;
        this.USEGLTFLIGHTFALLOFF = false;
        this.TWOSIDEDLIGHTING = false;
        this.MIRRORED = false;
        this.SHADOWFLOAT = false;
        this.CLIPPLANE = false;
        this.CLIPPLANE2 = false;
        this.CLIPPLANE3 = false;
        this.CLIPPLANE4 = false;
        this.CLIPPLANE5 = false;
        this.CLIPPLANE6 = false;
        this.POINTSIZE = false;
        this.FOG = false;
        this.LOGARITHMICDEPTH = false;
        this.CAMERA_ORTHOGRAPHIC = false;
        this.CAMERA_PERSPECTIVE = false;
        this.AREALIGHTSUPPORTED = true;
        this.FORCENORMALFORWARD = false;
        this.SPECULARAA = false;
        this.UNLIT = false;
        this.DECAL_AFTER_DETAIL = false;
        this.DEBUGMODE = 0;
        this.USE_VERTEX_PULLING = false;
        this.RIGHT_HANDED = false;
        this.CLUSTLIGHT_SLICES = 0;
        this.CLUSTLIGHT_BATCH = 0;
        this.rebuild();
      }
      /**
       * Resets the PBR Material defines.
       */
      reset() {
        super.reset();
        this.ALPHATESTVALUE = "0.5";
        this.PBR = true;
        this.NORMALXYSCALE = true;
      }
    };
    PBRBaseMaterialBase = class extends ImageProcessingMixin(PushMaterial) {
    };
    PBRBaseMaterial = class _PBRBaseMaterial extends PBRBaseMaterialBase {
      /**
       * Enables realtime filtering on the texture.
       */
      get realTimeFiltering() {
        return this._realTimeFiltering;
      }
      set realTimeFiltering(b) {
        this._realTimeFiltering = b;
        this.markAsDirty(1);
      }
      /**
       * Quality switch for realtime filtering
       */
      get realTimeFilteringQuality() {
        return this._realTimeFilteringQuality;
      }
      set realTimeFilteringQuality(n) {
        this._realTimeFilteringQuality = n;
        this.markAsDirty(1);
      }
      /**
       * Can this material render to several textures at once
       */
      get canRenderToMRT() {
        return true;
      }
      /**
       * Instantiates a new PBRMaterial instance.
       *
       * @param name The material name
       * @param scene The scene the material will be use in.
       * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
       */
      constructor(name, scene, forceGLSL = false) {
        super(name, scene, void 0, forceGLSL || _PBRBaseMaterial.ForceGLSL);
        this._directIntensity = 1;
        this._emissiveIntensity = 1;
        this._environmentIntensity = 1;
        this._specularIntensity = 1;
        this._lightingInfos = new Vector4(this._directIntensity, this._emissiveIntensity, this._environmentIntensity, this._specularIntensity);
        this._disableBumpMap = false;
        this._albedoTexture = null;
        this._baseWeightTexture = null;
        this._baseDiffuseRoughnessTexture = null;
        this._ambientTexture = null;
        this._ambientTextureStrength = 1;
        this._ambientTextureImpactOnAnalyticalLights = _PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
        this._opacityTexture = null;
        this._reflectionTexture = null;
        this._emissiveTexture = null;
        this._reflectivityTexture = null;
        this._metallicTexture = null;
        this._metallic = null;
        this._roughness = null;
        this._metallicF0Factor = 1;
        this._metallicReflectanceColor = Color3.White();
        this._useOnlyMetallicFromMetallicReflectanceTexture = false;
        this._metallicReflectanceTexture = null;
        this._reflectanceTexture = null;
        this._microSurfaceTexture = null;
        this._bumpTexture = null;
        this._lightmapTexture = null;
        this._ambientColor = new Color3(0, 0, 0);
        this._albedoColor = new Color3(1, 1, 1);
        this._baseWeight = 1;
        this._baseDiffuseRoughness = null;
        this._reflectivityColor = new Color3(1, 1, 1);
        this._reflectionColor = new Color3(1, 1, 1);
        this._emissiveColor = new Color3(0, 0, 0);
        this._microSurface = 0.9;
        this._useLightmapAsShadowmap = false;
        this._useHorizonOcclusion = true;
        this._useRadianceOcclusion = true;
        this._useAlphaFromAlbedoTexture = false;
        this._useSpecularOverAlpha = true;
        this._useMicroSurfaceFromReflectivityMapAlpha = false;
        this._useRoughnessFromMetallicTextureAlpha = true;
        this._useRoughnessFromMetallicTextureGreen = false;
        this._useMetallnessFromMetallicTextureBlue = false;
        this._useAmbientOcclusionFromMetallicTextureRed = false;
        this._useAmbientInGrayScale = false;
        this._useAutoMicroSurfaceFromReflectivityMap = false;
        this._lightFalloff = _PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
        this._useRadianceOverAlpha = true;
        this._useObjectSpaceNormalMap = false;
        this._useParallax = false;
        this._useParallaxOcclusion = false;
        this._parallaxScaleBias = 0.05;
        this._disableLighting = false;
        this._maxSimultaneousLights = 4;
        this._invertNormalMapX = false;
        this._invertNormalMapY = false;
        this._twoSidedLighting = false;
        this._alphaCutOff = 0.4;
        this._useAlphaFresnel = false;
        this._useLinearAlphaFresnel = false;
        this._environmentBRDFTexture = null;
        this._forceIrradianceInFragment = false;
        this._realTimeFiltering = false;
        this._realTimeFilteringQuality = 8;
        this._forceNormalForward = false;
        this._enableSpecularAntiAliasing = false;
        this._renderTargets = new SmartArray(16);
        this._globalAmbientColor = new Color3(0, 0, 0);
        this._unlit = false;
        this._applyDecalMapAfterDetailMap = false;
        this._debugMode = 0;
        this._shadersLoaded = false;
        this._breakShaderLoadedCheck = false;
        this.debugMode = 0;
        this.debugLimit = -1;
        this.debugFactor = 1;
        this._cacheHasRenderTargetTextures = false;
        this.brdf = new PBRBRDFConfiguration(this);
        this.clearCoat = new PBRClearCoatConfiguration(this);
        this.iridescence = new PBRIridescenceConfiguration(this);
        this.anisotropy = new PBRAnisotropicConfiguration(this);
        this.sheen = new PBRSheenConfiguration(this);
        this.subSurface = new PBRSubSurfaceConfiguration(this);
        this.detailMap = new DetailMapConfiguration(this);
        this._attachImageProcessingConfiguration(null);
        this.getRenderTargetTextures = () => {
          this._renderTargets.reset();
          if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
            this._renderTargets.push(this._reflectionTexture);
          }
          this._eventInfo.renderTargets = this._renderTargets;
          this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);
          return this._renderTargets;
        };
        this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());
        this.prePassConfiguration = new PrePassConfiguration();
      }
      /**
       * Gets a boolean indicating that current material needs to register RTT
       */
      get hasRenderTargetTextures() {
        if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
          return true;
        }
        return this._cacheHasRenderTargetTextures;
      }
      /**
       * Can this material render to prepass
       */
      get isPrePassCapable() {
        return !this.disableDepthWrite;
      }
      /**
       * @returns the name of the material class.
       */
      getClassName() {
        return "PBRBaseMaterial";
      }
      /**
       * Returns true if alpha blending should be disabled.
       */
      get _disableAlphaBlending() {
        return this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_OPAQUE || this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_ALPHATEST || this.subSurface?.disableAlphaBlending;
      }
      /**
       * @returns whether or not this material should be rendered in alpha blend mode.
       */
      needAlphaBlending() {
        if (this._hasTransparencyMode) {
          return this._transparencyModeIsBlend;
        }
        if (this._disableAlphaBlending) {
          return false;
        }
        return this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromAlbedoTexture();
      }
      /**
       * @returns whether or not this material should be rendered in alpha test mode.
       */
      needAlphaTesting() {
        if (this._hasTransparencyMode) {
          return this._transparencyModeIsTest;
        }
        if (this.subSurface?.disableAlphaBlending) {
          return false;
        }
        return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_ALPHATEST);
      }
      /**
       * @returns whether or not the alpha value of the albedo texture should be used for alpha blending.
       */
      _shouldUseAlphaFromAlbedoTexture() {
        return this._albedoTexture != null && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== _PBRBaseMaterial.PBRMATERIAL_OPAQUE;
      }
      /**
       * @returns whether or not there is a usable alpha channel for transparency.
       */
      _hasAlphaChannel() {
        return this._albedoTexture != null && this._albedoTexture.hasAlpha || this._opacityTexture != null;
      }
      /**
       * @returns the texture used for the alpha test.
       */
      getAlphaTestTexture() {
        return this._albedoTexture;
      }
      /**
       * Specifies that the submesh is ready to be used.
       * @param mesh - BJS mesh.
       * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.
       * @param useInstances - Specifies that instances should be used.
       * @returns - boolean indicating that the submesh is ready or not.
       */
      isReadyForSubMesh(mesh, subMesh, useInstances) {
        if (!this._uniformBufferLayoutBuilt) {
          this.buildUniformLayout();
        }
        const drawWrapper = subMesh._drawWrapper;
        if (drawWrapper.effect && this.isFrozen) {
          if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
            return true;
          }
        }
        if (!subMesh.materialDefines) {
          this._callbackPluginEventGeneric(4, this._eventInfo);
          subMesh.materialDefines = new PBRMaterialDefines(this._eventInfo.defineNames);
        }
        const defines = subMesh.materialDefines;
        if (this._isReadyForSubMesh(subMesh)) {
          return true;
        }
        const scene = this.getScene();
        const engine = scene.getEngine();
        if (defines._areTexturesDirty) {
          this._eventInfo.hasRenderTargetTextures = false;
          this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
          this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;
          if (scene.texturesEnabled) {
            if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
              if (!this._albedoTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {
              if (!this._baseWeightTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {
              if (!this._baseDiffuseRoughnessTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
              if (!this._ambientTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
              if (!this._opacityTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            const reflectionTexture = this._getReflectionTexture();
            if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
              if (!reflectionTexture.isReadyOrNotBlocking()) {
                return false;
              }
              if (reflectionTexture.irradianceTexture) {
                if (!reflectionTexture.irradianceTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              } else {
                if (!reflectionTexture.sphericalPolynomial && reflectionTexture.getInternalTexture()?._sphericalPolynomialPromise) {
                  return false;
                }
              }
            }
            if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
              if (!this._lightmapTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
              if (!this._emissiveTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (MaterialFlags.SpecularTextureEnabled) {
              if (this._metallicTexture) {
                if (!this._metallicTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              } else if (this._reflectivityTexture) {
                if (!this._reflectivityTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              }
              if (this._metallicReflectanceTexture) {
                if (!this._metallicReflectanceTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              }
              if (this._reflectanceTexture) {
                if (!this._reflectanceTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              }
              if (this._microSurfaceTexture) {
                if (!this._microSurfaceTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              }
            }
            if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
              if (!this._bumpTexture.isReady()) {
                return false;
              }
            }
            if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
              if (!this._environmentBRDFTexture.isReady()) {
                return false;
              }
            }
          }
        }
        this._eventInfo.isReadyForSubMesh = true;
        this._eventInfo.defines = defines;
        this._eventInfo.subMesh = subMesh;
        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
        if (!this._eventInfo.isReadyForSubMesh) {
          return false;
        }
        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
          if (!this._imageProcessingConfiguration.isReady()) {
            return false;
          }
        }
        if (defines["AREALIGHTUSED"] || defines["CLUSTLIGHT_BATCH"]) {
          for (let index = 0; index < mesh.lightSources.length; index++) {
            if (!mesh.lightSources[index]._isReady()) {
              return false;
            }
          }
        }
        if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          mesh.createNormals(true);
          Logger.Warn("PBRMaterial: Normals have been created for the mesh: " + mesh.name);
        }
        const previousEffect = subMesh.effect;
        const lightDisposed = defines._areLightsDisposed;
        let effect = this._prepareEffect(mesh, subMesh.getRenderingMesh(), defines, this.onCompiled, this.onError, useInstances, null);
        let forceWasNotReadyPreviously = false;
        if (effect) {
          if (this._onEffectCreatedObservable) {
            onCreatedEffectParameters2.effect = effect;
            onCreatedEffectParameters2.subMesh = subMesh;
            this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters2);
          }
          if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
            effect = previousEffect;
            defines.markAsUnprocessed();
            forceWasNotReadyPreviously = this.isFrozen;
            if (lightDisposed) {
              defines._areLightsDisposed = true;
              return false;
            }
          } else {
            scene.resetCachedMaterial();
            subMesh.setEffect(effect, defines, this._materialContext);
          }
        }
        if (!subMesh.effect || !subMesh.effect.isReady()) {
          return false;
        }
        defines._renderId = scene.getRenderId();
        drawWrapper._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;
        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
        this._checkScenePerformancePriority();
        return true;
      }
      /**
       * Specifies if the material uses metallic roughness workflow.
       * @returns boolean specifying if the material uses metallic roughness workflow.
       */
      isMetallicWorkflow() {
        if (this._metallic != null || this._roughness != null || this._metallicTexture) {
          return true;
        }
        return false;
      }
      _prepareEffect(mesh, renderingMesh, defines, onCompiled = null, onError = null, useInstances = null, useClipPlane = null) {
        this._prepareDefines(mesh, renderingMesh, defines, useInstances, useClipPlane);
        if (!defines.isDirty) {
          return null;
        }
        defines.markAsProcessed();
        const scene = this.getScene();
        const engine = scene.getEngine();
        const fallbacks = new EffectFallbacks();
        let fallbackRank = 0;
        if (defines.USESPHERICALINVERTEX) {
          fallbacks.addFallback(fallbackRank++, "USESPHERICALINVERTEX");
        }
        if (defines.FOG) {
          fallbacks.addFallback(fallbackRank, "FOG");
        }
        if (defines.SPECULARAA) {
          fallbacks.addFallback(fallbackRank, "SPECULARAA");
        }
        if (defines.POINTSIZE) {
          fallbacks.addFallback(fallbackRank, "POINTSIZE");
        }
        if (defines.LOGARITHMICDEPTH) {
          fallbacks.addFallback(fallbackRank, "LOGARITHMICDEPTH");
        }
        if (defines.PARALLAX) {
          fallbacks.addFallback(fallbackRank, "PARALLAX");
        }
        if (defines.PARALLAX_RHS) {
          fallbacks.addFallback(fallbackRank, "PARALLAX_RHS");
        }
        if (defines.PARALLAXOCCLUSION) {
          fallbacks.addFallback(fallbackRank++, "PARALLAXOCCLUSION");
        }
        if (defines.ENVIRONMENTBRDF) {
          fallbacks.addFallback(fallbackRank++, "ENVIRONMENTBRDF");
        }
        if (defines.TANGENT) {
          fallbacks.addFallback(fallbackRank++, "TANGENT");
        }
        if (defines.BUMP) {
          fallbacks.addFallback(fallbackRank++, "BUMP");
        }
        fallbackRank = HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);
        if (defines.SPECULARTERM) {
          fallbacks.addFallback(fallbackRank++, "SPECULARTERM");
        }
        if (defines.USESPHERICALFROMREFLECTIONMAP) {
          fallbacks.addFallback(fallbackRank++, "USESPHERICALFROMREFLECTIONMAP");
        }
        if (defines.USEIRRADIANCEMAP) {
          fallbacks.addFallback(fallbackRank++, "USEIRRADIANCEMAP");
        }
        if (defines.LIGHTMAP) {
          fallbacks.addFallback(fallbackRank++, "LIGHTMAP");
        }
        if (defines.NORMAL) {
          fallbacks.addFallback(fallbackRank++, "NORMAL");
        }
        if (defines.AMBIENT) {
          fallbacks.addFallback(fallbackRank++, "AMBIENT");
        }
        if (defines.EMISSIVE) {
          fallbacks.addFallback(fallbackRank++, "EMISSIVE");
        }
        if (defines.VERTEXCOLOR) {
          fallbacks.addFallback(fallbackRank++, "VERTEXCOLOR");
        }
        if (defines.MORPHTARGETS) {
          fallbacks.addFallback(fallbackRank++, "MORPHTARGETS");
        }
        if (defines.MULTIVIEW) {
          fallbacks.addFallback(0, "MULTIVIEW");
        }
        const attribs = [VertexBuffer.PositionKind];
        if (defines.NORMAL) {
          attribs.push(VertexBuffer.NormalKind);
        }
        if (defines.TANGENT) {
          attribs.push(VertexBuffer.TangentKind);
        }
        for (let i = 1; i <= 6; ++i) {
          if (defines["UV" + i]) {
            attribs.push(`uv${i === 1 ? "" : i}`);
          }
        }
        if (defines.VERTEXCOLOR) {
          attribs.push(VertexBuffer.ColorKind);
        }
        PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
        PrepareAttributesForInstances(attribs, defines);
        PrepareAttributesForMorphTargets(attribs, mesh, defines);
        PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
        let shaderName = "pbr";
        const uniforms = [
          "world",
          "view",
          "viewProjection",
          "vEyePosition",
          "vLightsType",
          "vAmbientColor",
          "vAlbedoColor",
          "baseWeight",
          "baseDiffuseRoughness",
          "vReflectivityColor",
          "vMetallicReflectanceFactors",
          "vEmissiveColor",
          "visibility",
          "vFogInfos",
          "vFogColor",
          "pointSize",
          "vAlbedoInfos",
          "vBaseWeightInfos",
          "vBaseDiffuseRoughnessInfos",
          "vAmbientInfos",
          "vOpacityInfos",
          "vEmissiveInfos",
          "vReflectivityInfos",
          "vMetallicReflectanceInfos",
          "vReflectanceInfos",
          "vMicroSurfaceSamplerInfos",
          "vBumpInfos",
          "vLightmapInfos",
          "mBones",
          "albedoMatrix",
          "baseWeightMatrix",
          "baseDiffuseRoughnessMatrix",
          "ambientMatrix",
          "opacityMatrix",
          "emissiveMatrix",
          "reflectivityMatrix",
          "normalMatrix",
          "microSurfaceSamplerMatrix",
          "bumpMatrix",
          "lightmapMatrix",
          "metallicReflectanceMatrix",
          "reflectanceMatrix",
          "vLightingIntensity",
          "logarithmicDepthConstant",
          "vTangentSpaceParams",
          "boneTextureWidth",
          "vDebugMode",
          "morphTargetTextureInfo",
          "morphTargetTextureIndices",
          "cameraInfo"
        ];
        const samplers = [
          "albedoSampler",
          "baseWeightSampler",
          "baseDiffuseRoughnessSampler",
          "reflectivitySampler",
          "ambientSampler",
          "emissiveSampler",
          "bumpSampler",
          "lightmapSampler",
          "opacitySampler",
          "microSurfaceSampler",
          "environmentBrdfSampler",
          "boneSampler",
          "metallicReflectanceSampler",
          "reflectanceSampler",
          "morphTargets",
          "oitDepthSampler",
          "oitFrontColorSampler",
          "areaLightsLTC1Sampler",
          "areaLightsLTC2Sampler"
        ];
        PrepareUniformsAndSamplersForIBL(uniforms, samplers, true);
        const uniformBuffers = ["Material", "Scene", "Mesh"];
        const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };
        this._eventInfo.fallbacks = fallbacks;
        this._eventInfo.fallbackRank = fallbackRank;
        this._eventInfo.defines = defines;
        this._eventInfo.uniforms = uniforms;
        this._eventInfo.attributes = attribs;
        this._eventInfo.samplers = samplers;
        this._eventInfo.uniformBuffersNames = uniformBuffers;
        this._eventInfo.customCode = void 0;
        this._eventInfo.mesh = mesh;
        this._eventInfo.indexParameters = indexParameters;
        this._callbackPluginEventGeneric(128, this._eventInfo);
        MaterialHelperGeometryRendering.AddUniformsAndSamplers(uniforms, samplers);
        PrePassConfiguration.AddUniforms(uniforms);
        PrePassConfiguration.AddSamplers(samplers);
        AddClipPlaneUniforms(uniforms);
        if (ImageProcessingConfiguration) {
          ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
          ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
        }
        PrepareUniformsAndSamplersList({
          uniformsNames: uniforms,
          uniformBuffersNames: uniformBuffers,
          samplers,
          defines,
          maxSimultaneousLights: this._maxSimultaneousLights
        });
        const csnrOptions = {};
        if (this.customShaderNameResolve) {
          shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
        }
        const join = defines.toString();
        const effect = engine.createEffect(shaderName, {
          attributes: attribs,
          uniformsNames: uniforms,
          uniformBuffersNames: uniformBuffers,
          samplers,
          defines: join,
          fallbacks,
          onCompiled,
          onError,
          indexParameters,
          processFinalCode: csnrOptions.processFinalCode,
          processCodeAfterIncludes: this._eventInfo.customCode,
          multiTarget: defines.PREPASS,
          shaderLanguage: this._shaderLanguage,
          extraInitializationsAsync: this._shadersLoaded ? void 0 : async () => {
            if (this.shaderLanguage === 1) {
              await Promise.all([import("./pbr.vertex-37OPNSQP.js"), import("./pbr.fragment-7A5FZGTL.js")]);
            } else {
              await Promise.all([import("./pbr.vertex-EFFX3F6T.js"), import("./pbr.fragment-XFD4WGDL.js")]);
            }
            this._shadersLoaded = true;
          }
        }, engine);
        this._eventInfo.customCode = void 0;
        return effect;
      }
      _prepareDefines(mesh, renderingMesh, defines, useInstances = null, useClipPlane = null) {
        const useThinInstances = renderingMesh.hasThinInstances;
        const scene = this.getScene();
        const engine = scene.getEngine();
        PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
        defines._needNormals = true;
        PrepareDefinesForMultiview(scene, defines);
        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
        PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);
        PrepareDefinesForOIT(scene, defines, oit);
        MaterialHelperGeometryRendering.PrepareDefines(engine.currentRenderPassId, mesh, defines);
        defines.METALLICWORKFLOW = this.isMetallicWorkflow();
        if (defines._areTexturesDirty) {
          defines._needUVs = false;
          for (let i = 1; i <= 6; ++i) {
            defines["MAINUV" + i] = false;
          }
          if (scene.texturesEnabled) {
            defines.ALBEDODIRECTUV = 0;
            defines.BASE_WEIGHTDIRECTUV = 0;
            defines.BASE_DIFFUSE_ROUGHNESSDIRECTUV = 0;
            defines.AMBIENTDIRECTUV = 0;
            defines.OPACITYDIRECTUV = 0;
            defines.EMISSIVEDIRECTUV = 0;
            defines.REFLECTIVITYDIRECTUV = 0;
            defines.MICROSURFACEMAPDIRECTUV = 0;
            defines.METALLIC_REFLECTANCEDIRECTUV = 0;
            defines.REFLECTANCEDIRECTUV = 0;
            defines.BUMPDIRECTUV = 0;
            defines.LIGHTMAPDIRECTUV = 0;
            if (engine.getCaps().textureLOD) {
              defines.LODBASEDMICROSFURACE = true;
            }
            if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
              PrepareDefinesForMergedUV(this._albedoTexture, defines, "ALBEDO");
              defines.GAMMAALBEDO = this._albedoTexture.gammaSpace;
            } else {
              defines.ALBEDO = false;
            }
            if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {
              PrepareDefinesForMergedUV(this._baseWeightTexture, defines, "BASE_WEIGHT");
            } else {
              defines.BASE_WEIGHT = false;
            }
            if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {
              PrepareDefinesForMergedUV(this._baseDiffuseRoughnessTexture, defines, "BASE_DIFFUSE_ROUGHNESS");
            } else {
              defines.BASE_DIFFUSE_ROUGHNESS = false;
            }
            if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
              PrepareDefinesForMergedUV(this._ambientTexture, defines, "AMBIENT");
              defines.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale;
            } else {
              defines.AMBIENT = false;
            }
            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
              PrepareDefinesForMergedUV(this._opacityTexture, defines, "OPACITY");
              defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
            } else {
              defines.OPACITY = false;
            }
            const reflectionTexture = this._getReflectionTexture();
            const useSHInFragment = this._forceIrradianceInFragment || this.realTimeFiltering || this._twoSidedLighting || engine.getCaps().maxVaryingVectors <= 8 || this._baseDiffuseRoughnessTexture != null;
            PrepareDefinesForIBL(scene, reflectionTexture, defines, this.realTimeFiltering, this.realTimeFilteringQuality, !useSHInFragment);
            if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
              PrepareDefinesForMergedUV(this._lightmapTexture, defines, "LIGHTMAP");
              defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;
              defines.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace;
              defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
            } else {
              defines.LIGHTMAP = false;
            }
            if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
              PrepareDefinesForMergedUV(this._emissiveTexture, defines, "EMISSIVE");
              defines.GAMMAEMISSIVE = this._emissiveTexture.gammaSpace;
            } else {
              defines.EMISSIVE = false;
            }
            if (MaterialFlags.SpecularTextureEnabled) {
              if (this._metallicTexture) {
                PrepareDefinesForMergedUV(this._metallicTexture, defines, "REFLECTIVITY");
                defines.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha;
                defines.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen;
                defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue;
                defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;
                defines.REFLECTIVITY_GAMMA = false;
              } else if (this._reflectivityTexture) {
                PrepareDefinesForMergedUV(this._reflectivityTexture, defines, "REFLECTIVITY");
                defines.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha;
                defines.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap;
                defines.REFLECTIVITY_GAMMA = this._reflectivityTexture.gammaSpace;
              } else {
                defines.REFLECTIVITY = false;
              }
              if (this._metallicReflectanceTexture || this._reflectanceTexture) {
                defines.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = this._useOnlyMetallicFromMetallicReflectanceTexture;
                if (this._metallicReflectanceTexture) {
                  PrepareDefinesForMergedUV(this._metallicReflectanceTexture, defines, "METALLIC_REFLECTANCE");
                  defines.METALLIC_REFLECTANCE_GAMMA = this._metallicReflectanceTexture.gammaSpace;
                } else {
                  defines.METALLIC_REFLECTANCE = false;
                }
                if (this._reflectanceTexture && (!this._metallicReflectanceTexture || this._metallicReflectanceTexture && this._useOnlyMetallicFromMetallicReflectanceTexture)) {
                  PrepareDefinesForMergedUV(this._reflectanceTexture, defines, "REFLECTANCE");
                  defines.REFLECTANCE_GAMMA = this._reflectanceTexture.gammaSpace;
                } else {
                  defines.REFLECTANCE = false;
                }
              } else {
                defines.METALLIC_REFLECTANCE = false;
                defines.REFLECTANCE = false;
              }
              if (this._microSurfaceTexture) {
                PrepareDefinesForMergedUV(this._microSurfaceTexture, defines, "MICROSURFACEMAP");
              } else {
                defines.MICROSURFACEMAP = false;
              }
            } else {
              defines.REFLECTIVITY = false;
              defines.MICROSURFACEMAP = false;
            }
            if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
              PrepareDefinesForMergedUV(this._bumpTexture, defines, "BUMP");
              if (this._useParallax && this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
                defines.PARALLAX = true;
                defines.PARALLAX_RHS = scene.useRightHandedSystem;
                defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;
              } else {
                defines.PARALLAX = false;
              }
              defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
            } else {
              defines.BUMP = false;
              defines.PARALLAX = false;
              defines.PARALLAX_RHS = false;
              defines.PARALLAXOCCLUSION = false;
              defines.OBJECTSPACE_NORMALMAP = false;
            }
            if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
              defines.ENVIRONMENTBRDF = true;
              defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;
            } else {
              defines.ENVIRONMENTBRDF = false;
              defines.ENVIRONMENTBRDF_RGBD = false;
            }
            if (this._shouldUseAlphaFromAlbedoTexture()) {
              defines.ALPHAFROMALBEDO = true;
            } else {
              defines.ALPHAFROMALBEDO = false;
            }
          }
          defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;
          if (this._lightFalloff === _PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {
            defines.USEPHYSICALLIGHTFALLOFF = false;
            defines.USEGLTFLIGHTFALLOFF = false;
          } else if (this._lightFalloff === _PBRBaseMaterial.LIGHTFALLOFF_GLTF) {
            defines.USEPHYSICALLIGHTFALLOFF = false;
            defines.USEGLTFLIGHTFALLOFF = true;
          } else {
            defines.USEPHYSICALLIGHTFALLOFF = true;
            defines.USEGLTFLIGHTFALLOFF = false;
          }
          defines.RADIANCEOVERALPHA = this._useRadianceOverAlpha;
          if (!this.backFaceCulling && this._twoSidedLighting) {
            defines.TWOSIDEDLIGHTING = true;
          } else {
            defines.TWOSIDEDLIGHTING = false;
          }
          defines.MIRRORED = !!scene._mirroredCameraPosition;
          defines.SPECULARAA = engine.getCaps().standardDerivatives && this._enableSpecularAntiAliasing;
        }
        if (defines._areTexturesDirty || defines._areMiscDirty) {
          defines.ALPHATESTVALUE = `${this._alphaCutOff}${this._alphaCutOff % 1 === 0 ? "." : ""}`;
          defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
          defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);
          defines.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel;
          defines.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel;
        }
        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
          this._imageProcessingConfiguration.prepareDefines(defines);
        }
        defines.FORCENORMALFORWARD = this._forceNormalForward;
        defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;
        defines.HORIZONOCCLUSION = this._useHorizonOcclusion;
        if (defines._areMiscDirty) {
          PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines, this._applyDecalMapAfterDetailMap, this._useVertexPulling, renderingMesh, this._isVertexOutputInvariant);
          defines.UNLIT = this._unlit || (this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
          defines.DEBUGMODE = this._debugMode;
        }
        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, useClipPlane, useThinInstances);
        this._eventInfo.defines = defines;
        this._eventInfo.mesh = mesh;
        this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);
        PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== _PBRBaseMaterial.PBRMATERIAL_OPAQUE);
        this._callbackPluginEventPrepareDefines(this._eventInfo);
      }
      /**
       * Force shader compilation
       * @param mesh - Define the mesh we want to force the compilation for
       * @param onCompiled - Define a callback triggered when the compilation completes
       * @param options - Define the options used to create the compilation
       */
      forceCompilation(mesh, onCompiled, options) {
        const localOptions = {
          clipPlane: false,
          useInstances: false,
          ...options
        };
        if (!this._uniformBufferLayoutBuilt) {
          this.buildUniformLayout();
        }
        this._callbackPluginEventGeneric(4, this._eventInfo);
        const checkReady = () => {
          if (this._breakShaderLoadedCheck) {
            return;
          }
          const defines = new PBRMaterialDefines(this._eventInfo.defineNames);
          const effect = this._prepareEffect(mesh, mesh, defines, void 0, void 0, localOptions.useInstances, localOptions.clipPlane);
          if (this._onEffectCreatedObservable) {
            onCreatedEffectParameters2.effect = effect;
            onCreatedEffectParameters2.subMesh = null;
            this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters2);
          }
          if (effect.isReady()) {
            if (onCompiled) {
              onCompiled(this);
            }
          } else {
            effect.onCompileObservable.add(() => {
              if (onCompiled) {
                onCompiled(this);
              }
            });
          }
        };
        checkReady();
      }
      /**
       * Initializes the uniform buffer layout for the shader.
       */
      buildUniformLayout() {
        const ubo = this._uniformBuffer;
        ubo.addUniform("vAlbedoInfos", 2);
        ubo.addUniform("vBaseWeightInfos", 2);
        ubo.addUniform("vBaseDiffuseRoughnessInfos", 2);
        ubo.addUniform("vAmbientInfos", 4);
        ubo.addUniform("vOpacityInfos", 2);
        ubo.addUniform("vEmissiveInfos", 2);
        ubo.addUniform("vLightmapInfos", 2);
        ubo.addUniform("vReflectivityInfos", 3);
        ubo.addUniform("vMicroSurfaceSamplerInfos", 2);
        ubo.addUniform("vBumpInfos", 3);
        ubo.addUniform("albedoMatrix", 16);
        ubo.addUniform("baseWeightMatrix", 16);
        ubo.addUniform("baseDiffuseRoughnessMatrix", 16);
        ubo.addUniform("ambientMatrix", 16);
        ubo.addUniform("opacityMatrix", 16);
        ubo.addUniform("emissiveMatrix", 16);
        ubo.addUniform("lightmapMatrix", 16);
        ubo.addUniform("reflectivityMatrix", 16);
        ubo.addUniform("microSurfaceSamplerMatrix", 16);
        ubo.addUniform("bumpMatrix", 16);
        ubo.addUniform("vTangentSpaceParams", 2);
        ubo.addUniform("vAlbedoColor", 4);
        ubo.addUniform("baseWeight", 1);
        ubo.addUniform("baseDiffuseRoughness", 1);
        ubo.addUniform("vLightingIntensity", 4);
        ubo.addUniform("pointSize", 1);
        ubo.addUniform("vReflectivityColor", 4);
        ubo.addUniform("vEmissiveColor", 3);
        ubo.addUniform("vAmbientColor", 3);
        ubo.addUniform("vDebugMode", 2);
        ubo.addUniform("vMetallicReflectanceFactors", 4);
        ubo.addUniform("vMetallicReflectanceInfos", 2);
        ubo.addUniform("metallicReflectanceMatrix", 16);
        ubo.addUniform("vReflectanceInfos", 2);
        ubo.addUniform("reflectanceMatrix", 16);
        ubo.addUniform("cameraInfo", 4);
        PrepareUniformLayoutForIBL(ubo, true, true, true, true, true);
        super.buildUniformLayout();
      }
      /**
       * Binds the submesh data.
       * @param world - The world matrix.
       * @param mesh - The BJS mesh.
       * @param subMesh - A submesh of the BJS mesh.
       */
      bindForSubMesh(world, mesh, subMesh) {
        const scene = this.getScene();
        const defines = subMesh.materialDefines;
        if (!defines) {
          return;
        }
        const effect = subMesh.effect;
        if (!effect) {
          return;
        }
        this._activeEffect = effect;
        mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
        mesh.transferToEffect(world);
        const engine = scene.getEngine();
        this._uniformBuffer.bindToEffect(effect, "Material");
        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
        MaterialHelperGeometryRendering.Bind(engine.currentRenderPassId, this._activeEffect, mesh, world, this);
        const camera = scene.activeCamera;
        if (camera) {
          this._uniformBuffer.updateFloat4("cameraInfo", camera.minZ, camera.maxZ, 0, 0);
        } else {
          this._uniformBuffer.updateFloat4("cameraInfo", 0, 0, 0, 0);
        }
        this._eventInfo.subMesh = subMesh;
        this._callbackPluginEventHardBindForSubMesh(this._eventInfo);
        if (defines.OBJECTSPACE_NORMALMAP) {
          world.toNormalMatrix(this._normalMatrix);
          this.bindOnlyNormalMatrix(this._normalMatrix);
        }
        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
        BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);
        let reflectionTexture = null;
        const ubo = this._uniformBuffer;
        if (mustRebind) {
          this.bindViewProjection(effect);
          reflectionTexture = this._getReflectionTexture();
          if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || subMesh._drawWrapper._forceRebindOnNextCall) {
            if (scene.texturesEnabled) {
              if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
                ubo.updateFloat2("vAlbedoInfos", this._albedoTexture.coordinatesIndex, this._albedoTexture.level);
                BindTextureMatrix(this._albedoTexture, ubo, "albedo");
              }
              if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {
                ubo.updateFloat2("vBaseWeightInfos", this._baseWeightTexture.coordinatesIndex, this._baseWeightTexture.level);
                BindTextureMatrix(this._baseWeightTexture, ubo, "baseWeight");
              }
              if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {
                ubo.updateFloat2("vBaseDiffuseRoughnessInfos", this._baseDiffuseRoughnessTexture.coordinatesIndex, this._baseDiffuseRoughnessTexture.level);
                BindTextureMatrix(this._baseDiffuseRoughnessTexture, ubo, "baseDiffuseRoughness");
              }
              if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
                ubo.updateFloat4("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level, this._ambientTextureStrength, this._ambientTextureImpactOnAnalyticalLights);
                BindTextureMatrix(this._ambientTexture, ubo, "ambient");
              }
              if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
                ubo.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
                BindTextureMatrix(this._opacityTexture, ubo, "opacity");
              }
              if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
                ubo.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);
                BindTextureMatrix(this._emissiveTexture, ubo, "emissive");
              }
              if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
                ubo.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);
                BindTextureMatrix(this._lightmapTexture, ubo, "lightmap");
              }
              if (MaterialFlags.SpecularTextureEnabled) {
                if (this._metallicTexture) {
                  ubo.updateFloat3("vReflectivityInfos", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength);
                  BindTextureMatrix(this._metallicTexture, ubo, "reflectivity");
                } else if (this._reflectivityTexture) {
                  ubo.updateFloat3("vReflectivityInfos", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1);
                  BindTextureMatrix(this._reflectivityTexture, ubo, "reflectivity");
                }
                if (this._metallicReflectanceTexture) {
                  ubo.updateFloat2("vMetallicReflectanceInfos", this._metallicReflectanceTexture.coordinatesIndex, this._metallicReflectanceTexture.level);
                  BindTextureMatrix(this._metallicReflectanceTexture, ubo, "metallicReflectance");
                }
                if (this._reflectanceTexture && defines.REFLECTANCE) {
                  ubo.updateFloat2("vReflectanceInfos", this._reflectanceTexture.coordinatesIndex, this._reflectanceTexture.level);
                  BindTextureMatrix(this._reflectanceTexture, ubo, "reflectance");
                }
                if (this._microSurfaceTexture) {
                  ubo.updateFloat2("vMicroSurfaceSamplerInfos", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level);
                  BindTextureMatrix(this._microSurfaceTexture, ubo, "microSurfaceSampler");
                }
              }
              if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
                ubo.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias);
                BindTextureMatrix(this._bumpTexture, ubo, "bump");
                if (scene._mirroredCameraPosition) {
                  ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
                } else {
                  ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
                }
              }
              BindIBLParameters(scene, defines, ubo, this._reflectionColor, reflectionTexture, this.realTimeFiltering, true, true, true, true, true);
            }
            if (this.pointsCloud) {
              ubo.updateFloat("pointSize", this.pointSize);
            }
            if (defines.METALLICWORKFLOW) {
              TmpColors.Color4[0].r = this._metallic === void 0 || this._metallic === null ? 1 : this._metallic;
              TmpColors.Color4[0].g = this._roughness === void 0 || this._roughness === null ? 1 : this._roughness;
              const ior = this.subSurface?._indexOfRefraction ?? 1.5;
              const outsideIOR = 1;
              TmpColors.Color4[0].b = ior;
              const f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);
              TmpColors.Color4[0].a = f0;
              ubo.updateDirectColor4("vReflectivityColor", TmpColors.Color4[0]);
              ubo.updateColor4("vMetallicReflectanceFactors", this._metallicReflectanceColor, this._metallicF0Factor);
            } else {
              ubo.updateColor4("vReflectivityColor", this._reflectivityColor, this._microSurface);
            }
            ubo.updateColor3("vEmissiveColor", MaterialFlags.EmissiveTextureEnabled ? this._emissiveColor : Color3.BlackReadOnly);
            if (!defines.SS_REFRACTION && this.subSurface?._linkRefractionWithTransparency) {
              ubo.updateColor4("vAlbedoColor", this._albedoColor, 1);
            } else {
              ubo.updateColor4("vAlbedoColor", this._albedoColor, this.alpha);
            }
            ubo.updateFloat("baseWeight", this._baseWeight);
            ubo.updateFloat("baseDiffuseRoughness", this._baseDiffuseRoughness || 0);
            this._lightingInfos.x = this._directIntensity;
            this._lightingInfos.y = this._emissiveIntensity;
            this._lightingInfos.z = this._environmentIntensity * scene.environmentIntensity;
            this._lightingInfos.w = this._specularIntensity;
            ubo.updateVector4("vLightingIntensity", this._lightingInfos);
            scene.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);
            ubo.updateColor3("vAmbientColor", this._globalAmbientColor);
            ubo.updateFloat2("vDebugMode", this.debugLimit, this.debugFactor);
          }
          if (scene.texturesEnabled) {
            if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
              ubo.setTexture("albedoSampler", this._albedoTexture);
            }
            if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {
              ubo.setTexture("baseWeightSampler", this._baseWeightTexture);
            }
            if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {
              ubo.setTexture("baseDiffuseRoughnessSampler", this._baseDiffuseRoughnessTexture);
            }
            if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
              ubo.setTexture("ambientSampler", this._ambientTexture);
            }
            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
              ubo.setTexture("opacitySampler", this._opacityTexture);
            }
            BindIBLSamplers(scene, defines, ubo, reflectionTexture, this.realTimeFiltering);
            if (defines.ENVIRONMENTBRDF) {
              ubo.setTexture("environmentBrdfSampler", this._environmentBRDFTexture);
            }
            if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
              ubo.setTexture("emissiveSampler", this._emissiveTexture);
            }
            if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
              ubo.setTexture("lightmapSampler", this._lightmapTexture);
            }
            if (MaterialFlags.SpecularTextureEnabled) {
              if (this._metallicTexture) {
                ubo.setTexture("reflectivitySampler", this._metallicTexture);
              } else if (this._reflectivityTexture) {
                ubo.setTexture("reflectivitySampler", this._reflectivityTexture);
              }
              if (this._metallicReflectanceTexture) {
                ubo.setTexture("metallicReflectanceSampler", this._metallicReflectanceTexture);
              }
              if (this._reflectanceTexture && defines.REFLECTANCE) {
                ubo.setTexture("reflectanceSampler", this._reflectanceTexture);
              }
              if (this._microSurfaceTexture) {
                ubo.setTexture("microSurfaceSampler", this._microSurfaceTexture);
              }
            }
            if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
              ubo.setTexture("bumpSampler", this._bumpTexture);
            }
          }
          if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {
            this.getScene().depthPeelingRenderer.bind(effect);
          }
          this._eventInfo.subMesh = subMesh;
          this._callbackPluginEventBindForSubMesh(this._eventInfo);
          BindClipPlane(this._activeEffect, this, scene);
          this.bindEyePosition(effect);
        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
          this._needToBindSceneUbo = true;
        }
        if (mustRebind || !this.isFrozen) {
          if (scene.lightsEnabled && !this._disableLighting) {
            BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);
          }
          if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || reflectionTexture || this.subSurface.refractionTexture || mesh.receiveShadows || defines.PREPASS || defines["CLUSTLIGHT_BATCH"]) {
            this.bindView(effect);
          }
          BindFogParameters(scene, mesh, this._activeEffect, true);
          if (defines.NUM_MORPH_INFLUENCERS) {
            BindMorphTargetParameters(mesh, this._activeEffect);
          }
          if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {
            mesh.bakedVertexAnimationManager?.bind(effect, defines.INSTANCES);
          }
          this._imageProcessingConfiguration.bind(this._activeEffect);
          BindLogDepth(defines, this._activeEffect, scene);
        }
        this._afterBind(mesh, this._activeEffect, subMesh);
        ubo.update();
      }
      /**
       * Returns the animatable textures.
       * If material have animatable metallic texture, then reflectivity texture will not be returned, even if it has animations.
       * @returns - Array of animatable textures.
       */
      getAnimatables() {
        const results = super.getAnimatables();
        if (this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0) {
          results.push(this._albedoTexture);
        }
        if (this._baseWeightTexture && this._baseWeightTexture.animations && this._baseWeightTexture.animations.length > 0) {
          results.push(this._baseWeightTexture);
        }
        if (this._baseDiffuseRoughnessTexture && this._baseDiffuseRoughnessTexture.animations && this._baseDiffuseRoughnessTexture.animations.length > 0) {
          results.push(this._baseDiffuseRoughnessTexture);
        }
        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {
          results.push(this._ambientTexture);
        }
        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
          results.push(this._opacityTexture);
        }
        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {
          results.push(this._reflectionTexture);
        }
        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {
          results.push(this._emissiveTexture);
        }
        if (this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0) {
          results.push(this._metallicTexture);
        } else if (this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0) {
          results.push(this._reflectivityTexture);
        }
        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
          results.push(this._bumpTexture);
        }
        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {
          results.push(this._lightmapTexture);
        }
        if (this._metallicReflectanceTexture && this._metallicReflectanceTexture.animations && this._metallicReflectanceTexture.animations.length > 0) {
          results.push(this._metallicReflectanceTexture);
        }
        if (this._reflectanceTexture && this._reflectanceTexture.animations && this._reflectanceTexture.animations.length > 0) {
          results.push(this._reflectanceTexture);
        }
        if (this._microSurfaceTexture && this._microSurfaceTexture.animations && this._microSurfaceTexture.animations.length > 0) {
          results.push(this._microSurfaceTexture);
        }
        return results;
      }
      /**
       * Returns the texture used for reflections.
       * @returns - Reflection texture if present.  Otherwise, returns the environment texture.
       */
      _getReflectionTexture() {
        if (this._reflectionTexture) {
          return this._reflectionTexture;
        }
        return this.getScene().environmentTexture;
      }
      /**
       * Returns an array of the actively used textures.
       * @returns - Array of BaseTextures
       */
      getActiveTextures() {
        const activeTextures = super.getActiveTextures();
        if (this._albedoTexture) {
          activeTextures.push(this._albedoTexture);
        }
        if (this._baseWeightTexture) {
          activeTextures.push(this._baseWeightTexture);
        }
        if (this._baseDiffuseRoughnessTexture) {
          activeTextures.push(this._baseDiffuseRoughnessTexture);
        }
        if (this._ambientTexture) {
          activeTextures.push(this._ambientTexture);
        }
        if (this._opacityTexture) {
          activeTextures.push(this._opacityTexture);
        }
        if (this._reflectionTexture) {
          activeTextures.push(this._reflectionTexture);
        }
        if (this._emissiveTexture) {
          activeTextures.push(this._emissiveTexture);
        }
        if (this._reflectivityTexture) {
          activeTextures.push(this._reflectivityTexture);
        }
        if (this._metallicTexture) {
          activeTextures.push(this._metallicTexture);
        }
        if (this._metallicReflectanceTexture) {
          activeTextures.push(this._metallicReflectanceTexture);
        }
        if (this._reflectanceTexture) {
          activeTextures.push(this._reflectanceTexture);
        }
        if (this._microSurfaceTexture) {
          activeTextures.push(this._microSurfaceTexture);
        }
        if (this._bumpTexture) {
          activeTextures.push(this._bumpTexture);
        }
        if (this._lightmapTexture) {
          activeTextures.push(this._lightmapTexture);
        }
        return activeTextures;
      }
      /**
       * Checks to see if a texture is used in the material.
       * @param texture - Base texture to use.
       * @returns - Boolean specifying if a texture is used in the material.
       */
      hasTexture(texture) {
        if (super.hasTexture(texture)) {
          return true;
        }
        if (this._albedoTexture === texture) {
          return true;
        }
        if (this._baseWeightTexture === texture) {
          return true;
        }
        if (this._baseDiffuseRoughnessTexture === texture) {
          return true;
        }
        if (this._ambientTexture === texture) {
          return true;
        }
        if (this._opacityTexture === texture) {
          return true;
        }
        if (this._reflectionTexture === texture) {
          return true;
        }
        if (this._emissiveTexture === texture) {
          return true;
        }
        if (this._reflectivityTexture === texture) {
          return true;
        }
        if (this._metallicTexture === texture) {
          return true;
        }
        if (this._metallicReflectanceTexture === texture) {
          return true;
        }
        if (this._reflectanceTexture === texture) {
          return true;
        }
        if (this._microSurfaceTexture === texture) {
          return true;
        }
        if (this._bumpTexture === texture) {
          return true;
        }
        if (this._lightmapTexture === texture) {
          return true;
        }
        return false;
      }
      /**
       * Sets the required values to the prepass renderer.
       * It can't be sets when subsurface scattering of this material is disabled.
       * When scene have ability to enable subsurface prepass effect, it will enable.
       * @returns - If prepass is enabled or not.
       */
      setPrePassRenderer() {
        if (!this.subSurface?.isScatteringEnabled) {
          return false;
        }
        const subSurfaceConfiguration = this.getScene().enableSubSurfaceForPrePass();
        if (subSurfaceConfiguration) {
          subSurfaceConfiguration.enabled = true;
        }
        return true;
      }
      /**
       * Disposes the resources of the material.
       * @param forceDisposeEffect - Forces the disposal of effects.
       * @param forceDisposeTextures - Forces the disposal of all textures.
       */
      dispose(forceDisposeEffect, forceDisposeTextures) {
        this._breakShaderLoadedCheck = true;
        if (forceDisposeTextures) {
          if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {
            this._environmentBRDFTexture.dispose();
          }
          this._albedoTexture?.dispose();
          this._baseWeightTexture?.dispose();
          this._baseDiffuseRoughnessTexture?.dispose();
          this._ambientTexture?.dispose();
          this._opacityTexture?.dispose();
          this._reflectionTexture?.dispose();
          this._emissiveTexture?.dispose();
          this._metallicTexture?.dispose();
          this._reflectivityTexture?.dispose();
          this._bumpTexture?.dispose();
          this._lightmapTexture?.dispose();
          this._metallicReflectanceTexture?.dispose();
          this._reflectanceTexture?.dispose();
          this._microSurfaceTexture?.dispose();
        }
        this._renderTargets.dispose();
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        super.dispose(forceDisposeEffect, forceDisposeTextures);
      }
    };
    PBRBaseMaterial.PBRMATERIAL_OPAQUE = Material.MATERIAL_OPAQUE;
    PBRBaseMaterial.PBRMATERIAL_ALPHATEST = Material.MATERIAL_ALPHATEST;
    PBRBaseMaterial.PBRMATERIAL_ALPHABLEND = Material.MATERIAL_ALPHABLEND;
    PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND = Material.MATERIAL_ALPHATESTANDBLEND;
    PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 0;
    PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL = 0;
    PBRBaseMaterial.LIGHTFALLOFF_GLTF = 1;
    PBRBaseMaterial.LIGHTFALLOFF_STANDARD = 2;
    PBRBaseMaterial.ForceGLSL = false;
    __decorate([
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBaseMaterial.prototype, "debugMode", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTextureSceneComponent.js
var ProceduralTextureSceneComponent;
var init_proceduralTextureSceneComponent = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTextureSceneComponent.js"() {
    init_tools();
    init_sceneComponent();
    ProceduralTextureSceneComponent = class {
      /**
       * Creates a new instance of the component for the given scene
       * @param scene Defines the scene to register the component in
       */
      constructor(scene) {
        this.name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;
        this.scene = scene;
      }
      /**
       * Registers the component in a given scene
       */
      register() {
        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);
      }
      /**
       * Rebuilds the elements related to this component in case of
       * context lost for instance.
       */
      rebuild() {
      }
      /**
       * Disposes the component and the associated resources.
       */
      dispose() {
      }
      _beforeClear() {
        if (this.scene.proceduralTexturesEnabled) {
          Tools.StartPerformanceCounter("Procedural textures", this.scene.proceduralTextures.length > 0);
          for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {
            const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];
            if (proceduralTexture._shouldRender()) {
              proceduralTexture.render();
            }
          }
          Tools.EndPerformanceCounter("Procedural textures", this.scene.proceduralTextures.length > 0);
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTexture.js
var ProceduralTexture;
var init_proceduralTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTexture.js"() {
    init_tslib_es6();
    init_decorators();
    init_observable();
    init_buffer();
    init_sceneComponent();
    init_material();
    init_texture();
    init_renderTargetTexture();
    init_proceduralTextureSceneComponent();
    init_typeStore();
    init_engineStore();
    init_drawWrapper();
    ProceduralTexture = class _ProceduralTexture extends Texture {
      /**
       * Gets the shader language type used to generate vertex and fragment source code.
       */
      get shaderLanguage() {
        return this._shaderLanguage;
      }
      /**
       * Instantiates a new procedural texture.
       * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
       * This is the base class of any Procedural texture and contains most of the shareable code.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures
       * @param name  Define the name of the texture
       * @param size Define the size of the texture to create
       * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later:
       *  * object: \{ fragmentElement: "fragmentShaderCode" \}, used with shader code in script tags
       *  * object: \{ fragmentSource: "fragment shader code string" \}, the string contains the shader code
       *  * string: the string contains a name "XXX" to lookup in Effect.ShadersStore["XXXFragmentShader"]
       * @param scene Define the scene the texture belongs to
       * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture
       * @param generateMipMaps Define if the texture should creates mip maps or not
       * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)
       * @param textureType The FBO internal texture type
       */
      constructor(name, size, fragment, scene, fallbackTexture = null, generateMipMaps = true, isCube = false, textureType = 0) {
        super(null, scene, !generateMipMaps);
        this.isEnabled = true;
        this.autoClear = true;
        this.onGeneratedObservable = new Observable();
        this.onBeforeGenerationObservable = new Observable();
        this.nodeMaterialSource = null;
        this.defines = "";
        this._textures = {};
        this._currentRefreshId = -1;
        this._frameId = -1;
        this._refreshRate = 1;
        this._vertexBuffers = {};
        this._uniforms = new Array();
        this._samplers = new Array();
        this._floats = {};
        this._ints = {};
        this._floatsArrays = {};
        this._colors3 = {};
        this._colors4 = {};
        this._vectors2 = {};
        this._vectors3 = {};
        this._vectors4 = {};
        this._matrices = {};
        this._fallbackTextureUsed = false;
        this._cachedDefines = null;
        this._contentUpdateId = -1;
        this._rtWrapper = null;
        if (fallbackTexture !== null && !(fallbackTexture instanceof Texture)) {
          this._options = fallbackTexture;
          this._fallbackTexture = fallbackTexture.fallbackTexture ?? null;
        } else {
          this._options = {};
          this._fallbackTexture = fallbackTexture;
        }
        this._shaderLanguage = this._options.shaderLanguage ?? 0;
        scene = this.getScene() || EngineStore.LastCreatedScene;
        let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);
        if (!component) {
          component = new ProceduralTextureSceneComponent(scene);
          scene._addComponent(component);
        }
        scene.proceduralTextures.push(this);
        this._fullEngine = scene.getEngine();
        this.name = name;
        this.isRenderTarget = true;
        this._size = size;
        this._textureType = textureType;
        this._generateMipMaps = generateMipMaps;
        this._drawWrapper = new DrawWrapper(this._fullEngine);
        this.setFragment(fragment);
        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);
        this._texture = rtWrapper.texture;
        const vertices = [];
        vertices.push(1, 1);
        vertices.push(-1, 1);
        vertices.push(-1, -1);
        vertices.push(1, -1);
        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);
        this._createIndexBuffer();
      }
      _createRtWrapper(isCube, size, generateMipMaps, textureType) {
        if (isCube) {
          this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size, {
            generateMipMaps,
            generateDepthBuffer: false,
            generateStencilBuffer: false,
            type: textureType,
            ...this._options
          });
          this.setFloat("face", 0);
        } else {
          this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {
            generateMipMaps,
            generateDepthBuffer: false,
            generateStencilBuffer: false,
            type: textureType,
            ...this._options
          });
          if (this._rtWrapper.is3D) {
            this.setFloat("layer", 0);
            this.setInt("layerNum", 0);
          }
        }
        return this._rtWrapper;
      }
      /**
       * The effect that is created when initializing the post process.
       * @returns The created effect corresponding the postprocess.
       */
      getEffect() {
        return this._drawWrapper.effect;
      }
      /**
       * @internal
       */
      _setEffect(effect) {
        this._drawWrapper.effect = effect;
      }
      /**
       * Gets texture content (Use this function wisely as reading from a texture can be slow)
       * @returns an ArrayBufferView promise (Uint8Array or Float32Array)
       */
      getContent() {
        if (this._contentData && this._frameId === this._contentUpdateId) {
          return this._contentData;
        }
        if (this._contentData) {
          this._contentData.then((buffer) => {
            this._contentData = this.readPixels(0, 0, buffer);
            this._contentUpdateId = this._frameId;
          });
        } else {
          this._contentData = this.readPixels(0, 0);
          this._contentUpdateId = this._frameId;
        }
        return this._contentData;
      }
      _createIndexBuffer() {
        const engine = this._fullEngine;
        const indices = [];
        indices.push(0);
        indices.push(1);
        indices.push(2);
        indices.push(0);
        indices.push(2);
        indices.push(3);
        this._indexBuffer = engine.createIndexBuffer(indices);
      }
      /** @internal */
      _rebuild() {
        const vb = this._vertexBuffers[VertexBuffer.PositionKind];
        if (vb) {
          vb._rebuild();
        }
        this._createIndexBuffer();
        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {
          this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
        }
      }
      /**
       * Resets the texture in order to recreate its associated resources.
       * This can be called in case of context loss or if you change the shader code and need to regenerate the texture with the new code
       */
      reset() {
        this._drawWrapper.effect?.dispose();
        this._drawWrapper.effect = null;
        this._cachedDefines = null;
      }
      _getDefines() {
        return this.defines;
      }
      /**
       * Executes a function when the texture will be ready to be drawn.
       * @param func The callback to be used.
       */
      executeWhenReady(func) {
        if (this.isReady()) {
          func(this);
          return;
        }
        const effect = this.getEffect();
        if (effect) {
          effect.executeWhenCompiled(() => {
            func(this);
          });
        }
      }
      /**
       * Is the texture ready to be used ? (rendered at least once)
       * @returns true if ready, otherwise, false.
       */
      isReady() {
        const engine = this._fullEngine;
        if (this.nodeMaterialSource) {
          return this._drawWrapper.effect.isReady();
        }
        if (!this._fragment) {
          return false;
        }
        if (this._fallbackTextureUsed) {
          return true;
        }
        if (!this._texture) {
          return false;
        }
        const defines = this._getDefines();
        if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {
          return true;
        }
        const shaders = {
          vertex: "procedural",
          fragmentElement: this._fragment.fragmentElement,
          fragmentSource: this._fragment.fragmentSource,
          fragment: typeof this._fragment === "string" ? this._fragment : void 0
        };
        if (this._cachedDefines !== defines) {
          this._cachedDefines = defines;
          this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, void 0, void 0, () => {
            this._rtWrapper?.dispose();
            this._rtWrapper = this._texture = null;
            if (this._fallbackTexture) {
              this._texture = this._fallbackTexture._texture;
              if (this._texture) {
                this._texture.incrementReferences();
              }
            }
            this._fallbackTextureUsed = true;
          }, void 0, this._shaderLanguage, async () => {
            if (this._options.extraInitializationsAsync) {
              if (this.shaderLanguage === 1) {
                await Promise.all([import("./procedural.vertex-RX7NKDUK.js"), this._options.extraInitializationsAsync()]);
              } else {
                await Promise.all([import("./procedural.vertex-2TOFGFJE.js"), this._options.extraInitializationsAsync()]);
              }
            } else {
              if (this.shaderLanguage === 1) {
                await import("./procedural.vertex-RX7NKDUK.js");
              } else {
                await import("./procedural.vertex-2TOFGFJE.js");
              }
            }
          });
        }
        return this._drawWrapper.effect.isReady();
      }
      /**
       * Resets the refresh counter of the texture and start bak from scratch.
       * Could be useful to regenerate the texture if it is setup to render only once.
       */
      resetRefreshCounter() {
        this._currentRefreshId = -1;
      }
      /**
       * Set the fragment shader to use in order to render the texture.
       * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.
       */
      setFragment(fragment) {
        this._fragment = fragment;
      }
      /**
       * Define the refresh rate of the texture or the rendering frequency.
       * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...
       */
      get refreshRate() {
        return this._refreshRate;
      }
      set refreshRate(value) {
        this._refreshRate = value;
        this.resetRefreshCounter();
      }
      /** @internal */
      _shouldRender() {
        if (!this.isEnabled || !this.isReady() || !this._texture) {
          if (this._texture) {
            this._texture.isReady = false;
          }
          return false;
        }
        if (this._fallbackTextureUsed) {
          return false;
        }
        if (this._currentRefreshId === -1) {
          this._currentRefreshId = 1;
          this._frameId++;
          return true;
        }
        if (this.refreshRate === this._currentRefreshId) {
          this._currentRefreshId = 1;
          this._frameId++;
          return true;
        }
        this._currentRefreshId++;
        return false;
      }
      /**
       * Get the size the texture is rendering at.
       * @returns the size (on cube texture it is always squared)
       */
      getRenderSize() {
        return this._size;
      }
      /**
       * Resize the texture to new value.
       * @param size Define the new size the texture should have
       * @param generateMipMaps Define whether the new texture should create mip maps
       */
      resize(size, generateMipMaps) {
        if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {
          return;
        }
        const isCube = this._texture.isCube;
        this._rtWrapper.dispose();
        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);
        this._texture = rtWrapper.texture;
        this._size = size;
        this._generateMipMaps = generateMipMaps;
      }
      _checkUniform(uniformName) {
        if (this._uniforms.indexOf(uniformName) === -1) {
          this._uniforms.push(uniformName);
        }
      }
      /**
       * Set a texture in the shader program used to render.
       * @param name Define the name of the uniform samplers as defined in the shader
       * @param texture Define the texture to bind to this sampler
       * @returns the texture itself allowing "fluent" like uniform updates
       */
      setTexture(name, texture) {
        if (this._samplers.indexOf(name) === -1) {
          this._samplers.push(name);
        }
        this._textures[name] = texture;
        return this;
      }
      /**
       * Set a float in the shader.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the texture itself allowing "fluent" like uniform updates
       */
      setFloat(name, value) {
        this._checkUniform(name);
        this._floats[name] = value;
        return this;
      }
      /**
       * Set a int in the shader.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the texture itself allowing "fluent" like uniform updates
       */
      setInt(name, value) {
        this._checkUniform(name);
        this._ints[name] = value;
        return this;
      }
      /**
       * Set an array of floats in the shader.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the texture itself allowing "fluent" like uniform updates
       */
      setFloats(name, value) {
        this._checkUniform(name);
        this._floatsArrays[name] = value;
        return this;
      }
      /**
       * Set a vec3 in the shader from a Color3.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the texture itself allowing "fluent" like uniform updates
       */
      setColor3(name, value) {
        this._checkUniform(name);
        this._colors3[name] = value;
        return this;
      }
      /**
       * Set a vec4 in the shader from a Color4.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the texture itself allowing "fluent" like uniform updates
       */
      setColor4(name, value) {
        this._checkUniform(name);
        this._colors4[name] = value;
        return this;
      }
      /**
       * Set a vec2 in the shader from a Vector2.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the texture itself allowing "fluent" like uniform updates
       */
      setVector2(name, value) {
        this._checkUniform(name);
        this._vectors2[name] = value;
        return this;
      }
      /**
       * Set a vec3 in the shader from a Vector3.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the texture itself allowing "fluent" like uniform updates
       */
      setVector3(name, value) {
        this._checkUniform(name);
        this._vectors3[name] = value;
        return this;
      }
      /**
       * Set a vec4 in the shader from a Vector4.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the texture itself allowing "fluent" like uniform updates
       */
      setVector4(name, value) {
        this._checkUniform(name);
        this._vectors4[name] = value;
        return this;
      }
      /**
       * Set a mat4 in the shader from a MAtrix.
       * @param name Define the name of the uniform as defined in the shader
       * @param value Define the value to give to the uniform
       * @returns the texture itself allowing "fluent" like uniform updates
       */
      setMatrix(name, value) {
        this._checkUniform(name);
        this._matrices[name] = value;
        return this;
      }
      /**
       * Render the texture to its associated render target.
       * @param useCameraPostProcess Define if camera post process should be applied to the texture
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      render(useCameraPostProcess) {
        const scene = this.getScene();
        if (!scene) {
          return;
        }
        const engine = this._fullEngine;
        engine.enableEffect(this._drawWrapper);
        this.onBeforeGenerationObservable.notifyObservers(this);
        engine.setState(false);
        if (!this.nodeMaterialSource) {
          for (const name in this._textures) {
            this._drawWrapper.effect.setTexture(name, this._textures[name]);
          }
          for (const name in this._ints) {
            this._drawWrapper.effect.setInt(name, this._ints[name]);
          }
          for (const name in this._floats) {
            this._drawWrapper.effect.setFloat(name, this._floats[name]);
          }
          for (const name in this._floatsArrays) {
            this._drawWrapper.effect.setArray(name, this._floatsArrays[name]);
          }
          for (const name in this._colors3) {
            this._drawWrapper.effect.setColor3(name, this._colors3[name]);
          }
          for (const name in this._colors4) {
            const color = this._colors4[name];
            this._drawWrapper.effect.setFloat4(name, color.r, color.g, color.b, color.a);
          }
          for (const name in this._vectors2) {
            this._drawWrapper.effect.setVector2(name, this._vectors2[name]);
          }
          for (const name in this._vectors3) {
            this._drawWrapper.effect.setVector3(name, this._vectors3[name]);
          }
          for (const name in this._vectors4) {
            this._drawWrapper.effect.setVector4(name, this._vectors4[name]);
          }
          for (const name in this._matrices) {
            this._drawWrapper.effect.setMatrix(name, this._matrices[name]);
          }
        }
        if (!this._texture || !this._rtWrapper) {
          return;
        }
        if (engine._enableGPUDebugMarkers) {
          engine.restoreDefaultFramebuffer();
          engine._debugPushGroup?.(`procedural texture generation for ${this.name}`);
        }
        const viewPort = engine.currentViewport;
        if (this.isCube) {
          for (let face = 0; face < 6; face++) {
            engine.bindFramebuffer(this._rtWrapper, face, void 0, void 0, true);
            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);
            this._drawWrapper.effect.setFloat("face", face);
            if (this.autoClear) {
              engine.clear(scene.clearColor, true, false, false);
            }
            engine.drawElementsType(Material.TriangleFillMode, 0, 6);
            engine.unBindFramebuffer(this._rtWrapper, true);
          }
        } else {
          let numLayers = 1;
          if (this._rtWrapper.is3D) {
            numLayers = this._rtWrapper.depth;
          } else if (this._rtWrapper.is2DArray) {
            numLayers = this._rtWrapper.layers;
          }
          for (let layer = 0; layer < numLayers; layer++) {
            engine.bindFramebuffer(this._rtWrapper, 0, void 0, void 0, true, 0, layer);
            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);
            if (this._rtWrapper.is3D || this._rtWrapper.is2DArray) {
              this._drawWrapper.effect?.setFloat("layer", numLayers !== 1 ? layer / (numLayers - 1) : 0);
              this._drawWrapper.effect?.setInt("layerNum", layer);
              for (const name in this._textures) {
                this._drawWrapper.effect.setTexture(name, this._textures[name]);
              }
            }
            if (this.autoClear) {
              engine.clear(scene.clearColor, true, false, false);
            }
            engine.drawElementsType(Material.TriangleFillMode, 0, 6);
            engine.unBindFramebuffer(this._rtWrapper, !this._generateMipMaps);
          }
        }
        if (viewPort) {
          engine.setViewport(viewPort);
        }
        if (this.isCube) {
          engine.generateMipMapsForCubemap(this._texture, true);
        }
        if (engine._enableGPUDebugMarkers) {
          engine._debugPopGroup?.();
        }
        if (this.onGenerated) {
          this.onGenerated();
        }
        this.onGeneratedObservable.notifyObservers(this);
      }
      /**
       * Clone the texture.
       * @returns the cloned texture
       */
      clone() {
        const textureSize = this.getSize();
        const newTexture = new _ProceduralTexture(this.name, textureSize.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps);
        newTexture.hasAlpha = this.hasAlpha;
        newTexture.level = this.level;
        newTexture.coordinatesMode = this.coordinatesMode;
        return newTexture;
      }
      /**
       * Dispose the texture and release its associated resources.
       */
      dispose() {
        const scene = this.getScene();
        if (!scene) {
          return;
        }
        const index = scene.proceduralTextures.indexOf(this);
        if (index >= 0) {
          scene.proceduralTextures.splice(index, 1);
        }
        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
        if (vertexBuffer) {
          vertexBuffer.dispose();
          this._vertexBuffers[VertexBuffer.PositionKind] = null;
        }
        if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {
          this._indexBuffer = null;
        }
        this.onGeneratedObservable.clear();
        this.onBeforeGenerationObservable.clear();
        super.dispose();
      }
    };
    __decorate([
      serialize()
    ], ProceduralTexture.prototype, "isEnabled", void 0);
    __decorate([
      serialize()
    ], ProceduralTexture.prototype, "autoClear", void 0);
    __decorate([
      serialize()
    ], ProceduralTexture.prototype, "_generateMipMaps", void 0);
    __decorate([
      serialize()
    ], ProceduralTexture.prototype, "_size", void 0);
    __decorate([
      serialize()
    ], ProceduralTexture.prototype, "refreshRate", null);
    RegisterClass("BABYLON.ProceduralTexture", ProceduralTexture);
  }
});

// node_modules/@babylonjs/core/Morph/morphTarget.js
var MorphTarget;
var init_morphTarget = __esm({
  "node_modules/@babylonjs/core/Morph/morphTarget.js"() {
    init_tslib_es6();
    init_observable();
    init_engineStore();
    init_buffer();
    init_decorators();
    init_decorators_serialization();
    init_typeStore();
    MorphTarget = class _MorphTarget {
      /**
       * Gets or sets the influence of this target (ie. its weight in the overall morphing)
       */
      get influence() {
        return this._influence;
      }
      set influence(influence) {
        if (this._influence === influence) {
          return;
        }
        const previous = this._influence;
        this._influence = influence;
        if (this.onInfluenceChanged.hasObservers()) {
          this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);
        }
      }
      /**
       * Gets or sets the animation properties override
       */
      get animationPropertiesOverride() {
        if (!this._animationPropertiesOverride && this._scene) {
          return this._scene.animationPropertiesOverride;
        }
        return this._animationPropertiesOverride;
      }
      set animationPropertiesOverride(value) {
        this._animationPropertiesOverride = value;
      }
      /**
       * Creates a new MorphTarget
       * @param name defines the name of the target
       * @param influence defines the influence to use
       * @param scene defines the scene the morphtarget belongs to
       */
      constructor(name, influence = 0, scene = null) {
        this.name = name;
        this.animations = [];
        this._positions = null;
        this._normals = null;
        this._tangents = null;
        this._uvs = null;
        this._uv2s = null;
        this._colors = null;
        this._uniqueId = 0;
        this.onInfluenceChanged = new Observable();
        this._onDataLayoutChanged = new Observable();
        this._animationPropertiesOverride = null;
        this.id = name;
        this._scene = scene || EngineStore.LastCreatedScene;
        this.influence = influence;
        if (this._scene) {
          this._uniqueId = this._scene.getUniqueId();
        }
      }
      /**
       * Gets the unique ID of this manager
       */
      get uniqueId() {
        return this._uniqueId;
      }
      /**
       * Gets a boolean defining if the target contains position data
       */
      get hasPositions() {
        return !!this._positions;
      }
      /**
       * Gets a boolean defining if the target contains normal data
       */
      get hasNormals() {
        return !!this._normals;
      }
      /**
       * Gets a boolean defining if the target contains tangent data
       */
      get hasTangents() {
        return !!this._tangents;
      }
      /**
       * Gets a boolean defining if the target contains texture coordinates data
       */
      get hasUVs() {
        return !!this._uvs;
      }
      /**
       * Gets a boolean defining if the target contains texture coordinates 2 data
       */
      get hasUV2s() {
        return !!this._uv2s;
      }
      get hasColors() {
        return !!this._colors;
      }
      /**
       * Gets the number of vertices stored in this target
       */
      get vertexCount() {
        return this._positions ? this._positions.length / 3 : this._normals ? this._normals.length / 3 : this._tangents ? this._tangents.length / 3 : this._uvs ? this._uvs.length / 2 : this._uv2s ? this._uv2s.length / 2 : this._colors ? this._colors.length / 4 : 0;
      }
      /**
       * Affects position data to this target
       * @param data defines the position data to use
       */
      setPositions(data) {
        const hadPositions = this.hasPositions;
        this._positions = data;
        if (hadPositions !== this.hasPositions) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      }
      /**
       * Gets the position data stored in this target
       * @returns a FloatArray containing the position data (or null if not present)
       */
      getPositions() {
        return this._positions;
      }
      /**
       * Affects normal data to this target
       * @param data defines the normal data to use
       */
      setNormals(data) {
        const hadNormals = this.hasNormals;
        this._normals = data;
        if (hadNormals !== this.hasNormals) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      }
      /**
       * Gets the normal data stored in this target
       * @returns a FloatArray containing the normal data (or null if not present)
       */
      getNormals() {
        return this._normals;
      }
      /**
       * Affects tangent data to this target
       * @param data defines the tangent data to use
       */
      setTangents(data) {
        const hadTangents = this.hasTangents;
        this._tangents = data;
        if (hadTangents !== this.hasTangents) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      }
      /**
       * Gets the tangent data stored in this target
       * @returns a FloatArray containing the tangent data (or null if not present)
       */
      getTangents() {
        return this._tangents;
      }
      /**
       * Affects texture coordinates data to this target
       * @param data defines the texture coordinates data to use
       */
      setUVs(data) {
        const hadUVs = this.hasUVs;
        this._uvs = data;
        if (hadUVs !== this.hasUVs) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      }
      /**
       * Gets the texture coordinates data stored in this target
       * @returns a FloatArray containing the texture coordinates data (or null if not present)
       */
      getUVs() {
        return this._uvs;
      }
      /**
       * Affects texture coordinates 2 data to this target
       * @param data defines the texture coordinates 2 data to use
       */
      setUV2s(data) {
        const hadUV2s = this.hasUV2s;
        this._uv2s = data;
        if (hadUV2s !== this.hasUV2s) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      }
      /**
       * Gets the texture coordinates 2 data stored in this target
       * @returns a FloatArray containing the texture coordinates 2 data (or null if not present)
       */
      getUV2s() {
        return this._uv2s;
      }
      /**
       * Affects color data to this target
       * @param data defines the color data to use
       */
      setColors(data) {
        const hadColors = this.hasColors;
        this._colors = data;
        if (hadColors !== this.hasColors) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      }
      /**
       * Gets the color data stored in this target
       * @returns a FloatArray containing the color data (or null if not present)
       */
      getColors() {
        return this._colors;
      }
      /**
       * Clone the current target
       * @returns a new MorphTarget
       */
      clone() {
        const newOne = SerializationHelper.Clone(() => new _MorphTarget(this.name, this.influence, this._scene), this);
        newOne._positions = this._positions;
        newOne._normals = this._normals;
        newOne._tangents = this._tangents;
        newOne._uvs = this._uvs;
        newOne._uv2s = this._uv2s;
        newOne._colors = this._colors;
        return newOne;
      }
      /**
       * Serializes the current target into a Serialization object
       * @returns the serialized object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.influence = this.influence;
        serializationObject.positions = Array.prototype.slice.call(this.getPositions());
        if (this.id != null) {
          serializationObject.id = this.id;
        }
        if (this.hasNormals) {
          serializationObject.normals = Array.prototype.slice.call(this.getNormals());
        }
        if (this.hasTangents) {
          serializationObject.tangents = Array.prototype.slice.call(this.getTangents());
        }
        if (this.hasUVs) {
          serializationObject.uvs = Array.prototype.slice.call(this.getUVs());
        }
        if (this.hasUV2s) {
          serializationObject.uv2s = Array.prototype.slice.call(this.getUV2s());
        }
        if (this.hasColors) {
          serializationObject.colors = Array.prototype.slice.call(this.getColors());
        }
        SerializationHelper.AppendSerializedAnimations(this, serializationObject);
        return serializationObject;
      }
      /**
       * Returns the string "MorphTarget"
       * @returns "MorphTarget"
       */
      getClassName() {
        return "MorphTarget";
      }
      // Statics
      /**
       * Creates a new target from serialized data
       * @param serializationObject defines the serialized data to use
       * @param scene defines the hosting scene
       * @returns a new MorphTarget
       */
      static Parse(serializationObject, scene) {
        const result = new _MorphTarget(serializationObject.name, serializationObject.influence);
        result.setPositions(serializationObject.positions);
        if (serializationObject.id != null) {
          result.id = serializationObject.id;
        }
        if (serializationObject.normals) {
          result.setNormals(serializationObject.normals);
        }
        if (serializationObject.tangents) {
          result.setTangents(serializationObject.tangents);
        }
        if (serializationObject.uvs) {
          result.setUVs(serializationObject.uvs);
        }
        if (serializationObject.uv2s) {
          result.setUV2s(serializationObject.uv2s);
        }
        if (serializationObject.colors) {
          result.setColors(serializationObject.colors);
        }
        if (serializationObject.animations) {
          for (let animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {
            const parsedAnimation = serializationObject.animations[animationIndex];
            const internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              result.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          if (serializationObject.autoAnimate && scene) {
            scene.beginAnimation(result, serializationObject.autoAnimateFrom, serializationObject.autoAnimateTo, serializationObject.autoAnimateLoop, serializationObject.autoAnimateSpeed || 1);
          }
        }
        return result;
      }
      /**
       * Creates a MorphTarget from mesh data
       * @param mesh defines the source mesh
       * @param name defines the name to use for the new target
       * @param influence defines the influence to attach to the target
       * @returns a new MorphTarget
       */
      static FromMesh(mesh, name, influence) {
        if (!name) {
          name = mesh.name;
        }
        const result = new _MorphTarget(name, influence, mesh.getScene());
        result.setPositions(mesh.getVerticesData(VertexBuffer.PositionKind));
        if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          result.setNormals(mesh.getVerticesData(VertexBuffer.NormalKind));
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
          result.setTangents(mesh.getVerticesData(VertexBuffer.TangentKind));
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
          result.setUVs(mesh.getVerticesData(VertexBuffer.UVKind));
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
          result.setUV2s(mesh.getVerticesData(VertexBuffer.UV2Kind));
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {
          result.setColors(mesh.getVerticesData(VertexBuffer.ColorKind));
        }
        return result;
      }
    };
    __decorate([
      serialize()
    ], MorphTarget.prototype, "id", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/openpbrMaterial.js
var onCreatedEffectParameters3, Uniform, Property, Sampler, OpenPBRMaterialDefinesBase, OpenPBRMaterialDefines, OpenPBRMaterialBase, OpenPBRMaterial;
var init_openpbrMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/openpbrMaterial.js"() {
    init_tslib_es6();
    init_decorators();
    init_brdfTextureTools();
    init_math_color();
    init_imageProcessingConfiguration();
    init_texture();
    init_typeStore();
    init_material();
    init_decorators_serialization();
    init_materialDefines();
    init_imageProcessingConfiguration_defines();
    init_effectFallbacks();
    init_clipPlaneMaterialHelper();
    init_materialHelper_functions();
    init_buffer();
    init_materialHelper_geometryrendering();
    init_prePassConfiguration();
    init_materialFlags();
    init_logger();
    init_uv_defines();
    init_math_vector();
    init_imageProcessing();
    init_pushMaterial();
    init_smartArray();
    init_tools();
    onCreatedEffectParameters3 = { effect: null, subMesh: null };
    Uniform = class _Uniform {
      populateVectorFromLinkedProperties(vector) {
        const destinationSize = vector.dimension[0];
        for (const propKey in this.linkedProperties) {
          const prop = this.linkedProperties[propKey];
          const sourceSize = prop.numComponents;
          if (destinationSize < sourceSize || prop.targetUniformComponentOffset > destinationSize - sourceSize) {
            if (sourceSize == 1) {
              Logger.Error(`Float property ${prop.name} has an offset that is too large.`);
            } else {
              Logger.Error(`Vector${sourceSize} property ${prop.name} won't fit in Vector${destinationSize} or has an offset that is too large.`);
            }
            return;
          }
          if (typeof prop.value === "number") {
            _Uniform._tmpArray[prop.targetUniformComponentOffset] = prop.value;
          } else {
            prop.value.toArray(_Uniform._tmpArray, prop.targetUniformComponentOffset);
          }
        }
        vector.fromArray(_Uniform._tmpArray);
      }
      constructor(name, componentNum) {
        this.linkedProperties = {};
        this.name = name;
        this.numComponents = componentNum;
      }
    };
    Uniform._tmpArray = [0, 0, 0, 0];
    Property = class {
      /**
       * Creates a new Property instance.
       * @param name The name of the property in the shader
       * @param defaultValue The default value of the property
       * @param targetUniformName The name of the property in the shader uniform block
       * @param targetUniformComponentNum The number of components in the target uniform. All properties that are
       * packed into the same uniform must agree on the size of the target uniform.
       * @param targetUniformComponentOffset The offset in the uniform where this property will be packed.
       */
      constructor(name, defaultValue, targetUniformName, targetUniformComponentNum, targetUniformComponentOffset = 0) {
        this.targetUniformComponentNum = 4;
        this.targetUniformComponentOffset = 0;
        this.name = name;
        this.targetUniformName = targetUniformName;
        this.defaultValue = defaultValue;
        this.value = defaultValue;
        this.targetUniformComponentNum = targetUniformComponentNum;
        this.targetUniformComponentOffset = targetUniformComponentOffset;
      }
      /**
       * Returns the number of components of the property based on its default value type.
       */
      get numComponents() {
        if (typeof this.defaultValue === "number") {
          return 1;
        }
        return this.defaultValue.dimension[0];
      }
    };
    Sampler = class {
      /**
       * The name of the sampler used in the shader.
       * If this naming changes, we'll also need to change:
       * - samplerFragmentDeclaration.fx
       * - openpbr.fragment.fx
       */
      get samplerName() {
        return this.samplerPrefix + "Sampler";
      }
      /**
       * The name of the sampler info used in the shader.
       * If this naming changes, we'll also need to change:
       * - openpbr.vertex.fx
       * - openpbr.fragment.fx
       */
      get samplerInfoName() {
        return "v" + this.samplerPrefix.charAt(0).toUpperCase() + this.samplerPrefix.slice(1) + "Infos";
      }
      /**
       * The name of the matrix used for this sampler in the shader.
       * If this naming changes, we'll also need to change:
       * - materialHelper.functions.BindTextureMatrix
       * - samplerVertexImplementation.fx
       * - openpbr.fragment.fx
       */
      get samplerMatrixName() {
        return this.samplerPrefix + "Matrix";
      }
      /**
       * Creates a new Sampler instance.
       * @param name The name of the texture property
       * @param samplerPrefix The prefix used for the name of the sampler in the shader
       * @param textureDefine The define used in the shader for this sampler
       */
      constructor(name, samplerPrefix, textureDefine) {
        this.value = null;
        this.samplerPrefix = "";
        this.textureDefine = "";
        this.name = name;
        this.samplerPrefix = samplerPrefix;
        this.textureDefine = textureDefine;
      }
    };
    OpenPBRMaterialDefinesBase = class extends UVDefinesMixin(MaterialDefines) {
    };
    OpenPBRMaterialDefines = class extends ImageProcessingDefinesMixin(OpenPBRMaterialDefinesBase) {
      /**
       * Initializes the PBR Material defines.
       * @param externalProperties The external properties
       */
      constructor(externalProperties) {
        super(externalProperties);
        this.NUM_SAMPLES = "0";
        this.REALTIME_FILTERING = false;
        this.IBL_CDF_FILTERING = false;
        this.VERTEXCOLOR = false;
        this.BAKED_VERTEX_ANIMATION_TEXTURE = false;
        this.VERTEXALPHA = false;
        this.ALPHATEST = false;
        this.DEPTHPREPASS = false;
        this.ALPHABLEND = false;
        this.ALPHA_FROM_BASE_COLOR_TEXTURE = false;
        this.ALPHATESTVALUE = "0.5";
        this.PREMULTIPLYALPHA = false;
        this.REFLECTIVITY_GAMMA = false;
        this.REFLECTIVITYDIRECTUV = 0;
        this.SPECULARTERM = false;
        this.LODBASEDMICROSFURACE = true;
        this.SPECULAR_ROUGHNESS_FROM_METALNESS_TEXTURE_GREEN = false;
        this.BASE_METALNESS_FROM_METALNESS_TEXTURE_BLUE = false;
        this.AOSTOREINMETALMAPRED = false;
        this.SPECULAR_WEIGHT_IN_ALPHA = false;
        this.SPECULAR_WEIGHT_FROM_SPECULAR_COLOR_TEXTURE = false;
        this.SPECULAR_ROUGHNESS_ANISOTROPY_FROM_TANGENT_TEXTURE = false;
        this.COAT_ROUGHNESS_FROM_GREEN_CHANNEL = false;
        this.COAT_ROUGHNESS_ANISOTROPY_FROM_TANGENT_TEXTURE = false;
        this.USE_GLTF_STYLE_ANISOTROPY = false;
        this.THIN_FILM_THICKNESS_FROM_THIN_FILM_TEXTURE = false;
        this.FUZZ_ROUGHNESS_FROM_TEXTURE_ALPHA = false;
        this.GEOMETRY_THICKNESS_FROM_GREEN_CHANNEL = false;
        this.ENVIRONMENTBRDF = false;
        this.ENVIRONMENTBRDF_RGBD = false;
        this.FUZZENVIRONMENTBRDF = false;
        this.NORMAL = false;
        this.TANGENT = false;
        this.OBJECTSPACE_NORMALMAP = false;
        this.PARALLAX = false;
        this.PARALLAX_RHS = false;
        this.PARALLAXOCCLUSION = false;
        this.NORMALXYSCALE = true;
        this.ANISOTROPIC = false;
        this.ANISOTROPIC_OPENPBR = true;
        this.ANISOTROPIC_BASE = false;
        this.ANISOTROPIC_COAT = false;
        this.FUZZ_IBL_SAMPLES = 6;
        this.FUZZ = false;
        this.THIN_FILM = false;
        this.IRIDESCENCE = false;
        this.DISPERSION = false;
        this.SCATTERING = false;
        this.REFRACTED_BACKGROUND = false;
        this.REFRACTED_LIGHTS = false;
        this.REFRACTED_ENVIRONMENT = false;
        this.REFRACTED_ENVIRONMENT_OPPOSITEZ = false;
        this.REFRACTED_ENVIRONMENT_LOCAL_CUBE = false;
        this.REFLECTION = false;
        this.REFLECTIONMAP_3D = false;
        this.REFLECTIONMAP_SPHERICAL = false;
        this.REFLECTIONMAP_PLANAR = false;
        this.REFLECTIONMAP_CUBIC = false;
        this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
        this.REFLECTIONMAP_PROJECTION = false;
        this.REFLECTIONMAP_SKYBOX = false;
        this.REFLECTIONMAP_EXPLICIT = false;
        this.REFLECTIONMAP_EQUIRECTANGULAR = false;
        this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
        this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
        this.INVERTCUBICMAP = false;
        this.USESPHERICALFROMREFLECTIONMAP = false;
        this.USEIRRADIANCEMAP = false;
        this.USE_IRRADIANCE_DOMINANT_DIRECTION = false;
        this.USESPHERICALINVERTEX = false;
        this.REFLECTIONMAP_OPPOSITEZ = false;
        this.LODINREFLECTIONALPHA = false;
        this.GAMMAREFLECTION = false;
        this.RGBDREFLECTION = false;
        this.RADIANCEOCCLUSION = false;
        this.HORIZONOCCLUSION = false;
        this.INSTANCES = false;
        this.THIN_INSTANCES = false;
        this.INSTANCESCOLOR = false;
        this.PREPASS = false;
        this.PREPASS_COLOR = false;
        this.PREPASS_COLOR_INDEX = -1;
        this.PREPASS_IRRADIANCE = false;
        this.PREPASS_IRRADIANCE_INDEX = -1;
        this.PREPASS_ALBEDO = false;
        this.PREPASS_ALBEDO_INDEX = -1;
        this.PREPASS_ALBEDO_SQRT = false;
        this.PREPASS_ALBEDO_SQRT_INDEX = -1;
        this.PREPASS_DEPTH = false;
        this.PREPASS_DEPTH_INDEX = -1;
        this.PREPASS_SCREENSPACE_DEPTH = false;
        this.PREPASS_SCREENSPACE_DEPTH_INDEX = -1;
        this.PREPASS_NORMALIZED_VIEW_DEPTH = false;
        this.PREPASS_NORMALIZED_VIEW_DEPTH_INDEX = -1;
        this.PREPASS_NORMAL = false;
        this.PREPASS_NORMAL_INDEX = -1;
        this.PREPASS_NORMAL_WORLDSPACE = false;
        this.PREPASS_WORLD_NORMAL = false;
        this.PREPASS_WORLD_NORMAL_INDEX = -1;
        this.PREPASS_POSITION = false;
        this.PREPASS_POSITION_INDEX = -1;
        this.PREPASS_LOCAL_POSITION = false;
        this.PREPASS_LOCAL_POSITION_INDEX = -1;
        this.PREPASS_VELOCITY = false;
        this.PREPASS_VELOCITY_INDEX = -1;
        this.PREPASS_VELOCITY_LINEAR = false;
        this.PREPASS_VELOCITY_LINEAR_INDEX = -1;
        this.PREPASS_REFLECTIVITY = false;
        this.PREPASS_REFLECTIVITY_INDEX = -1;
        this.SCENE_MRT_COUNT = 0;
        this.NUM_BONE_INFLUENCERS = 0;
        this.BonesPerMesh = 0;
        this.BONETEXTURE = false;
        this.BONES_VELOCITY_ENABLED = false;
        this.NONUNIFORMSCALING = false;
        this.MORPHTARGETS = false;
        this.MORPHTARGETS_POSITION = false;
        this.MORPHTARGETS_NORMAL = false;
        this.MORPHTARGETS_TANGENT = false;
        this.MORPHTARGETS_UV = false;
        this.MORPHTARGETS_UV2 = false;
        this.MORPHTARGETS_COLOR = false;
        this.MORPHTARGETTEXTURE_HASPOSITIONS = false;
        this.MORPHTARGETTEXTURE_HASNORMALS = false;
        this.MORPHTARGETTEXTURE_HASTANGENTS = false;
        this.MORPHTARGETTEXTURE_HASUVS = false;
        this.MORPHTARGETTEXTURE_HASUV2S = false;
        this.MORPHTARGETTEXTURE_HASCOLORS = false;
        this.NUM_MORPH_INFLUENCERS = 0;
        this.MORPHTARGETS_TEXTURE = false;
        this.USEPHYSICALLIGHTFALLOFF = false;
        this.USEGLTFLIGHTFALLOFF = false;
        this.TWOSIDEDLIGHTING = false;
        this.MIRRORED = false;
        this.SHADOWFLOAT = false;
        this.CLIPPLANE = false;
        this.CLIPPLANE2 = false;
        this.CLIPPLANE3 = false;
        this.CLIPPLANE4 = false;
        this.CLIPPLANE5 = false;
        this.CLIPPLANE6 = false;
        this.POINTSIZE = false;
        this.FOG = false;
        this.LOGARITHMICDEPTH = false;
        this.CAMERA_ORTHOGRAPHIC = false;
        this.CAMERA_PERSPECTIVE = false;
        this.AREALIGHTSUPPORTED = true;
        this.FORCENORMALFORWARD = false;
        this.SPECULARAA = false;
        this.UNLIT = false;
        this.DECAL_AFTER_DETAIL = false;
        this.DEBUGMODE = 0;
        this.CLUSTLIGHT_SLICES = 0;
        this.CLUSTLIGHT_BATCH = 0;
        this.BRDF_V_HEIGHT_CORRELATED = true;
        this.MS_BRDF_ENERGY_CONSERVATION = true;
        this.SPHERICAL_HARMONICS = true;
        this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = true;
        this.MIX_IBL_RADIANCE_WITH_IRRADIANCE = true;
        this.LEGACY_SPECULAR_ENERGY_CONSERVATION = false;
        this.BASE_DIFFUSE_MODEL = 0;
        this.DIELECTRIC_SPECULAR_MODEL = 1;
        this.CONDUCTOR_SPECULAR_MODEL = 1;
        this.rebuild();
      }
      /**
       * Resets the PBR Material defines.
       */
      reset() {
        super.reset();
        this.ALPHATESTVALUE = "0.5";
        this.NORMALXYSCALE = true;
      }
    };
    OpenPBRMaterialBase = class extends ImageProcessingMixin(PushMaterial) {
    };
    OpenPBRMaterial = class _OpenPBRMaterial extends OpenPBRMaterialBase {
      /**
       * Defines the angle of the tangent of the material's geometry. Used only for anisotropic reflections.
       * See OpenPBR's specs for geometry_tangent
       */
      get geometryTangentAngle() {
        return Math.atan2(this.geometryTangent.y, this.geometryTangent.x);
      }
      set geometryTangentAngle(value) {
        this.geometryTangent = new Vector2(Math.cos(value), Math.sin(value));
      }
      /**
       * Defines the angle of the tangent of the material's coat layer.
       */
      get geometryCoatTangentAngle() {
        return Math.atan2(this.geometryCoatTangent.y, this.geometryCoatTangent.x);
      }
      /**
       * Defines the angle of the tangent of the material's coat layer.
       */
      set geometryCoatTangentAngle(value) {
        this.geometryCoatTangent = new Vector2(Math.cos(value), Math.sin(value));
      }
      /**
       * BJS is using an hardcoded light falloff based on a manually sets up range.
       * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.
       * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
       */
      get usePhysicalLightFalloff() {
        return this._lightFalloff === Material.LIGHTFALLOFF_PHYSICAL;
      }
      /**
       * BJS is using an hardcoded light falloff based on a manually sets up range.
       * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.
       * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
       */
      set usePhysicalLightFalloff(value) {
        if (value !== this.usePhysicalLightFalloff) {
          this._markAllSubMeshesAsTexturesDirty();
          if (value) {
            this._lightFalloff = Material.LIGHTFALLOFF_PHYSICAL;
          } else {
            this._lightFalloff = Material.LIGHTFALLOFF_STANDARD;
          }
        }
      }
      /**
       * In order to support the falloff compatibility with gltf, a special mode has been added
       * to reproduce the gltf light falloff.
       */
      get useGLTFLightFalloff() {
        return this._lightFalloff === Material.LIGHTFALLOFF_GLTF;
      }
      /**
       * In order to support the falloff compatibility with gltf, a special mode has been added
       * to reproduce the gltf light falloff.
       */
      set useGLTFLightFalloff(value) {
        if (value !== this.useGLTFLightFalloff) {
          this._markAllSubMeshesAsTexturesDirty();
          if (value) {
            this._lightFalloff = Material.LIGHTFALLOFF_GLTF;
          } else {
            this._lightFalloff = Material.LIGHTFALLOFF_STANDARD;
          }
        }
      }
      /**
       * Set the texture used for refraction of the background of transparent materials
       * @internal
       */
      get backgroundRefractionTexture() {
        return this._backgroundRefractionTexture;
      }
      set backgroundRefractionTexture(texture) {
        this._backgroundRefractionTexture = texture;
        this._markAllSubMeshesAsTexturesDirty();
      }
      /**
       * Enables realtime filtering on the texture.
       */
      get realTimeFiltering() {
        return this._realTimeFiltering;
      }
      set realTimeFiltering(b) {
        this._realTimeFiltering = b;
        this.markAsDirty(1);
      }
      /**
       * Quality switch for realtime filtering
       */
      get realTimeFilteringQuality() {
        return this._realTimeFilteringQuality;
      }
      set realTimeFilteringQuality(n) {
        this._realTimeFilteringQuality = n;
        this.markAsDirty(1);
      }
      /**
       * The number of samples used to compute the fuzz IBL lighting.
       */
      get fuzzSampleNumber() {
        return this._fuzzSampleNumber;
      }
      set fuzzSampleNumber(n) {
        this._fuzzSampleNumber = n;
        this.markAsDirty(1);
      }
      /**
       * Can this material render to several textures at once
       */
      get canRenderToMRT() {
        return true;
      }
      /**
       * Instantiates a new OpenPBRMaterial instance.
       *
       * @param name The material name
       * @param scene The scene the material will be use in.
       * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
       */
      constructor(name, scene, forceGLSL = false) {
        super(name, scene, void 0, forceGLSL || _OpenPBRMaterial.ForceGLSL);
        this._baseWeight = new Property("base_weight", 1, "vBaseWeight", 1);
        this._baseWeightTexture = new Sampler("base_weight", "baseWeight", "BASE_WEIGHT");
        this._baseColor = new Property("base_color", Color3.White(), "vBaseColor", 4);
        this._baseColorTexture = new Sampler("base_color", "baseColor", "BASE_COLOR");
        this._baseDiffuseRoughness = new Property("base_diffuse_roughness", 0, "vBaseDiffuseRoughness", 1);
        this._baseDiffuseRoughnessTexture = new Sampler("base_diffuse_roughness", "baseDiffuseRoughness", "BASE_DIFFUSE_ROUGHNESS");
        this._baseMetalness = new Property("base_metalness", 0, "vReflectanceInfo", 4, 0);
        this._baseMetalnessTexture = new Sampler("base_metalness", "baseMetalness", "BASE_METALNESS");
        this._specularWeight = new Property("specular_weight", 1, "vReflectanceInfo", 4, 3);
        this._specularWeightTexture = new Sampler("specular_weight", "specularWeight", "SPECULAR_WEIGHT");
        this._specularColor = new Property("specular_color", Color3.White(), "vSpecularColor", 4);
        this._specularColorTexture = new Sampler("specular_color", "specularColor", "SPECULAR_COLOR");
        this._specularRoughness = new Property("specular_roughness", 0.3, "vReflectanceInfo", 4, 1);
        this._specularRoughnessTexture = new Sampler("specular_roughness", "specularRoughness", "SPECULAR_ROUGHNESS");
        this._specularRoughnessAnisotropy = new Property("specular_roughness_anisotropy", 0, "vSpecularAnisotropy", 3, 2);
        this._specularRoughnessAnisotropyTexture = new Sampler("specular_roughness_anisotropy", "specularRoughnessAnisotropy", "SPECULAR_ROUGHNESS_ANISOTROPY");
        this._specularIor = new Property("specular_ior", 1.5, "vReflectanceInfo", 4, 2);
        this._transmissionWeight = new Property("transmission_weight", 0, "vTransmissionWeight", 1);
        this._transmissionWeightTexture = new Sampler("transmission_weight", "transmissionWeight", "TRANSMISSION_WEIGHT");
        this._transmissionColor = new Property("transmission_color", Color3.White(), "vTransmissionColor", 3, 0);
        this._transmissionColorTexture = new Sampler("transmission_color", "transmissionColor", "TRANSMISSION_COLOR");
        this._transmissionDepth = new Property("transmission_depth", 0, "vTransmissionDepth", 1, 0);
        this._transmissionDepthTexture = new Sampler("transmission_depth", "transmissionDepth", "TRANSMISSION_DEPTH");
        this._transmissionScatter = new Property("transmission_scatter", Color3.Black(), "vTransmissionScatter", 3, 0);
        this._transmissionScatterTexture = new Sampler("transmission_scatter", "transmissionScatter", "TRANSMISSION_SCATTER");
        this._transmissionScatterAnisotropy = new Property("transmission_scatter_anisotropy", 0, "vTransmissionScatterAnisotropy", 1, 0);
        this._transmissionDispersionScale = new Property("transmission_dispersion_scale", 0, "vTransmissionDispersionScale", 1, 0);
        this._transmissionDispersionScaleTexture = new Sampler("transmission_dispersion_scale", "transmissionDispersionScale", "TRANSMISSION_DISPERSION_SCALE");
        this._transmissionDispersionAbbeNumber = new Property("transmission_dispersion_abbe_number", 20, "vTransmissionDispersionAbbeNumber", 1, 0);
        this._coatWeight = new Property("coat_weight", 0, "vCoatWeight", 1, 0);
        this._coatWeightTexture = new Sampler("coat_weight", "coatWeight", "COAT_WEIGHT");
        this._coatColor = new Property("coat_color", Color3.White(), "vCoatColor", 3, 0);
        this._coatColorTexture = new Sampler("coat_color", "coatColor", "COAT_COLOR");
        this._coatRoughness = new Property("coat_roughness", 0, "vCoatRoughness", 1, 0);
        this._coatRoughnessTexture = new Sampler("coat_roughness", "coatRoughness", "COAT_ROUGHNESS");
        this._coatRoughnessAnisotropy = new Property("coat_roughness_anisotropy", 0, "vCoatRoughnessAnisotropy", 1);
        this._coatRoughnessAnisotropyTexture = new Sampler("coat_roughness_anisotropy", "coatRoughnessAnisotropy", "COAT_ROUGHNESS_ANISOTROPY");
        this._coatIor = new Property("coat_ior", 1.5, "vCoatIor", 1, 0);
        this._coatDarkening = new Property("coat_darkening", 1, "vCoatDarkening", 1, 0);
        this._coatDarkeningTexture = new Sampler("coat_darkening", "coatDarkening", "COAT_DARKENING");
        this.useCoatRoughnessFromWeightTexture = false;
        this._fuzzWeight = new Property("fuzz_weight", 0, "vFuzzWeight", 1, 0);
        this._fuzzWeightTexture = new Sampler("fuzz_weight", "fuzzWeight", "FUZZ_WEIGHT");
        this._fuzzColor = new Property("fuzz_color", Color3.White(), "vFuzzColor", 3, 0);
        this._fuzzColorTexture = new Sampler("fuzz_color", "fuzzColor", "FUZZ_COLOR");
        this._fuzzRoughness = new Property("fuzz_roughness", 0.5, "vFuzzRoughness", 1, 0);
        this._fuzzRoughnessTexture = new Sampler("fuzz_roughness", "fuzzRoughness", "FUZZ_ROUGHNESS");
        this._geometryNormalTexture = new Sampler("geometry_normal", "geometryNormal", "GEOMETRY_NORMAL");
        this._geometryTangent = new Property("geometry_tangent", new Vector2(1, 0), "vSpecularAnisotropy", 3, 0);
        this._geometryTangentTexture = new Sampler("geometry_tangent", "geometryTangent", "GEOMETRY_TANGENT");
        this._geometryCoatNormalTexture = new Sampler("geometry_coat_normal", "geometryCoatNormal", "GEOMETRY_COAT_NORMAL");
        this._geometryCoatTangent = new Property("geometry_coat_tangent", new Vector2(1, 0), "vGeometryCoatTangent", 2, 0);
        this._geometryCoatTangentTexture = new Sampler("geometry_coat_tangent", "geometryCoatTangent", "GEOMETRY_COAT_TANGENT");
        this._geometryOpacity = new Property("geometry_opacity", 1, "vBaseColor", 4, 3);
        this._geometryOpacityTexture = new Sampler("geometry_opacity", "geometryOpacity", "GEOMETRY_OPACITY");
        this._geometryThickness = new Property("geometry_thickness", 0, "vGeometryThickness", 1, 0);
        this._geometryThicknessTexture = new Sampler("geometry_thickness", "geometryThickness", "GEOMETRY_THICKNESS");
        this._emissionLuminance = new Property("emission_luminance", 1, "vLightingIntensity", 4, 1);
        this._emissionColor = new Property("emission_color", Color3.Black(), "vEmissionColor", 3);
        this._emissionColorTexture = new Sampler("emission_color", "emissionColor", "EMISSION_COLOR");
        this._thinFilmWeight = new Property("thin_film_weight", 0, "vThinFilmWeight", 1, 0);
        this._thinFilmWeightTexture = new Sampler("thin_film_weight", "thinFilmWeight", "THIN_FILM_WEIGHT");
        this._thinFilmThickness = new Property("thin_film_thickness", 0.5, "vThinFilmThickness", 2, 0);
        this._thinFilmThicknessMin = new Property("thin_film_thickness_min", 0, "vThinFilmThickness", 2, 1);
        this._thinFilmThicknessTexture = new Sampler("thin_film_thickness", "thinFilmThickness", "THIN_FILM_THICKNESS");
        this._thinFilmIor = new Property("thin_film_ior", 1.4, "vThinFilmIor", 1, 0);
        this._ambientOcclusionTexture = new Sampler("ambient_occlusion", "ambientOcclusion", "AMBIENT_OCCLUSION");
        this._uniformsList = {};
        this._samplersList = {};
        this._samplerDefines = {};
        this.directIntensity = 1;
        this.environmentIntensity = 1;
        this.useSpecularWeightFromTextureAlpha = false;
        this.forceAlphaTest = false;
        this.alphaCutOff = 0.4;
        this.useAmbientOcclusionFromMetallicTextureRed = false;
        this.useAmbientInGrayScale = false;
        this.useObjectSpaceNormalMap = false;
        this.useParallax = false;
        this.useParallaxOcclusion = false;
        this.parallaxScaleBias = 0.05;
        this.disableLighting = false;
        this.forceIrradianceInFragment = false;
        this.maxSimultaneousLights = 4;
        this.invertNormalMapX = false;
        this.invertNormalMapY = false;
        this.twoSidedLighting = false;
        this.useAlphaFresnel = false;
        this.useLinearAlphaFresnel = false;
        this.environmentBRDFTexture = null;
        this.forceNormalForward = false;
        this.enableSpecularAntiAliasing = false;
        this.useHorizonOcclusion = true;
        this.useRadianceOcclusion = true;
        this.unlit = false;
        this.applyDecalMapAfterDetailMap = false;
        this._lightingInfos = new Vector4(this.directIntensity, 1, this.environmentIntensity, 1);
        this._radianceTexture = null;
        this._useSpecularWeightFromAlpha = false;
        this._useSpecularWeightFromSpecularColorTexture = false;
        this._useSpecularRoughnessAnisotropyFromTangentTexture = false;
        this._useCoatRoughnessAnisotropyFromTangentTexture = false;
        this._useCoatRoughnessFromGreenChannel = false;
        this._useGltfStyleAnisotropy = false;
        this._useFuzzRoughnessFromTextureAlpha = false;
        this._useHorizonOcclusion = true;
        this._useRadianceOcclusion = true;
        this._useAlphaFromBaseColorTexture = false;
        this._useAmbientOcclusionFromMetallicTextureRed = false;
        this._useRoughnessFromMetallicTextureGreen = false;
        this._useMetallicFromMetallicTextureBlue = false;
        this._useThinFilmThicknessFromTextureGreen = false;
        this._useGeometryThicknessFromGreenChannel = false;
        this._lightFalloff = Material.LIGHTFALLOFF_PHYSICAL;
        this._useObjectSpaceNormalMap = false;
        this._useParallax = false;
        this._useParallaxOcclusion = false;
        this._parallaxScaleBias = 0.05;
        this._disableLighting = false;
        this._maxSimultaneousLights = 4;
        this._invertNormalMapX = false;
        this._invertNormalMapY = false;
        this._twoSidedLighting = false;
        this._alphaCutOff = 0.4;
        this._useAlphaFresnel = false;
        this._useLinearAlphaFresnel = false;
        this._environmentBRDFTexture = null;
        this._environmentFuzzBRDFTexture = null;
        this._backgroundRefractionTexture = null;
        this._forceIrradianceInFragment = false;
        this._realTimeFiltering = false;
        this._realTimeFilteringQuality = 8;
        this._fuzzSampleNumber = 4;
        this._forceNormalForward = false;
        this._enableSpecularAntiAliasing = false;
        this._renderTargets = new SmartArray(16);
        this._unlit = false;
        this._applyDecalMapAfterDetailMap = false;
        this._debugMode = 0;
        this._shadersLoaded = false;
        this._breakShaderLoadedCheck = false;
        this.debugMode = 0;
        this.debugLimit = -1;
        this.debugFactor = 1;
        this._cacheHasRenderTargetTextures = false;
        this._transparencyMode = Material.MATERIAL_OPAQUE;
        if (this.getScene() && !this.getScene()?.getEngine().isWebGPU && this.getScene().getEngine().webGLVersion < 2) {
          Logger.Error("OpenPBRMaterial: WebGL 2.0 or above is required for this material.");
        }
        if (!_OpenPBRMaterial._noiseTextures[this.getScene().uniqueId]) {
          _OpenPBRMaterial._noiseTextures[this.getScene().uniqueId] = new Texture(Tools.GetAssetUrl("https://assets.babylonjs.com/core/blue_noise/blue_noise_rgb.png"), this.getScene(), false, true, 1);
          this.getScene().onDisposeObservable.addOnce(() => {
            _OpenPBRMaterial._noiseTextures[this.getScene().uniqueId]?.dispose();
            delete _OpenPBRMaterial._noiseTextures[this.getScene().uniqueId];
          });
        }
        this._attachImageProcessingConfiguration(null);
        this.getRenderTargetTextures = () => {
          this._renderTargets.reset();
          if (MaterialFlags.ReflectionTextureEnabled && this._radianceTexture && this._radianceTexture.isRenderTarget) {
            this._renderTargets.push(this._radianceTexture);
          }
          if (MaterialFlags.RefractionTextureEnabled && this._backgroundRefractionTexture && this._backgroundRefractionTexture.isRenderTarget) {
            this._renderTargets.push(this._backgroundRefractionTexture);
          }
          this._eventInfo.renderTargets = this._renderTargets;
          this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);
          return this._renderTargets;
        };
        this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());
        this._environmentFuzzBRDFTexture = GetEnvironmentFuzzBRDFTexture(this.getScene());
        this.prePassConfiguration = new PrePassConfiguration();
        this._propertyList = {};
        for (const key of Object.getOwnPropertyNames(this)) {
          const value = this[key];
          if (value instanceof Property) {
            this._propertyList[key] = value;
          }
        }
        const propertyKeys = Object.keys(this._propertyList);
        propertyKeys.forEach((key) => {
          const prop = this._propertyList[key];
          let uniform = this._uniformsList[prop.targetUniformName];
          if (!uniform) {
            uniform = new Uniform(prop.targetUniformName, prop.targetUniformComponentNum);
            this._uniformsList[prop.targetUniformName] = uniform;
          } else if (uniform.numComponents !== prop.targetUniformComponentNum) {
            Logger.Error(`Uniform ${prop.targetUniformName} already exists of size ${uniform.numComponents}, but trying to set it to ${prop.targetUniformComponentNum}.`);
          }
          uniform.linkedProperties[prop.name] = prop;
        });
        this._samplersList = {};
        for (const key of Object.getOwnPropertyNames(this)) {
          const value = this[key];
          if (value instanceof Sampler) {
            this._samplersList[key] = value;
          }
        }
        for (const samplerKey in this._samplersList) {
          const sampler = this._samplersList[samplerKey];
          const defineName = sampler.textureDefine;
          this._samplerDefines[defineName] = { type: "boolean", default: false };
          this._samplerDefines[defineName + "DIRECTUV"] = { type: "number", default: 0 };
          this._samplerDefines[defineName + "_GAMMA"] = { type: "boolean", default: false };
        }
        this._baseWeight;
        this._baseWeightTexture;
        this._baseColor;
        this._baseColorTexture;
        this._baseDiffuseRoughness;
        this._baseDiffuseRoughnessTexture;
        this._baseMetalness;
        this._baseMetalnessTexture;
        this._specularWeight;
        this._specularWeightTexture;
        this._specularColor;
        this._specularColorTexture;
        this._specularRoughness;
        this._specularIor;
        this._specularRoughnessTexture;
        this._specularRoughnessAnisotropy;
        this._specularRoughnessAnisotropyTexture;
        this._transmissionWeight;
        this._transmissionWeightTexture;
        this._transmissionColor;
        this._transmissionColorTexture;
        this._transmissionDepth;
        this._transmissionDepthTexture;
        this._transmissionScatter;
        this._transmissionScatterTexture;
        this._transmissionScatterAnisotropy;
        this._transmissionDispersionScale;
        this._transmissionDispersionScaleTexture;
        this._transmissionDispersionAbbeNumber;
        this._coatWeight;
        this._coatWeightTexture;
        this._coatColor;
        this._coatColorTexture;
        this._coatRoughness;
        this._coatRoughnessTexture;
        this._coatRoughnessAnisotropy;
        this._coatRoughnessAnisotropyTexture;
        this._coatIor;
        this._coatDarkening;
        this._coatDarkeningTexture;
        this._fuzzWeight;
        this._fuzzWeightTexture;
        this._fuzzColor;
        this._fuzzColorTexture;
        this._fuzzRoughness;
        this._fuzzRoughnessTexture;
        this._geometryNormalTexture;
        this._geometryTangent;
        this._geometryTangentTexture;
        this._geometryCoatNormalTexture;
        this._geometryCoatTangent;
        this._geometryCoatTangentTexture;
        this._geometryOpacity;
        this._geometryOpacityTexture;
        this._geometryThickness;
        this._geometryThicknessTexture;
        this._thinFilmWeight;
        this._thinFilmWeightTexture;
        this._thinFilmThickness;
        this._thinFilmThicknessMin;
        this._thinFilmThicknessTexture;
        this._thinFilmIor;
        this._emissionLuminance;
        this._emissionColor;
        this._emissionColorTexture;
        this._ambientOcclusionTexture;
      }
      /**
       * Gets a boolean indicating that current material needs to register RTT
       */
      get hasRenderTargetTextures() {
        if (MaterialFlags.ReflectionTextureEnabled && this._radianceTexture && this._radianceTexture.isRenderTarget) {
          return true;
        }
        if (MaterialFlags.RefractionTextureEnabled && this._backgroundRefractionTexture && this._backgroundRefractionTexture.isRenderTarget) {
          return true;
        }
        return this._cacheHasRenderTargetTextures;
      }
      /**
       * Can this material render to prepass
       */
      get isPrePassCapable() {
        return !this.disableDepthWrite;
      }
      /**
       * @returns the name of the material class.
       */
      getClassName() {
        return "OpenPBRMaterial";
      }
      get transparencyMode() {
        return this._transparencyMode;
      }
      set transparencyMode(value) {
        if (this._transparencyMode === value) {
          return;
        }
        this._transparencyMode = value;
        this._markAllSubMeshesAsTexturesAndMiscDirty();
      }
      /**
       * @returns whether or not the alpha value of the albedo texture should be used for alpha blending.
       */
      _shouldUseAlphaFromBaseColorTexture() {
        return this._hasAlphaChannel() && this._transparencyMode !== Material.MATERIAL_OPAQUE && !this.geometryOpacityTexture;
      }
      /**
       * @returns whether or not there is a usable alpha channel for transparency.
       */
      _hasAlphaChannel() {
        return this.baseColorTexture != null && this.baseColorTexture.hasAlpha && this._useAlphaFromBaseColorTexture || this.geometryOpacityTexture != null;
      }
      /**
       * Makes a duplicate of the current material.
       * @param name - name to use for the new material.
       * @param cloneTexturesOnlyOnce - if a texture is used in more than one channel (e.g baseColor and opacity), only clone it once and reuse it on the other channels. Default false.
       * @param rootUrl defines the root URL to use to load textures
       * @returns cloned material instance
       */
      clone(name, cloneTexturesOnlyOnce = true, rootUrl = "") {
        const clone = SerializationHelper.Clone(() => new _OpenPBRMaterial(name, this.getScene()), this, { cloneTexturesOnlyOnce });
        clone.id = name;
        clone.name = name;
        this.stencil.copyTo(clone.stencil);
        this._clonePlugins(clone, rootUrl);
        return clone;
      }
      /**
       * Serializes this PBR Material.
       * @returns - An object with the serialized material.
       */
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.customType = "BABYLON.OpenPBRMaterial";
        return serializationObject;
      }
      // Statics
      /**
       * Parses a PBR Material from a serialized object.
       * @param source - Serialized object.
       * @param scene - BJS scene instance.
       * @param rootUrl - url for the scene object
       * @returns - OpenPBRMaterial
       */
      static Parse(source, scene, rootUrl) {
        const material = SerializationHelper.Parse(() => new _OpenPBRMaterial(source.name, scene), source, scene, rootUrl);
        if (source.stencil) {
          material.stencil.parse(source.stencil, scene, rootUrl);
        }
        Material._ParsePlugins(source, material, scene, rootUrl);
        return material;
      }
      /**
       * Force shader compilation
       * @param mesh - Define the mesh we want to force the compilation for
       * @param onCompiled - Define a callback triggered when the compilation completes
       * @param options - Define the options used to create the compilation
       */
      forceCompilation(mesh, onCompiled, options) {
        const localOptions = {
          clipPlane: false,
          useInstances: false,
          ...options
        };
        if (!this._uniformBufferLayoutBuilt) {
          this.buildUniformLayout();
        }
        this._callbackPluginEventGeneric(4, this._eventInfo);
        const checkReady = () => {
          if (this._breakShaderLoadedCheck) {
            return;
          }
          const defines = new OpenPBRMaterialDefines({
            ...this._eventInfo.defineNames || {},
            ...this._samplerDefines || {}
          });
          const effect = this._prepareEffect(mesh, mesh, defines, void 0, void 0, localOptions.useInstances, localOptions.clipPlane);
          if (this._onEffectCreatedObservable) {
            onCreatedEffectParameters3.effect = effect;
            onCreatedEffectParameters3.subMesh = null;
            this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters3);
          }
          if (effect.isReady()) {
            if (onCompiled) {
              onCompiled(this);
            }
          } else {
            effect.onCompileObservable.add(() => {
              if (onCompiled) {
                onCompiled(this);
              }
            });
          }
        };
        checkReady();
      }
      /**
       * Specifies that the submesh is ready to be used.
       * @param mesh - BJS mesh.
       * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.
       * @param useInstances - Specifies that instances should be used.
       * @returns - boolean indicating that the submesh is ready or not.
       */
      isReadyForSubMesh(mesh, subMesh, useInstances) {
        if (!this._uniformBufferLayoutBuilt) {
          this.buildUniformLayout();
        }
        const drawWrapper = subMesh._drawWrapper;
        if (drawWrapper.effect && this.isFrozen) {
          if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
            return true;
          }
        }
        if (!subMesh.materialDefines) {
          this._callbackPluginEventGeneric(4, this._eventInfo);
          subMesh.materialDefines = new OpenPBRMaterialDefines({
            ...this._eventInfo.defineNames || {},
            ...this._samplerDefines || {}
          });
        }
        const defines = subMesh.materialDefines;
        if (this._isReadyForSubMesh(subMesh)) {
          return true;
        }
        const scene = this.getScene();
        const engine = scene.getEngine();
        if (defines._areTexturesDirty) {
          this._eventInfo.hasRenderTargetTextures = false;
          this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
          this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;
          if (scene.texturesEnabled) {
            for (const key in this._samplersList) {
              const sampler = this._samplersList[key];
              if (sampler.value) {
                if (!sampler.value.isReadyOrNotBlocking()) {
                  return false;
                }
              }
            }
            const radianceTexture = this._getRadianceTexture();
            if (radianceTexture && MaterialFlags.ReflectionTextureEnabled) {
              if (!radianceTexture.isReadyOrNotBlocking()) {
                return false;
              }
              if (radianceTexture.irradianceTexture) {
                if (!radianceTexture.irradianceTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              } else {
                if (!radianceTexture.sphericalPolynomial && radianceTexture.getInternalTexture()?._sphericalPolynomialPromise) {
                  return false;
                }
              }
            }
            if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
              if (!this._environmentBRDFTexture.isReady()) {
                return false;
              }
            }
            if (this._environmentFuzzBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
              if (!this._environmentFuzzBRDFTexture.isReady()) {
                return false;
              }
            }
            if (this._backgroundRefractionTexture && MaterialFlags.RefractionTextureEnabled) {
              if (!this._backgroundRefractionTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (_OpenPBRMaterial._noiseTextures[scene.uniqueId]) {
              if (!_OpenPBRMaterial._noiseTextures[scene.uniqueId].isReady()) {
                return false;
              }
            }
          }
        }
        this._eventInfo.isReadyForSubMesh = true;
        this._eventInfo.defines = defines;
        this._eventInfo.subMesh = subMesh;
        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
        if (!this._eventInfo.isReadyForSubMesh) {
          return false;
        }
        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
          if (!this._imageProcessingConfiguration.isReady()) {
            return false;
          }
        }
        if (defines["AREALIGHTUSED"]) {
          for (let index = 0; index < mesh.lightSources.length; index++) {
            if (!mesh.lightSources[index]._isReady()) {
              return false;
            }
          }
        }
        if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          mesh.createNormals(true);
          Logger.Warn("OpenPBRMaterial: Normals have been created for the mesh: " + mesh.name);
        }
        const previousEffect = subMesh.effect;
        const lightDisposed = defines._areLightsDisposed;
        let effect = this._prepareEffect(mesh, subMesh.getRenderingMesh(), defines, this.onCompiled, this.onError, useInstances, null);
        let forceWasNotReadyPreviously = false;
        if (effect) {
          if (this._onEffectCreatedObservable) {
            onCreatedEffectParameters3.effect = effect;
            onCreatedEffectParameters3.subMesh = subMesh;
            this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters3);
          }
          if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
            effect = previousEffect;
            defines.markAsUnprocessed();
            forceWasNotReadyPreviously = this.isFrozen;
            if (lightDisposed) {
              defines._areLightsDisposed = true;
              return false;
            }
          } else {
            scene.resetCachedMaterial();
            subMesh.setEffect(effect, defines, this._materialContext);
          }
        }
        if (!subMesh.effect || !subMesh.effect.isReady()) {
          return false;
        }
        defines._renderId = scene.getRenderId();
        drawWrapper._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;
        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
        this._checkScenePerformancePriority();
        return true;
      }
      /**
       * Initializes the uniform buffer layout for the shader.
       */
      buildUniformLayout() {
        const ubo = this._uniformBuffer;
        ubo.addUniform("vTangentSpaceParams", 2);
        ubo.addUniform("vLightingIntensity", 4);
        ubo.addUniform("pointSize", 1);
        ubo.addUniform("vDebugMode", 2);
        ubo.addUniform("cameraInfo", 4);
        ubo.addUniform("backgroundRefractionMatrix", 16);
        ubo.addUniform("vBackgroundRefractionInfos", 3);
        PrepareUniformLayoutForIBL(ubo, true, true, true, true, true);
        Object.values(this._uniformsList).forEach((uniform) => {
          ubo.addUniform(uniform.name, uniform.numComponents);
        });
        Object.values(this._samplersList).forEach((sampler) => {
          ubo.addUniform(sampler.samplerInfoName, 2);
          ubo.addUniform(sampler.samplerMatrixName, 16);
        });
        super.buildUniformLayout();
      }
      /**
       * Binds the material data (this function is called even if mustRebind() returns false)
       * @param uniformBuffer defines the Uniform buffer to fill in.
       * @param scene defines the scene the material belongs to.
       * @param engine defines the engine the material belongs to.
       * @param subMesh the submesh to bind data for
       */
      bindPropertiesForSubMesh(uniformBuffer, scene, engine, subMesh) {
        if (this.geometryThickness === 0) {
          uniformBuffer.updateFloat("vGeometryThickness", 0);
        } else {
          subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);
          const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));
          uniformBuffer.updateFloat("vGeometryThickness", this.geometryThickness * thicknessScale);
        }
      }
      /**
       * Binds the submesh data.
       * @param world - The world matrix.
       * @param mesh - The BJS mesh.
       * @param subMesh - A submesh of the BJS mesh.
       */
      bindForSubMesh(world, mesh, subMesh) {
        const scene = this.getScene();
        const defines = subMesh.materialDefines;
        if (!defines) {
          return;
        }
        const effect = subMesh.effect;
        if (!effect) {
          return;
        }
        this._activeEffect = effect;
        mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
        mesh.transferToEffect(world);
        const engine = scene.getEngine();
        this._uniformBuffer.bindToEffect(effect, "Material");
        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
        MaterialHelperGeometryRendering.Bind(engine.currentRenderPassId, this._activeEffect, mesh, world, this);
        const camera = scene.activeCamera;
        if (camera) {
          this._uniformBuffer.updateFloat4("cameraInfo", camera.minZ, camera.maxZ, 0, 0);
        } else {
          this._uniformBuffer.updateFloat4("cameraInfo", 0, 0, 0, 0);
        }
        this._eventInfo.subMesh = subMesh;
        this._callbackPluginEventHardBindForSubMesh(this._eventInfo);
        this.bindPropertiesForSubMesh(this._uniformBuffer, scene, scene.getEngine(), subMesh);
        if (defines.OBJECTSPACE_NORMALMAP) {
          world.toNormalMatrix(this._normalMatrix);
          this.bindOnlyNormalMatrix(this._normalMatrix);
        }
        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
        BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);
        let radianceTexture = null;
        const ubo = this._uniformBuffer;
        if (mustRebind) {
          this.bindViewProjection(effect);
          radianceTexture = this._getRadianceTexture();
          if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || subMesh._drawWrapper._forceRebindOnNextCall) {
            if (scene.texturesEnabled) {
              for (const key in this._samplersList) {
                const sampler = this._samplersList[key];
                if (sampler.value) {
                  ubo.updateFloat2(sampler.samplerInfoName, sampler.value.coordinatesIndex, sampler.value.level);
                  BindTextureMatrix(sampler.value, ubo, sampler.samplerPrefix);
                }
              }
              if (this.geometryNormalTexture) {
                if (scene._mirroredCameraPosition) {
                  ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
                } else {
                  ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
                }
              }
              BindIBLParameters(scene, defines, ubo, Color3.White(), radianceTexture, this.realTimeFiltering, true, true, true, true, true);
            }
            if (this.pointsCloud) {
              ubo.updateFloat("pointSize", this.pointSize);
            }
            Object.values(this._uniformsList).forEach((uniform) => {
              if (uniform.numComponents === 4) {
                uniform.populateVectorFromLinkedProperties(TmpVectors.Vector4[0]);
                ubo.updateVector4(uniform.name, TmpVectors.Vector4[0]);
              } else if (uniform.numComponents === 3) {
                uniform.populateVectorFromLinkedProperties(TmpVectors.Vector3[0]);
                ubo.updateVector3(uniform.name, TmpVectors.Vector3[0]);
              } else if (uniform.numComponents === 2) {
                uniform.populateVectorFromLinkedProperties(TmpVectors.Vector2[0]);
                ubo.updateFloat2(uniform.name, TmpVectors.Vector2[0].x, TmpVectors.Vector2[0].y);
              } else if (uniform.numComponents === 1) {
                ubo.updateFloat(uniform.name, uniform.linkedProperties[Object.keys(uniform.linkedProperties)[0]].value);
              }
            });
            this._lightingInfos.x = this.directIntensity;
            this._lightingInfos.y = this.emissionLuminance;
            this._lightingInfos.z = this.environmentIntensity * scene.environmentIntensity;
            this._lightingInfos.w = 1;
            ubo.updateVector4("vLightingIntensity", this._lightingInfos);
            ubo.updateFloat2("vDebugMode", this.debugLimit, this.debugFactor);
          }
          if (scene.texturesEnabled) {
            for (const key in this._samplersList) {
              const sampler = this._samplersList[key];
              if (sampler.value) {
                ubo.setTexture(sampler.samplerName, sampler.value);
              }
            }
            BindIBLSamplers(scene, defines, ubo, radianceTexture, this.realTimeFiltering);
            if (defines.ENVIRONMENTBRDF) {
              ubo.setTexture("environmentBrdfSampler", this._environmentBRDFTexture);
            }
            if (defines.FUZZENVIRONMENTBRDF) {
              ubo.setTexture("environmentFuzzBrdfSampler", this._environmentFuzzBRDFTexture);
            }
            if (defines.REFRACTED_BACKGROUND) {
              ubo.setTexture("backgroundRefractionSampler", this._backgroundRefractionTexture);
              ubo.updateMatrix("backgroundRefractionMatrix", this._backgroundRefractionTexture.getReflectionTextureMatrix());
              TmpVectors.Vector3[1].set(Math.log2(this._backgroundRefractionTexture.getSize().width), 0, 0);
              ubo.updateVector3("vBackgroundRefractionInfos", TmpVectors.Vector3[1]);
            }
            if (defines.ANISOTROPIC || defines.FUZZ || defines.REFRACTED_BACKGROUND) {
              ubo.setTexture("blueNoiseSampler", _OpenPBRMaterial._noiseTextures[this.getScene().uniqueId]);
            }
          }
          if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {
            this.getScene().depthPeelingRenderer.bind(effect);
          }
          this._eventInfo.subMesh = subMesh;
          this._callbackPluginEventBindForSubMesh(this._eventInfo);
          BindClipPlane(this._activeEffect, this, scene);
          this.bindEyePosition(effect);
        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
          this._needToBindSceneUbo = true;
        }
        if (mustRebind || !this.isFrozen) {
          if (scene.lightsEnabled && !this._disableLighting) {
            BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);
          }
          this.bindView(effect);
          BindFogParameters(scene, mesh, this._activeEffect, true);
          if (defines.NUM_MORPH_INFLUENCERS) {
            BindMorphTargetParameters(mesh, this._activeEffect);
          }
          if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {
            mesh.bakedVertexAnimationManager?.bind(effect, defines.INSTANCES);
          }
          this._imageProcessingConfiguration.bind(this._activeEffect);
          BindLogDepth(defines, this._activeEffect, scene);
        }
        this._afterBind(mesh, this._activeEffect, subMesh);
        ubo.update();
      }
      /**
       * Returns the animatable textures.
       * If material have animatable metallic texture, then reflectivity texture will not be returned, even if it has animations.
       * @returns - Array of animatable textures.
       */
      getAnimatables() {
        const results = super.getAnimatables();
        for (const key in this._samplersList) {
          const sampler = this._samplersList[key];
          if (sampler.value && sampler.value.animations && sampler.value.animations.length > 0) {
            results.push(sampler.value);
          }
        }
        if (this._radianceTexture && this._radianceTexture.animations && this._radianceTexture.animations.length > 0) {
          results.push(this._radianceTexture);
        }
        return results;
      }
      /**
       * Returns an array of the actively used textures.
       * @returns - Array of BaseTextures
       */
      getActiveTextures() {
        const activeTextures = super.getActiveTextures();
        for (const key in this._samplersList) {
          const sampler = this._samplersList[key];
          if (sampler.value) {
            activeTextures.push(sampler.value);
          }
        }
        if (this._radianceTexture) {
          activeTextures.push(this._radianceTexture);
        }
        return activeTextures;
      }
      /**
       * Checks to see if a texture is used in the material.
       * @param texture - Base texture to use.
       * @returns - Boolean specifying if a texture is used in the material.
       */
      hasTexture(texture) {
        if (super.hasTexture(texture)) {
          return true;
        }
        for (const key in this._samplersList) {
          const sampler = this._samplersList[key];
          if (sampler.value === texture) {
            return true;
          }
        }
        if (this._radianceTexture === texture) {
          return true;
        }
        return false;
      }
      /**
       * Sets the required values to the prepass renderer.
       * It can't be sets when subsurface scattering of this material is disabled.
       * When scene have ability to enable subsurface prepass effect, it will enable.
       * @returns - If prepass is enabled or not.
       */
      setPrePassRenderer() {
        return false;
      }
      /**
       * Disposes the resources of the material.
       * @param forceDisposeEffect - Forces the disposal of effects.
       * @param forceDisposeTextures - Forces the disposal of all textures.
       */
      dispose(forceDisposeEffect, forceDisposeTextures) {
        this._breakShaderLoadedCheck = true;
        if (forceDisposeTextures) {
          if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {
            this._environmentBRDFTexture.dispose();
          }
          if (this._environmentFuzzBRDFTexture && this.getScene().environmentFuzzBRDFTexture !== this._environmentFuzzBRDFTexture) {
            this._environmentFuzzBRDFTexture.dispose();
          }
          this._backgroundRefractionTexture = null;
          for (const key in this._samplersList) {
            const sampler = this._samplersList[key];
            sampler.value?.dispose();
          }
          this._radianceTexture?.dispose();
        }
        this._renderTargets.dispose();
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        super.dispose(forceDisposeEffect, forceDisposeTextures);
      }
      /**
       * Returns the texture used for reflections.
       * @returns - Reflection texture if present.  Otherwise, returns the environment texture.
       */
      _getRadianceTexture() {
        if (this._radianceTexture) {
          return this._radianceTexture;
        }
        return this.getScene().environmentTexture;
      }
      _prepareEffect(mesh, renderingMesh, defines, onCompiled = null, onError = null, useInstances = null, useClipPlane = null) {
        this._prepareDefines(mesh, renderingMesh, defines, useInstances, useClipPlane);
        if (!defines.isDirty) {
          return null;
        }
        defines.markAsProcessed();
        const scene = this.getScene();
        const engine = scene.getEngine();
        const fallbacks = new EffectFallbacks();
        let fallbackRank = 0;
        if (defines.USESPHERICALINVERTEX) {
          fallbacks.addFallback(fallbackRank++, "USESPHERICALINVERTEX");
        }
        if (defines.FOG) {
          fallbacks.addFallback(fallbackRank, "FOG");
        }
        if (defines.SPECULARAA) {
          fallbacks.addFallback(fallbackRank, "SPECULARAA");
        }
        if (defines.POINTSIZE) {
          fallbacks.addFallback(fallbackRank, "POINTSIZE");
        }
        if (defines.LOGARITHMICDEPTH) {
          fallbacks.addFallback(fallbackRank, "LOGARITHMICDEPTH");
        }
        if (defines.PARALLAX) {
          fallbacks.addFallback(fallbackRank, "PARALLAX");
        }
        if (defines.PARALLAX_RHS) {
          fallbacks.addFallback(fallbackRank, "PARALLAX_RHS");
        }
        if (defines.PARALLAXOCCLUSION) {
          fallbacks.addFallback(fallbackRank++, "PARALLAXOCCLUSION");
        }
        if (defines.ENVIRONMENTBRDF) {
          fallbacks.addFallback(fallbackRank++, "ENVIRONMENTBRDF");
        }
        if (defines.TANGENT) {
          fallbacks.addFallback(fallbackRank++, "TANGENT");
        }
        fallbackRank = HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);
        if (defines.SPECULARTERM) {
          fallbacks.addFallback(fallbackRank++, "SPECULARTERM");
        }
        if (defines.USESPHERICALFROMREFLECTIONMAP) {
          fallbacks.addFallback(fallbackRank++, "USESPHERICALFROMREFLECTIONMAP");
        }
        if (defines.USEIRRADIANCEMAP) {
          fallbacks.addFallback(fallbackRank++, "USEIRRADIANCEMAP");
        }
        if (defines.NORMAL) {
          fallbacks.addFallback(fallbackRank++, "NORMAL");
        }
        if (defines.VERTEXCOLOR) {
          fallbacks.addFallback(fallbackRank++, "VERTEXCOLOR");
        }
        if (defines.MORPHTARGETS) {
          fallbacks.addFallback(fallbackRank++, "MORPHTARGETS");
        }
        if (defines.MULTIVIEW) {
          fallbacks.addFallback(0, "MULTIVIEW");
        }
        const attribs = [VertexBuffer.PositionKind];
        if (defines.NORMAL) {
          attribs.push(VertexBuffer.NormalKind);
        }
        if (defines.TANGENT) {
          attribs.push(VertexBuffer.TangentKind);
        }
        for (let i = 1; i <= 6; ++i) {
          if (defines["UV" + i]) {
            attribs.push(`uv${i === 1 ? "" : i}`);
          }
        }
        if (defines.VERTEXCOLOR) {
          attribs.push(VertexBuffer.ColorKind);
        }
        PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
        PrepareAttributesForInstances(attribs, defines);
        PrepareAttributesForMorphTargets(attribs, mesh, defines);
        PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
        let shaderName = "openpbr";
        const uniforms = [
          "world",
          "view",
          "viewProjection",
          "vEyePosition",
          "vLightsType",
          "visibility",
          "vFogInfos",
          "vFogColor",
          "pointSize",
          "mBones",
          "normalMatrix",
          "vLightingIntensity",
          "logarithmicDepthConstant",
          "vTangentSpaceParams",
          "boneTextureWidth",
          "vDebugMode",
          "morphTargetTextureInfo",
          "morphTargetTextureIndices",
          "cameraInfo",
          "backgroundRefractionMatrix",
          "vBackgroundRefractionInfos"
        ];
        for (const uniformName in this._uniformsList) {
          uniforms.push(uniformName);
        }
        const samplers = ["environmentBrdfSampler", "boneSampler", "morphTargets", "oitDepthSampler", "oitFrontColorSampler", "areaLightsLTC1Sampler", "areaLightsLTC2Sampler"];
        if (defines.FUZZENVIRONMENTBRDF) {
          samplers.push("environmentFuzzBrdfSampler");
        }
        if (defines.REFRACTED_BACKGROUND) {
          samplers.push("backgroundRefractionSampler");
        }
        if (defines.ANISOTROPIC || defines.FUZZ || defines.REFRACTED_BACKGROUND) {
          samplers.push("blueNoiseSampler");
        }
        for (const key in this._samplersList) {
          const sampler = this._samplersList[key];
          samplers.push(sampler.samplerName);
          uniforms.push(sampler.samplerInfoName);
          uniforms.push(sampler.samplerMatrixName);
        }
        PrepareUniformsAndSamplersForIBL(uniforms, samplers, true);
        const uniformBuffers = ["Material", "Scene", "Mesh"];
        const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };
        this._eventInfo.fallbacks = fallbacks;
        this._eventInfo.fallbackRank = fallbackRank;
        this._eventInfo.defines = defines;
        this._eventInfo.uniforms = uniforms;
        this._eventInfo.attributes = attribs;
        this._eventInfo.samplers = samplers;
        this._eventInfo.uniformBuffersNames = uniformBuffers;
        this._eventInfo.customCode = void 0;
        this._eventInfo.mesh = mesh;
        this._eventInfo.indexParameters = indexParameters;
        this._callbackPluginEventGeneric(128, this._eventInfo);
        MaterialHelperGeometryRendering.AddUniformsAndSamplers(uniforms, samplers);
        PrePassConfiguration.AddUniforms(uniforms);
        PrePassConfiguration.AddSamplers(samplers);
        AddClipPlaneUniforms(uniforms);
        if (ImageProcessingConfiguration) {
          ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
          ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
        }
        PrepareUniformsAndSamplersList({
          uniformsNames: uniforms,
          uniformBuffersNames: uniformBuffers,
          samplers,
          defines,
          maxSimultaneousLights: this._maxSimultaneousLights
        });
        const csnrOptions = {};
        if (this.customShaderNameResolve) {
          shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
        }
        const join = defines.toString();
        const effect = engine.createEffect(shaderName, {
          attributes: attribs,
          uniformsNames: uniforms,
          uniformBuffersNames: uniformBuffers,
          samplers,
          defines: join,
          fallbacks,
          onCompiled,
          onError,
          indexParameters,
          processFinalCode: csnrOptions.processFinalCode,
          processCodeAfterIncludes: this._eventInfo.customCode,
          multiTarget: defines.PREPASS,
          shaderLanguage: this._shaderLanguage,
          extraInitializationsAsync: this._shadersLoaded ? void 0 : async () => {
            if (this.shaderLanguage === 1) {
              await Promise.all([import("./openpbr.vertex-KKZDD7XL.js"), import("./openpbr.fragment-KIOQNOMR.js")]);
            } else {
              await Promise.all([import("./openpbr.vertex-SJP6YHUR.js"), import("./openpbr.fragment-LKBTCP2P.js")]);
            }
            this._shadersLoaded = true;
          }
        }, engine);
        this._eventInfo.customCode = void 0;
        return effect;
      }
      _prepareDefines(mesh, renderingMesh, defines, useInstances = null, useClipPlane = null) {
        const useThinInstances = renderingMesh.hasThinInstances;
        const scene = this.getScene();
        const engine = scene.getEngine();
        PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
        defines._needNormals = true;
        PrepareDefinesForMultiview(scene, defines);
        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
        PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);
        PrepareDefinesForOIT(scene, defines, oit);
        MaterialHelperGeometryRendering.PrepareDefines(engine.currentRenderPassId, mesh, defines);
        if (defines._areTexturesDirty) {
          defines._needUVs = false;
          for (let i = 1; i <= 6; ++i) {
            defines["MAINUV" + i] = false;
          }
          if (scene.texturesEnabled) {
            for (const key in this._samplersList) {
              const sampler = this._samplersList[key];
              if (sampler.value) {
                PrepareDefinesForMergedUV(sampler.value, defines, sampler.textureDefine);
                defines[sampler.textureDefine + "_GAMMA"] = sampler.value.gammaSpace;
              } else {
                defines[sampler.textureDefine] = false;
              }
            }
            const radianceTexture = this._getRadianceTexture();
            const useSHInFragment = this._forceIrradianceInFragment || this.realTimeFiltering || this._twoSidedLighting || engine.getCaps().maxVaryingVectors <= 8 || this._baseDiffuseRoughnessTexture != null;
            PrepareDefinesForIBL(scene, radianceTexture, defines, this.realTimeFiltering, this.realTimeFilteringQuality, !useSHInFragment);
            if (this._baseMetalnessTexture) {
              defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;
            }
            defines.SPECULAR_WEIGHT_IN_ALPHA = this._useSpecularWeightFromAlpha;
            defines.SPECULAR_WEIGHT_FROM_SPECULAR_COLOR_TEXTURE = this._useSpecularWeightFromSpecularColorTexture;
            defines.SPECULAR_ROUGHNESS_ANISOTROPY_FROM_TANGENT_TEXTURE = this._useSpecularRoughnessAnisotropyFromTangentTexture;
            defines.COAT_ROUGHNESS_ANISOTROPY_FROM_TANGENT_TEXTURE = this._useCoatRoughnessAnisotropyFromTangentTexture;
            defines.COAT_ROUGHNESS_FROM_GREEN_CHANNEL = this._useCoatRoughnessFromGreenChannel;
            defines.SPECULAR_ROUGHNESS_FROM_METALNESS_TEXTURE_GREEN = this._useRoughnessFromMetallicTextureGreen;
            defines.FUZZ_ROUGHNESS_FROM_TEXTURE_ALPHA = this._useFuzzRoughnessFromTextureAlpha;
            defines.BASE_METALNESS_FROM_METALNESS_TEXTURE_BLUE = this._useMetallicFromMetallicTextureBlue;
            defines.THIN_FILM_THICKNESS_FROM_THIN_FILM_TEXTURE = this._useThinFilmThicknessFromTextureGreen;
            defines.GEOMETRY_THICKNESS_FROM_GREEN_CHANNEL = this._useGeometryThicknessFromGreenChannel;
            if (this.geometryNormalTexture) {
              if (this._useParallax && this.baseColorTexture && MaterialFlags.DiffuseTextureEnabled) {
                defines.PARALLAX = true;
                defines.PARALLAX_RHS = scene.useRightHandedSystem;
                defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;
              } else {
                defines.PARALLAX = false;
              }
              defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
            } else {
              defines.PARALLAX = false;
              defines.PARALLAX_RHS = false;
              defines.PARALLAXOCCLUSION = false;
              defines.OBJECTSPACE_NORMALMAP = false;
            }
            if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
              defines.ENVIRONMENTBRDF = true;
              defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;
            } else {
              defines.ENVIRONMENTBRDF = false;
              defines.ENVIRONMENTBRDF_RGBD = false;
            }
            if (this._environmentFuzzBRDFTexture) {
              defines.FUZZENVIRONMENTBRDF = true;
            } else {
              defines.FUZZENVIRONMENTBRDF = false;
            }
            if (this.transmissionWeight > 0) {
              defines.REFRACTED_BACKGROUND = !!this._backgroundRefractionTexture && MaterialFlags.RefractionTextureEnabled;
              defines.REFRACTED_LIGHTS = true;
              const radianceTexture2 = this._getRadianceTexture();
              if (radianceTexture2) {
                defines.REFRACTED_ENVIRONMENT = MaterialFlags.RefractionTextureEnabled;
                defines.REFRACTED_ENVIRONMENT_OPPOSITEZ = this.getScene().useRightHandedSystem ? !radianceTexture2.invertZ : radianceTexture2.invertZ;
                defines.REFRACTED_ENVIRONMENT_LOCAL_CUBE = radianceTexture2.isCube && radianceTexture2.boundingBoxSize;
              } else {
                defines.REFRACTED_ENVIRONMENT = false;
              }
            } else {
              defines.REFRACTED_BACKGROUND = false;
              defines.REFRACTED_LIGHTS = false;
              defines.REFRACTED_ENVIRONMENT = false;
            }
            if (this._shouldUseAlphaFromBaseColorTexture()) {
              defines.ALPHA_FROM_BASE_COLOR_TEXTURE = true;
            } else {
              defines.ALPHA_FROM_BASE_COLOR_TEXTURE = false;
            }
          }
          if (this._lightFalloff === Material.LIGHTFALLOFF_STANDARD) {
            defines.USEPHYSICALLIGHTFALLOFF = false;
            defines.USEGLTFLIGHTFALLOFF = false;
          } else if (this._lightFalloff === Material.LIGHTFALLOFF_GLTF) {
            defines.USEPHYSICALLIGHTFALLOFF = false;
            defines.USEGLTFLIGHTFALLOFF = true;
          } else {
            defines.USEPHYSICALLIGHTFALLOFF = true;
            defines.USEGLTFLIGHTFALLOFF = false;
          }
          if (!this.backFaceCulling && this._twoSidedLighting) {
            defines.TWOSIDEDLIGHTING = true;
          } else {
            defines.TWOSIDEDLIGHTING = false;
          }
          defines.MIRRORED = !!scene._mirroredCameraPosition;
          defines.SPECULARAA = engine.getCaps().standardDerivatives && this._enableSpecularAntiAliasing;
        }
        if (defines._areTexturesDirty || defines._areMiscDirty) {
          defines.ALPHATESTVALUE = `${this._alphaCutOff}${this._alphaCutOff % 1 === 0 ? "." : ""}`;
          defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
          defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);
        }
        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
          this._imageProcessingConfiguration.prepareDefines(defines);
        }
        defines.FORCENORMALFORWARD = this._forceNormalForward;
        defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;
        defines.HORIZONOCCLUSION = this._useHorizonOcclusion;
        if ((this.specularRoughnessAnisotropy > 0 || this.coatRoughnessAnisotropy > 0) && _OpenPBRMaterial._noiseTextures[scene.uniqueId] && MaterialFlags.ReflectionTextureEnabled) {
          defines.ANISOTROPIC = true;
          if (!mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
            defines._needUVs = true;
            defines.MAINUV1 = true;
          }
          if (this._useGltfStyleAnisotropy) {
            defines.USE_GLTF_STYLE_ANISOTROPY = true;
          }
          defines.ANISOTROPIC_BASE = this.specularRoughnessAnisotropy > 0;
          defines.ANISOTROPIC_COAT = this.coatRoughnessAnisotropy > 0;
        } else {
          defines.ANISOTROPIC = false;
          defines.USE_GLTF_STYLE_ANISOTROPY = false;
          defines.ANISOTROPIC_BASE = false;
          defines.ANISOTROPIC_COAT = false;
        }
        defines.THIN_FILM = this.thinFilmWeight > 0;
        defines.IRIDESCENCE = this.thinFilmWeight > 0;
        defines.DISPERSION = this.transmissionDispersionScale > 0;
        defines.SCATTERING = !this.transmissionScatter.equals(Color3.BlackReadOnly);
        defines.FUZZ = this.fuzzWeight > 0 && MaterialFlags.ReflectionTextureEnabled;
        if (defines.FUZZ) {
          if (!mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
            defines._needUVs = true;
            defines.MAINUV1 = true;
          }
          this._environmentFuzzBRDFTexture = GetEnvironmentFuzzBRDFTexture(this.getScene());
          defines.FUZZ_IBL_SAMPLES = this.fuzzSampleNumber;
        } else {
          this._environmentFuzzBRDFTexture = null;
          defines.FUZZENVIRONMENTBRDF = false;
          defines.FUZZ_IBL_SAMPLES = 0;
        }
        if (defines._areMiscDirty) {
          PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines, this._applyDecalMapAfterDetailMap, this._useVertexPulling, renderingMesh, this._isVertexOutputInvariant);
          defines.UNLIT = this._unlit || (this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
          defines.DEBUGMODE = this._debugMode;
        }
        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, useClipPlane, useThinInstances);
        this._eventInfo.defines = defines;
        this._eventInfo.mesh = mesh;
        this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);
        PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== Material.MATERIAL_OPAQUE);
        this._callbackPluginEventPrepareDefines(this._eventInfo);
      }
    };
    OpenPBRMaterial._noiseTextures = {};
    OpenPBRMaterial.ForceGLSL = false;
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "baseWeight")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_baseWeight", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "baseWeightTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_baseWeightTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "baseColor")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_baseColor", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "baseColorTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_baseColorTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "baseDiffuseRoughness")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_baseDiffuseRoughness", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "baseDiffuseRoughnessTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_baseDiffuseRoughnessTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "baseMetalness")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_baseMetalness", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "baseMetalnessTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_baseMetalnessTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularWeight")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_specularWeight", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularWeightTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_specularWeightTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularColor")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_specularColor", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularColorTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_specularColorTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularRoughness")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_specularRoughness", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularRoughnessTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_specularRoughnessTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularRoughnessAnisotropy")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_specularRoughnessAnisotropy", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularRoughnessAnisotropyTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_specularRoughnessAnisotropyTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularIor")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_specularIor", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "transmissionWeight")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_transmissionWeight", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "transmissionWeightTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_transmissionWeightTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "transmissionColor")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_transmissionColor", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "transmissionColorTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_transmissionColorTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "transmissionDepth")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_transmissionDepth", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "transmissionDepthTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_transmissionDepthTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "transmissionScatter")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_transmissionScatter", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "transmissionScatterTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_transmissionScatterTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "transmissionScatterAnisotropy")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_transmissionScatterAnisotropy", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "transmissionDispersionScale")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_transmissionDispersionScale", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "transmissionDispersionScaleTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_transmissionDispersionScaleTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "transmissionDispersionAbbeNumber")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_transmissionDispersionAbbeNumber", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatWeight")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_coatWeight", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatWeightTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_coatWeightTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatColor")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_coatColor", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatColorTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_coatColorTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatRoughness")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_coatRoughness", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatRoughnessTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_coatRoughnessTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatRoughnessAnisotropy")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_coatRoughnessAnisotropy", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatRoughnessAnisotropyTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_coatRoughnessAnisotropyTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatIor")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_coatIor", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatDarkening")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_coatDarkening", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatDarkeningTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_coatDarkeningTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "fuzzWeight")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_fuzzWeight", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "fuzzWeightTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_fuzzWeightTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "fuzzColor")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_fuzzColor", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "fuzzColorTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_fuzzColorTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "fuzzRoughness")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_fuzzRoughness", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "fuzzRoughnessTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_fuzzRoughnessTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryNormalTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_geometryNormalTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryTangent")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_geometryTangent", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryTangentTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_geometryTangentTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryCoatNormalTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_geometryCoatNormalTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryCoatTangent")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_geometryCoatTangent", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryCoatTangentTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_geometryCoatTangentTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryOpacity")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_geometryOpacity", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryOpacityTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_geometryOpacityTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryThickness")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_geometryThickness", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryThicknessTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_geometryThicknessTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "emissionLuminance")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_emissionLuminance", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "emissionColor")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_emissionColor", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "emissionColorTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_emissionColorTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "thinFilmWeight")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_thinFilmWeight", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "thinFilmWeightTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_thinFilmWeightTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "thinFilmThickness")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_thinFilmThickness", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "thinFilmThicknessMin")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_thinFilmThicknessMin", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "thinFilmThicknessTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_thinFilmThicknessTexture", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "thinFilmIor")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_thinFilmIor", void 0);
    __decorate([
      addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "ambientOcclusionTexture")
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], OpenPBRMaterial.prototype, "_ambientOcclusionTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "directIntensity", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "environmentIntensity", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "useSpecularWeightFromTextureAlpha", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], OpenPBRMaterial.prototype, "forceAlphaTest", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], OpenPBRMaterial.prototype, "alphaCutOff", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "useAmbientOcclusionFromMetallicTextureRed", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "useAmbientInGrayScale", void 0);
    __decorate([
      serialize()
    ], OpenPBRMaterial.prototype, "usePhysicalLightFalloff", null);
    __decorate([
      serialize()
    ], OpenPBRMaterial.prototype, "useGLTFLightFalloff", null);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "useObjectSpaceNormalMap", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "useParallax", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "useParallaxOcclusion", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "parallaxScaleBias", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], OpenPBRMaterial.prototype, "disableLighting", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "forceIrradianceInFragment", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], OpenPBRMaterial.prototype, "maxSimultaneousLights", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "invertNormalMapX", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "invertNormalMapY", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "twoSidedLighting", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "useAlphaFresnel", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "useLinearAlphaFresnel", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "environmentBRDFTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "forceNormalForward", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "enableSpecularAntiAliasing", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "useHorizonOcclusion", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], OpenPBRMaterial.prototype, "useRadianceOcclusion", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], OpenPBRMaterial.prototype, "unlit", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], OpenPBRMaterial.prototype, "applyDecalMapAfterDetailMap", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], OpenPBRMaterial.prototype, "debugMode", void 0);
    __decorate([
      serialize()
    ], OpenPBRMaterial.prototype, "transparencyMode", null);
    RegisterClass("BABYLON.OpenPBRMaterial", OpenPBRMaterial);
  }
});

// node_modules/@babylonjs/core/Maths/math.scalar.js
var HCF, Scalar;
var init_math_scalar = __esm({
  "node_modules/@babylonjs/core/Maths/math.scalar.js"() {
    init_math_scalar_functions();
    HCF = HighestCommonFactor;
    Scalar = {
      ...math_scalar_functions_exports,
      /**
       * Two pi constants convenient for computation.
       */
      TwoPi: Math.PI * 2,
      /**
       * Returns -1 if value is negative and +1 is value is positive.
       * @param value the value
       * @returns the value itself if it's equal to zero.
       */
      Sign: Math.sign,
      /**
       * the log2 of value.
       * @param value the value to compute log2 of
       * @returns the log2 of value.
       */
      Log2: Math.log2,
      /**
       * Returns the highest common factor of two integers.
       * @param a first parameter
       * @param b second parameter
       * @returns HCF of a and b
       */
      HCF
    };
  }
});

export {
  Camera,
  init_camera,
  SceneLoaderFlags,
  init_sceneLoaderFlags,
  Geometry,
  init_geometry,
  MultiMaterial,
  init_multiMaterial,
  MeshLODLevel,
  init_meshLODLevel,
  _CreationDataStorage,
  _InstancesBatch,
  Mesh,
  init_mesh,
  InstancedMesh,
  init_instancedMesh,
  Light,
  init_light,
  RawTexture,
  init_rawTexture,
  TargetCamera,
  init_targetCamera,
  ImageProcessingDefinesMixin,
  ImageProcessingConfigurationDefines,
  init_imageProcessingConfiguration_defines,
  MaterialPluginManager,
  RegisterMaterialPlugin,
  UnregisterMaterialPlugin,
  UnregisterAllMaterialPlugins,
  init_materialPluginManager,
  MaterialPluginBase,
  init_materialPluginBase,
  MaterialDetailMapDefines,
  DetailMapConfiguration,
  init_material_detailMapConfiguration,
  GeometryRenderingTextureClearType,
  MaterialHelperGeometryRendering,
  init_materialHelper_geometryrendering,
  UVDefinesMixin,
  init_uv_defines,
  ImageProcessingMixin,
  init_imageProcessing,
  StandardMaterialDefines,
  StandardMaterial,
  init_standardMaterial,
  PrepareVertexPullingUniforms,
  BindVertexPullingUniforms,
  init_vertexPullingHelper_functions,
  ShaderMaterial,
  init_shaderMaterial,
  LinesMesh,
  InstancedLinesMesh,
  init_linesMesh,
  Polygon,
  PolygonMeshBuilder,
  init_polygonMesh,
  CreatePolygonVertexData,
  CreatePolygon,
  ExtrudePolygon,
  PolygonBuilder,
  init_polygonBuilder,
  CreateTextShapePaths,
  CreateText,
  init_textBuilder,
  Constants,
  init_constants,
  GetEnvironmentBRDFTexture,
  GetEnvironmentFuzzBRDFTexture,
  BRDFTextureTools,
  init_brdfTextureTools,
  MaterialBRDFDefines,
  PBRBRDFConfiguration,
  init_pbrBRDFConfiguration,
  MaterialClearCoatDefines,
  PBRClearCoatConfiguration,
  init_pbrClearCoatConfiguration,
  MaterialIridescenceDefines,
  PBRIridescenceConfiguration,
  init_pbrIridescenceConfiguration,
  MaterialAnisotropicDefines,
  PBRAnisotropicConfiguration,
  init_pbrAnisotropicConfiguration,
  MaterialSheenDefines,
  PBRSheenConfiguration,
  init_pbrSheenConfiguration,
  MaterialSubSurfaceDefines,
  PBRSubSurfaceConfiguration,
  init_pbrSubSurfaceConfiguration,
  PBRMaterialDefines,
  PBRBaseMaterial,
  init_pbrBaseMaterial,
  ProceduralTextureSceneComponent,
  init_proceduralTextureSceneComponent,
  ProceduralTexture,
  init_proceduralTexture,
  MorphTarget,
  init_morphTarget,
  OpenPBRMaterialDefines,
  OpenPBRMaterial,
  init_openpbrMaterial,
  Scalar,
  init_math_scalar
};
//# sourceMappingURL=chunk-JWLZD23T.js.map
