{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/materialStencilState.ts", "../../../dev/core/src/Materials/material.ts", "../../../dev/core/src/Materials/materialDefines.ts", "../../../dev/core/src/Materials/pushMaterial.ts", "../../../dev/core/src/Materials/effectFallbacks.ts"],
  "sourcesContent": ["import { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\n\r\nimport type { Scene } from \"../scene\";\r\n\r\n/**\r\n * Class that holds the different stencil states of a material\r\n * Usage example: https://playground.babylonjs.com/#CW5PRI#10\r\n */\r\nexport class MaterialStencilState implements IStencilState {\r\n    /**\r\n     * Creates a material stencil state instance\r\n     */\r\n    public constructor() {\r\n        this.reset();\r\n    }\r\n\r\n    /**\r\n     * Resets all the stencil states to default values\r\n     */\r\n    public reset() {\r\n        this.enabled = false;\r\n        this.mask = 0xff;\r\n\r\n        this.funcRef = 1;\r\n        this.funcMask = 0xff;\r\n\r\n        this.func = Constants.ALWAYS;\r\n        this.opStencilFail = Constants.KEEP;\r\n        this.opDepthFail = Constants.KEEP;\r\n        this.opStencilDepthPass = Constants.REPLACE;\r\n\r\n        this.backFunc = Constants.ALWAYS;\r\n        this.backOpStencilFail = Constants.KEEP;\r\n        this.backOpDepthFail = Constants.KEEP;\r\n        this.backOpStencilDepthPass = Constants.REPLACE;\r\n    }\r\n\r\n    private _func: number;\r\n    /**\r\n     * Gets or sets the stencil function\r\n     */\r\n    @serialize()\r\n    public get func(): number {\r\n        return this._func;\r\n    }\r\n\r\n    public set func(value: number) {\r\n        this._func = value;\r\n    }\r\n\r\n    private _backFunc: number;\r\n    /**\r\n     * Gets or sets the stencil back function\r\n     */\r\n    @serialize()\r\n    public get backFunc(): number {\r\n        return this._backFunc;\r\n    }\r\n\r\n    public set backFunc(value: number) {\r\n        this._backFunc = value;\r\n    }\r\n\r\n    private _funcRef: number;\r\n    /**\r\n     * Gets or sets the stencil function reference\r\n     */\r\n    @serialize()\r\n    public get funcRef(): number {\r\n        return this._funcRef;\r\n    }\r\n\r\n    public set funcRef(value: number) {\r\n        this._funcRef = value;\r\n    }\r\n\r\n    private _funcMask: number;\r\n    /**\r\n     * Gets or sets the stencil function mask\r\n     */\r\n    @serialize()\r\n    public get funcMask(): number {\r\n        return this._funcMask;\r\n    }\r\n\r\n    public set funcMask(value: number) {\r\n        this._funcMask = value;\r\n    }\r\n\r\n    private _opStencilFail: number;\r\n    /**\r\n     * Gets or sets the operation when the stencil test fails\r\n     */\r\n    @serialize()\r\n    public get opStencilFail(): number {\r\n        return this._opStencilFail;\r\n    }\r\n\r\n    public set opStencilFail(value: number) {\r\n        this._opStencilFail = value;\r\n    }\r\n\r\n    private _opDepthFail: number;\r\n    /**\r\n     * Gets or sets the operation when the depth test fails\r\n     */\r\n    @serialize()\r\n    public get opDepthFail(): number {\r\n        return this._opDepthFail;\r\n    }\r\n\r\n    public set opDepthFail(value: number) {\r\n        this._opDepthFail = value;\r\n    }\r\n\r\n    private _opStencilDepthPass: number;\r\n    /**\r\n     * Gets or sets the operation when the stencil+depth test succeeds\r\n     */\r\n    @serialize()\r\n    public get opStencilDepthPass(): number {\r\n        return this._opStencilDepthPass;\r\n    }\r\n\r\n    public set opStencilDepthPass(value: number) {\r\n        this._opStencilDepthPass = value;\r\n    }\r\n\r\n    private _backOpStencilFail: number;\r\n    /**\r\n     * Gets or sets the operation when the back stencil test fails\r\n     */\r\n    @serialize()\r\n    public get backOpStencilFail(): number {\r\n        return this._backOpStencilFail;\r\n    }\r\n\r\n    public set backOpStencilFail(value: number) {\r\n        this._backOpStencilFail = value;\r\n    }\r\n\r\n    private _backOpDepthFail: number;\r\n    /**\r\n     * Gets or sets the operation when the back depth test fails\r\n     */\r\n    @serialize()\r\n    public get backOpDepthFail(): number {\r\n        return this._backOpDepthFail;\r\n    }\r\n\r\n    public set backOpDepthFail(value: number) {\r\n        this._backOpDepthFail = value;\r\n    }\r\n\r\n    private _backOpStencilDepthPass: number;\r\n    /**\r\n     * Gets or sets the operation when the back stencil+depth test succeeds\r\n     */\r\n    @serialize()\r\n    public get backOpStencilDepthPass(): number {\r\n        return this._backOpStencilDepthPass;\r\n    }\r\n\r\n    public set backOpStencilDepthPass(value: number) {\r\n        this._backOpStencilDepthPass = value;\r\n    }\r\n\r\n    private _mask: number;\r\n    /**\r\n     * Gets or sets the stencil mask\r\n     */\r\n    @serialize()\r\n    public get mask(): number {\r\n        return this._mask;\r\n    }\r\n\r\n    public set mask(value: number) {\r\n        this._mask = value;\r\n    }\r\n\r\n    private _enabled: boolean;\r\n    /**\r\n     * Enables or disables the stencil test\r\n     */\r\n    @serialize()\r\n    public get enabled(): boolean {\r\n        return this._enabled;\r\n    }\r\n\r\n    public set enabled(value: boolean) {\r\n        this._enabled = value;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name, useful for serialization or dynamic coding.\r\n     * @returns \"MaterialStencilState\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MaterialStencilState\";\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param stencilState defines stencil state where to copy the info\r\n     */\r\n    public copyTo(stencilState: MaterialStencilState): void {\r\n        SerializationHelper.Clone(() => stencilState, this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this stencil configuration.\r\n     * @returns - An object with the serialized config.\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Parses a stencil state configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        SerializationHelper.Parse(() => this, source, scene, rootUrl);\r\n    }\r\n}\r\n", "import { serialize } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Immutable, Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { Effect } from \"./effect\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport { Plane } from \"../Maths/math.plane\";\r\nimport type { ShadowDepthWrapper } from \"./shadowDepthWrapper\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\nimport { DrawWrapper } from \"./drawWrapper\";\r\nimport { MaterialStencilState } from \"./materialStencilState\";\r\nimport { ScenePerformancePriority } from \"../scene\";\r\nimport type { Scene } from \"../scene\";\r\nimport type {\r\n    MaterialPluginDisposed,\r\n    MaterialPluginIsReadyForSubMesh,\r\n    MaterialPluginGetDefineNames,\r\n    MaterialPluginBindForSubMesh,\r\n    MaterialPluginGetActiveTextures,\r\n    MaterialPluginHasTexture,\r\n    MaterialPluginGetAnimatables,\r\n    MaterialPluginPrepareDefines,\r\n    MaterialPluginPrepareEffect,\r\n    MaterialPluginPrepareUniformBuffer,\r\n    MaterialPluginCreated,\r\n    MaterialPluginFillRenderTargetTextures,\r\n    MaterialPluginHasRenderTargetTextures,\r\n    MaterialPluginHardBindForSubMesh,\r\n} from \"./materialPluginEvent\";\r\nimport { MaterialPluginEvent } from \"./materialPluginEvent\";\r\nimport type { ShaderCustomProcessingFunction } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { IClipPlanesHolder } from \"../Misc/interfaces/iClipPlanesHolder\";\r\n\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Animation } from \"../Animations/animation\";\r\nimport type { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { BindSceneUniformBuffer } from \"./materialHelper.functions\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport { IsWrapper } from \"./drawWrapper.functions\";\r\n\r\ndeclare let BABYLON: any;\r\n\r\n/**\r\n * Options for compiling materials.\r\n */\r\nexport interface IMaterialCompilationOptions {\r\n    /**\r\n     * Defines whether clip planes are enabled.\r\n     */\r\n    clipPlane: boolean;\r\n\r\n    /**\r\n     * Defines whether instances are enabled.\r\n     */\r\n    useInstances: boolean;\r\n}\r\n\r\n/**\r\n * Options passed when calling customShaderNameResolve\r\n */\r\nexport interface ICustomShaderNameResolveOptions {\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>;\r\n}\r\n\r\n/**\r\n * Base class for the main features of a material in Babylon.js\r\n */\r\nexport class Material implements IAnimatable, IClipPlanesHolder {\r\n    /**\r\n     * Returns the triangle fill mode\r\n     */\r\n    public static readonly TriangleFillMode = Constants.MATERIAL_TriangleFillMode;\r\n    /**\r\n     * Returns the wireframe mode\r\n     */\r\n    public static readonly WireFrameFillMode = Constants.MATERIAL_WireFrameFillMode;\r\n    /**\r\n     * Returns the point fill mode\r\n     */\r\n    public static readonly PointFillMode = Constants.MATERIAL_PointFillMode;\r\n    /**\r\n     * Returns the point list draw mode\r\n     */\r\n    public static readonly PointListDrawMode = Constants.MATERIAL_PointListDrawMode;\r\n    /**\r\n     * Returns the line list draw mode\r\n     */\r\n    public static readonly LineListDrawMode = Constants.MATERIAL_LineListDrawMode;\r\n    /**\r\n     * Returns the line loop draw mode\r\n     */\r\n    public static readonly LineLoopDrawMode = Constants.MATERIAL_LineLoopDrawMode;\r\n    /**\r\n     * Returns the line strip draw mode\r\n     */\r\n    public static readonly LineStripDrawMode = Constants.MATERIAL_LineStripDrawMode;\r\n    /**\r\n     * Returns the triangle strip draw mode\r\n     */\r\n    public static readonly TriangleStripDrawMode = Constants.MATERIAL_TriangleStripDrawMode;\r\n    /**\r\n     * Returns the triangle fan draw mode\r\n     */\r\n    public static readonly TriangleFanDrawMode = Constants.MATERIAL_TriangleFanDrawMode;\r\n\r\n    /**\r\n     * Stores the clock-wise side orientation\r\n     */\r\n    public static readonly ClockWiseSideOrientation = Constants.MATERIAL_ClockWiseSideOrientation;\r\n\r\n    /**\r\n     * Stores the counter clock-wise side orientation\r\n     */\r\n    public static readonly CounterClockWiseSideOrientation = Constants.MATERIAL_CounterClockWiseSideOrientation;\r\n\r\n    /**\r\n     * The dirty image processing flag value\r\n     */\r\n    public static readonly ImageProcessingDirtyFlag = Constants.MATERIAL_ImageProcessingDirtyFlag;\r\n\r\n    /**\r\n     * The dirty texture flag value\r\n     */\r\n    public static readonly TextureDirtyFlag = Constants.MATERIAL_TextureDirtyFlag;\r\n\r\n    /**\r\n     * The dirty light flag value\r\n     */\r\n    public static readonly LightDirtyFlag = Constants.MATERIAL_LightDirtyFlag;\r\n\r\n    /**\r\n     * The dirty fresnel flag value\r\n     */\r\n    public static readonly FresnelDirtyFlag = Constants.MATERIAL_FresnelDirtyFlag;\r\n\r\n    /**\r\n     * The dirty attribute flag value\r\n     */\r\n    public static readonly AttributesDirtyFlag = Constants.MATERIAL_AttributesDirtyFlag;\r\n\r\n    /**\r\n     * The dirty misc flag value\r\n     */\r\n    public static readonly MiscDirtyFlag = Constants.MATERIAL_MiscDirtyFlag;\r\n\r\n    /**\r\n     * The dirty prepass flag value\r\n     */\r\n    public static readonly PrePassDirtyFlag = Constants.MATERIAL_PrePassDirtyFlag;\r\n\r\n    /**\r\n     * The all dirty flag value\r\n     */\r\n    public static readonly AllDirtyFlag = Constants.MATERIAL_AllDirtyFlag;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: No transparency mode, Alpha channel is not use.\r\n     */\r\n    public static readonly MATERIAL_OPAQUE = 0;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\r\n     */\r\n    public static readonly MATERIAL_ALPHATEST = 1;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     */\r\n    public static readonly MATERIAL_ALPHABLEND = 2;\r\n\r\n    /**\r\n     * MaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\r\n     * They are also discarded below the alpha cutoff threshold to improve performances.\r\n     */\r\n    public static readonly MATERIAL_ALPHATESTANDBLEND = 3;\r\n\r\n    /**\r\n     * The Whiteout method is used to blend normals.\r\n     * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n     */\r\n    public static readonly MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;\r\n\r\n    /**\r\n     * The Reoriented Normal Mapping method is used to blend normals.\r\n     * Details of the algorithm can be found here: https://blog.selfshadow.com/publications/blending-in-detail/\r\n     */\r\n    public static readonly MATERIAL_NORMALBLENDMETHOD_RNM = 1;\r\n\r\n    /**\r\n     * PBRMaterialLightFalloff Physical: light is falling off following the inverse squared distance law.\r\n     */\r\n    public static readonly LIGHTFALLOFF_PHYSICAL = 0;\r\n\r\n    /**\r\n     * PBRMaterialLightFalloff gltf: light is falling off as described in the gltf moving to PBR document\r\n     * to enhance interoperability with other engines.\r\n     */\r\n    public static readonly LIGHTFALLOFF_GLTF = 1;\r\n\r\n    /**\r\n     * PBRMaterialLightFalloff Standard: light is falling off like in the standard material\r\n     * to enhance interoperability with other materials.\r\n     */\r\n    public static readonly LIGHTFALLOFF_STANDARD = 2;\r\n\r\n    /**\r\n     * Event observable which raises global events common to all materials (like MaterialPluginEvent.Created)\r\n     */\r\n    public static OnEventObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * If true, all materials will have their vertex output set to invariant (see the vertexOutputInvariant property).\r\n     */\r\n    public static ForceVertexOutputInvariant = false;\r\n\r\n    /**\r\n     * Custom callback helping to override the default shader used in the material.\r\n     */\r\n    public customShaderNameResolve: (\r\n        shaderName: string,\r\n        uniforms: string[],\r\n        uniformBuffers: string[],\r\n        samplers: string[],\r\n        defines: MaterialDefines | string[],\r\n        attributes?: string[],\r\n        options?: ICustomShaderNameResolveOptions\r\n    ) => string;\r\n\r\n    /**\r\n     * Custom shadow depth material to use for shadow rendering instead of the in-built one\r\n     */\r\n    public shadowDepthWrapper: Nullable<ShadowDepthWrapper> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the material is allowed (if supported) to do shader hot swapping.\r\n     * This means that the material can keep using a previous shader while a new one is being compiled.\r\n     * This is mostly used when shader parallel compilation is supported (true by default)\r\n     */\r\n    public allowShaderHotSwapping = true;\r\n\r\n    /** Shader language used by the material */\r\n    protected _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    protected _forceGLSL = false;\r\n\r\n    protected _useVertexPulling = false;\r\n    /**\r\n     * Tells the engine to draw geometry using vertex pulling instead of index drawing. This will automatically\r\n     * set the vertex buffers as storage buffers and make them accessible to the vertex shader (WebGPU only).\r\n     */\r\n    public get useVertexPulling() {\r\n        return this._useVertexPulling;\r\n    }\r\n\r\n    public set useVertexPulling(value: boolean) {\r\n        if (this._useVertexPulling === value) {\r\n            return;\r\n        }\r\n\r\n        this._useVertexPulling = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /** @internal */\r\n    public get _supportGlowLayer() {\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public set _glowModeEnabled(value: boolean) {\r\n        // Do nothing here\r\n    }\r\n\r\n    /**\r\n     * Gets the shader language used in this material.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * The ID of the material\r\n     */\r\n    @serialize()\r\n    public id: string;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the material\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /** @internal */\r\n    public _loadedUniqueId: string;\r\n\r\n    /**\r\n     * The name of the material\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets user defined metadata\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _internalMetadata: any;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    /**\r\n     * Specifies if the ready state should be checked on each call\r\n     */\r\n    @serialize()\r\n    public checkReadyOnEveryCall = false;\r\n\r\n    /**\r\n     * Specifies if the ready state should be checked once\r\n     */\r\n    @serialize()\r\n    public checkReadyOnlyOnce = false;\r\n\r\n    /**\r\n     * The state of the material\r\n     */\r\n    @serialize()\r\n    public state = \"\";\r\n\r\n    /**\r\n     * If the material can be rendered to several textures with MRT extension\r\n     */\r\n    public get canRenderToMRT(): boolean {\r\n        // By default, shaders are not compatible with MRTs\r\n        // Base classes should override that if their shader supports MRT\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The alpha value of the material\r\n     */\r\n    @serialize(\"alpha\")\r\n    protected _alpha = 1.0;\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * Sets the alpha value of the material\r\n     */\r\n    public set alpha(value: number) {\r\n        if (this._alpha === value) {\r\n            return;\r\n        }\r\n\r\n        const oldValue = this._alpha;\r\n        this._alpha = value;\r\n\r\n        // Only call dirty when there is a state change (no alpha / alpha)\r\n        if (oldValue === 1 || value === 1) {\r\n            this.markAsDirty(Material.MiscDirtyFlag + Material.PrePassDirtyFlag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the alpha value of the material\r\n     */\r\n    public get alpha(): number {\r\n        return this._alpha;\r\n    }\r\n\r\n    /**\r\n     * Specifies if back face culling is enabled\r\n     */\r\n    @serialize(\"backFaceCulling\")\r\n    protected _backFaceCulling = true;\r\n\r\n    /**\r\n     * Sets the culling state (true to enable culling, false to disable)\r\n     */\r\n    public set backFaceCulling(value: boolean) {\r\n        if (this._backFaceCulling === value) {\r\n            return;\r\n        }\r\n        this._backFaceCulling = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the culling state\r\n     */\r\n    public get backFaceCulling(): boolean {\r\n        return this._backFaceCulling;\r\n    }\r\n\r\n    /**\r\n     * Specifies if back or front faces should be culled (when culling is enabled)\r\n     */\r\n    @serialize(\"cullBackFaces\")\r\n    protected _cullBackFaces = true;\r\n\r\n    /**\r\n     * Sets the type of faces that should be culled (true for back faces, false for front faces)\r\n     */\r\n    public set cullBackFaces(value: boolean) {\r\n        if (this._cullBackFaces === value) {\r\n            return;\r\n        }\r\n        this._cullBackFaces = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the type of faces that should be culled\r\n     */\r\n    public get cullBackFaces(): boolean {\r\n        return this._cullBackFaces;\r\n    }\r\n\r\n    private _blockDirtyMechanism = false;\r\n\r\n    /**\r\n     * Block the dirty-mechanism for this specific material\r\n     * When set to false after being true the material will be marked as dirty.\r\n     */\r\n    public get blockDirtyMechanism(): boolean {\r\n        return this._blockDirtyMechanism;\r\n    }\r\n\r\n    public set blockDirtyMechanism(value: boolean) {\r\n        if (this._blockDirtyMechanism === value) {\r\n            return;\r\n        }\r\n\r\n        this._blockDirtyMechanism = value;\r\n\r\n        if (!value) {\r\n            this.markDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This allows you to modify the material without marking it as dirty after every change.\r\n     * This function should be used if you need to make more than one dirty-enabling change to the material - adding a texture, setting a new fill mode and so on.\r\n     * The callback will pass the material as an argument, so you can make your changes to it.\r\n     * @param callback the callback to be executed that will update the material\r\n     */\r\n    public atomicMaterialsUpdate(callback: (material: this) => void): void {\r\n        this.blockDirtyMechanism = true;\r\n        try {\r\n            callback(this);\r\n        } finally {\r\n            this.blockDirtyMechanism = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stores the value for side orientation\r\n     */\r\n    @serialize()\r\n    public sideOrientation: Nullable<number> = null;\r\n\r\n    /**\r\n     * Callback triggered when the material is compiled\r\n     */\r\n    public onCompiled: Nullable<(effect: Effect) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\r\n    public onError: Nullable<(effect: Effect, errors: string) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered to get the render target textures\r\n     */\r\n    public getRenderTargetTextures: Nullable<() => SmartArray<RenderTargetTexture>> = null;\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        this._eventInfo.hasRenderTargetTextures = false;\r\n        this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\r\n        return this._eventInfo.hasRenderTargetTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material should be serialized\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _storeEffectOnSubMeshes = false;\r\n\r\n    /**\r\n     * Stores the animations for the material\r\n     */\r\n    public animations: Nullable<Array<Animation>> = null;\r\n\r\n    /**\r\n     * An event triggered when the material is disposed\r\n     */\r\n    public onDisposeObservable = new Observable<Material>();\r\n\r\n    /**\r\n     * An observer which watches for dispose events\r\n     */\r\n    private _onDisposeObserver: Nullable<Observer<Material>> = null;\r\n    private _onUnBindObservable: Nullable<Observable<Material>> = null;\r\n\r\n    /**\r\n     * Called during a dispose event\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    private _onBindObservable: Nullable<Observable<AbstractMesh>>;\r\n\r\n    /**\r\n     * An event triggered when the material is bound\r\n     */\r\n    public get onBindObservable(): Observable<AbstractMesh> {\r\n        if (!this._onBindObservable) {\r\n            this._onBindObservable = new Observable<AbstractMesh>();\r\n        }\r\n\r\n        return this._onBindObservable;\r\n    }\r\n\r\n    /**\r\n     * An observer which watches for bind events\r\n     */\r\n    private _onBindObserver: Nullable<Observer<AbstractMesh>> = null;\r\n\r\n    /**\r\n     * Called during a bind event\r\n     */\r\n    public set onBind(callback: (Mesh: AbstractMesh) => void) {\r\n        if (this._onBindObserver) {\r\n            this.onBindObservable.remove(this._onBindObserver);\r\n        }\r\n        this._onBindObserver = this.onBindObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the material is unbound\r\n     */\r\n    public get onUnBindObservable(): Observable<Material> {\r\n        if (!this._onUnBindObservable) {\r\n            this._onUnBindObservable = new Observable<Material>();\r\n        }\r\n\r\n        return this._onUnBindObservable;\r\n    }\r\n\r\n    protected _onEffectCreatedObservable: Nullable<Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }>>;\r\n\r\n    /**\r\n     * An event triggered when the effect is (re)created\r\n     */\r\n    public get onEffectCreatedObservable(): Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }> {\r\n        if (!this._onEffectCreatedObservable) {\r\n            this._onEffectCreatedObservable = new Observable<{ effect: Effect; subMesh: Nullable<SubMesh> }>();\r\n        }\r\n\r\n        return this._onEffectCreatedObservable;\r\n    }\r\n\r\n    /**\r\n     * Stores the value of the alpha mode\r\n     */\r\n    @serialize()\r\n    private _alphaMode: number[] = [Constants.ALPHA_COMBINE];\r\n\r\n    /**\r\n     * Sets the value of the alpha mode.\r\n     *\r\n     * | Value | Type | Description |\r\n     * | --- | --- | --- |\r\n     * | 0 | ALPHA_DISABLE |  |\r\n     * | 1 | ALPHA_ADD | Defines that alpha blending is COLOR=SRC_ALPHA * SRC + DEST, ALPHA=DEST_ALPHA |\r\n     * | 2 | ALPHA_COMBINE | Defines that alpha blending is COLOR=SRC_ALPHA * SRC + (1 - SRC_ALPHA) * DEST, ALPHA=SRC_ALPHA + DEST_ALPHA |\r\n     * | 3 | ALPHA_SUBTRACT | Defines that alpha blending is COLOR=(1 - SRC) * DEST, ALPHA=SRC_ALPHA + DEST_ALPHA |\r\n     * | 4 | ALPHA_MULTIPLY | Defines that alpha blending is COLOR=DEST * SRC, ALPHA=SRC_ALPHA + DEST_ALPHA |\r\n     * | 5 | ALPHA_MAXIMIZED | Defines that alpha blending is COLOR=SRC_ALPHA * SRC + (1 - SRC) * DEST, ALPHA=SRC_ALPHA + DEST_ALPHA |\r\n     * | 6 | ALPHA_ONEONE | Defines that alpha blending is COLOR=SRC + DEST, ALPHA=DEST_ALPHA |\r\n     * | 7 | ALPHA_PREMULTIPLIED | Defines that alpha blending is COLOR=SRC + (1 - SRC_ALPHA) * DEST, ALPHA=SRC_ALPHA + DEST_ALPHA |\r\n     * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF | Defines that alpha blending is COLOR=SRC + (1 - SRC_ALPHA) * DEST, ALPHA=SRC_ALPHA + (1 - SRC_ALPHA) * DEST_ALPHA |\r\n     * | 9 | ALPHA_INTERPOLATE | Defines that alpha blending is COLOR=CST * SRC + (1 - CST) * DEST, ALPHA=CST_ALPHA * SRC + (1 - CST_ALPHA) * DEST_ALPHA |\r\n     * | 10 | ALPHA_SCREENMODE | Defines that alpha blending is COLOR=SRC + (1 - SRC) * DEST, ALPHA=SRC_ALPHA + (1 - SRC_ALPHA) * DEST_ALPHA |\r\n     * | 11 | ALPHA_ONEONE_ONEONE | Defines that alpha blending is COLOR=SRC + DST, ALPHA=SRC_ALPHA + DEST_ALPHA |\r\n     * | 12 | ALPHA_ALPHATOCOLOR | Defines that alpha blending is COLOR=DEST_ALPHA * SRC + DST, ALPHA=0 |\r\n     * | 13 | ALPHA_REVERSEONEMINUS | Defines that alpha blending is COLOR=(1 - DEST) * SRC + (1 - SRC) * DEST, ALPHA=(1 - DEST_ALPHA) * SRC_ALPHA + (1 - SRC_ALPHA) * DEST_ALPHA |\r\n     * | 14 | ALPHA_SRC_DSTONEMINUSSRCALPHA | Defines that alpha blending is ALPHA=SRC + (1 - SRC ALPHA) * DEST, ALPHA=SRC_ALPHA + (1 - SRC ALPHA) * DEST_ALPHA |\r\n     * | 15 | ALPHA_ONEONE_ONEZERO | Defines that alpha blending is COLOR=SRC + DST, ALPHA=SRC_ALPHA |\r\n     * | 16 | ALPHA_EXCLUSION | Defines that alpha blending is COLOR=(1 - DEST) * SRC + (1 - SRC) * DEST, ALPHA=DEST_ALPHA |\r\n     * | 17 | ALPHA_LAYER_ACCUMULATE | Defines that alpha blending is COLOR=SRC_ALPHA * SRC + (1 - SRC ALPHA) * DEST, ALPHA=SRC_ALPHA + (1 - SRC_ALPHA) * DEST_ALPHA |\r\n     * | 18 | ALPHA_MIN | Defines that alpha blending is COLOR=MIN(SRC, DEST), ALPHA=MIN(SRC_ALPHA, DEST_ALPHA) |\r\n     * | 19 | ALPHA_MAX | Defines that alpha blending is COLOR=MAX(SRC, DEST), ALPHA=MAX(SRC_ALPHA, DEST_ALPHA) |\r\n     * | 20 | ALPHA_DUAL_SRC0_ADD_SRC1xDST | Defines that alpha blending uses dual source blending and is COLOR=SRC + SRC1 * DEST, ALPHA=DST_ALPHA |\r\n     *\r\n     */\r\n    public set alphaMode(value: number) {\r\n        if (this._alphaMode[0] === value) {\r\n            return;\r\n        }\r\n        this._alphaMode[0] = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the alpha mode\r\n     */\r\n    public get alphaMode(): number {\r\n        return this._alphaMode[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the list of alpha modes (length greater than 1 for multi-targets)\r\n     */\r\n    public get alphaModes(): Immutable<number[]> {\r\n        return this._alphaMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the alpha mode for a specific target index.\r\n     * @param value The alpha mode value to set.\r\n     * @param targetIndex The index of the target to set the alpha mode for. Defaults to 0.\r\n     */\r\n    public setAlphaMode(value: number, targetIndex: number = 0): void {\r\n        if (this._alphaMode[targetIndex] === value) {\r\n            return;\r\n        }\r\n        this._alphaMode[targetIndex] = value;\r\n        this.markAsDirty(Material.TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Stores the state of the need depth pre-pass value\r\n     */\r\n    @serialize()\r\n    private _needDepthPrePass = false;\r\n\r\n    /**\r\n     * Sets the need depth pre-pass value\r\n     */\r\n    public set needDepthPrePass(value: boolean) {\r\n        if (this._needDepthPrePass === value) {\r\n            return;\r\n        }\r\n        this._needDepthPrePass = value;\r\n        if (this._needDepthPrePass) {\r\n            this.checkReadyOnEveryCall = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the depth pre-pass value\r\n     */\r\n    public get needDepthPrePass(): boolean {\r\n        return this._needDepthPrePass;\r\n    }\r\n\r\n    /**\r\n     * Can this material render to prepass\r\n     */\r\n    public get isPrePassCapable(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if depth writing should be disabled\r\n     */\r\n    @serialize()\r\n    public disableDepthWrite = false;\r\n\r\n    /**\r\n     * Specifies if color writing should be disabled\r\n     */\r\n    @serialize()\r\n    public disableColorWrite = false;\r\n\r\n    /**\r\n     * Specifies if depth writing should be forced\r\n     */\r\n    @serialize()\r\n    public forceDepthWrite = false;\r\n\r\n    /**\r\n     * Specifies the depth function that should be used. 0 means the default engine function\r\n     */\r\n    @serialize()\r\n    public depthFunction = 0;\r\n\r\n    /**\r\n     * Specifies if there should be a separate pass for culling\r\n     */\r\n    @serialize()\r\n    public separateCullingPass = false;\r\n\r\n    /**\r\n     * Stores the state specifying if fog should be enabled\r\n     */\r\n    @serialize(\"fogEnabled\")\r\n    private _fogEnabled = true;\r\n\r\n    /**\r\n     * Sets the state for enabling fog\r\n     */\r\n    public set fogEnabled(value: boolean) {\r\n        if (this._fogEnabled === value) {\r\n            return;\r\n        }\r\n        this._fogEnabled = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the fog enabled state\r\n     */\r\n    public get fogEnabled(): boolean {\r\n        return this._fogEnabled;\r\n    }\r\n\r\n    /**\r\n     * Stores the size of points\r\n     */\r\n    @serialize()\r\n    public pointSize = 1.0;\r\n\r\n    /**\r\n     * Stores the z offset Factor value\r\n     */\r\n    @serialize()\r\n    public zOffset = 0;\r\n\r\n    /**\r\n     * Stores the z offset Units value\r\n     */\r\n    @serialize()\r\n    public zOffsetUnits = 0;\r\n\r\n    public get wireframe(): boolean {\r\n        switch (this._fillMode) {\r\n            case Material.WireFrameFillMode:\r\n            case Material.LineListDrawMode:\r\n            case Material.LineLoopDrawMode:\r\n            case Material.LineStripDrawMode:\r\n                return true;\r\n        }\r\n\r\n        return this._scene.forceWireframe;\r\n    }\r\n\r\n    /**\r\n     * Sets the state of wireframe mode\r\n     */\r\n    public set wireframe(value: boolean) {\r\n        this.fillMode = value ? Material.WireFrameFillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the value specifying if point clouds are enabled\r\n     */\r\n    @serialize()\r\n    public get pointsCloud(): boolean {\r\n        switch (this._fillMode) {\r\n            case Material.PointFillMode:\r\n            case Material.PointListDrawMode:\r\n                return true;\r\n        }\r\n\r\n        return this._scene.forcePointsCloud;\r\n    }\r\n\r\n    /**\r\n     * Sets the state of point cloud mode\r\n     */\r\n    public set pointsCloud(value: boolean) {\r\n        this.fillMode = value ? Material.PointFillMode : Material.TriangleFillMode;\r\n    }\r\n\r\n    /**\r\n     * Gets the material fill mode\r\n     */\r\n    @serialize()\r\n    public get fillMode(): number {\r\n        return this._fillMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the material fill mode\r\n     */\r\n    public set fillMode(value: number) {\r\n        if (this._fillMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._fillMode = value;\r\n        this.markAsDirty(Material.MiscDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 1\r\n     */\r\n    public clipPlane: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 2\r\n     */\r\n    public clipPlane2: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 3\r\n     */\r\n    public clipPlane3: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 4\r\n     */\r\n    public clipPlane4: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 5\r\n     */\r\n    public clipPlane5: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gets or sets the active clipplane 6\r\n     */\r\n    public clipPlane6: Nullable<Plane>;\r\n\r\n    /**\r\n     * Gives access to the stencil properties of the material\r\n     */\r\n    public readonly stencil = new MaterialStencilState();\r\n\r\n    protected _useLogarithmicDepth: boolean;\r\n\r\n    /**\r\n     * In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)\r\n     * You can try switching to logarithmic depth.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/logarithmicDepthBuffer\r\n     */\r\n    @serialize()\r\n    public get useLogarithmicDepth(): boolean {\r\n        return this._useLogarithmicDepth;\r\n    }\r\n\r\n    public set useLogarithmicDepth(value: boolean) {\r\n        const fragmentDepthSupported = this.getScene().getEngine().getCaps().fragmentDepthSupported;\r\n\r\n        if (value && !fragmentDepthSupported) {\r\n            Logger.Warn(\"Logarithmic depth has been requested for a material on a device that doesn't support it.\");\r\n        }\r\n\r\n        this._useLogarithmicDepth = value && fragmentDepthSupported;\r\n\r\n        this._markAllSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    @serialize()\r\n    protected _isVertexOutputInvariant = Material.ForceVertexOutputInvariant;\r\n    /**\r\n     * Gets or sets the vertex output invariant state\r\n     * Setting this property to true will force the shader compiler to disable some optimization to make sure the vertex output is always calculated\r\n     * the same way across different compilation units.\r\n     * You may need to enable this option if you are seeing some depth artifacts when using a depth pre-pass, for e.g.\r\n     * Note that this may have an impact on performance, so leave this option disabled if not needed.\r\n     */\r\n    public get isVertexOutputInvariant(): boolean {\r\n        return this._isVertexOutputInvariant;\r\n    }\r\n\r\n    public set isVertexOutputInvariant(value: boolean) {\r\n        if (this._isVertexOutputInvariant === value) {\r\n            return;\r\n        }\r\n\r\n        this._isVertexOutputInvariant = value;\r\n        this._markAllSubMeshesAsMiscDirty();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Stores the effects for the material\r\n     */\r\n    public _materialContext: IMaterialContext | undefined;\r\n\r\n    protected _drawWrapper: DrawWrapper;\r\n    /** @internal */\r\n    public _getDrawWrapper(): DrawWrapper {\r\n        return this._drawWrapper;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setDrawWrapper(drawWrapper: DrawWrapper) {\r\n        this._drawWrapper = drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * Specifies if uniform buffers should be used\r\n     */\r\n    private _useUBO: boolean = false;\r\n\r\n    /**\r\n     * Stores a reference to the scene\r\n     */\r\n    private _scene: Scene;\r\n    protected _needToBindSceneUbo: boolean;\r\n\r\n    /**\r\n     * Stores the fill mode state\r\n     */\r\n    private _fillMode = Material.TriangleFillMode;\r\n\r\n    /**\r\n     * Specifies if the depth write state should be cached\r\n     */\r\n    private _cachedDepthWriteState: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the color write state should be cached\r\n     */\r\n    private _cachedColorWriteState: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the depth function state should be cached\r\n     */\r\n    private _cachedDepthFunctionState: number = 0;\r\n\r\n    /**\r\n     * Stores the uniform buffer\r\n     * @internal\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @internal */\r\n    public _indexInSceneMaterialArray = -1;\r\n\r\n    /** @internal */\r\n    public meshMap: Nullable<{ [id: string]: AbstractMesh | undefined }> = null;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    /** @internal */\r\n    public _dirtyCallbacks: { [code: number]: () => void };\r\n\r\n    /** @internal */\r\n    public _uniformBufferLayoutBuilt = false;\r\n\r\n    protected _eventInfo: MaterialPluginCreated &\r\n        MaterialPluginDisposed &\r\n        MaterialPluginHasTexture &\r\n        MaterialPluginIsReadyForSubMesh &\r\n        MaterialPluginGetDefineNames &\r\n        MaterialPluginPrepareEffect &\r\n        MaterialPluginPrepareDefines &\r\n        MaterialPluginPrepareUniformBuffer &\r\n        MaterialPluginBindForSubMesh &\r\n        MaterialPluginGetAnimatables &\r\n        MaterialPluginGetActiveTextures &\r\n        MaterialPluginFillRenderTargetTextures &\r\n        MaterialPluginHasRenderTargetTextures &\r\n        MaterialPluginHardBindForSubMesh = {} as any; // will be initialized before each event notification\r\n\r\n    /** @internal */\r\n    public _callbackPluginEventGeneric: (\r\n        id: number,\r\n        info:\r\n            | MaterialPluginGetActiveTextures\r\n            | MaterialPluginGetAnimatables\r\n            | MaterialPluginHasTexture\r\n            | MaterialPluginDisposed\r\n            | MaterialPluginGetDefineNames\r\n            | MaterialPluginPrepareEffect\r\n            | MaterialPluginPrepareUniformBuffer\r\n    ) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventIsReadyForSubMesh: (eventData: MaterialPluginIsReadyForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventPrepareDefines: (eventData: MaterialPluginPrepareDefines) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventPrepareDefinesBeforeAttributes: (eventData: MaterialPluginPrepareDefines) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventHardBindForSubMesh: (eventData: MaterialPluginHardBindForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventBindForSubMesh: (eventData: MaterialPluginBindForSubMesh) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventHasRenderTargetTextures: (eventData: MaterialPluginHasRenderTargetTextures) => void = () => void 0;\r\n    /** @internal */\r\n    public _callbackPluginEventFillRenderTargetTextures: (eventData: MaterialPluginFillRenderTargetTextures) => void = () => void 0;\r\n\r\n    /**\r\n     * Creates a material instance\r\n     * @param name defines the name of the material\r\n     * @param scene defines the scene to reference\r\n     * @param doNotAdd specifies if the material should be added to the scene\r\n     * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false\r\n     */\r\n    constructor(name: string, scene?: Nullable<Scene>, doNotAdd?: boolean, forceGLSL = false) {\r\n        this.name = name;\r\n        const setScene = scene || EngineStore.LastCreatedScene;\r\n        if (!setScene) {\r\n            return;\r\n        }\r\n        this._scene = setScene;\r\n        this._dirtyCallbacks = {};\r\n        this._forceGLSL = forceGLSL;\r\n\r\n        this._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag] = this._markAllSubMeshesAsTexturesDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_LightDirtyFlag] = this._markAllSubMeshesAsLightsDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_FresnelDirtyFlag] = this._markAllSubMeshesAsFresnelDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_AttributesDirtyFlag] = this._markAllSubMeshesAsAttributesDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_MiscDirtyFlag] = this._markAllSubMeshesAsMiscDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_PrePassDirtyFlag] = this._markAllSubMeshesAsPrePassDirty.bind(this);\r\n        this._dirtyCallbacks[Constants.MATERIAL_AllDirtyFlag] = this._markAllSubMeshesAsAllDirty.bind(this);\r\n\r\n        this.id = name || Tools.RandomId();\r\n        this.uniqueId = this._scene.getUniqueId();\r\n        this._materialContext = this._scene.getEngine().createMaterialContext();\r\n        this._drawWrapper = new DrawWrapper(this._scene.getEngine(), false);\r\n        this._drawWrapper.materialContext = this._materialContext;\r\n\r\n        this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), undefined, undefined, name);\r\n        this._useUBO = this.getScene().getEngine().supportsUniformBuffers;\r\n\r\n        this._createUniformBuffer();\r\n\r\n        if (!doNotAdd) {\r\n            this._scene.addMaterial(this);\r\n        }\r\n\r\n        if (this._scene.useMaterialMeshMap) {\r\n            this.meshMap = {};\r\n        }\r\n\r\n        Material.OnEventObservable.notifyObservers(this, MaterialPluginEvent.Created);\r\n    }\r\n\r\n    /** @internal */\r\n    public _createUniformBuffer() {\r\n        const engine = this.getScene().getEngine();\r\n\r\n        this._uniformBuffer?.dispose();\r\n\r\n        if (engine.isWebGPU && !this._forceGLSL) {\r\n            // Switch main UBO to non UBO to connect to leftovers UBO in webgpu\r\n            this._uniformBuffer = new UniformBuffer(engine, undefined, undefined, this.name, true);\r\n            this._shaderLanguage = ShaderLanguage.WGSL;\r\n        } else {\r\n            this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), undefined, undefined, this.name);\r\n        }\r\n\r\n        this._uniformBufferLayoutBuilt = false;\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the current material\r\n     * @param fullDetails defines a boolean indicating which levels of logging is desired\r\n     * @returns a string with material information\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public toString(fullDetails?: boolean): string {\r\n        const ret = \"Name: \" + this.name;\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the material\r\n     * @returns a string with the class name of the material\r\n     */\r\n    public getClassName(): string {\r\n        return \"Material\";\r\n    }\r\n\r\n    /** @internal */\r\n    public get _isMaterial() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies if updates for the material been locked\r\n     */\r\n    public get isFrozen(): boolean {\r\n        return this.checkReadyOnlyOnce;\r\n    }\r\n\r\n    /**\r\n     * Locks updates for the material\r\n     */\r\n    public freeze(): void {\r\n        this.markDirty();\r\n        this.checkReadyOnlyOnce = true;\r\n    }\r\n\r\n    /**\r\n     * Unlocks updates for the material\r\n     */\r\n    public unfreeze(): void {\r\n        this.markDirty();\r\n        this.checkReadyOnlyOnce = false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param useInstances specifies if instances should be used\r\n     * @returns a boolean indicating if the material is ready to be used\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        const defines = subMesh.materialDefines;\r\n        if (!defines) {\r\n            return false;\r\n        }\r\n\r\n        this._eventInfo.isReadyForSubMesh = true;\r\n        this._eventInfo.defines = defines;\r\n        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\r\n\r\n        return this._eventInfo.isReadyForSubMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the material effect\r\n     * @returns the effect associated with the material\r\n     */\r\n    public getEffect(): Nullable<Effect> {\r\n        return this._drawWrapper.effect;\r\n    }\r\n\r\n    /**\r\n     * Returns the current scene\r\n     * @returns a Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getEffectiveOrientation(mesh: Mesh): number {\r\n        return this.sideOrientation !== null ? this.sideOrientation : mesh.sideOrientation;\r\n    }\r\n\r\n    /**\r\n     * The transparency mode of the material.\r\n     */\r\n    protected _transparencyMode: Nullable<number> = null;\r\n\r\n    /**\r\n     * Gets the current transparency mode.\r\n     */\r\n    @serialize()\r\n    public get transparencyMode(): Nullable<number> {\r\n        return this._transparencyMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the transparency mode of the material.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | OPAQUE                              |             |\r\n     * | 1     | ALPHATEST                           |             |\r\n     * | 2     | ALPHABLEND                          |             |\r\n     * | 3     | ALPHATESTANDBLEND                   |             |\r\n     *\r\n     */\r\n    public set transparencyMode(value: Nullable<number>) {\r\n        if (this._transparencyMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._transparencyMode = value;\r\n\r\n        this._markAllSubMeshesAsTexturesAndMiscDirty();\r\n    }\r\n\r\n    protected get _hasTransparencyMode(): boolean {\r\n        return this._transparencyMode != null;\r\n    }\r\n\r\n    protected get _transparencyModeIsBlend(): boolean {\r\n        return this._transparencyMode === Material.MATERIAL_ALPHABLEND || this._transparencyMode === Material.MATERIAL_ALPHATESTANDBLEND;\r\n    }\r\n\r\n    protected get _transparencyModeIsTest(): boolean {\r\n        return this._transparencyMode === Material.MATERIAL_ALPHATEST || this._transparencyMode === Material.MATERIAL_ALPHATESTANDBLEND;\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    protected get _disableAlphaBlending(): boolean {\r\n        return this._transparencyMode === Material.MATERIAL_OPAQUE || this._transparencyMode === Material.MATERIAL_ALPHATEST;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha blend mode.\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     * @deprecated Please use needAlphaBlendingForMesh instead\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsBlend;\r\n        }\r\n\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return this.alpha < 1.0;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the mesh will require alpha blending\r\n     * @param mesh defines the mesh to check\r\n     * @returns a boolean specifying if alpha blending is needed for the mesh\r\n     */\r\n    public needAlphaBlendingForMesh(mesh: AbstractMesh): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsBlend;\r\n        }\r\n\r\n        if (mesh.visibility < 1.0) {\r\n            return true;\r\n        }\r\n\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return mesh.hasVertexAlpha || this.needAlphaBlending();\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha test mode.\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     * @deprecated Please use needAlphaTestingForMesh instead\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsTest;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies if material alpha testing should be turned on for the mesh\r\n     * @param mesh defines the mesh to check\r\n     * @returns a boolean specifying if alpha testing should be turned on for the mesh\r\n     */\r\n    public needAlphaTestingForMesh(mesh: AbstractMesh): boolean {\r\n        if (this._hasTransparencyMode) {\r\n            return this._transparencyModeIsTest;\r\n        }\r\n\r\n        return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();\r\n    }\r\n\r\n    /**\r\n     * Gets the texture used for the alpha test\r\n     * @returns the texture to use for alpha testing\r\n     */\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that it needs to be re-calculated\r\n     * @param forceMaterialDirty - Forces the material to be marked as dirty for all components (same as this.markAsDirty(Material.AllDirtyFlag)). You should use this flag if the material is frozen and you want to force a recompilation.\r\n     */\r\n    public markDirty(forceMaterialDirty = false): void {\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                for (const drawWrapper of subMesh._drawWrappers) {\r\n                    if (!drawWrapper) {\r\n                        continue;\r\n                    }\r\n                    if (this._materialContext === drawWrapper.materialContext) {\r\n                        drawWrapper._wasPreviouslyReady = false;\r\n                        drawWrapper._wasPreviouslyUsingInstances = null;\r\n                        drawWrapper._forceRebindOnNextCall = forceMaterialDirty;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (forceMaterialDirty) {\r\n            this.markAsDirty(Material.AllDirtyFlag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preBind(effect?: Effect | DrawWrapper, overrideOrientation: Nullable<number> = null): boolean {\r\n        const engine = this._scene.getEngine();\r\n\r\n        const orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;\r\n        const reverse = orientation === Material.ClockWiseSideOrientation;\r\n\r\n        const effectiveDrawWrapper = effect ? effect : this._getDrawWrapper();\r\n\r\n        if (IsWrapper(effectiveDrawWrapper) && effectiveDrawWrapper.materialContext) {\r\n            effectiveDrawWrapper.materialContext.useVertexPulling = this.useVertexPulling;\r\n        }\r\n\r\n        engine.enableEffect(effectiveDrawWrapper);\r\n        engine.setState(\r\n            this.backFaceCulling,\r\n            this.zOffset,\r\n            false,\r\n            reverse,\r\n            this._scene._mirroredCameraPosition ? !this.cullBackFaces : this.cullBackFaces,\r\n            this.stencil,\r\n            this.zOffsetUnits\r\n        );\r\n\r\n        return reverse;\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bind(world: Matrix, mesh?: Mesh): void {}\r\n\r\n    /**\r\n     * Initializes the uniform buffer layout for the shader.\r\n     */\r\n    public buildUniformLayout(): void {\r\n        const ubo = this._uniformBuffer;\r\n\r\n        this._eventInfo.ubo = ubo;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareUniformBuffer, this._eventInfo);\r\n\r\n        ubo.create();\r\n\r\n        this._uniformBufferLayoutBuilt = true;\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventBindForSubMesh(this._eventInfo);\r\n        drawWrapper._forceRebindOnNextCall = false;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bindOnlyWorldMatrix(world: Matrix): void {}\r\n\r\n    /**\r\n     * Binds the view matrix to the effect\r\n     * @param effect defines the effect to bind the view matrix to\r\n     */\r\n    public bindView(effect: Effect): void {\r\n        if (!this._useUBO) {\r\n            effect.setMatrix(\"view\", this.getScene().getViewMatrix());\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the view projection and projection matrices to the effect\r\n     * @param effect defines the effect to bind the view projection and projection matrices to\r\n     */\r\n    public bindViewProjection(effect: Effect): void {\r\n        if (!this._useUBO) {\r\n            effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\r\n            effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the view matrix to the effect\r\n     * @param effect defines the effect to bind the view matrix to\r\n     * @param variableName name of the shader variable that will hold the eye position\r\n     */\r\n    public bindEyePosition(effect: Effect, variableName?: string): void {\r\n        if (!this._useUBO) {\r\n            this._scene.bindEyePosition(effect, variableName);\r\n        } else {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes to execute after binding the material to a mesh\r\n     * @param mesh defines the rendered mesh\r\n     * @param effect defines the effect used to bind the material\r\n     * @param _subMesh defines the subMesh that the material has been bound for\r\n     */\r\n    protected _afterBind(mesh?: AbstractMesh, effect: Nullable<Effect> = null, _subMesh?: SubMesh): void {\r\n        this._scene._cachedMaterial = this;\r\n        if (this._needToBindSceneUbo) {\r\n            if (effect) {\r\n                this._needToBindSceneUbo = false;\r\n                BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\r\n                this._scene.finalizeSceneUbo();\r\n            }\r\n        }\r\n        if (mesh) {\r\n            this._scene._cachedVisibility = mesh.visibility;\r\n        } else {\r\n            this._scene._cachedVisibility = 1;\r\n        }\r\n\r\n        if (this._onBindObservable && mesh) {\r\n            this._onBindObservable.notifyObservers(mesh);\r\n        }\r\n\r\n        if (this.disableDepthWrite) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedDepthWriteState = engine.getDepthWrite();\r\n            engine.setDepthWrite(false);\r\n        }\r\n\r\n        if (this.disableColorWrite) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedColorWriteState = engine.getColorWrite();\r\n            engine.setColorWrite(false);\r\n        }\r\n\r\n        if (this.depthFunction !== 0) {\r\n            const engine = this._scene.getEngine();\r\n            this._cachedDepthFunctionState = engine.getDepthFunction() || 0;\r\n            engine.setDepthFunction(this.depthFunction);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unbinds the material from the mesh\r\n     */\r\n    public unbind(): void {\r\n        this._scene.getSceneUniformBuffer().unbindEffect();\r\n\r\n        if (this._onUnBindObservable) {\r\n            this._onUnBindObservable.notifyObservers(this);\r\n        }\r\n\r\n        if (this.depthFunction !== 0) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setDepthFunction(this._cachedDepthFunctionState);\r\n        }\r\n\r\n        if (this.disableDepthWrite) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setDepthWrite(this._cachedDepthWriteState);\r\n        }\r\n\r\n        if (this.disableColorWrite) {\r\n            const engine = this._scene.getEngine();\r\n            engine.setColorWrite(this._cachedColorWriteState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @returns - Array of animatable textures.\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        this._eventInfo.animatables = [];\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetAnimatables, this._eventInfo);\r\n        return this._eventInfo.animatables;\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        this._eventInfo.activeTextures = [];\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetActiveTextures, this._eventInfo);\r\n        return this._eventInfo.activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        this._eventInfo.hasTexture = false;\r\n        this._eventInfo.texture = texture;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.HasTexture, this._eventInfo);\r\n        return this._eventInfo.hasTexture;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public clone(name: string): Nullable<Material> {\r\n        return null;\r\n    }\r\n\r\n    protected _clonePlugins(targetMaterial: Material, rootUrl: string) {\r\n        const serializationObject: any = {};\r\n\r\n        // Create plugins in targetMaterial in case they don't exist\r\n        this._serializePlugins(serializationObject);\r\n\r\n        Material._ParsePlugins(serializationObject, targetMaterial, this._scene, rootUrl);\r\n\r\n        // Copy the properties of the current plugins to the cloned material's plugins\r\n        if (this.pluginManager) {\r\n            for (const plugin of this.pluginManager._plugins) {\r\n                const targetPlugin = targetMaterial.pluginManager!.getPlugin(plugin.name);\r\n                if (targetPlugin) {\r\n                    plugin.copyTo(targetPlugin);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the meshes bound to the material\r\n     * @returns an array of meshes bound to the material\r\n     */\r\n    public getBindedMeshes(): AbstractMesh[] {\r\n        if (this.meshMap) {\r\n            const result: AbstractMesh[] = [];\r\n            for (const meshId in this.meshMap) {\r\n                const mesh = this.meshMap[meshId];\r\n                if (mesh) {\r\n                    result.push(mesh);\r\n                }\r\n            }\r\n            return result;\r\n        } else {\r\n            const meshes = this._scene.meshes;\r\n            return meshes.filter((mesh) => mesh.material === this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh defines the mesh associated with this material\r\n     * @param onCompiled defines a function to execute once the material is compiled\r\n     * @param options defines the options to configure the compilation\r\n     * @param onError defines a function to execute if the material fails compiling\r\n     */\r\n    public forceCompilation(\r\n        mesh: AbstractMesh,\r\n        onCompiled?: (material: Material) => void,\r\n        options?: Partial<IMaterialCompilationOptions>,\r\n        onError?: (reason: string) => void\r\n    ): void {\r\n        const localOptions = {\r\n            clipPlane: false,\r\n            useInstances: false,\r\n            ...options,\r\n        };\r\n\r\n        const scene = this.getScene();\r\n        const currentHotSwapingState = this.allowShaderHotSwapping;\r\n        this.allowShaderHotSwapping = false; // Turned off to let us evaluate the real compilation state\r\n\r\n        const checkReady = () => {\r\n            if (!this._scene || !this._scene.getEngine()) {\r\n                return;\r\n            }\r\n\r\n            const clipPlaneState = scene.clipPlane;\r\n\r\n            if (localOptions.clipPlane) {\r\n                scene.clipPlane = new Plane(0, 0, 0, 1);\r\n            }\r\n\r\n            if (this._storeEffectOnSubMeshes) {\r\n                let allDone = true,\r\n                    lastError = null;\r\n                if (mesh.subMeshes) {\r\n                    const tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, undefined, false, false);\r\n                    if (tempSubMesh.materialDefines) {\r\n                        tempSubMesh.materialDefines._renderId = -1;\r\n                    }\r\n                    if (!this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {\r\n                        if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {\r\n                            lastError = tempSubMesh.effect.getCompilationError();\r\n                        } else {\r\n                            allDone = false;\r\n                            setTimeout(checkReady, 16);\r\n                        }\r\n                    }\r\n                }\r\n                if (allDone) {\r\n                    this.allowShaderHotSwapping = currentHotSwapingState;\r\n                    if (lastError) {\r\n                        if (onError) {\r\n                            onError(lastError);\r\n                        }\r\n                    }\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                }\r\n            } else {\r\n                if (this.isReady()) {\r\n                    this.allowShaderHotSwapping = currentHotSwapingState;\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                } else {\r\n                    setTimeout(checkReady, 16);\r\n                }\r\n            }\r\n\r\n            if (localOptions.clipPlane) {\r\n                scene.clipPlane = clipPlaneState;\r\n            }\r\n        };\r\n\r\n        checkReady();\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh defines the mesh that will use this material\r\n     * @param options defines additional options for compiling the shaders\r\n     * @returns a promise that resolves when the compilation completes\r\n     */\r\n    public async forceCompilationAsync(mesh: AbstractMesh, options?: Partial<IMaterialCompilationOptions>): Promise<void> {\r\n        return await new Promise((resolve, reject) => {\r\n            this.forceCompilation(\r\n                mesh,\r\n                () => {\r\n                    resolve();\r\n                },\r\n                options,\r\n                (reason) => {\r\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                    reject(reason);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    private static readonly _AllDirtyCallBack = (defines: MaterialDefines) => defines.markAllAsDirty();\r\n    private static readonly _ImageProcessingDirtyCallBack = (defines: MaterialDefines) => defines.markAsImageProcessingDirty();\r\n    private static readonly _TextureDirtyCallBack = (defines: MaterialDefines) => defines.markAsTexturesDirty();\r\n    private static readonly _FresnelDirtyCallBack = (defines: MaterialDefines) => defines.markAsFresnelDirty();\r\n    private static readonly _MiscDirtyCallBack = (defines: MaterialDefines) => defines.markAsMiscDirty();\r\n    private static readonly _PrePassDirtyCallBack = (defines: MaterialDefines) => defines.markAsPrePassDirty();\r\n    private static readonly _LightsDirtyCallBack = (defines: MaterialDefines) => defines.markAsLightDirty();\r\n    private static readonly _AttributeDirtyCallBack = (defines: MaterialDefines) => defines.markAsAttributesDirty();\r\n\r\n    private static _FresnelAndMiscDirtyCallBack = (defines: MaterialDefines) => {\r\n        Material._FresnelDirtyCallBack(defines);\r\n        Material._MiscDirtyCallBack(defines);\r\n    };\r\n\r\n    private static _TextureAndMiscDirtyCallBack = (defines: MaterialDefines) => {\r\n        Material._TextureDirtyCallBack(defines);\r\n        Material._MiscDirtyCallBack(defines);\r\n    };\r\n\r\n    private static readonly _DirtyCallbackArray: Array<(defines: MaterialDefines) => void> = [];\r\n    private static readonly _RunDirtyCallBacks = (defines: MaterialDefines) => {\r\n        for (const cb of Material._DirtyCallbackArray) {\r\n            cb(defines);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Marks a define in the material to indicate that it needs to be re-computed\r\n     * @param flag defines a flag used to determine which parts of the material have to be marked as dirty\r\n     */\r\n    public markAsDirty(flag: number): void {\r\n        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        Material._DirtyCallbackArray.length = 0;\r\n\r\n        if (flag & Material.ImageProcessingDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._ImageProcessingDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.TextureDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._TextureDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.LightDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._LightsDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.FresnelDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._FresnelDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.AttributesDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._AttributeDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.MiscDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._MiscDirtyCallBack);\r\n        }\r\n\r\n        if (flag & Material.PrePassDirtyFlag) {\r\n            Material._DirtyCallbackArray.push(Material._PrePassDirtyCallBack);\r\n        }\r\n\r\n        if (Material._DirtyCallbackArray.length) {\r\n            this._markAllSubMeshesAsDirty(Material._RunDirtyCallBacks);\r\n        }\r\n\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache for all submeshes that are using this material\r\n     */\r\n    public resetDrawCache(): void {\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                subMesh.resetDrawCache();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Marks all submeshes of a material to indicate that their material defines need to be re-calculated\r\n     * @param func defines a function which checks material defines against the submeshes\r\n     */\r\n    protected _markAllSubMeshesAsDirty(func: (defines: MaterialDefines) => void) {\r\n        const scene = this.getScene();\r\n        if (scene.blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        const meshes = scene.meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                // We want to skip the submeshes which are not using this material or which have not yet rendered at least once\r\n                const material = subMesh.getMaterial() || (scene._hasDefaultMaterial ? scene.defaultMaterial : null);\r\n                if (material !== this) {\r\n                    continue;\r\n                }\r\n\r\n                for (const drawWrapper of subMesh._drawWrappers) {\r\n                    if (!drawWrapper || !drawWrapper.defines || !(drawWrapper.defines as MaterialDefines).markAllAsDirty) {\r\n                        continue;\r\n                    }\r\n                    if (this._materialContext === drawWrapper.materialContext) {\r\n                        func(drawWrapper.defines as MaterialDefines);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that the scene should check if the rendering now needs a prepass\r\n     */\r\n    protected _markScenePrePassDirty() {\r\n        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {\r\n            return;\r\n        }\r\n\r\n        const prePassRenderer = this.getScene().enablePrePassRenderer();\r\n        if (prePassRenderer) {\r\n            prePassRenderer.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Indicates that we need to re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsAllDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._AllDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that image processing needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsImageProcessingDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._ImageProcessingDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._TextureDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that fresnel needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsFresnelDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._FresnelDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that fresnel and misc need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsFresnelAndMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._FresnelAndMiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that lights need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsLightsDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._LightsDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that attributes need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsAttributesDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._AttributeDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that misc needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that prepass needs to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsPrePassDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._PrePassDirtyCallBack);\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures and misc need to be re-calculated for all submeshes\r\n     */\r\n    protected _markAllSubMeshesAsTexturesAndMiscDirty() {\r\n        this._markAllSubMeshesAsDirty(Material._TextureAndMiscDirtyCallBack);\r\n    }\r\n\r\n    protected _checkScenePerformancePriority() {\r\n        if (this._scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {\r\n            this.checkReadyOnlyOnce = true;\r\n            // re-set the flag when the perf priority changes\r\n            const observer = this._scene.onScenePerformancePriorityChangedObservable.addOnce(() => {\r\n                this.checkReadyOnlyOnce = false;\r\n            });\r\n            // if this material is disposed before the scene is disposed, cleanup the observer\r\n            this.onDisposeObservable.add(() => {\r\n                this._scene.onScenePerformancePriorityChangedObservable.remove(observer);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        // Do Nothing by default\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param _forceDisposeEffect kept for backward compat. We reference count the effect now.\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(_forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        const scene = this.getScene();\r\n        // Animations\r\n        scene.stopAnimation(this);\r\n        scene.freeProcessedMaterials();\r\n\r\n        // Remove from scene\r\n        scene.removeMaterial(this);\r\n\r\n        this._eventInfo.forceDisposeTextures = forceDisposeTextures;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.Disposed, this._eventInfo);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.materials.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.materials.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (notBoundToMesh !== true) {\r\n            // Remove from meshes\r\n            if (this.meshMap) {\r\n                for (const meshId in this.meshMap) {\r\n                    const mesh = this.meshMap[meshId];\r\n                    this._disposeMeshResources(mesh);\r\n                }\r\n            } else {\r\n                const meshes = scene.meshes;\r\n                for (const mesh of meshes) {\r\n                    this._disposeMeshResources(mesh);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Shader are kept in cache for further use but we can get rid of this by using forceDisposeEffect\r\n        if (this._drawWrapper.effect) {\r\n            if (!this._storeEffectOnSubMeshes) {\r\n                this._drawWrapper.effect.dispose();\r\n            }\r\n\r\n            this._drawWrapper.effect = null;\r\n        }\r\n\r\n        this.metadata = null;\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        if (this._onBindObservable) {\r\n            this._onBindObservable.clear();\r\n        }\r\n\r\n        if (this._onUnBindObservable) {\r\n            this._onUnBindObservable.clear();\r\n        }\r\n\r\n        if (this._onEffectCreatedObservable) {\r\n            this._onEffectCreatedObservable.clear();\r\n        }\r\n\r\n        if (this._eventInfo) {\r\n            this._eventInfo = {} as any;\r\n        }\r\n    }\r\n\r\n    private _disposeMeshResources(mesh: AbstractMesh | undefined) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        const geometry = (<Mesh>mesh).geometry;\r\n        const materialForRenderPass = mesh._internalAbstractMeshDataInfo._materialForRenderPass;\r\n        if (this._storeEffectOnSubMeshes) {\r\n            if (mesh.subMeshes && materialForRenderPass) {\r\n                for (const subMesh of mesh.subMeshes) {\r\n                    const drawWrappers = subMesh._drawWrappers;\r\n                    for (let renderPassIndex = 0; renderPassIndex < drawWrappers.length; renderPassIndex++) {\r\n                        const effect = drawWrappers[renderPassIndex]?.effect;\r\n                        if (!effect) {\r\n                            continue;\r\n                        }\r\n                        const material = materialForRenderPass[renderPassIndex];\r\n                        if (material === this) {\r\n                            geometry?._releaseVertexArrayObject(effect);\r\n                            subMesh._removeDrawWrapper(renderPassIndex, true, true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            geometry?._releaseVertexArrayObject(this._drawWrapper.effect);\r\n        }\r\n\r\n        if (mesh.material === this && !(mesh as InstancedMesh).sourceMesh) {\r\n            mesh.material = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this material\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        serializationObject.stencil = this.stencil.serialize();\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        this._serializePlugins(serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    protected _serializePlugins(serializationObject: any) {\r\n        serializationObject.plugins = {};\r\n\r\n        if (this.pluginManager) {\r\n            for (const plugin of this.pluginManager._plugins) {\r\n                if (!plugin.doNotSerialize) {\r\n                    serializationObject.plugins[plugin.getClassName()] = plugin.serialize();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses the alpha mode from the material data to parse\r\n     * @param parsedMaterial defines the material data to parse\r\n     * @param material defines the material to update\r\n     */\r\n    public static ParseAlphaMode(parsedMaterial: any, material: Material) {\r\n        if (parsedMaterial._alphaMode !== undefined) {\r\n            material._alphaMode = Array.isArray(parsedMaterial._alphaMode) ? parsedMaterial._alphaMode : [parsedMaterial._alphaMode];\r\n        } else if (parsedMaterial.alphaMode !== undefined) {\r\n            material._alphaMode = Array.isArray(parsedMaterial.alphaMode) ? parsedMaterial.alphaMode : [parsedMaterial.alphaMode];\r\n        } else {\r\n            material._alphaMode = [Constants.ALPHA_COMBINE];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a material from parsed material data\r\n     * @param parsedMaterial defines parsed material data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns a new material\r\n     */\r\n    public static Parse(parsedMaterial: any, scene: Scene, rootUrl: string): Nullable<Material> {\r\n        if (!parsedMaterial.customType) {\r\n            parsedMaterial.customType = \"BABYLON.StandardMaterial\";\r\n        } else if (parsedMaterial.customType === \"BABYLON.PBRMaterial\" && parsedMaterial.overloadedAlbedo) {\r\n            parsedMaterial.customType = \"BABYLON.LegacyPBRMaterial\";\r\n            if (!BABYLON.LegacyPBRMaterial) {\r\n                Logger.Error(\"Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.\");\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const materialType = Tools.Instantiate(parsedMaterial.customType);\r\n        const material = materialType.Parse(parsedMaterial, scene, rootUrl);\r\n        material._loadedUniqueId = parsedMaterial.uniqueId;\r\n\r\n        Material.ParseAlphaMode(parsedMaterial, material);\r\n\r\n        return material;\r\n    }\r\n\r\n    protected static _ParsePlugins(serializationObject: any, material: Material, scene: Scene, rootUrl: string) {\r\n        if (!serializationObject.plugins) {\r\n            return;\r\n        }\r\n\r\n        for (const pluginClassName in serializationObject.plugins) {\r\n            const pluginData = serializationObject.plugins[pluginClassName];\r\n\r\n            let plugin = material.pluginManager?.getPlugin(pluginData.name);\r\n\r\n            if (!plugin) {\r\n                const pluginClassType = Tools.Instantiate(\"BABYLON.\" + pluginClassName);\r\n                if (pluginClassType) {\r\n                    plugin = new pluginClassType(material);\r\n                }\r\n            }\r\n\r\n            plugin?.parse(pluginData, scene, rootUrl);\r\n        }\r\n    }\r\n}\r\n", "/**\r\n * Manages the defines for the Material\r\n */\r\nexport class MaterialDefines {\r\n    public VERTEXOUTPUT_INVARIANT = false;\r\n\r\n    /** @internal */\r\n    protected _keys: string[] = [];\r\n    private _isDirty = true;\r\n    /** @internal */\r\n    public _renderId: number;\r\n\r\n    /** @internal */\r\n    public _areLightsDirty = true;\r\n    /** @internal */\r\n    public _areLightsDisposed = false;\r\n    /** @internal */\r\n    public _areAttributesDirty = true;\r\n    /** @internal */\r\n    public _areTexturesDirty = true;\r\n    /** @internal */\r\n    public _areFresnelDirty = true;\r\n    /** @internal */\r\n    public _areMiscDirty = true;\r\n    /** @internal */\r\n    public _arePrePassDirty = true;\r\n    /** @internal */\r\n    public _areImageProcessingDirty = true;\r\n\r\n    /** @internal */\r\n    public _normals = false;\r\n    /** @internal */\r\n    public _uvs = false;\r\n\r\n    /** @internal */\r\n    public _needNormals = false;\r\n    /** @internal */\r\n    public _needUVs = false;\r\n\r\n    protected _externalProperties?: { [name: string]: { type: string; default: any } };\r\n\r\n    [id: string]: any;\r\n\r\n    /**\r\n     * Creates a new instance\r\n     * @param externalProperties list of external properties to inject into the object\r\n     */\r\n    constructor(externalProperties?: { [name: string]: { type: string; default: any } }) {\r\n        this._externalProperties = externalProperties;\r\n\r\n        // Initialize External Properties\r\n        if (externalProperties) {\r\n            for (const prop in externalProperties) {\r\n                if (Object.prototype.hasOwnProperty.call(externalProperties, prop)) {\r\n                    this._setDefaultValue(prop);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material needs to be re-calculated\r\n     */\r\n    public get isDirty(): boolean {\r\n        return this._isDirty;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that it has been re-calculated\r\n     */\r\n    public markAsProcessed() {\r\n        this._isDirty = false;\r\n        this._areAttributesDirty = false;\r\n        this._areTexturesDirty = false;\r\n        this._areFresnelDirty = false;\r\n        this._areLightsDirty = false;\r\n        this._areLightsDisposed = false;\r\n        this._areMiscDirty = false;\r\n        this._arePrePassDirty = false;\r\n        this._areImageProcessingDirty = false;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that it needs to be re-calculated\r\n     */\r\n    public markAsUnprocessed() {\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate all of its defines need to be re-calculated\r\n     */\r\n    public markAllAsDirty() {\r\n        this._areTexturesDirty = true;\r\n        this._areAttributesDirty = true;\r\n        this._areLightsDirty = true;\r\n        this._areFresnelDirty = true;\r\n        this._areMiscDirty = true;\r\n        this._arePrePassDirty = true;\r\n        this._areImageProcessingDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that image processing needs to be re-calculated\r\n     */\r\n    public markAsImageProcessingDirty() {\r\n        this._areImageProcessingDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate the lights need to be re-calculated\r\n     * @param disposed Defines whether the light is dirty due to dispose or not\r\n     */\r\n    public markAsLightDirty(disposed = false) {\r\n        this._areLightsDirty = true;\r\n        this._areLightsDisposed = this._areLightsDisposed || disposed;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the attribute state as changed\r\n     */\r\n    public markAsAttributesDirty() {\r\n        this._areAttributesDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the texture state as changed\r\n     */\r\n    public markAsTexturesDirty() {\r\n        this._areTexturesDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the fresnel state as changed\r\n     */\r\n    public markAsFresnelDirty() {\r\n        this._areFresnelDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the misc state as changed\r\n     */\r\n    public markAsMiscDirty() {\r\n        this._areMiscDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the prepass state as changed\r\n     */\r\n    public markAsPrePassDirty() {\r\n        this._arePrePassDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the material defines\r\n     */\r\n    public rebuild() {\r\n        this._keys.length = 0;\r\n\r\n        for (const key of Object.keys(this)) {\r\n            if (key[0] === \"_\") {\r\n                continue;\r\n            }\r\n\r\n            this._keys.push(key);\r\n        }\r\n\r\n        if (this._externalProperties) {\r\n            for (const name in this._externalProperties) {\r\n                if (this._keys.indexOf(name) === -1) {\r\n                    this._keys.push(name);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies if two material defines are equal\r\n     * @param other - A material define instance to compare to\r\n     * @returns - Boolean indicating if the material defines are equal (true) or not (false)\r\n     */\r\n    public isEqual(other: MaterialDefines): boolean {\r\n        if (this._keys.length !== other._keys.length) {\r\n            return false;\r\n        }\r\n\r\n        for (let index = 0; index < this._keys.length; index++) {\r\n            const prop = this._keys[index];\r\n\r\n            if ((<any>this)[prop] !== (<any>other)[prop]) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Clones this instance's defines to another instance\r\n     * @param other - material defines to clone values to\r\n     */\r\n    public cloneTo(other: MaterialDefines): void {\r\n        if (this._keys.length !== other._keys.length) {\r\n            other._keys = this._keys.slice(0);\r\n        }\r\n\r\n        for (let index = 0; index < this._keys.length; index++) {\r\n            const prop = this._keys[index];\r\n\r\n            (<any>other)[prop] = (<any>this)[prop];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the material define values\r\n     */\r\n    public reset(): void {\r\n        for (const prop of this._keys) {\r\n            this._setDefaultValue(prop);\r\n        }\r\n    }\r\n\r\n    private _setDefaultValue(prop: string): void {\r\n        const type = this._externalProperties?.[prop]?.type ?? typeof (<any>this)[prop];\r\n        const defValue = this._externalProperties?.[prop]?.default;\r\n\r\n        switch (type) {\r\n            case \"number\":\r\n                (<any>this)[prop] = defValue ?? 0;\r\n                break;\r\n            case \"string\":\r\n                (<any>this)[prop] = defValue ?? \"\";\r\n                break;\r\n            default:\r\n                (<any>this)[prop] = defValue ?? false;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts the material define values to a string\r\n     * @returns - String of material define information\r\n     */\r\n    public toString(): string {\r\n        let result = \"\";\r\n        for (let index = 0; index < this._keys.length; index++) {\r\n            const prop = this._keys[index];\r\n            const value = (<any>this)[prop];\r\n            const type = typeof value;\r\n\r\n            switch (type) {\r\n                case \"number\":\r\n                case \"string\":\r\n                    result += \"#define \" + prop + \" \" + value + \"\\n\";\r\n                    break;\r\n                default:\r\n                    if (value) {\r\n                        result += \"#define \" + prop + \"\\n\";\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\n/**\r\n * Base class of materials working in push mode in babylon JS\r\n * @internal\r\n */\r\nexport class PushMaterial extends Material {\r\n    protected _activeEffect?: Effect;\r\n\r\n    protected _normalMatrix: Matrix = new Matrix();\r\n\r\n    constructor(name: string, scene?: Scene, storeEffectOnSubMeshes = true, forceGLSL = false) {\r\n        super(name, scene, undefined, forceGLSL);\r\n        this._storeEffectOnSubMeshes = storeEffectOnSubMeshes;\r\n    }\r\n\r\n    public override getEffect(): Effect {\r\n        return this._storeEffectOnSubMeshes ? this._activeEffect! : super.getEffect()!;\r\n    }\r\n\r\n    public override isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        if (!mesh) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._storeEffectOnSubMeshes) {\r\n            return true;\r\n        }\r\n\r\n        if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\r\n            return true;\r\n        }\r\n\r\n        return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);\r\n    }\r\n\r\n    protected _isReadyForSubMesh(subMesh: SubMesh) {\r\n        const defines = subMesh.materialDefines;\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {\r\n            if (defines._renderId === this.getScene().getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Binds the given world matrix to the active effect\r\n     *\r\n     * @param world the matrix to bind\r\n     */\r\n    public override bindOnlyWorldMatrix(world: Matrix): void {\r\n        this._activeEffect!.setMatrix(\"world\", world);\r\n    }\r\n\r\n    /**\r\n     * Binds the given normal matrix to the active effect\r\n     *\r\n     * @param normalMatrix the matrix to bind\r\n     */\r\n    public bindOnlyNormalMatrix(normalMatrix: Matrix): void {\r\n        this._activeEffect!.setMatrix(\"normalMatrix\", normalMatrix);\r\n    }\r\n\r\n    public override bind(world: Matrix, mesh?: Mesh): void {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);\r\n    }\r\n\r\n    protected override _afterBind(mesh?: AbstractMesh, effect: Nullable<Effect> = null, subMesh?: SubMesh): void {\r\n        super._afterBind(mesh, effect, subMesh);\r\n        this.getScene()._cachedEffect = effect;\r\n        if (subMesh) {\r\n            subMesh._drawWrapper._forceRebindOnNextCall = false;\r\n        } else {\r\n            this._drawWrapper._forceRebindOnNextCall = false;\r\n        }\r\n    }\r\n\r\n    protected _mustRebind(scene: Scene, effect: Effect, subMesh: SubMesh, visibility = 1): boolean {\r\n        return subMesh._drawWrapper._forceRebindOnNextCall || scene.isCachedMaterialInvalid(this, effect, visibility);\r\n    }\r\n\r\n    public override dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean) {\r\n        this._activeEffect = undefined;\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { IEffectFallbacks } from \"./iEffectFallbacks\";\r\n\r\nimport type { Effect } from \"./effect\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/**\r\n * EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.\r\n * (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)\r\n */\r\nexport class EffectFallbacks implements IEffectFallbacks {\r\n    private _defines: { [key: string]: Array<string> } = {};\r\n\r\n    private _currentRank = 32;\r\n    private _maxRank = -1;\r\n\r\n    private _mesh: Nullable<AbstractMesh> = null;\r\n\r\n    /**\r\n     * Removes the fallback from the bound mesh.\r\n     */\r\n    public unBindMesh() {\r\n        this._mesh = null;\r\n    }\r\n\r\n    /**\r\n     * Adds a fallback on the specified property.\r\n     * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\r\n     * @param define The name of the define in the shader\r\n     */\r\n    public addFallback(rank: number, define: string): void {\r\n        if (!this._defines[rank]) {\r\n            if (rank < this._currentRank) {\r\n                this._currentRank = rank;\r\n            }\r\n\r\n            if (rank > this._maxRank) {\r\n                this._maxRank = rank;\r\n            }\r\n\r\n            this._defines[rank] = new Array<string>();\r\n        }\r\n\r\n        this._defines[rank].push(define);\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh to use CPU skinning when needing to fallback.\r\n     * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\r\n     * @param mesh The mesh to use the fallbacks.\r\n     */\r\n    public addCPUSkinningFallback(rank: number, mesh: AbstractMesh) {\r\n        this._mesh = mesh;\r\n\r\n        if (rank < this._currentRank) {\r\n            this._currentRank = rank;\r\n        }\r\n        if (rank > this._maxRank) {\r\n            this._maxRank = rank;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks to see if more fallbacks are still available.\r\n     */\r\n    public get hasMoreFallbacks(): boolean {\r\n        return this._currentRank <= this._maxRank;\r\n    }\r\n\r\n    /**\r\n     * Removes the defines that should be removed when falling back.\r\n     * @param currentDefines defines the current define statements for the shader.\r\n     * @param effect defines the current effect we try to compile\r\n     * @returns The resulting defines with defines of the current rank removed.\r\n     */\r\n    public reduce(currentDefines: string, effect: Effect): string {\r\n        // First we try to switch to CPU skinning\r\n        if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {\r\n            this._mesh.computeBonesUsingShaders = false;\r\n            currentDefines = currentDefines.replace(\"#define NUM_BONE_INFLUENCERS \" + this._mesh.numBoneInfluencers, \"#define NUM_BONE_INFLUENCERS 0\");\r\n            effect._bonesComputationForcedToCPU = true;\r\n\r\n            const scene = this._mesh.getScene();\r\n            for (let index = 0; index < scene.meshes.length; index++) {\r\n                const otherMesh = scene.meshes[index];\r\n\r\n                if (!otherMesh.material) {\r\n                    if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {\r\n                        otherMesh.computeBonesUsingShaders = false;\r\n                    }\r\n                    continue;\r\n                }\r\n\r\n                if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (otherMesh.material.getEffect() === effect) {\r\n                    otherMesh.computeBonesUsingShaders = false;\r\n                } else if (otherMesh.subMeshes) {\r\n                    for (const subMesh of otherMesh.subMeshes) {\r\n                        const subMeshEffect = subMesh.effect;\r\n\r\n                        if (subMeshEffect === effect) {\r\n                            otherMesh.computeBonesUsingShaders = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const currentFallbacks = this._defines[this._currentRank];\r\n            if (currentFallbacks) {\r\n                for (let index = 0; index < currentFallbacks.length; index++) {\r\n                    currentDefines = currentDefines.replace(\"#define \" + currentFallbacks[index], \"\");\r\n                }\r\n            }\r\n\r\n            this._currentRank++;\r\n        }\r\n\r\n        return currentDefines;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
