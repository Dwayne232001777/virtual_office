{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/flowGraphMath.ts", "../../../dev/core/src/FlowGraph/Blocks/Data/Math/flowGraphVectorMathBlocks.ts"],
  "sourcesContent": ["import type { IQuaternionLike } from \"../Maths/math.like\";\r\nimport { Clamp } from \"../Maths/math.scalar.functions\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\nimport { Vector3Dot, Vector4Dot } from \"../Maths/math.vector.functions\";\r\nimport type { DeepImmutable } from \"../types\";\r\n\r\n// *** NOTE ***\r\n// These functions should ideally go in math.vector.functions.ts, but they require math.vector.ts to\r\n// be imported which is big. To avoid the larger bundle size, they are kept inside flow graph for now.\r\n\r\n/**\r\n * Returns the angle in radians between two quaternions\r\n * @param q1 defines the first quaternion\r\n * @param q2 defines the second quaternion\r\n * @returns the angle in radians between the two quaternions\r\n */\r\nexport function GetAngleBetweenQuaternions(q1: DeepImmutable<IQuaternionLike>, q2: DeepImmutable<IQuaternionLike>): number {\r\n    return Math.acos(Clamp(Vector4Dot(q1, q2), -1, 1)) * 2;\r\n}\r\n\r\n/**\r\n * Creates a quaternion from two direction vectors\r\n * @param a defines the first direction vector\r\n * @param b defines the second direction vector\r\n * @returns the target quaternion\r\n */\r\nexport function GetQuaternionFromDirections<T extends Vector3>(a: DeepImmutable<T>, b: DeepImmutable<T>): Quaternion {\r\n    const result = new Quaternion();\r\n    GetQuaternionFromDirectionsToRef(a, b, result);\r\n    return result;\r\n}\r\n\r\n/**\r\n * Creates a quaternion from two direction vectors\r\n * @param a defines the first direction vector\r\n * @param b defines the second direction vector\r\n * @param result defines the target quaternion\r\n * @returns the target quaternion\r\n */\r\nexport function GetQuaternionFromDirectionsToRef<T extends Vector3, ResultT extends Quaternion>(a: DeepImmutable<T>, b: DeepImmutable<T>, result: ResultT): ResultT {\r\n    const axis = Vector3.Cross(a, b);\r\n    const angle = Math.acos(Clamp(Vector3Dot(a, b), -1, 1));\r\n    Quaternion.RotationAxisToRef(axis, angle, result);\r\n    return result;\r\n}\r\n", "import { FlowGraphBlock, type IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport {\n    RichTypeVector3,\n    FlowGraphTypes,\n    RichTypeNumber,\n    RichTypeAny,\n    RichTypeVector2,\n    RichTypeMatrix,\n    getRichTypeByFlowGraphType,\n    RichTypeQuaternion,\n    RichTypeBoolean,\n} from \"core/FlowGraph/flowGraphRichTypes\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\nimport { FlowGraphBinaryOperationBlock } from \"../flowGraphBinaryOperationBlock\";\nimport { FlowGraphUnaryOperationBlock } from \"../flowGraphUnaryOperationBlock\";\nimport { Quaternion, Vector3, Vector4 } from \"core/Maths/math.vector\";\nimport type { Matrix, Vector2 } from \"core/Maths/math.vector\";\nimport type { FlowGraphMatrix2D, FlowGraphMatrix3D } from \"core/FlowGraph/CustomTypes\";\nimport type { FlowGraphMatrix, FlowGraphVector } from \"core/FlowGraph/utils\";\nimport { _GetClassNameOf } from \"core/FlowGraph/utils\";\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\nimport type { FlowGraphContext } from \"../../../flowGraphContext\";\nimport type { Nullable } from \"../../../../types\";\nimport { GetAngleBetweenQuaternions, GetQuaternionFromDirections } from \"core/FlowGraph/flowGraphMath\";\n\nconst AxisCacheName = \"cachedOperationAxis\";\nconst AngleCacheName = \"cachedOperationAngle\";\nconst CacheExecIdName = \"cachedExecutionId\";\n\n/**\n * Vector length block.\n */\nexport class FlowGraphLengthBlock extends FlowGraphUnaryOperationBlock<FlowGraphVector, number> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicLength(a), FlowGraphBlockNames.Length, config);\n    }\n\n    private _polymorphicLength(a: FlowGraphVector) {\n        const aClassName = _GetClassNameOf(a);\n        switch (aClassName) {\n            case FlowGraphTypes.Vector2:\n            case FlowGraphTypes.Vector3:\n            case FlowGraphTypes.Vector4:\n            case FlowGraphTypes.Quaternion:\n                return (a as Vector3).length();\n            default:\n                throw new Error(`Cannot compute length of value ${a}`);\n        }\n    }\n}\nRegisterClass(FlowGraphBlockNames.Length, FlowGraphLengthBlock);\n\n/**\n * Configuration for normalized vector\n */\nexport interface IFlowGraphNormalizeBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * If true, the block will return NaN if the input vector has a length of 0.\n     * This is the expected behavior for glTF interactivity graphs.\n     */\n    nanOnZeroLength?: boolean;\n}\n\n/**\n * Vector normalize block.\n */\nexport class FlowGraphNormalizeBlock extends FlowGraphUnaryOperationBlock<FlowGraphVector, FlowGraphVector> {\n    constructor(config?: IFlowGraphNormalizeBlockConfiguration) {\n        super(RichTypeAny, RichTypeAny, (a) => this._polymorphicNormalize(a), FlowGraphBlockNames.Normalize, config);\n    }\n\n    private _polymorphicNormalize(a: FlowGraphVector) {\n        const aClassName = _GetClassNameOf(a);\n        let normalized: FlowGraphVector;\n        switch (aClassName) {\n            case FlowGraphTypes.Vector2:\n            case FlowGraphTypes.Vector3:\n            case FlowGraphTypes.Vector4:\n            case FlowGraphTypes.Quaternion:\n                normalized = a.normalizeToNew();\n                if (this.config?.nanOnZeroLength) {\n                    const length = a.length();\n                    if (length === 0) {\n                        normalized.setAll(NaN);\n                    }\n                }\n                return normalized;\n            default:\n                throw new Error(`Cannot normalize value ${a}`);\n        }\n    }\n}\nRegisterClass(FlowGraphBlockNames.Normalize, FlowGraphNormalizeBlock);\n\n/**\n * Dot product block.\n */\nexport class FlowGraphDotBlock extends FlowGraphBinaryOperationBlock<FlowGraphVector, FlowGraphVector, number> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeAny, RichTypeAny, RichTypeNumber, (a, b) => this._polymorphicDot(a, b), FlowGraphBlockNames.Dot, config);\n    }\n\n    private _polymorphicDot(a: FlowGraphVector, b: FlowGraphVector) {\n        const className = _GetClassNameOf(a);\n        switch (className) {\n            case FlowGraphTypes.Vector2:\n            case FlowGraphTypes.Vector3:\n            case FlowGraphTypes.Vector4:\n            case FlowGraphTypes.Quaternion:\n                // casting is needed because dot requires both to be the same type\n                return (a as Vector3).dot(b as Vector3);\n            default:\n                throw new Error(`Cannot get dot product of ${a} and ${b}`);\n        }\n    }\n}\nRegisterClass(FlowGraphBlockNames.Dot, FlowGraphDotBlock);\n\n/**\n * Cross product block.\n */\nexport class FlowGraphCrossBlock extends FlowGraphBinaryOperationBlock<Vector3, Vector3, Vector3> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeVector3, RichTypeVector3, (a, b) => Vector3.Cross(a, b), FlowGraphBlockNames.Cross, config);\n    }\n}\nRegisterClass(FlowGraphBlockNames.Cross, FlowGraphCrossBlock);\n\n/**\n * 2D rotation block.\n */\nexport class FlowGraphRotate2DBlock extends FlowGraphBinaryOperationBlock<Vector2, number, Vector2> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector2, RichTypeNumber, RichTypeVector2, (a, b) => a.rotate(b), FlowGraphBlockNames.Rotate2D, config);\n    }\n}\nRegisterClass(FlowGraphBlockNames.Rotate2D, FlowGraphRotate2DBlock);\n\n/**\n * 3D rotation block.\n */\nexport class FlowGraphRotate3DBlock extends FlowGraphBinaryOperationBlock<Vector3, Quaternion, Vector3> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeQuaternion, RichTypeVector3, (a, b) => a.applyRotationQuaternion(b), FlowGraphBlockNames.Rotate3D, config);\n    }\n}\nRegisterClass(FlowGraphBlockNames.Rotate3D, FlowGraphRotate3DBlock);\n\nfunction TransformVector(a: FlowGraphVector, b: FlowGraphMatrix): FlowGraphVector {\n    const className = _GetClassNameOf(a);\n    switch (className) {\n        case FlowGraphTypes.Vector2:\n            return (b as FlowGraphMatrix2D).transformVector(a as Vector2);\n        case FlowGraphTypes.Vector3:\n            return (b as FlowGraphMatrix3D).transformVector(a as Vector3);\n        case FlowGraphTypes.Vector4:\n            a = a as Vector4;\n            // transform the vector 4 with the matrix here. Vector4.TransformCoordinates transforms a 3D coordinate, not Vector4\n            return new Vector4(\n                a.x * b.m[0] + a.y * b.m[1] + a.z * b.m[2] + a.w * b.m[3],\n                a.x * b.m[4] + a.y * b.m[5] + a.z * b.m[6] + a.w * b.m[7],\n                a.x * b.m[8] + a.y * b.m[9] + a.z * b.m[10] + a.w * b.m[11],\n                a.x * b.m[12] + a.y * b.m[13] + a.z * b.m[14] + a.w * b.m[15]\n            );\n        default:\n            throw new Error(`Cannot transform value ${a}`);\n    }\n}\n\n/**\n * Configuration for the transform block.\n */\nexport interface IFlowGraphTransformBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * The vector type\n     */\n    vectorType: FlowGraphTypes;\n}\n\n/**\n * Transform a vector3 by a matrix.\n */\nexport class FlowGraphTransformBlock extends FlowGraphBinaryOperationBlock<FlowGraphVector, FlowGraphMatrix, FlowGraphVector> {\n    constructor(config?: IFlowGraphTransformBlockConfiguration) {\n        const vectorType = config?.vectorType || FlowGraphTypes.Vector3;\n        const matrixType =\n            vectorType === FlowGraphTypes.Vector2 ? FlowGraphTypes.Matrix2D : vectorType === FlowGraphTypes.Vector3 ? FlowGraphTypes.Matrix3D : FlowGraphTypes.Matrix;\n        super(\n            getRichTypeByFlowGraphType(vectorType),\n            getRichTypeByFlowGraphType(matrixType),\n            getRichTypeByFlowGraphType(vectorType),\n            TransformVector,\n            FlowGraphBlockNames.TransformVector,\n            config\n        );\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.TransformVector, FlowGraphTransformBlock);\n\n/**\n * Transform a vector3 by a matrix.\n */\nexport class FlowGraphTransformCoordinatesBlock extends FlowGraphBinaryOperationBlock<Vector3, Matrix, Vector3> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeMatrix, RichTypeVector3, (a, b) => Vector3.TransformCoordinates(a, b), FlowGraphBlockNames.TransformCoordinates, config);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.TransformCoordinates, FlowGraphTransformCoordinatesBlock);\n\n/**\n * Conjugate the quaternion.\n */\nexport class FlowGraphConjugateBlock extends FlowGraphUnaryOperationBlock<Quaternion, Quaternion> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeQuaternion, RichTypeQuaternion, (a) => a.conjugate(), FlowGraphBlockNames.Conjugate, config);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.Conjugate, FlowGraphConjugateBlock);\n\n/**\n * Get the angle between two quaternions.\n */\nexport class FlowGraphAngleBetweenBlock extends FlowGraphBinaryOperationBlock<Quaternion, Quaternion, number> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeQuaternion, RichTypeQuaternion, RichTypeNumber, (a, b) => GetAngleBetweenQuaternions(a, b), FlowGraphBlockNames.AngleBetween, config);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.AngleBetween, FlowGraphAngleBetweenBlock);\n\n/**\n * Get the quaternion from an axis and an angle.\n */\nexport class FlowGraphQuaternionFromAxisAngleBlock extends FlowGraphBinaryOperationBlock<Vector3, number, Quaternion> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeNumber, RichTypeQuaternion, (a, b) => Quaternion.RotationAxis(a, b), FlowGraphBlockNames.QuaternionFromAxisAngle, config);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.QuaternionFromAxisAngle, FlowGraphQuaternionFromAxisAngleBlock);\n\n/**\n * Get the axis and angle from a quaternion.\n */\nexport class FlowGraphAxisAngleFromQuaternionBlock extends FlowGraphBlock {\n    /**\n     * The input of this block.\n     */\n    public readonly a: FlowGraphDataConnection<Quaternion>;\n\n    /**\n     * The output axis of rotation.\n     */\n    public readonly axis: FlowGraphDataConnection<Vector3>;\n\n    /**\n     * The output angle of rotation.\n     */\n    public readonly angle: FlowGraphDataConnection<number>;\n\n    /**\n     * Output connection: Whether the value is valid.\n     */\n    public readonly isValid: FlowGraphDataConnection<boolean>;\n\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(config);\n\n        this.a = this.registerDataInput(\"a\", RichTypeQuaternion);\n\n        this.axis = this.registerDataOutput(\"axis\", RichTypeVector3);\n        this.angle = this.registerDataOutput(\"angle\", RichTypeNumber);\n\n        this.isValid = this.registerDataOutput(\"isValid\", RichTypeBoolean);\n    }\n\n    /** @override */\n    public override _updateOutputs(context: FlowGraphContext) {\n        const cachedExecutionId = context._getExecutionVariable(this, CacheExecIdName, -1);\n        const cachedAxis = context._getExecutionVariable<Nullable<Vector3>>(this, AxisCacheName, null);\n        const cachedAngle = context._getExecutionVariable<Nullable<number>>(this, AngleCacheName, null);\n        if (cachedAxis !== undefined && cachedAxis !== null && cachedAngle !== undefined && cachedAngle !== null && cachedExecutionId === context.executionId) {\n            this.axis.setValue(cachedAxis, context);\n            this.angle.setValue(cachedAngle, context);\n        } else {\n            try {\n                const { axis, angle } = this.a.getValue(context).toAxisAngle();\n                context._setExecutionVariable(this, AxisCacheName, axis);\n                context._setExecutionVariable(this, AngleCacheName, angle);\n                context._setExecutionVariable(this, CacheExecIdName, context.executionId);\n                this.axis.setValue(axis, context);\n                this.angle.setValue(angle, context);\n                this.isValid.setValue(true, context);\n            } catch (e) {\n                this.isValid.setValue(false, context);\n            }\n        }\n    }\n\n    /** @override */\n    public override getClassName(): string {\n        return FlowGraphBlockNames.AxisAngleFromQuaternion;\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.AxisAngleFromQuaternion, FlowGraphAxisAngleFromQuaternionBlock);\n\n/**\n * Get the quaternion from two direction vectors.\n */\nexport class FlowGraphQuaternionFromDirectionsBlock extends FlowGraphBinaryOperationBlock<Vector3, Vector3, Quaternion> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeVector3, RichTypeQuaternion, (a, b) => GetQuaternionFromDirections(a, b), FlowGraphBlockNames.QuaternionFromDirections, config);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
