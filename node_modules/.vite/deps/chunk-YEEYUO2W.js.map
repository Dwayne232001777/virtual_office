{
  "version": 3,
  "sources": ["../../../dev/core/src/Buffers/buffer.ts"],
  "sourcesContent": ["import type { Nullable, DataArray, FloatArray } from \"../types\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { DataBuffer } from \"./dataBuffer\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { EnumerateFloatValues, GetFloatData, GetTypeByteLength } from \"./bufferUtils\";\r\n\r\n/**\r\n * Class used to store data that will be store in GPU memory\r\n */\r\nexport class Buffer {\r\n    private _engine: AbstractEngine;\r\n    private _buffer: Nullable<DataBuffer>;\r\n    /** @internal */\r\n    public _data: Nullable<DataArray>;\r\n    private _updatable: boolean;\r\n    private _instanced: boolean;\r\n    private _divisor: number;\r\n    private _isAlreadyOwned = false;\r\n    private _isDisposed = false;\r\n    private _label?: string;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the Buffer is disposed\r\n     */\r\n    public get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Gets the byte stride.\r\n     */\r\n    public readonly byteStride: number;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine the engine\r\n     * @param data the data to use for this buffer\r\n     * @param updatable whether the data is updatable\r\n     * @param stride the stride (optional)\r\n     * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\r\n     * @param instanced whether the buffer is instanced (optional)\r\n     * @param useBytes set to true if the stride in in bytes (optional)\r\n     * @param divisor sets an optional divisor for instances (1 by default)\r\n     * @param label defines the label of the buffer (for debug purpose)\r\n     */\r\n    constructor(\r\n        engine: AbstractEngine,\r\n        data: DataArray | DataBuffer,\r\n        updatable: boolean,\r\n        stride = 0,\r\n        postponeInternalCreation = false,\r\n        instanced = false,\r\n        useBytes = false,\r\n        divisor?: number,\r\n        label?: string\r\n    ) {\r\n        if (engine && (engine as unknown as Mesh).getScene) {\r\n            // old versions of VertexBuffer accepted 'mesh' instead of 'engine'\r\n            this._engine = (engine as unknown as Mesh).getScene().getEngine();\r\n        } else {\r\n            this._engine = engine;\r\n        }\r\n\r\n        this._updatable = updatable;\r\n        this._instanced = instanced;\r\n        this._divisor = divisor || 1;\r\n        this._label = label;\r\n\r\n        if (data instanceof DataBuffer) {\r\n            this._data = null;\r\n            this._buffer = data;\r\n        } else {\r\n            this._data = data;\r\n            this._buffer = null;\r\n        }\r\n\r\n        this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;\r\n\r\n        if (!postponeInternalCreation) {\r\n            // by default\r\n            this.create();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new VertexBuffer based on the current buffer\r\n     * @param kind defines the vertex buffer kind (position, normal, etc.)\r\n     * @param offset defines offset in the buffer (0 by default)\r\n     * @param size defines the size in floats of attributes (position is 3 for instance)\r\n     * @param stride defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)\r\n     * @param instanced defines if the vertex buffer contains indexed data\r\n     * @param useBytes defines if the offset and stride are in bytes     *\r\n     * @param divisor sets an optional divisor for instances (1 by default)\r\n     * @returns the new vertex buffer\r\n     */\r\n    public createVertexBuffer(kind: string, offset: number, size: number, stride?: number, instanced?: boolean, useBytes = false, divisor?: number): VertexBuffer {\r\n        const byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;\r\n        const byteStride = stride ? (useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT) : this.byteStride;\r\n\r\n        // a lot of these parameters are ignored as they are overridden by the buffer\r\n        return new VertexBuffer(\r\n            this._engine,\r\n            this,\r\n            kind,\r\n            this._updatable,\r\n            true,\r\n            byteStride,\r\n            instanced === undefined ? this._instanced : instanced,\r\n            byteOffset,\r\n            size,\r\n            undefined,\r\n            undefined,\r\n            true,\r\n            this._divisor || divisor\r\n        );\r\n    }\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets a boolean indicating if the Buffer is updatable?\r\n     * @returns true if the buffer is updatable\r\n     */\r\n    public isUpdatable(): boolean {\r\n        return this._updatable;\r\n    }\r\n\r\n    /**\r\n     * Gets current buffer's data\r\n     * @returns a DataArray or null\r\n     */\r\n    public getData(): Nullable<DataArray> {\r\n        return this._data;\r\n    }\r\n\r\n    /**\r\n     * Gets underlying native buffer\r\n     * @returns underlying native buffer\r\n     */\r\n    public getBuffer(): Nullable<DataBuffer> {\r\n        return this._buffer;\r\n    }\r\n\r\n    /**\r\n     * Gets the stride in float32 units (i.e. byte stride / 4).\r\n     * May not be an integer if the byte stride is not divisible by 4.\r\n     * @returns the stride in float32 units\r\n     * @deprecated Please use byteStride instead.\r\n     */\r\n    public getStrideSize(): number {\r\n        return this.byteStride / Float32Array.BYTES_PER_ELEMENT;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Store data into the buffer. Creates the buffer if not used already.\r\n     * If the buffer was already used, it will be updated only if it is updatable, otherwise it will do nothing.\r\n     * @param data defines the data to store\r\n     */\r\n    public create(data: Nullable<DataArray> = null): void {\r\n        if (!data && this._buffer) {\r\n            return; // nothing to do\r\n        }\r\n\r\n        data = data || this._data;\r\n\r\n        if (!data) {\r\n            return;\r\n        }\r\n\r\n        if (!this._buffer) {\r\n            // create buffer\r\n            if (this._updatable) {\r\n                this._buffer = this._engine.createDynamicVertexBuffer(data, this._label);\r\n                this._data = data;\r\n            } else {\r\n                this._buffer = this._engine.createVertexBuffer(data, undefined, this._label);\r\n            }\r\n        } else if (this._updatable) {\r\n            // update buffer\r\n            this._engine.updateDynamicVertexBuffer(this._buffer, data);\r\n            this._data = data;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (!this._data) {\r\n            if (!this._buffer) {\r\n                // Buffer was not yet created, nothing to do\r\n                return;\r\n            }\r\n            if (this._buffer.capacity > 0) {\r\n                // We can at least recreate the buffer with the right size, even if we don't have the data\r\n                if (this._updatable) {\r\n                    this._buffer = this._engine.createDynamicVertexBuffer(this._buffer.capacity, this._label);\r\n                } else {\r\n                    this._buffer = this._engine.createVertexBuffer(this._buffer.capacity, undefined, this._label);\r\n                }\r\n                return;\r\n            }\r\n            Logger.Warn(`Missing data for buffer \"${this._label}\" ${this._buffer ? \"(uniqueId: \" + this._buffer.uniqueId + \")\" : \"\"}. Buffer reconstruction failed.`);\r\n            this._buffer = null;\r\n        } else {\r\n            this._buffer = null;\r\n            this.create(this._data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update current buffer data\r\n     * @param data defines the data to store\r\n     */\r\n    public update(data: DataArray): void {\r\n        this.create(data);\r\n    }\r\n\r\n    /**\r\n     * Updates the data directly.\r\n     * @param data the new data\r\n     * @param offset the new offset\r\n     * @param vertexCount the vertex count (optional)\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    public updateDirectly(data: DataArray, offset: number, vertexCount?: number, useBytes: boolean = false): void {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        if (this._updatable) {\r\n            // update buffer\r\n            this._engine.updateDynamicVertexBuffer(\r\n                this._buffer,\r\n                data,\r\n                useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT,\r\n                vertexCount ? vertexCount * this.byteStride : undefined\r\n            );\r\n            if (offset === 0 && vertexCount === undefined) {\r\n                // Keep the data if we easily can\r\n                this._data = data;\r\n            } else {\r\n                this._data = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _increaseReferences() {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        if (!this._isAlreadyOwned) {\r\n            this._isAlreadyOwned = true;\r\n            return;\r\n        }\r\n\r\n        this._buffer.references++;\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        // The data buffer has an internal counter as this buffer can be used by several VertexBuffer objects\r\n        // This means that we only flag it as disposed when all references are released (when _releaseBuffer will return true)\r\n        if (this._engine._releaseBuffer(this._buffer)) {\r\n            this._isDisposed = true;\r\n            this._data = null;\r\n            this._buffer = null;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Options to be used when creating a vertex buffer\r\n */\r\nexport interface IVertexBufferOptions {\r\n    /**\r\n     * whether the data is updatable (default: false)\r\n     */\r\n    updatable?: boolean;\r\n    /**\r\n     * whether to postpone creating the internal WebGL buffer (default: false)\r\n     */\r\n    postponeInternalCreation?: boolean;\r\n    /**\r\n     * the stride (will be automatically computed from the kind parameter if not specified)\r\n     */\r\n    stride?: number;\r\n    /**\r\n     * whether the buffer is instanced (default: false)\r\n     */\r\n    instanced?: boolean;\r\n    /**\r\n     * the offset of the data (default: 0)\r\n     */\r\n    offset?: number;\r\n    /**\r\n     * the number of components (will be automatically computed from the kind parameter if not specified)\r\n     */\r\n    size?: number;\r\n    /**\r\n     * the type of the component (will be deduce from the data parameter if not specified)\r\n     */\r\n    type?: number;\r\n    /**\r\n     * whether the data contains normalized data (default: false)\r\n     */\r\n    normalized?: boolean;\r\n    /**\r\n     * set to true if stride and offset are in bytes (default: false)\r\n     */\r\n    useBytes?: boolean;\r\n    /**\r\n     * defines the instance divisor to use (default: 1, only used if instanced is true)\r\n     */\r\n    divisor?: number;\r\n    /**\r\n     * defines if the buffer should be released when the vertex buffer is disposed (default: false)\r\n     */\r\n    takeBufferOwnership?: boolean;\r\n    /**\r\n     * label to use for this vertex buffer (debugging purpose)\r\n     */\r\n    label?: string;\r\n}\r\n\r\n/**\r\n * Specialized buffer used to store vertex data\r\n */\r\nexport class VertexBuffer {\r\n    private static _Counter = 0;\r\n\r\n    /** @internal */\r\n    public _buffer: Buffer;\r\n    /** @internal */\r\n    public _validOffsetRange: boolean; // used internally by the engine\r\n    private _kind: string;\r\n    private _size: number;\r\n    /** @internal */\r\n    public _ownsBuffer: boolean;\r\n    private _instanced: boolean;\r\n    private _instanceDivisor: number;\r\n    /** @internal */\r\n    public _isDisposed = false;\r\n    /** @internal */\r\n    public _label?: string;\r\n\r\n    /**\r\n     * The byte type.\r\n     */\r\n    public static readonly BYTE = Constants.BYTE;\r\n\r\n    /**\r\n     * The unsigned byte type.\r\n     */\r\n    public static readonly UNSIGNED_BYTE = Constants.UNSIGNED_BYTE;\r\n\r\n    /**\r\n     * The short type.\r\n     */\r\n    public static readonly SHORT = Constants.SHORT;\r\n\r\n    /**\r\n     * The unsigned short type.\r\n     */\r\n    public static readonly UNSIGNED_SHORT = Constants.UNSIGNED_SHORT;\r\n\r\n    /**\r\n     * The integer type.\r\n     */\r\n    public static readonly INT = Constants.INT;\r\n\r\n    /**\r\n     * The unsigned integer type.\r\n     */\r\n    public static readonly UNSIGNED_INT = Constants.UNSIGNED_INT;\r\n\r\n    /**\r\n     * The float type.\r\n     */\r\n    public static readonly FLOAT = Constants.FLOAT;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the Buffer is disposed\r\n     */\r\n    public get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the instance divisor when in instanced mode\r\n     */\r\n    public get instanceDivisor(): number {\r\n        return this._instanceDivisor;\r\n    }\r\n\r\n    public set instanceDivisor(value: number) {\r\n        const isInstanced = value != 0;\r\n        this._instanceDivisor = value;\r\n\r\n        if (isInstanced !== this._instanced) {\r\n            this._instanced = isInstanced;\r\n            this._computeHashCode();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the byte stride.\r\n     */\r\n    public readonly byteStride: number;\r\n\r\n    /**\r\n     * Gets the byte offset.\r\n     */\r\n    public readonly byteOffset: number;\r\n\r\n    /**\r\n     * Gets whether integer data values should be normalized into a certain range when being casted to a float.\r\n     */\r\n    public readonly normalized: boolean;\r\n\r\n    /**\r\n     * Gets the data type of each component in the array.\r\n     */\r\n    public readonly type: number;\r\n\r\n    /**\r\n     * Gets the unique id of this vertex buffer\r\n     */\r\n    public readonly uniqueId: number;\r\n\r\n    /**\r\n     * Gets a hash code representing the format (type, normalized, size, instanced, stride) of this buffer\r\n     * All buffers with the same format will have the same hash code\r\n     */\r\n    public readonly hashCode: number;\r\n\r\n    /**\r\n     * Gets the engine associated with the buffer\r\n     */\r\n    public readonly engine: AbstractEngine;\r\n\r\n    /**\r\n     * Gets the max possible amount of vertices stored within the current vertex buffer.\r\n     * We do not have the end offset or count so this will be too big for concatenated vertex buffers.\r\n     * @internal\r\n     */\r\n    public get _maxVerticesCount() {\r\n        const data = this.getData();\r\n        if (!data) {\r\n            return 0;\r\n        }\r\n\r\n        if (Array.isArray(data)) {\r\n            // data is a regular number[] with float values\r\n            return data.length / (this.byteStride / 4) - this.byteOffset / 4;\r\n        }\r\n\r\n        return (data.byteLength - this.byteOffset) / this.byteStride;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine the engine\r\n     * @param data the data to use for this vertex buffer\r\n     * @param kind the vertex buffer kind\r\n     * @param updatable whether the data is updatable\r\n     * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\r\n     * @param stride the stride (optional)\r\n     * @param instanced whether the buffer is instanced (optional)\r\n     * @param offset the offset of the data (optional)\r\n     * @param size the number of components (optional)\r\n     * @param type the type of the component (optional)\r\n     * @param normalized whether the data contains normalized data (optional)\r\n     * @param useBytes set to true if stride and offset are in bytes (optional)\r\n     * @param divisor defines the instance divisor to use (1 by default)\r\n     * @param takeBufferOwnership defines if the buffer should be released when the vertex buffer is disposed\r\n     */\r\n    constructor(\r\n        engine: AbstractEngine,\r\n        data: DataArray | Buffer | DataBuffer,\r\n        kind: string,\r\n        updatable: boolean,\r\n        postponeInternalCreation?: boolean,\r\n        stride?: number,\r\n        instanced?: boolean,\r\n        offset?: number,\r\n        size?: number,\r\n        type?: number,\r\n        normalized?: boolean,\r\n        useBytes?: boolean,\r\n        divisor?: number,\r\n        takeBufferOwnership?: boolean\r\n    );\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine the engine\r\n     * @param data the data to use for this vertex buffer\r\n     * @param kind the vertex buffer kind\r\n     * @param options defines the rest of the options used to create the buffer\r\n     */\r\n    constructor(engine: AbstractEngine, data: DataArray | Buffer | DataBuffer, kind: string, options?: IVertexBufferOptions);\r\n\r\n    /** @internal */\r\n    constructor(\r\n        engine: AbstractEngine,\r\n        data: DataArray | Buffer | DataBuffer,\r\n        kind: string,\r\n        updatableOrOptions?: boolean | IVertexBufferOptions,\r\n        postponeInternalCreation?: boolean,\r\n        stride?: number,\r\n        instanced?: boolean,\r\n        offset?: number,\r\n        size?: number,\r\n        type?: number,\r\n        normalized = false,\r\n        useBytes = false,\r\n        divisor = 1,\r\n        takeBufferOwnership = false\r\n    ) {\r\n        let updatable = false;\r\n\r\n        this.engine = engine;\r\n\r\n        if (typeof updatableOrOptions === \"object\" && updatableOrOptions !== null) {\r\n            updatable = updatableOrOptions.updatable ?? false;\r\n            postponeInternalCreation = updatableOrOptions.postponeInternalCreation;\r\n            stride = updatableOrOptions.stride;\r\n            instanced = updatableOrOptions.instanced;\r\n            offset = updatableOrOptions.offset;\r\n            size = updatableOrOptions.size;\r\n            type = updatableOrOptions.type;\r\n            normalized = updatableOrOptions.normalized ?? false;\r\n            useBytes = updatableOrOptions.useBytes ?? false;\r\n            divisor = updatableOrOptions.divisor ?? 1;\r\n            takeBufferOwnership = updatableOrOptions.takeBufferOwnership ?? false;\r\n            this._label = updatableOrOptions.label;\r\n        } else {\r\n            updatable = !!updatableOrOptions;\r\n        }\r\n\r\n        if (data instanceof Buffer) {\r\n            this._buffer = data;\r\n            this._ownsBuffer = takeBufferOwnership;\r\n        } else {\r\n            this._buffer = new Buffer(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes, divisor, this._label);\r\n            this._ownsBuffer = true;\r\n        }\r\n\r\n        this.uniqueId = VertexBuffer._Counter++;\r\n        this._kind = kind;\r\n\r\n        if (type === undefined) {\r\n            const vertexData = this.getData();\r\n            this.type = vertexData ? VertexBuffer.GetDataType(vertexData) : VertexBuffer.FLOAT;\r\n        } else {\r\n            this.type = type;\r\n        }\r\n\r\n        const typeByteLength = GetTypeByteLength(this.type);\r\n\r\n        if (useBytes) {\r\n            this._size = size || (stride ? stride / typeByteLength : VertexBuffer.DeduceStride(kind));\r\n            this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;\r\n            this.byteOffset = offset || 0;\r\n        } else {\r\n            this._size = size || stride || VertexBuffer.DeduceStride(kind);\r\n            this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;\r\n            this.byteOffset = (offset || 0) * typeByteLength;\r\n        }\r\n\r\n        this.normalized = normalized;\r\n\r\n        this._instanced = instanced !== undefined ? instanced : false;\r\n        this._instanceDivisor = instanced ? divisor : 0;\r\n\r\n        this._alignBuffer();\r\n        this._computeHashCode();\r\n    }\r\n\r\n    private _computeHashCode(): void {\r\n        // note: cast to any because the property is declared readonly\r\n        (this.hashCode as any) =\r\n            ((this.type - 5120) << 0) +\r\n            ((this.normalized ? 1 : 0) << 3) +\r\n            (this._size << 4) +\r\n            ((this._instanced ? 1 : 0) << 6) +\r\n            /* keep 5 bits free */\r\n            (this.byteStride << 12);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this._buffer?._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Returns the kind of the VertexBuffer (string)\r\n     * @returns a string\r\n     */\r\n    public getKind(): string {\r\n        return this._kind;\r\n    }\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets a boolean indicating if the VertexBuffer is updatable?\r\n     * @returns true if the buffer is updatable\r\n     */\r\n    public isUpdatable(): boolean {\r\n        return this._buffer.isUpdatable();\r\n    }\r\n\r\n    /**\r\n     * Gets the raw data from the underlying buffer.\r\n     * Note: The data may include more than just this vertex buffer's values.\r\n     * @returns the buffer data as a DataArray, or null.\r\n     */\r\n    public getData(): Nullable<DataArray> {\r\n        return this._buffer.getData();\r\n    }\r\n\r\n    /**\r\n     * Gets this vertex buffer's data as a float array. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param totalVertices number of vertices in the buffer to take into account\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    public getFloatData(totalVertices: number, forceCopy?: boolean): Nullable<FloatArray> {\r\n        const data = this.getData();\r\n        if (!data) {\r\n            return null;\r\n        }\r\n\r\n        return GetFloatData(data, this._size, this.type, this.byteOffset, this.byteStride, this.normalized, totalVertices, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Gets underlying native buffer\r\n     * @returns underlying native buffer\r\n     */\r\n    public getBuffer(): Nullable<DataBuffer> {\r\n        return this._buffer.getBuffer();\r\n    }\r\n\r\n    /**\r\n     * Gets the Buffer instance that wraps the native GPU buffer\r\n     * @returns the wrapper buffer\r\n     */\r\n    public getWrapperBuffer(): Buffer {\r\n        return this._buffer;\r\n    }\r\n\r\n    /**\r\n     * Gets the stride in float32 units (i.e. byte stride / 4).\r\n     * May not be an integer if the byte stride is not divisible by 4.\r\n     * @returns the stride in float32 units\r\n     * @deprecated Please use byteStride instead.\r\n     */\r\n    public getStrideSize(): number {\r\n        return this.byteStride / GetTypeByteLength(this.type);\r\n    }\r\n\r\n    /**\r\n     * Returns the offset as a multiple of the type byte length.\r\n     * @returns the offset in bytes\r\n     * @deprecated Please use byteOffset instead.\r\n     */\r\n    public getOffset(): number {\r\n        return this.byteOffset / GetTypeByteLength(this.type);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of components or the byte size per vertex attribute\r\n     * @param sizeInBytes If true, returns the size in bytes or else the size in number of components of the vertex attribute (default: false)\r\n     * @returns the number of components\r\n     */\r\n    public getSize(sizeInBytes = false): number {\r\n        return sizeInBytes ? this._size * GetTypeByteLength(this.type) : this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating is the internal buffer of the VertexBuffer is instanced\r\n     * @returns true if this buffer is instanced\r\n     */\r\n    public getIsInstanced(): boolean {\r\n        return this._instanced;\r\n    }\r\n\r\n    /**\r\n     * Returns the instancing divisor, zero for non-instanced (integer).\r\n     * @returns a number\r\n     */\r\n    public getInstanceDivisor(): number {\r\n        return this._instanceDivisor;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property\r\n     * @param data defines the data to store\r\n     */\r\n    public create(data?: DataArray): void {\r\n        this._buffer.create(data);\r\n        this._alignBuffer();\r\n    }\r\n\r\n    /**\r\n     * Updates the underlying buffer according to the passed numeric array or Float32Array.\r\n     * This function will create a new buffer if the current one is not updatable\r\n     * @param data defines the data to store\r\n     */\r\n    public update(data: DataArray): void {\r\n        this._buffer.update(data);\r\n        this._alignBuffer();\r\n    }\r\n\r\n    /**\r\n     * Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.\r\n     * Returns the directly updated WebGLBuffer.\r\n     * @param data the new data\r\n     * @param offset the new offset\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    public updateDirectly(data: DataArray, offset: number, useBytes: boolean = false): void {\r\n        this._buffer.updateDirectly(data, offset, undefined, useBytes);\r\n        this._alignBuffer();\r\n    }\r\n\r\n    /**\r\n     * Disposes the VertexBuffer and the underlying WebGLBuffer.\r\n     */\r\n    public dispose(): void {\r\n        if (this._ownsBuffer) {\r\n            this._buffer.dispose();\r\n        }\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * Enumerates each value of this vertex buffer as numbers.\r\n     * @param count the number of values to enumerate\r\n     * @param callback the callback function called for each value\r\n     */\r\n    public forEach(count: number, callback: (value: number, index: number) => void): void {\r\n        EnumerateFloatValues(this._buffer.getData()!, this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, (values, index) => {\r\n            for (let i = 0; i < this._size; i++) {\r\n                callback(values[i], index + i);\r\n            }\r\n        });\r\n    }\r\n\r\n    /** @internal */\r\n    public _alignBuffer() {}\r\n\r\n    // Enums\r\n    /**\r\n     * Positions\r\n     */\r\n    public static readonly PositionKind = Constants.PositionKind;\r\n    /**\r\n     * Normals\r\n     */\r\n    public static readonly NormalKind = Constants.NormalKind;\r\n    /**\r\n     * Tangents\r\n     */\r\n    public static readonly TangentKind = Constants.TangentKind;\r\n    /**\r\n     * Texture coordinates\r\n     */\r\n    public static readonly UVKind = Constants.UVKind;\r\n    /**\r\n     * Texture coordinates 2\r\n     */\r\n    public static readonly UV2Kind = Constants.UV2Kind;\r\n    /**\r\n     * Texture coordinates 3\r\n     */\r\n    public static readonly UV3Kind = Constants.UV3Kind;\r\n    /**\r\n     * Texture coordinates 4\r\n     */\r\n    public static readonly UV4Kind = Constants.UV4Kind;\r\n    /**\r\n     * Texture coordinates 5\r\n     */\r\n    public static readonly UV5Kind = Constants.UV5Kind;\r\n    /**\r\n     * Texture coordinates 6\r\n     */\r\n    public static readonly UV6Kind = Constants.UV6Kind;\r\n    /**\r\n     * Colors\r\n     */\r\n    public static readonly ColorKind = Constants.ColorKind;\r\n    /**\r\n     * Instance Colors\r\n     */\r\n    public static readonly ColorInstanceKind = Constants.ColorInstanceKind;\r\n    /**\r\n     * Matrix indices (for bones)\r\n     */\r\n    public static readonly MatricesIndicesKind = Constants.MatricesIndicesKind;\r\n    /**\r\n     * Matrix weights (for bones)\r\n     */\r\n    public static readonly MatricesWeightsKind = Constants.MatricesWeightsKind;\r\n    /**\r\n     * Additional matrix indices (for bones)\r\n     */\r\n    public static readonly MatricesIndicesExtraKind = Constants.MatricesIndicesExtraKind;\r\n    /**\r\n     * Additional matrix weights (for bones)\r\n     */\r\n    public static readonly MatricesWeightsExtraKind = Constants.MatricesWeightsExtraKind;\r\n\r\n    /**\r\n     * Deduces the stride given a kind.\r\n     * @param kind The kind string to deduce\r\n     * @returns The deduced stride\r\n     */\r\n    public static DeduceStride(kind: string): number {\r\n        switch (kind) {\r\n            case VertexBuffer.UVKind:\r\n            case VertexBuffer.UV2Kind:\r\n            case VertexBuffer.UV3Kind:\r\n            case VertexBuffer.UV4Kind:\r\n            case VertexBuffer.UV5Kind:\r\n            case VertexBuffer.UV6Kind:\r\n                return 2;\r\n            case VertexBuffer.NormalKind:\r\n            case VertexBuffer.PositionKind:\r\n                return 3;\r\n            case VertexBuffer.ColorKind:\r\n            case VertexBuffer.ColorInstanceKind:\r\n            case VertexBuffer.MatricesIndicesKind:\r\n            case VertexBuffer.MatricesIndicesExtraKind:\r\n            case VertexBuffer.MatricesWeightsKind:\r\n            case VertexBuffer.MatricesWeightsExtraKind:\r\n            case VertexBuffer.TangentKind:\r\n                return 4;\r\n            default:\r\n                throw new Error(\"Invalid kind '\" + kind + \"'\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex buffer type of the given data array.\r\n     * @param data the data array\r\n     * @returns the vertex buffer type\r\n     */\r\n    public static GetDataType(data: DataArray): number {\r\n        if (data instanceof Int8Array) {\r\n            return VertexBuffer.BYTE;\r\n        } else if (data instanceof Uint8Array) {\r\n            return VertexBuffer.UNSIGNED_BYTE;\r\n        } else if (data instanceof Int16Array) {\r\n            return VertexBuffer.SHORT;\r\n        } else if (data instanceof Uint16Array) {\r\n            return VertexBuffer.UNSIGNED_SHORT;\r\n        } else if (data instanceof Int32Array) {\r\n            return VertexBuffer.INT;\r\n        } else if (data instanceof Uint32Array) {\r\n            return VertexBuffer.UNSIGNED_INT;\r\n        } else {\r\n            return VertexBuffer.FLOAT;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the byte length of the given type.\r\n     * @param type the type\r\n     * @returns the number of bytes\r\n     * @deprecated Use `getTypeByteLength` from `bufferUtils` instead\r\n     */\r\n    public static GetTypeByteLength(type: number): number {\r\n        return GetTypeByteLength(type);\r\n    }\r\n\r\n    /**\r\n     * Enumerates each value of the given parameters as numbers.\r\n     * @param data the data to enumerate\r\n     * @param byteOffset the byte offset of the data\r\n     * @param byteStride the byte stride of the data\r\n     * @param componentCount the number of components per element\r\n     * @param componentType the type of the component\r\n     * @param count the number of values to enumerate\r\n     * @param normalized whether the data is normalized\r\n     * @param callback the callback function called for each value\r\n     * @deprecated Use `EnumerateFloatValues` from `bufferUtils` instead\r\n     */\r\n    public static ForEach(\r\n        data: DataArray,\r\n        byteOffset: number,\r\n        byteStride: number,\r\n        componentCount: number,\r\n        componentType: number,\r\n        count: number,\r\n        normalized: boolean,\r\n        callback: (value: number, index: number) => void\r\n    ): void {\r\n        EnumerateFloatValues(data, byteOffset, byteStride, componentCount, componentType, count, normalized, (values, index) => {\r\n            for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                callback(values[componentIndex], index + componentIndex);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the given data array as a float array. Float data is constructed if the data array cannot be returned directly.\r\n     * @param data the input data array\r\n     * @param size the number of components\r\n     * @param type the component type\r\n     * @param byteOffset the byte offset of the data\r\n     * @param byteStride the byte stride of the data\r\n     * @param normalized whether the data is normalized\r\n     * @param totalVertices number of vertices in the buffer to take into account\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     * @deprecated Use `GetFloatData` from `bufferUtils` instead\r\n     */\r\n    public static GetFloatData(\r\n        data: DataArray,\r\n        size: number,\r\n        type: number,\r\n        byteOffset: number,\r\n        byteStride: number,\r\n        normalized: boolean,\r\n        totalVertices: number,\r\n        forceCopy?: boolean\r\n    ): FloatArray {\r\n        return GetFloatData(data, size, type, byteOffset, byteStride, normalized, totalVertices, forceCopy);\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
