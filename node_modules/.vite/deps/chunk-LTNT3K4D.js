import {
  init_clusteredLightingFunctions
} from "./chunk-ZC27AFOZ.js";
import {
  init_sceneVertexDeclaration
} from "./chunk-MR4MHZDR.js";
import {
  init_sceneUboDeclaration
} from "./chunk-24OONKND.js";
import {
  ShaderStore,
  init_shaderStore
} from "./chunk-4OYBTWIA.js";
import {
  __esm
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@babylonjs/core/Shaders/lightProxy.vertex.js
var name, shader, lightProxyVertexShader;
var init_lightProxy_vertex = __esm({
  "node_modules/@babylonjs/core/Shaders/lightProxy.vertex.js"() {
    init_shaderStore();
    init_sceneVertexDeclaration();
    init_sceneUboDeclaration();
    init_clusteredLightingFunctions();
    name = "lightProxyVertexShader";
    shader = `attribute vec3 position;flat varying vec2 vLimits;flat varying highp uint vMask;
#include<__decl__sceneVertex>
uniform sampler2D lightDataTexture;uniform vec3 tileMaskResolution;
#include<clusteredLightingFunctions>
void main(void) {ClusteredLight light=getClusteredLight(lightDataTexture,gl_InstanceID);float range=light.vLightFalloff.x;vec4 viewPosition=view*vec4(light.vLightData.xyz,1);vec4 viewPositionSq=viewPosition*viewPosition;vec2 distSq=viewPositionSq.xy+viewPositionSq.z;vec2 sinSq=(range*range)/distSq;vec2 cosSq=max(1.0-sinSq,0.01);vec2 sinCos=position.xy*sqrt(sinSq*cosSq);
#ifdef RIGHT_HANDED
vec2 rotatedX=mat2(cosSq.x,sinCos.x,-sinCos.x,cosSq.x)*viewPosition.xz;vec2 rotatedY=mat2(cosSq.y,sinCos.y,-sinCos.y,cosSq.y)*viewPosition.yz;
#else
vec2 rotatedX=mat2(cosSq.x,-sinCos.x,sinCos.x,cosSq.x)*viewPosition.xz;vec2 rotatedY=mat2(cosSq.y,-sinCos.y,sinCos.y,cosSq.y)*viewPosition.yz;
#endif
vec4 projX=projection*vec4(rotatedX.x,0,rotatedX.y,1);vec4 projY=projection*vec4(0,rotatedY.x,rotatedY.y,1);vec2 projPosition=vec2(projX.x/max(projX.w,0.01),projY.y/max(projY.w,0.01));projPosition=mix(position.xy,projPosition,greaterThan(cosSq,vec2(0.01)));vec2 halfTileRes=tileMaskResolution.xy/2.0;vec2 tilePosition=(projPosition+1.0)*halfTileRes;tilePosition=mix(floor(tilePosition)-0.01,ceil(tilePosition)+0.01,greaterThan(position.xy,vec2(0)));float offset=float(gl_InstanceID/CLUSTLIGHT_BATCH)*tileMaskResolution.y;tilePosition.y=(tilePosition.y+offset)/tileMaskResolution.z;gl_Position=vec4(tilePosition/halfTileRes-1.0,0,1);vLimits=vec2(offset,offset+tileMaskResolution.y);vMask=1u<<(gl_InstanceID % CLUSTLIGHT_BATCH);}
`;
    if (!ShaderStore.ShadersStore[name]) {
      ShaderStore.ShadersStore[name] = shader;
    }
    lightProxyVertexShader = { name, shader };
  }
});

export {
  lightProxyVertexShader,
  init_lightProxy_vertex
};
//# sourceMappingURL=chunk-LTNT3K4D.js.map
