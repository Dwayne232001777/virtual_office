import {
  CreateConstantInput,
  CreateRGBAConfiguration,
  CreateTextureInput,
  GreasedLineBaseMesh,
  MergeTexturesAsync,
  SpecularPowerToRoughness,
  init_greasedLineBaseMesh,
  init_materialConversionHelper,
  init_textureMerger
} from "./chunk-U2PPL777.js";
import {
  Camera,
  Constants,
  InstancedMesh,
  Light,
  LinesMesh,
  Mesh,
  MorphTarget,
  MultiMaterial,
  OpenPBRMaterial,
  PBRBaseMaterial,
  RawTexture,
  Scalar,
  StandardMaterial,
  TargetCamera,
  init_camera,
  init_constants,
  init_instancedMesh,
  init_light,
  init_linesMesh,
  init_math_scalar,
  init_mesh,
  init_morphTarget,
  init_multiMaterial,
  init_openpbrMaterial,
  init_pbrBaseMaterial,
  init_rawTexture,
  init_standardMaterial,
  init_targetCamera
} from "./chunk-JWLZD23T.js";
import {
  Material,
  init_material
} from "./chunk-OBADV6JF.js";
import {
  AbstractMesh,
  TransformNode,
  init_abstractMesh,
  init_transformNode
} from "./chunk-TMHG26QH.js";
import "./chunk-JTDOLEW4.js";
import {
  Animation,
  init_animation
} from "./chunk-IPODAMC3.js";
import "./chunk-E7XHG63E.js";
import "./chunk-R3NLUQNA.js";
import "./chunk-Y5XTKMAE.js";
import "./chunk-ESGOHTGL.js";
import "./chunk-U45B254N.js";
import "./chunk-CCNHJS5Q.js";
import "./chunk-FV6YI4DO.js";
import "./chunk-KEMNSKWR.js";
import "./chunk-3DVETICX.js";
import "./chunk-ETNKJY4V.js";
import {
  EncodeImageAsync,
  init_dumpTools
} from "./chunk-RSNSIAVI.js";
import "./chunk-XXTMV5AV.js";
import {
  Engine,
  GetTextureDataAsync,
  TextureTools,
  init_engine,
  init_textureTools
} from "./chunk-E2UXTG46.js";
import "./chunk-2EZNXTHP.js";
import "./chunk-XUMUHFKD.js";
import "./chunk-3V3ZT36M.js";
import "./chunk-TYVCVQQX.js";
import "./chunk-TZ4U7RDF.js";
import "./chunk-WJTQGE6H.js";
import "./chunk-4L5VDV4X.js";
import "./chunk-NER52ESJ.js";
import {
  VertexBuffer,
  init_buffer
} from "./chunk-YEEYUO2W.js";
import "./chunk-BXP5BQWR.js";
import "./chunk-IIY2JHNQ.js";
import "./chunk-LNXOCKX5.js";
import {
  Texture,
  init_texture
} from "./chunk-W2Z3EUIE.js";
import "./chunk-6DIPKSGI.js";
import "./chunk-HNJVWIJU.js";
import {
  Color3,
  Color4,
  init_math_color
} from "./chunk-FQA5U7KF.js";
import "./chunk-KU6EWKFQ.js";
import {
  Tools,
  init_tools
} from "./chunk-TQMUJQOB.js";
import {
  AreIndices32Bits,
  EnumerateFloatValues,
  GetMimeType,
  init_bufferUtils,
  init_fileTools
} from "./chunk-X7JT3LZV.js";
import "./chunk-T55R2ONV.js";
import "./chunk-PSHGEZXL.js";
import "./chunk-WTQMXJ7P.js";
import "./chunk-HCT32MRG.js";
import "./chunk-4OYBTWIA.js";
import {
  Epsilon,
  Matrix,
  Quaternion,
  TmpVectors,
  Vector3,
  Vector4,
  init_math_constants,
  init_math_vector
} from "./chunk-VQZCJUUR.js";
import "./chunk-7ANHXSNA.js";
import "./chunk-YU3PZQGE.js";
import {
  EngineStore,
  init_engineStore
} from "./chunk-TS7QJBPS.js";
import "./chunk-XBFJXXXT.js";
import {
  Logger,
  init_logger
} from "./chunk-2X44KPCK.js";
import "./chunk-PY47FUFT.js";
import "./chunk-V4OQ3NZ2.js";

// node_modules/@babylonjs/serializers/glTF/2.0/glTFExporter.js
init_math_vector();
init_tools();
init_buffer();
init_transformNode();
init_abstractMesh();
init_instancedMesh();
init_material();
init_engine();
init_engineStore();

// node_modules/@babylonjs/serializers/glTF/2.0/glTFMaterialExporter.js
init_math_color();
init_math_scalar();
init_tools();
init_textureTools();
init_texture();
init_rawTexture();
init_constants();
init_dumpTools();
init_pbrBaseMaterial();
init_materialConversionHelper();
init_fileTools();
init_openpbrMaterial();
init_textureMerger();
var Epsilon2 = 1e-6;
var DielectricSpecular = new Color3(0.04, 0.04, 0.04);
var MaxSpecularPower = 1024;
var White = Color3.White();
var Black = Color3.BlackReadOnly;
function GetFileExtensionFromMimeType(mimeType) {
  switch (mimeType) {
    case "image/jpeg":
      return ".jpg";
    case "image/png":
      return ".png";
    case "image/webp":
      return ".webp";
    case "image/avif":
      return ".avif";
    case "image/ktx2":
      return ".ktx2";
  }
}
function IsSupportedMimeType(mimeType) {
  switch (mimeType) {
    case "image/jpeg":
    case "image/png":
    case "image/webp":
    case "image/avif":
    case "image/ktx2":
      return true;
    default:
      return false;
  }
}
async function GetCachedImageAsync(babylonTexture) {
  const internalTexture = babylonTexture.getInternalTexture();
  if (!internalTexture || internalTexture.source !== 1) {
    return null;
  }
  if (internalTexture.invertY) {
    return null;
  }
  const buffer = internalTexture._buffer;
  let data;
  let mimeType = babylonTexture.mimeType;
  try {
    if (!buffer) {
      data = await Tools.LoadFileAsync(internalTexture.url);
      mimeType = GetMimeType(internalTexture.url) || mimeType;
    } else if (ArrayBuffer.isView(buffer)) {
      data = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
    } else if (buffer instanceof ArrayBuffer) {
      data = buffer;
    } else if (buffer instanceof Blob) {
      data = await buffer.arrayBuffer();
      mimeType = buffer.type || mimeType;
    } else if (typeof buffer === "string") {
      data = await Tools.LoadFileAsync(buffer);
      mimeType = GetMimeType(buffer) || mimeType;
    } else if (typeof HTMLImageElement !== "undefined" && buffer instanceof HTMLImageElement) {
      data = await Tools.LoadFileAsync(buffer.src);
      mimeType = GetMimeType(buffer.src) || mimeType;
    }
  } catch {
    return null;
  }
  if (data && IsSupportedMimeType(mimeType)) {
    return new Blob([data], { type: mimeType });
  }
  return null;
}
function _SolveMetallic(diffuse, specular, oneMinusSpecularStrength) {
  if (specular < DielectricSpecular.r) {
    return 0;
  }
  const a = DielectricSpecular.r;
  const b = diffuse * oneMinusSpecularStrength / (1 - DielectricSpecular.r) + specular - 2 * DielectricSpecular.r;
  const c = DielectricSpecular.r - specular;
  const d = b * b - 4 * a * c;
  return Scalar.Clamp((-b + Math.sqrt(d)) / (2 * a), 0, 1);
}
function _ConvertToGLTFPBRMetallicRoughness(babylonStandardMaterial) {
  const diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace(babylonStandardMaterial.getScene().getEngine().useExactSrgbConversions).scale(0.5);
  const opacity = babylonStandardMaterial.alpha;
  const specularPower = Scalar.Clamp(babylonStandardMaterial.specularPower, 0, MaxSpecularPower);
  const roughness = SpecularPowerToRoughness(specularPower);
  const glTFPbrMetallicRoughness = {
    baseColorFactor: [diffuse.r, diffuse.g, diffuse.b, opacity],
    metallicFactor: 0,
    roughnessFactor: roughness
  };
  return glTFPbrMetallicRoughness;
}
function SetAlphaMode(glTFMaterial, babylonMaterial) {
  if (babylonMaterial.needAlphaBlending()) {
    glTFMaterial.alphaMode = "BLEND";
  } else if (babylonMaterial.needAlphaTesting()) {
    glTFMaterial.alphaMode = "MASK";
    glTFMaterial.alphaCutoff = babylonMaterial.alphaCutOff;
  }
}
function CreateWhiteTexture(width, height, scene) {
  const data = new Uint8Array(width * height * 4);
  for (let i = 0; i < data.length; i = i + 4) {
    data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 255;
  }
  const rawTexture = RawTexture.CreateRGBATexture(data, width, height, scene);
  return rawTexture;
}
function ConvertPixelArrayToFloat32(pixels) {
  if (pixels instanceof Uint8Array) {
    const length = pixels.length;
    const buffer = new Float32Array(pixels.length);
    for (let i = 0; i < length; ++i) {
      buffer[i] = pixels[i] / 255;
    }
    return buffer;
  } else if (pixels instanceof Float32Array) {
    return pixels;
  } else {
    throw new Error("Unsupported pixel format!");
  }
}
var GLTFMaterialExporter = class {
  constructor(_exporter) {
    this._exporter = _exporter;
    this._textureMap = /* @__PURE__ */ new Map();
    this._internalTextureToImage = {};
  }
  getTextureInfo(babylonTexture) {
    return babylonTexture ? this._textureMap.get(babylonTexture.uniqueId) ?? null : null;
  }
  async exportStandardMaterialAsync(babylonStandardMaterial, hasUVs) {
    const pbrMetallicRoughness = _ConvertToGLTFPBRMetallicRoughness(babylonStandardMaterial);
    const material = { name: babylonStandardMaterial.name };
    if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {
      if (!babylonStandardMaterial.twoSidedLighting) {
        Tools.Warn(babylonStandardMaterial.name + ": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.");
      }
      material.doubleSided = true;
    }
    if (hasUVs) {
      const promises = [];
      const diffuseTexture = babylonStandardMaterial.diffuseTexture;
      if (diffuseTexture) {
        promises.push(this.exportTextureAsync(diffuseTexture).then((textureInfo) => {
          if (textureInfo) {
            pbrMetallicRoughness.baseColorTexture = textureInfo;
          }
        }));
      }
      const bumpTexture = babylonStandardMaterial.bumpTexture;
      if (bumpTexture) {
        promises.push(this.exportTextureAsync(bumpTexture).then((textureInfo) => {
          if (textureInfo) {
            material.normalTexture = textureInfo;
            if (bumpTexture.level !== 1) {
              material.normalTexture.scale = bumpTexture.level;
            }
          }
        }));
      }
      const emissiveTexture = babylonStandardMaterial.emissiveTexture;
      if (emissiveTexture) {
        material.emissiveFactor = [1, 1, 1];
        promises.push(this.exportTextureAsync(emissiveTexture).then((textureInfo) => {
          if (textureInfo) {
            material.emissiveTexture = textureInfo;
          }
        }));
      }
      const ambientTexture = babylonStandardMaterial.ambientTexture;
      if (ambientTexture) {
        promises.push(this.exportTextureAsync(ambientTexture).then((textureInfo) => {
          if (textureInfo) {
            const occlusionTexture = {
              index: textureInfo.index
            };
            material.occlusionTexture = occlusionTexture;
          }
        }));
      }
      if (promises.length > 0) {
        this._exporter._materialNeedsUVsSet.add(babylonStandardMaterial);
        await Promise.all(promises);
      }
    }
    if (babylonStandardMaterial.alpha < 1 || babylonStandardMaterial.opacityTexture) {
      if (babylonStandardMaterial.alphaMode === Constants.ALPHA_COMBINE) {
        material.alphaMode = "BLEND";
      } else {
        Tools.Warn(babylonStandardMaterial.name + ": glTF 2.0 does not support alpha mode: " + babylonStandardMaterial.alphaMode.toString());
      }
    }
    if (babylonStandardMaterial.emissiveColor && !babylonStandardMaterial.emissiveColor.equalsWithEpsilon(Black, Epsilon2)) {
      material.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();
    }
    material.pbrMetallicRoughness = pbrMetallicRoughness;
    SetAlphaMode(material, babylonStandardMaterial);
    await this._finishMaterialAsync(material, babylonStandardMaterial);
    const materials = this._exporter._materials;
    materials.push(material);
    return materials.length - 1;
  }
  async _finishMaterialAsync(glTFMaterial, babylonMaterial) {
    const textures = await this._exporter._extensionsPostExportMaterialAdditionalTexturesAsync("exportMaterial", glTFMaterial, babylonMaterial);
    const promises = [];
    for (const texture of textures) {
      promises.push(this.exportTextureAsync(texture));
    }
    await Promise.all(promises);
    await this._exporter._extensionsPostExportMaterialAsync("exportMaterial", glTFMaterial, babylonMaterial);
  }
  /**
   * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null
   * @param texture1 first texture to resize
   * @param texture2 second texture to resize
   * @param scene babylonjs scene
   * @returns resized textures or null
   */
  _resizeTexturesToSameDimensions(texture1, texture2, scene) {
    const texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };
    const texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };
    let resizedTexture1;
    let resizedTexture2;
    if (texture1Size.width < texture2Size.width) {
      if (texture1 && texture1 instanceof Texture) {
        resizedTexture1 = TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);
      } else {
        resizedTexture1 = CreateWhiteTexture(texture2Size.width, texture2Size.height, scene);
      }
      resizedTexture2 = texture2;
    } else if (texture1Size.width > texture2Size.width) {
      if (texture2 && texture2 instanceof Texture) {
        resizedTexture2 = TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);
      } else {
        resizedTexture2 = CreateWhiteTexture(texture1Size.width, texture1Size.height, scene);
      }
      resizedTexture1 = texture1;
    } else {
      resizedTexture1 = texture1;
      resizedTexture2 = texture2;
    }
    return {
      texture1: resizedTexture1,
      texture2: resizedTexture2
    };
  }
  /**
   * Convert Specular Glossiness Textures to Metallic Roughness
   * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness
   * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-.js/babylon.pbrUtilities.js
   * @param diffuseTexture texture used to store diffuse information
   * @param specularGlossinessTexture texture used to store specular and glossiness information
   * @param factors specular glossiness material factors
   * @returns pbr metallic roughness interface or null
   */
  async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(diffuseTexture, specularGlossinessTexture, factors) {
    const promises = new Array();
    if (!(diffuseTexture || specularGlossinessTexture)) {
      return await Promise.reject("diffuse and specular glossiness textures are not defined!");
    }
    const scene = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;
    if (scene) {
      const resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);
      const diffuseSize = resizedTextures.texture1?.getSize();
      let diffuseBuffer;
      let specularGlossinessBuffer;
      const width = diffuseSize.width;
      const height = diffuseSize.height;
      const diffusePixels = await resizedTextures.texture1.readPixels();
      const specularPixels = await resizedTextures.texture2.readPixels();
      if (diffusePixels) {
        diffuseBuffer = ConvertPixelArrayToFloat32(diffusePixels);
      } else {
        return await Promise.reject("Failed to retrieve pixels from diffuse texture!");
      }
      if (specularPixels) {
        specularGlossinessBuffer = ConvertPixelArrayToFloat32(specularPixels);
      } else {
        return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");
      }
      const byteLength = specularGlossinessBuffer.byteLength;
      const metallicRoughnessBuffer = new Uint8Array(byteLength);
      const baseColorBuffer = new Uint8Array(byteLength);
      const strideSize = 4;
      const maxBaseColor = new Color3(0, 0, 0);
      let maxMetallic = 0;
      let maxRoughness = 0;
      for (let h = 0; h < height; ++h) {
        for (let w = 0; w < width; ++w) {
          const offset = (width * h + w) * strideSize;
          const diffuseColor = new Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2]).toLinearSpace(scene.getEngine().useExactSrgbConversions).multiply(factors.diffuseColor);
          const specularColor = new Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2]).toLinearSpace(scene.getEngine().useExactSrgbConversions).multiply(factors.specularColor);
          const glossiness = specularGlossinessBuffer[offset + 3] * factors.glossiness;
          const specularGlossiness = {
            diffuseColor,
            specularColor,
            glossiness
          };
          const metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);
          maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);
          maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);
          maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);
          maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic);
          maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness);
          baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;
          baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;
          baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;
          baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;
          metallicRoughnessBuffer[offset] = 0;
          metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness * 255;
          metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic * 255;
          metallicRoughnessBuffer[offset + 3] = 255;
        }
      }
      const metallicRoughnessFactors = {
        baseColor: maxBaseColor,
        metallic: maxMetallic,
        roughness: maxRoughness
      };
      let writeOutMetallicRoughnessTexture = false;
      let writeOutBaseColorTexture = false;
      for (let h = 0; h < height; ++h) {
        for (let w = 0; w < width; ++w) {
          const destinationOffset = (width * h + w) * strideSize;
          baseColorBuffer[destinationOffset] /= metallicRoughnessFactors.baseColor.r > Epsilon2 ? metallicRoughnessFactors.baseColor.r : 1;
          baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors.baseColor.g > Epsilon2 ? metallicRoughnessFactors.baseColor.g : 1;
          baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors.baseColor.b > Epsilon2 ? metallicRoughnessFactors.baseColor.b : 1;
          const linearBaseColorPixel = Color3.FromInts(baseColorBuffer[destinationOffset], baseColorBuffer[destinationOffset + 1], baseColorBuffer[destinationOffset + 2]);
          const sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace(scene.getEngine().useExactSrgbConversions);
          baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;
          baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;
          baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;
          if (!sRGBBaseColorPixel.equalsWithEpsilon(White, Epsilon2)) {
            writeOutBaseColorTexture = true;
          }
          metallicRoughnessBuffer[destinationOffset + 1] /= metallicRoughnessFactors.roughness > Epsilon2 ? metallicRoughnessFactors.roughness : 1;
          metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors.metallic > Epsilon2 ? metallicRoughnessFactors.metallic : 1;
          const metallicRoughnessPixel = Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);
          if (!metallicRoughnessPixel.equalsWithEpsilon(White, Epsilon2)) {
            writeOutMetallicRoughnessTexture = true;
          }
        }
      }
      if (writeOutMetallicRoughnessTexture) {
        promises.push(EncodeImageAsync(metallicRoughnessBuffer, width, height).then((data) => {
          metallicRoughnessFactors.metallicRoughnessTextureData = data;
        }));
      }
      if (writeOutBaseColorTexture) {
        promises.push(EncodeImageAsync(baseColorBuffer, width, height).then((data) => {
          metallicRoughnessFactors.baseColorTextureData = data;
        }));
      }
      return await Promise.all(promises).then(() => {
        return metallicRoughnessFactors;
      });
    } else {
      return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!");
    }
  }
  /**
   * Converts specular glossiness material properties to metallic roughness
   * @param specularGlossiness interface with specular glossiness material properties
   * @returns interface with metallic roughness material properties
   */
  _convertSpecularGlossinessToMetallicRoughness(specularGlossiness) {
    const diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);
    const specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);
    const oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);
    const metallic = _SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);
    const baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(oneMinusSpecularStrength / (1 - DielectricSpecular.r) / Math.max(1 - metallic, Epsilon2));
    const baseColorFromSpecular = specularGlossiness.specularColor.subtract(DielectricSpecular.scale(1 - metallic)).scale(1 / Math.max(metallic, Epsilon2));
    let baseColor = Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);
    baseColor = baseColor.clampToRef(0, 1, baseColor);
    const metallicRoughness = {
      baseColor,
      metallic,
      roughness: 1 - specularGlossiness.glossiness
    };
    return metallicRoughness;
  }
  /**
   * Calculates the surface reflectance, independent of lighting conditions
   * @param color Color source to calculate brightness from
   * @returns number representing the perceived brightness, or zero if color is undefined
   */
  _getPerceivedBrightness(color) {
    return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);
  }
  /**
   * Returns the maximum color component value
   * @param color
   * @returns maximum color component value, or zero if color is null or undefined
   */
  _getMaxComponent(color) {
    return Math.max(color.r, Math.max(color.g, color.b));
  }
  /**
   * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors
   * @param baseColor Base color of the material
   * @param metallic Metallic factor of the material
   * @param roughness Roughness factor of the material
   * @param albedoTexture Albedo texture of the material
   * @param metallicTexture Metallic texture of the material
   * @param roughnessTexture Roughness texture of the material
   * @param babylonPBRMaterial BJS PBR Metallic Roughness Material
   * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface
   * @param hasUVs specifies if texture coordinates are present on the submesh to determine if textures should be applied
   * @returns glTF PBR Metallic Roughness factors
   */
  async _convertMetalRoughFactorsToMetallicRoughnessAsync(baseColor, metallic, roughness, albedoTexture, metallicTexture, roughnessTexture, babylonPBRMaterial, glTFPbrMetallicRoughness, hasUVs) {
    const promises = [];
    const metallicRoughness = {
      baseColor,
      metallic,
      roughness
    };
    if (hasUVs) {
      if (babylonPBRMaterial instanceof OpenPBRMaterial) {
        if (babylonPBRMaterial.geometryOpacityTexture) {
          const albedoId = albedoTexture && albedoTexture.getInternalTexture() ? albedoTexture.getInternalTexture().uniqueId : 0;
          const opacityId = babylonPBRMaterial.geometryOpacityTexture && babylonPBRMaterial.geometryOpacityTexture.getInternalTexture() ? babylonPBRMaterial.geometryOpacityTexture.getInternalTexture().uniqueId : 0;
          const mergedId = Number(`${albedoId}${opacityId}`);
          const glTFTexture = this._textureMap.get(mergedId);
          if (glTFTexture) {
            glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;
          } else {
            promises.push(MergeTexturesAsync("baseColorOpacityTexture", CreateRGBAConfiguration(albedoTexture ? CreateTextureInput(albedoTexture, 0) : CreateConstantInput(1), albedoTexture ? CreateTextureInput(albedoTexture, 1) : CreateConstantInput(1), albedoTexture ? CreateTextureInput(albedoTexture, 2) : CreateConstantInput(1), CreateTextureInput(babylonPBRMaterial.geometryOpacityTexture, 0)), babylonPBRMaterial.getScene()).then(async (mergedTexture) => {
              const glTFTexture2 = await this.exportTextureAsync(mergedTexture, mergedId);
              if (glTFTexture2) {
                glTFPbrMetallicRoughness.baseColorTexture = glTFTexture2;
              }
            }));
          }
        } else {
          if (albedoTexture) {
            promises.push(this.exportTextureAsync(albedoTexture).then((glTFTexture) => {
              if (glTFTexture) {
                glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;
              }
            }));
          }
        }
        if (babylonPBRMaterial._useMetallicFromMetallicTextureBlue && metallicTexture) {
          promises.push(this.exportTextureAsync(metallicTexture).then((glTFTexture) => {
            if (glTFTexture) {
              glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;
            }
          }));
        } else if (roughnessTexture || metallicTexture) {
          const metallicId = metallicTexture && metallicTexture.getInternalTexture() ? metallicTexture.getInternalTexture().uniqueId : 0;
          const roughnessId = roughnessTexture && roughnessTexture.getInternalTexture() ? roughnessTexture.getInternalTexture().uniqueId : 0;
          const mergedId = Number(`${metallicId}${roughnessId}`);
          const glTFTexture = this._textureMap.get(mergedId);
          if (glTFTexture) {
            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;
          } else {
            promises.push(MergeTexturesAsync("MetalRoughTexture", CreateRGBAConfiguration(babylonPBRMaterial.ambientOcclusionTexture ? CreateTextureInput(babylonPBRMaterial.ambientOcclusionTexture, 0) : CreateConstantInput(1), roughnessTexture ? CreateTextureInput(roughnessTexture, 0) : CreateConstantInput(1), metallicTexture ? CreateTextureInput(metallicTexture, 0) : CreateConstantInput(1)), babylonPBRMaterial.getScene()).then(async (mergedTexture) => {
              const glTFTexture2 = await this.exportTextureAsync(mergedTexture, mergedId);
              if (glTFTexture2) {
                glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture2;
              }
            }));
          }
        }
      } else {
        if (albedoTexture) {
          promises.push(this.exportTextureAsync(albedoTexture).then((glTFTexture) => {
            if (glTFTexture) {
              glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;
            }
          }));
        }
        if (metallicTexture) {
          promises.push(this.exportTextureAsync(metallicTexture).then((glTFTexture) => {
            if (glTFTexture) {
              glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;
            }
          }));
        }
      }
    }
    if (promises.length > 0) {
      this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);
      await Promise.all(promises);
    }
    return metallicRoughness;
  }
  _getTextureSampler(texture) {
    const sampler = {};
    if (!texture || !(texture instanceof Texture)) {
      return sampler;
    }
    const wrapS = this._getGLTFTextureWrapMode(texture.wrapU);
    if (wrapS !== 10497) {
      sampler.wrapS = wrapS;
    }
    const wrapT = this._getGLTFTextureWrapMode(texture.wrapV);
    if (wrapT !== 10497) {
      sampler.wrapT = wrapT;
    }
    switch (texture.samplingMode) {
      case Texture.LINEAR_LINEAR: {
        sampler.magFilter = 9729;
        sampler.minFilter = 9729;
        break;
      }
      case Texture.LINEAR_NEAREST: {
        sampler.magFilter = 9729;
        sampler.minFilter = 9728;
        break;
      }
      case Texture.NEAREST_LINEAR: {
        sampler.magFilter = 9728;
        sampler.minFilter = 9729;
        break;
      }
      case Texture.NEAREST_LINEAR_MIPLINEAR: {
        sampler.magFilter = 9728;
        sampler.minFilter = 9987;
        break;
      }
      case Texture.NEAREST_NEAREST: {
        sampler.magFilter = 9728;
        sampler.minFilter = 9728;
        break;
      }
      case Texture.NEAREST_LINEAR_MIPNEAREST: {
        sampler.magFilter = 9728;
        sampler.minFilter = 9985;
        break;
      }
      case Texture.LINEAR_NEAREST_MIPNEAREST: {
        sampler.magFilter = 9729;
        sampler.minFilter = 9984;
        break;
      }
      case Texture.LINEAR_NEAREST_MIPLINEAR: {
        sampler.magFilter = 9729;
        sampler.minFilter = 9986;
        break;
      }
      case Texture.NEAREST_NEAREST_MIPLINEAR: {
        sampler.magFilter = 9728;
        sampler.minFilter = 9986;
        break;
      }
      case Texture.LINEAR_LINEAR_MIPLINEAR: {
        sampler.magFilter = 9729;
        sampler.minFilter = 9987;
        break;
      }
      case Texture.LINEAR_LINEAR_MIPNEAREST: {
        sampler.magFilter = 9729;
        sampler.minFilter = 9985;
        break;
      }
      case Texture.NEAREST_NEAREST_MIPNEAREST: {
        sampler.magFilter = 9728;
        sampler.minFilter = 9984;
        break;
      }
    }
    return sampler;
  }
  _getGLTFTextureWrapMode(wrapMode) {
    switch (wrapMode) {
      case Texture.WRAP_ADDRESSMODE: {
        return 10497;
      }
      case Texture.CLAMP_ADDRESSMODE: {
        return 33071;
      }
      case Texture.MIRROR_ADDRESSMODE: {
        return 33648;
      }
      default: {
        Tools.Error(`Unsupported Texture Wrap Mode ${wrapMode}!`);
        return 10497;
      }
    }
  }
  /**
   * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors
   * @param babylonPBRMaterial BJS PBR Metallic Roughness Material
   * @param pbrMetallicRoughness glTF PBR Metallic Roughness interface
   * @param hasUVs specifies if texture coordinates are present on the submesh to determine if textures should be applied
   * @returns glTF PBR Metallic Roughness factors
   */
  async _convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, pbrMetallicRoughness, hasUVs) {
    const specGloss = {
      diffuseColor: babylonPBRMaterial._albedoColor,
      specularColor: babylonPBRMaterial._reflectivityColor,
      glossiness: babylonPBRMaterial._microSurface
    };
    const albedoTexture = babylonPBRMaterial._albedoTexture;
    const reflectivityTexture = babylonPBRMaterial._reflectivityTexture;
    const useMicrosurfaceFromReflectivityMapAlpha = babylonPBRMaterial._useMicroSurfaceFromReflectivityMapAlpha;
    if (reflectivityTexture && !useMicrosurfaceFromReflectivityMapAlpha) {
      return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");
    }
    if ((albedoTexture || reflectivityTexture) && hasUVs) {
      this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);
      const samplerIndex = this._exportTextureSampler(albedoTexture || reflectivityTexture);
      const metallicRoughnessFactors = await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(albedoTexture, reflectivityTexture, specGloss);
      const textures = this._exporter._textures;
      if (metallicRoughnessFactors.baseColorTextureData) {
        const imageIndex = await this._exportImageAsync(`baseColor${textures.length}`, metallicRoughnessFactors.baseColorTextureData);
        pbrMetallicRoughness.baseColorTexture = this._exportTextureInfo(imageIndex, samplerIndex, albedoTexture?.coordinatesIndex);
      }
      if (metallicRoughnessFactors.metallicRoughnessTextureData) {
        const imageIndex = await this._exportImageAsync(`metallicRoughness${textures.length}`, metallicRoughnessFactors.metallicRoughnessTextureData);
        pbrMetallicRoughness.metallicRoughnessTexture = this._exportTextureInfo(imageIndex, samplerIndex, reflectivityTexture?.coordinatesIndex);
      }
      return metallicRoughnessFactors;
    } else {
      return this._convertSpecularGlossinessToMetallicRoughness(specGloss);
    }
  }
  async exportPBRMaterialAsync(babylonPBRMaterial, hasUVs) {
    const glTFPbrMetallicRoughness = {};
    const glTFMaterial = {
      name: babylonPBRMaterial.name
    };
    const useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();
    if (useMetallicRoughness) {
      const albedoColor = babylonPBRMaterial._albedoColor;
      const alpha = babylonPBRMaterial.alpha;
      if (albedoColor) {
        glTFPbrMetallicRoughness.baseColorFactor = [albedoColor.r, albedoColor.g, albedoColor.b, alpha];
      }
    }
    const metallicRoughness = useMetallicRoughness ? await this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial._albedoColor, babylonPBRMaterial._metallic, babylonPBRMaterial._roughness, babylonPBRMaterial._albedoTexture, babylonPBRMaterial._metallicTexture, babylonPBRMaterial._metallicTexture, babylonPBRMaterial, glTFPbrMetallicRoughness, hasUVs) : await this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, glTFPbrMetallicRoughness, hasUVs);
    await this._setMetallicRoughnessPbrMaterialAsync(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, hasUVs);
    await this._finishMaterialAsync(glTFMaterial, babylonPBRMaterial);
    const materials = this._exporter._materials;
    materials.push(glTFMaterial);
    return materials.length - 1;
  }
  async _setMetallicRoughnessPbrMaterialAsync(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, hasUVs) {
    SetAlphaMode(glTFMaterial, babylonPBRMaterial);
    if (!metallicRoughness.baseColor.equalsWithEpsilon(White, Epsilon2) || !Scalar.WithinEpsilon(babylonPBRMaterial.alpha, 1, Epsilon2)) {
      glTFPbrMetallicRoughness.baseColorFactor = [metallicRoughness.baseColor.r, metallicRoughness.baseColor.g, metallicRoughness.baseColor.b, babylonPBRMaterial.alpha];
    }
    if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {
      glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;
    }
    if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {
      glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;
    }
    if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {
      if (!babylonPBRMaterial._twoSidedLighting) {
        Tools.Warn(babylonPBRMaterial.name + ": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.");
      }
      glTFMaterial.doubleSided = true;
    }
    if (hasUVs) {
      const promises = [];
      const bumpTexture = babylonPBRMaterial instanceof PBRBaseMaterial ? babylonPBRMaterial._bumpTexture : babylonPBRMaterial.geometryNormalTexture;
      if (bumpTexture) {
        promises.push(this.exportTextureAsync(bumpTexture).then((glTFTexture) => {
          if (glTFTexture) {
            glTFMaterial.normalTexture = glTFTexture;
            if (bumpTexture.level !== 1) {
              glTFMaterial.normalTexture.scale = bumpTexture.level;
            }
          }
        }));
      }
      const ambientTexture = babylonPBRMaterial instanceof PBRBaseMaterial ? babylonPBRMaterial._ambientTexture : babylonPBRMaterial.ambientOcclusionTexture;
      if (ambientTexture) {
        promises.push(new Promise(async (resolve) => {
          if (babylonPBRMaterial instanceof OpenPBRMaterial && glTFPbrMetallicRoughness.metallicRoughnessTexture) {
            const samplerIndex = this._exportTextureSampler(ambientTexture);
            const imageIndex = this._exporter._textures[glTFPbrMetallicRoughness.metallicRoughnessTexture.index].source;
            const textureInfo = this._exportTextureInfo(imageIndex, samplerIndex, ambientTexture.coordinatesIndex);
            this._textureMap.set(ambientTexture.uniqueId, textureInfo);
            this._exporter._extensionsPostExportTextures("exporter", textureInfo, ambientTexture);
            return resolve(textureInfo);
          } else {
            return resolve(await this.exportTextureAsync(ambientTexture));
          }
        }).then(async (glTFTexture) => {
          if (glTFTexture) {
            const occlusionTexture = {
              index: glTFTexture.index,
              texCoord: glTFTexture.texCoord,
              extensions: glTFTexture.extensions
            };
            glTFMaterial.occlusionTexture = occlusionTexture;
            if (babylonPBRMaterial instanceof PBRBaseMaterial) {
              occlusionTexture.strength = babylonPBRMaterial._ambientTextureStrength;
            } else {
              occlusionTexture.strength = babylonPBRMaterial.ambientOcclusionTexture.level;
            }
          }
        }));
      }
      const emissiveTexture = babylonPBRMaterial instanceof PBRBaseMaterial ? babylonPBRMaterial._emissiveTexture : babylonPBRMaterial.emissionColorTexture;
      if (emissiveTexture) {
        promises.push(this.exportTextureAsync(emissiveTexture).then((glTFTexture) => {
          if (glTFTexture) {
            glTFMaterial.emissiveTexture = glTFTexture;
          }
        }));
      }
      if (promises.length > 0) {
        this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);
        await Promise.all(promises);
      }
    }
    const emissiveColor = babylonPBRMaterial instanceof PBRBaseMaterial ? babylonPBRMaterial._emissiveColor : babylonPBRMaterial.emissionColor;
    if (!emissiveColor.equalsWithEpsilon(Black, Epsilon2)) {
      glTFMaterial.emissiveFactor = emissiveColor.asArray();
    }
    glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;
  }
  async exportOpenPBRMaterialAsync(babylonOpenPBRMaterial, hasUVs) {
    const glTFPbrMetallicRoughness = {};
    const glTFMaterial = {
      name: babylonOpenPBRMaterial.name
    };
    const albedoColor = babylonOpenPBRMaterial.baseColor;
    const alpha = babylonOpenPBRMaterial.geometryOpacity;
    if (albedoColor) {
      glTFPbrMetallicRoughness.baseColorFactor = [albedoColor.r, albedoColor.g, albedoColor.b, alpha];
    }
    const metallicRoughness = await this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonOpenPBRMaterial.baseColor, babylonOpenPBRMaterial.baseMetalness, babylonOpenPBRMaterial.specularRoughness, babylonOpenPBRMaterial.baseColorTexture, babylonOpenPBRMaterial.baseMetalnessTexture, babylonOpenPBRMaterial.specularRoughnessTexture, babylonOpenPBRMaterial, glTFPbrMetallicRoughness, hasUVs);
    await this._setMetallicRoughnessPbrMaterialAsync(metallicRoughness, babylonOpenPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, hasUVs);
    await this._finishMaterialAsync(glTFMaterial, babylonOpenPBRMaterial);
    const materials = this._exporter._materials;
    materials.push(glTFMaterial);
    return materials.length - 1;
  }
  async exportTextureAsync(babylonTexture, overrideId = null) {
    let textureInfo = this._textureMap.get(overrideId ?? babylonTexture.uniqueId);
    if (textureInfo) {
      return textureInfo;
    }
    const samplerIndex = this._exportTextureSampler(babylonTexture);
    const imageIndex = await this._exportTextureImageAsync(babylonTexture);
    textureInfo = this._exportTextureInfo(imageIndex, samplerIndex, babylonTexture.coordinatesIndex);
    this._textureMap.set(overrideId ?? babylonTexture.uniqueId, textureInfo);
    this._exporter._extensionsPostExportTextures("exporter", textureInfo, babylonTexture);
    return textureInfo;
  }
  async _exportTextureImageAsync(babylonTexture) {
    const requestedMimeType = babylonTexture.mimeType ?? "none";
    const internalTextureToImage = this._internalTextureToImage;
    const internalTextureUniqueId = babylonTexture.getInternalTexture().uniqueId;
    internalTextureToImage[internalTextureUniqueId] = internalTextureToImage[internalTextureUniqueId] || {};
    let imageIndexPromise = internalTextureToImage[internalTextureUniqueId][requestedMimeType];
    if (imageIndexPromise === void 0) {
      imageIndexPromise = (async () => {
        const cache = await GetCachedImageAsync(babylonTexture);
        if (cache && (requestedMimeType === "none" || cache.type === requestedMimeType)) {
          return await this._exportImageAsync(babylonTexture.name, cache);
        }
        let mimeType = "image/png";
        if (requestedMimeType !== "none") {
          if (IsSupportedMimeType(requestedMimeType)) {
            mimeType = requestedMimeType;
          } else {
            mimeType = "image/png";
            Tools.Warn(`Unsupported media type: ${requestedMimeType}. Exporting texture as PNG.`);
          }
        }
        const size = babylonTexture.getSize();
        const pixels = await GetTextureDataAsync(babylonTexture);
        const imageData = await EncodeImageAsync(pixels, size.width, size.height, mimeType);
        return await this._exportImageAsync(babylonTexture.name, imageData);
      })();
      internalTextureToImage[internalTextureUniqueId][requestedMimeType] = imageIndexPromise;
    }
    return await imageIndexPromise;
  }
  async _exportImageAsync(name, imageData) {
    const images = this._exporter._images;
    let image;
    if (this._exporter._shouldUseGlb) {
      image = {
        name,
        mimeType: imageData.type,
        bufferView: void 0
        // Will be updated later by BufferManager
      };
      const data = await imageData.arrayBuffer();
      const bufferView = this._exporter._bufferManager.createBufferView(new Uint8Array(data));
      this._exporter._bufferManager.setBufferView(image, bufferView);
    } else {
      const baseName = name.replace(/\.\/|\/|\.\\|\\/g, "_");
      const extension = GetFileExtensionFromMimeType(imageData.type);
      let fileName = baseName + extension;
      if (images.some((image2) => image2.uri === fileName)) {
        fileName = `${baseName}_${Tools.RandomId()}${extension}`;
      }
      image = {
        name,
        uri: fileName
      };
      this._exporter._imageData[fileName] = imageData;
    }
    images.push(image);
    return images.length - 1;
  }
  _exportTextureInfo(imageIndex, samplerIndex, coordinatesIndex) {
    const textures = this._exporter._textures;
    let textureIndex = textures.findIndex((t) => t.sampler == samplerIndex && t.source === imageIndex);
    if (textureIndex === -1) {
      textureIndex = textures.length;
      textures.push({
        source: imageIndex,
        sampler: samplerIndex
      });
    }
    const textureInfo = { index: textureIndex };
    if (coordinatesIndex) {
      textureInfo.texCoord = coordinatesIndex;
    }
    return textureInfo;
  }
  _exportTextureSampler(texture) {
    const sampler = this._getTextureSampler(texture);
    const samplers = this._exporter._samplers;
    const samplerIndex = samplers.findIndex((s) => s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter && s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT);
    if (samplerIndex !== -1) {
      return samplerIndex;
    }
    samplers.push(sampler);
    return samplers.length - 1;
  }
};

// node_modules/@babylonjs/serializers/glTF/2.0/glTFData.js
init_fileTools();
init_tools();
var GLTFData = class {
  constructor() {
    this.files = {};
  }
  /**
   * @deprecated Use files instead
   */
  get glTFFiles() {
    return this.files;
  }
  /**
   * Downloads the glTF data as files based on their names and data
   */
  downloadFiles() {
    for (const key in this.files) {
      const value = this.files[key];
      const blob = new Blob([value], { type: GetMimeType(key) });
      Tools.Download(blob, key);
    }
  }
};

// node_modules/@babylonjs/serializers/glTF/2.0/glTFUtilities.js
init_math_vector();
init_buffer();
init_material();
init_transformNode();
init_bufferUtils();
init_logger();
init_targetCamera();
init_math_constants();

// node_modules/@babylonjs/serializers/exportUtils.js
init_math_vector();
init_math_constants();
init_transformNode();
init_abstractMesh();
var ConvertHandednessMatrix = Matrix.Compose(new Vector3(-1, 1, 1), Quaternion.Identity(), Vector3.Zero());
function IsNoopNode(node, useRightHandedSystem) {
  if (!(node instanceof TransformNode)) {
    return false;
  }
  if (useRightHandedSystem) {
    const matrix = node.getWorldMatrix();
    if (!matrix.equalsWithEpsilon(Matrix.IdentityReadOnly, Epsilon)) {
      return false;
    }
  } else {
    const matrix = node.getWorldMatrix().multiplyToRef(ConvertHandednessMatrix, TmpVectors.Matrix[0]);
    if (!matrix.equalsWithEpsilon(Matrix.IdentityReadOnly, Epsilon)) {
      return false;
    }
  }
  if (node instanceof AbstractMesh && node.geometry) {
    return false;
  }
  return true;
}

// node_modules/@babylonjs/serializers/glTF/2.0/glTFUtilities.js
var DefaultTranslation = Vector3.ZeroReadOnly;
var DefaultRotation = Quaternion.Identity();
var DefaultScale = Vector3.OneReadOnly;
var DefaultLoaderCameraParentScaleLh = new Vector3(-1, 1, 1);
function GetVertexBufferInfo(vertexBuffer, meshes) {
  const { byteOffset, byteStride, type, normalized } = vertexBuffer;
  const componentCount = vertexBuffer.getSize();
  const totalVertices = meshes.reduce((max, current) => {
    return current.getTotalVertices() > max ? current.getTotalVertices() : max;
  }, -Number.MAX_VALUE);
  const count = totalVertices * componentCount;
  const kind = vertexBuffer.getKind();
  return { byteOffset, byteStride, componentCount, type, count, normalized, totalVertices, kind };
}
function GetAccessorElementCount(accessorType) {
  switch (accessorType) {
    case "MAT2":
      return 4;
    case "MAT3":
      return 9;
    case "MAT4":
      return 16;
    case "SCALAR":
      return 1;
    case "VEC2":
      return 2;
    case "VEC3":
      return 3;
    case "VEC4":
      return 4;
  }
}
function FloatsNeed16BitInteger(floatArray) {
  return floatArray.some((value) => value >= 256);
}
function IsStandardVertexAttribute(type) {
  switch (type) {
    case VertexBuffer.PositionKind:
    case VertexBuffer.NormalKind:
    case VertexBuffer.TangentKind:
    case VertexBuffer.ColorKind:
    case VertexBuffer.MatricesIndicesKind:
    case VertexBuffer.MatricesIndicesExtraKind:
    case VertexBuffer.MatricesWeightsKind:
    case VertexBuffer.MatricesWeightsExtraKind:
    case VertexBuffer.UVKind:
    case VertexBuffer.UV2Kind:
    case VertexBuffer.UV3Kind:
    case VertexBuffer.UV4Kind:
    case VertexBuffer.UV5Kind:
    case VertexBuffer.UV6Kind:
      return true;
  }
  return false;
}
function GetAccessorType(kind, hasVertexColorAlpha) {
  if (kind == VertexBuffer.ColorKind) {
    return hasVertexColorAlpha ? "VEC4" : "VEC3";
  }
  switch (kind) {
    case VertexBuffer.PositionKind:
    case VertexBuffer.NormalKind:
      return "VEC3";
    case VertexBuffer.TangentKind:
    case VertexBuffer.MatricesIndicesKind:
    case VertexBuffer.MatricesIndicesExtraKind:
    case VertexBuffer.MatricesWeightsKind:
    case VertexBuffer.MatricesWeightsExtraKind:
      return "VEC4";
    case VertexBuffer.UVKind:
    case VertexBuffer.UV2Kind:
    case VertexBuffer.UV3Kind:
    case VertexBuffer.UV4Kind:
    case VertexBuffer.UV5Kind:
    case VertexBuffer.UV6Kind:
      return "VEC2";
  }
  throw new Error(`Unknown kind ${kind}`);
}
function GetAttributeType(kind) {
  switch (kind) {
    case VertexBuffer.PositionKind:
      return "POSITION";
    case VertexBuffer.NormalKind:
      return "NORMAL";
    case VertexBuffer.TangentKind:
      return "TANGENT";
    case VertexBuffer.ColorKind:
      return "COLOR_0";
    case VertexBuffer.UVKind:
      return "TEXCOORD_0";
    case VertexBuffer.UV2Kind:
      return "TEXCOORD_1";
    case VertexBuffer.UV3Kind:
      return "TEXCOORD_2";
    case VertexBuffer.UV4Kind:
      return "TEXCOORD_3";
    case VertexBuffer.UV5Kind:
      return "TEXCOORD_4";
    case VertexBuffer.UV6Kind:
      return "TEXCOORD_5";
    case VertexBuffer.MatricesIndicesKind:
      return "JOINTS_0";
    case VertexBuffer.MatricesIndicesExtraKind:
      return "JOINTS_1";
    case VertexBuffer.MatricesWeightsKind:
      return "WEIGHTS_0";
    case VertexBuffer.MatricesWeightsExtraKind:
      return "WEIGHTS_1";
  }
  throw new Error(`Unknown kind: ${kind}`);
}
function GetPrimitiveMode(fillMode) {
  switch (fillMode) {
    case Material.TriangleFillMode:
      return 4;
    case Material.TriangleStripDrawMode:
      return 5;
    case Material.TriangleFanDrawMode:
      return 6;
    case Material.PointListDrawMode:
    case Material.PointFillMode:
      return 0;
    case Material.LineLoopDrawMode:
      return 2;
    case Material.LineListDrawMode:
      return 1;
    case Material.LineStripDrawMode:
      return 3;
  }
  throw new Error(`Unknown fill mode: ${fillMode}`);
}
function IsTriangleFillMode(fillMode) {
  switch (fillMode) {
    case Material.TriangleFillMode:
    case Material.TriangleStripDrawMode:
    case Material.TriangleFanDrawMode:
      return true;
  }
  return false;
}
function NormalizeTangent(tangent) {
  const length = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z);
  if (length > 0) {
    tangent.x /= length;
    tangent.y /= length;
    tangent.z /= length;
  }
}
function ConvertToRightHandedPosition(value) {
  value.x *= -1;
  return value;
}
function ConvertToRightHandedTransformMatrix(matrix) {
  ConvertHandednessMatrix.invertToRef(TmpVectors.Matrix[0]).multiplyToRef(matrix, matrix).multiplyToRef(ConvertHandednessMatrix, matrix);
  return matrix;
}
function ConvertToRightHandedRotation(value) {
  if (value.x * value.x + value.y * value.y > 0.5) {
    const absX = Math.abs(value.x);
    const absY = Math.abs(value.y);
    if (absX > absY) {
      const sign = Math.sign(value.x);
      value.x = absX;
      value.y *= -sign;
      value.z *= -sign;
      value.w *= sign;
    } else {
      const sign = Math.sign(value.y);
      value.x *= -sign;
      value.y = absY;
      value.z *= sign;
      value.w *= -sign;
    }
  } else {
    const absZ = Math.abs(value.z);
    const absW = Math.abs(value.w);
    if (absZ > absW) {
      const sign = Math.sign(value.z);
      value.x *= -sign;
      value.y *= sign;
      value.z = absZ;
      value.w *= -sign;
    } else {
      const sign = Math.sign(value.w);
      value.x *= sign;
      value.y *= -sign;
      value.z *= -sign;
      value.w = absW;
    }
  }
  return value;
}
function Rotate180Y(rotation) {
  rotation.copyFromFloats(-rotation.z, rotation.w, rotation.x, -rotation.y);
}
function CollapseChildIntoParent(node, parentNode) {
  const parentTranslation = Vector3.FromArrayToRef(parentNode.translation || [0, 0, 0], 0, TmpVectors.Vector3[0]);
  const parentRotation = Quaternion.FromArrayToRef(parentNode.rotation || [0, 0, 0, 1], 0, TmpVectors.Quaternion[0]);
  const parentMatrix = Matrix.ComposeToRef(DefaultScale, parentRotation, parentTranslation, TmpVectors.Matrix[0]);
  const translation = Vector3.FromArrayToRef(node.translation || [0, 0, 0], 0, TmpVectors.Vector3[2]);
  const rotation = Quaternion.FromArrayToRef(node.rotation || [0, 0, 0, 1], 0, TmpVectors.Quaternion[1]);
  const matrix = Matrix.ComposeToRef(DefaultScale, rotation, translation, TmpVectors.Matrix[1]);
  parentMatrix.multiplyToRef(matrix, matrix);
  matrix.decompose(void 0, parentRotation, parentTranslation);
  if (parentTranslation.equalsWithEpsilon(DefaultTranslation, Epsilon)) {
    delete parentNode.translation;
  } else {
    parentNode.translation = parentTranslation.asArray();
  }
  if (parentRotation.equalsWithEpsilon(DefaultRotation, Epsilon)) {
    delete parentNode.rotation;
  } else {
    parentNode.rotation = parentRotation.asArray();
  }
  if (parentNode.scale) {
    delete parentNode.scale;
  }
}
function IsChildCollapsible(babylonNode, parentBabylonNode) {
  if (!(parentBabylonNode instanceof TransformNode)) {
    return false;
  }
  const isOnlyDescendant = parentBabylonNode.getChildren().length === 1 && babylonNode.getChildren().length === 0 && babylonNode.parent === parentBabylonNode;
  if (!isOnlyDescendant) {
    return false;
  }
  const scene = babylonNode.getScene();
  const expectedScale = babylonNode instanceof TargetCamera && !scene.useRightHandedSystem ? DefaultLoaderCameraParentScaleLh : DefaultScale;
  if (!parentBabylonNode.scaling.equalsWithEpsilon(expectedScale, Epsilon)) {
    Logger.Warn(`Cannot collapse node ${babylonNode.name} into parent node ${parentBabylonNode.name} with modified scaling.`);
    return false;
  }
  return true;
}
function IndicesArrayToTypedSubarray(indices, start, count, is32Bits) {
  let processedIndices = indices;
  if (start !== 0 || count !== indices.length) {
    processedIndices = Array.isArray(indices) ? indices.slice(start, start + count) : indices.subarray(start, start + count);
  }
  if (processedIndices instanceof Int32Array) {
    return new Uint32Array(processedIndices.buffer, processedIndices.byteOffset, processedIndices.length);
  }
  if (Array.isArray(processedIndices)) {
    return is32Bits ? new Uint32Array(processedIndices) : new Uint16Array(processedIndices);
  }
  return processedIndices;
}
function DataArrayToUint8Array(data) {
  if (data instanceof Array) {
    const floatData = new Float32Array(data);
    return new Uint8Array(floatData.buffer, floatData.byteOffset, floatData.byteLength);
  }
  return ArrayBuffer.isView(data) ? new Uint8Array(data.buffer, data.byteOffset, data.byteLength) : new Uint8Array(data);
}
function GetMinMax(data, vertexBuffer, start, count) {
  const { byteOffset, byteStride, type, normalized } = vertexBuffer;
  const size = vertexBuffer.getSize();
  const min = new Array(size).fill(Infinity);
  const max = new Array(size).fill(-Infinity);
  EnumerateFloatValues(data, byteOffset + start * byteStride, byteStride, size, type, count * size, normalized, (values) => {
    for (let i = 0; i < size; i++) {
      min[i] = Math.min(min[i], values[i]);
      max[i] = Math.max(max[i], values[i]);
    }
  });
  return { min, max };
}

// node_modules/@babylonjs/serializers/glTF/2.0/dataWriter.js
var TypedArrayToWriteMethod = /* @__PURE__ */ new Map([
  [Int8Array, (d, b, v) => d.setInt8(b, v)],
  [Uint8Array, (dv, bo, v) => dv.setUint8(bo, v)],
  [Uint8ClampedArray, (dv, bo, v) => dv.setUint8(bo, v)],
  [Int16Array, (dv, bo, v) => dv.setInt16(bo, v, true)],
  [Uint16Array, (dv, bo, v) => dv.setUint16(bo, v, true)],
  [Int32Array, (dv, bo, v) => dv.setInt32(bo, v, true)],
  [Uint32Array, (dv, bo, v) => dv.setUint32(bo, v, true)],
  [Float32Array, (dv, bo, v) => dv.setFloat32(bo, v, true)],
  [Float64Array, (dv, bo, v) => dv.setFloat64(bo, v, true)]
]);
var DataWriter = class {
  writeTypedArray(value) {
    this._checkGrowBuffer(value.byteLength);
    const setMethod = TypedArrayToWriteMethod.get(value.constructor);
    for (let i = 0; i < value.length; i++) {
      setMethod(this._dataView, this._byteOffset, value[i]);
      this._byteOffset += value.BYTES_PER_ELEMENT;
    }
  }
  constructor(byteLength) {
    this._data = new Uint8Array(byteLength);
    this._dataView = new DataView(this._data.buffer);
    this._byteOffset = 0;
  }
  get byteOffset() {
    return this._byteOffset;
  }
  getOutputData() {
    return new Uint8Array(this._data.buffer, 0, this._byteOffset);
  }
  writeUInt8(value) {
    this._checkGrowBuffer(1);
    this._dataView.setUint8(this._byteOffset, value);
    this._byteOffset++;
  }
  writeInt8(value) {
    this._checkGrowBuffer(1);
    this._dataView.setInt8(this._byteOffset, value);
    this._byteOffset++;
  }
  writeInt16(entry) {
    this._checkGrowBuffer(2);
    this._dataView.setInt16(this._byteOffset, entry, true);
    this._byteOffset += 2;
  }
  writeUInt16(value) {
    this._checkGrowBuffer(2);
    this._dataView.setUint16(this._byteOffset, value, true);
    this._byteOffset += 2;
  }
  writeInt32(entry) {
    this._checkGrowBuffer(4);
    this._dataView.setInt32(this._byteOffset, entry, true);
    this._byteOffset += 4;
  }
  writeUInt32(value) {
    this._checkGrowBuffer(4);
    this._dataView.setUint32(this._byteOffset, value, true);
    this._byteOffset += 4;
  }
  writeFloat32(value) {
    this._checkGrowBuffer(4);
    this._dataView.setFloat32(this._byteOffset, value, true);
    this._byteOffset += 4;
  }
  writeFloat64(value) {
    this._checkGrowBuffer(8);
    this._dataView.setFloat64(this._byteOffset, value, true);
    this._byteOffset += 8;
  }
  _checkGrowBuffer(byteLength) {
    const newByteLength = this.byteOffset + byteLength;
    if (newByteLength > this._data.byteLength) {
      const newData = new Uint8Array(newByteLength * 2);
      newData.set(this._data);
      this._data = newData;
      this._dataView = new DataView(this._data.buffer);
    }
  }
};

// node_modules/@babylonjs/serializers/glTF/2.0/bufferManager.js
function GetHighestByteAlignment(byteLength) {
  if (byteLength % 4 === 0) {
    return 4;
  }
  if (byteLength % 2 === 0) {
    return 2;
  }
  return 1;
}
var BufferManager = class {
  constructor() {
    this._bufferViewToData = /* @__PURE__ */ new Map();
    this._bufferViewToProperties = /* @__PURE__ */ new Map();
    this._accessorToBufferView = /* @__PURE__ */ new Map();
  }
  /**
   * Generates a binary buffer from the stored bufferViews. Also populates the bufferViews list.
   * @param bufferViews The list of bufferViews to be populated while writing the binary
   * @returns The binary buffer
   */
  generateBinary(bufferViews) {
    let totalByteLength = 0;
    this._bufferViewToData.forEach((data) => {
      totalByteLength += data.byteLength;
    });
    const dataWriter = new DataWriter(totalByteLength);
    const orderedBufferViews = Array.from(this._bufferViewToData.keys()).sort((a, b) => GetHighestByteAlignment(b.byteLength) - GetHighestByteAlignment(a.byteLength));
    for (const bufferView of orderedBufferViews) {
      bufferView.byteOffset = dataWriter.byteOffset;
      bufferViews.push(bufferView);
      const bufferViewIndex = bufferViews.length - 1;
      const properties = this.getPropertiesWithBufferView(bufferView);
      for (const object of properties) {
        object.bufferView = bufferViewIndex;
      }
      dataWriter.writeTypedArray(this._bufferViewToData.get(bufferView));
      this._bufferViewToData.delete(bufferView);
    }
    return dataWriter.getOutputData();
  }
  /**
   * Creates a buffer view based on the supplied arguments
   * @param data a TypedArray to create the bufferView for
   * @param byteStride byte distance between consecutive elements
   * @returns bufferView for glTF
   */
  createBufferView(data, byteStride) {
    const bufferView = {
      buffer: 0,
      byteOffset: void 0,
      // byteOffset will be set later, when we write the binary and decide bufferView ordering
      byteLength: data.byteLength,
      byteStride
    };
    this._bufferViewToData.set(bufferView, data);
    return bufferView;
  }
  /**
   * Creates an accessor based on the supplied arguments and assigns it to the bufferView
   * @param bufferView The glTF bufferView referenced by this accessor
   * @param type The type of the accessor
   * @param componentType The datatype of components in the attribute
   * @param count The number of attributes referenced by this accessor
   * @param byteOffset The offset relative to the start of the bufferView in bytes
   * @param minMax Minimum and maximum value of each component in this attribute
   * @param normalized Specifies whether integer data values are normalized before usage
   * @returns accessor for glTF
   */
  createAccessor(bufferView, type, componentType, count, byteOffset, minMax, normalized) {
    this._verifyBufferView(bufferView);
    const accessor = {
      bufferView: void 0,
      // bufferView will be set to a real index later, once we write the binary and decide bufferView ordering
      componentType,
      count,
      type,
      min: minMax?.min,
      max: minMax?.max,
      normalized,
      byteOffset
    };
    this.setBufferView(accessor, bufferView);
    this._accessorToBufferView.set(accessor, bufferView);
    return accessor;
  }
  /**
   * Assigns a bufferView to a glTF object that references it
   * @param object The glTF object
   * @param bufferView The bufferView to assign
   */
  setBufferView(object, bufferView) {
    this._verifyBufferView(bufferView);
    const properties = this.getPropertiesWithBufferView(bufferView);
    properties.push(object);
  }
  /**
   * Removes buffer view from the binary data, as well as from all its known references
   * @param bufferView the bufferView to remove
   */
  removeBufferView(bufferView) {
    const properties = this.getPropertiesWithBufferView(bufferView);
    for (const object of properties) {
      if (object.bufferView !== void 0) {
        delete object.bufferView;
      }
    }
    this._bufferViewToData.delete(bufferView);
    this._bufferViewToProperties.delete(bufferView);
    this._accessorToBufferView.forEach((bv, accessor) => {
      if (bv === bufferView) {
        if (accessor.byteOffset !== void 0) {
          delete accessor.byteOffset;
        }
        this._accessorToBufferView.delete(accessor);
      }
    });
  }
  getBufferView(accessor) {
    const bufferView = this._accessorToBufferView.get(accessor);
    this._verifyBufferView(bufferView);
    return bufferView;
  }
  getPropertiesWithBufferView(bufferView) {
    this._verifyBufferView(bufferView);
    this._bufferViewToProperties.set(bufferView, this._bufferViewToProperties.get(bufferView) ?? []);
    return this._bufferViewToProperties.get(bufferView);
  }
  getData(bufferView) {
    this._verifyBufferView(bufferView);
    return this._bufferViewToData.get(bufferView);
  }
  _verifyBufferView(bufferView) {
    if (bufferView === void 0 || !this._bufferViewToData.has(bufferView)) {
      throw new Error(`BufferView ${bufferView} not found in BufferManager.`);
    }
  }
};

// node_modules/@babylonjs/serializers/glTF/2.0/glTFExporter.js
init_camera();
init_multiMaterial();
init_pbrBaseMaterial();
init_standardMaterial();
init_logger();
init_bufferUtils();

// node_modules/@babylonjs/serializers/glTF/2.0/glTFAnimation.js
init_math_vector();
init_tools();
init_animation();
init_transformNode();
init_morphTarget();
init_mesh();
init_camera();
init_light();
var _TangentType;
(function(_TangentType2) {
  _TangentType2[_TangentType2["INTANGENT"] = 0] = "INTANGENT";
  _TangentType2[_TangentType2["OUTTANGENT"] = 1] = "OUTTANGENT";
})(_TangentType || (_TangentType = {}));
var _GLTFAnimation = class __GLTFAnimation {
  /**
   * Determine if a node is transformable - ie has properties it should be part of animation of transformation.
   * @param babylonNode the node to test
   * @returns true if can be animated, false otherwise. False if the parameter is null or undefined.
   */
  static _IsTransformable(babylonNode) {
    return babylonNode && (babylonNode instanceof TransformNode || babylonNode instanceof Camera || babylonNode instanceof Light);
  }
  /**
   * @ignore
   *
   * Creates glTF channel animation from BabylonJS animation.
   * @param babylonTransformNode - BabylonJS mesh.
   * @param animation - animation.
   * @param animationChannelTargetPath - The target animation channel.
   * @param useQuaternion - Specifies if quaternions are used.
   * @returns nullable IAnimationData
   */
  static _CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, useQuaternion, animationSampleRate) {
    if (this._IsTransformable(babylonTransformNode)) {
      const inputs = [];
      const outputs = [];
      const keyFrames = animation.getKeys();
      const minMaxKeyFrames = __GLTFAnimation._CalculateMinMaxKeyFrames(keyFrames);
      const interpolationOrBake = __GLTFAnimation._DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion);
      const interpolation = interpolationOrBake.interpolationType;
      const shouldBakeAnimation = interpolationOrBake.shouldBakeAnimation;
      if (shouldBakeAnimation) {
        __GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, useQuaternion);
      } else {
        if (interpolation === "LINEAR" || interpolation === "STEP") {
          __GLTFAnimation._CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion);
        } else if (interpolation === "CUBICSPLINE") {
          __GLTFAnimation._CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion);
        } else {
          __GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, useQuaternion);
        }
      }
      if (inputs.length && outputs.length) {
        const result = {
          inputs,
          outputs,
          samplerInterpolation: interpolation,
          inputsMin: shouldBakeAnimation ? minMaxKeyFrames.min : Tools.FloatRound(minMaxKeyFrames.min / animation.framePerSecond),
          inputsMax: shouldBakeAnimation ? minMaxKeyFrames.max : Tools.FloatRound(minMaxKeyFrames.max / animation.framePerSecond)
        };
        return result;
      }
    }
    return null;
  }
  static _DeduceAnimationInfo(animation) {
    let animationChannelTargetPath = null;
    let dataAccessorType = "VEC3";
    let useQuaternion = false;
    const property = animation.targetProperty.split(".");
    switch (property[0]) {
      case "scaling": {
        animationChannelTargetPath = "scale";
        break;
      }
      case "position": {
        animationChannelTargetPath = "translation";
        break;
      }
      case "rotation": {
        dataAccessorType = "VEC4";
        animationChannelTargetPath = "rotation";
        break;
      }
      case "rotationQuaternion": {
        dataAccessorType = "VEC4";
        useQuaternion = true;
        animationChannelTargetPath = "rotation";
        break;
      }
      case "influence": {
        dataAccessorType = "SCALAR";
        animationChannelTargetPath = "weights";
        break;
      }
      default: {
        Tools.Error(`Unsupported animatable property ${property[0]}`);
      }
    }
    if (animationChannelTargetPath) {
      return { animationChannelTargetPath, dataAccessorType, useQuaternion };
    } else {
      Tools.Error("animation channel target path and data accessor type could be deduced");
    }
    return null;
  }
  /**
   * @ignore
   * Create node animations from the transform node animations
   * @param babylonNode
   * @param runtimeGLTFAnimation
   * @param idleGLTFAnimations
   * @param nodeMap
   * @param nodes
   * @param bufferManager
   * @param bufferViews
   * @param accessors
   * @param animationSampleRate
   */
  static _CreateNodeAnimationFromNodeAnimations(babylonNode, runtimeGLTFAnimation, idleGLTFAnimations, nodeMap, nodes, bufferManager, bufferViews, accessors, animationSampleRate, useRightHanded, shouldExportAnimation) {
    let glTFAnimation;
    if (__GLTFAnimation._IsTransformable(babylonNode)) {
      if (babylonNode.animations) {
        for (const animation of babylonNode.animations) {
          if (shouldExportAnimation && !shouldExportAnimation(animation)) {
            continue;
          }
          const animationInfo = __GLTFAnimation._DeduceAnimationInfo(animation);
          if (animationInfo) {
            glTFAnimation = {
              name: animation.name,
              samplers: [],
              channels: []
            };
            __GLTFAnimation._AddAnimation(`${animation.name}`, animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation, babylonNode, animation, animationInfo.dataAccessorType, animationInfo.animationChannelTargetPath, nodeMap, bufferManager, bufferViews, accessors, animationInfo.useQuaternion, animationSampleRate, useRightHanded);
            if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {
              idleGLTFAnimations.push(glTFAnimation);
            }
          }
        }
      }
    }
  }
  /**
   * @ignore
   * Create individual morph animations from the mesh's morph target animation tracks
   * @param babylonNode
   * @param runtimeGLTFAnimation
   * @param idleGLTFAnimations
   * @param nodeMap
   * @param nodes
   * @param bufferManager
   * @param bufferViews
   * @param accessors
   * @param animationSampleRate
   */
  static _CreateMorphTargetAnimationFromMorphTargetAnimations(babylonNode, runtimeGLTFAnimation, idleGLTFAnimations, nodeMap, nodes, bufferManager, bufferViews, accessors, animationSampleRate, useRightHanded, shouldExportAnimation) {
    let glTFAnimation;
    if (babylonNode instanceof Mesh) {
      const morphTargetManager = babylonNode.morphTargetManager;
      if (morphTargetManager) {
        for (let i = 0; i < morphTargetManager.numTargets; ++i) {
          const morphTarget = morphTargetManager.getTarget(i);
          for (const animation of morphTarget.animations) {
            if (shouldExportAnimation && !shouldExportAnimation(animation)) {
              continue;
            }
            const combinedAnimation = new Animation(`${animation.name}`, "influence", animation.framePerSecond, animation.dataType, animation.loopMode, animation.enableBlending);
            const combinedAnimationKeys = [];
            const animationKeys = animation.getKeys();
            for (let j = 0; j < animationKeys.length; ++j) {
              const animationKey = animationKeys[j];
              for (let k = 0; k < morphTargetManager.numTargets; ++k) {
                if (k == i) {
                  combinedAnimationKeys.push(animationKey);
                } else {
                  combinedAnimationKeys.push({ frame: animationKey.frame, value: 0 });
                }
              }
            }
            combinedAnimation.setKeys(combinedAnimationKeys, true);
            const animationInfo = __GLTFAnimation._DeduceAnimationInfo(combinedAnimation);
            if (animationInfo) {
              glTFAnimation = {
                name: combinedAnimation.name,
                samplers: [],
                channels: []
              };
              __GLTFAnimation._AddAnimation(animation.name, animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation, babylonNode, combinedAnimation, animationInfo.dataAccessorType, animationInfo.animationChannelTargetPath, nodeMap, bufferManager, bufferViews, accessors, animationInfo.useQuaternion, animationSampleRate, useRightHanded, morphTargetManager.numTargets);
              if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {
                idleGLTFAnimations.push(glTFAnimation);
              }
            }
          }
        }
      }
    }
  }
  /**
   * @internal
   * Create node and morph animations from the animation groups
   * @param babylonScene
   * @param glTFAnimations
   * @param nodeMap
   * @param nodes
   * @param bufferManager
   * @param bufferViews
   * @param accessors
   * @param animationSampleRate
   */
  static _CreateNodeAndMorphAnimationFromAnimationGroups(babylonScene, glTFAnimations, nodeMap, bufferManager, bufferViews, accessors, animationSampleRate, leftHandedNodes, shouldExportAnimation) {
    let glTFAnimation;
    if (babylonScene.animationGroups) {
      const animationGroups = babylonScene.animationGroups;
      for (const animationGroup of animationGroups) {
        const morphAnimations = /* @__PURE__ */ new Map();
        const sampleAnimations = /* @__PURE__ */ new Map();
        const morphAnimationMeshes = /* @__PURE__ */ new Set();
        const animationGroupFrameDiff = animationGroup.to - animationGroup.from;
        glTFAnimation = {
          name: animationGroup.name,
          channels: [],
          samplers: []
        };
        for (let i = 0; i < animationGroup.targetedAnimations.length; ++i) {
          const targetAnimation = animationGroup.targetedAnimations[i];
          const target = targetAnimation.target;
          const animation = targetAnimation.animation;
          if (shouldExportAnimation && !shouldExportAnimation(animation)) {
            continue;
          }
          const convertToRightHanded = leftHandedNodes.has(target);
          if (this._IsTransformable(target) || target.length === 1 && this._IsTransformable(target[0])) {
            const animationInfo = __GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);
            if (animationInfo) {
              const babylonTransformNode = this._IsTransformable(target) ? target : this._IsTransformable(target[0]) ? target[0] : null;
              if (babylonTransformNode) {
                __GLTFAnimation._AddAnimation(`${animation.name}`, glTFAnimation, babylonTransformNode, animation, animationInfo.dataAccessorType, animationInfo.animationChannelTargetPath, nodeMap, bufferManager, bufferViews, accessors, animationInfo.useQuaternion, animationSampleRate, convertToRightHanded);
              }
            }
          } else if (target instanceof MorphTarget || target.length === 1 && target[0] instanceof MorphTarget) {
            const animationInfo = __GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);
            if (animationInfo) {
              const babylonMorphTarget = target instanceof MorphTarget ? target : target[0];
              if (babylonMorphTarget) {
                const babylonMorphTargetManager = babylonScene.morphTargetManagers.find((morphTargetManager) => {
                  for (let j = 0; j < morphTargetManager.numTargets; ++j) {
                    if (morphTargetManager.getTarget(j) === babylonMorphTarget) {
                      return true;
                    }
                  }
                  return false;
                });
                if (babylonMorphTargetManager) {
                  const babylonMesh = babylonScene.meshes.find((mesh) => {
                    return mesh.morphTargetManager === babylonMorphTargetManager;
                  });
                  if (babylonMesh) {
                    if (!morphAnimations.has(babylonMesh)) {
                      morphAnimations.set(babylonMesh, /* @__PURE__ */ new Map());
                    }
                    morphAnimations.get(babylonMesh)?.set(babylonMorphTarget, animation);
                    morphAnimationMeshes.add(babylonMesh);
                    sampleAnimations.set(babylonMesh, animation);
                  }
                }
              }
            }
          } else {
          }
        }
        morphAnimationMeshes.forEach((mesh) => {
          const morphTargetManager = mesh.morphTargetManager;
          let combinedAnimationGroup = null;
          const animationKeys = [];
          const sampleAnimation = sampleAnimations.get(mesh);
          const sampleAnimationKeys = sampleAnimation.getKeys();
          const numAnimationKeys = sampleAnimationKeys.length;
          for (let i = 0; i < numAnimationKeys; ++i) {
            for (let j = 0; j < morphTargetManager.numTargets; ++j) {
              const morphTarget = morphTargetManager.getTarget(j);
              const animationsByMorphTarget = morphAnimations.get(mesh);
              if (animationsByMorphTarget) {
                const morphTargetAnimation = animationsByMorphTarget.get(morphTarget);
                if (morphTargetAnimation) {
                  if (!combinedAnimationGroup) {
                    combinedAnimationGroup = new Animation(`${animationGroup.name}_${mesh.name}_MorphWeightAnimation`, "influence", morphTargetAnimation.framePerSecond, Animation.ANIMATIONTYPE_FLOAT, morphTargetAnimation.loopMode, morphTargetAnimation.enableBlending);
                  }
                  animationKeys.push(morphTargetAnimation.getKeys()[i]);
                } else {
                  animationKeys.push({
                    frame: animationGroup.from + animationGroupFrameDiff / numAnimationKeys * i,
                    value: morphTarget.influence,
                    inTangent: sampleAnimationKeys[0].inTangent ? 0 : void 0,
                    outTangent: sampleAnimationKeys[0].outTangent ? 0 : void 0
                  });
                }
              }
            }
          }
          combinedAnimationGroup.setKeys(animationKeys, true);
          const animationInfo = __GLTFAnimation._DeduceAnimationInfo(combinedAnimationGroup);
          if (animationInfo) {
            __GLTFAnimation._AddAnimation(`${animationGroup.name}_${mesh.name}_MorphWeightAnimation`, glTFAnimation, mesh, combinedAnimationGroup, animationInfo.dataAccessorType, animationInfo.animationChannelTargetPath, nodeMap, bufferManager, bufferViews, accessors, animationInfo.useQuaternion, animationSampleRate, false, morphTargetManager?.numTargets);
          }
        });
        if (glTFAnimation.channels.length && glTFAnimation.samplers.length) {
          glTFAnimations.push(glTFAnimation);
        }
      }
    }
  }
  static _AddAnimation(name, glTFAnimation, babylonTransformNode, animation, dataAccessorType, animationChannelTargetPath, nodeMap, bufferManager, bufferViews, accessors, useQuaternion, animationSampleRate, convertToRightHanded, morphAnimationChannels) {
    const animationData = __GLTFAnimation._CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, useQuaternion, animationSampleRate);
    let bufferView;
    let accessor;
    let keyframeAccessorIndex;
    let dataAccessorIndex;
    let animationSampler;
    let animationChannel;
    if (animationData) {
      if (morphAnimationChannels) {
        let index = 0;
        let currentInput = 0;
        const newInputs = [];
        while (animationData.inputs.length > 0) {
          currentInput = animationData.inputs.shift();
          if (index % morphAnimationChannels == 0) {
            newInputs.push(currentInput);
          }
          index++;
        }
        animationData.inputs = newInputs;
      }
      const nodeIndex = nodeMap.get(babylonTransformNode);
      const inputData = new Float32Array(animationData.inputs);
      bufferView = bufferManager.createBufferView(inputData);
      accessor = bufferManager.createAccessor(bufferView, "SCALAR", 5126, animationData.inputs.length, void 0, {
        min: [animationData.inputsMin],
        max: [animationData.inputsMax]
      });
      accessors.push(accessor);
      keyframeAccessorIndex = accessors.length - 1;
      const rotationQuaternion = new Quaternion();
      const eulerVec3 = new Vector3();
      const position = new Vector3();
      const isCamera = babylonTransformNode instanceof Camera;
      const elementCount = GetAccessorElementCount(dataAccessorType);
      const outputData = new Float32Array(animationData.outputs.length * elementCount);
      animationData.outputs.forEach(function(output, index) {
        let outputToWrite = output;
        switch (animationChannelTargetPath) {
          case "translation":
            if (convertToRightHanded) {
              Vector3.FromArrayToRef(output, 0, position);
              ConvertToRightHandedPosition(position);
              position.toArray(outputToWrite);
            }
            break;
          case "rotation":
            if (output.length === 4) {
              Quaternion.FromArrayToRef(output, 0, rotationQuaternion);
            } else {
              outputToWrite = new Array(4);
              Vector3.FromArrayToRef(output, 0, eulerVec3);
              Quaternion.FromEulerVectorToRef(eulerVec3, rotationQuaternion);
            }
            if (convertToRightHanded) {
              ConvertToRightHandedRotation(rotationQuaternion);
              if (isCamera) {
                Rotate180Y(rotationQuaternion);
              }
            }
            rotationQuaternion.toArray(outputToWrite);
            break;
        }
        outputData.set(outputToWrite, index * elementCount);
      });
      bufferView = bufferManager.createBufferView(outputData);
      accessor = bufferManager.createAccessor(bufferView, dataAccessorType, 5126, animationData.outputs.length);
      accessors.push(accessor);
      dataAccessorIndex = accessors.length - 1;
      animationSampler = {
        interpolation: animationData.samplerInterpolation,
        input: keyframeAccessorIndex,
        output: dataAccessorIndex
      };
      glTFAnimation.samplers.push(animationSampler);
      animationChannel = {
        sampler: glTFAnimation.samplers.length - 1,
        target: {
          node: nodeIndex,
          path: animationChannelTargetPath
        }
      };
      glTFAnimation.channels.push(animationChannel);
    }
  }
  /**
   * Create a baked animation
   * @param babylonTransformNode BabylonJS mesh
   * @param animation BabylonJS animation corresponding to the BabylonJS mesh
   * @param animationChannelTargetPath animation target channel
   * @param minFrame minimum animation frame
   * @param maxFrame maximum animation frame
   * @param fps frames per second of the animation
   * @param sampleRate
   * @param inputs input key frames of the animation
   * @param outputs output key frame data of the animation
   * @param minMaxFrames
   * @param minMaxFrames.min
   * @param minMaxFrames.max
   * @param useQuaternion specifies if quaternions should be used
   */
  static _CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minFrame, maxFrame, fps, sampleRate, inputs, outputs, minMaxFrames, useQuaternion) {
    let value;
    const quaternionCache = Quaternion.Identity();
    let previousTime = null;
    let time;
    let maxUsedFrame = null;
    let currKeyFrame = null;
    let nextKeyFrame = null;
    let prevKeyFrame = null;
    let endFrame = null;
    minMaxFrames.min = Tools.FloatRound(minFrame / fps);
    const keyFrames = animation.getKeys();
    for (let i = 0, length = keyFrames.length; i < length; ++i) {
      endFrame = null;
      currKeyFrame = keyFrames[i];
      if (i + 1 < length) {
        nextKeyFrame = keyFrames[i + 1];
        if (currKeyFrame.value.equals && currKeyFrame.value.equals(nextKeyFrame.value) || currKeyFrame.value === nextKeyFrame.value) {
          if (i === 0) {
            endFrame = currKeyFrame.frame;
          } else {
            continue;
          }
        } else {
          endFrame = nextKeyFrame.frame;
        }
      } else {
        prevKeyFrame = keyFrames[i - 1];
        if (currKeyFrame.value.equals && currKeyFrame.value.equals(prevKeyFrame.value) || currKeyFrame.value === prevKeyFrame.value) {
          continue;
        } else {
          endFrame = maxFrame;
        }
      }
      if (endFrame) {
        for (let f = currKeyFrame.frame; f <= endFrame; f += sampleRate) {
          time = Tools.FloatRound(f / fps);
          if (time === previousTime) {
            continue;
          }
          previousTime = time;
          maxUsedFrame = time;
          const state = {
            key: 0,
            repeatCount: 0,
            loopMode: animation.loopMode
          };
          value = animation._interpolate(f, state);
          __GLTFAnimation._SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, useQuaternion);
        }
      }
    }
    if (maxUsedFrame) {
      minMaxFrames.max = maxUsedFrame;
    }
  }
  static _ConvertFactorToVector3OrQuaternion(factor, babylonTransformNode, animation, animationChannelTargetPath, useQuaternion) {
    const basePositionRotationOrScale = __GLTFAnimation._GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, useQuaternion);
    const property = animation.targetProperty.split(".");
    const componentName = property ? property[1] : "";
    const value = useQuaternion ? Quaternion.FromArray(basePositionRotationOrScale).normalize() : Vector3.FromArray(basePositionRotationOrScale);
    switch (componentName) {
      case "x":
      case "y":
      case "z": {
        value[componentName] = factor;
        break;
      }
      case "w": {
        value.w = factor;
        break;
      }
      default: {
        Tools.Error(`glTFAnimation: Unsupported component name "${componentName}"!`);
      }
    }
    return value;
  }
  static _SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, useQuaternion) {
    let cacheValue;
    inputs.push(time);
    if (animationChannelTargetPath === "weights") {
      outputs.push([value]);
      return;
    }
    if (animation.dataType === Animation.ANIMATIONTYPE_FLOAT) {
      value = this._ConvertFactorToVector3OrQuaternion(value, babylonTransformNode, animation, animationChannelTargetPath, useQuaternion);
    }
    if (animationChannelTargetPath === "rotation") {
      if (useQuaternion) {
        quaternionCache = value;
      } else {
        cacheValue = value;
        Quaternion.RotationYawPitchRollToRef(cacheValue.y, cacheValue.x, cacheValue.z, quaternionCache);
      }
      outputs.push(quaternionCache.asArray());
    } else {
      cacheValue = value;
      outputs.push(cacheValue.asArray());
    }
  }
  /**
   * Creates linear animation from the animation key frames
   * @param babylonTransformNode BabylonJS mesh
   * @param animation BabylonJS animation
   * @param animationChannelTargetPath The target animation channel
   * @param inputs Array to store the key frame times
   * @param outputs Array to store the key frame data
   * @param useQuaternion Specifies if quaternions are used in the animation
   */
  static _CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion) {
    for (const keyFrame of animation.getKeys()) {
      inputs.push(keyFrame.frame / animation.framePerSecond);
      __GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion);
    }
  }
  /**
   * Creates cubic spline animation from the animation key frames
   * @param babylonTransformNode BabylonJS mesh
   * @param animation BabylonJS animation
   * @param animationChannelTargetPath The target animation channel
   * @param inputs Array to store the key frame times
   * @param outputs Array to store the key frame data
   * @param useQuaternion Specifies if quaternions are used in the animation
   */
  static _CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion) {
    animation.getKeys().forEach(function(keyFrame) {
      inputs.push(keyFrame.frame / animation.framePerSecond);
      __GLTFAnimation._AddSplineTangent(_TangentType.INTANGENT, outputs, animationChannelTargetPath, "CUBICSPLINE", keyFrame, useQuaternion);
      __GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion);
      __GLTFAnimation._AddSplineTangent(_TangentType.OUTTANGENT, outputs, animationChannelTargetPath, "CUBICSPLINE", keyFrame, useQuaternion);
    });
  }
  static _GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, useQuaternion) {
    let basePositionRotationOrScale;
    if (animationChannelTargetPath === "rotation") {
      if (useQuaternion) {
        const q = babylonTransformNode.rotationQuaternion;
        basePositionRotationOrScale = (q ?? Quaternion.Identity()).asArray();
      } else {
        const r = babylonTransformNode.rotation;
        basePositionRotationOrScale = (r ?? Vector3.Zero()).asArray();
      }
    } else if (animationChannelTargetPath === "translation") {
      const p = babylonTransformNode.position;
      basePositionRotationOrScale = (p ?? Vector3.Zero()).asArray();
    } else {
      const s = babylonTransformNode.scaling;
      basePositionRotationOrScale = (s ?? Vector3.One()).asArray();
    }
    return basePositionRotationOrScale;
  }
  /**
   * Adds a key frame value
   * @param keyFrame
   * @param animation
   * @param outputs
   * @param animationChannelTargetPath
   * @param babylonTransformNode
   * @param useQuaternion
   */
  static _AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion) {
    let newPositionRotationOrScale;
    const animationType = animation.dataType;
    if (animationType === Animation.ANIMATIONTYPE_VECTOR3) {
      let value = keyFrame.value.asArray();
      if (animationChannelTargetPath === "rotation") {
        const array = Vector3.FromArray(value);
        const rotationQuaternion = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z);
        value = rotationQuaternion.asArray();
      }
      outputs.push(value);
    } else if (animationType === Animation.ANIMATIONTYPE_FLOAT) {
      if (animationChannelTargetPath === "weights") {
        outputs.push([keyFrame.value]);
      } else {
        newPositionRotationOrScale = this._ConvertFactorToVector3OrQuaternion(keyFrame.value, babylonTransformNode, animation, animationChannelTargetPath, useQuaternion);
        if (newPositionRotationOrScale) {
          if (animationChannelTargetPath === "rotation") {
            const posRotScale = useQuaternion ? newPositionRotationOrScale : Quaternion.RotationYawPitchRoll(newPositionRotationOrScale.y, newPositionRotationOrScale.x, newPositionRotationOrScale.z).normalize();
            outputs.push(posRotScale.asArray());
          }
          outputs.push(newPositionRotationOrScale.asArray());
        }
      }
    } else if (animationType === Animation.ANIMATIONTYPE_QUATERNION) {
      outputs.push(keyFrame.value.normalize().asArray());
    } else {
      Tools.Error("glTFAnimation: Unsupported key frame values for animation!");
    }
  }
  /**
   * @internal
   * Determine the interpolation based on the key frames
   * @param keyFrames
   * @param animationChannelTargetPath
   * @param useQuaternion
   */
  static _DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion) {
    let interpolationType;
    let shouldBakeAnimation = false;
    let key;
    if (animationChannelTargetPath === "rotation" && !useQuaternion) {
      return { interpolationType: "LINEAR", shouldBakeAnimation: true };
    }
    for (let i = 0, length = keyFrames.length; i < length; ++i) {
      key = keyFrames[i];
      if (key.inTangent || key.outTangent) {
        if (interpolationType) {
          if (interpolationType !== "CUBICSPLINE") {
            interpolationType = "LINEAR";
            shouldBakeAnimation = true;
            break;
          }
        } else {
          interpolationType = "CUBICSPLINE";
        }
      } else {
        if (interpolationType) {
          if (interpolationType === "CUBICSPLINE" || key.interpolation && key.interpolation === 1 && interpolationType !== "STEP") {
            interpolationType = "LINEAR";
            shouldBakeAnimation = true;
            break;
          }
        } else {
          if (key.interpolation && key.interpolation === 1) {
            interpolationType = "STEP";
          } else {
            interpolationType = "LINEAR";
          }
        }
      }
    }
    if (!interpolationType) {
      interpolationType = "LINEAR";
    }
    return { interpolationType, shouldBakeAnimation };
  }
  /**
   * Adds an input tangent or output tangent to the output data
   * If an input tangent or output tangent is missing, it uses the zero vector or zero quaternion
   * @param tangentType Specifies which type of tangent to handle (inTangent or outTangent)
   * @param outputs The animation data by keyframe
   * @param animationChannelTargetPath The target animation channel
   * @param interpolation The interpolation type
   * @param keyFrame The key frame with the animation data
   * @param useQuaternion Specifies if quaternions are used
   */
  static _AddSplineTangent(tangentType, outputs, animationChannelTargetPath, interpolation, keyFrame, useQuaternion) {
    let tangent;
    const tangentValue = tangentType === _TangentType.INTANGENT ? keyFrame.inTangent : keyFrame.outTangent;
    if (interpolation === "CUBICSPLINE") {
      if (animationChannelTargetPath === "rotation") {
        if (tangentValue) {
          if (useQuaternion) {
            tangent = tangentValue.asArray();
          } else {
            const array = tangentValue;
            tangent = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z).asArray();
          }
        } else {
          tangent = [0, 0, 0, 0];
        }
      } else if (animationChannelTargetPath === "weights") {
        if (tangentValue) {
          tangent = [tangentValue];
        } else {
          tangent = [0];
        }
      } else {
        if (tangentValue) {
          tangent = tangentValue.asArray();
        } else {
          tangent = [0, 0, 0];
        }
      }
      outputs.push(tangent);
    }
  }
  /**
   * Get the minimum and maximum key frames' frame values
   * @param keyFrames animation key frames
   * @returns the minimum and maximum key frame value
   */
  static _CalculateMinMaxKeyFrames(keyFrames) {
    let min = Infinity;
    let max = -Infinity;
    keyFrames.forEach(function(keyFrame) {
      min = Math.min(min, keyFrame.frame);
      max = Math.max(max, keyFrame.frame);
    });
    return { min, max };
  }
};

// node_modules/@babylonjs/serializers/glTF/2.0/glTFMorphTargetsUtilities.js
init_buffer();
init_math_vector();
init_tools();
function BuildMorphTargetBuffers(morphTarget, mesh, bufferManager, bufferViews, accessors, convertToRightHanded) {
  const result = {
    attributes: {},
    influence: morphTarget.influence,
    name: morphTarget.name
  };
  const geometry = mesh.geometry;
  if (!geometry) {
    Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen.");
    return result;
  }
  const flipX = convertToRightHanded ? -1 : 1;
  const floatSize = 4;
  const difference = Vector3.Zero();
  let vertexStart = 0;
  let vertexCount = 0;
  if (morphTarget.hasPositions) {
    const morphPositions = morphTarget.getPositions();
    const originalPositions = geometry.getVerticesData(VertexBuffer.PositionKind);
    if (originalPositions) {
      const positionData = new Float32Array(originalPositions.length);
      const min = [Infinity, Infinity, Infinity];
      const max = [-Infinity, -Infinity, -Infinity];
      vertexCount = originalPositions.length / 3;
      vertexStart = 0;
      for (let i = vertexStart; i < vertexCount; ++i) {
        const originalPosition = Vector3.FromArray(originalPositions, i * 3);
        const morphPosition = Vector3.FromArray(morphPositions, i * 3);
        morphPosition.subtractToRef(originalPosition, difference);
        difference.x *= flipX;
        min[0] = Math.min(min[0], difference.x);
        max[0] = Math.max(max[0], difference.x);
        min[1] = Math.min(min[1], difference.y);
        max[1] = Math.max(max[1], difference.y);
        min[2] = Math.min(min[2], difference.z);
        max[2] = Math.max(max[2], difference.z);
        positionData[i * 3] = difference.x;
        positionData[i * 3 + 1] = difference.y;
        positionData[i * 3 + 2] = difference.z;
      }
      const bufferView = bufferManager.createBufferView(positionData, floatSize * 3);
      const accessor = bufferManager.createAccessor(bufferView, "VEC3", 5126, morphPositions.length / 3, 0, { min, max });
      accessors.push(accessor);
      result.attributes["POSITION"] = accessors.length - 1;
    } else {
      Tools.Warn(`Morph target positions for mesh ${mesh.name} were not exported. Mesh does not have position vertex data`);
    }
  }
  if (morphTarget.hasNormals) {
    const morphNormals = morphTarget.getNormals();
    const originalNormals = geometry.getVerticesData(VertexBuffer.NormalKind);
    if (originalNormals) {
      const normalData = new Float32Array(originalNormals.length);
      vertexCount = originalNormals.length / 3;
      vertexStart = 0;
      for (let i = vertexStart; i < vertexCount; ++i) {
        const originalNormal = Vector3.FromArray(originalNormals, i * 3).normalize();
        const morphNormal = Vector3.FromArray(morphNormals, i * 3).normalize();
        morphNormal.subtractToRef(originalNormal, difference);
        normalData[i * 3] = difference.x * flipX;
        normalData[i * 3 + 1] = difference.y;
        normalData[i * 3 + 2] = difference.z;
      }
      const bufferView = bufferManager.createBufferView(normalData, floatSize * 3);
      const accessor = bufferManager.createAccessor(bufferView, "VEC3", 5126, morphNormals.length / 3, 0);
      accessors.push(accessor);
      result.attributes["NORMAL"] = accessors.length - 1;
    } else {
      Tools.Warn(`Morph target normals for mesh ${mesh.name} were not exported. Mesh does not have normals vertex data`);
    }
  }
  if (morphTarget.hasTangents) {
    const morphTangents = morphTarget.getTangents();
    const originalTangents = geometry.getVerticesData(VertexBuffer.TangentKind);
    if (originalTangents) {
      vertexCount = originalTangents.length / 4;
      const tangentData = new Float32Array(vertexCount * 3);
      vertexStart = 0;
      for (let i = vertexStart; i < vertexCount; ++i) {
        const originalTangent = Vector3.FromArray(originalTangents, i * 4);
        NormalizeTangent(originalTangent);
        const morphTangent = Vector3.FromArray(morphTangents, i * 3);
        NormalizeTangent(morphTangent);
        morphTangent.subtractToRef(originalTangent, difference);
        tangentData[i * 3] = difference.x * flipX;
        tangentData[i * 3 + 1] = difference.y;
        tangentData[i * 3 + 2] = difference.z;
      }
      const bufferView = bufferManager.createBufferView(tangentData, floatSize * 3);
      const accessor = bufferManager.createAccessor(bufferView, "VEC3", 5126, vertexCount, 0);
      accessors.push(accessor);
      result.attributes["TANGENT"] = accessors.length - 1;
    } else {
      Tools.Warn(`Morph target tangents for mesh ${mesh.name} were not exported. Mesh does not have tangents vertex data`);
    }
  }
  if (morphTarget.hasColors) {
    const morphColors = morphTarget.getColors();
    const originalColors = geometry.getVerticesData(VertexBuffer.ColorKind);
    const buffer = geometry.getVertexBuffer(VertexBuffer.ColorKind);
    if (originalColors && buffer) {
      const componentSize = buffer.getSize();
      vertexCount = originalColors.length / componentSize;
      const colorData = new Float32Array(vertexCount * componentSize);
      vertexStart = 0;
      for (let i = vertexStart; i < vertexCount; ++i) {
        if (componentSize === 3) {
          const originalColor = Vector3.FromArray(originalColors, i * componentSize);
          const morphColor = Vector3.FromArray(morphColors, i * componentSize);
          morphColor.subtractToRef(originalColor, difference);
          colorData[i * 3] = difference.x;
          colorData[i * 3 + 1] = difference.y;
          colorData[i * 3 + 2] = difference.z;
        } else if (componentSize === 4) {
          const difference4 = new Vector4();
          const originalColor = Vector4.FromArray(originalColors, i * componentSize);
          const morphColor = Vector4.FromArray(morphColors, i * componentSize);
          morphColor.subtractToRef(originalColor, difference4);
          colorData[i * 4] = difference4.x;
          colorData[i * 4 + 1] = difference4.y;
          colorData[i * 4 + 2] = difference4.z;
          colorData[i * 4 + 3] = difference4.w;
        } else {
          Tools.Warn(`Unsupported number of components for color attribute: ${componentSize}`);
        }
      }
      const bufferView = bufferManager.createBufferView(colorData, floatSize * componentSize);
      const accessor = bufferManager.createAccessor(bufferView, componentSize === 3 ? "VEC3" : "VEC4", 5126, vertexCount, 0);
      accessors.push(accessor);
      result.attributes["COLOR_0"] = accessors.length - 1;
    } else {
      Tools.Warn(`Morph target colors for mesh ${mesh.name} were not exported. Mesh does not have colors vertex data`);
    }
  }
  return result;
}

// node_modules/@babylonjs/serializers/glTF/2.0/glTFExporter.js
init_linesMesh();
init_greasedLineBaseMesh();
init_math_color();
init_targetCamera();
init_math_constants();
init_openpbrMaterial();
var ExporterState = class {
  constructor(convertToRightHanded, wasAddedByNoopNode) {
    this._indicesAccessorMap = /* @__PURE__ */ new Map();
    this._vertexBufferViewMap = /* @__PURE__ */ new Map();
    this._vertexAccessorMap = /* @__PURE__ */ new Map();
    this._remappedBufferView = /* @__PURE__ */ new Map();
    this._meshMorphTargetMap = /* @__PURE__ */ new Map();
    this._vertexMapColorAlpha = /* @__PURE__ */ new Map();
    this._exportedNodes = /* @__PURE__ */ new Set();
    this._meshMap = /* @__PURE__ */ new Map();
    this.convertedToRightHandedBuffers = /* @__PURE__ */ new Map();
    this.convertToRightHanded = convertToRightHanded;
    this.wasAddedByNoopNode = wasAddedByNoopNode;
  }
  getIndicesAccessor(indices, start, count, offset, flip) {
    return this._indicesAccessorMap.get(indices)?.get(start)?.get(count)?.get(offset)?.get(flip);
  }
  setIndicesAccessor(indices, start, count, offset, flip, accessorIndex) {
    let map1 = this._indicesAccessorMap.get(indices);
    if (!map1) {
      map1 = /* @__PURE__ */ new Map();
      this._indicesAccessorMap.set(indices, map1);
    }
    let map2 = map1.get(start);
    if (!map2) {
      map2 = /* @__PURE__ */ new Map();
      map1.set(start, map2);
    }
    let map3 = map2.get(count);
    if (!map3) {
      map3 = /* @__PURE__ */ new Map();
      map2.set(count, map3);
    }
    let map4 = map3.get(offset);
    if (!map4) {
      map4 = /* @__PURE__ */ new Map();
      map3.set(offset, map4);
    }
    map4.set(flip, accessorIndex);
  }
  pushExportedNode(node) {
    if (!this._exportedNodes.has(node)) {
      this._exportedNodes.add(node);
    }
  }
  getNodesSet() {
    return this._exportedNodes;
  }
  getVertexBufferView(buffer) {
    return this._vertexBufferViewMap.get(buffer);
  }
  setVertexBufferView(buffer, bufferView) {
    this._vertexBufferViewMap.set(buffer, bufferView);
  }
  setRemappedBufferView(buffer, vertexBuffer, bufferView) {
    this._remappedBufferView.set(buffer, /* @__PURE__ */ new Map());
    this._remappedBufferView.get(buffer).set(vertexBuffer, bufferView);
  }
  getRemappedBufferView(buffer, vertexBuffer) {
    return this._remappedBufferView.get(buffer)?.get(vertexBuffer);
  }
  getVertexAccessor(vertexBuffer, start, count) {
    return this._vertexAccessorMap.get(vertexBuffer)?.get(start)?.get(count);
  }
  setVertexAccessor(vertexBuffer, start, count, accessorIndex) {
    let map1 = this._vertexAccessorMap.get(vertexBuffer);
    if (!map1) {
      map1 = /* @__PURE__ */ new Map();
      this._vertexAccessorMap.set(vertexBuffer, map1);
    }
    let map2 = map1.get(start);
    if (!map2) {
      map2 = /* @__PURE__ */ new Map();
      map1.set(start, map2);
    }
    map2.set(count, accessorIndex);
  }
  hasVertexColorAlpha(vertexBuffer) {
    return this._vertexMapColorAlpha.get(vertexBuffer) || false;
  }
  setHasVertexColorAlpha(vertexBuffer, hasAlpha) {
    return this._vertexMapColorAlpha.set(vertexBuffer, hasAlpha);
  }
  getMesh(mesh) {
    return this._meshMap.get(mesh);
  }
  setMesh(mesh, meshIndex) {
    this._meshMap.set(mesh, meshIndex);
  }
  bindMorphDataToMesh(mesh, morphData) {
    const morphTargets = this._meshMorphTargetMap.get(mesh) || [];
    this._meshMorphTargetMap.set(mesh, morphTargets);
    if (morphTargets.indexOf(morphData) === -1) {
      morphTargets.push(morphData);
    }
  }
  getMorphTargetsFromMesh(mesh) {
    return this._meshMorphTargetMap.get(mesh);
  }
};
var GLTFExporter = class _GLTFExporter {
  // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async
  _ApplyExtension(node, extensions, index, actionAsync) {
    if (index >= extensions.length) {
      return Promise.resolve(node);
    }
    const currentPromise = actionAsync(extensions[index], node);
    if (!currentPromise) {
      return this._ApplyExtension(node, extensions, index + 1, actionAsync);
    }
    return currentPromise.then(async (newNode) => newNode ? await this._ApplyExtension(newNode, extensions, index + 1, actionAsync) : null);
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async
  _ApplyExtensions(node, actionAsync) {
    const extensions = [];
    for (const name of _GLTFExporter._ExtensionNames) {
      extensions.push(this._extensions[name]);
    }
    return this._ApplyExtension(node, extensions, 0, actionAsync);
  }
  // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async
  _extensionsPostExportNodeAsync(context, node, babylonNode, nodeMap, convertToRightHanded) {
    return this._ApplyExtensions(
      node,
      // eslint-disable-next-line @typescript-eslint/promise-function-async
      (extension, node2) => extension.postExportNodeAsync && extension.postExportNodeAsync(context, node2, babylonNode, nodeMap, convertToRightHanded, this._bufferManager)
    );
  }
  // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async
  _extensionsPostExportMaterialAsync(context, material, babylonMaterial) {
    return this._ApplyExtensions(material, (extension, node) => extension.postExportMaterialAsync && extension.postExportMaterialAsync(context, node, babylonMaterial));
  }
  /**
   * Get additional textures for a material
   * @param context The context when loading the asset
   * @param material The glTF material
   * @param babylonMaterial The Babylon.js material
   * @returns List of additional textures
   */
  async _extensionsPostExportMaterialAdditionalTexturesAsync(context, material, babylonMaterial) {
    const output = [];
    await Promise.all(_GLTFExporter._ExtensionNames.map(async (name) => {
      const extension = this._extensions[name];
      if (extension.postExportMaterialAdditionalTexturesAsync) {
        const textures = await extension.postExportMaterialAdditionalTexturesAsync(context, material, babylonMaterial);
        output.push(...textures);
      }
    }));
    return output;
  }
  _extensionsPostExportTextures(context, textureInfo, babylonTexture) {
    for (const name of _GLTFExporter._ExtensionNames) {
      const extension = this._extensions[name];
      if (extension.postExportTexture) {
        extension.postExportTexture(context, textureInfo, babylonTexture);
      }
    }
  }
  _extensionsPostExportMeshPrimitive(primitive) {
    for (const name of _GLTFExporter._ExtensionNames) {
      const extension = this._extensions[name];
      if (extension.postExportMeshPrimitive) {
        extension.postExportMeshPrimitive(primitive, this._bufferManager, this._accessors);
      }
    }
  }
  async _extensionsPreGenerateBinaryAsync() {
    for (const name of _GLTFExporter._ExtensionNames) {
      const extension = this._extensions[name];
      if (extension.preGenerateBinaryAsync) {
        await extension.preGenerateBinaryAsync(this._bufferManager);
      }
    }
  }
  _forEachExtensions(action) {
    for (const name of _GLTFExporter._ExtensionNames) {
      const extension = this._extensions[name];
      if (extension.enabled) {
        action(extension);
      }
    }
  }
  _extensionsOnExporting() {
    this._forEachExtensions((extension) => {
      var _a, _b, _c;
      if (extension.wasUsed) {
        (_a = this._glTF).extensionsUsed || (_a.extensionsUsed = []);
        if (this._glTF.extensionsUsed.indexOf(extension.name) === -1) {
          this._glTF.extensionsUsed.push(extension.name);
        }
        if (extension.required) {
          (_b = this._glTF).extensionsRequired || (_b.extensionsRequired = []);
          if (this._glTF.extensionsRequired.indexOf(extension.name) === -1) {
            this._glTF.extensionsRequired.push(extension.name);
          }
        }
        (_c = this._glTF).extensions || (_c.extensions = {});
        if (extension.onExporting) {
          extension.onExporting();
        }
      }
    });
  }
  _loadExtensions() {
    for (const name of _GLTFExporter._ExtensionNames) {
      const extension = _GLTFExporter._ExtensionFactories[name](this);
      this._extensions[name] = extension;
    }
  }
  constructor(babylonScene = EngineStore.LastCreatedScene, options) {
    this._glTF = {
      asset: { generator: `Babylon.js v${Engine.Version}`, version: "2.0" }
    };
    this._animations = [];
    this._accessors = [];
    this._bufferViews = [];
    this._cameras = [];
    this._images = [];
    this._materials = [];
    this._meshes = [];
    this._nodes = [];
    this._samplers = [];
    this._scenes = [];
    this._skins = [];
    this._textures = [];
    this._imageData = {};
    this._shouldUseGlb = false;
    this._materialExporter = new GLTFMaterialExporter(this);
    this._extensions = {};
    this._bufferManager = new BufferManager();
    this._shouldExportNodeMap = /* @__PURE__ */ new Map();
    this._nodeMap = /* @__PURE__ */ new Map();
    this._materialMap = /* @__PURE__ */ new Map();
    this._camerasMap = /* @__PURE__ */ new Map();
    this._nodesCameraMap = /* @__PURE__ */ new Map();
    this._skinMap = /* @__PURE__ */ new Map();
    this._nodesSkinMap = /* @__PURE__ */ new Map();
    this._materialNeedsUVsSet = /* @__PURE__ */ new Set();
    if (!babylonScene) {
      throw new Error("No scene available to export");
    }
    this._babylonScene = babylonScene;
    this._options = {
      shouldExportNode: () => true,
      shouldExportAnimation: () => true,
      metadataSelector: (metadata) => metadata?.gltf?.extras,
      animationSampleRate: 1 / 60,
      exportWithoutWaitingForScene: false,
      exportUnusedUVs: false,
      removeNoopRootNodes: true,
      includeCoordinateSystemConversionNodes: false,
      meshCompressionMethod: "None",
      ...options
    };
    this._loadExtensions();
  }
  dispose() {
    for (const key in this._extensions) {
      const extension = this._extensions[key];
      extension.dispose();
    }
  }
  get options() {
    return this._options;
  }
  static RegisterExtension(name, factory, order = 100) {
    if (_GLTFExporter.UnregisterExtension(name)) {
      Tools.Warn(`Extension with the name ${name} already exists`);
    }
    _GLTFExporter._ExtensionFactories[name] = factory;
    const extensionOrder = order ?? 0;
    _GLTFExporter._ExtensionOrders[name] = extensionOrder;
    let insertIndex = _GLTFExporter._ExtensionNames.length;
    for (let i = 0; i < _GLTFExporter._ExtensionNames.length; i++) {
      const existingName = _GLTFExporter._ExtensionNames[i];
      const existingOrder = _GLTFExporter._ExtensionOrders[existingName];
      if (extensionOrder < existingOrder) {
        insertIndex = i;
        break;
      }
    }
    _GLTFExporter._ExtensionNames.splice(insertIndex, 0, name);
  }
  static UnregisterExtension(name) {
    if (!_GLTFExporter._ExtensionFactories[name]) {
      return false;
    }
    delete _GLTFExporter._ExtensionFactories[name];
    delete _GLTFExporter._ExtensionOrders[name];
    const index = _GLTFExporter._ExtensionNames.indexOf(name);
    if (index !== -1) {
      _GLTFExporter._ExtensionNames.splice(index, 1);
    }
    return true;
  }
  _generateJSON(bufferByteLength, fileName, prettyPrint) {
    const buffer = { byteLength: bufferByteLength };
    if (buffer.byteLength) {
      this._glTF.buffers = [buffer];
    }
    if (this._nodes && this._nodes.length) {
      this._glTF.nodes = this._nodes;
    }
    if (this._meshes && this._meshes.length) {
      this._glTF.meshes = this._meshes;
    }
    if (this._scenes && this._scenes.length) {
      this._glTF.scenes = this._scenes;
      this._glTF.scene = 0;
    }
    if (this._cameras && this._cameras.length) {
      this._glTF.cameras = this._cameras;
    }
    if (this._bufferViews && this._bufferViews.length) {
      this._glTF.bufferViews = this._bufferViews;
    }
    if (this._accessors && this._accessors.length) {
      this._glTF.accessors = this._accessors;
    }
    if (this._animations && this._animations.length) {
      this._glTF.animations = this._animations;
    }
    if (this._materials && this._materials.length) {
      this._glTF.materials = this._materials;
    }
    if (this._textures && this._textures.length) {
      this._glTF.textures = this._textures;
    }
    if (this._samplers && this._samplers.length) {
      this._glTF.samplers = this._samplers;
    }
    if (this._skins && this._skins.length) {
      this._glTF.skins = this._skins;
    }
    if (this._images && this._images.length) {
      this._glTF.images = this._images;
    }
    if (!this._shouldUseGlb) {
      buffer.uri = fileName + ".bin";
    }
    return prettyPrint ? JSON.stringify(this._glTF, null, 2) : JSON.stringify(this._glTF);
  }
  async generateGLTFAsync(glTFPrefix) {
    const binaryBuffer = await this._generateBinaryAsync();
    this._extensionsOnExporting();
    const jsonText = this._generateJSON(binaryBuffer.byteLength, glTFPrefix, true);
    const bin = new Blob([binaryBuffer], { type: "application/octet-stream" });
    const glTFFileName = glTFPrefix + ".gltf";
    const glTFBinFile = glTFPrefix + ".bin";
    const container = new GLTFData();
    container.files[glTFFileName] = jsonText;
    container.files[glTFBinFile] = bin;
    if (this._imageData) {
      for (const image in this._imageData) {
        container.files[image] = this._imageData[image];
      }
    }
    return container;
  }
  async _generateBinaryAsync() {
    await this._exportSceneAsync();
    await this._extensionsPreGenerateBinaryAsync();
    return this._bufferManager.generateBinary(this._bufferViews);
  }
  /**
   * Pads the number to a multiple of 4
   * @param num number to pad
   * @returns padded number
   */
  _getPadding(num) {
    const remainder = num % 4;
    const padding = remainder === 0 ? remainder : 4 - remainder;
    return padding;
  }
  async generateGLBAsync(glTFPrefix) {
    this._shouldUseGlb = true;
    const binaryBuffer = await this._generateBinaryAsync();
    this._extensionsOnExporting();
    const jsonText = this._generateJSON(binaryBuffer.byteLength);
    const glbFileName = glTFPrefix + ".glb";
    const headerLength = 12;
    const chunkLengthPrefix = 8;
    let jsonLength = jsonText.length;
    let encodedJsonText;
    if (typeof TextEncoder !== "undefined") {
      const encoder = new TextEncoder();
      encodedJsonText = encoder.encode(jsonText);
      jsonLength = encodedJsonText.length;
    }
    const jsonPadding = this._getPadding(jsonLength);
    const binPadding = this._getPadding(binaryBuffer.byteLength);
    const byteLength = headerLength + 2 * chunkLengthPrefix + jsonLength + jsonPadding + binaryBuffer.byteLength + binPadding;
    const dataWriter = new DataWriter(byteLength);
    dataWriter.writeUInt32(1179937895);
    dataWriter.writeUInt32(2);
    dataWriter.writeUInt32(byteLength);
    dataWriter.writeUInt32(jsonLength + jsonPadding);
    dataWriter.writeUInt32(1313821514);
    if (encodedJsonText) {
      dataWriter.writeTypedArray(encodedJsonText);
    } else {
      const blankCharCode = "_".charCodeAt(0);
      for (let i = 0; i < jsonLength; ++i) {
        const charCode = jsonText.charCodeAt(i);
        if (charCode != jsonText.codePointAt(i)) {
          dataWriter.writeUInt8(blankCharCode);
        } else {
          dataWriter.writeUInt8(charCode);
        }
      }
    }
    for (let i = 0; i < jsonPadding; ++i) {
      dataWriter.writeUInt8(32);
    }
    dataWriter.writeUInt32(binaryBuffer.byteLength + binPadding);
    dataWriter.writeUInt32(5130562);
    dataWriter.writeTypedArray(binaryBuffer);
    for (let i = 0; i < binPadding; ++i) {
      dataWriter.writeUInt8(0);
    }
    const container = new GLTFData();
    container.files[glbFileName] = new Blob([dataWriter.getOutputData()], { type: "application/octet-stream" });
    return container;
  }
  _setNodeTransformation(node, babylonTransformNode, convertToRightHanded) {
    if (!babylonTransformNode.getPivotPoint().equalsWithEpsilon(DefaultTranslation, Epsilon)) {
      Tools.Warn("Pivot points are not supported in the glTF serializer");
    }
    if (!babylonTransformNode.position.equalsWithEpsilon(DefaultTranslation, Epsilon)) {
      const translation = TmpVectors.Vector3[0].copyFrom(babylonTransformNode.position);
      if (convertToRightHanded) {
        ConvertToRightHandedPosition(translation);
      }
      node.translation = translation.asArray();
    }
    if (!babylonTransformNode.scaling.equalsWithEpsilon(DefaultScale, Epsilon)) {
      node.scale = babylonTransformNode.scaling.asArray();
    }
    const rotationQuaternion = babylonTransformNode.rotationQuaternion?.clone() || Quaternion.FromEulerAngles(babylonTransformNode.rotation.x, babylonTransformNode.rotation.y, babylonTransformNode.rotation.z);
    if (!rotationQuaternion.equalsWithEpsilon(DefaultRotation, Epsilon)) {
      if (convertToRightHanded) {
        ConvertToRightHandedRotation(rotationQuaternion);
      }
      node.rotation = rotationQuaternion.normalize().asArray();
    }
  }
  _setCameraTransformation(node, babylonCamera, convertToRightHanded) {
    const translation = TmpVectors.Vector3[0];
    const rotationQuaternion = TmpVectors.Quaternion[0];
    const cameraWorldMatrix = babylonCamera.getWorldMatrix();
    if (babylonCamera.parent) {
      const parentInvWorldMatrix = babylonCamera.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);
      const cameraLocal = cameraWorldMatrix.multiplyToRef(parentInvWorldMatrix, TmpVectors.Matrix[1]);
      cameraLocal.decompose(void 0, rotationQuaternion, translation);
    } else {
      cameraWorldMatrix.decompose(void 0, rotationQuaternion, translation);
    }
    if (!translation.equalsWithEpsilon(DefaultTranslation, Epsilon)) {
      if (convertToRightHanded) {
        ConvertToRightHandedPosition(translation);
      }
      node.translation = translation.asArray();
    }
    if (convertToRightHanded) {
      ConvertToRightHandedRotation(rotationQuaternion);
    }
    if (!this._babylonScene.useRightHandedSystem) {
      Rotate180Y(rotationQuaternion);
    }
    if (!rotationQuaternion.equalsWithEpsilon(DefaultRotation, Epsilon)) {
      node.rotation = rotationQuaternion.asArray();
    }
  }
  // Export babylon cameras to glTF cameras
  _listAvailableCameras() {
    for (const camera of this._babylonScene.cameras) {
      const glTFCamera = {
        type: camera.mode === Camera.PERSPECTIVE_CAMERA ? "perspective" : "orthographic"
      };
      if (camera.name) {
        glTFCamera.name = camera.name;
      }
      if (glTFCamera.type === "perspective") {
        glTFCamera.perspective = {
          aspectRatio: camera.getEngine().getAspectRatio(camera),
          yfov: camera.fovMode === Camera.FOVMODE_VERTICAL_FIXED ? camera.fov : camera.fov * camera.getEngine().getAspectRatio(camera),
          znear: camera.minZ,
          zfar: camera.maxZ
        };
      } else if (glTFCamera.type === "orthographic") {
        const halfWidth = camera.orthoLeft && camera.orthoRight ? 0.5 * (camera.orthoRight - camera.orthoLeft) : camera.getEngine().getRenderWidth() * 0.5;
        const halfHeight = camera.orthoBottom && camera.orthoTop ? 0.5 * (camera.orthoTop - camera.orthoBottom) : camera.getEngine().getRenderHeight() * 0.5;
        glTFCamera.orthographic = {
          xmag: halfWidth,
          ymag: halfHeight,
          znear: camera.minZ,
          zfar: camera.maxZ
        };
      }
      this._camerasMap.set(camera, glTFCamera);
    }
  }
  // Cleanup unused cameras and assign index to nodes.
  _exportAndAssignCameras() {
    const gltfCameras = Array.from(this._camerasMap.values());
    for (const gltfCamera of gltfCameras) {
      const usedNodes = this._nodesCameraMap.get(gltfCamera);
      if (usedNodes !== void 0) {
        this._cameras.push(gltfCamera);
        for (const node of usedNodes) {
          node.camera = this._cameras.length - 1;
        }
      }
    }
  }
  // Collects all skins in a skins map so nodes can reference it during node parsing.
  _listAvailableSkeletons() {
    for (const skeleton of this._babylonScene.skeletons) {
      if (skeleton.bones.length <= 0) {
        continue;
      }
      const skin = { joints: [] };
      this._skinMap.set(skeleton, skin);
    }
  }
  _exportAndAssignSkeletons(leftHandNodes) {
    for (const skeleton of this._babylonScene.skeletons) {
      if (skeleton.bones.length <= 0) {
        continue;
      }
      const skin = this._skinMap.get(skeleton);
      if (skin == void 0) {
        continue;
      }
      const boneIndexMap = {};
      let maxBoneIndex = -1;
      for (let i = 0; i < skeleton.bones.length; ++i) {
        const bone = skeleton.bones[i];
        const boneIndex = bone.getIndex() ?? i;
        if (boneIndex !== -1) {
          boneIndexMap[boneIndex] = bone;
          if (boneIndex > maxBoneIndex) {
            maxBoneIndex = boneIndex;
          }
        }
      }
      const inverseBindMatrices = [];
      for (let boneIndex = 0; boneIndex <= maxBoneIndex; ++boneIndex) {
        const bone = boneIndexMap[boneIndex];
        const transformNode = bone.getTransformNode();
        const nodeIndex = transformNode ? this._nodeMap.get(transformNode) : void 0;
        if (nodeIndex === void 0) {
          Tools.Warn("Exporting a bone without a linked transform node is currently unsupported.");
          continue;
        }
        skin.joints.push(nodeIndex);
        const boneMatrix = bone.getAbsoluteInverseBindMatrix().clone();
        if (leftHandNodes.has(transformNode)) {
          ConvertToRightHandedTransformMatrix(boneMatrix);
        }
        inverseBindMatrices.push(boneMatrix);
      }
      const skinnedNodes = this._nodesSkinMap.get(skin);
      if (skin.joints.length > 0 && skinnedNodes !== void 0) {
        const inverseBindMatricesData = new Float32Array(inverseBindMatrices.length * 16);
        inverseBindMatrices.forEach((mat, index) => {
          inverseBindMatricesData.set(mat.m, index * 16);
        });
        const bufferView = this._bufferManager.createBufferView(inverseBindMatricesData);
        this._accessors.push(this._bufferManager.createAccessor(bufferView, "MAT4", 5126, inverseBindMatrices.length));
        skin.inverseBindMatrices = this._accessors.length - 1;
        this._skins.push(skin);
        const skinIndex = this._skins.length - 1;
        for (const skinnedNode of skinnedNodes) {
          skinnedNode.skin = skinIndex;
        }
      }
    }
  }
  async _exportSceneAsync() {
    const scene = { nodes: [] };
    if (this._babylonScene.metadata) {
      const extras = this._options.metadataSelector(this._babylonScene.metadata);
      if (extras) {
        scene.extras = extras;
      }
    }
    const rootNodesRH = new Array();
    const rootNodesLH = new Array();
    const rootNoopNodesRH = new Array();
    for (const rootNode of this._babylonScene.rootNodes) {
      if (this._options.removeNoopRootNodes && !this._options.includeCoordinateSystemConversionNodes && IsNoopNode(rootNode, this._babylonScene.useRightHandedSystem)) {
        rootNoopNodesRH.push(...rootNode.getChildren());
      } else if (this._babylonScene.useRightHandedSystem) {
        rootNodesRH.push(rootNode);
      } else {
        rootNodesLH.push(rootNode);
      }
    }
    this._listAvailableCameras();
    this._listAvailableSkeletons();
    const stateLH = new ExporterState(true, false);
    scene.nodes.push(...await this._exportNodesAsync(rootNodesLH, stateLH));
    const stateRH = new ExporterState(false, false);
    scene.nodes.push(...await this._exportNodesAsync(rootNodesRH, stateRH));
    const noopRH = new ExporterState(false, true);
    scene.nodes.push(...await this._exportNodesAsync(rootNoopNodesRH, noopRH));
    if (scene.nodes.length) {
      this._scenes.push(scene);
    }
    this._exportAndAssignCameras();
    this._exportAndAssignSkeletons(stateLH.getNodesSet());
    if (this._babylonScene.animationGroups.length) {
      _GLTFAnimation._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene, this._animations, this._nodeMap, this._bufferManager, this._bufferViews, this._accessors, this._animationSampleRate, stateLH.getNodesSet(), this._options.shouldExportAnimation);
    }
  }
  _shouldExportNode(babylonNode) {
    let result = this._shouldExportNodeMap.get(babylonNode);
    if (result === void 0) {
      result = this._options.shouldExportNode(babylonNode);
      this._shouldExportNodeMap.set(babylonNode, result);
    }
    return result;
  }
  async _exportNodesAsync(babylonRootNodes, state) {
    const nodes = new Array();
    this._exportBuffers(babylonRootNodes, state);
    for (const babylonNode of babylonRootNodes) {
      await this._exportNodeAsync(babylonNode, nodes, state);
    }
    return nodes;
  }
  _collectBuffers(babylonNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsToMeshesMap, state) {
    if (this._shouldExportNode(babylonNode) && babylonNode instanceof AbstractMesh && babylonNode.geometry) {
      const vertexBuffers = babylonNode.geometry.getVertexBuffers();
      if (vertexBuffers) {
        for (const kind in vertexBuffers) {
          if (!IsStandardVertexAttribute(kind)) {
            continue;
          }
          const vertexBuffer = vertexBuffers[kind];
          state.setHasVertexColorAlpha(vertexBuffer, babylonNode.hasVertexAlpha);
          const buffer = vertexBuffer._buffer;
          const vertexBufferArray = bufferToVertexBuffersMap.get(buffer) || [];
          bufferToVertexBuffersMap.set(buffer, vertexBufferArray);
          if (vertexBufferArray.indexOf(vertexBuffer) === -1) {
            vertexBufferArray.push(vertexBuffer);
          }
          const meshes = vertexBufferToMeshesMap.get(vertexBuffer) || [];
          vertexBufferToMeshesMap.set(vertexBuffer, meshes);
          if (meshes.indexOf(babylonNode) === -1) {
            meshes.push(babylonNode);
          }
        }
      }
      const morphTargetManager = babylonNode.morphTargetManager;
      if (morphTargetManager) {
        for (let morphIndex = 0; morphIndex < morphTargetManager.numTargets; morphIndex++) {
          const morphTarget = morphTargetManager.getTarget(morphIndex);
          const meshes = morphTargetsToMeshesMap.get(morphTarget) || [];
          morphTargetsToMeshesMap.set(morphTarget, meshes);
          if (meshes.indexOf(babylonNode) === -1) {
            meshes.push(babylonNode);
          }
        }
      }
    }
    for (const babylonChildNode of babylonNode.getChildren()) {
      this._collectBuffers(babylonChildNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsToMeshesMap, state);
    }
  }
  _exportBuffers(babylonRootNodes, state) {
    const bufferToVertexBuffersMap = /* @__PURE__ */ new Map();
    const vertexBufferToMeshesMap = /* @__PURE__ */ new Map();
    const morphTargetsMeshesMap = /* @__PURE__ */ new Map();
    for (const babylonNode of babylonRootNodes) {
      this._collectBuffers(babylonNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsMeshesMap, state);
    }
    const buffers = Array.from(bufferToVertexBuffersMap.keys());
    for (const buffer of buffers) {
      const data = buffer.getData();
      if (!data) {
        throw new Error("Buffer data is not available");
      }
      const vertexBuffers = bufferToVertexBuffersMap.get(buffer);
      if (!vertexBuffers) {
        continue;
      }
      const byteStride = vertexBuffers[0].byteStride;
      if (vertexBuffers.some((vertexBuffer) => vertexBuffer.byteStride !== byteStride)) {
        throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");
      }
      const bytes = DataArrayToUint8Array(data).slice();
      for (const vertexBuffer of vertexBuffers) {
        const meshes = vertexBufferToMeshesMap.get(vertexBuffer);
        const { byteOffset, byteStride: byteStride2, componentCount, type, count, normalized, kind } = GetVertexBufferInfo(vertexBuffer, meshes);
        switch (kind) {
          // Normalize normals and tangents.
          case VertexBuffer.NormalKind:
          case VertexBuffer.TangentKind: {
            EnumerateFloatValues(bytes, byteOffset, byteStride2, componentCount, type, count, normalized, (values) => {
              const length = Math.sqrt(values[0] * values[0] + values[1] * values[1] + values[2] * values[2]);
              if (length > 0) {
                const invLength = 1 / length;
                values[0] *= invLength;
                values[1] *= invLength;
                values[2] *= invLength;
              }
            });
            break;
          }
          // Convert StandardMaterial vertex colors from gamma to linear space.
          case VertexBuffer.ColorKind: {
            const stdMaterialCount = meshes.filter((mesh) => mesh.material instanceof StandardMaterial || mesh.material == null).length;
            if (stdMaterialCount == 0) {
              break;
            }
            if (stdMaterialCount != meshes.length) {
              Logger.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");
              break;
            }
            if (type == VertexBuffer.UNSIGNED_BYTE) {
              Logger.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");
            }
            const vertexData3 = new Color3();
            const vertexData4 = new Color4();
            const useExactSrgbConversions = this._babylonScene.getEngine().useExactSrgbConversions;
            EnumerateFloatValues(bytes, byteOffset, byteStride2, componentCount, type, count, normalized, (values) => {
              if (values.length === 3) {
                vertexData3.fromArray(values, 0);
                vertexData3.toLinearSpaceToRef(vertexData3, useExactSrgbConversions);
                vertexData3.toArray(values, 0);
              } else {
                vertexData4.fromArray(values, 0);
                vertexData4.toLinearSpaceToRef(vertexData4, useExactSrgbConversions);
                vertexData4.toArray(values, 0);
              }
            });
          }
        }
      }
      if (state.convertToRightHanded) {
        for (const vertexBuffer of vertexBuffers) {
          const meshes = vertexBufferToMeshesMap.get(vertexBuffer);
          const { byteOffset, byteStride: byteStride2, componentCount, type, count, normalized, kind } = GetVertexBufferInfo(vertexBuffer, meshes);
          switch (kind) {
            case VertexBuffer.PositionKind:
            case VertexBuffer.NormalKind:
            case VertexBuffer.TangentKind: {
              EnumerateFloatValues(bytes, byteOffset, byteStride2, componentCount, type, count, normalized, (values) => {
                values[0] = -values[0];
              });
            }
          }
        }
        state.convertedToRightHandedBuffers.set(buffer, bytes);
      }
      const bufferView = this._bufferManager.createBufferView(bytes, byteStride);
      state.setVertexBufferView(buffer, bufferView);
      const floatMatricesIndices = /* @__PURE__ */ new Map();
      for (const vertexBuffer of vertexBuffers) {
        const meshes = vertexBufferToMeshesMap.get(vertexBuffer);
        const { kind, totalVertices } = GetVertexBufferInfo(vertexBuffer, meshes);
        switch (kind) {
          case VertexBuffer.MatricesIndicesKind:
          case VertexBuffer.MatricesIndicesExtraKind: {
            if (vertexBuffer.type == VertexBuffer.FLOAT) {
              const floatData = vertexBuffer.getFloatData(totalVertices);
              if (floatData !== null) {
                floatMatricesIndices.set(vertexBuffer, floatData);
              }
            }
          }
        }
      }
      if (floatMatricesIndices.size !== 0) {
        Logger.Warn(`Joint indices conversion needed: some joint indices are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.`);
      }
      const floatArrayVertexBuffers = Array.from(floatMatricesIndices.keys());
      for (const vertexBuffer of floatArrayVertexBuffers) {
        const array = floatMatricesIndices.get(vertexBuffer);
        if (!array) {
          continue;
        }
        const is16Bit = FloatsNeed16BitInteger(array);
        const newArray = new (is16Bit ? Uint16Array : Uint8Array)(array.length);
        for (let index = 0; index < array.length; index++) {
          newArray[index] = array[index];
        }
        const bufferView2 = this._bufferManager.createBufferView(newArray, 4 * (is16Bit ? 2 : 1));
        state.setRemappedBufferView(buffer, vertexBuffer, bufferView2);
      }
    }
    const morphTargets = Array.from(morphTargetsMeshesMap.keys());
    for (const morphTarget of morphTargets) {
      const meshes = morphTargetsMeshesMap.get(morphTarget);
      if (!meshes) {
        continue;
      }
      const glTFMorphTarget = BuildMorphTargetBuffers(morphTarget, meshes[0], this._bufferManager, this._bufferViews, this._accessors, state.convertToRightHanded);
      for (const mesh of meshes) {
        state.bindMorphDataToMesh(mesh, glTFMorphTarget);
      }
    }
  }
  /**
   * Processes a node to be exported to the glTF file
   * @returns A promise that resolves once the node has been exported
   * @internal
   */
  async _exportNodeAsync(babylonNode, parentNodeChildren, state) {
    let nodeIndex = this._nodeMap.get(babylonNode);
    if (nodeIndex !== void 0) {
      if (!parentNodeChildren.includes(nodeIndex)) {
        parentNodeChildren.push(nodeIndex);
      }
      return;
    }
    const node = await this._createNodeAsync(babylonNode, state);
    if (node) {
      nodeIndex = this._nodes.length;
      this._nodes.push(node);
      this._nodeMap.set(babylonNode, nodeIndex);
      state.pushExportedNode(babylonNode);
      parentNodeChildren.push(nodeIndex);
      const runtimeGLTFAnimation = {
        name: "runtime animations",
        channels: [],
        samplers: []
      };
      const idleGLTFAnimations = [];
      if (!this._babylonScene.animationGroups.length) {
        _GLTFAnimation._CreateMorphTargetAnimationFromMorphTargetAnimations(babylonNode, runtimeGLTFAnimation, idleGLTFAnimations, this._nodeMap, this._nodes, this._bufferManager, this._bufferViews, this._accessors, this._animationSampleRate, state.convertToRightHanded, this._options.shouldExportAnimation);
        if (babylonNode.animations.length) {
          _GLTFAnimation._CreateNodeAnimationFromNodeAnimations(babylonNode, runtimeGLTFAnimation, idleGLTFAnimations, this._nodeMap, this._nodes, this._bufferManager, this._bufferViews, this._accessors, this._animationSampleRate, state.convertToRightHanded, this._options.shouldExportAnimation);
        }
      }
      if (runtimeGLTFAnimation.channels.length && runtimeGLTFAnimation.samplers.length) {
        this._animations.push(runtimeGLTFAnimation);
      }
      idleGLTFAnimations.forEach((idleGLTFAnimation) => {
        if (idleGLTFAnimation.channels.length && idleGLTFAnimation.samplers.length) {
          this._animations.push(idleGLTFAnimation);
        }
      });
    }
    const children = node ? [] : parentNodeChildren;
    for (const babylonChildNode of babylonNode.getChildren()) {
      await this._exportNodeAsync(babylonChildNode, children, state);
    }
    if (node && children.length) {
      node.children = children;
    }
  }
  /**
   * Creates a glTF node from a Babylon.js node. If skipped, returns null.
   * @internal
   */
  async _createNodeAsync(babylonNode, state) {
    if (!this._shouldExportNode(babylonNode)) {
      return null;
    }
    const node = {};
    if (babylonNode.name) {
      node.name = babylonNode.name;
    }
    if (babylonNode.metadata) {
      const extras = this._options.metadataSelector(babylonNode.metadata);
      if (extras) {
        node.extras = extras;
      }
    }
    if (babylonNode instanceof TransformNode) {
      this._setNodeTransformation(node, babylonNode, state.convertToRightHanded);
      if (babylonNode instanceof AbstractMesh) {
        const babylonMesh = babylonNode instanceof InstancedMesh ? babylonNode.sourceMesh : babylonNode;
        if (babylonMesh.subMeshes && babylonMesh.subMeshes.length > 0) {
          node.mesh = await this._exportMeshAsync(babylonMesh, state);
        }
        if (babylonNode.skeleton) {
          const skin = this._skinMap.get(babylonNode.skeleton);
          if (skin !== void 0) {
            if (this._nodesSkinMap.get(skin) === void 0) {
              this._nodesSkinMap.set(skin, []);
            }
            this._nodesSkinMap.get(skin)?.push(node);
          }
        }
      }
    }
    if (babylonNode instanceof TargetCamera) {
      const gltfCamera = this._camerasMap.get(babylonNode);
      if (gltfCamera) {
        if (this._nodesCameraMap.get(gltfCamera) === void 0) {
          this._nodesCameraMap.set(gltfCamera, []);
        }
        this._setCameraTransformation(node, babylonNode, state.convertToRightHanded);
        const parentBabylonNode = babylonNode.parent;
        if (parentBabylonNode !== null && IsChildCollapsible(babylonNode, parentBabylonNode)) {
          const parentNodeIndex = this._nodeMap.get(parentBabylonNode);
          if (parentNodeIndex !== void 0) {
            const parentNode = this._nodes[parentNodeIndex];
            CollapseChildIntoParent(node, parentNode);
            this._nodesCameraMap.get(gltfCamera)?.push(parentNode);
            return null;
          }
        }
        this._nodesCameraMap.get(gltfCamera)?.push(node);
      }
    }
    const processedNode = await this._extensionsPostExportNodeAsync("exportNodeAsync", node, babylonNode, this._nodeMap, state.convertToRightHanded);
    if (!processedNode) {
      Logger.Warn(`Not exporting node ${babylonNode.name}`);
      return null;
    }
    return node;
  }
  _exportIndices(indices, is32Bits, start, count, offset, fillMode, sideOrientation, state, primitive) {
    let indicesToExport = null;
    primitive.mode = GetPrimitiveMode(fillMode);
    const flip = sideOrientation !== Material.CounterClockWiseSideOrientation && IsTriangleFillMode(fillMode);
    if (flip) {
      if (fillMode === Material.TriangleStripDrawMode || fillMode === Material.TriangleFanDrawMode) {
        throw new Error("Triangle strip/fan fill mode is not implemented");
      }
      const newIndices = is32Bits ? new Uint32Array(count) : new Uint16Array(count);
      if (indices) {
        for (let i = 0; i + 2 < count; i += 3) {
          newIndices[i] = indices[start + i] + offset;
          newIndices[i + 1] = indices[start + i + 2] + offset;
          newIndices[i + 2] = indices[start + i + 1] + offset;
        }
      } else {
        for (let i = 0; i + 2 < count; i += 3) {
          newIndices[i] = i;
          newIndices[i + 1] = i + 2;
          newIndices[i + 2] = i + 1;
        }
      }
      indicesToExport = newIndices;
    } else if (indices && offset !== 0) {
      const newIndices = is32Bits ? new Uint32Array(count) : new Uint16Array(count);
      for (let i = 0; i < count; i++) {
        newIndices[i] = indices[start + i] + offset;
      }
      indicesToExport = newIndices;
    } else if (indices) {
      indicesToExport = IndicesArrayToTypedSubarray(indices, start, count, is32Bits);
    }
    if (indicesToExport) {
      let accessorIndex = state.getIndicesAccessor(indices, start, count, offset, flip);
      if (accessorIndex === void 0) {
        const bufferView = this._bufferManager.createBufferView(indicesToExport);
        const componentType = is32Bits ? 5125 : 5123;
        this._accessors.push(this._bufferManager.createAccessor(bufferView, "SCALAR", componentType, count, 0));
        accessorIndex = this._accessors.length - 1;
        state.setIndicesAccessor(indices, start, count, offset, flip, accessorIndex);
      }
      primitive.indices = accessorIndex;
    }
  }
  _exportVertexBuffer(vertexBuffer, babylonMaterial, start, count, state, primitive) {
    const kind = vertexBuffer.getKind();
    if (!IsStandardVertexAttribute(kind)) {
      return;
    }
    if (kind.startsWith("uv") && !this._options.exportUnusedUVs) {
      if (!babylonMaterial || !this._materialNeedsUVsSet.has(babylonMaterial)) {
        return;
      }
    }
    let accessorIndex = state.getVertexAccessor(vertexBuffer, start, count);
    if (accessorIndex === void 0) {
      const data = state.convertedToRightHandedBuffers.get(vertexBuffer._buffer) || vertexBuffer._buffer.getData();
      const minMax = kind === VertexBuffer.PositionKind ? GetMinMax(data, vertexBuffer, start, count) : void 0;
      const isFloatMatricesIndices = (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) && vertexBuffer.type === VertexBuffer.FLOAT;
      const vertexBufferType = isFloatMatricesIndices ? VertexBuffer.UNSIGNED_BYTE : vertexBuffer.type;
      const vertexBufferNormalized = isFloatMatricesIndices ? void 0 : vertexBuffer.normalized;
      const bufferView = isFloatMatricesIndices ? state.getRemappedBufferView(vertexBuffer._buffer, vertexBuffer) : state.getVertexBufferView(vertexBuffer._buffer);
      const byteOffset = vertexBuffer.byteOffset + start * vertexBuffer.byteStride;
      this._accessors.push(this._bufferManager.createAccessor(
        bufferView,
        GetAccessorType(kind, state.hasVertexColorAlpha(vertexBuffer)),
        vertexBufferType,
        count,
        byteOffset,
        minMax,
        vertexBufferNormalized
        // TODO: Find other places where this is needed.
      ));
      accessorIndex = this._accessors.length - 1;
      state.setVertexAccessor(vertexBuffer, start, count, accessorIndex);
    }
    primitive.attributes[GetAttributeType(kind)] = accessorIndex;
  }
  async _exportMaterialAsync(babylonMaterial, vertexBuffers, subMesh, primitive) {
    let materialIndex = this._materialMap.get(babylonMaterial);
    if (materialIndex === void 0) {
      const hasUVs = vertexBuffers && Object.keys(vertexBuffers).some((kind) => kind.startsWith("uv"));
      babylonMaterial = babylonMaterial instanceof MultiMaterial ? babylonMaterial.subMaterials[subMesh.materialIndex] : babylonMaterial;
      if (babylonMaterial instanceof PBRBaseMaterial) {
        materialIndex = await this._materialExporter.exportPBRMaterialAsync(babylonMaterial, hasUVs);
      } else if (babylonMaterial instanceof StandardMaterial) {
        materialIndex = await this._materialExporter.exportStandardMaterialAsync(babylonMaterial, hasUVs);
      } else if (babylonMaterial instanceof OpenPBRMaterial) {
        materialIndex = await this._materialExporter.exportOpenPBRMaterialAsync(babylonMaterial, hasUVs);
      } else {
        Logger.Warn(`Unsupported material '${babylonMaterial.name}' with type ${babylonMaterial.getClassName()}`);
        return;
      }
      this._materialMap.set(babylonMaterial, materialIndex);
    }
    primitive.material = materialIndex;
  }
  async _exportMeshAsync(babylonMesh, state) {
    let meshIndex = state.getMesh(babylonMesh);
    if (meshIndex !== void 0) {
      return meshIndex;
    }
    const mesh = { primitives: [] };
    meshIndex = this._meshes.length;
    this._meshes.push(mesh);
    state.setMesh(babylonMesh, meshIndex);
    const indices = babylonMesh.isUnIndexed ? null : babylonMesh.getIndices();
    const vertexBuffers = babylonMesh.geometry?.getVertexBuffers();
    const morphTargets = state.getMorphTargetsFromMesh(babylonMesh);
    const isLinesMesh = babylonMesh instanceof LinesMesh;
    const isGreasedLineMesh = babylonMesh instanceof GreasedLineBaseMesh;
    const subMeshes = babylonMesh.subMeshes;
    if (vertexBuffers && subMeshes && subMeshes.length > 0) {
      for (const subMesh of subMeshes) {
        const primitive = { attributes: {} };
        const babylonMaterial = subMesh.getMaterial() || this._babylonScene.defaultMaterial;
        if (isGreasedLineMesh) {
          const material = {
            name: babylonMaterial.name
          };
          const babylonLinesMesh = babylonMesh;
          const colorWhite = Color3.White();
          const alpha = babylonLinesMesh.material?.alpha ?? 1;
          const color = babylonLinesMesh.greasedLineMaterial?.color ?? colorWhite;
          if (!color.equalsWithEpsilon(colorWhite, Epsilon) || alpha < 1) {
            material.pbrMetallicRoughness = {
              baseColorFactor: [...color.asArray(), alpha]
            };
          }
          this._materials.push(material);
          primitive.material = this._materials.length - 1;
        } else if (isLinesMesh) {
          const material = {
            name: babylonMaterial.name
          };
          const babylonLinesMesh = babylonMesh;
          if (!babylonLinesMesh.color.equalsWithEpsilon(Color3.White(), Epsilon) || babylonLinesMesh.alpha < 1) {
            material.pbrMetallicRoughness = {
              baseColorFactor: [...babylonLinesMesh.color.asArray(), babylonLinesMesh.alpha]
            };
          }
          this._materials.push(material);
          primitive.material = this._materials.length - 1;
        } else {
          await this._exportMaterialAsync(babylonMaterial, vertexBuffers, subMesh, primitive);
        }
        const fillMode = isLinesMesh || isGreasedLineMesh ? Material.LineListDrawMode : babylonMesh.overrideRenderingFillMode ?? babylonMaterial.fillMode;
        let sideOrientation = babylonMaterial._getEffectiveOrientation(babylonMesh);
        if (state.wasAddedByNoopNode && !babylonMesh.getScene().useRightHandedSystem) {
          sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
        }
        this._exportIndices(indices, indices ? AreIndices32Bits(indices, subMesh.indexCount, subMesh.indexStart, subMesh.verticesStart) : subMesh.verticesCount > 65535, indices ? subMesh.indexStart : subMesh.verticesStart, indices ? subMesh.indexCount : subMesh.verticesCount, -subMesh.verticesStart, fillMode, sideOrientation, state, primitive);
        for (const vertexBuffer of Object.values(vertexBuffers)) {
          this._exportVertexBuffer(vertexBuffer, babylonMaterial, subMesh.verticesStart, subMesh.verticesCount, state, primitive);
        }
        if (morphTargets) {
          primitive.targets = [];
          for (const gltfMorphTarget of morphTargets) {
            primitive.targets.push(gltfMorphTarget.attributes);
          }
        }
        mesh.primitives.push(primitive);
        this._extensionsPostExportMeshPrimitive(primitive);
      }
    }
    if (morphTargets) {
      mesh.weights = [];
      if (!mesh.extras) {
        mesh.extras = {};
      }
      mesh.extras.targetNames = [];
      for (const gltfMorphTarget of morphTargets) {
        mesh.weights.push(gltfMorphTarget.influence);
        mesh.extras.targetNames.push(gltfMorphTarget.name);
      }
    }
    return meshIndex;
  }
};
GLTFExporter._ExtensionNames = new Array();
GLTFExporter._ExtensionFactories = {};
GLTFExporter._ExtensionOrders = {};

// node_modules/@babylonjs/serializers/glTF/2.0/glTFSerializer.js
var GLTF2Export = class {
  /**
   * Exports the scene to .gltf file format
   * @param scene Babylon scene
   * @param fileName Name to use for the .gltf file
   * @param options Exporter options
   * @returns Returns the exported data
   */
  static async GLTFAsync(scene, fileName, options) {
    if (!options || !options.exportWithoutWaitingForScene) {
      await scene.whenReadyAsync();
    }
    const exporter = new GLTFExporter(scene, options);
    const data = await exporter.generateGLTFAsync(fileName.replace(/\.[^/.]+$/, ""));
    exporter.dispose();
    return data;
  }
  /**
   * Exports the scene to .glb file format
   * @param scene Babylon scene
   * @param fileName Name to use for the .glb file
   * @param options Exporter options
   * @returns Returns the exported data
   */
  static async GLBAsync(scene, fileName, options) {
    if (!options || !options.exportWithoutWaitingForScene) {
      await scene.whenReadyAsync();
    }
    const exporter = new GLTFExporter(scene, options);
    const data = await exporter.generateGLBAsync(fileName.replace(/\.[^/.]+$/, ""));
    exporter.dispose();
    return data;
  }
};
export {
  GLTF2Export
};
//# sourceMappingURL=glTFSerializer-7BKMKQSO.js.map
