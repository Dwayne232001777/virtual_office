import {
  Camera,
  CreatePolygon,
  CreateText,
  ExtrudePolygon,
  ImageProcessingConfigurationDefines,
  ImageProcessingDefinesMixin,
  ImageProcessingMixin,
  InstancedLinesMesh,
  InstancedMesh,
  Light,
  LinesMesh,
  MaterialHelperGeometryRendering,
  MaterialPluginBase,
  Mesh,
  MorphTarget,
  MultiMaterial,
  OpenPBRMaterial,
  PBRBaseMaterial,
  ProceduralTexture,
  RawTexture,
  Scalar,
  SceneLoaderFlags,
  ShaderMaterial,
  StandardMaterial,
  TargetCamera,
  UVDefinesMixin,
  _CreationDataStorage,
  init_camera,
  init_imageProcessing,
  init_imageProcessingConfiguration_defines,
  init_instancedMesh,
  init_light,
  init_linesMesh,
  init_materialHelper_geometryrendering,
  init_materialPluginBase,
  init_math_scalar,
  init_mesh,
  init_morphTarget,
  init_multiMaterial,
  init_openpbrMaterial,
  init_pbrBaseMaterial,
  init_polygonBuilder,
  init_proceduralTexture,
  init_rawTexture,
  init_sceneLoaderFlags,
  init_shaderMaterial,
  init_standardMaterial,
  init_targetCamera,
  init_textBuilder,
  init_uv_defines
} from "./chunk-JWLZD23T.js";
import {
  EffectFallbacks,
  Material,
  MaterialDefines,
  PushMaterial,
  init_effectFallbacks,
  init_material,
  init_materialDefines,
  init_pushMaterial
} from "./chunk-OBADV6JF.js";
import {
  init_geometry_fragment
} from "./chunk-JIO6C5IF.js";
import {
  init_geometry_vertex
} from "./chunk-RJ2RNMIL.js";
import {
  init_gaussianSplatting,
  init_gaussianSplattingUboDeclaration,
  init_gaussianSplattingVertexDeclaration,
  init_gaussianSplatting_vertex
} from "./chunk-DSLQYMGE.js";
import {
  init_gaussianSplattingFragmentDeclaration,
  init_gaussianSplatting_fragment as init_gaussianSplatting_fragment2
} from "./chunk-RQDKNWPQ.js";
import {
  init_gaussianSplatting as init_gaussianSplatting2,
  init_gaussianSplatting_vertex as init_gaussianSplatting_vertex2
} from "./chunk-6UQQDTV4.js";
import {
  init_gaussianSplatting_fragment
} from "./chunk-5EPOFQSC.js";
import {
  init_minmaxRedux_fragment
} from "./chunk-I4TMRQDB.js";
import {
  init_minmaxRedux_fragment as init_minmaxRedux_fragment2
} from "./chunk-IJXTNMZ6.js";
import {
  init_depth_fragment
} from "./chunk-QJAKFPLU.js";
import {
  init_depth_vertex
} from "./chunk-TDAMRNXH.js";
import {
  init_ssaoCombine_fragment
} from "./chunk-YQPXPURX.js";
import {
  init_sharpen_fragment
} from "./chunk-C62IEWMB.js";
import {
  init_chromaticAberration_fragment
} from "./chunk-Q4ATXN7P.js";
import {
  BackEase,
  CubicEase,
  EasingFunction,
  ExponentialEase,
  init_easing
} from "./chunk-ND5SZGM6.js";
import {
  Vector3CopyToRef,
  Vector3Distance,
  Vector3Dot,
  Vector3SubtractToRef,
  init_math_vector_functions
} from "./chunk-KSPXS46C.js";
import {
  init_abstractEngine_query
} from "./chunk-YW3NGYMJ.js";
import {
  AbstractMesh,
  TransformNode,
  VertexData,
  createYieldingScheduler,
  init_abstractMesh,
  init_coroutine,
  init_mesh_vertexData,
  init_transformNode,
  runCoroutineAsync,
  runCoroutineSync
} from "./chunk-TMHG26QH.js";
import {
  BoundingBox,
  BoundingInfo,
  IntersectionInfo,
  SubMesh,
  init_boundingBox,
  init_boundingInfo,
  init_intersectionInfo,
  init_subMesh
} from "./chunk-JTDOLEW4.js";
import {
  Bone,
  init_bone
} from "./chunk-AF4R4V7O.js";
import {
  Animation,
  AnimationRange,
  init_animation,
  init_animationRange
} from "./chunk-IPODAMC3.js";
import {
  Node,
  init_node
} from "./chunk-E7XHG63E.js";
import {
  AddClipPlaneUniforms,
  BindBonesParameters,
  BindClipPlane,
  BindFogParameters,
  BindLogDepth,
  BindMorphTargetParameters,
  BindSceneUniformBuffer,
  MaterialFlags,
  PrepareAttributesForInstances,
  PrepareDefinesAndAttributesForMorphTargets,
  PrepareDefinesForAttributes,
  PrepareDefinesForCamera,
  PrepareDefinesForFrameBoundValues,
  PrepareDefinesForMisc,
  PrepareDefinesForPrePass,
  PrepareStringDefinesForClipPlanes,
  PrepareUniformsAndSamplersList,
  PushAttributesForInstances,
  init_clipPlaneMaterialHelper,
  init_materialFlags,
  init_materialHelper_functions,
  init_materialHelper_functions_pure
} from "./chunk-R3NLUQNA.js";
import {
  init_engine_multiRender
} from "./chunk-B4ONFBQP.js";
import {
  init_logDepthFragment
} from "./chunk-NCRPMFYT.js";
import {
  init_fogFragment
} from "./chunk-ORGDVUQ5.js";
import {
  StorageBuffer,
  init_storageBuffer
} from "./chunk-RKJ3OZYD.js";
import {
  init_imageProcessingDeclaration
} from "./chunk-VZPPBK3A.js";
import {
  init_imageProcessingFunctions
} from "./chunk-QF4IVEOO.js";
import {
  init_fogFragmentDeclaration
} from "./chunk-YGF775II.js";
import {
  init_clipPlaneFragment
} from "./chunk-OYBIGYUP.js";
import {
  init_logDepthVertex
} from "./chunk-KOTVE4EO.js";
import {
  init_fogVertex
} from "./chunk-72KUQ4IQ.js";
import {
  init_fogVertexDeclaration
} from "./chunk-V3TVNJXE.js";
import {
  init_logDepthDeclaration
} from "./chunk-IEAIFCDZ.js";
import {
  init_clipPlaneVertex
} from "./chunk-W5UENS42.js";
import {
  init_meshUboDeclaration
} from "./chunk-DQLZ7JYN.js";
import {
  init_sceneUboDeclaration
} from "./chunk-WADM34TY.js";
import {
  init_helperFunctions
} from "./chunk-VR6S6BQH.js";
import {
  ActionEvent,
  EventConstants,
  ImageProcessingConfiguration,
  KeyboardEventTypes,
  PrepareSamplersForImageProcessing,
  PrepareUniformsForImageProcessing,
  Scene,
  SceneComponentConstants,
  _ImportHelper,
  init_actionEvent,
  init_deviceInputEvents,
  init_imageProcessingConfiguration,
  init_imageProcessingConfiguration_functions,
  init_import_helper,
  init_keyboardEvents,
  init_scene,
  init_sceneComponent
} from "./chunk-U45B254N.js";
import {
  PointerEventTypes,
  PointerInfo,
  init_pointerEvents
} from "./chunk-CCNHJS5Q.js";
import {
  PickingInfo,
  init_pickingInfo
} from "./chunk-FV6YI4DO.js";
import {
  FloatingOriginCurrentScene,
  GetFullOffsetViewProjectionToRef,
  GetOffsetTransformMatrices,
  init_floatingOriginMatrixOverrides
} from "./chunk-KEMNSKWR.js";
import {
  UniqueIdGenerator,
  init_uniqueIdGenerator
} from "./chunk-3DVETICX.js";
import {
  UniformBuffer,
  init_uniformBuffer
} from "./chunk-ETNKJY4V.js";
import {
  DumpData,
  init_dumpTools
} from "./chunk-RSNSIAVI.js";
import {
  init_abstractEngine_cubeTexture
} from "./chunk-TYUDJDBK.js";
import {
  ApplyPostProcess,
  Axis,
  Engine,
  ObjectRenderer,
  PassPostProcess,
  PostProcess,
  RenderTargetTexture,
  TextureTools,
  ThinPassCubePostProcess,
  ThinPassPostProcess,
  ToHalfFloat,
  init_engine,
  init_engine_alpha,
  init_engine_dynamicBuffer,
  init_math,
  init_math_axis,
  init_objectRenderer,
  init_passPostProcess,
  init_postProcess,
  init_renderTargetTexture,
  init_textureTools,
  init_thinPassPostProcess
} from "./chunk-E2UXTG46.js";
import {
  Path3D,
  init_math_path
} from "./chunk-2EZNXTHP.js";
import {
  PostProcessManager,
  RenderingManager,
  SmartArray,
  init_postProcessManager,
  init_renderingManager,
  init_smartArray
} from "./chunk-XUMUHFKD.js";
import {
  LightConstants,
  init_lightConstants
} from "./chunk-3V3ZT36M.js";
import {
  PerfCounter,
  init_perfCounter
} from "./chunk-TYVCVQQX.js";
import {
  GetTypeForDepthTexture,
  HasStencilAspect,
  IsDepthTexture,
  ThinEngine,
  WebGLShaderProcessor,
  init_textureHelper_functions,
  init_thinEngine,
  init_webGLShaderProcessors
} from "./chunk-TZ4U7RDF.js";
import {
  EffectRenderer,
  EffectWrapper,
  init_effectRenderer
} from "./chunk-4L5VDV4X.js";
import {
  DrawWrapper,
  init_drawWrapper
} from "./chunk-NER52ESJ.js";
import {
  Buffer,
  VertexBuffer,
  init_buffer
} from "./chunk-YEEYUO2W.js";
import {
  BaseTexture,
  GenerateBase64StringFromPixelData,
  Texture,
  ThinTexture,
  init_baseTexture,
  init_compatibilityOptions,
  init_copyTools,
  init_texture,
  init_thinTexture,
  useOpenGLOrientationForUV
} from "./chunk-W2Z3EUIE.js";
import {
  Plane,
  init_math_plane
} from "./chunk-6DIPKSGI.js";
import {
  SerializationHelper,
  Tags,
  init_decorators_serialization,
  init_tags
} from "./chunk-HNJVWIJU.js";
import {
  Color3,
  Color4,
  TmpColors,
  init_math_color
} from "./chunk-FQA5U7KF.js";
import {
  __decorate,
  expandToProperty,
  init_decorators,
  init_tslib_es6,
  serialize,
  serializeAsCameraReference,
  serializeAsColor3,
  serializeAsColor4,
  serializeAsMatrix,
  serializeAsMeshReference,
  serializeAsTexture,
  serializeAsVector2,
  serializeAsVector3
} from "./chunk-KU6EWKFQ.js";
import {
  _WebAudioStaticSound,
  init_webAudioStaticSound
} from "./chunk-YAQBA6HC.js";
import {
  _WebAudioSoundSource,
  init_webAudioSoundSource
} from "./chunk-UOPMYM72.js";
import {
  _WebAudioStreamingSound,
  init_webAudioStreamingSound
} from "./chunk-7BKBHJIC.js";
import {
  DeepCopier,
  Tools,
  init_deepCopier,
  init_tools
} from "./chunk-TQMUJQOB.js";
import {
  Decode,
  ErrorCodes,
  FilesInputStore,
  IsBase64DataUrl,
  RuntimeError,
  init_error,
  init_fileTools,
  init_filesInputStore,
  init_stringTools
} from "./chunk-X7JT3LZV.js";
import {
  WebRequest,
  init_webRequest
} from "./chunk-T55R2ONV.js";
import {
  RandomGUID,
  init_guid
} from "./chunk-PSHGEZXL.js";
import {
  AbstractEngine,
  Effect,
  GetExponentOfTwo,
  InternalTexture,
  Process,
  TimingTools,
  _RetryWithInterval,
  init_abstractEngine,
  init_effect,
  init_internalTexture,
  init_shaderProcessor,
  init_timingTools,
  init_tools_functions
} from "./chunk-WTQMXJ7P.js";
import {
  _WarnImport,
  init_devTools
} from "./chunk-HCT32MRG.js";
import {
  ShaderStore,
  init_shaderStore
} from "./chunk-4OYBTWIA.js";
import {
  _HasSpatialAudioOptions,
  _SpatialAudioDefaults,
  init_abstractSpatialAudio
} from "./chunk-XZNSM4SR.js";
import {
  BuildArray,
  Epsilon,
  Matrix,
  PHI,
  Quaternion,
  TmpVectors,
  ToGammaSpace,
  Vector2,
  Vector3,
  Vector4,
  init_arrayTools,
  init_math_constants,
  init_math_vector
} from "./chunk-VQZCJUUR.js";
import {
  GetClass,
  RegisterClass,
  init_typeStore
} from "./chunk-7ANHXSNA.js";
import {
  PrecisionDate,
  init_precisionDate
} from "./chunk-YU3PZQGE.js";
import {
  EngineStore,
  init_engineStore
} from "./chunk-TS7QJBPS.js";
import {
  Clamp,
  HighestCommonFactor,
  Lerp,
  NormalizeRadians,
  RandomRange,
  WithinEpsilon,
  init_math_scalar_functions
} from "./chunk-XBFJXXXT.js";
import {
  Logger,
  init_logger
} from "./chunk-2X44KPCK.js";
import {
  EventState,
  Observable,
  init_observable
} from "./chunk-PY47FUFT.js";
import {
  __esm
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@babylonjs/core/Animations/animationPropertiesOverride.js
var AnimationPropertiesOverride;
var init_animationPropertiesOverride = __esm({
  "node_modules/@babylonjs/core/Animations/animationPropertiesOverride.js"() {
    init_animation();
    AnimationPropertiesOverride = class {
      constructor() {
        this.enableBlending = false;
        this.blendingSpeed = 0.01;
        this.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE;
      }
    };
  }
});

// node_modules/@babylonjs/core/assetContainer.js
var AbstractAssetContainer, KeepAssets, InstantiatedEntries, AssetContainer;
var init_assetContainer = __esm({
  "node_modules/@babylonjs/core/assetContainer.js"() {
    init_mesh();
    init_transformNode();
    init_abstractMesh();
    init_logger();
    init_engineStore();
    init_instancedMesh();
    init_light();
    init_camera();
    init_tools();
    init_tags();
    AbstractAssetContainer = class {
      constructor() {
        this.rootNodes = [];
        this.cameras = [];
        this.lights = [];
        this.meshes = [];
        this.skeletons = [];
        this.particleSystems = [];
        this.animations = [];
        this.animationGroups = [];
        this.multiMaterials = [];
        this.materials = [];
        this.morphTargetManagers = [];
        this.geometries = [];
        this.transformNodes = [];
        this.actionManagers = [];
        this.textures = [];
        this._environmentTexture = null;
        this.postProcesses = [];
        this.sounds = null;
        this.effectLayers = [];
        this.layers = [];
        this.reflectionProbes = [];
        this.spriteManagers = [];
      }
      /**
       * Texture used in all pbr material as the reflection texture.
       * As in the majority of the scene they are the same (exception for multi room and so on),
       * this is easier to reference from here than from all the materials.
       */
      get environmentTexture() {
        return this._environmentTexture;
      }
      set environmentTexture(value) {
        this._environmentTexture = value;
      }
      /**
       * @returns all meshes, lights, cameras, transformNodes and bones
       */
      getNodes() {
        let nodes = [];
        nodes = nodes.concat(this.meshes);
        nodes = nodes.concat(this.lights);
        nodes = nodes.concat(this.cameras);
        nodes = nodes.concat(this.transformNodes);
        for (const skeleton of this.skeletons) {
          nodes = nodes.concat(skeleton.bones);
        }
        return nodes;
      }
    };
    KeepAssets = class extends AbstractAssetContainer {
    };
    InstantiatedEntries = class {
      constructor() {
        this.rootNodes = [];
        this.skeletons = [];
        this.animationGroups = [];
      }
      /**
       * Disposes the instantiated entries from the scene
       */
      dispose() {
        const rootNodes = this.rootNodes;
        for (const rootNode of rootNodes) {
          rootNode.dispose();
        }
        rootNodes.length = 0;
        const skeletons = this.skeletons;
        for (const skeleton of skeletons) {
          skeleton.dispose();
        }
        skeletons.length = 0;
        const animationGroups = this.animationGroups;
        for (const animationGroup of animationGroups) {
          animationGroup.dispose();
        }
        animationGroups.length = 0;
      }
    };
    AssetContainer = class extends AbstractAssetContainer {
      /**
       * Instantiates an AssetContainer.
       * @param scene The scene the AssetContainer belongs to.
       */
      constructor(scene) {
        super();
        this._wasAddedToScene = false;
        scene = scene || EngineStore.LastCreatedScene;
        if (!scene) {
          return;
        }
        this.scene = scene;
        this["proceduralTextures"] = [];
        scene.onDisposeObservable.add(() => {
          if (!this._wasAddedToScene) {
            this.dispose();
          }
        });
        this._onContextRestoredObserver = scene.getEngine().onContextRestoredObservable.add(() => {
          for (const geometry of this.geometries) {
            geometry._rebuild();
          }
          for (const mesh of this.meshes) {
            mesh._rebuild();
          }
          for (const system of this.particleSystems) {
            system.rebuild();
          }
          for (const texture of this.textures) {
            texture._rebuild();
          }
          for (const spriteManager of this.spriteManagers) {
            spriteManager.rebuild();
          }
        });
      }
      /**
       * Given a list of nodes, return a topological sorting of them.
       * @param nodes
       * @returns a sorted array of nodes
       */
      _topologicalSort(nodes) {
        const nodesUidMap = /* @__PURE__ */ new Map();
        for (const node of nodes) {
          nodesUidMap.set(node.uniqueId, node);
        }
        const dependencyGraph = {
          dependsOn: /* @__PURE__ */ new Map(),
          // given a node id, what are the ids of the nodes it depends on
          dependedBy: /* @__PURE__ */ new Map()
          // given a node id, what are the ids of the nodes that depend on it
        };
        for (const node of nodes) {
          const nodeId = node.uniqueId;
          dependencyGraph.dependsOn.set(nodeId, /* @__PURE__ */ new Set());
          dependencyGraph.dependedBy.set(nodeId, /* @__PURE__ */ new Set());
        }
        for (const node of nodes) {
          const nodeId = node.uniqueId;
          const dependsOn = dependencyGraph.dependsOn.get(nodeId);
          if (node instanceof InstancedMesh) {
            const masterMesh = node.sourceMesh;
            if (nodesUidMap.has(masterMesh.uniqueId)) {
              dependsOn.add(masterMesh.uniqueId);
              dependencyGraph.dependedBy.get(masterMesh.uniqueId).add(nodeId);
            }
          }
          const dependedBy = dependencyGraph.dependedBy.get(nodeId);
          for (const child of node.getDescendants()) {
            const childId = child.uniqueId;
            if (nodesUidMap.has(childId)) {
              dependedBy.add(childId);
              const childDependsOn = dependencyGraph.dependsOn.get(childId);
              childDependsOn.add(nodeId);
            }
          }
        }
        const sortedNodes = [];
        const leaves = [];
        for (const node of nodes) {
          const nodeId = node.uniqueId;
          if (dependencyGraph.dependsOn.get(nodeId).size === 0) {
            leaves.push(node);
            nodesUidMap.delete(nodeId);
          }
        }
        const visitList = leaves;
        while (visitList.length > 0) {
          const nodeToVisit = visitList.shift();
          sortedNodes.push(nodeToVisit);
          const dependedByVisitedNode = dependencyGraph.dependedBy.get(nodeToVisit.uniqueId);
          for (const dependedByVisitedNodeId of Array.from(dependedByVisitedNode.values())) {
            const dependsOnDependedByVisitedNode = dependencyGraph.dependsOn.get(dependedByVisitedNodeId);
            dependsOnDependedByVisitedNode.delete(nodeToVisit.uniqueId);
            if (dependsOnDependedByVisitedNode.size === 0 && nodesUidMap.get(dependedByVisitedNodeId)) {
              visitList.push(nodesUidMap.get(dependedByVisitedNodeId));
              nodesUidMap.delete(dependedByVisitedNodeId);
            }
          }
        }
        if (nodesUidMap.size > 0) {
          Logger.Error("SceneSerializer._topologicalSort: There were unvisited nodes:");
          nodesUidMap.forEach((node) => {
            Logger.Error(node.name);
          });
        }
        return sortedNodes;
      }
      _addNodeAndDescendantsToList(list, addedIds, rootNode, predicate) {
        if (!rootNode || predicate && !predicate(rootNode) || addedIds.has(rootNode.uniqueId)) {
          return;
        }
        list.push(rootNode);
        addedIds.add(rootNode.uniqueId);
        for (const child of rootNode.getDescendants(true)) {
          this._addNodeAndDescendantsToList(list, addedIds, child, predicate);
        }
      }
      /**
       * Check if a specific node is contained in this asset container.
       * @param node the node to check
       * @returns true if the node is contained in this container, otherwise false.
       */
      _isNodeInContainer(node) {
        if (node instanceof AbstractMesh && this.meshes.indexOf(node) !== -1) {
          return true;
        }
        if (node instanceof TransformNode && this.transformNodes.indexOf(node) !== -1) {
          return true;
        }
        if (node instanceof Light && this.lights.indexOf(node) !== -1) {
          return true;
        }
        if (node instanceof Camera && this.cameras.indexOf(node) !== -1) {
          return true;
        }
        return false;
      }
      /**
       * For every node in the scene, check if its parent node is also in the scene.
       * @returns true if every node's parent is also in the scene, otherwise false.
       */
      _isValidHierarchy() {
        for (const node of this.meshes) {
          if (node.parent && !this._isNodeInContainer(node.parent)) {
            Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
            return false;
          }
        }
        for (const node of this.transformNodes) {
          if (node.parent && !this._isNodeInContainer(node.parent)) {
            Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
            return false;
          }
        }
        for (const node of this.lights) {
          if (node.parent && !this._isNodeInContainer(node.parent)) {
            Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
            return false;
          }
        }
        for (const node of this.cameras) {
          if (node.parent && !this._isNodeInContainer(node.parent)) {
            Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
            return false;
          }
        }
        return true;
      }
      /**
       * Instantiate or clone all meshes and add the new ones to the scene.
       * Skeletons and animation groups will all be cloned
       * @param nameFunction defines an optional function used to get new names for clones
       * @param cloneMaterials defines an optional boolean that defines if materials must be cloned as well (false by default)
       * @param options defines an optional list of options to control how to instantiate / clone models
       * @param options.doNotInstantiate defines if the model must be instantiated or just cloned
       * @param options.predicate defines a predicate used to filter whih mesh to instantiate/clone
       * @returns a list of rootNodes, skeletons and animation groups that were duplicated
       */
      instantiateModelsToScene(nameFunction, cloneMaterials = false, options) {
        if (!this._isValidHierarchy()) {
          Tools.Warn("SceneSerializer.InstantiateModelsToScene: The Asset Container hierarchy is not valid.");
        }
        const conversionMap = {};
        const storeMap = {};
        const result = new InstantiatedEntries();
        const alreadySwappedSkeletons = [];
        const alreadySwappedMaterials = [];
        const localOptions = {
          doNotInstantiate: true,
          ...options
        };
        const onClone = (source, clone) => {
          conversionMap[source.uniqueId] = clone.uniqueId;
          storeMap[clone.uniqueId] = clone;
          if (nameFunction) {
            clone.name = nameFunction(source.name);
          }
          if (clone instanceof Mesh) {
            const clonedMesh = clone;
            if (clonedMesh.morphTargetManager) {
              const oldMorphTargetManager = source.morphTargetManager;
              clonedMesh.morphTargetManager = oldMorphTargetManager.clone();
              for (let index = 0; index < oldMorphTargetManager.numTargets; index++) {
                const oldTarget = oldMorphTargetManager.getTarget(index);
                const newTarget = clonedMesh.morphTargetManager.getTarget(index);
                conversionMap[oldTarget.uniqueId] = newTarget.uniqueId;
                storeMap[newTarget.uniqueId] = newTarget;
              }
            }
          }
        };
        const nodesToSort = [];
        const idsOnSortList = /* @__PURE__ */ new Set();
        for (const transformNode of this.transformNodes) {
          if (transformNode.parent === null) {
            this._addNodeAndDescendantsToList(nodesToSort, idsOnSortList, transformNode, localOptions.predicate);
          }
        }
        for (const mesh of this.meshes) {
          if (mesh.parent === null) {
            this._addNodeAndDescendantsToList(nodesToSort, idsOnSortList, mesh, localOptions.predicate);
          }
        }
        const sortedNodes = this._topologicalSort(nodesToSort);
        const onNewCreated = (source, clone) => {
          onClone(source, clone);
          if (source.parent) {
            const replicatedParentId = conversionMap[source.parent.uniqueId];
            const replicatedParent = storeMap[replicatedParentId];
            if (replicatedParent) {
              clone.parent = replicatedParent;
            } else {
              clone.parent = source.parent;
            }
          }
          if (clone.position && source.position) {
            clone.position.copyFrom(source.position);
          }
          if (clone.rotationQuaternion && source.rotationQuaternion) {
            clone.rotationQuaternion.copyFrom(source.rotationQuaternion);
          }
          if (clone.rotation && source.rotation) {
            clone.rotation.copyFrom(source.rotation);
          }
          if (clone.scaling && source.scaling) {
            clone.scaling.copyFrom(source.scaling);
          }
          if (clone.material) {
            const mesh = clone;
            if (mesh.material) {
              if (cloneMaterials) {
                const sourceMaterial = source.material;
                if (alreadySwappedMaterials.indexOf(sourceMaterial) === -1) {
                  let swap = sourceMaterial.clone(nameFunction ? nameFunction(sourceMaterial.name) : "Clone of " + sourceMaterial.name);
                  alreadySwappedMaterials.push(sourceMaterial);
                  conversionMap[sourceMaterial.uniqueId] = swap.uniqueId;
                  storeMap[swap.uniqueId] = swap;
                  if (sourceMaterial.getClassName() === "MultiMaterial") {
                    const multi = sourceMaterial;
                    for (const material of multi.subMaterials) {
                      if (!material) {
                        continue;
                      }
                      swap = material.clone(nameFunction ? nameFunction(material.name) : "Clone of " + material.name);
                      alreadySwappedMaterials.push(material);
                      conversionMap[material.uniqueId] = swap.uniqueId;
                      storeMap[swap.uniqueId] = swap;
                    }
                    multi.subMaterials = multi.subMaterials.map((m) => m && storeMap[conversionMap[m.uniqueId]]);
                  }
                }
                if (mesh.getClassName() !== "InstancedMesh") {
                  mesh.material = storeMap[conversionMap[sourceMaterial.uniqueId]];
                }
              } else {
                if (mesh.material.getClassName() === "MultiMaterial") {
                  if (this.scene.multiMaterials.indexOf(mesh.material) === -1) {
                    this.scene.addMultiMaterial(mesh.material);
                  }
                } else {
                  if (this.scene.materials.indexOf(mesh.material) === -1) {
                    this.scene.addMaterial(mesh.material);
                  }
                }
              }
            }
          }
          if (clone.parent === null) {
            result.rootNodes.push(clone);
          }
        };
        for (const node of sortedNodes) {
          if (node.getClassName() === "InstancedMesh") {
            const instancedNode = node;
            const sourceMesh = instancedNode.sourceMesh;
            const replicatedSourceId = conversionMap[sourceMesh.uniqueId];
            const replicatedSource = typeof replicatedSourceId === "number" ? storeMap[replicatedSourceId] : sourceMesh;
            const replicatedInstancedNode = replicatedSource.createInstance(instancedNode.name);
            onNewCreated(instancedNode, replicatedInstancedNode);
          } else {
            let canInstance = true;
            if (node.getClassName() === "TransformNode" || node.getClassName() === "Node" || node.skeleton || !node.getTotalVertices || node.getTotalVertices() === 0) {
              canInstance = false;
            } else if (localOptions.doNotInstantiate) {
              if (typeof localOptions.doNotInstantiate === "function") {
                canInstance = !localOptions.doNotInstantiate(node);
              } else {
                canInstance = !localOptions.doNotInstantiate;
              }
            }
            const replicatedNode = canInstance ? node.createInstance(`instance of ${node.name}`) : node.clone(`Clone of ${node.name}`, null, true);
            if (!replicatedNode) {
              throw new Error(`Could not clone or instantiate node on Asset Container ${node.name}`);
            }
            onNewCreated(node, replicatedNode);
          }
        }
        for (const s of this.skeletons) {
          if (localOptions.predicate && !localOptions.predicate(s)) {
            continue;
          }
          const clone = s.clone(nameFunction ? nameFunction(s.name) : "Clone of " + s.name);
          for (const m of this.meshes) {
            if (m.skeleton === s && !m.isAnInstance) {
              const copy = storeMap[conversionMap[m.uniqueId]];
              if (!copy || copy.isAnInstance) {
                continue;
              }
              copy.skeleton = clone;
              if (alreadySwappedSkeletons.indexOf(clone) !== -1) {
                continue;
              }
              alreadySwappedSkeletons.push(clone);
              for (const bone of clone.bones) {
                if (bone._linkedTransformNode) {
                  bone._linkedTransformNode = storeMap[conversionMap[bone._linkedTransformNode.uniqueId]];
                }
              }
            }
          }
          result.skeletons.push(clone);
        }
        for (const o of this.animationGroups) {
          if (localOptions.predicate && !localOptions.predicate(o)) {
            continue;
          }
          const clone = o.clone(nameFunction ? nameFunction(o.name) : "Clone of " + o.name, (oldTarget) => {
            const newTarget = storeMap[conversionMap[oldTarget.uniqueId]];
            return newTarget || oldTarget;
          });
          result.animationGroups.push(clone);
        }
        return result;
      }
      /**
       * Adds all the assets from the container to the scene.
       */
      addAllToScene() {
        if (this._wasAddedToScene) {
          return;
        }
        if (!this._isValidHierarchy()) {
          Tools.Warn("SceneSerializer.addAllToScene: The Asset Container hierarchy is not valid.");
        }
        this._wasAddedToScene = true;
        this.addToScene(null);
        if (this.environmentTexture) {
          this.scene.environmentTexture = this.environmentTexture;
        }
        for (const component of this.scene._serializableComponents) {
          component.addFromContainer(this);
        }
        this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
        this._onContextRestoredObserver = null;
      }
      /**
       * Adds assets from the container to the scene.
       * @param predicate defines a predicate used to select which entity will be added (can be null)
       */
      addToScene(predicate = null) {
        const addedNodes = [];
        for (const o of this.cameras) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.addCamera(o);
          addedNodes.push(o);
        }
        for (const o of this.lights) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.addLight(o);
          addedNodes.push(o);
        }
        for (const o of this.meshes) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.addMesh(o);
          addedNodes.push(o);
        }
        for (const o of this.skeletons) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.addSkeleton(o);
        }
        for (const o of this.animations) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.addAnimation(o);
        }
        for (const o of this.animationGroups) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.addAnimationGroup(o);
        }
        for (const o of this.multiMaterials) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.addMultiMaterial(o);
        }
        for (const o of this.materials) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.addMaterial(o);
        }
        for (const o of this.morphTargetManagers) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.addMorphTargetManager(o);
        }
        for (const o of this.geometries) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.addGeometry(o);
        }
        for (const o of this.transformNodes) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.addTransformNode(o);
          addedNodes.push(o);
        }
        for (const o of this.actionManagers) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.addActionManager(o);
        }
        for (const o of this.textures) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.addTexture(o);
        }
        for (const o of this.reflectionProbes) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.addReflectionProbe(o);
        }
        for (const o of this.spriteManagers) {
          if (predicate && !predicate(o)) {
            continue;
          }
          if (!this.scene.spriteManagers) {
            this.scene.spriteManagers = [];
          }
          this.scene.spriteManagers.push(o);
        }
        if (addedNodes.length) {
          const nodeSet = new Set(this.scene.meshes);
          for (const light of this.scene.lights) {
            nodeSet.add(light);
          }
          for (const camera of this.scene.cameras) {
            nodeSet.add(camera);
          }
          for (const transformNode of this.scene.transformNodes) {
            nodeSet.add(transformNode);
          }
          for (const skeleton of this.skeletons) {
            for (const bone of skeleton.bones) {
              nodeSet.add(bone);
            }
          }
          for (const addedNode of addedNodes) {
            if (addedNode.parent && !nodeSet.has(addedNode.parent)) {
              if (addedNode.setParent) {
                addedNode.setParent(null);
              } else {
                addedNode.parent = null;
              }
            }
          }
        }
      }
      /**
       * Removes all the assets in the container from the scene
       */
      removeAllFromScene() {
        if (!this._isValidHierarchy()) {
          Tools.Warn("SceneSerializer.removeAllFromScene: The Asset Container hierarchy is not valid.");
        }
        this._wasAddedToScene = false;
        this.removeFromScene(null);
        if (this.environmentTexture === this.scene.environmentTexture) {
          this.scene.environmentTexture = null;
        }
        for (const component of this.scene._serializableComponents) {
          component.removeFromContainer(this);
        }
      }
      /**
       * Removes assets in the container from the scene
       * @param predicate defines a predicate used to select which entity will be added (can be null)
       */
      removeFromScene(predicate = null) {
        for (const o of this.cameras) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.removeCamera(o);
        }
        for (const o of this.lights) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.removeLight(o);
        }
        for (const o of this.meshes) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.removeMesh(o, true);
        }
        for (const o of this.skeletons) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.removeSkeleton(o);
        }
        for (const o of this.animations) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.removeAnimation(o);
        }
        for (const o of this.animationGroups) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.removeAnimationGroup(o);
        }
        for (const o of this.multiMaterials) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.removeMultiMaterial(o);
        }
        for (const o of this.materials) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.removeMaterial(o);
        }
        for (const o of this.morphTargetManagers) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.removeMorphTargetManager(o);
        }
        for (const o of this.geometries) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.removeGeometry(o);
        }
        for (const o of this.transformNodes) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.removeTransformNode(o);
        }
        for (const o of this.actionManagers) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.removeActionManager(o);
        }
        for (const o of this.textures) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.removeTexture(o);
        }
        for (const o of this.reflectionProbes) {
          if (predicate && !predicate(o)) {
            continue;
          }
          this.scene.removeReflectionProbe(o);
        }
        for (const o of this.spriteManagers) {
          if (predicate && !predicate(o)) {
            continue;
          }
          if (this.scene.spriteManagers) {
            const index = this.scene.spriteManagers.indexOf(o);
            if (index !== -1) {
              this.scene.spriteManagers.splice(index, 1);
            }
          }
        }
      }
      /**
       * Disposes all the assets in the container
       */
      dispose() {
        const cameras = this.cameras.slice(0);
        for (const camera of cameras) {
          camera.dispose();
        }
        this.cameras.length = 0;
        const lights = this.lights.slice(0);
        for (const light of lights) {
          light.dispose();
        }
        this.lights.length = 0;
        const meshes = this.meshes.slice(0);
        for (const mesh of meshes) {
          mesh.dispose();
        }
        this.meshes.length = 0;
        const skeletons = this.skeletons.slice(0);
        for (const skeleton of skeletons) {
          skeleton.dispose();
        }
        this.skeletons.length = 0;
        const animationGroups = this.animationGroups.slice(0);
        for (const animationGroup of animationGroups) {
          animationGroup.dispose();
        }
        this.animationGroups.length = 0;
        const multiMaterials = this.multiMaterials.slice(0);
        for (const multiMaterial of multiMaterials) {
          multiMaterial.dispose();
        }
        this.multiMaterials.length = 0;
        const materials = this.materials.slice(0);
        for (const material of materials) {
          material.dispose();
        }
        this.materials.length = 0;
        const geometries = this.geometries.slice(0);
        for (const geometry of geometries) {
          geometry.dispose();
        }
        this.geometries.length = 0;
        const transformNodes = this.transformNodes.slice(0);
        for (const transformNode of transformNodes) {
          transformNode.dispose();
        }
        this.transformNodes.length = 0;
        const actionManagers = this.actionManagers.slice(0);
        for (const actionManager of actionManagers) {
          actionManager.dispose();
        }
        this.actionManagers.length = 0;
        const textures = this.textures.slice(0);
        for (const texture of textures) {
          texture.dispose();
        }
        this.textures.length = 0;
        const reflectionProbes = this.reflectionProbes.slice(0);
        for (const reflectionProbe of reflectionProbes) {
          reflectionProbe.dispose();
        }
        this.reflectionProbes.length = 0;
        const morphTargetManagers = this.morphTargetManagers.slice(0);
        for (const morphTargetManager of morphTargetManagers) {
          morphTargetManager.dispose();
        }
        this.morphTargetManagers.length = 0;
        const spriteManagers = this.spriteManagers.slice(0);
        for (const spriteManager of spriteManagers) {
          spriteManager.dispose();
        }
        this.spriteManagers.length = 0;
        if (this.environmentTexture) {
          this.environmentTexture.dispose();
          this.environmentTexture = null;
        }
        for (const component of this.scene._serializableComponents) {
          component.removeFromContainer(this, true);
        }
        if (this._onContextRestoredObserver) {
          this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
          this._onContextRestoredObserver = null;
        }
      }
      _moveAssets(sourceAssets, targetAssets, keepAssets) {
        if (!sourceAssets || !targetAssets) {
          return;
        }
        for (const asset of sourceAssets) {
          let move = true;
          if (keepAssets) {
            for (const keepAsset of keepAssets) {
              if (asset === keepAsset) {
                move = false;
                break;
              }
            }
          }
          if (move) {
            targetAssets.push(asset);
            asset._parentContainer = this;
          }
        }
      }
      /**
       * Removes all the assets contained in the scene and adds them to the container.
       * @param keepAssets Set of assets to keep in the scene. (default: empty)
       */
      moveAllFromScene(keepAssets) {
        this._wasAddedToScene = false;
        if (keepAssets === void 0) {
          keepAssets = new KeepAssets();
        }
        for (const key in this) {
          if (Object.prototype.hasOwnProperty.call(this, key)) {
            this[key] = this[key] || (key === "_environmentTexture" ? null : []);
            this._moveAssets(this.scene[key], this[key], keepAssets[key]);
          }
        }
        this.environmentTexture = this.scene.environmentTexture;
        this.removeAllFromScene();
      }
      /**
       * Adds all meshes in the asset container to a root mesh that can be used to position all the contained meshes. The root mesh is then added to the front of the meshes in the assetContainer.
       * @returns the root mesh
       */
      createRootMesh() {
        const rootMesh = new Mesh("assetContainerRootMesh", this.scene);
        for (const m of this.meshes) {
          if (!m.parent) {
            rootMesh.addChild(m);
          }
        }
        this.meshes.unshift(rootMesh);
        return rootMesh;
      }
      /**
       * Merge animations (direct and animation groups) from this asset container into a scene
       * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
       * @param animatables set of animatables to retarget to a node from the scene
       * @param targetConverter defines a function used to convert animation targets from the asset container to the scene (default: search node by name)
       * @returns an array of the new AnimationGroup added to the scene (empty array if none)
       */
      mergeAnimationsTo(scene = EngineStore.LastCreatedScene, animatables, targetConverter = null) {
        if (!scene) {
          Logger.Error("No scene available to merge animations to");
          return [];
        }
        const _targetConverter = targetConverter ? targetConverter : (target) => {
          let node = null;
          const targetProperty = target.animations.length ? target.animations[0].targetProperty : "";
          const name13 = target.name.split(".").join("").split("_primitive")[0];
          switch (targetProperty) {
            case "position":
            case "rotationQuaternion":
              node = scene.getTransformNodeByName(target.name) || scene.getTransformNodeByName(name13);
              break;
            case "influence":
              node = scene.getMorphTargetByName(target.name) || scene.getMorphTargetByName(name13);
              break;
            default:
              node = scene.getNodeByName(target.name) || scene.getNodeByName(name13);
          }
          return node;
        };
        const nodesInAC = this.getNodes();
        for (const nodeInAC of nodesInAC) {
          const nodeInScene = _targetConverter(nodeInAC);
          if (nodeInScene !== null) {
            for (const animationInAC of nodeInAC.animations) {
              const animationsWithSameProperty = nodeInScene.animations.filter((animationInScene) => {
                return animationInScene.targetProperty === animationInAC.targetProperty;
              });
              for (const animationWithSameProperty of animationsWithSameProperty) {
                const index = nodeInScene.animations.indexOf(animationWithSameProperty, 0);
                if (index > -1) {
                  nodeInScene.animations.splice(index, 1);
                }
              }
            }
            nodeInScene.animations = nodeInScene.animations.concat(nodeInAC.animations);
          }
        }
        const newAnimationGroups = [];
        const animationGroups = this.animationGroups.slice();
        for (const animationGroupInAC of animationGroups) {
          newAnimationGroups.push(animationGroupInAC.clone(animationGroupInAC.name, _targetConverter));
          for (const animatable of animationGroupInAC.animatables) {
            animatable.stop();
          }
        }
        for (const animatable of animatables) {
          const target = _targetConverter(animatable.target);
          if (target) {
            scene.beginAnimation(target, animatable.fromFrame, animatable.toFrame, animatable.loopAnimation, animatable.speedRatio, animatable.onAnimationEnd ? animatable.onAnimationEnd : void 0, void 0, true, void 0, animatable.onAnimationLoop ? animatable.onAnimationLoop : void 0);
            scene.stopAnimation(animatable.target);
          }
        }
        return newAnimationGroups;
      }
      /**
       * @since 6.15.0
       * This method checks for any node that has no parent
       * and is not in the rootNodes array, and adds the node
       * there, if so.
       */
      populateRootNodes() {
        this.rootNodes.length = 0;
        for (const m of this.meshes) {
          if (!m.parent && this.rootNodes.indexOf(m) === -1) {
            this.rootNodes.push(m);
          }
        }
        for (const t of this.transformNodes) {
          if (!t.parent && this.rootNodes.indexOf(t) === -1) {
            this.rootNodes.push(t);
          }
        }
        for (const l of this.lights) {
          if (!l.parent && this.rootNodes.indexOf(l) === -1) {
            this.rootNodes.push(l);
          }
        }
        for (const c of this.cameras) {
          if (!c.parent && this.rootNodes.indexOf(c) === -1) {
            this.rootNodes.push(c);
          }
        }
      }
      /**
       * @since 6.26.0
       * Given a root asset, this method will traverse its hierarchy and add it, its children and any materials/skeletons to the container.
       * @param root root node
       */
      addAllAssetsToContainer(root) {
        if (!root) {
          return;
        }
        const nodesToVisit = [];
        const visitedNodes = /* @__PURE__ */ new Set();
        nodesToVisit.push(root);
        while (nodesToVisit.length > 0) {
          const nodeToVisit = nodesToVisit.pop();
          if (nodeToVisit instanceof Mesh) {
            if (nodeToVisit.geometry && this.geometries.indexOf(nodeToVisit.geometry) === -1) {
              this.geometries.push(nodeToVisit.geometry);
            }
            this.meshes.push(nodeToVisit);
          } else if (nodeToVisit instanceof InstancedMesh) {
            this.meshes.push(nodeToVisit);
          } else if (nodeToVisit instanceof TransformNode) {
            this.transformNodes.push(nodeToVisit);
          } else if (nodeToVisit instanceof Light) {
            this.lights.push(nodeToVisit);
          } else if (nodeToVisit instanceof Camera) {
            this.cameras.push(nodeToVisit);
          }
          if (nodeToVisit instanceof AbstractMesh) {
            if (nodeToVisit.material && this.materials.indexOf(nodeToVisit.material) === -1) {
              this.materials.push(nodeToVisit.material);
              for (const texture of nodeToVisit.material.getActiveTextures()) {
                if (this.textures.indexOf(texture) === -1) {
                  this.textures.push(texture);
                }
              }
            }
            if (nodeToVisit.skeleton && this.skeletons.indexOf(nodeToVisit.skeleton) === -1) {
              this.skeletons.push(nodeToVisit.skeleton);
            }
            if (nodeToVisit.morphTargetManager && this.morphTargetManagers.indexOf(nodeToVisit.morphTargetManager) === -1) {
              this.morphTargetManagers.push(nodeToVisit.morphTargetManager);
            }
          }
          for (const child of nodeToVisit.getChildren()) {
            if (!visitedNodes.has(child)) {
              nodesToVisit.push(child);
            }
          }
          visitedNodes.add(nodeToVisit);
        }
        this.populateRootNodes();
      }
      /**
       * Get from a list of objects by tags
       * @param list the list of objects to use
       * @param tagsQuery the query to use
       * @param filter a predicate to filter for tags
       * @returns
       */
      _getByTags(list, tagsQuery, filter) {
        if (tagsQuery === void 0) {
          return list;
        }
        const listByTags = [];
        for (const i in list) {
          const item = list[i];
          if (Tags && Tags.MatchesQuery(item, tagsQuery) && (!filter || filter(item))) {
            listByTags.push(item);
          }
        }
        return listByTags;
      }
      /**
       * Get a list of meshes by tags
       * @param tagsQuery defines the tags query to use
       * @param filter defines a predicate used to filter results
       * @returns an array of Mesh
       */
      getMeshesByTags(tagsQuery, filter) {
        return this._getByTags(this.meshes, tagsQuery, filter);
      }
      /**
       * Get a list of cameras by tags
       * @param tagsQuery defines the tags query to use
       * @param filter defines a predicate used to filter results
       * @returns an array of Camera
       */
      getCamerasByTags(tagsQuery, filter) {
        return this._getByTags(this.cameras, tagsQuery, filter);
      }
      /**
       * Get a list of lights by tags
       * @param tagsQuery defines the tags query to use
       * @param filter defines a predicate used to filter results
       * @returns an array of Light
       */
      getLightsByTags(tagsQuery, filter) {
        return this._getByTags(this.lights, tagsQuery, filter);
      }
      /**
       * Get a list of materials by tags
       * @param tagsQuery defines the tags query to use
       * @param filter defines a predicate used to filter results
       * @returns an array of Material
       */
      getMaterialsByTags(tagsQuery, filter) {
        return this._getByTags(this.materials, tagsQuery, filter).concat(this._getByTags(this.multiMaterials, tagsQuery, filter));
      }
      /**
       * Get a list of transform nodes by tags
       * @param tagsQuery defines the tags query to use
       * @param filter defines a predicate used to filter results
       * @returns an array of TransformNode
       */
      getTransformNodesByTags(tagsQuery, filter) {
        return this._getByTags(this.transformNodes, tagsQuery, filter);
      }
    };
  }
});

// node_modules/@babylonjs/core/Audio/sound.js
function D2r(degrees) {
  return degrees * Math.PI / 180;
}
function R2d(radians) {
  return radians * 180 / Math.PI;
}
var TmpRampOptions, TmpPlayOptions, TmpStopOptions, Sound;
var init_sound = __esm({
  "node_modules/@babylonjs/core/Audio/sound.js"() {
    init_abstractSpatialAudio();
    init_webAudioSoundSource();
    init_webAudioStaticSound();
    init_webAudioStreamingSound();
    init_abstractEngine();
    init_engineStore();
    init_math_vector();
    init_devTools();
    init_logger();
    init_observable();
    init_timingTools();
    init_typeStore();
    TmpRampOptions = {
      duration: 0,
      shape: "linear"
    };
    TmpPlayOptions = {
      duration: 0,
      startOffset: 0,
      waitTime: 0
    };
    TmpStopOptions = {
      waitTime: 0
    };
    Sound = class _Sound {
      /**
       * The name of the sound in the scene.
       */
      get name() {
        return this._soundV2.name;
      }
      set name(value) {
        this._soundV2.name = value;
      }
      /**
       * Does the sound autoplay once loaded.
       */
      get autoplay() {
        return this._soundV2 instanceof _WebAudioSoundSource ? true : this._optionsV2.autoplay;
      }
      set autoplay(value) {
        this._optionsV2.autoplay = value;
      }
      /**
       * Does the sound loop after it finishes playing once.
       */
      get loop() {
        return this._soundV2 instanceof _WebAudioSoundSource ? true : this._soundV2.loop;
      }
      set loop(value) {
        if (this._soundV2 instanceof _WebAudioSoundSource) {
          return;
        }
        if (this._soundV2) {
          this._soundV2.loop = value;
        }
      }
      /**
       * Is this sound currently played.
       */
      get isPlaying() {
        return this._soundV2 instanceof _WebAudioSoundSource ? true : this._soundV2?.state === 3 || !this.isReady() && this._optionsV2.autoplay;
      }
      /**
       * Is this sound currently paused.
       */
      get isPaused() {
        return this._soundV2 instanceof _WebAudioSoundSource ? false : this._soundV2.state === 5;
      }
      /**
       * Define the max distance the sound should be heard (intensity just became 0 at this point).
       * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound
       */
      get maxDistance() {
        return this._optionsV2.spatialMaxDistance || 100;
      }
      set maxDistance(value) {
        this._optionsV2.spatialMaxDistance = value;
        if (this.useCustomAttenuation) {
          return;
        }
        if (this._soundV2) {
          this._initSpatial();
          this._soundV2.spatial.maxDistance = value;
        }
      }
      /**
       * Define the distance attenuation model the sound will follow.
       * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound
       */
      get distanceModel() {
        return this._optionsV2.spatialDistanceModel || "linear";
      }
      set distanceModel(value) {
        this._optionsV2.spatialDistanceModel = value;
        if (this._soundV2) {
          this._initSpatial();
          this._soundV2.spatial.distanceModel = value;
        }
      }
      /**
       * Gets the current time for the sound.
       */
      get currentTime() {
        return this._soundV2 instanceof _WebAudioSoundSource ? this._soundV2.engine.currentTime : this._soundV2.currentTime;
      }
      /**
       * Does this sound enables spatial sound.
       * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound
       */
      get spatialSound() {
        return this._soundV2?._isSpatial ?? false;
      }
      /**
       * Does this sound enables spatial sound.
       * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound
       */
      set spatialSound(newValue) {
        if (this._soundV2) {
          if (newValue) {
            this._initSpatial();
          } else {
            this._soundV2._isSpatial = false;
          }
        }
      }
      get _onReady() {
        if (!this._onReadyObservable) {
          this._onReadyObservable = new Observable();
        }
        return this._onReadyObservable;
      }
      /**
       * Create a sound and attach it to a scene
       * @param name Name of your sound
       * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams and AudioBuffers
       * @param scene defines the scene the sound belongs to
       * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played
       * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming
       */
      constructor(name13, urlOrArrayBuffer, scene, readyToPlayCallback = null, options) {
        this.useCustomAttenuation = false;
        this.soundTrackId = -1;
        this.refDistance = 1;
        this.rolloffFactor = 1;
        this.metadata = null;
        this.onEndedObservable = new Observable();
        this._localDirection = new Vector3(1, 0, 0);
        this._volume = 1;
        this._isReadyToPlay = false;
        this._isDirectional = false;
        this._isOutputConnected = false;
        this._url = null;
        this._onReadyObservable = null;
        this._onReadyToPlay = () => {
          this._scene.mainSoundTrack.addSound(this);
          this._isReadyToPlay = true;
          this._readyToPlayCallback();
          if (this._onReadyObservable) {
            this._onReadyObservable.notifyObservers();
          }
          if (this._optionsV2.autoplay) {
            this.play();
          }
        };
        this._onended = () => {
          if (this.onended) {
            this.onended();
          }
          this.onEndedObservable.notifyObservers(this);
        };
        scene = scene || EngineStore.LastCreatedScene;
        if (!scene) {
          return;
        }
        this._scene = scene;
        _Sound._SceneComponentInitialization(scene);
        this._readyToPlayCallback = readyToPlayCallback || (() => {
        });
        this._customAttenuationFunction = (currentVolume, currentDistance, maxDistance, refDistance, rolloffFactor) => {
          if (currentDistance < maxDistance) {
            return currentVolume * (1 - currentDistance / maxDistance);
          } else {
            return 0;
          }
        };
        options = options || {};
        const optionsV2 = {
          analyzerEnabled: false,
          autoplay: false,
          // `false` for now, but will be set to given option later
          duration: options.length || 0,
          loop: options.loop || false,
          loopEnd: 0,
          loopStart: 0,
          outBus: null,
          outBusAutoDefault: false,
          playbackRate: options.playbackRate || 1,
          pitch: 0,
          skipCodecCheck: options.skipCodecCheck || false,
          spatialDistanceModel: options.distanceModel,
          spatialEnabled: options.spatialSound,
          spatialMaxDistance: options.maxDistance,
          spatialMinDistance: options.refDistance,
          spatialRolloffFactor: options.rolloffFactor,
          stereoEnabled: false,
          startOffset: options.offset || 0,
          volume: options.volume ?? 1
        };
        this._volume = options.volume ?? 1;
        if (_HasSpatialAudioOptions(optionsV2)) {
          optionsV2.spatialAutoUpdate = false;
          optionsV2.spatialConeInnerAngle = _SpatialAudioDefaults.coneInnerAngle;
          optionsV2.spatialConeOuterAngle = _SpatialAudioDefaults.coneOuterAngle;
          optionsV2.spatialConeOuterVolume = _SpatialAudioDefaults.coneOuterVolume;
          optionsV2.spatialMinUpdateTime = 0;
          optionsV2.spatialOrientation = _SpatialAudioDefaults.orientation.clone();
          optionsV2.spatialPanningModel = this._scene.headphone ? "HRTF" : "equalpower";
          optionsV2.spatialPosition = _SpatialAudioDefaults.position.clone();
          optionsV2.spatialRotation = _SpatialAudioDefaults.rotation.clone();
          optionsV2.spatialRotationQuaternion = _SpatialAudioDefaults.rotationQuaternion.clone();
          if (optionsV2.spatialMaxDistance === void 0) {
            optionsV2.spatialMaxDistance = 100;
          }
        }
        this._optionsV2 = { ...optionsV2 };
        this._optionsV2.autoplay = options.autoplay || false;
        this.useCustomAttenuation = options.useCustomAttenuation ?? false;
        if (this.useCustomAttenuation) {
          optionsV2.spatialMaxDistance = Number.MAX_VALUE;
          optionsV2.volume = 0;
        }
        let streaming = options?.streaming || false;
        const audioEngine = AbstractEngine.audioEngine;
        if (!audioEngine) {
          return;
        }
        const audioEngineV2 = AbstractEngine.audioEngine._v2;
        const createSoundV2 = () => {
          if (streaming) {
            const streamingOptionsV2 = {
              preloadCount: 0,
              ...optionsV2
            };
            const sound = new _WebAudioStreamingSound(name13, audioEngineV2, streamingOptionsV2);
            void sound._initAsync(urlOrArrayBuffer, optionsV2).then(() => {
              void sound.preloadInstancesAsync(1).then(this._onReadyToPlay);
            });
            return sound;
          } else {
            const sound = new _WebAudioStaticSound(name13, audioEngineV2, optionsV2);
            void sound._initAsync(urlOrArrayBuffer, optionsV2).then(this._onReadyToPlay);
            return sound;
          }
        };
        if (!urlOrArrayBuffer) {
          this._soundV2 = new _WebAudioStaticSound(name13, audioEngineV2, optionsV2);
        } else if (typeof urlOrArrayBuffer === "string") {
          this._url = urlOrArrayBuffer;
          this._soundV2 = createSoundV2();
        } else if (urlOrArrayBuffer instanceof ArrayBuffer) {
          streaming = false;
          this._soundV2 = createSoundV2();
        } else if (urlOrArrayBuffer instanceof HTMLMediaElement) {
          streaming = true;
          this._soundV2 = createSoundV2();
        } else if (urlOrArrayBuffer instanceof MediaStream) {
          const node = new MediaStreamAudioSourceNode(audioEngineV2._audioContext, { mediaStream: urlOrArrayBuffer });
          this._soundV2 = new _WebAudioSoundSource(name13, node, audioEngineV2, optionsV2);
          void this._soundV2._initAsync(optionsV2).then(this._onReadyToPlay);
        } else if (urlOrArrayBuffer instanceof AudioBuffer) {
          streaming = false;
          this._soundV2 = createSoundV2();
        } else if (Array.isArray(urlOrArrayBuffer)) {
          this._soundV2 = createSoundV2();
        }
        if (!this._soundV2) {
          Logger.Error("Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.");
          return;
        }
        if (!(this._soundV2 instanceof _WebAudioSoundSource)) {
          this._soundV2.onEndedObservable.add(this._onended);
        }
      }
      /**
       * Release the sound and its associated resources
       */
      dispose() {
        if (this.isPlaying) {
          this.stop();
        }
        this._isReadyToPlay = false;
        if (this.soundTrackId === -1) {
          this._scene.mainSoundTrack.removeSound(this);
        } else if (this._scene.soundTracks) {
          this._scene.soundTracks[this.soundTrackId].removeSound(this);
        }
        if (this._connectedTransformNode && this._registerFunc) {
          this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
          this._connectedTransformNode = null;
        }
        this._soundV2.dispose();
      }
      /**
       * Gets if the sounds is ready to be played or not.
       * @returns true if ready, otherwise false
       */
      isReady() {
        return this._isReadyToPlay;
      }
      /**
       * Get the current class name.
       * @returns current class name
       */
      getClassName() {
        return "Sound";
      }
      /**
       * Sets the data of the sound from an audiobuffer
       * @param audioBuffer The audioBuffer containing the data
       */
      setAudioBuffer(audioBuffer) {
        if (this._isReadyToPlay) {
          return;
        }
        if (this._soundV2 instanceof _WebAudioStaticSound) {
          this._soundV2._initAsync(audioBuffer, this._optionsV2).then(this._onReadyToPlay);
        }
      }
      /**
       * Updates the current sounds options such as maxdistance, loop...
       * @param options A JSON object containing values named as the object properties
       */
      updateOptions(options) {
        if (options) {
          this.loop = options.loop ?? this.loop;
          this.maxDistance = options.maxDistance ?? this.maxDistance;
          this.useCustomAttenuation = options.useCustomAttenuation ?? this.useCustomAttenuation;
          this.rolloffFactor = options.rolloffFactor ?? this.rolloffFactor;
          this.refDistance = options.refDistance ?? this.refDistance;
          this.distanceModel = options.distanceModel ?? this.distanceModel;
          if (options.playbackRate !== void 0) {
            this.setPlaybackRate(options.playbackRate);
          }
          if (options.spatialSound !== void 0) {
            this.spatialSound = options.spatialSound;
          }
          if (options.volume !== void 0) {
            this.setVolume(options.volume);
          }
          if (this._soundV2 instanceof _WebAudioStaticSound) {
            let updated = false;
            if (options.offset !== void 0) {
              this._optionsV2.startOffset = options.offset;
              updated = true;
            }
            if (options.length !== void 0) {
              this._soundV2.duration = options.length;
              updated = true;
            }
            if (updated && this.isPaused) {
              this.stop();
            }
          }
          this._updateSpatialParameters();
        }
      }
      _updateSpatialParameters() {
        if (!this.spatialSound) {
          return;
        }
        const spatial = this._soundV2.spatial;
        if (this.useCustomAttenuation) {
          spatial.distanceModel = "linear";
          spatial.minDistance = 1;
          spatial.maxDistance = Number.MAX_VALUE;
          spatial.rolloffFactor = 1;
          spatial.panningModel = "equalpower";
        } else {
          spatial.distanceModel = this.distanceModel;
          spatial.minDistance = this.refDistance;
          spatial.maxDistance = this.maxDistance;
          spatial.rolloffFactor = this.rolloffFactor;
          spatial.panningModel = this._optionsV2.spatialPanningModel || "equalpower";
        }
      }
      /**
       * Switch the panning model to HRTF:
       * Renders a stereo output of higher quality than equalpower  it uses a convolution with measured impulse responses from human subjects.
       * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound
       */
      switchPanningModelToHRTF() {
        if (this.spatialSound) {
          this._initSpatial();
          this._soundV2.spatial.panningModel = "HRTF";
        }
      }
      /**
       * Switch the panning model to Equal Power:
       * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.
       * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound
       */
      switchPanningModelToEqualPower() {
        if (this.spatialSound) {
          this._initSpatial();
          this._soundV2.spatial.panningModel = "equalpower";
        }
      }
      /**
       * Connect this sound to a sound track audio node like gain...
       * @param soundTrackAudioNode the sound track audio node to connect to
       */
      connectToSoundTrackAudioNode(soundTrackAudioNode) {
        const outputNode = this._soundV2._outNode;
        if (outputNode) {
          if (this._isOutputConnected) {
            outputNode.disconnect();
          }
          outputNode.connect(soundTrackAudioNode);
          this._isOutputConnected = true;
        }
      }
      /**
       * Transform this sound into a directional source
       * @param coneInnerAngle Size of the inner cone in degree
       * @param coneOuterAngle Size of the outer cone in degree
       * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)
       */
      setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        if (coneOuterAngle < coneInnerAngle) {
          Logger.Error("setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.");
          return;
        }
        this._optionsV2.spatialConeInnerAngle = D2r(coneInnerAngle);
        this._optionsV2.spatialConeOuterAngle = D2r(coneOuterAngle);
        this._optionsV2.spatialConeOuterVolume = coneOuterGain;
        this._initSpatial();
        this._soundV2.spatial.coneInnerAngle = this._optionsV2.spatialConeInnerAngle;
        this._soundV2.spatial.coneOuterAngle = this._optionsV2.spatialConeOuterAngle;
        this._soundV2.spatial.coneOuterVolume = coneOuterGain;
        this._isDirectional = true;
        if (this.isPlaying && this.loop) {
          this.stop();
          this.play(0, this._optionsV2.startOffset, this._optionsV2.duration);
        }
      }
      /**
       * Gets or sets the inner angle for the directional cone.
       */
      get directionalConeInnerAngle() {
        return R2d(typeof this._optionsV2.spatialConeInnerAngle === "number" ? this._optionsV2.spatialConeInnerAngle : _SpatialAudioDefaults.coneInnerAngle);
      }
      /**
       * Gets or sets the inner angle for the directional cone.
       */
      set directionalConeInnerAngle(value) {
        value = D2r(value);
        if (value != this._optionsV2.spatialConeInnerAngle) {
          if (this.directionalConeOuterAngle < value) {
            Logger.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");
            return;
          }
          this._optionsV2.spatialConeInnerAngle = value;
          if (this.spatialSound) {
            this._initSpatial();
            this._soundV2.spatial.coneInnerAngle = value;
          }
        }
      }
      /**
       * Gets or sets the outer angle for the directional cone.
       */
      get directionalConeOuterAngle() {
        return R2d(typeof this._optionsV2.spatialConeOuterAngle === "number" ? this._optionsV2.spatialConeOuterAngle : _SpatialAudioDefaults.coneOuterAngle);
      }
      /**
       * Gets or sets the outer angle for the directional cone.
       */
      set directionalConeOuterAngle(value) {
        value = D2r(value);
        if (value != this._optionsV2.spatialConeOuterAngle) {
          if (value < this.directionalConeInnerAngle) {
            Logger.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");
            return;
          }
          this._optionsV2.spatialConeOuterAngle = value;
          if (this.spatialSound) {
            this._initSpatial();
            this._soundV2.spatial.coneOuterAngle = value;
          }
        }
      }
      /**
       * Sets the position of the emitter if spatial sound is enabled
       * @param newPosition Defines the new position
       */
      setPosition(newPosition) {
        if (this._optionsV2.spatialPosition && newPosition.equals(this._optionsV2.spatialPosition)) {
          return;
        }
        if (!this._optionsV2.spatialPosition) {
          this._optionsV2.spatialPosition = Vector3.Zero();
        }
        this._optionsV2.spatialPosition.copyFrom(newPosition);
        if (this.spatialSound && !isNaN(newPosition.x) && !isNaN(newPosition.y) && !isNaN(newPosition.z)) {
          this._initSpatial();
          this._soundV2.spatial.position = newPosition;
        }
      }
      /**
       * Sets the local direction of the emitter if spatial sound is enabled
       * @param newLocalDirection Defines the new local direction
       */
      setLocalDirectionToMesh(newLocalDirection) {
        this._localDirection = newLocalDirection;
        if (this._connectedTransformNode && this.isPlaying) {
          this._updateDirection();
        }
      }
      _updateDirection() {
        if (!this._connectedTransformNode || !this.spatialSound) {
          return;
        }
        const mat = this._connectedTransformNode.getWorldMatrix();
        const direction = Vector3.TransformNormal(this._localDirection, mat);
        direction.normalize();
        this._initSpatial();
        this._soundV2.spatial.orientation = direction;
      }
      _initSpatial() {
        this._soundV2._isSpatial = true;
        if (this._optionsV2.spatialDistanceModel === void 0) {
          this._optionsV2.spatialDistanceModel = "linear";
          this._soundV2.spatial.distanceModel = "linear";
        }
        if (this._optionsV2.spatialMaxDistance === void 0) {
          this._optionsV2.spatialMaxDistance = 100;
          this._soundV2.spatial.maxDistance = 100;
        }
      }
      /** @internal */
      updateDistanceFromListener() {
        if (this._soundV2._outNode && this._connectedTransformNode && this.useCustomAttenuation && this._scene.activeCamera) {
          const distance = this._scene.audioListenerPositionProvider ? this._connectedTransformNode.position.subtract(this._scene.audioListenerPositionProvider()).length() : this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);
          this._soundV2.volume = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);
        }
      }
      /**
       * Sets a new custom attenuation function for the sound.
       * @param callback Defines the function used for the attenuation
       * @see https://doc.babylonjs.com/legacy/audio#creating-your-own-custom-attenuation-function
       */
      setAttenuationFunction(callback) {
        this._customAttenuationFunction = callback;
      }
      /**
       * Play the sound
       * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.
       * @param offset (optional) Start the sound at a specific time in seconds
       * @param length (optional) Sound duration (in seconds)
       */
      play(time, offset, length) {
        const audioEngine = AbstractEngine.audioEngine;
        audioEngine?.unlock();
        if (this._soundV2 instanceof _WebAudioSoundSource) {
          return;
        }
        if (this._isReadyToPlay && this._scene.audioEnabled) {
          if (this._soundV2.state === 5 && (time !== void 0 || offset !== void 0 || length !== void 0)) {
            this._soundV2.stop();
          }
          try {
            TmpPlayOptions.duration = length || 0;
            TmpPlayOptions.startOffset = offset !== void 0 ? offset || this._optionsV2.startOffset : this._optionsV2.startOffset;
            TmpPlayOptions.waitTime = time || 0;
            TmpPlayOptions.loop = void 0;
            TmpPlayOptions.loopStart = void 0;
            TmpPlayOptions.loopEnd = void 0;
            TmpPlayOptions.volume = void 0;
            if (audioEngine?.unlocked) {
              this._soundV2.play(TmpPlayOptions);
            } else {
              setTimeout(() => {
                this._soundV2.play(TmpPlayOptions);
              }, 500);
            }
          } catch (ex) {
            Logger.Error("Error while trying to play audio: " + this.name + ", " + ex.message);
          }
        }
      }
      /**
       * Stop the sound
       * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.
       */
      stop(time) {
        if (!this._soundV2) {
          return;
        }
        if (this._soundV2 instanceof _WebAudioSoundSource) {
          return;
        }
        TmpStopOptions.waitTime = time || 0;
        this._soundV2.stop(TmpStopOptions);
      }
      /**
       * Put the sound in pause
       */
      pause() {
        if (!this._soundV2) {
          return;
        }
        if (this._soundV2 instanceof _WebAudioSoundSource) {
          return;
        }
        this._soundV2.pause();
      }
      /**
       * Sets a dedicated volume for this sounds
       * @param newVolume Define the new volume of the sound
       * @param time Define time for gradual change to new volume
       */
      setVolume(newVolume, time) {
        if (!this.isReady()) {
          this._onReady.addOnce(() => {
            this.setVolume(newVolume, time);
          });
          return;
        }
        TmpRampOptions.duration = time || 0;
        this._soundV2.setVolume(newVolume, TmpRampOptions);
        this._volume = newVolume;
      }
      /**
       * Set the sound play back rate
       * @param newPlaybackRate Define the playback rate the sound should be played at
       */
      setPlaybackRate(newPlaybackRate) {
        if (this._soundV2 instanceof _WebAudioStaticSound) {
          this._soundV2.playbackRate = newPlaybackRate;
        }
      }
      /**
       * Gets the sound play back rate.
       * @returns the  play back rate of the sound
       */
      getPlaybackRate() {
        if (this._soundV2 instanceof _WebAudioStaticSound) {
          return this._soundV2.playbackRate;
        }
        return 1;
      }
      /**
       * Gets the volume of the sound.
       * @returns the volume of the sound
       */
      getVolume() {
        return this._volume;
      }
      /**
       * Attach the sound to a dedicated mesh
       * @param transformNode The transform node to connect the sound with
       * @see https://doc.babylonjs.com/legacy/audio#attaching-a-sound-to-a-mesh
       */
      attachToMesh(transformNode) {
        if (this._connectedTransformNode && this._registerFunc) {
          this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
          this._registerFunc = null;
        }
        this._connectedTransformNode = transformNode;
        if (!this.spatialSound) {
          this.spatialSound = true;
          if (this.isPlaying && this.loop) {
            this.stop();
            this.play(0, this._optionsV2.startOffset, this._optionsV2.duration);
          }
        }
        this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);
        this._registerFunc = (transformNode2) => this._onRegisterAfterWorldMatrixUpdate(transformNode2);
        this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);
      }
      /**
       * Detach the sound from the previously attached mesh
       * @see https://doc.babylonjs.com/legacy/audio#attaching-a-sound-to-a-mesh
       */
      detachFromMesh() {
        if (this._connectedTransformNode && this._registerFunc) {
          this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
          this._registerFunc = null;
          this._connectedTransformNode = null;
        }
      }
      _onRegisterAfterWorldMatrixUpdate(node) {
        if (!node.getBoundingInfo) {
          this.setPosition(node.absolutePosition);
        } else {
          const mesh = node;
          const boundingInfo = mesh.getBoundingInfo();
          this.setPosition(boundingInfo.boundingSphere.centerWorld);
        }
        if (this._isDirectional && this.isPlaying) {
          this._updateDirection();
        }
      }
      /**
       * Clone the current sound in the scene.
       * @returns the new sound clone
       */
      clone() {
        if (!(this._soundV2 instanceof _WebAudioStaticSound)) {
          return null;
        }
        const currentOptions = {
          autoplay: this.autoplay,
          loop: this.loop,
          volume: this._volume,
          spatialSound: this.spatialSound,
          maxDistance: this.maxDistance,
          useCustomAttenuation: this.useCustomAttenuation,
          rolloffFactor: this.rolloffFactor,
          refDistance: this.refDistance,
          distanceModel: this.distanceModel
        };
        const clonedSound = new _Sound(this.name + "_cloned", this._soundV2.buffer, this._scene, null, currentOptions);
        clonedSound._optionsV2 = this._optionsV2;
        if (this.useCustomAttenuation) {
          clonedSound.setAttenuationFunction(this._customAttenuationFunction);
        }
        return clonedSound;
      }
      /**
       * Gets the current underlying audio buffer containing the data
       * @returns the audio buffer
       */
      getAudioBuffer() {
        if (this._soundV2 instanceof _WebAudioStaticSound) {
          return this._soundV2.buffer._audioBuffer;
        }
        return null;
      }
      /**
       * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.
       * @returns the source node
       */
      getSoundSource() {
        return null;
      }
      /**
       * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.
       * @returns the gain node
       */
      getSoundGain() {
        return this._soundV2._outNode;
      }
      /**
       * Serializes the Sound in a JSON representation
       * @returns the JSON representation of the sound
       */
      serialize() {
        const serializationObject = {
          name: this.name,
          url: this._url,
          autoplay: this.autoplay,
          loop: this.loop,
          volume: this._volume,
          spatialSound: this.spatialSound,
          maxDistance: this.maxDistance,
          rolloffFactor: this.rolloffFactor,
          refDistance: this.refDistance,
          distanceModel: this.distanceModel,
          playbackRate: this.getPlaybackRate(),
          panningModel: this._soundV2.spatial.panningModel,
          soundTrackId: this.soundTrackId,
          metadata: this.metadata
        };
        if (this.spatialSound) {
          if (this._connectedTransformNode) {
            serializationObject.connectedMeshId = this._connectedTransformNode.id;
          }
          serializationObject.position = this._soundV2.spatial.position.asArray();
          serializationObject.refDistance = this.refDistance;
          serializationObject.distanceModel = this.distanceModel;
          serializationObject.isDirectional = this._isDirectional;
          serializationObject.localDirectionToMesh = this._localDirection.asArray();
          serializationObject.coneInnerAngle = this.directionalConeInnerAngle;
          serializationObject.coneOuterAngle = this.directionalConeOuterAngle;
          serializationObject.coneOuterGain = this._soundV2.spatial.coneOuterVolume;
        }
        return serializationObject;
      }
      /**
       * Parse a JSON representation of a sound to instantiate in a given scene
       * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)
       * @param scene Define the scene the new parsed sound should be created in
       * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies
       * @param sourceSound Define a sound place holder if do not need to instantiate a new one
       * @returns the newly parsed sound
       */
      static Parse(parsedSound, scene, rootUrl, sourceSound) {
        const soundName = parsedSound.name;
        let soundUrl;
        if (parsedSound.url) {
          soundUrl = rootUrl + parsedSound.url;
        } else {
          soundUrl = rootUrl + soundName;
        }
        const options = {
          autoplay: parsedSound.autoplay,
          loop: parsedSound.loop,
          volume: parsedSound.volume,
          spatialSound: parsedSound.spatialSound,
          maxDistance: parsedSound.maxDistance,
          rolloffFactor: parsedSound.rolloffFactor,
          refDistance: parsedSound.refDistance,
          distanceModel: parsedSound.distanceModel,
          playbackRate: parsedSound.playbackRate
        };
        let newSound;
        if (!sourceSound) {
          newSound = new _Sound(soundName, soundUrl, scene, () => {
            scene.removePendingData(newSound);
          }, options);
          scene.addPendingData(newSound);
        } else {
          const setBufferAndRun = () => {
            _RetryWithInterval(() => sourceSound._isReadyToPlay, () => {
              const audioBuffer = sourceSound.getAudioBuffer();
              if (audioBuffer) {
                newSound.setAudioBuffer(audioBuffer);
              }
              newSound._isReadyToPlay = true;
              if (newSound.autoplay) {
                newSound.play(0, sourceSound._optionsV2.startOffset, sourceSound._optionsV2.duration);
              }
            }, void 0, 300);
          };
          newSound = new _Sound(soundName, new ArrayBuffer(0), scene, null, options);
          setBufferAndRun();
        }
        if (parsedSound.position) {
          const soundPosition = Vector3.FromArray(parsedSound.position);
          newSound.setPosition(soundPosition);
        }
        if (parsedSound.isDirectional) {
          newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);
          if (parsedSound.localDirectionToMesh) {
            const localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);
            newSound.setLocalDirectionToMesh(localDirectionToMesh);
          }
        }
        if (parsedSound.connectedMeshId) {
          const connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);
          if (connectedMesh) {
            newSound.attachToMesh(connectedMesh);
          }
        }
        if (parsedSound.metadata) {
          newSound.metadata = parsedSound.metadata;
        }
        return newSound;
      }
    };
    Sound._SceneComponentInitialization = (_) => {
      throw _WarnImport("AudioSceneComponent");
    };
    RegisterClass("BABYLON.Sound", Sound);
  }
});

// node_modules/@babylonjs/core/Loading/Plugins/babylonFileParser.function.js
function AddParser(name13, parser) {
  BabylonFileParsers[name13] = parser;
}
function GetParser(name13) {
  if (BabylonFileParsers[name13]) {
    return BabylonFileParsers[name13];
  }
  return null;
}
function AddIndividualParser(name13, parser) {
  IndividualBabylonFileParsers[name13] = parser;
}
function GetIndividualParser(name13) {
  if (IndividualBabylonFileParsers[name13]) {
    return IndividualBabylonFileParsers[name13];
  }
  return null;
}
function Parse(jsonData, scene, container, rootUrl) {
  for (const parserName in BabylonFileParsers) {
    if (Object.prototype.hasOwnProperty.call(BabylonFileParsers, parserName)) {
      BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);
    }
  }
}
var BabylonFileParsers, IndividualBabylonFileParsers;
var init_babylonFileParser_function = __esm({
  "node_modules/@babylonjs/core/Loading/Plugins/babylonFileParser.function.js"() {
    BabylonFileParsers = {};
    IndividualBabylonFileParsers = {};
  }
});

// node_modules/@babylonjs/core/Bones/skeleton.js
var Skeleton;
var init_skeleton = __esm({
  "node_modules/@babylonjs/core/Bones/skeleton.js"() {
    init_bone();
    init_observable();
    init_math_vector();
    init_rawTexture();
    init_animation();
    init_animationRange();
    init_engineStore();
    init_logger();
    init_deepCopier();
    Skeleton = class _Skeleton {
      /**
       * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).
       * Please note that this option is not available if the hardware does not support it
       */
      get useTextureToStoreBoneMatrices() {
        return this._useTextureToStoreBoneMatrices;
      }
      set useTextureToStoreBoneMatrices(value) {
        this._useTextureToStoreBoneMatrices = value;
        this._markAsDirty();
      }
      /**
       * Gets or sets the animation properties override
       */
      get animationPropertiesOverride() {
        if (!this._animationPropertiesOverride) {
          return this._scene.animationPropertiesOverride;
        }
        return this._animationPropertiesOverride;
      }
      set animationPropertiesOverride(value) {
        this._animationPropertiesOverride = value;
      }
      /**
       * Gets a boolean indicating that the skeleton effectively stores matrices into a texture
       */
      get isUsingTextureForMatrices() {
        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;
      }
      /**
       * Gets the unique ID of this skeleton
       */
      get uniqueId() {
        return this._uniqueId;
      }
      /**
       * Creates a new skeleton
       * @param name defines the skeleton name
       * @param id defines the skeleton Id
       * @param scene defines the hosting scene
       */
      constructor(name13, id, scene) {
        this.name = name13;
        this.id = id;
        this.bones = [];
        this.needInitialSkinMatrix = false;
        this._isDirty = true;
        this._meshesWithPoseMatrix = new Array();
        this._identity = Matrix.Identity();
        this._currentRenderId = -1;
        this._ranges = {};
        this._absoluteTransformIsDirty = true;
        this._canUseTextureForBones = false;
        this._uniqueId = 0;
        this._numBonesWithLinkedTransformNode = 0;
        this._hasWaitingData = null;
        this._parentContainer = null;
        this.doNotSerialize = false;
        this._useTextureToStoreBoneMatrices = true;
        this._animationPropertiesOverride = null;
        this.onBeforeComputeObservable = new Observable();
        this.metadata = null;
        this.bones = [];
        this._scene = scene || EngineStore.LastCreatedScene;
        this._uniqueId = this._scene.getUniqueId();
        this._scene.addSkeleton(this);
        this._isDirty = true;
        const engineCaps = this._scene.getEngine().getCaps();
        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;
      }
      /**
       * Gets the current object class name.
       * @returns the class name
       */
      getClassName() {
        return "Skeleton";
      }
      /**
       * Returns an array containing the root bones
       * @returns an array containing the root bones
       */
      getChildren() {
        return this.bones.filter((b) => !b.getParent());
      }
      // Members
      /**
       * Gets the list of transform matrices to send to shaders (one matrix per bone)
       * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)
       * @returns a Float32Array containing matrices data
       */
      getTransformMatrices(mesh) {
        if (this.needInitialSkinMatrix) {
          if (!mesh) {
            throw new Error("getTransformMatrices: When using the needInitialSkinMatrix flag, a mesh must be provided");
          }
          if (!mesh._bonesTransformMatrices) {
            this.prepare(true);
          }
          return mesh._bonesTransformMatrices;
        }
        if (!this._transformMatrices || this._isDirty) {
          this.prepare(!this._transformMatrices);
        }
        return this._transformMatrices;
      }
      /**
       * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)
       * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)
       * @returns a raw texture containing the data
       */
      getTransformMatrixTexture(mesh) {
        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {
          return mesh._transformMatrixTexture;
        }
        return this._transformMatrixTexture;
      }
      /**
       * Gets the current hosting scene
       * @returns a scene object
       */
      getScene() {
        return this._scene;
      }
      // Methods
      /**
       * Gets a string representing the current skeleton data
       * @param fullDetails defines a boolean indicating if we want a verbose version
       * @returns a string representing the current skeleton data
       */
      toString(fullDetails) {
        let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;
        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : "none"}`;
        if (fullDetails) {
          ret += ", Ranges: {";
          let first = true;
          for (const name13 in this._ranges) {
            if (first) {
              ret += ", ";
              first = false;
            }
            ret += name13;
          }
          ret += "}";
        }
        return ret;
      }
      /**
       * Get bone's index searching by name
       * @param name defines bone's name to search for
       * @returns the indice of the bone. Returns -1 if not found
       */
      getBoneIndexByName(name13) {
        for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {
          if (this.bones[boneIndex].name === name13) {
            return boneIndex;
          }
        }
        return -1;
      }
      /**
       * Create a new animation range
       * @param name defines the name of the range
       * @param from defines the start key
       * @param to defines the end key
       */
      createAnimationRange(name13, from, to) {
        if (!this._ranges[name13]) {
          this._ranges[name13] = new AnimationRange(name13, from, to);
          for (let i = 0, nBones = this.bones.length; i < nBones; i++) {
            if (this.bones[i].animations[0]) {
              this.bones[i].animations[0].createRange(name13, from, to);
            }
          }
        }
      }
      /**
       * Delete a specific animation range
       * @param name defines the name of the range
       * @param deleteFrames defines if frames must be removed as well
       */
      deleteAnimationRange(name13, deleteFrames = true) {
        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {
          if (this.bones[i].animations[0]) {
            this.bones[i].animations[0].deleteRange(name13, deleteFrames);
          }
        }
        this._ranges[name13] = null;
      }
      /**
       * Gets a specific animation range
       * @param name defines the name of the range to look for
       * @returns the requested animation range or null if not found
       */
      getAnimationRange(name13) {
        return this._ranges[name13] || null;
      }
      /**
       * Gets the list of all animation ranges defined on this skeleton
       * @returns an array
       */
      getAnimationRanges() {
        const animationRanges = [];
        let name13;
        for (name13 in this._ranges) {
          animationRanges.push(this._ranges[name13]);
        }
        return animationRanges;
      }
      /**
       * Copy animation range from a source skeleton.
       * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences
       * @param source defines the source skeleton
       * @param name defines the name of the range to copy
       * @param rescaleAsRequired defines if rescaling must be applied if required
       * @returns true if operation was successful
       */
      copyAnimationRange(source, name13, rescaleAsRequired = false) {
        if (this._ranges[name13] || !source.getAnimationRange(name13)) {
          return false;
        }
        let ret = true;
        const frameOffset = this._getHighestAnimationFrame() + 1;
        const boneDict = {};
        const sourceBones = source.bones;
        let nBones;
        let i;
        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {
          boneDict[sourceBones[i].name] = sourceBones[i];
        }
        if (this.bones.length !== sourceBones.length) {
          Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);
          ret = false;
        }
        const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;
        for (i = 0, nBones = this.bones.length; i < nBones; i++) {
          const boneName = this.bones[i].name;
          const sourceBone = boneDict[boneName];
          if (sourceBone) {
            ret = ret && this.bones[i].copyAnimationRange(sourceBone, name13, frameOffset, rescaleAsRequired, skelDimensionsRatio);
          } else {
            Logger.Warn("copyAnimationRange: not same rig, missing source bone " + boneName);
            ret = false;
          }
        }
        const range = source.getAnimationRange(name13);
        if (range) {
          this._ranges[name13] = new AnimationRange(name13, range.from + frameOffset, range.to + frameOffset);
        }
        return ret;
      }
      /**
       * Forces the skeleton to go to rest pose
       */
      returnToRest() {
        for (const bone of this.bones) {
          if (bone._index !== -1) {
            bone.returnToRest();
          }
        }
      }
      _getHighestAnimationFrame() {
        let ret = 0;
        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {
          if (this.bones[i].animations[0]) {
            const highest = this.bones[i].animations[0].getHighestFrame();
            if (ret < highest) {
              ret = highest;
            }
          }
        }
        return ret;
      }
      /**
       * Begin a specific animation range
       * @param name defines the name of the range to start
       * @param loop defines if looping must be turned on (false by default)
       * @param speedRatio defines the speed ratio to apply (1 by default)
       * @param onAnimationEnd defines a callback which will be called when animation will end
       * @returns a new animatable
       */
      beginAnimation(name13, loop, speedRatio, onAnimationEnd) {
        const range = this.getAnimationRange(name13);
        if (!range) {
          return null;
        }
        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);
      }
      /**
       * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.
       * @param skeleton defines the Skeleton containing the animation range to convert
       * @param referenceFrame defines the frame that keyframes in the range will be relative to
       * @param range defines the name of the AnimationRange belonging to the Skeleton to convert
       * @returns the original skeleton
       */
      static MakeAnimationAdditive(skeleton, referenceFrame = 0, range) {
        const rangeValue = skeleton.getAnimationRange(range);
        if (!rangeValue) {
          return null;
        }
        const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);
        let rangeAnimatable = null;
        for (let index = 0; index < sceneAnimatables.length; index++) {
          const sceneAnimatable = sceneAnimatables[index];
          if (sceneAnimatable.fromFrame === rangeValue?.from && sceneAnimatable.toFrame === rangeValue?.to) {
            rangeAnimatable = sceneAnimatable;
            break;
          }
        }
        const animatables = skeleton.getAnimatables();
        for (let index = 0; index < animatables.length; index++) {
          const animatable = animatables[index];
          const animations = animatable.animations;
          if (!animations) {
            continue;
          }
          for (let animIndex = 0; animIndex < animations.length; animIndex++) {
            Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);
          }
        }
        if (rangeAnimatable) {
          rangeAnimatable.isAdditive = true;
        }
        return skeleton;
      }
      /** @internal */
      _markAsDirty() {
        this._isDirty = true;
        this._absoluteTransformIsDirty = true;
      }
      /**
       * @internal
       */
      _registerMeshWithPoseMatrix(mesh) {
        this._meshesWithPoseMatrix.push(mesh);
      }
      /**
       * @internal
       */
      _unregisterMeshWithPoseMatrix(mesh) {
        const index = this._meshesWithPoseMatrix.indexOf(mesh);
        if (index > -1) {
          this._meshesWithPoseMatrix.splice(index, 1);
        }
      }
      _computeTransformMatrices(targetMatrix, initialSkinMatrix) {
        this.onBeforeComputeObservable.notifyObservers(this);
        for (let index = 0; index < this.bones.length; index++) {
          const bone = this.bones[index];
          bone._childUpdateId++;
          const parentBone = bone.getParent();
          if (parentBone) {
            bone.getLocalMatrix().multiplyToRef(parentBone.getFinalMatrix(), bone.getFinalMatrix());
          } else {
            if (initialSkinMatrix) {
              bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getFinalMatrix());
            } else {
              bone.getFinalMatrix().copyFrom(bone.getLocalMatrix());
            }
          }
          if (bone._index !== -1) {
            const mappedIndex = bone._index === null ? index : bone._index;
            bone.getAbsoluteInverseBindMatrix().multiplyToArray(bone.getFinalMatrix(), targetMatrix, mappedIndex * 16);
          }
        }
        this._identity.copyToArray(targetMatrix, this.bones.length * 16);
      }
      /**
       * Build all resources required to render a skeleton
       * @param dontCheckFrameId defines a boolean indicating if prepare should be run without checking first the current frame id (default: false)
       */
      prepare(dontCheckFrameId = false) {
        if (!dontCheckFrameId) {
          const currentRenderId = this.getScene().getRenderId();
          if (this._currentRenderId === currentRenderId) {
            return;
          }
          this._currentRenderId = currentRenderId;
        }
        if (this._numBonesWithLinkedTransformNode > 0) {
          for (const bone of this.bones) {
            if (bone._linkedTransformNode) {
              const node = bone._linkedTransformNode;
              bone.position = node.position;
              if (node.rotationQuaternion) {
                bone.rotationQuaternion = node.rotationQuaternion;
              } else {
                bone.rotation = node.rotation;
              }
              bone.scaling = node.scaling;
            }
          }
        }
        if (this.needInitialSkinMatrix) {
          for (const mesh of this._meshesWithPoseMatrix) {
            const poseMatrix = mesh.getPoseMatrix();
            let needsUpdate = this._isDirty;
            if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {
              mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));
              needsUpdate = true;
            }
            if (!needsUpdate) {
              continue;
            }
            if (this._synchronizedWithMesh !== mesh) {
              this._synchronizedWithMesh = mesh;
              for (const bone of this.bones) {
                if (!bone.getParent()) {
                  const matrix = bone.getBindMatrix();
                  matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);
                  bone._updateAbsoluteBindMatrices(TmpVectors.Matrix[1]);
                }
              }
              if (this.isUsingTextureForMatrices) {
                const textureWidth = (this.bones.length + 1) * 4;
                if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {
                  if (mesh._transformMatrixTexture) {
                    mesh._transformMatrixTexture.dispose();
                  }
                  mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);
                }
              }
            }
            this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);
            if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {
              mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);
            }
          }
        } else {
          if (!this._isDirty) {
            return;
          }
          if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {
            this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));
            if (this.isUsingTextureForMatrices) {
              if (this._transformMatrixTexture) {
                this._transformMatrixTexture.dispose();
              }
              this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);
            }
          }
          this._computeTransformMatrices(this._transformMatrices, null);
          if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {
            this._transformMatrixTexture.update(this._transformMatrices);
          }
        }
        this._isDirty = false;
      }
      /**
       * Gets the list of animatables currently running for this skeleton
       * @returns an array of animatables
       */
      getAnimatables() {
        if (!this._animatables || this._animatables.length !== this.bones.length) {
          this._animatables = [];
          for (let index = 0; index < this.bones.length; index++) {
            this._animatables.push(this.bones[index]);
          }
        }
        return this._animatables;
      }
      /**
       * Clone the current skeleton
       * @param name defines the name of the new skeleton
       * @param id defines the id of the new skeleton
       * @returns the new skeleton
       */
      clone(name13, id) {
        const result = new _Skeleton(name13, id || name13, this._scene);
        result.needInitialSkinMatrix = this.needInitialSkinMatrix;
        result.metadata = this.metadata;
        for (let index = 0; index < this.bones.length; index++) {
          const source = this.bones[index];
          let parentBone = null;
          const parent = source.getParent();
          if (parent) {
            const parentIndex = this.bones.indexOf(parent);
            parentBone = result.bones[parentIndex];
          }
          const bone = new Bone(source.name, result, parentBone, source.getBindMatrix().clone(), source.getRestMatrix().clone());
          bone._index = source._index;
          if (source._linkedTransformNode) {
            bone.linkTransformNode(source._linkedTransformNode);
          }
          DeepCopier.DeepCopy(source.animations, bone.animations);
        }
        if (this._ranges) {
          result._ranges = {};
          for (const rangeName in this._ranges) {
            const range = this._ranges[rangeName];
            if (range) {
              result._ranges[rangeName] = range.clone();
            }
          }
        }
        this._isDirty = true;
        result.prepare(true);
        return result;
      }
      /**
       * Enable animation blending for this skeleton
       * @param blendingSpeed defines the blending speed to apply
       * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending
       */
      enableBlending(blendingSpeed = 0.01) {
        for (const bone of this.bones) {
          for (const animation of bone.animations) {
            animation.enableBlending = true;
            animation.blendingSpeed = blendingSpeed;
          }
        }
      }
      /**
       * Releases all resources associated with the current skeleton
       */
      dispose() {
        this._meshesWithPoseMatrix.length = 0;
        this.metadata = null;
        this.getScene().stopAnimation(this);
        this.getScene().removeSkeleton(this);
        if (this._parentContainer) {
          const index = this._parentContainer.skeletons.indexOf(this);
          if (index > -1) {
            this._parentContainer.skeletons.splice(index, 1);
          }
          this._parentContainer = null;
        }
        if (this._transformMatrixTexture) {
          this._transformMatrixTexture.dispose();
          this._transformMatrixTexture = null;
        }
      }
      /**
       * Serialize the skeleton in a JSON object
       * @returns a JSON object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.id = this.id;
        if (this.dimensionsAtRest) {
          serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();
        }
        serializationObject.bones = [];
        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;
        if (this.metadata) {
          serializationObject.metadata = this.metadata;
        }
        for (let index = 0; index < this.bones.length; index++) {
          const bone = this.bones[index];
          const parent = bone.getParent();
          const serializedBone = {
            parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,
            index: bone.getIndex(),
            name: bone.name,
            id: bone.id,
            matrix: bone.getBindMatrix().asArray(),
            rest: bone.getRestMatrix().asArray(),
            linkedTransformNodeId: bone.getTransformNode()?.id
          };
          serializationObject.bones.push(serializedBone);
          if (bone.length) {
            serializedBone.length = bone.length;
          }
          if (bone.metadata) {
            serializedBone.metadata = bone.metadata;
          }
          if (bone.animations && bone.animations.length > 0) {
            serializedBone.animation = bone.animations[0].serialize();
          }
          serializationObject.ranges = [];
          for (const name13 in this._ranges) {
            const source = this._ranges[name13];
            if (!source) {
              continue;
            }
            const range = {};
            range.name = name13;
            range.from = source.from;
            range.to = source.to;
            serializationObject.ranges.push(range);
          }
        }
        return serializationObject;
      }
      /**
       * Creates a new skeleton from serialized data
       * @param parsedSkeleton defines the serialized data
       * @param scene defines the hosting scene
       * @returns a new skeleton
       */
      static Parse(parsedSkeleton, scene) {
        const skeleton = new _Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);
        if (parsedSkeleton.dimensionsAtRest) {
          skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);
        }
        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;
        if (parsedSkeleton.metadata) {
          skeleton.metadata = parsedSkeleton.metadata;
        }
        let index;
        for (index = 0; index < parsedSkeleton.bones.length; index++) {
          const parsedBone = parsedSkeleton.bones[index];
          const parsedBoneIndex = parsedSkeleton.bones[index].index;
          let parentBone = null;
          if (parsedBone.parentBoneIndex > -1) {
            parentBone = skeleton.bones[parsedBone.parentBoneIndex];
          }
          const rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;
          const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);
          if (parsedBone.id !== void 0 && parsedBone.id !== null) {
            bone.id = parsedBone.id;
          }
          if (parsedBone.length) {
            bone.length = parsedBone.length;
          }
          if (parsedBone.metadata) {
            bone.metadata = parsedBone.metadata;
          }
          if (parsedBone.animation) {
            bone.animations.push(Animation.Parse(parsedBone.animation));
          }
          if (parsedBone.linkedTransformNodeId !== void 0 && parsedBone.linkedTransformNodeId !== null) {
            skeleton._hasWaitingData = true;
            bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;
          }
        }
        if (parsedSkeleton.ranges) {
          for (index = 0; index < parsedSkeleton.ranges.length; index++) {
            const data = parsedSkeleton.ranges[index];
            skeleton.createAnimationRange(data.name, data.from, data.to);
          }
        }
        return skeleton;
      }
      /**
       * Compute all node absolute matrices
       * @param forceUpdate defines if computation must be done even if cache is up to date
       */
      computeAbsoluteMatrices(forceUpdate = false) {
        if (this._absoluteTransformIsDirty || forceUpdate) {
          this.bones[0].computeAbsoluteMatrices();
          this._absoluteTransformIsDirty = false;
        }
      }
      /**
       * Compute all node absolute matrices
       * @param forceUpdate defines if computation must be done even if cache is up to date
       * @deprecated Please use computeAbsoluteMatrices instead
       */
      computeAbsoluteTransforms(forceUpdate = false) {
        this.computeAbsoluteMatrices(forceUpdate);
      }
      /**
       * Gets the root pose matrix
       * @returns a matrix
       */
      getPoseMatrix() {
        let poseMatrix = null;
        if (this._meshesWithPoseMatrix.length > 0) {
          poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();
        }
        return poseMatrix;
      }
      /**
       * Sorts bones per internal index
       */
      sortBones() {
        const bones = [];
        const visited = new Array(this.bones.length);
        for (let index = 0; index < this.bones.length; index++) {
          this._sortBones(index, bones, visited);
        }
        this.bones = bones;
      }
      _sortBones(index, bones, visited) {
        if (visited[index]) {
          return;
        }
        visited[index] = true;
        const bone = this.bones[index];
        if (!bone) {
          return;
        }
        if (bone._index === void 0) {
          bone._index = index;
        }
        const parentBone = bone.getParent();
        if (parentBone) {
          this._sortBones(this.bones.indexOf(parentBone), bones, visited);
        }
        bones.push(bone);
      }
      /**
       * Set the current local matrix as the restPose for all bones in the skeleton.
       */
      setCurrentPoseAsRest() {
        for (const b of this.bones) {
          b.setCurrentPoseAsRest();
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Behaviors/Cameras/autoRotationBehavior.js
var AutoRotationBehavior;
var init_autoRotationBehavior = __esm({
  "node_modules/@babylonjs/core/Behaviors/Cameras/autoRotationBehavior.js"() {
    init_pointerEvents();
    init_precisionDate();
    init_math_constants();
    AutoRotationBehavior = class {
      constructor() {
        this._zoomStopsAnimation = false;
        this._idleRotationSpeed = 0.05;
        this._idleRotationWaitTime = 2e3;
        this._idleRotationSpinupTime = 2e3;
        this.targetAlpha = null;
        this._attachedCamera = null;
        this._isPointerDown = false;
        this._lastFrameTime = null;
        this._lastInteractionTime = -Infinity;
        this._cameraRotationSpeed = 0;
        this._lastFrameRadius = 0;
      }
      /**
       * Gets the name of the behavior.
       */
      get name() {
        return "AutoRotation";
      }
      /**
       * Sets the flag that indicates if user zooming should stop animation.
       */
      set zoomStopsAnimation(flag) {
        this._zoomStopsAnimation = flag;
      }
      /**
       * Gets the flag that indicates if user zooming should stop animation.
       */
      get zoomStopsAnimation() {
        return this._zoomStopsAnimation;
      }
      /**
       * Sets the default speed at which the camera rotates around the model.
       */
      set idleRotationSpeed(speed) {
        this._idleRotationSpeed = speed;
      }
      /**
       * Gets the default speed at which the camera rotates around the model.
       */
      get idleRotationSpeed() {
        return this._idleRotationSpeed;
      }
      /**
       * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.
       */
      set idleRotationWaitTime(time) {
        this._idleRotationWaitTime = time;
      }
      /**
       * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.
       */
      get idleRotationWaitTime() {
        return this._idleRotationWaitTime;
      }
      /**
       * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.
       */
      set idleRotationSpinupTime(time) {
        this._idleRotationSpinupTime = time;
      }
      /**
       * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.
       */
      get idleRotationSpinupTime() {
        return this._idleRotationSpinupTime;
      }
      /**
       * Gets a value indicating if the camera is currently rotating because of this behavior
       */
      get rotationInProgress() {
        return Math.abs(this._cameraRotationSpeed) > 0;
      }
      /**
       * Attached node of this behavior
       */
      get attachedNode() {
        return this._attachedCamera;
      }
      /**
       * Initializes the behavior.
       */
      init() {
      }
      /**
       * Attaches the behavior to its arc rotate camera.
       * @param camera Defines the camera to attach the behavior to
       */
      attach(camera) {
        this._attachedCamera = camera;
        const scene = this._attachedCamera.getScene();
        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {
          if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {
            this._isPointerDown = true;
            return;
          }
          if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {
            this._isPointerDown = false;
          }
        });
        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {
          if (this._reachTargetAlpha()) {
            return;
          }
          const now = PrecisionDate.Now;
          let dt = 0;
          if (this._lastFrameTime != null) {
            dt = now - this._lastFrameTime;
          }
          this._lastFrameTime = now;
          this._applyUserInteraction();
          const timeToRotation = now - this._lastInteractionTime - this._idleRotationWaitTime;
          const scale = Math.max(Math.min(timeToRotation / this._idleRotationSpinupTime, 1), 0);
          this._cameraRotationSpeed = this._idleRotationSpeed * scale;
          if (this._attachedCamera) {
            this._attachedCamera.alpha -= this._cameraRotationSpeed * (dt / 1e3);
          }
        });
      }
      /**
       * Detaches the behavior from its current arc rotate camera.
       */
      detach() {
        if (!this._attachedCamera) {
          return;
        }
        const scene = this._attachedCamera.getScene();
        if (this._onPrePointerObservableObserver) {
          scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);
        }
        this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
        this._attachedCamera = null;
        this._lastFrameTime = null;
      }
      /**
       * Force-reset the last interaction time
       * @param customTime an optional time that will be used instead of the current last interaction time. For example `Date.now()`
       */
      resetLastInteractionTime(customTime) {
        this._lastInteractionTime = customTime ?? PrecisionDate.Now;
      }
      /**
       * Returns true if camera alpha reaches the target alpha
       * @returns true if camera alpha reaches the target alpha
       */
      _reachTargetAlpha() {
        if (this._attachedCamera && this.targetAlpha) {
          return Math.abs(this._attachedCamera.alpha - this.targetAlpha) < Epsilon;
        }
        return false;
      }
      /**
       * Returns true if user is scrolling.
       * @returns true if user is scrolling.
       */
      _userIsZooming() {
        if (!this._attachedCamera) {
          return false;
        }
        return this._attachedCamera.inertialRadiusOffset !== 0;
      }
      _shouldAnimationStopForInteraction() {
        if (!this._attachedCamera) {
          return false;
        }
        let zoomHasHitLimit = false;
        if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {
          zoomHasHitLimit = true;
        }
        this._lastFrameRadius = this._attachedCamera.radius;
        return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();
      }
      /**
       *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.
       */
      _applyUserInteraction() {
        if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {
          this._lastInteractionTime = PrecisionDate.Now;
        }
      }
      // Tools
      _userIsMoving() {
        if (!this._attachedCamera) {
          return false;
        }
        return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;
      }
    };
  }
});

// node_modules/@babylonjs/core/Behaviors/Cameras/bouncingBehavior.js
var BouncingBehavior;
var init_bouncingBehavior = __esm({
  "node_modules/@babylonjs/core/Behaviors/Cameras/bouncingBehavior.js"() {
    init_easing();
    init_animation();
    BouncingBehavior = class _BouncingBehavior {
      constructor() {
        this.transitionDuration = 450;
        this.lowerRadiusTransitionRange = 2;
        this.upperRadiusTransitionRange = -2;
        this._autoTransitionRange = false;
        this._attachedCamera = null;
        this._radiusIsAnimating = false;
        this._radiusBounceTransition = null;
        this._animatables = new Array();
      }
      /**
       * Gets the name of the behavior.
       */
      get name() {
        return "Bouncing";
      }
      /**
       * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
       */
      get autoTransitionRange() {
        return this._autoTransitionRange;
      }
      /**
       * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
       * Transition ranges will be set to 5% of the bounding box diagonal in world space
       */
      set autoTransitionRange(value) {
        if (this._autoTransitionRange === value) {
          return;
        }
        this._autoTransitionRange = value;
        const camera = this._attachedCamera;
        if (!camera) {
          return;
        }
        if (value) {
          this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((transformNode) => {
            if (!transformNode) {
              return;
            }
            transformNode.computeWorldMatrix(true);
            if (transformNode.getBoundingInfo) {
              const diagonal = transformNode.getBoundingInfo().diagonalLength;
              this.lowerRadiusTransitionRange = diagonal * 0.05;
              this.upperRadiusTransitionRange = diagonal * 0.05;
            }
          });
        } else if (this._onMeshTargetChangedObserver) {
          camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
        }
      }
      /**
       * Attached node of this behavior
       */
      get attachedNode() {
        return this._attachedCamera;
      }
      /**
       * Initializes the behavior.
       */
      init() {
      }
      /**
       * Attaches the behavior to its arc rotate camera.
       * @param camera Defines the camera to attach the behavior to
       */
      attach(camera) {
        this._attachedCamera = camera;
        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {
          if (!this._attachedCamera) {
            return;
          }
          if (this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)) {
            this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange);
          }
          if (this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)) {
            this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange);
          }
        });
      }
      /**
       * Detaches the behavior from its current arc rotate camera.
       */
      detach() {
        if (!this._attachedCamera) {
          return;
        }
        if (this._onAfterCheckInputsObserver) {
          this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
        }
        if (this._onMeshTargetChangedObserver) {
          this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
        }
        this._attachedCamera = null;
      }
      /**
       * Checks if the camera radius is at the specified limit. Takes into account animation locks.
       * @param radiusLimit The limit to check against.
       * @returns Bool to indicate if at limit.
       */
      _isRadiusAtLimit(radiusLimit) {
        if (!this._attachedCamera) {
          return false;
        }
        if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {
          return true;
        }
        return false;
      }
      /**
       * Applies an animation to the radius of the camera, extending by the radiusDelta.
       * @param radiusDelta The delta by which to animate to. Can be negative.
       */
      _applyBoundRadiusAnimation(radiusDelta) {
        if (!this._attachedCamera) {
          return;
        }
        if (!this._radiusBounceTransition) {
          _BouncingBehavior.EasingFunction.setEasingMode(_BouncingBehavior.EasingMode);
          this._radiusBounceTransition = Animation.CreateAnimation("radius", Animation.ANIMATIONTYPE_FLOAT, 60, _BouncingBehavior.EasingFunction);
        }
        this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;
        this._attachedCamera.wheelPrecision = Infinity;
        this._attachedCamera.inertialRadiusOffset = 0;
        this.stopAllAnimations();
        this._radiusIsAnimating = true;
        const animatable = Animation.TransitionTo("radius", this._attachedCamera.radius + radiusDelta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusBounceTransition, this.transitionDuration, () => this._clearAnimationLocks());
        if (animatable) {
          this._animatables.push(animatable);
        }
      }
      /**
       * Removes all animation locks. Allows new animations to be added to any of the camera properties.
       */
      _clearAnimationLocks() {
        this._radiusIsAnimating = false;
        if (this._attachedCamera) {
          this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;
        }
      }
      /**
       * Stops and removes all animations that have been applied to the camera
       */
      stopAllAnimations() {
        if (this._attachedCamera) {
          this._attachedCamera.animations = [];
        }
        while (this._animatables.length) {
          this._animatables[0].onAnimationEnd = null;
          this._animatables[0].stop();
          this._animatables.shift();
        }
      }
    };
    BouncingBehavior.EasingFunction = new BackEase(0.3);
    BouncingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEOUT;
  }
});

// node_modules/@babylonjs/core/Behaviors/Cameras/framingBehavior.js
var FramingBehavior;
var init_framingBehavior = __esm({
  "node_modules/@babylonjs/core/Behaviors/Cameras/framingBehavior.js"() {
    init_easing();
    init_observable();
    init_pointerEvents();
    init_precisionDate();
    init_math_vector();
    init_animation();
    FramingBehavior = class _FramingBehavior {
      constructor() {
        this.onTargetFramingAnimationEndObservable = new Observable();
        this._mode = _FramingBehavior.FitFrustumSidesMode;
        this._radiusScale = 1;
        this._positionScale = 0.5;
        this._defaultElevation = 0.3;
        this._elevationReturnTime = 1500;
        this._elevationReturnWaitTime = 1e3;
        this._zoomStopsAnimation = false;
        this._framingTime = 1500;
        this.autoCorrectCameraLimitsAndSensibility = true;
        this._attachedCamera = null;
        this._isPointerDown = false;
        this._lastInteractionTime = -Infinity;
        this._animatables = new Array();
        this._betaIsAnimating = false;
      }
      /**
       * Gets the name of the behavior.
       */
      get name() {
        return "Framing";
      }
      /**
       * Sets the current mode used by the behavior
       */
      set mode(mode) {
        this._mode = mode;
      }
      /**
       * Gets current mode used by the behavior.
       */
      get mode() {
        return this._mode;
      }
      /**
       * Sets the scale applied to the radius (1 by default)
       */
      set radiusScale(radius) {
        this._radiusScale = radius;
      }
      /**
       * Gets the scale applied to the radius
       */
      get radiusScale() {
        return this._radiusScale;
      }
      /**
       * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
       */
      set positionScale(scale) {
        this._positionScale = scale;
      }
      /**
       * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
       */
      get positionScale() {
        return this._positionScale;
      }
      /**
       * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle
       * behaviour is triggered, in radians.
       */
      set defaultElevation(elevation) {
        this._defaultElevation = elevation;
      }
      /**
       * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle
       * behaviour is triggered, in radians.
       */
      get defaultElevation() {
        return this._defaultElevation;
      }
      /**
       * Sets the time (in milliseconds) taken to return to the default beta position.
       * Negative value indicates camera should not return to default.
       */
      set elevationReturnTime(speed) {
        this._elevationReturnTime = speed;
      }
      /**
       * Gets the time (in milliseconds) taken to return to the default beta position.
       * Negative value indicates camera should not return to default.
       */
      get elevationReturnTime() {
        return this._elevationReturnTime;
      }
      /**
       * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.
       */
      set elevationReturnWaitTime(time) {
        this._elevationReturnWaitTime = time;
      }
      /**
       * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.
       */
      get elevationReturnWaitTime() {
        return this._elevationReturnWaitTime;
      }
      /**
       * Sets the flag that indicates if user zooming should stop animation.
       */
      set zoomStopsAnimation(flag) {
        this._zoomStopsAnimation = flag;
      }
      /**
       * Gets the flag that indicates if user zooming should stop animation.
       */
      get zoomStopsAnimation() {
        return this._zoomStopsAnimation;
      }
      /**
       * Sets the transition time when framing the mesh, in milliseconds
       */
      set framingTime(time) {
        this._framingTime = time;
      }
      /**
       * Gets the transition time when framing the mesh, in milliseconds
       */
      get framingTime() {
        return this._framingTime;
      }
      /**
       * Attached node of this behavior
       */
      get attachedNode() {
        return this._attachedCamera;
      }
      /**
       * Initializes the behavior.
       */
      init() {
      }
      /**
       * Attaches the behavior to its arc rotate camera.
       * @param camera Defines the camera to attach the behavior to
       */
      attach(camera) {
        this._attachedCamera = camera;
        const scene = this._attachedCamera.getScene();
        _FramingBehavior.EasingFunction.setEasingMode(_FramingBehavior.EasingMode);
        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {
          if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {
            this._isPointerDown = true;
            return;
          }
          if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {
            this._isPointerDown = false;
          }
        });
        this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((transformNode) => {
          if (transformNode && transformNode.getBoundingInfo) {
            this.zoomOnMesh(transformNode, void 0, () => {
              this.onTargetFramingAnimationEndObservable.notifyObservers();
            });
          }
        });
        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {
          this._applyUserInteraction();
          this._maintainCameraAboveGround();
        });
      }
      /**
       * Detaches the behavior from its current arc rotate camera.
       */
      detach() {
        if (!this._attachedCamera) {
          return;
        }
        const scene = this._attachedCamera.getScene();
        if (this._onPrePointerObservableObserver) {
          scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);
        }
        if (this._onAfterCheckInputsObserver) {
          this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);
        }
        if (this._onMeshTargetChangedObserver) {
          this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);
        }
        this._attachedCamera = null;
      }
      /**
       * Targets the given mesh and updates zoom level accordingly.
       * @param mesh  The mesh to target.
       * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
       * @param onAnimationEnd Callback triggered at the end of the framing animation
       */
      zoomOnMesh(mesh, focusOnOriginXZ = false, onAnimationEnd = null) {
        mesh.computeWorldMatrix(true);
        const boundingBox = mesh.getBoundingInfo().boundingBox;
        this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);
      }
      /**
       * Targets the given mesh with its children and updates zoom level accordingly.
       * @param mesh The mesh to target.
       * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
       * @param onAnimationEnd Callback triggered at the end of the framing animation
       */
      zoomOnMeshHierarchy(mesh, focusOnOriginXZ = false, onAnimationEnd = null) {
        mesh.computeWorldMatrix(true);
        const boundingBox = mesh.getHierarchyBoundingVectors(true);
        this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);
      }
      /**
       * Targets the given meshes with their children and updates zoom level accordingly.
       * @param meshes  The mesh to target.
       * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
       * @param onAnimationEnd Callback triggered at the end of the framing animation
       */
      zoomOnMeshesHierarchy(meshes, focusOnOriginXZ = false, onAnimationEnd = null) {
        const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        for (let i = 0; i < meshes.length; i++) {
          const boundingInfo = meshes[i].getHierarchyBoundingVectors(true);
          Vector3.CheckExtends(boundingInfo.min, min, max);
          Vector3.CheckExtends(boundingInfo.max, min, max);
        }
        this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);
      }
      /**
       * Targets the bounding box info defined by its extends and updates zoom level accordingly.
       * @param minimumWorld Determines the smaller position of the bounding box extend
       * @param maximumWorld Determines the bigger position of the bounding box extend
       * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh
       * @param onAnimationEnd Callback triggered at the end of the framing animation
       * @returns true if the zoom was done
       */
      zoomOnBoundingInfo(minimumWorld, maximumWorld, focusOnOriginXZ = false, onAnimationEnd = null) {
        let zoomTarget;
        if (!this._attachedCamera) {
          return false;
        }
        const bottom = minimumWorld.y;
        const top = maximumWorld.y;
        const zoomTargetY = bottom + (top - bottom) * this._positionScale;
        const radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);
        if (!isFinite(zoomTargetY)) {
          return false;
        }
        if (focusOnOriginXZ) {
          zoomTarget = new Vector3(0, zoomTargetY, 0);
        } else {
          const centerWorld = minimumWorld.add(radiusWorld);
          zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);
        }
        if (!this._vectorTransition) {
          this._vectorTransition = Animation.CreateAnimation("target", Animation.ANIMATIONTYPE_VECTOR3, 60, _FramingBehavior.EasingFunction);
        }
        this._betaIsAnimating = true;
        let animatable = Animation.TransitionTo("target", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);
        if (animatable) {
          this._animatables.push(animatable);
        }
        let radius = 0;
        if (this._mode === _FramingBehavior.FitFrustumSidesMode) {
          const position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);
          if (this.autoCorrectCameraLimitsAndSensibility) {
            this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;
          }
          radius = position;
        } else if (this._mode === _FramingBehavior.IgnoreBoundsSizeMode) {
          radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);
          if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {
            this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;
          }
        }
        if (this.autoCorrectCameraLimitsAndSensibility) {
          const extend = maximumWorld.subtract(minimumWorld).length();
          this._attachedCamera.panningSensibility = 5e3 / extend;
          this._attachedCamera.wheelPrecision = 100 / radius;
        }
        if (!this._radiusTransition) {
          this._radiusTransition = Animation.CreateAnimation("radius", Animation.ANIMATIONTYPE_FLOAT, 60, _FramingBehavior.EasingFunction);
        }
        animatable = Animation.TransitionTo("radius", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, () => {
          this.stopAllAnimations();
          if (onAnimationEnd) {
            onAnimationEnd();
          }
          if (this._attachedCamera && this._attachedCamera.useInputToRestoreState) {
            this._attachedCamera.storeState();
          }
        });
        if (animatable) {
          this._animatables.push(animatable);
        }
        return true;
      }
      /**
       * Calculates the lowest radius for the camera based on the bounding box of the mesh.
       * @param minimumWorld
       * @param maximumWorld
       * @returns The minimum distance from the primary mesh's center point at which the camera must be kept in order
       *		 to fully enclose the mesh in the viewing frustum.
       */
      _calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld) {
        const camera = this._attachedCamera;
        if (!camera) {
          return 0;
        }
        let distance = camera._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld, this._radiusScale);
        if (camera.lowerRadiusLimit && this._mode === _FramingBehavior.IgnoreBoundsSizeMode) {
          distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;
        }
        if (camera.upperRadiusLimit) {
          distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;
        }
        return distance;
      }
      /**
       * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera
       * is automatically returned to its default position (expected to be above ground plane).
       */
      _maintainCameraAboveGround() {
        if (this._elevationReturnTime < 0) {
          return;
        }
        const timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;
        const defaultBeta = Math.PI * 0.5 - this._defaultElevation;
        const limitBeta = Math.PI * 0.5;
        if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {
          this._betaIsAnimating = true;
          this.stopAllAnimations();
          if (!this._betaTransition) {
            this._betaTransition = Animation.CreateAnimation("beta", Animation.ANIMATIONTYPE_FLOAT, 60, _FramingBehavior.EasingFunction);
          }
          const animatable = Animation.TransitionTo("beta", defaultBeta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._betaTransition, this._elevationReturnTime, () => {
            this._clearAnimationLocks();
            this.stopAllAnimations();
          });
          if (animatable) {
            this._animatables.push(animatable);
          }
        }
      }
      /**
       * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.
       */
      _clearAnimationLocks() {
        this._betaIsAnimating = false;
      }
      /**
       *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.
       */
      _applyUserInteraction() {
        if (this.isUserIsMoving) {
          this._lastInteractionTime = PrecisionDate.Now;
          this.stopAllAnimations();
          this._clearAnimationLocks();
        }
      }
      /**
       * Stops and removes all animations that have been applied to the camera
       */
      stopAllAnimations() {
        if (this._attachedCamera) {
          this._attachedCamera.animations = [];
        }
        while (this._animatables.length) {
          if (this._animatables[0]) {
            this._animatables[0].onAnimationEnd = null;
            this._animatables[0].stop();
          }
          this._animatables.shift();
        }
      }
      /**
       * Gets a value indicating if the user is moving the camera
       */
      get isUserIsMoving() {
        if (!this._attachedCamera) {
          return false;
        }
        return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;
      }
    };
    FramingBehavior.EasingFunction = new ExponentialEase();
    FramingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEINOUT;
    FramingBehavior.IgnoreBoundsSizeMode = 0;
    FramingBehavior.FitFrustumSidesMode = 1;
  }
});

// node_modules/@babylonjs/core/Behaviors/Cameras/interpolatingBehavior.js
function IsQuaternionLike(v) {
  return v != null && typeof v.x === "number" && typeof v.y === "number" && typeof v.z === "number" && typeof v.w === "number";
}
function IsMatrixLike(v) {
  return v != null && (Array.isArray(v.m) || typeof v.m === "object");
}
function IsVector3Like(v) {
  return v != null && typeof v.x === "number" && typeof v.y === "number" && typeof v.z === "number";
}
function IsVector2Like(v) {
  return v != null && typeof v.x === "number" && typeof v.y === "number";
}
function IsColor3Like(v) {
  return v != null && typeof v.r === "number" && typeof v.g === "number" && typeof v.b === "number";
}
function IsColor4Like(v) {
  return v != null && typeof v.r === "number" && typeof v.g === "number" && typeof v.b === "number" && typeof v.a === "number";
}
function IsSizeLike(v) {
  return v != null && typeof v.width === "number" && typeof v.height === "number";
}
var InterpolatingBehavior, GetAnimationType;
var init_interpolatingBehavior = __esm({
  "node_modules/@babylonjs/core/Behaviors/Cameras/interpolatingBehavior.js"() {
    init_easing();
    init_animation();
    InterpolatingBehavior = class {
      /**
       * Gets the name of the behavior.
       */
      get name() {
        return "Interpolating";
      }
      /**
       * Attached node of this behavior
       */
      get attachedNode() {
        return this._attachedCamera;
      }
      /**
       * Initializes the behavior
       */
      constructor() {
        this.easingFunction = new CubicEase();
        this.easingMode = EasingFunction.EASINGMODE_EASEINOUT;
        this.transitionDuration = 450;
        this._attachedCamera = null;
        this._animatables = /* @__PURE__ */ new Map();
        this.easingFunction.setEasingMode(this.easingMode);
      }
      /**
       * Initializes the behavior
       */
      init() {
      }
      /**
       * Attaches the behavior to a camera
       * @param camera The camera to attach to
       */
      attach(camera) {
        this._attachedCamera = camera;
      }
      /**
       * Detaches the behavior from the camera
       */
      detach() {
        if (!this._attachedCamera) {
          return;
        }
        this.stopAllAnimations();
        this._attachedCamera = null;
      }
      get isInterpolating() {
        return this._animatables.size > 0;
      }
      /**
       * Stops and removes all animations
       */
      stopAllAnimations() {
        if (this._attachedCamera) {
          this._animatables.forEach((animatable) => animatable.stop());
        }
        this._animatables.clear();
        this._promiseResolve?.();
        this._promiseResolve = void 0;
      }
      updateProperties(properties) {
        properties.forEach((value, key) => {
          if (value !== void 0) {
            const animatable = this._animatables.get(String(key));
            animatable && (animatable.target = value);
          }
        });
      }
      async animatePropertiesAsync(properties, transitionDuration = this.transitionDuration, easingFn = this.easingFunction, updateAnimation) {
        const promise = new Promise((resolve) => {
          this.stopAllAnimations();
          this._promiseResolve = resolve;
          if (!this._attachedCamera) {
            this._promiseResolve = void 0;
            return resolve();
          }
          const camera = this._attachedCamera;
          const scene = camera.getScene();
          const checkClear = (propertyName) => {
            for (let i = camera.animations.length - 1; i >= 0; --i) {
              if (camera.animations[i].name === propertyName + "Animation") {
                camera.animations.splice(i, 1);
              }
            }
            this._animatables.delete(propertyName);
            if (this._animatables.size === 0) {
              this._promiseResolve = void 0;
              resolve();
            }
          };
          properties.forEach((value, key) => {
            if (value !== void 0 && camera[key] !== value) {
              const propertyName = String(key);
              const animation = Animation.CreateAnimation(propertyName, GetAnimationType(value), 60, easingFn);
              updateAnimation?.(propertyName, animation);
              const animatable = Animation.TransitionTo(propertyName, value, camera, scene, 60, animation, transitionDuration, () => checkClear(propertyName), false);
              if (animatable) {
                this._animatables.set(propertyName, animatable);
              }
            }
          });
        });
        return await promise;
      }
    };
    GetAnimationType = (value) => {
      if (IsQuaternionLike(value)) {
        return Animation.ANIMATIONTYPE_QUATERNION;
      }
      if (IsMatrixLike(value)) {
        return Animation.ANIMATIONTYPE_MATRIX;
      }
      if (IsVector3Like(value)) {
        return Animation.ANIMATIONTYPE_VECTOR3;
      }
      if (IsVector2Like(value)) {
        return Animation.ANIMATIONTYPE_VECTOR2;
      }
      if (IsColor3Like(value)) {
        return Animation.ANIMATIONTYPE_COLOR3;
      }
      if (IsColor4Like(value)) {
        return Animation.ANIMATIONTYPE_COLOR4;
      }
      if (IsSizeLike(value)) {
        return Animation.ANIMATIONTYPE_SIZE;
      }
      return Animation.ANIMATIONTYPE_FLOAT;
    };
  }
});

// node_modules/@babylonjs/core/Culling/ray.core.js
function CreatePickingRay(scene, x, y, world, camera, cameraViewSpace = false) {
  const result = Ray.Zero();
  CreatePickingRayToRef(scene, x, y, world, result, camera, cameraViewSpace);
  return result;
}
function CreatePickingRayToRef(scene, x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {
  const engine = scene.getEngine();
  if (!camera && !(camera = scene.activeCamera)) {
    return scene;
  }
  const cameraViewport = camera.viewport;
  const renderHeight = engine.getRenderHeight();
  const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);
  const levelInv = 1 / engine.getHardwareScalingLevel();
  x = x * levelInv - vx;
  y = y * levelInv - (renderHeight - vy - height);
  result.update(x, y, width, height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix(), enableDistantPicking);
  return scene;
}
function CreatePickingRayInCameraSpace(scene, x, y, camera) {
  const result = Ray.Zero();
  CreatePickingRayInCameraSpaceToRef(scene, x, y, result, camera);
  return result;
}
function CreatePickingRayInCameraSpaceToRef(scene, x, y, result, camera) {
  if (!PickingInfo) {
    return scene;
  }
  const engine = scene.getEngine();
  if (!camera && !(camera = scene.activeCamera)) {
    throw new Error("Active camera not set");
  }
  const cameraViewport = camera.viewport;
  const renderHeight = engine.getRenderHeight();
  const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);
  const identity = Matrix.Identity();
  const levelInv = 1 / engine.getHardwareScalingLevel();
  x = x * levelInv - vx;
  y = y * levelInv - (renderHeight - vy - height);
  result.update(x, y, width, height, identity, identity, camera.getProjectionMatrix());
  return scene;
}
function InternalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate, skipBoundingInfo) {
  const ray = rayFunction(world, mesh.enableDistantPicking);
  const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);
  if (!result || !result.hit) {
    return null;
  }
  if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {
    return null;
  }
  return result;
}
function InternalPick(scene, rayFunction, predicate, fastCheck, onlyBoundingInfo, trianglePredicate) {
  let pickingInfo = null;
  const computeWorldMatrixForCamera = !!(scene.activeCameras && scene.activeCameras.length > 1 && scene.cameraToUseForPointers !== scene.activeCamera);
  const currentCamera = scene.cameraToUseForPointers || scene.activeCamera;
  const picker = PickingCustomization.internalPickerForMesh || InternalPickForMesh;
  for (let meshIndex = 0; meshIndex < scene.meshes.length; meshIndex++) {
    const mesh = scene.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh, -1)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();
    const world = mesh.computeWorldMatrix(forceCompute, currentCamera);
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      const result = picker(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        if (onlyBoundingInfo) {
          return result;
        }
        const tmpMatrix = TmpVectors.Matrix[1];
        const thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (let index = 0; index < thinMatrices.length; index++) {
          if (predicate && !predicate(mesh, index)) {
            continue;
          }
          const thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix);
          const result2 = picker(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);
          if (result2) {
            pickingInfo = result2;
            pickingInfo.thinInstanceIndex = index;
            if (fastCheck) {
              return pickingInfo;
            }
          }
        }
      }
    } else {
      const result = picker(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);
      if (result) {
        pickingInfo = result;
        if (fastCheck) {
          return pickingInfo;
        }
      }
    }
  }
  return pickingInfo || new PickingInfo();
}
function InternalMultiPick(scene, rayFunction, predicate, trianglePredicate) {
  if (!PickingInfo) {
    return null;
  }
  const pickingInfos = [];
  const computeWorldMatrixForCamera = !!(scene.activeCameras && scene.activeCameras.length > 1 && scene.cameraToUseForPointers !== scene.activeCamera);
  const currentCamera = scene.cameraToUseForPointers || scene.activeCamera;
  const picker = PickingCustomization.internalPickerForMesh || InternalPickForMesh;
  for (let meshIndex = 0; meshIndex < scene.meshes.length; meshIndex++) {
    const mesh = scene.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh, -1)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();
    const world = mesh.computeWorldMatrix(forceCompute, currentCamera);
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      const result = picker(null, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        const tmpMatrix = TmpVectors.Matrix[1];
        const thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (let index = 0; index < thinMatrices.length; index++) {
          if (predicate && !predicate(mesh, index)) {
            continue;
          }
          const thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix);
          const result2 = picker(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);
          if (result2) {
            result2.thinInstanceIndex = index;
            pickingInfos.push(result2);
          }
        }
      }
    } else {
      const result = picker(null, rayFunction, mesh, world, false, false, trianglePredicate);
      if (result) {
        pickingInfos.push(result);
      }
    }
  }
  return pickingInfos;
}
function PickWithBoundingInfo(scene, x, y, predicate, fastCheck, camera) {
  if (!PickingInfo) {
    return null;
  }
  const result = InternalPick(scene, (world) => {
    if (!scene._tempPickingRay) {
      scene._tempPickingRay = Ray.Zero();
    }
    CreatePickingRayToRef(scene, x, y, world, scene._tempPickingRay, camera || null);
    return scene._tempPickingRay;
  }, predicate, fastCheck, true);
  if (result) {
    result.ray = CreatePickingRay(scene, x, y, Matrix.Identity(), camera || null);
  }
  return result;
}
function Pick(scene, x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking = false) {
  const result = InternalPick(scene, (world, enableDistantPicking) => {
    if (!scene._tempPickingRay) {
      scene._tempPickingRay = Ray.Zero();
    }
    CreatePickingRayToRef(scene, x, y, world, scene._tempPickingRay, camera || null, false, enableDistantPicking);
    return scene._tempPickingRay;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = CreatePickingRay(scene, x, y, Matrix.Identity(), camera || null);
  }
  return result;
}
function PickWithRay(scene, ray, predicate, fastCheck, trianglePredicate) {
  const result = InternalPick(scene, (world) => {
    if (!scene._pickWithRayInverseMatrix) {
      scene._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(scene._pickWithRayInverseMatrix);
    if (!scene._cachedRayForTransform) {
      scene._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, scene._pickWithRayInverseMatrix, scene._cachedRayForTransform);
    return scene._cachedRayForTransform;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = ray;
  }
  return result;
}
function MultiPick(scene, x, y, predicate, camera, trianglePredicate) {
  return InternalMultiPick(scene, (world) => CreatePickingRay(scene, x, y, world, camera || null), predicate, trianglePredicate);
}
function MultiPickWithRay(scene, ray, predicate, trianglePredicate) {
  return InternalMultiPick(scene, (world) => {
    if (!scene._pickWithRayInverseMatrix) {
      scene._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(scene._pickWithRayInverseMatrix);
    if (!scene._cachedRayForTransform) {
      scene._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, scene._pickWithRayInverseMatrix, scene._cachedRayForTransform);
    return scene._cachedRayForTransform;
  }, predicate, trianglePredicate);
}
function GetForwardRay(camera, length = 100, transform, origin) {
  return GetForwardRayToRef(camera, new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);
}
function GetForwardRayToRef(camera, refRay, length = 100, transform, origin) {
  if (!transform) {
    transform = camera.getWorldMatrix();
  }
  refRay.length = length;
  if (origin) {
    refRay.origin.copyFrom(origin);
  } else {
    refRay.origin.copyFrom(camera.position);
  }
  const forward = TmpVectors.Vector3[2];
  forward.set(0, 0, camera._scene.useRightHandedSystem ? -1 : 1);
  const worldForward = TmpVectors.Vector3[3];
  Vector3.TransformNormalToRef(forward, transform, worldForward);
  Vector3.NormalizeToRef(worldForward, refRay.direction);
  return refRay;
}
function AddRayExtensions(sceneClass, cameraClass) {
  if (cameraClass) {
    cameraClass.prototype.getForwardRay = function(length = 100, transform, origin) {
      return GetForwardRayToRef(this, new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);
    };
    cameraClass.prototype.getForwardRayToRef = function(refRay, length = 100, transform, origin) {
      return GetForwardRayToRef(this, refRay, length, transform, origin);
    };
  }
  if (!sceneClass) {
    return;
  }
  _ImportHelper._IsPickingAvailable = true;
  sceneClass.prototype.createPickingRay = function(x, y, world, camera, cameraViewSpace = false) {
    return CreatePickingRay(this, x, y, world, camera, cameraViewSpace);
  };
}
var PickingCustomization, Ray;
var init_ray_core = __esm({
  "node_modules/@babylonjs/core/Culling/ray.core.js"() {
    init_math_constants();
    init_math_vector();
    init_arrayTools();
    init_intersectionInfo();
    init_pickingInfo();
    init_engineStore();
    init_import_helper();
    PickingCustomization = {
      internalPickerForMesh: void 0
    };
    Ray = class _Ray {
      /**
       * Creates a new ray
       * @param origin origin point
       * @param direction direction
       * @param length length of the ray
       * @param epsilon The epsilon value to use when calculating the ray/triangle intersection (default: Epsilon from math constants)
       */
      constructor(origin, direction, length = Number.MAX_VALUE, epsilon = Epsilon) {
        this.origin = origin;
        this.direction = direction;
        this.length = length;
        this.epsilon = epsilon;
      }
      // Methods
      /**
       * Clone the current ray
       * @returns a new ray
       */
      clone() {
        return new _Ray(this.origin.clone(), this.direction.clone(), this.length);
      }
      /**
       * Checks if the ray intersects a box
       * This does not account for the ray length by design to improve perfs.
       * @param minimum bound of the box
       * @param maximum bound of the box
       * @param intersectionTreshold extra extend to be added to the box in all direction
       * @returns if the box was hit
       */
      intersectsBoxMinMax(minimum, maximum, intersectionTreshold = 0) {
        const newMinimum = _Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);
        const newMaximum = _Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);
        let d = 0;
        let maxValue = Number.MAX_VALUE;
        let inv;
        let min;
        let max;
        let temp;
        if (Math.abs(this.direction.x) < 1e-7) {
          if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {
            return false;
          }
        } else {
          inv = 1 / this.direction.x;
          min = (newMinimum.x - this.origin.x) * inv;
          max = (newMaximum.x - this.origin.x) * inv;
          if (max === -Infinity) {
            max = Infinity;
          }
          if (min > max) {
            temp = min;
            min = max;
            max = temp;
          }
          d = Math.max(min, d);
          maxValue = Math.min(max, maxValue);
          if (d > maxValue) {
            return false;
          }
        }
        if (Math.abs(this.direction.y) < 1e-7) {
          if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {
            return false;
          }
        } else {
          inv = 1 / this.direction.y;
          min = (newMinimum.y - this.origin.y) * inv;
          max = (newMaximum.y - this.origin.y) * inv;
          if (max === -Infinity) {
            max = Infinity;
          }
          if (min > max) {
            temp = min;
            min = max;
            max = temp;
          }
          d = Math.max(min, d);
          maxValue = Math.min(max, maxValue);
          if (d > maxValue) {
            return false;
          }
        }
        if (Math.abs(this.direction.z) < 1e-7) {
          if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {
            return false;
          }
        } else {
          inv = 1 / this.direction.z;
          min = (newMinimum.z - this.origin.z) * inv;
          max = (newMaximum.z - this.origin.z) * inv;
          if (max === -Infinity) {
            max = Infinity;
          }
          if (min > max) {
            temp = min;
            min = max;
            max = temp;
          }
          d = Math.max(min, d);
          maxValue = Math.min(max, maxValue);
          if (d > maxValue) {
            return false;
          }
        }
        return true;
      }
      /**
       * Checks if the ray intersects a box
       * This does not account for the ray length by design to improve perfs.
       * @param box the bounding box to check
       * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction
       * @returns if the box was hit
       */
      intersectsBox(box, intersectionTreshold = 0) {
        return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);
      }
      /**
       * If the ray hits a sphere
       * @param sphere the bounding sphere to check
       * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction
       * @returns true if it hits the sphere
       */
      intersectsSphere(sphere, intersectionTreshold = 0) {
        const x = sphere.center.x - this.origin.x;
        const y = sphere.center.y - this.origin.y;
        const z = sphere.center.z - this.origin.z;
        const pyth = x * x + y * y + z * z;
        const radius = sphere.radius + intersectionTreshold;
        const rr = radius * radius;
        if (pyth <= rr) {
          return true;
        }
        const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;
        if (dot < 0) {
          return false;
        }
        const temp = pyth - dot * dot;
        return temp <= rr;
      }
      /**
       * If the ray hits a triange
       * @param vertex0 triangle vertex
       * @param vertex1 triangle vertex
       * @param vertex2 triangle vertex
       * @returns intersection information if hit
       */
      intersectsTriangle(vertex0, vertex1, vertex2) {
        const edge1 = _Ray._TmpVector3[0];
        const edge2 = _Ray._TmpVector3[1];
        const pvec = _Ray._TmpVector3[2];
        const tvec = _Ray._TmpVector3[3];
        const qvec = _Ray._TmpVector3[4];
        vertex1.subtractToRef(vertex0, edge1);
        vertex2.subtractToRef(vertex0, edge2);
        Vector3.CrossToRef(this.direction, edge2, pvec);
        const det = Vector3.Dot(edge1, pvec);
        if (det === 0) {
          return null;
        }
        const invdet = 1 / det;
        this.origin.subtractToRef(vertex0, tvec);
        const bv = Vector3.Dot(tvec, pvec) * invdet;
        if (bv < -this.epsilon || bv > 1 + this.epsilon) {
          return null;
        }
        Vector3.CrossToRef(tvec, edge1, qvec);
        const bw = Vector3.Dot(this.direction, qvec) * invdet;
        if (bw < -this.epsilon || bv + bw > 1 + this.epsilon) {
          return null;
        }
        const distance = Vector3.Dot(edge2, qvec) * invdet;
        if (distance > this.length || distance < 0) {
          return null;
        }
        return new IntersectionInfo(1 - bv - bw, bv, distance);
      }
      /**
       * Checks if ray intersects a plane
       * @param plane the plane to check
       * @returns the distance away it was hit
       */
      intersectsPlane(plane) {
        let distance;
        const result1 = Vector3.Dot(plane.normal, this.direction);
        if (Math.abs(result1) < 999999997475243e-21) {
          return null;
        } else {
          const result2 = Vector3.Dot(plane.normal, this.origin);
          distance = (-plane.d - result2) / result1;
          if (distance < 0) {
            if (distance < -999999997475243e-21) {
              return null;
            } else {
              return 0;
            }
          }
          return distance;
        }
      }
      /**
       * Calculate the intercept of a ray on a given axis
       * @param axis to check 'x' | 'y' | 'z'
       * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)
       * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.
       */
      intersectsAxis(axis, offset = 0) {
        switch (axis) {
          case "y": {
            const t = (this.origin.y - offset) / this.direction.y;
            if (t > 0) {
              return null;
            }
            return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);
          }
          case "x": {
            const t = (this.origin.x - offset) / this.direction.x;
            if (t > 0) {
              return null;
            }
            return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);
          }
          case "z": {
            const t = (this.origin.z - offset) / this.direction.z;
            if (t > 0) {
              return null;
            }
            return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);
          }
          default:
            return null;
        }
      }
      /**
       * Checks if ray intersects a mesh. The ray is defined in WORLD space. A mesh triangle can be picked both from its front and back sides,
       * irrespective of orientation.
       * @param mesh the mesh to check
       * @param fastCheck defines if the first intersection will be used (and not the closest)
       * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
       * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)
       * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point
       * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check
       * @returns picking info of the intersection
       */
      intersectsMesh(mesh, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {
        const tm = TmpVectors.Matrix[0];
        mesh.getWorldMatrix().invertToRef(tm);
        if (this._tmpRay) {
          _Ray.TransformToRef(this, tm, this._tmpRay);
        } else {
          this._tmpRay = _Ray.Transform(this, tm);
        }
        return mesh.intersects(this._tmpRay, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo);
      }
      /**
       * Checks if ray intersects a mesh
       * @param meshes the meshes to check
       * @param fastCheck defines if the first intersection will be used (and not the closest)
       * @param results array to store result in
       * @returns Array of picking infos
       */
      intersectsMeshes(meshes, fastCheck, results) {
        if (results) {
          results.length = 0;
        } else {
          results = [];
        }
        for (let i = 0; i < meshes.length; i++) {
          const pickInfo = this.intersectsMesh(meshes[i], fastCheck);
          if (pickInfo.hit) {
            results.push(pickInfo);
          }
        }
        results.sort(this._comparePickingInfo);
        return results;
      }
      _comparePickingInfo(pickingInfoA, pickingInfoB) {
        if (pickingInfoA.distance < pickingInfoB.distance) {
          return -1;
        } else if (pickingInfoA.distance > pickingInfoB.distance) {
          return 1;
        } else {
          return 0;
        }
      }
      /**
       * Intersection test between the ray and a given segment within a given tolerance (threshold)
       * @param sega the first point of the segment to test the intersection against
       * @param segb the second point of the segment to test the intersection against
       * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful
       * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection
       */
      intersectionSegment(sega, segb, threshold) {
        const o = this.origin;
        const u = TmpVectors.Vector3[0];
        const rsegb = TmpVectors.Vector3[1];
        const v = TmpVectors.Vector3[2];
        const w = TmpVectors.Vector3[3];
        segb.subtractToRef(sega, u);
        this.direction.scaleToRef(_Ray._Rayl, v);
        o.addToRef(v, rsegb);
        sega.subtractToRef(o, w);
        const a = Vector3.Dot(u, u);
        const b = Vector3.Dot(u, v);
        const c = Vector3.Dot(v, v);
        const d = Vector3.Dot(u, w);
        const e = Vector3.Dot(v, w);
        const discriminant = a * c - b * b;
        let sN, sD = discriminant;
        let tN, tD = discriminant;
        if (discriminant < _Ray._Smallnum) {
          sN = 0;
          sD = 1;
          tN = e;
          tD = c;
        } else {
          sN = b * e - c * d;
          tN = a * e - b * d;
          if (sN < 0) {
            sN = 0;
            tN = e;
            tD = c;
          } else if (sN > sD) {
            sN = sD;
            tN = e + b;
            tD = c;
          }
        }
        if (tN < 0) {
          tN = 0;
          if (-d < 0) {
            sN = 0;
          } else if (-d > a) {
            sN = sD;
          } else {
            sN = -d;
            sD = a;
          }
        } else if (tN > tD) {
          tN = tD;
          if (-d + b < 0) {
            sN = 0;
          } else if (-d + b > a) {
            sN = sD;
          } else {
            sN = -d + b;
            sD = a;
          }
        }
        const sc = Math.abs(sN) < _Ray._Smallnum ? 0 : sN / sD;
        const tc = Math.abs(tN) < _Ray._Smallnum ? 0 : tN / tD;
        const qtc = TmpVectors.Vector3[4];
        v.scaleToRef(tc, qtc);
        const qsc = TmpVectors.Vector3[5];
        u.scaleToRef(sc, qsc);
        qsc.addInPlace(w);
        const dP = TmpVectors.Vector3[6];
        qsc.subtractToRef(qtc, dP);
        const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold;
        if (isIntersected) {
          return qsc.length();
        }
        return -1;
      }
      /**
       * Update the ray from viewport position
       * @param x position
       * @param y y position
       * @param viewportWidth viewport width
       * @param viewportHeight viewport height
       * @param world world matrix
       * @param view view matrix
       * @param projection projection matrix
       * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)
       * @returns this ray updated
       */
      update(x, y, viewportWidth, viewportHeight, world, view, projection, enableDistantPicking = false) {
        if (enableDistantPicking) {
          if (!_Ray._RayDistant) {
            _Ray._RayDistant = _Ray.Zero();
          }
          _Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);
          const tm = TmpVectors.Matrix[0];
          world.invertToRef(tm);
          _Ray.TransformToRef(_Ray._RayDistant, tm, this);
        } else {
          this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);
        }
        return this;
      }
      // Statics
      /**
       * Creates a ray with origin and direction of 0,0,0
       * @returns the new ray
       */
      static Zero() {
        return new _Ray(Vector3.Zero(), Vector3.Zero());
      }
      /**
       * Creates a new ray from screen space and viewport
       * @param x position
       * @param y y position
       * @param viewportWidth viewport width
       * @param viewportHeight viewport height
       * @param world world matrix
       * @param view view matrix
       * @param projection projection matrix
       * @returns new ray
       */
      static CreateNew(x, y, viewportWidth, viewportHeight, world, view, projection) {
        const result = _Ray.Zero();
        return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);
      }
      /**
       * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
       * transformed to the given world matrix.
       * @param origin The origin point
       * @param end The end point
       * @param world a matrix to transform the ray to. Default is the identity matrix.
       * @returns the new ray
       */
      static CreateNewFromTo(origin, end, world = Matrix.IdentityReadOnly) {
        const result = new _Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
        return _Ray.CreateFromToToRef(origin, end, result, world);
      }
      /**
       * Function will update a transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
       * transformed to the given world matrix.
       * @param origin The origin point
       * @param end The end point
       * @param result the object to store the result
       * @param world a matrix to transform the ray to. Default is the identity matrix.
       * @returns the ref ray
       */
      static CreateFromToToRef(origin, end, result, world = Matrix.IdentityReadOnly) {
        result.origin.copyFrom(origin);
        const direction = end.subtractToRef(origin, result.direction);
        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
        result.length = length;
        result.direction.normalize();
        return _Ray.TransformToRef(result, world, result);
      }
      /**
       * Transforms a ray by a matrix
       * @param ray ray to transform
       * @param matrix matrix to apply
       * @returns the resulting new ray
       */
      static Transform(ray, matrix) {
        const result = new _Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
        _Ray.TransformToRef(ray, matrix, result);
        return result;
      }
      /**
       * Transforms a ray by a matrix
       * @param ray ray to transform
       * @param matrix matrix to apply
       * @param result ray to store result in
       * @returns the updated result ray
       */
      static TransformToRef(ray, matrix, result) {
        Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);
        Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);
        result.length = ray.length;
        result.epsilon = ray.epsilon;
        const dir = result.direction;
        const len = dir.length();
        if (!(len === 0 || len === 1)) {
          const num = 1 / len;
          dir.x *= num;
          dir.y *= num;
          dir.z *= num;
          result.length *= len;
        }
        return result;
      }
      /**
       * Unproject a ray from screen space to object space
       * @param sourceX defines the screen space x coordinate to use
       * @param sourceY defines the screen space y coordinate to use
       * @param viewportWidth defines the current width of the viewport
       * @param viewportHeight defines the current height of the viewport
       * @param world defines the world matrix to use (can be set to Identity to go to world space)
       * @param view defines the view matrix to use
       * @param projection defines the projection matrix to use
       */
      unprojectRayToRef(sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {
        const matrix = TmpVectors.Matrix[0];
        world.multiplyToRef(view, matrix);
        matrix.multiplyToRef(projection, matrix);
        matrix.invert();
        const engine = EngineStore.LastCreatedEngine;
        const nearScreenSource = TmpVectors.Vector3[0];
        nearScreenSource.x = sourceX / viewportWidth * 2 - 1;
        nearScreenSource.y = -(sourceY / viewportHeight * 2 - 1);
        nearScreenSource.z = engine?.useReverseDepthBuffer ? 1 : engine?.isNDCHalfZRange ? 0 : -1;
        const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1 - 1e-8);
        const nearVec3 = TmpVectors.Vector3[2];
        const farVec3 = TmpVectors.Vector3[3];
        Vector3.TransformCoordinatesToRef(nearScreenSource, matrix, nearVec3);
        Vector3.TransformCoordinatesToRef(farScreenSource, matrix, farVec3);
        this.origin.copyFrom(nearVec3);
        farVec3.subtractToRef(nearVec3, this.direction);
        this.direction.normalize();
      }
    };
    Ray._TmpVector3 = BuildArray(6, Vector3.Zero);
    Ray._RayDistant = Ray.Zero();
    Ray._Smallnum = 1e-8;
    Ray._Rayl = 1e9;
  }
});

// node_modules/@babylonjs/core/Misc/pivotTools.js
var PivotTools;
var init_pivotTools = __esm({
  "node_modules/@babylonjs/core/Misc/pivotTools.js"() {
    init_math_vector();
    PivotTools = class _PivotTools {
      /**
       * @internal
       */
      static _RemoveAndStorePivotPoint(mesh) {
        if (mesh && _PivotTools._PivotCached === 0) {
          mesh.getPivotPointToRef(_PivotTools._OldPivotPoint);
          _PivotTools._PivotPostMultiplyPivotMatrix = mesh._postMultiplyPivotMatrix;
          if (!_PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0)) {
            mesh.setPivotMatrix(Matrix.IdentityReadOnly);
            _PivotTools._OldPivotPoint.subtractToRef(mesh.getPivotPoint(), _PivotTools._PivotTranslation);
            _PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);
            _PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);
            _PivotTools._PivotTmpVector.multiplyInPlace(_PivotTools._PivotTranslation);
            mesh.position.addInPlace(_PivotTools._PivotTmpVector);
          }
        }
        _PivotTools._PivotCached++;
      }
      /**
       * @internal
       */
      static _RestorePivotPoint(mesh) {
        if (mesh && !_PivotTools._OldPivotPoint.equalsToFloats(0, 0, 0) && _PivotTools._PivotCached === 1) {
          mesh.setPivotPoint(_PivotTools._OldPivotPoint);
          mesh._postMultiplyPivotMatrix = _PivotTools._PivotPostMultiplyPivotMatrix;
          _PivotTools._PivotTmpVector.copyFromFloats(1, 1, 1);
          _PivotTools._PivotTmpVector.subtractInPlace(mesh.scaling);
          _PivotTools._PivotTmpVector.multiplyInPlace(_PivotTools._PivotTranslation);
          mesh.position.subtractInPlace(_PivotTools._PivotTmpVector);
        }
        this._PivotCached--;
      }
    };
    PivotTools._PivotCached = 0;
    PivotTools._OldPivotPoint = new Vector3();
    PivotTools._PivotTranslation = new Vector3();
    PivotTools._PivotTmpVector = new Vector3();
    PivotTools._PivotPostMultiplyPivotMatrix = false;
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js
function CreatePlaneVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  const width = options.width !== void 0 ? options.width : options.size !== void 0 ? options.size : 1;
  const height = options.height !== void 0 ? options.height : options.size !== void 0 ? options.size : 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const halfWidth = width / 2;
  const halfHeight = height / 2;
  positions.push(-halfWidth, -halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(0, useOpenGLOrientationForUV ? 1 : 0);
  positions.push(halfWidth, -halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(1, useOpenGLOrientationForUV ? 1 : 0);
  positions.push(halfWidth, halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(1, useOpenGLOrientationForUV ? 0 : 1);
  positions.push(-halfWidth, halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(0, useOpenGLOrientationForUV ? 0 : 1);
  indices.push(0);
  indices.push(1);
  indices.push(2);
  indices.push(0);
  indices.push(2);
  indices.push(3);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreatePlane(name13, options = {}, scene = null) {
  const plane = new Mesh(name13, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  plane._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreatePlaneVertexData(options);
  vertexData.applyToMesh(plane, options.updatable);
  if (options.sourcePlane) {
    plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);
    plane.setDirection(options.sourcePlane.normal.scale(-1));
  }
  return plane;
}
var PlaneBuilder;
var init_planeBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js"() {
    init_mesh();
    init_mesh_vertexData();
    init_compatibilityOptions();
    PlaneBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreatePlane
    };
    VertexData.CreatePlane = CreatePlaneVertexData;
    Mesh.CreatePlane = (name13, size, scene, updatable, sideOrientation) => {
      const options = {
        size,
        width: size,
        height: size,
        sideOrientation,
        updatable
      };
      return CreatePlane(name13, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Culling/ray.js
var init_ray = __esm({
  "node_modules/@babylonjs/core/Culling/ray.js"() {
    init_scene();
    init_camera();
    init_ray_core();
    init_ray_core();
    AddRayExtensions(Scene, Camera);
    Scene.prototype.createPickingRayToRef = function(x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {
      return CreatePickingRayToRef(this, x, y, world, result, camera, cameraViewSpace, enableDistantPicking);
    };
    Scene.prototype.createPickingRayInCameraSpace = function(x, y, camera) {
      return CreatePickingRayInCameraSpace(this, x, y, camera);
    };
    Scene.prototype.createPickingRayInCameraSpaceToRef = function(x, y, result, camera) {
      return CreatePickingRayInCameraSpaceToRef(this, x, y, result, camera);
    };
    Scene.prototype.pickWithBoundingInfo = function(x, y, predicate, fastCheck, camera) {
      return PickWithBoundingInfo(this, x, y, predicate, fastCheck, camera);
    };
    Scene.prototype.pick = function(x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking = false) {
      return Pick(this, x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking);
    };
    Scene.prototype.pickWithRay = function(ray, predicate, fastCheck, trianglePredicate) {
      return PickWithRay(this, ray, predicate, fastCheck, trianglePredicate);
    };
    Scene.prototype.multiPick = function(x, y, predicate, camera, trianglePredicate) {
      return MultiPick(this, x, y, predicate, camera, trianglePredicate);
    };
    Scene.prototype.multiPickWithRay = function(ray, predicate, trianglePredicate) {
      return MultiPickWithRay(this, ray, predicate, trianglePredicate);
    };
  }
});

// node_modules/@babylonjs/core/Behaviors/Meshes/pointerDragBehavior.js
var PointerDragBehavior;
var init_pointerDragBehavior = __esm({
  "node_modules/@babylonjs/core/Behaviors/Meshes/pointerDragBehavior.js"() {
    init_mesh();
    init_scene();
    init_observable();
    init_math_vector();
    init_pointerEvents();
    init_ray();
    init_pivotTools();
    init_planeBuilder();
    init_math_constants();
    PointerDragBehavior = class _PointerDragBehavior {
      /**
       * Get or set the currentDraggingPointerId
       * @deprecated Please use currentDraggingPointerId instead
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      get currentDraggingPointerID() {
        return this.currentDraggingPointerId;
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      set currentDraggingPointerID(currentDraggingPointerId) {
        this.currentDraggingPointerId = currentDraggingPointerId;
      }
      /**
       *  If the drag behavior will react to drag events (Default: true)
       */
      set enabled(value) {
        if (value != this._enabled) {
          this.onEnabledObservable.notifyObservers(value);
        }
        this._enabled = value;
      }
      get enabled() {
        return this._enabled;
      }
      /**
       * Gets the options used by the behavior
       */
      get options() {
        return this._options;
      }
      /**
       * Sets the options used by the behavior
       */
      set options(options) {
        this._options = options;
      }
      /**
       * Creates a pointer drag behavior that can be attached to a mesh
       * @param options The drag axis or normal of the plane that will be dragged across. If no options are specified the drag plane will always face the ray's origin (eg. camera)
       * @param options.dragAxis
       * @param options.dragPlaneNormal
       */
      constructor(options) {
        this._useAlternatePickedPointAboveMaxDragAngleDragSpeed = -1.1;
        this._activeDragButton = -1;
        this.maxDragAngle = 0;
        this.dragButtons = [0, 1, 2];
        this._useAlternatePickedPointAboveMaxDragAngle = false;
        this.currentDraggingPointerId = -1;
        this.dragging = false;
        this.dragDeltaRatio = 0.2;
        this.updateDragPlane = true;
        this._debugMode = false;
        this._moving = false;
        this.onDragObservable = new Observable();
        this.onDragStartObservable = new Observable();
        this.onDragEndObservable = new Observable();
        this.onEnabledObservable = new Observable();
        this.moveAttached = true;
        this._enabled = true;
        this.startAndReleaseDragOnPointerEvents = true;
        this.detachCameraControls = true;
        this.useObjectOrientationForDragging = true;
        this.allowOtherButtonsDuringDrag = false;
        this.validateDrag = (target) => {
          return true;
        };
        this._tmpVector = new Vector3(0, 0, 0);
        this._alternatePickedPoint = new Vector3(0, 0, 0);
        this._worldDragAxis = new Vector3(0, 0, 0);
        this._targetPosition = new Vector3(0, 0, 0);
        this._attachedToElement = false;
        this._startDragRay = new Ray(new Vector3(), new Vector3());
        this._lastPointerRay = {};
        this._dragDelta = new Vector3();
        this._pointA = new Vector3(0, 0, 0);
        this._pointC = new Vector3(0, 0, 0);
        this._localAxis = new Vector3(0, 0, 0);
        this._lookAt = new Vector3(0, 0, 0);
        this._options = options ? options : {};
        let optionCount = 0;
        if (this._options.dragAxis) {
          optionCount++;
        }
        if (this._options.dragPlaneNormal) {
          optionCount++;
        }
        if (optionCount > 1) {
          throw "Multiple drag modes specified in dragBehavior options. Only one expected";
        }
      }
      /**
       *  The name of the behavior
       */
      get name() {
        return "PointerDrag";
      }
      /**
       *  Initializes the behavior
       */
      init() {
      }
      /**
       * Attaches the drag behavior the passed in mesh
       * @param ownerNode The mesh that will be dragged around once attached
       * @param predicate Predicate to use for pick filtering
       */
      attach(ownerNode, predicate) {
        this._scene = ownerNode.getScene();
        ownerNode.isNearGrabbable = true;
        this.attachedNode = ownerNode;
        if (!_PointerDragBehavior._PlaneScene) {
          if (this._debugMode) {
            _PointerDragBehavior._PlaneScene = this._scene;
          } else {
            _PointerDragBehavior._PlaneScene = new Scene(this._scene.getEngine(), { virtual: true });
            _PointerDragBehavior._PlaneScene.detachControl();
            this._scene.onDisposeObservable.addOnce(() => {
              _PointerDragBehavior._PlaneScene.dispose();
              _PointerDragBehavior._PlaneScene = null;
            });
          }
        }
        this._dragPlane = CreatePlane("pointerDragPlane", { size: this._debugMode ? 1 : 1e4, updatable: false, sideOrientation: Mesh.DOUBLESIDE }, _PointerDragBehavior._PlaneScene);
        this.lastDragPosition = new Vector3(0, 0, 0);
        const pickPredicate = predicate ? predicate : (m) => {
          return this.attachedNode == m || m.isDescendantOf(this.attachedNode);
        };
        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {
          if (!this.enabled) {
            if (this._attachedToElement) {
              this.releaseDrag();
            }
            return;
          }
          if (this.dragging && this.currentDraggingPointerId == pointerInfo.event.pointerId && pointerInfo.event.button !== -1 && pointerInfo.event.button !== this._activeDragButton && !this.allowOtherButtonsDuringDrag) {
            this.releaseDrag();
            return;
          }
          if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
            if (this.startAndReleaseDragOnPointerEvents && !this.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.pickedPoint && pointerInfo.pickInfo.ray && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {
              if (this._activeDragButton === -1 && this.dragButtons.indexOf(pointerInfo.event.button) !== -1) {
                this._activeDragButton = pointerInfo.event.button;
                this._activePointerInfo = pointerInfo;
                this._startDrag(pointerInfo.event.pointerId, pointerInfo.pickInfo.ray, pointerInfo.pickInfo.pickedPoint);
              }
            }
          } else if (pointerInfo.type == PointerEventTypes.POINTERUP) {
            if (this.startAndReleaseDragOnPointerEvents && this.currentDraggingPointerId == pointerInfo.event.pointerId && (this._activeDragButton === pointerInfo.event.button || this._activeDragButton === -1)) {
              this.releaseDrag();
            }
          } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {
            const pointerId = pointerInfo.event.pointerId;
            if (this.currentDraggingPointerId === _PointerDragBehavior._AnyMouseId && pointerId !== _PointerDragBehavior._AnyMouseId) {
              const evt = pointerInfo.event;
              const isMouseEvent = evt.pointerType === "mouse" || !this._scene.getEngine().hostInformation.isMobile && evt instanceof MouseEvent;
              if (isMouseEvent) {
                if (this._lastPointerRay[this.currentDraggingPointerId]) {
                  this._lastPointerRay[pointerId] = this._lastPointerRay[this.currentDraggingPointerId];
                  delete this._lastPointerRay[this.currentDraggingPointerId];
                }
                this.currentDraggingPointerId = pointerId;
              }
            }
            if (!this._lastPointerRay[pointerId]) {
              this._lastPointerRay[pointerId] = new Ray(new Vector3(), new Vector3());
            }
            if (pointerInfo.pickInfo && pointerInfo.pickInfo.ray) {
              this._lastPointerRay[pointerId].origin.copyFrom(pointerInfo.pickInfo.ray.origin);
              this._lastPointerRay[pointerId].direction.copyFrom(pointerInfo.pickInfo.ray.direction);
              if (this.currentDraggingPointerId == pointerId && this.dragging) {
                this._moveDrag(pointerInfo.pickInfo.ray);
              }
            }
          }
        });
        this._beforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {
          if (this._moving && this.moveAttached) {
            let needMatrixUpdate = false;
            PivotTools._RemoveAndStorePivotPoint(this.attachedNode);
            this._targetPosition.subtractToRef(this.attachedNode.absolutePosition, this._tmpVector);
            this._tmpVector.scaleInPlace(this.dragDeltaRatio);
            this.attachedNode.getAbsolutePosition().addToRef(this._tmpVector, this._tmpVector);
            if (this.validateDrag(this._tmpVector)) {
              this.attachedNode.setAbsolutePosition(this._tmpVector);
              needMatrixUpdate = true;
            }
            PivotTools._RestorePivotPoint(this.attachedNode);
            if (needMatrixUpdate) {
              this.attachedNode.computeWorldMatrix();
            }
          }
        });
      }
      /**
       * Force release the drag action by code.
       */
      releaseDrag() {
        if (this.dragging) {
          this.dragging = false;
          this.onDragEndObservable.notifyObservers({ dragPlanePoint: this.lastDragPosition, pointerId: this.currentDraggingPointerId, pointerInfo: this._activePointerInfo });
        }
        this.currentDraggingPointerId = -1;
        this._activeDragButton = -1;
        this._activePointerInfo = null;
        this._moving = false;
        if (this.detachCameraControls && this._attachedToElement && this._scene.activeCamera && !this._scene.activeCamera.leftCamera) {
          if (this._scene.activeCamera.getClassName() === "ArcRotateCamera") {
            const arcRotateCamera = this._scene.activeCamera;
            arcRotateCamera.attachControl(arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true, arcRotateCamera._useCtrlForPanning, arcRotateCamera._panningMouseButton);
          } else {
            this._scene.activeCamera.attachControl(this._scene.activeCamera.inputs ? this._scene.activeCamera.inputs.noPreventDefault : true);
          }
          this._attachedToElement = false;
        }
      }
      /**
       * Simulates the start of a pointer drag event on the behavior
       * @param pointerId pointerID of the pointer that should be simulated (Default: Any mouse pointer ID)
       * @param fromRay initial ray of the pointer to be simulated (Default: Ray from camera to attached mesh)
       * @param startPickedPoint picked point of the pointer to be simulated (Default: attached mesh position)
       */
      startDrag(pointerId = _PointerDragBehavior._AnyMouseId, fromRay, startPickedPoint) {
        this._startDrag(pointerId, fromRay, startPickedPoint);
        let lastRay = this._lastPointerRay[pointerId];
        if (pointerId === _PointerDragBehavior._AnyMouseId) {
          lastRay = this._lastPointerRay[Object.keys(this._lastPointerRay)[0]];
        }
        if (lastRay) {
          this._moveDrag(lastRay);
        }
      }
      _startDrag(pointerId, fromRay, startPickedPoint) {
        if (!this._scene.activeCamera || this.dragging || !this.attachedNode) {
          return;
        }
        PivotTools._RemoveAndStorePivotPoint(this.attachedNode);
        if (fromRay) {
          this._startDragRay.direction.copyFrom(fromRay.direction);
          this._startDragRay.origin.copyFrom(fromRay.origin);
        } else {
          this._startDragRay.origin.copyFrom(this._scene.activeCamera.position);
          this.attachedNode.getWorldMatrix().getTranslationToRef(this._tmpVector);
          this._tmpVector.subtractToRef(this._scene.activeCamera.position, this._startDragRay.direction);
        }
        this._updateDragPlanePosition(this._startDragRay, startPickedPoint ? startPickedPoint : this._tmpVector);
        const pickedPoint = this._pickWithRayOnDragPlane(this._startDragRay);
        if (pickedPoint) {
          this.dragging = true;
          this.currentDraggingPointerId = pointerId;
          this.lastDragPosition.copyFrom(pickedPoint);
          this.onDragStartObservable.notifyObservers({ dragPlanePoint: pickedPoint, pointerId: this.currentDraggingPointerId, pointerInfo: this._activePointerInfo });
          this._targetPosition.copyFrom(this.attachedNode.getAbsolutePosition());
          if (this.detachCameraControls && this._scene.activeCamera && this._scene.activeCamera.inputs && !this._scene.activeCamera.leftCamera) {
            if (this._scene.activeCamera.inputs.attachedToElement) {
              this._scene.activeCamera.detachControl();
              this._attachedToElement = true;
            } else {
              this._attachedToElement = false;
            }
          }
        } else {
          this.releaseDrag();
        }
        PivotTools._RestorePivotPoint(this.attachedNode);
      }
      _moveDrag(ray) {
        this._moving = true;
        const pickedPoint = this._pickWithRayOnDragPlane(ray);
        if (pickedPoint) {
          PivotTools._RemoveAndStorePivotPoint(this.attachedNode);
          if (this.updateDragPlane) {
            this._updateDragPlanePosition(ray, pickedPoint);
          }
          let dragLength = 0;
          if (this._options.dragAxis) {
            this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._worldDragAxis) : this._worldDragAxis.copyFrom(this._options.dragAxis);
            pickedPoint.subtractToRef(this.lastDragPosition, this._tmpVector);
            this._worldDragAxis.normalize();
            dragLength = Vector3.Dot(this._tmpVector, this._worldDragAxis);
            this._worldDragAxis.scaleToRef(dragLength, this._dragDelta);
          } else {
            dragLength = this._dragDelta.length();
            pickedPoint.subtractToRef(this.lastDragPosition, this._dragDelta);
          }
          this._targetPosition.addInPlace(this._dragDelta);
          this.onDragObservable.notifyObservers({
            dragDistance: dragLength,
            delta: this._dragDelta,
            dragPlanePoint: pickedPoint,
            dragPlaneNormal: this._dragPlane.forward,
            pointerId: this.currentDraggingPointerId,
            pointerInfo: this._activePointerInfo
          });
          this.lastDragPosition.copyFrom(pickedPoint);
          PivotTools._RestorePivotPoint(this.attachedNode);
        }
      }
      _pickWithRayOnDragPlane(ray) {
        if (!ray) {
          return null;
        }
        let angle = Math.acos(Vector3.Dot(this._dragPlane.forward, ray.direction));
        if (angle > Math.PI / 2) {
          angle = Math.PI - angle;
        }
        if (this.maxDragAngle > 0 && angle > this.maxDragAngle) {
          if (this._useAlternatePickedPointAboveMaxDragAngle) {
            this._tmpVector.copyFrom(ray.direction);
            this.attachedNode.absolutePosition.subtractToRef(ray.origin, this._alternatePickedPoint);
            this._alternatePickedPoint.normalize();
            this._alternatePickedPoint.scaleInPlace(this._useAlternatePickedPointAboveMaxDragAngleDragSpeed * Vector3.Dot(this._alternatePickedPoint, this._tmpVector));
            this._tmpVector.addInPlace(this._alternatePickedPoint);
            const dot = Vector3.Dot(this._dragPlane.forward, this._tmpVector);
            this._dragPlane.forward.scaleToRef(-dot, this._alternatePickedPoint);
            this._alternatePickedPoint.addInPlace(this._tmpVector);
            this._alternatePickedPoint.addInPlace(this.attachedNode.absolutePosition);
            return this._alternatePickedPoint;
          } else {
            return null;
          }
        }
        const planeNormal = this._dragPlane.forward;
        const planePosition = this._dragPlane.position;
        const dotProduct = ray.direction.dot(planeNormal);
        if (Math.abs(dotProduct) < Epsilon) {
          return null;
        }
        planePosition.subtractToRef(ray.origin, TmpVectors.Vector3[0]);
        const t = TmpVectors.Vector3[0].dot(planeNormal) / dotProduct;
        if (t < 0) {
          return null;
        }
        ray.direction.scaleToRef(t, TmpVectors.Vector3[0]);
        const intersectionPoint = ray.origin.add(TmpVectors.Vector3[0]);
        return intersectionPoint;
      }
      // Position the drag plane based on the attached mesh position, for single axis rotate the plane along the axis to face the camera
      _updateDragPlanePosition(ray, dragPlanePosition) {
        this._pointA.copyFrom(dragPlanePosition);
        if (this._options.dragAxis) {
          this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragAxis, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragAxis);
          ray.origin.subtractToRef(this._pointA, this._pointC);
          this._pointC.normalize();
          if (Math.abs(Vector3.Dot(this._localAxis, this._pointC)) > 0.999) {
            if (Math.abs(Vector3.Dot(Vector3.UpReadOnly, this._pointC)) > 0.999) {
              this._lookAt.copyFrom(Vector3.Right());
            } else {
              this._lookAt.copyFrom(Vector3.UpReadOnly);
            }
          } else {
            Vector3.CrossToRef(this._localAxis, this._pointC, this._lookAt);
            Vector3.CrossToRef(this._localAxis, this._lookAt, this._lookAt);
            this._lookAt.normalize();
          }
          this._dragPlane.position.copyFrom(this._pointA);
          this._pointA.addToRef(this._lookAt, this._lookAt);
          this._dragPlane.lookAt(this._lookAt);
        } else if (this._options.dragPlaneNormal) {
          this.useObjectOrientationForDragging ? Vector3.TransformCoordinatesToRef(this._options.dragPlaneNormal, this.attachedNode.getWorldMatrix().getRotationMatrix(), this._localAxis) : this._localAxis.copyFrom(this._options.dragPlaneNormal);
          this._dragPlane.position.copyFrom(this._pointA);
          this._pointA.addToRef(this._localAxis, this._lookAt);
          this._dragPlane.lookAt(this._lookAt);
        } else {
          if (this._scene.activeCamera) {
            this._scene.activeCamera.getForwardRay().direction.normalizeToRef(this._localAxis);
          }
          this._dragPlane.position.copyFrom(this._pointA);
          this._dragPlane.lookAt(this._pointA.add(this._localAxis));
        }
        this._dragPlane.position.copyFrom(this.attachedNode.getAbsolutePosition());
        this._dragPlane.computeWorldMatrix(true);
      }
      /**
       *  Detaches the behavior from the mesh
       */
      detach() {
        this._lastPointerRay = {};
        if (this.attachedNode) {
          this.attachedNode.isNearGrabbable = false;
        }
        if (this._pointerObserver) {
          this._scene.onPointerObservable.remove(this._pointerObserver);
        }
        if (this._beforeRenderObserver) {
          this._scene.onBeforeRenderObservable.remove(this._beforeRenderObserver);
        }
        if (this._dragPlane) {
          this._dragPlane.dispose();
        }
        this.releaseDrag();
      }
    };
    PointerDragBehavior._AnyMouseId = -2;
  }
});

// node_modules/@babylonjs/core/Behaviors/Meshes/baseSixDofDragBehavior.js
var BaseSixDofDragBehavior;
var init_baseSixDofDragBehavior = __esm({
  "node_modules/@babylonjs/core/Behaviors/Meshes/baseSixDofDragBehavior.js"() {
    init_scene();
    init_pointerEvents();
    init_math_vector();
    init_observable();
    init_transformNode();
    init_camera();
    BaseSixDofDragBehavior = class _BaseSixDofDragBehavior {
      constructor() {
        this._attachedToElement = false;
        this._virtualMeshesInfo = {};
        this._tmpVector = new Vector3();
        this._tmpQuaternion = new Quaternion();
        this._dragType = {
          NONE: 0,
          DRAG: 1,
          DRAG_WITH_CONTROLLER: 2,
          NEAR_DRAG: 3
        };
        this._moving = false;
        this._ownerNode = null;
        this._dragging = this._dragType.NONE;
        this.draggableMeshes = null;
        this.zDragFactor = 3;
        this.currentDraggingPointerIds = [];
        this.detachCameraControls = true;
        this.onDragStartObservable = new Observable();
        this.onDragObservable = new Observable();
        this.onDragEndObservable = new Observable();
        this.allowMultiPointer = true;
      }
      /**
       * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)
       */
      get currentDraggingPointerId() {
        if (this.currentDraggingPointerIds[0] !== void 0) {
          return this.currentDraggingPointerIds[0];
        }
        return -1;
      }
      set currentDraggingPointerId(value) {
        this.currentDraggingPointerIds[0] = value;
      }
      /**
       * Get or set the currentDraggingPointerId
       * @deprecated Please use currentDraggingPointerId instead
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      get currentDraggingPointerID() {
        return this.currentDraggingPointerId;
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      set currentDraggingPointerID(currentDraggingPointerID) {
        this.currentDraggingPointerId = currentDraggingPointerID;
      }
      /**
       *  The name of the behavior
       */
      get name() {
        return "BaseSixDofDrag";
      }
      /**
       *  Returns true if the attached mesh is currently moving with this behavior
       */
      get isMoving() {
        return this._moving;
      }
      /**
       * Attached node of this behavior
       */
      get attachedNode() {
        return this._ownerNode;
      }
      /**
       *  Initializes the behavior
       */
      init() {
      }
      /**
       * In the case of multiple active cameras, the cameraToUseForPointers should be used if set instead of active camera
       */
      get _pointerCamera() {
        if (this._scene.cameraToUseForPointers) {
          return this._scene.cameraToUseForPointers;
        } else {
          return this._scene.activeCamera;
        }
      }
      _createVirtualMeshInfo() {
        const dragMesh = new TransformNode("", _BaseSixDofDragBehavior._VirtualScene);
        dragMesh.rotationQuaternion = new Quaternion();
        const originMesh = new TransformNode("", _BaseSixDofDragBehavior._VirtualScene);
        originMesh.rotationQuaternion = new Quaternion();
        const pivotMesh = new TransformNode("", _BaseSixDofDragBehavior._VirtualScene);
        pivotMesh.rotationQuaternion = new Quaternion();
        return {
          dragging: false,
          moving: false,
          dragMesh,
          originMesh,
          pivotMesh,
          startingPivotPosition: new Vector3(),
          startingPivotOrientation: new Quaternion(),
          startingPosition: new Vector3(),
          startingOrientation: new Quaternion(),
          lastOriginPosition: new Vector3(),
          lastDragPosition: new Vector3()
        };
      }
      _resetVirtualMeshesPosition() {
        for (let i = 0; i < this.currentDraggingPointerIds.length; i++) {
          this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());
          this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion.copyFrom(this._ownerNode.rotationQuaternion);
          this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position);
          this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotOrientation.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion);
          this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.position);
          this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingOrientation.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.rotationQuaternion);
        }
      }
      _pointerUpdate2D(ray, pointerId, zDragFactor) {
        if (this._pointerCamera && this._pointerCamera.cameraRigMode == Camera.RIG_MODE_NONE && !this._pointerCamera._isLeftCamera && !this._pointerCamera._isRightCamera) {
          ray.origin.copyFrom(this._pointerCamera.globalPosition);
          zDragFactor = 0;
        }
        const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];
        const originDragDifference = TmpVectors.Vector3[11];
        ray.origin.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDifference);
        virtualMeshesInfo.lastOriginPosition.copyFrom(ray.origin);
        const localOriginDragDifference = -Vector3.Dot(originDragDifference, ray.direction);
        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.dragMesh);
        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.pivotMesh);
        this._applyZOffset(virtualMeshesInfo.dragMesh, localOriginDragDifference, zDragFactor);
        this._applyZOffset(virtualMeshesInfo.pivotMesh, localOriginDragDifference, zDragFactor);
        virtualMeshesInfo.originMesh.position.copyFrom(ray.origin);
        const lookAt = TmpVectors.Vector3[10];
        ray.origin.addToRef(ray.direction, lookAt);
        virtualMeshesInfo.originMesh.lookAt(lookAt);
        virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);
        virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);
      }
      _pointerUpdateXR(controllerAimTransform, controllerGripTransform, pointerId, zDragFactor) {
        const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];
        virtualMeshesInfo.originMesh.position.copyFrom(controllerAimTransform.position);
        if (this._dragging === this._dragType.NEAR_DRAG && controllerGripTransform) {
          virtualMeshesInfo.originMesh.rotationQuaternion.copyFrom(controllerGripTransform.rotationQuaternion);
        } else {
          virtualMeshesInfo.originMesh.rotationQuaternion.copyFrom(controllerAimTransform.rotationQuaternion);
        }
        virtualMeshesInfo.pivotMesh.computeWorldMatrix(true);
        virtualMeshesInfo.dragMesh.computeWorldMatrix(true);
        if (zDragFactor !== 0) {
          const cameraForwardVec = TmpVectors.Vector3[10];
          const originDragDirection = TmpVectors.Vector3[11];
          cameraForwardVec.copyFrom(this._pointerCamera.getForwardRay().direction);
          virtualMeshesInfo.originMesh.position.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDirection);
          virtualMeshesInfo.lastOriginPosition.copyFrom(virtualMeshesInfo.originMesh.position);
          const controllerDragDistance = originDragDirection.length();
          originDragDirection.normalize();
          const cameraToDrag = TmpVectors.Vector3[12];
          const controllerToDrag = TmpVectors.Vector3[9];
          virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(this._pointerCamera.globalPosition, cameraToDrag);
          virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(virtualMeshesInfo.originMesh.position, controllerToDrag);
          const controllerToDragDistance = controllerToDrag.length();
          cameraToDrag.normalize();
          controllerToDrag.normalize();
          const controllerDragScaling = Math.abs(Vector3.Dot(originDragDirection, controllerToDrag)) * Vector3.Dot(originDragDirection, cameraForwardVec);
          let zOffsetScaling = controllerDragScaling * zDragFactor * controllerDragDistance * controllerToDragDistance;
          const minDistanceFromControllerToDragMesh = 0.01;
          if (zOffsetScaling < 0 && minDistanceFromControllerToDragMesh - controllerToDragDistance > zOffsetScaling) {
            zOffsetScaling = Math.min(minDistanceFromControllerToDragMesh - controllerToDragDistance, 0);
          }
          controllerToDrag.scaleInPlace(zOffsetScaling);
          controllerToDrag.addToRef(virtualMeshesInfo.pivotMesh.absolutePosition, this._tmpVector);
          virtualMeshesInfo.pivotMesh.setAbsolutePosition(this._tmpVector);
          controllerToDrag.addToRef(virtualMeshesInfo.dragMesh.absolutePosition, this._tmpVector);
          virtualMeshesInfo.dragMesh.setAbsolutePosition(this._tmpVector);
        }
      }
      /**
       * Attaches the scale behavior the passed in mesh
       * @param ownerNode The mesh that will be scaled around once attached
       */
      attach(ownerNode) {
        this._ownerNode = ownerNode;
        this._scene = this._ownerNode.getScene();
        if (!_BaseSixDofDragBehavior._VirtualScene) {
          _BaseSixDofDragBehavior._VirtualScene = new Scene(this._scene.getEngine(), { virtual: true });
          _BaseSixDofDragBehavior._VirtualScene.detachControl();
        }
        const pickPredicate = (m) => {
          return this._ownerNode === m || m.isDescendantOf(this._ownerNode) && (!this.draggableMeshes || this.draggableMeshes.indexOf(m) !== -1);
        };
        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {
          const pointerId = pointerInfo.event.pointerId;
          if (!this._virtualMeshesInfo[pointerId]) {
            this._virtualMeshesInfo[pointerId] = this._createVirtualMeshInfo();
          }
          const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];
          const isXRPointer = pointerInfo.event.pointerType === "xr-near" || pointerInfo.event.pointerType === "xr";
          const isNearXRPointer = pointerInfo.event.pointerType === "xr-near";
          if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
            if (!virtualMeshesInfo.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.pickedPoint && pointerInfo.pickInfo.ray && (!isNearXRPointer || pointerInfo.pickInfo.aimTransform) && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {
              if ((!this.allowMultiPointer || isXRPointer) && this.currentDraggingPointerIds.length > 0) {
                return;
              }
              if (this._pointerCamera && this._pointerCamera.cameraRigMode === Camera.RIG_MODE_NONE && !this._pointerCamera._isLeftCamera && !this._pointerCamera._isRightCamera) {
                pointerInfo.pickInfo.ray.origin.copyFrom(this._pointerCamera.globalPosition);
              }
              this._ownerNode.computeWorldMatrix(true);
              const virtualMeshesInfo2 = this._virtualMeshesInfo[pointerId];
              if (isXRPointer) {
                this._dragging = pointerInfo.pickInfo.originMesh ? this._dragType.NEAR_DRAG : this._dragType.DRAG_WITH_CONTROLLER;
                virtualMeshesInfo2.originMesh.position.copyFrom(pointerInfo.pickInfo.aimTransform.position);
                if (this._dragging === this._dragType.NEAR_DRAG && pointerInfo.pickInfo.gripTransform) {
                  virtualMeshesInfo2.originMesh.rotationQuaternion.copyFrom(pointerInfo.pickInfo.gripTransform.rotationQuaternion);
                } else {
                  virtualMeshesInfo2.originMesh.rotationQuaternion.copyFrom(pointerInfo.pickInfo.aimTransform.rotationQuaternion);
                }
              } else {
                this._dragging = this._dragType.DRAG;
                virtualMeshesInfo2.originMesh.position.copyFrom(pointerInfo.pickInfo.ray.origin);
              }
              virtualMeshesInfo2.lastOriginPosition.copyFrom(virtualMeshesInfo2.originMesh.position);
              virtualMeshesInfo2.dragMesh.position.copyFrom(pointerInfo.pickInfo.pickedPoint);
              virtualMeshesInfo2.lastDragPosition.copyFrom(pointerInfo.pickInfo.pickedPoint);
              virtualMeshesInfo2.pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());
              virtualMeshesInfo2.pivotMesh.rotationQuaternion.copyFrom(this._ownerNode.absoluteRotationQuaternion);
              virtualMeshesInfo2.startingPosition.copyFrom(virtualMeshesInfo2.dragMesh.position);
              virtualMeshesInfo2.startingPivotPosition.copyFrom(virtualMeshesInfo2.pivotMesh.position);
              virtualMeshesInfo2.startingOrientation.copyFrom(virtualMeshesInfo2.dragMesh.rotationQuaternion);
              virtualMeshesInfo2.startingPivotOrientation.copyFrom(virtualMeshesInfo2.pivotMesh.rotationQuaternion);
              if (isNearXRPointer) {
                virtualMeshesInfo2.originMesh.addChild(virtualMeshesInfo2.dragMesh);
                virtualMeshesInfo2.originMesh.addChild(virtualMeshesInfo2.pivotMesh);
              } else {
                virtualMeshesInfo2.originMesh.lookAt(virtualMeshesInfo2.dragMesh.position);
              }
              virtualMeshesInfo2.dragging = true;
              if (this.currentDraggingPointerIds.indexOf(pointerId) === -1) {
                this.currentDraggingPointerIds.push(pointerId);
              }
              if (this.detachCameraControls && this._pointerCamera && !this._pointerCamera.leftCamera) {
                if (this._pointerCamera.inputs && this._pointerCamera.inputs.attachedToElement) {
                  this._pointerCamera.detachControl();
                  this._attachedToElement = true;
                } else if (!this.allowMultiPointer || this.currentDraggingPointerIds.length === 0) {
                  this._attachedToElement = false;
                }
              }
              this._targetDragStart(virtualMeshesInfo2.pivotMesh.position, virtualMeshesInfo2.pivotMesh.rotationQuaternion, pointerId);
              this.onDragStartObservable.notifyObservers({ position: virtualMeshesInfo2.pivotMesh.position });
            }
          } else if (pointerInfo.type == PointerEventTypes.POINTERUP || pointerInfo.type == PointerEventTypes.POINTERDOUBLETAP) {
            const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);
            virtualMeshesInfo.dragging = false;
            if (registeredPointerIndex !== -1) {
              this.currentDraggingPointerIds.splice(registeredPointerIndex, 1);
              if (this.currentDraggingPointerIds.length === 0) {
                this._moving = false;
                this._dragging = this._dragType.NONE;
                if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {
                  this._reattachCameraControls();
                  this._attachedToElement = false;
                }
              }
              virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);
              virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);
              this._targetDragEnd(pointerId);
              this.onDragEndObservable.notifyObservers({});
            }
          } else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {
            const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);
            if (registeredPointerIndex !== -1 && virtualMeshesInfo.dragging && pointerInfo.pickInfo && (pointerInfo.pickInfo.ray || pointerInfo.pickInfo.aimTransform)) {
              let zDragFactor = this.zDragFactor;
              if (this.currentDraggingPointerIds.length > 1 || pointerInfo.pickInfo.originMesh) {
                zDragFactor = 0;
              }
              this._ownerNode.computeWorldMatrix(true);
              if (!isNearXRPointer) {
                this._pointerUpdate2D(pointerInfo.pickInfo.ray, pointerId, zDragFactor);
              } else {
                this._pointerUpdateXR(pointerInfo.pickInfo.aimTransform, pointerInfo.pickInfo.gripTransform, pointerId, zDragFactor);
              }
              this._tmpQuaternion.copyFrom(virtualMeshesInfo.startingPivotOrientation);
              this._tmpQuaternion.x = -this._tmpQuaternion.x;
              this._tmpQuaternion.y = -this._tmpQuaternion.y;
              this._tmpQuaternion.z = -this._tmpQuaternion.z;
              virtualMeshesInfo.pivotMesh.absoluteRotationQuaternion.multiplyToRef(this._tmpQuaternion, this._tmpQuaternion);
              virtualMeshesInfo.pivotMesh.absolutePosition.subtractToRef(virtualMeshesInfo.startingPivotPosition, this._tmpVector);
              this.onDragObservable.notifyObservers({ delta: this._tmpVector, position: virtualMeshesInfo.pivotMesh.position, pickInfo: pointerInfo.pickInfo });
              this._targetDrag(this._tmpVector, this._tmpQuaternion, pointerId);
              virtualMeshesInfo.lastDragPosition.copyFrom(virtualMeshesInfo.dragMesh.absolutePosition);
              this._moving = true;
            }
          }
        });
      }
      _applyZOffset(node, localOriginDragDifference, zDragFactor) {
        node.position.z -= node.position.z < 1 ? localOriginDragDifference * zDragFactor : localOriginDragDifference * zDragFactor * node.position.z;
        if (node.position.z < 0) {
          node.position.z = 0;
        }
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _targetDragStart(worldPosition, worldRotation, pointerId) {
      }
      _targetDrag(worldDeltaPosition, worldDeltaRotation, pointerId) {
      }
      _targetDragEnd(pointerId) {
      }
      _reattachCameraControls() {
        if (this._pointerCamera) {
          if (this._pointerCamera.getClassName() === "ArcRotateCamera") {
            const arcRotateCamera = this._pointerCamera;
            arcRotateCamera.attachControl(arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true, arcRotateCamera._useCtrlForPanning, arcRotateCamera._panningMouseButton);
          } else {
            this._pointerCamera.attachControl(this._pointerCamera.inputs ? this._pointerCamera.inputs.noPreventDefault : true);
          }
        }
      }
      /**
       * Detaches the behavior from the mesh
       */
      detach() {
        if (this._scene) {
          if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {
            this._reattachCameraControls();
            this._attachedToElement = false;
          }
          this._scene.onPointerObservable.remove(this._pointerObserver);
        }
        for (const pointerId in this._virtualMeshesInfo) {
          this._virtualMeshesInfo[pointerId].originMesh.dispose();
          this._virtualMeshesInfo[pointerId].dragMesh.dispose();
        }
        this.onDragEndObservable.clear();
        this.onDragObservable.clear();
        this.onDragStartObservable.clear();
        this._ownerNode = null;
      }
    };
  }
});

// node_modules/@babylonjs/core/Behaviors/Meshes/sixDofDragBehavior.js
var SixDofDragBehavior;
var init_sixDofDragBehavior = __esm({
  "node_modules/@babylonjs/core/Behaviors/Meshes/sixDofDragBehavior.js"() {
    init_math_vector();
    init_observable();
    init_baseSixDofDragBehavior();
    init_transformNode();
    SixDofDragBehavior = class extends BaseSixDofDragBehavior {
      constructor() {
        super(...arguments);
        this._sceneRenderObserver = null;
        this._targetPosition = new Vector3(0, 0, 0);
        this._targetOrientation = new Quaternion();
        this._targetScaling = new Vector3(1, 1, 1);
        this._startingPosition = new Vector3(0, 0, 0);
        this._startingOrientation = new Quaternion();
        this._startingScaling = new Vector3(1, 1, 1);
        this.onPositionChangedObservable = new Observable();
        this.dragDeltaRatio = 0.2;
        this.rotateDraggedObject = true;
        this.rotateAroundYOnly = false;
        this.rotateWithMotionController = true;
        this.disableMovement = false;
        this.faceCameraOnDragStart = false;
      }
      /**
       *  The name of the behavior
       */
      get name() {
        return "SixDofDrag";
      }
      /**
       * Attaches the six DoF drag behavior
       * In XR mode the mesh and its children will have their isNearGrabbable property set to true
       * @param ownerNode The mesh that will be dragged around once attached
       */
      attach(ownerNode) {
        super.attach(ownerNode);
        ownerNode.isNearGrabbable = true;
        const children = ownerNode.getChildMeshes();
        for (const m of children) {
          m.isNearGrabbable = true;
        }
        this._virtualTransformNode = new TransformNode("virtual_sixDof", BaseSixDofDragBehavior._VirtualScene);
        this._virtualTransformNode.rotationQuaternion = Quaternion.Identity();
        this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {
          if (this.currentDraggingPointerIds.length === 1 && this._moving && !this.disableMovement) {
            const deltaToAdd = TmpVectors.Vector3[0];
            deltaToAdd.copyFrom(this._targetPosition).subtractInPlace(ownerNode.absolutePosition).scaleInPlace(this.dragDeltaRatio);
            const deltaToAddTransformed = TmpVectors.Vector3[1];
            deltaToAddTransformed.copyFrom(deltaToAdd);
            if (ownerNode.parent) {
              const parentRotationMatrixInverse = TmpVectors.Matrix[0];
              ownerNode.parent.absoluteRotationQuaternion.toRotationMatrix(parentRotationMatrixInverse);
              parentRotationMatrixInverse.invert();
              Vector3.TransformNormalToRef(deltaToAdd, parentRotationMatrixInverse, deltaToAddTransformed);
            }
            ownerNode.position.addInPlace(deltaToAddTransformed);
            this.onPositionChangedObservable.notifyObservers({ position: ownerNode.absolutePosition });
            if (!ownerNode.parent || ownerNode.parent.scaling && !ownerNode.parent.scaling.isNonUniformWithinEpsilon(1e-3)) {
              const rotationToApply = TmpVectors.Quaternion[0];
              rotationToApply.copyFrom(this._targetOrientation);
              if (ownerNode.parent) {
                const parentRotationInverse = TmpVectors.Quaternion[0];
                parentRotationInverse.copyFrom(ownerNode.parent.absoluteRotationQuaternion);
                parentRotationInverse.invertInPlace();
                parentRotationInverse.multiplyToRef(this._targetOrientation, rotationToApply);
              }
              Quaternion.SlerpToRef(ownerNode.rotationQuaternion, rotationToApply, this.dragDeltaRatio, ownerNode.rotationQuaternion);
            }
          }
        });
      }
      _getPositionOffsetAround(transformationLocalOrigin, scaling, rotation) {
        const translationMatrix = TmpVectors.Matrix[0];
        const translationMatrixInv = TmpVectors.Matrix[1];
        const rotationMatrix = TmpVectors.Matrix[2];
        const scaleMatrix = TmpVectors.Matrix[3];
        const finalMatrix = TmpVectors.Matrix[4];
        Matrix.TranslationToRef(transformationLocalOrigin.x, transformationLocalOrigin.y, transformationLocalOrigin.z, translationMatrix);
        Matrix.TranslationToRef(-transformationLocalOrigin.x, -transformationLocalOrigin.y, -transformationLocalOrigin.z, translationMatrixInv);
        Matrix.FromQuaternionToRef(rotation, rotationMatrix);
        Matrix.ScalingToRef(scaling, scaling, scaling, scaleMatrix);
        translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix);
        finalMatrix.multiplyToRef(scaleMatrix, finalMatrix);
        finalMatrix.multiplyToRef(translationMatrix, finalMatrix);
        return finalMatrix.getTranslation();
      }
      _onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation) {
        const pointerDelta = TmpVectors.Vector3[0];
        pointerDelta.setAll(0);
        if (this._dragging === this._dragType.DRAG) {
          if (this.rotateDraggedObject) {
            if (this.rotateAroundYOnly) {
              Quaternion.RotationYawPitchRollToRef(worldDeltaRotation.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);
            } else {
              TmpVectors.Quaternion[0].copyFrom(worldDeltaRotation);
            }
            TmpVectors.Quaternion[0].multiplyToRef(this._startingOrientation, this._targetOrientation);
          }
        } else if (this._dragging === this._dragType.NEAR_DRAG || this._dragging === this._dragType.DRAG_WITH_CONTROLLER && this.rotateWithMotionController) {
          worldDeltaRotation.multiplyToRef(this._startingOrientation, this._targetOrientation);
        }
        this._targetPosition.copyFrom(this._startingPosition).addInPlace(worldDeltaPosition);
      }
      _twoPointersPositionUpdated() {
        const startingPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].startingPosition;
        const startingPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].startingPosition;
        const startingCenter = TmpVectors.Vector3[0];
        startingPosition0.addToRef(startingPosition1, startingCenter);
        startingCenter.scaleInPlace(0.5);
        const startingVector = TmpVectors.Vector3[1];
        startingPosition1.subtractToRef(startingPosition0, startingVector);
        const currentPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].dragMesh.absolutePosition;
        const currentPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].dragMesh.absolutePosition;
        const currentCenter = TmpVectors.Vector3[2];
        currentPosition0.addToRef(currentPosition1, currentCenter);
        currentCenter.scaleInPlace(0.5);
        const currentVector = TmpVectors.Vector3[3];
        currentPosition1.subtractToRef(currentPosition0, currentVector);
        const scaling = currentVector.length() / startingVector.length();
        const translation = currentCenter.subtract(startingCenter);
        const rotationQuaternion = Quaternion.FromEulerAngles(0, Vector3.GetAngleBetweenVectorsOnPlane(startingVector.normalize(), currentVector.normalize(), Vector3.UpReadOnly), 0);
        const oldParent = this._ownerNode.parent;
        this._ownerNode.setParent(null);
        const positionOffset = this._getPositionOffsetAround(startingCenter.subtract(this._virtualTransformNode.getAbsolutePivotPoint()), scaling, rotationQuaternion);
        this._virtualTransformNode.rotationQuaternion.multiplyToRef(rotationQuaternion, this._ownerNode.rotationQuaternion);
        this._virtualTransformNode.scaling.scaleToRef(scaling, this._ownerNode.scaling);
        this._virtualTransformNode.position.addToRef(translation.addInPlace(positionOffset), this._ownerNode.position);
        this.onPositionChangedObservable.notifyObservers({ position: this._ownerNode.position });
        this._ownerNode.setParent(oldParent);
      }
      _targetDragStart() {
        const pointerCount = this.currentDraggingPointerIds.length;
        if (!this._ownerNode.rotationQuaternion) {
          this._ownerNode.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ownerNode.rotation.y, this._ownerNode.rotation.x, this._ownerNode.rotation.z);
        }
        const worldPivot = this._ownerNode.getAbsolutePivotPoint();
        if (pointerCount === 1) {
          this._targetPosition.copyFrom(this._ownerNode.absolutePosition);
          this._targetOrientation.copyFrom(this._ownerNode.rotationQuaternion);
          this._targetScaling.copyFrom(this._ownerNode.absoluteScaling);
          if (this.faceCameraOnDragStart && this._scene.activeCamera) {
            const toCamera = TmpVectors.Vector3[0];
            this._scene.activeCamera.position.subtractToRef(worldPivot, toCamera);
            toCamera.normalize();
            const quat = TmpVectors.Quaternion[0];
            if (this._scene.useRightHandedSystem) {
              Quaternion.FromLookDirectionRHToRef(toCamera, new Vector3(0, 1, 0), quat);
            } else {
              Quaternion.FromLookDirectionLHToRef(toCamera, new Vector3(0, 1, 0), quat);
            }
            quat.normalize();
            Quaternion.RotationYawPitchRollToRef(quat.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);
            this._targetOrientation.copyFrom(TmpVectors.Quaternion[0]);
          }
          this._startingPosition.copyFrom(this._targetPosition);
          this._startingOrientation.copyFrom(this._targetOrientation);
          this._startingScaling.copyFrom(this._targetScaling);
        } else if (pointerCount === 2) {
          this._virtualTransformNode.setPivotPoint(
            new Vector3(0, 0, 0),
            0
            /* Space.LOCAL */
          );
          this._virtualTransformNode.position.copyFrom(this._ownerNode.absolutePosition);
          this._virtualTransformNode.scaling.copyFrom(this._ownerNode.absoluteScaling);
          this._virtualTransformNode.rotationQuaternion.copyFrom(this._ownerNode.absoluteRotationQuaternion);
          this._virtualTransformNode.setPivotPoint(
            worldPivot,
            1
            /* Space.WORLD */
          );
          this._resetVirtualMeshesPosition();
        }
      }
      _targetDrag(worldDeltaPosition, worldDeltaRotation) {
        if (this.currentDraggingPointerIds.length === 1) {
          this._onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation);
        } else if (this.currentDraggingPointerIds.length === 2) {
          this._twoPointersPositionUpdated();
        }
      }
      _targetDragEnd() {
        if (this.currentDraggingPointerIds.length === 1) {
          this._resetVirtualMeshesPosition();
          const previousFaceCameraFlag = this.faceCameraOnDragStart;
          this.faceCameraOnDragStart = false;
          this._targetDragStart();
          this.faceCameraOnDragStart = previousFaceCameraFlag;
        }
      }
      /**
       *  Detaches the behavior from the mesh
       */
      detach() {
        if (this._ownerNode) {
          this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);
        }
        if (this._virtualTransformNode) {
          this._virtualTransformNode.dispose();
        }
        super.detach();
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraMouseWheelInput.js
var BaseCameraMouseWheelInput;
var init_BaseCameraMouseWheelInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraMouseWheelInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_observable();
    init_pointerEvents();
    init_deviceInputEvents();
    init_tools();
    BaseCameraMouseWheelInput = class {
      constructor() {
        this.wheelPrecisionX = 3;
        this.wheelPrecisionY = 3;
        this.wheelPrecisionZ = 3;
        this.onChangedObservable = new Observable();
        this._wheelDeltaX = 0;
        this._wheelDeltaY = 0;
        this._wheelDeltaZ = 0;
        this._ffMultiplier = 12;
        this._normalize = 120;
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       * @param noPreventDefault Defines whether event caught by the controls
       *   should call preventdefault().
       *   (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        this._wheel = (pointer) => {
          if (pointer.type !== PointerEventTypes.POINTERWHEEL) {
            return;
          }
          const event = pointer.event;
          const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? this._ffMultiplier : 1;
          this._wheelDeltaX += this.wheelPrecisionX * platformScale * event.deltaX / this._normalize;
          this._wheelDeltaY -= this.wheelPrecisionY * platformScale * event.deltaY / this._normalize;
          this._wheelDeltaZ += this.wheelPrecisionZ * platformScale * event.deltaZ / this._normalize;
          if (event.preventDefault) {
            if (!noPreventDefault) {
              event.preventDefault();
            }
          }
        };
        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        if (this._observer) {
          this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
          this._observer = null;
          this._wheel = null;
        }
        if (this.onChangedObservable) {
          this.onChangedObservable.clear();
        }
      }
      /**
       * Called for each rendered frame.
       */
      checkInputs() {
        this.onChangedObservable.notifyObservers({
          wheelDeltaX: this._wheelDeltaX,
          wheelDeltaY: this._wheelDeltaY,
          wheelDeltaZ: this._wheelDeltaZ
        });
        this._wheelDeltaX = 0;
        this._wheelDeltaY = 0;
        this._wheelDeltaZ = 0;
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "BaseCameraMouseWheelInput";
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "mousewheel";
      }
    };
    __decorate([
      serialize()
    ], BaseCameraMouseWheelInput.prototype, "wheelPrecisionX", void 0);
    __decorate([
      serialize()
    ], BaseCameraMouseWheelInput.prototype, "wheelPrecisionY", void 0);
    __decorate([
      serialize()
    ], BaseCameraMouseWheelInput.prototype, "wheelPrecisionZ", void 0);
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraPointersInput.js
var BaseCameraPointersInput;
var init_BaseCameraPointersInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraPointersInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_tools();
    init_pointerEvents();
    BaseCameraPointersInput = class {
      constructor() {
        this._currentMousePointerIdDown = -1;
        this.buttons = [0, 1, 2];
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        const engine = this.camera.getEngine();
        const element = engine.getInputElement();
        let previousPinchSquaredDistance = 0;
        let previousMultiTouchPanPosition = null;
        this._pointA = null;
        this._pointB = null;
        this._altKey = false;
        this._ctrlKey = false;
        this._metaKey = false;
        this._shiftKey = false;
        this._buttonsPressed = 0;
        this._pointerInput = (p) => {
          const evt = p.event;
          const isTouch = evt.pointerType === "touch";
          if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {
            return;
          }
          const srcElement = evt.target;
          this._altKey = evt.altKey;
          this._ctrlKey = evt.ctrlKey;
          this._metaKey = evt.metaKey;
          this._shiftKey = evt.shiftKey;
          this._buttonsPressed = evt.buttons;
          if (engine.isPointerLock) {
            const offsetX = evt.movementX;
            const offsetY = evt.movementY;
            this.onTouch(null, offsetX, offsetY);
            this._pointA = null;
            this._pointB = null;
          } else if (p.type !== PointerEventTypes.POINTERDOWN && p.type !== PointerEventTypes.POINTERDOUBLETAP && isTouch && this._pointA?.pointerId !== evt.pointerId && this._pointB?.pointerId !== evt.pointerId) {
            return;
          } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentMousePointerIdDown === -1 || isTouch)) {
            try {
              srcElement?.setPointerCapture(evt.pointerId);
            } catch (e) {
            }
            if (this._pointA === null) {
              this._pointA = {
                x: evt.clientX,
                y: evt.clientY,
                pointerId: evt.pointerId,
                type: evt.pointerType,
                button: evt.button
              };
            } else if (this._pointB === null) {
              this._pointB = {
                x: evt.clientX,
                y: evt.clientY,
                pointerId: evt.pointerId,
                type: evt.pointerType,
                button: evt.button
              };
            } else {
              return;
            }
            if (this._currentMousePointerIdDown === -1 && !isTouch) {
              this._currentMousePointerIdDown = evt.pointerId;
            }
            this.onButtonDown(evt);
            if (!noPreventDefault) {
              evt.preventDefault();
              if (element) {
                element.focus();
              }
            }
          } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {
            this.onDoubleTap(evt.pointerType);
          } else if (p.type === PointerEventTypes.POINTERUP && (this._currentMousePointerIdDown === evt.pointerId || isTouch)) {
            try {
              srcElement?.releasePointerCapture(evt.pointerId);
            } catch (e) {
            }
            if (!isTouch) {
              this._pointB = null;
            }
            if (engine._badOS) {
              this._pointA = this._pointB = null;
            } else {
              if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {
                this._pointA = this._pointB;
                this._pointB = null;
              } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {
                this._pointB = null;
              } else {
                this._pointA = this._pointB = null;
              }
            }
            if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {
              this.onMultiTouch(
                this._pointA,
                this._pointB,
                previousPinchSquaredDistance,
                0,
                // pinchSquaredDistance
                previousMultiTouchPanPosition,
                null
                // multiTouchPanPosition
              );
              previousPinchSquaredDistance = 0;
              previousMultiTouchPanPosition = null;
            }
            this._currentMousePointerIdDown = -1;
            this.onButtonUp(evt);
            if (!noPreventDefault) {
              evt.preventDefault();
            }
          } else if (p.type === PointerEventTypes.POINTERMOVE) {
            if (!noPreventDefault) {
              evt.preventDefault();
            }
            if (this._pointA && this._pointB === null) {
              const offsetX = evt.clientX - this._pointA.x;
              const offsetY = evt.clientY - this._pointA.y;
              this._pointA.x = evt.clientX;
              this._pointA.y = evt.clientY;
              this.onTouch(this._pointA, offsetX, offsetY);
            } else if (this._pointA && this._pointB) {
              const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;
              ed.x = evt.clientX;
              ed.y = evt.clientY;
              const distX = this._pointA.x - this._pointB.x;
              const distY = this._pointA.y - this._pointB.y;
              const pinchSquaredDistance = distX * distX + distY * distY;
              const multiTouchPanPosition = {
                x: (this._pointA.x + this._pointB.x) / 2,
                y: (this._pointA.y + this._pointB.y) / 2,
                pointerId: evt.pointerId,
                type: p.type
              };
              this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);
              previousMultiTouchPanPosition = multiTouchPanPosition;
              previousPinchSquaredDistance = pinchSquaredDistance;
            }
          }
        };
        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP);
        this._onLostFocus = () => {
          this._pointA = this._pointB = null;
          previousPinchSquaredDistance = 0;
          previousMultiTouchPanPosition = null;
          this.onLostFocus();
        };
        this._contextMenuBind = (evt) => this.onContextMenu(evt);
        if (element) {
          element.addEventListener("contextmenu", this._contextMenuBind, false);
        }
        const hostWindow = this.camera.getScene().getEngine().getHostWindow();
        if (hostWindow) {
          Tools.RegisterTopRootEvents(hostWindow, [{ name: "blur", handler: this._onLostFocus }]);
        }
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        if (this._onLostFocus) {
          const hostWindow = this.camera.getScene().getEngine().getHostWindow();
          if (hostWindow) {
            Tools.UnregisterTopRootEvents(hostWindow, [{ name: "blur", handler: this._onLostFocus }]);
          }
        }
        if (this._observer) {
          this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
          this._observer = null;
          if (this._contextMenuBind) {
            const inputElement = this.camera.getScene().getEngine().getInputElement();
            if (inputElement) {
              inputElement.removeEventListener("contextmenu", this._contextMenuBind);
            }
          }
          this._onLostFocus = null;
        }
        this._altKey = false;
        this._ctrlKey = false;
        this._metaKey = false;
        this._shiftKey = false;
        this._buttonsPressed = 0;
        this._currentMousePointerIdDown = -1;
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "BaseCameraPointersInput";
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "pointers";
      }
      /**
       * Called on pointer POINTERDOUBLETAP event.
       * Override this method to provide functionality on POINTERDOUBLETAP event.
       * @param type type of event
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onDoubleTap(type) {
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      /**
       * Called on pointer POINTERMOVE event if only a single touch is active.
       * Override this method to provide functionality.
       * @param point The current position of the pointer
       * @param offsetX The offsetX of the pointer when the event occurred
       * @param offsetY The offsetY of the pointer when the event occurred
       */
      onTouch(point, offsetX, offsetY) {
      }
      /**
       * Called on pointer POINTERMOVE event if multiple touches are active.
       * Override this method to provide functionality.
       * @param _pointA First point in the pair
       * @param _pointB Second point in the pair
       * @param previousPinchSquaredDistance Sqr Distance between the points the last time this event was fired (by this input)
       * @param pinchSquaredDistance Sqr Distance between the points this time
       * @param previousMultiTouchPanPosition Previous center point between the points
       * @param multiTouchPanPosition Current center point between the points
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onMultiTouch(_pointA, _pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
      }
      /**
       * Called on JS contextmenu event.
       * Override this method to provide functionality.
       * @param evt the event to be handled
       */
      onContextMenu(evt) {
        evt.preventDefault();
      }
      /**
       * Called each time a new POINTERDOWN event occurs. Ie, for each button
       * press.
       * Override this method to provide functionality.
       * @param _evt Defines the event to track
       */
      onButtonDown(_evt) {
      }
      /**
       * Called each time a new POINTERUP event occurs. Ie, for each button
       * release.
       * Override this method to provide functionality.
       * @param _evt Defines the event to track
       */
      onButtonUp(_evt) {
      }
      /**
       * Called when window becomes inactive.
       * Override this method to provide functionality.
       */
      onLostFocus() {
      }
    };
    __decorate([
      serialize()
    ], BaseCameraPointersInput.prototype, "buttons", void 0);
  }
});

// node_modules/@babylonjs/core/Cameras/cameraInputsManager.js
var CameraInputTypes, CameraInputsManager;
var init_cameraInputsManager = __esm({
  "node_modules/@babylonjs/core/Cameras/cameraInputsManager.js"() {
    init_logger();
    init_decorators_serialization();
    init_camera();
    CameraInputTypes = {};
    CameraInputsManager = class {
      /**
       * Instantiate a new Camera Input Manager.
       * @param camera Defines the camera the input manager belongs to
       */
      constructor(camera) {
        this.attachedToElement = false;
        this.attached = {};
        this.camera = camera;
        this.checkInputs = () => {
        };
      }
      /**
       * Add an input method to a camera
       * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs
       * @param input Camera input method
       */
      add(input) {
        const type = input.getSimpleName();
        if (this.attached[type]) {
          Logger.Warn("camera input of type " + type + " already exists on camera");
          return;
        }
        this.attached[type] = input;
        input.camera = this.camera;
        if (input.checkInputs) {
          this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));
        }
        if (this.attachedToElement) {
          input.attachControl(this.noPreventDefault);
        }
      }
      /**
       * Remove a specific input method from a camera
       * example: camera.inputs.remove(camera.inputs.attached.mouse);
       * @param inputToRemove camera input method
       */
      remove(inputToRemove) {
        for (const cam in this.attached) {
          const input = this.attached[cam];
          if (input === inputToRemove) {
            input.detachControl();
            input.camera = null;
            delete this.attached[cam];
            this.rebuildInputCheck();
            return;
          }
        }
      }
      /**
       * Remove a specific input type from a camera
       * example: camera.inputs.remove("ArcRotateCameraGamepadInput");
       * @param inputType the type of the input to remove
       */
      removeByType(inputType) {
        for (const cam in this.attached) {
          const input = this.attached[cam];
          if (input.getClassName() === inputType) {
            input.detachControl();
            input.camera = null;
            delete this.attached[cam];
            this.rebuildInputCheck();
          }
        }
      }
      _addCheckInputs(fn) {
        const current = this.checkInputs;
        return () => {
          current();
          fn();
        };
      }
      /**
       * Attach the input controls to the currently attached dom element to listen the events from.
       * @param input Defines the input to attach
       */
      attachInput(input) {
        if (this.attachedToElement) {
          input.attachControl(this.noPreventDefault);
        }
      }
      /**
       * Attach the current manager inputs controls to a specific dom element to listen the events from.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachElement(noPreventDefault = false) {
        if (this.attachedToElement) {
          return;
        }
        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;
        this.attachedToElement = true;
        this.noPreventDefault = noPreventDefault;
        for (const cam in this.attached) {
          this.attached[cam].attachControl(noPreventDefault);
        }
      }
      /**
       * Detach the current manager inputs controls from a specific dom element.
       * @param disconnect Defines whether the input should be removed from the current list of attached inputs
       */
      detachElement(disconnect = false) {
        for (const cam in this.attached) {
          this.attached[cam].detachControl();
          if (disconnect) {
            this.attached[cam].camera = null;
          }
        }
        this.attachedToElement = false;
      }
      /**
       * Rebuild the dynamic inputCheck function from the current list of
       * defined inputs in the manager.
       */
      rebuildInputCheck() {
        this.checkInputs = () => {
        };
        for (const cam in this.attached) {
          const input = this.attached[cam];
          if (input.checkInputs) {
            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));
          }
        }
      }
      /**
       * Remove all attached input methods from a camera
       */
      clear() {
        if (this.attachedToElement) {
          this.detachElement(true);
        }
        this.attached = {};
        this.attachedToElement = false;
        this.checkInputs = () => {
        };
      }
      /**
       * Serialize the current input manager attached to a camera.
       * This ensures than once parsed,
       * the input associated to the camera will be identical to the current ones
       * @param serializedCamera Defines the camera serialization JSON the input serialization should write to
       */
      serialize(serializedCamera) {
        const inputs = {};
        for (const cam in this.attached) {
          const input = this.attached[cam];
          const res = SerializationHelper.Serialize(input);
          inputs[input.getClassName()] = res;
        }
        serializedCamera.inputsmgr = inputs;
      }
      /**
       * Parses an input manager serialized JSON to restore the previous list of inputs
       * and states associated to a camera.
       * @param parsedCamera Defines the JSON to parse
       */
      parse(parsedCamera) {
        const parsedInputs = parsedCamera.inputsmgr;
        if (parsedInputs) {
          this.clear();
          for (const n in parsedInputs) {
            const construct = CameraInputTypes[n];
            if (construct) {
              const parsedinput = parsedInputs[n];
              const input = SerializationHelper.Parse(() => {
                return new construct();
              }, parsedinput, null);
              this.add(input);
            }
          }
        } else {
          for (const n in this.attached) {
            const construct = CameraInputTypes[this.attached[n].getClassName()];
            if (construct) {
              const input = SerializationHelper.Parse(() => {
                return new construct();
              }, parsedCamera, null);
              this.remove(this.attached[n]);
              this.add(input);
            }
          }
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraKeyboardMoveInput.js
var ArcRotateCameraKeyboardMoveInput;
var init_arcRotateCameraKeyboardMoveInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraKeyboardMoveInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_keyboardEvents();
    init_tools();
    ArcRotateCameraKeyboardMoveInput = class {
      constructor() {
        this.keysUp = [38];
        this.keysDown = [40];
        this.keysLeft = [37];
        this.keysRight = [39];
        this.keysReset = [220];
        this.panningSensibility = 50;
        this.zoomingSensibility = 25;
        this.useAltToZoom = true;
        this.angularSpeed = 0.01;
        this._keys = new Array();
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        if (this._onCanvasBlurObserver) {
          return;
        }
        this._scene = this.camera.getScene();
        this._engine = this._scene.getEngine();
        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {
          this._keys.length = 0;
        });
        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {
          const evt = info.event;
          if (!evt.metaKey) {
            if (info.type === KeyboardEventTypes.KEYDOWN) {
              this._ctrlPressed = evt.ctrlKey;
              this._altPressed = evt.altKey;
              if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysReset.indexOf(evt.keyCode) !== -1) {
                const index = this._keys.indexOf(evt.keyCode);
                if (index === -1) {
                  this._keys.push(evt.keyCode);
                }
                if (evt.preventDefault) {
                  if (!noPreventDefault) {
                    evt.preventDefault();
                  }
                }
              }
            } else {
              if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysReset.indexOf(evt.keyCode) !== -1) {
                const index = this._keys.indexOf(evt.keyCode);
                if (index >= 0) {
                  this._keys.splice(index, 1);
                }
                if (evt.preventDefault) {
                  if (!noPreventDefault) {
                    evt.preventDefault();
                  }
                }
              }
            }
          }
        });
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        if (this._scene) {
          if (this._onKeyboardObserver) {
            this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
          }
          if (this._onCanvasBlurObserver) {
            this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
          }
          this._onKeyboardObserver = null;
          this._onCanvasBlurObserver = null;
        }
        this._keys.length = 0;
      }
      /**
       * Update the current camera state depending on the inputs that have been used this frame.
       * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
       */
      checkInputs() {
        if (this._onKeyboardObserver) {
          const camera = this.camera;
          for (let index = 0; index < this._keys.length; index++) {
            const keyCode = this._keys[index];
            if (this.keysLeft.indexOf(keyCode) !== -1) {
              if (this._ctrlPressed && this.camera._useCtrlForPanning) {
                camera.inertialPanningX -= 1 / this.panningSensibility;
              } else {
                camera.inertialAlphaOffset -= this.angularSpeed;
              }
            } else if (this.keysUp.indexOf(keyCode) !== -1) {
              if (this._ctrlPressed && this.camera._useCtrlForPanning) {
                camera.inertialPanningY += 1 / this.panningSensibility;
              } else if (this._altPressed && this.useAltToZoom) {
                camera.inertialRadiusOffset += 1 / this.zoomingSensibility;
              } else {
                camera.inertialBetaOffset -= this.angularSpeed;
              }
            } else if (this.keysRight.indexOf(keyCode) !== -1) {
              if (this._ctrlPressed && this.camera._useCtrlForPanning) {
                camera.inertialPanningX += 1 / this.panningSensibility;
              } else {
                camera.inertialAlphaOffset += this.angularSpeed;
              }
            } else if (this.keysDown.indexOf(keyCode) !== -1) {
              if (this._ctrlPressed && this.camera._useCtrlForPanning) {
                camera.inertialPanningY -= 1 / this.panningSensibility;
              } else if (this._altPressed && this.useAltToZoom) {
                camera.inertialRadiusOffset -= 1 / this.zoomingSensibility;
              } else {
                camera.inertialBetaOffset += this.angularSpeed;
              }
            } else if (this.keysReset.indexOf(keyCode) !== -1) {
              if (camera.useInputToRestoreState) {
                camera.restoreState();
              }
            }
          }
        }
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "ArcRotateCameraKeyboardMoveInput";
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "keyboard";
      }
    };
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "keysUp", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "keysDown", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "keysLeft", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "keysRight", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "keysReset", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "panningSensibility", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "zoomingSensibility", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "useAltToZoom", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraKeyboardMoveInput.prototype, "angularSpeed", void 0);
    CameraInputTypes["ArcRotateCameraKeyboardMoveInput"] = ArcRotateCameraKeyboardMoveInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraMouseWheelInput.js
var FfMultiplier, ArcRotateCameraMouseWheelInput;
var init_arcRotateCameraMouseWheelInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraMouseWheelInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_pointerEvents();
    init_math_plane();
    init_math_vector();
    init_math_constants();
    init_deviceInputEvents();
    init_math_scalar_functions();
    init_tools();
    FfMultiplier = 40;
    ArcRotateCameraMouseWheelInput = class {
      constructor() {
        this.wheelPrecision = 3;
        this.zoomToMouseLocation = false;
        this.wheelDeltaPercentage = 0;
        this.customComputeDeltaFromMouseWheel = null;
        this._viewOffset = new Vector3(0, 0, 0);
        this._globalOffset = new Vector3(0, 0, 0);
        this._inertialPanning = Vector3.Zero();
      }
      _computeDeltaFromMouseWheelLegacyEvent(mouseWheelDelta, radius) {
        let delta = 0;
        const wheelDelta = mouseWheelDelta * 0.01 * this.wheelDeltaPercentage * radius;
        if (mouseWheelDelta > 0) {
          delta = wheelDelta / (1 + this.wheelDeltaPercentage);
        } else {
          delta = wheelDelta * (1 + this.wheelDeltaPercentage);
        }
        return delta;
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        this._wheel = (p) => {
          if (p.type !== PointerEventTypes.POINTERWHEEL) {
            return;
          }
          const event = p.event;
          let delta = 0;
          const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? FfMultiplier : 1;
          const wheelDelta = -(event.deltaY * platformScale);
          if (this.customComputeDeltaFromMouseWheel) {
            delta = this.customComputeDeltaFromMouseWheel(wheelDelta, this, event);
          } else {
            if (this.wheelDeltaPercentage) {
              delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, this.camera.radius);
              if (delta > 0) {
                let estimatedTargetRadius = this.camera.radius;
                let targetInertia = this.camera.inertialRadiusOffset + delta;
                for (let i = 0; i < 20; i++) {
                  if (estimatedTargetRadius <= targetInertia) {
                    break;
                  }
                  if (Math.abs(targetInertia * this.camera.inertia) < 1e-3) {
                    break;
                  }
                  estimatedTargetRadius -= targetInertia;
                  targetInertia *= this.camera.inertia;
                }
                estimatedTargetRadius = Clamp(estimatedTargetRadius, 0, Number.MAX_VALUE);
                delta = this._computeDeltaFromMouseWheelLegacyEvent(wheelDelta, estimatedTargetRadius);
              }
            } else {
              delta = wheelDelta / (this.wheelPrecision * 40);
            }
          }
          if (delta) {
            if (this.zoomToMouseLocation) {
              if (!this._hitPlane) {
                this._updateHitPlane();
              }
              this._zoomToMouse(delta);
            } else {
              this.camera.inertialRadiusOffset += delta;
            }
          }
          if (event.preventDefault) {
            if (!noPreventDefault) {
              event.preventDefault();
            }
          }
        };
        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);
        if (this.zoomToMouseLocation) {
          this._inertialPanning.setAll(0);
        }
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        if (this._observer) {
          this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
          this._observer = null;
          this._wheel = null;
        }
      }
      /**
       * Update the current camera state depending on the inputs that have been used this frame.
       * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
       */
      checkInputs() {
        if (!this.zoomToMouseLocation) {
          return;
        }
        const camera = this.camera;
        const motion = 0 + camera.inertialAlphaOffset + camera.inertialBetaOffset + camera.inertialRadiusOffset;
        if (motion) {
          this._updateHitPlane();
          camera.target.addInPlace(this._inertialPanning);
          this._inertialPanning.scaleInPlace(camera.inertia);
          this._zeroIfClose(this._inertialPanning);
        }
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "ArcRotateCameraMouseWheelInput";
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "mousewheel";
      }
      _updateHitPlane() {
        const camera = this.camera;
        const direction = camera.target.subtract(camera.position);
        this._hitPlane = Plane.FromPositionAndNormal(camera.target, direction);
      }
      // Get position on the hit plane
      _getPosition() {
        const camera = this.camera;
        const scene = camera.getScene();
        const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, Matrix.Identity(), camera, false);
        if (camera.targetScreenOffset.x !== 0 || camera.targetScreenOffset.y !== 0) {
          this._viewOffset.set(camera.targetScreenOffset.x, camera.targetScreenOffset.y, 0);
          camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);
          this._globalOffset = Vector3.TransformNormal(this._viewOffset, camera._cameraTransformMatrix);
          ray.origin.addInPlace(this._globalOffset);
        }
        let distance = 0;
        if (this._hitPlane) {
          distance = ray.intersectsPlane(this._hitPlane) ?? 0;
        }
        return ray.origin.addInPlace(ray.direction.scaleInPlace(distance));
      }
      _zoomToMouse(delta) {
        const camera = this.camera;
        const inertiaComp = 1 - camera.inertia;
        if (camera.lowerRadiusLimit) {
          const lowerLimit = camera.lowerRadiusLimit ?? 0;
          if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp < lowerLimit) {
            delta = (camera.radius - lowerLimit) * inertiaComp - camera.inertialRadiusOffset;
          }
        }
        if (camera.upperRadiusLimit) {
          const upperLimit = camera.upperRadiusLimit ?? 0;
          if (camera.radius - (camera.inertialRadiusOffset + delta) / inertiaComp > upperLimit) {
            delta = (camera.radius - upperLimit) * inertiaComp - camera.inertialRadiusOffset;
          }
        }
        const zoomDistance = delta / inertiaComp;
        const ratio = zoomDistance / camera.radius;
        const vec = this._getPosition();
        const directionToZoomLocation = TmpVectors.Vector3[6];
        vec.subtractToRef(camera.target, directionToZoomLocation);
        directionToZoomLocation.scaleInPlace(ratio);
        directionToZoomLocation.scaleInPlace(inertiaComp);
        this._inertialPanning.addInPlace(directionToZoomLocation);
        camera.inertialRadiusOffset += delta;
      }
      // Sets x y or z of passed in vector to zero if less than Epsilon.
      _zeroIfClose(vec) {
        if (Math.abs(vec.x) < Epsilon) {
          vec.x = 0;
        }
        if (Math.abs(vec.y) < Epsilon) {
          vec.y = 0;
        }
        if (Math.abs(vec.z) < Epsilon) {
          vec.z = 0;
        }
      }
    };
    __decorate([
      serialize()
    ], ArcRotateCameraMouseWheelInput.prototype, "wheelPrecision", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraMouseWheelInput.prototype, "zoomToMouseLocation", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraMouseWheelInput.prototype, "wheelDeltaPercentage", void 0);
    CameraInputTypes["ArcRotateCameraMouseWheelInput"] = ArcRotateCameraMouseWheelInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/orbitCameraPointersInput.js
var OrbitCameraPointersInput;
var init_orbitCameraPointersInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/orbitCameraPointersInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_BaseCameraPointersInput();
    OrbitCameraPointersInput = class extends BaseCameraPointersInput {
      constructor() {
        super(...arguments);
        this.pinchZoom = true;
        this.multiTouchPanning = true;
        this.multiTouchPanAndZoom = true;
        this._isPinching = false;
        this._twoFingerActivityCount = 0;
        this._shouldStartPinchZoom = false;
      }
      _computePinchZoom(_previousPinchSquaredDistance, _pinchSquaredDistance) {
      }
      _computeMultiTouchPanning(_previousMultiTouchPanPosition, _multiTouchPanPosition) {
      }
      /**
       * Called on pointer POINTERMOVE event if multiple touches are active.
       * Override this method to provide functionality.
       * @param _pointA First point in the pair
       * @param _pointB Second point in the pair
       * @param previousPinchSquaredDistance Sqr Distance between the points the last time this event was fired (by this input)
       * @param pinchSquaredDistance Sqr Distance between the points this time
       * @param previousMultiTouchPanPosition Previous center point between the points
       * @param multiTouchPanPosition Current center point between the points
       */
      onMultiTouch(_pointA, _pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {
          return;
        }
        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {
          return;
        }
        if (this.multiTouchPanAndZoom) {
          this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);
          this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);
        } else if (this.multiTouchPanning && this.pinchZoom) {
          this._twoFingerActivityCount++;
          if (this._isPinching || this._shouldStartPinchZoom) {
            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);
            this._isPinching = true;
          } else {
            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);
          }
        } else if (this.multiTouchPanning) {
          this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);
        } else if (this.pinchZoom) {
          this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);
        }
      }
      /**
       * Called each time a new POINTERUP event occurs. Ie, for each button
       * release.
       * @param _evt Defines the event to track
       */
      onButtonUp(_evt) {
        this._twoFingerActivityCount = 0;
        this._isPinching = false;
      }
      /**
       * Called when window becomes inactive.
       */
      onLostFocus() {
        this._twoFingerActivityCount = 0;
        this._isPinching = false;
      }
    };
    __decorate([
      serialize()
    ], OrbitCameraPointersInput.prototype, "pinchZoom", void 0);
    __decorate([
      serialize()
    ], OrbitCameraPointersInput.prototype, "multiTouchPanning", void 0);
    __decorate([
      serialize()
    ], OrbitCameraPointersInput.prototype, "multiTouchPanAndZoom", void 0);
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraPointersInput.js
var ArcRotateCameraPointersInput;
var init_arcRotateCameraPointersInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraPointersInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_orbitCameraPointersInput();
    ArcRotateCameraPointersInput = class _ArcRotateCameraPointersInput extends OrbitCameraPointersInput {
      constructor() {
        super(...arguments);
        this.buttons = [0, 1, 2];
        this.angularSensibilityX = 1e3;
        this.angularSensibilityY = 1e3;
        this.pinchPrecision = 12;
        this.pinchDeltaPercentage = 0;
        this.useNaturalPinchZoom = false;
        this.panningSensibility = 1e3;
        this.pinchInwards = true;
        this._isPanClick = false;
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "ArcRotateCameraPointersInput";
      }
      /**
       * Move camera from multi touch panning positions.
       * @param previousMultiTouchPanPosition
       * @param multiTouchPanPosition
       */
      _computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition) {
        if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {
          const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;
          const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;
          this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;
          this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;
        }
      }
      /**
       * Move camera from multitouch (pinch) zoom distances.
       * @param previousPinchSquaredDistance
       * @param pinchSquaredDistance
       */
      _computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance) {
        const radius = this.camera.radius || _ArcRotateCameraPointersInput.MinimumRadiusForPinch;
        if (this.useNaturalPinchZoom) {
          this.camera.radius = radius * Math.sqrt(previousPinchSquaredDistance) / Math.sqrt(pinchSquaredDistance);
        } else if (this.pinchDeltaPercentage) {
          this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 1e-3 * radius * this.pinchDeltaPercentage;
        } else {
          this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY) / 2);
        }
      }
      /**
       * Called on pointer POINTERMOVE event if only a single touch is active.
       * @param point current touch point
       * @param offsetX offset on X
       * @param offsetY offset on Y
       */
      onTouch(point, offsetX, offsetY) {
        if (this.panningSensibility !== 0 && (this._ctrlKey && this.camera._useCtrlForPanning || this._isPanClick)) {
          this.camera.inertialPanningX += -offsetX / this.panningSensibility;
          this.camera.inertialPanningY += offsetY / this.panningSensibility;
        } else {
          this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;
          this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;
        }
      }
      /**
       * Called on pointer POINTERDOUBLETAP event.
       */
      onDoubleTap() {
        if (this.camera.useInputToRestoreState) {
          this.camera.restoreState();
        }
      }
      /**
       * Called on pointer POINTERMOVE event if multiple touches are active.
       * @param pointA point A
       * @param pointB point B
       * @param previousPinchSquaredDistance distance between points in previous pinch
       * @param pinchSquaredDistance distance between points in current pinch
       * @param previousMultiTouchPanPosition multi-touch position in previous step
       * @param multiTouchPanPosition multi-touch position in current step
       */
      onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
        this._shouldStartPinchZoom = this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance;
        super.onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);
      }
      /**
       * Called each time a new POINTERDOWN event occurs. Ie, for each button
       * press.
       * @param evt Defines the event to track
       */
      onButtonDown(evt) {
        this._isPanClick = evt.button === this.camera._panningMouseButton;
        super.onButtonDown(evt);
      }
      /**
       * Called each time a new POINTERUP event occurs. Ie, for each button
       * release.
       * @param _evt Defines the event to track
       */
      onButtonUp(_evt) {
        super.onButtonUp(_evt);
      }
      /**
       * Called when window becomes inactive.
       */
      onLostFocus() {
        this._isPanClick = false;
        super.onLostFocus();
      }
    };
    ArcRotateCameraPointersInput.MinimumRadiusForPinch = 1e-3;
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "buttons", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "angularSensibilityX", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "angularSensibilityY", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "pinchPrecision", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "pinchDeltaPercentage", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "useNaturalPinchZoom", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraPointersInput.prototype, "panningSensibility", void 0);
    CameraInputTypes["ArcRotateCameraPointersInput"] = ArcRotateCameraPointersInput;
  }
});

// node_modules/@babylonjs/core/Cameras/arcRotateCameraInputsManager.js
var ArcRotateCameraInputsManager;
var init_arcRotateCameraInputsManager = __esm({
  "node_modules/@babylonjs/core/Cameras/arcRotateCameraInputsManager.js"() {
    init_arcRotateCameraPointersInput();
    init_arcRotateCameraKeyboardMoveInput();
    init_arcRotateCameraMouseWheelInput();
    init_cameraInputsManager();
    ArcRotateCameraInputsManager = class extends CameraInputsManager {
      /**
       * Instantiates a new ArcRotateCameraInputsManager.
       * @param camera Defines the camera the inputs belong to
       */
      constructor(camera) {
        super(camera);
      }
      /**
       * Add mouse wheel input support to the input manager.
       * @returns the current input manager
       */
      addMouseWheel() {
        this.add(new ArcRotateCameraMouseWheelInput());
        return this;
      }
      /**
       * Add pointers input support to the input manager.
       * @returns the current input manager
       */
      addPointers() {
        this.add(new ArcRotateCameraPointersInput());
        return this;
      }
      /**
       * Add keyboard input support to the input manager.
       * @returns the current input manager
       */
      addKeyboard() {
        this.add(new ArcRotateCameraKeyboardMoveInput());
        return this;
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/followCameraKeyboardMoveInput.js
var FollowCameraKeyboardMoveInput;
var init_followCameraKeyboardMoveInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/followCameraKeyboardMoveInput.js"() {
    init_tslib_es6();
    init_cameraInputsManager();
    init_decorators();
    init_keyboardEvents();
    init_tools();
    FollowCameraKeyboardMoveInput = class {
      constructor() {
        this.keysHeightOffsetIncr = [38];
        this.keysHeightOffsetDecr = [40];
        this.keysHeightOffsetModifierAlt = false;
        this.keysHeightOffsetModifierCtrl = false;
        this.keysHeightOffsetModifierShift = false;
        this.keysRotationOffsetIncr = [37];
        this.keysRotationOffsetDecr = [39];
        this.keysRotationOffsetModifierAlt = false;
        this.keysRotationOffsetModifierCtrl = false;
        this.keysRotationOffsetModifierShift = false;
        this.keysRadiusIncr = [40];
        this.keysRadiusDecr = [38];
        this.keysRadiusModifierAlt = true;
        this.keysRadiusModifierCtrl = false;
        this.keysRadiusModifierShift = false;
        this.heightSensibility = 1;
        this.rotationSensibility = 1;
        this.radiusSensibility = 1;
        this._keys = new Array();
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        if (this._onCanvasBlurObserver) {
          return;
        }
        this._scene = this.camera.getScene();
        this._engine = this._scene.getEngine();
        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {
          this._keys.length = 0;
        });
        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {
          const evt = info.event;
          if (!evt.metaKey) {
            if (info.type === KeyboardEventTypes.KEYDOWN) {
              this._ctrlPressed = evt.ctrlKey;
              this._altPressed = evt.altKey;
              this._shiftPressed = evt.shiftKey;
              if (this.keysHeightOffsetIncr.indexOf(evt.keyCode) !== -1 || this.keysHeightOffsetDecr.indexOf(evt.keyCode) !== -1 || this.keysRotationOffsetIncr.indexOf(evt.keyCode) !== -1 || this.keysRotationOffsetDecr.indexOf(evt.keyCode) !== -1 || this.keysRadiusIncr.indexOf(evt.keyCode) !== -1 || this.keysRadiusDecr.indexOf(evt.keyCode) !== -1) {
                const index = this._keys.indexOf(evt.keyCode);
                if (index === -1) {
                  this._keys.push(evt.keyCode);
                }
                if (evt.preventDefault) {
                  if (!noPreventDefault) {
                    evt.preventDefault();
                  }
                }
              }
            } else {
              if (this.keysHeightOffsetIncr.indexOf(evt.keyCode) !== -1 || this.keysHeightOffsetDecr.indexOf(evt.keyCode) !== -1 || this.keysRotationOffsetIncr.indexOf(evt.keyCode) !== -1 || this.keysRotationOffsetDecr.indexOf(evt.keyCode) !== -1 || this.keysRadiusIncr.indexOf(evt.keyCode) !== -1 || this.keysRadiusDecr.indexOf(evt.keyCode) !== -1) {
                const index = this._keys.indexOf(evt.keyCode);
                if (index >= 0) {
                  this._keys.splice(index, 1);
                }
                if (evt.preventDefault) {
                  if (!noPreventDefault) {
                    evt.preventDefault();
                  }
                }
              }
            }
          }
        });
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        if (this._scene) {
          if (this._onKeyboardObserver) {
            this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
          }
          if (this._onCanvasBlurObserver) {
            this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
          }
          this._onKeyboardObserver = null;
          this._onCanvasBlurObserver = null;
        }
        this._keys.length = 0;
      }
      /**
       * Update the current camera state depending on the inputs that have been used this frame.
       * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
       */
      checkInputs() {
        if (this._onKeyboardObserver) {
          for (const keyCode of this._keys) {
            if (this.keysHeightOffsetIncr.indexOf(keyCode) !== -1 && this._modifierHeightOffset()) {
              this.camera.heightOffset += this.heightSensibility;
            } else if (this.keysHeightOffsetDecr.indexOf(keyCode) !== -1 && this._modifierHeightOffset()) {
              this.camera.heightOffset -= this.heightSensibility;
            } else if (this.keysRotationOffsetIncr.indexOf(keyCode) !== -1 && this._modifierRotationOffset()) {
              this.camera.rotationOffset += this.rotationSensibility;
              this.camera.rotationOffset %= 360;
            } else if (this.keysRotationOffsetDecr.indexOf(keyCode) !== -1 && this._modifierRotationOffset()) {
              this.camera.rotationOffset -= this.rotationSensibility;
              this.camera.rotationOffset %= 360;
            } else if (this.keysRadiusIncr.indexOf(keyCode) !== -1 && this._modifierRadius()) {
              this.camera.radius += this.radiusSensibility;
            } else if (this.keysRadiusDecr.indexOf(keyCode) !== -1 && this._modifierRadius()) {
              this.camera.radius -= this.radiusSensibility;
            }
          }
        }
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "FollowCameraKeyboardMoveInput";
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "keyboard";
      }
      /**
       * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to
       * allow modification of the heightOffset value.
       * @returns true if modifier keys match
       */
      _modifierHeightOffset() {
        return this.keysHeightOffsetModifierAlt === this._altPressed && this.keysHeightOffsetModifierCtrl === this._ctrlPressed && this.keysHeightOffsetModifierShift === this._shiftPressed;
      }
      /**
       * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to
       * allow modification of the rotationOffset value.
       * @returns true if modifier keys match
       */
      _modifierRotationOffset() {
        return this.keysRotationOffsetModifierAlt === this._altPressed && this.keysRotationOffsetModifierCtrl === this._ctrlPressed && this.keysRotationOffsetModifierShift === this._shiftPressed;
      }
      /**
       * Check if the pressed modifier keys (Alt/Ctrl/Shift) match those configured to
       * allow modification of the radius value.
       * @returns true if modifier keys match
       */
      _modifierRadius() {
        return this.keysRadiusModifierAlt === this._altPressed && this.keysRadiusModifierCtrl === this._ctrlPressed && this.keysRadiusModifierShift === this._shiftPressed;
      }
    };
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysHeightOffsetIncr", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysHeightOffsetDecr", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysHeightOffsetModifierAlt", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysHeightOffsetModifierCtrl", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysHeightOffsetModifierShift", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRotationOffsetIncr", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRotationOffsetDecr", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRotationOffsetModifierAlt", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRotationOffsetModifierCtrl", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRotationOffsetModifierShift", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRadiusIncr", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRadiusDecr", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRadiusModifierAlt", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRadiusModifierCtrl", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "keysRadiusModifierShift", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "heightSensibility", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "rotationSensibility", void 0);
    __decorate([
      serialize()
    ], FollowCameraKeyboardMoveInput.prototype, "radiusSensibility", void 0);
    CameraInputTypes["FollowCameraKeyboardMoveInput"] = FollowCameraKeyboardMoveInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/followCameraMouseWheelInput.js
var FollowCameraMouseWheelInput;
var init_followCameraMouseWheelInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/followCameraMouseWheelInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_pointerEvents();
    init_tools();
    init_logger();
    FollowCameraMouseWheelInput = class {
      constructor() {
        this.axisControlRadius = true;
        this.axisControlHeight = false;
        this.axisControlRotation = false;
        this.wheelPrecision = 3;
        this.wheelDeltaPercentage = 0;
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        this._wheel = (p) => {
          if (p.type !== PointerEventTypes.POINTERWHEEL) {
            return;
          }
          const event = p.event;
          let delta = 0;
          const wheelDelta = Math.max(-1, Math.min(1, event.deltaY));
          if (this.wheelDeltaPercentage) {
            if (+this.axisControlRadius + +this.axisControlHeight + +this.axisControlRotation) {
              Logger.Warn("wheelDeltaPercentage only usable when mouse wheel controls ONE axis. Currently enabled: axisControlRadius: " + this.axisControlRadius + ", axisControlHeightOffset: " + this.axisControlHeight + ", axisControlRotationOffset: " + this.axisControlRotation);
            }
            if (this.axisControlRadius) {
              delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.radius;
            } else if (this.axisControlHeight) {
              delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.heightOffset;
            } else if (this.axisControlRotation) {
              delta = wheelDelta * 0.01 * this.wheelDeltaPercentage * this.camera.rotationOffset;
            }
          } else {
            delta = wheelDelta * this.wheelPrecision;
          }
          if (delta) {
            if (this.axisControlRadius) {
              this.camera.radius += delta;
            } else if (this.axisControlHeight) {
              this.camera.heightOffset -= delta;
            } else if (this.axisControlRotation) {
              this.camera.rotationOffset -= delta;
            }
          }
          if (event.preventDefault) {
            if (!noPreventDefault) {
              event.preventDefault();
            }
          }
        };
        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        if (this._observer) {
          this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
          this._observer = null;
          this._wheel = null;
        }
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "ArcRotateCameraMouseWheelInput";
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "mousewheel";
      }
    };
    __decorate([
      serialize()
    ], FollowCameraMouseWheelInput.prototype, "axisControlRadius", void 0);
    __decorate([
      serialize()
    ], FollowCameraMouseWheelInput.prototype, "axisControlHeight", void 0);
    __decorate([
      serialize()
    ], FollowCameraMouseWheelInput.prototype, "axisControlRotation", void 0);
    __decorate([
      serialize()
    ], FollowCameraMouseWheelInput.prototype, "wheelPrecision", void 0);
    __decorate([
      serialize()
    ], FollowCameraMouseWheelInput.prototype, "wheelDeltaPercentage", void 0);
    CameraInputTypes["FollowCameraMouseWheelInput"] = FollowCameraMouseWheelInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/followCameraPointersInput.js
var FollowCameraPointersInput;
var init_followCameraPointersInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/followCameraPointersInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_BaseCameraPointersInput();
    init_logger();
    FollowCameraPointersInput = class extends BaseCameraPointersInput {
      constructor() {
        super(...arguments);
        this.angularSensibilityX = 1;
        this.angularSensibilityY = 1;
        this.pinchPrecision = 1e4;
        this.pinchDeltaPercentage = 0;
        this.axisXControlRadius = false;
        this.axisXControlHeight = false;
        this.axisXControlRotation = true;
        this.axisYControlRadius = false;
        this.axisYControlHeight = true;
        this.axisYControlRotation = false;
        this.axisPinchControlRadius = true;
        this.axisPinchControlHeight = false;
        this.axisPinchControlRotation = false;
        this.warningEnable = true;
        this._warningCounter = 0;
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "FollowCameraPointersInput";
      }
      onTouch(pointA, offsetX, offsetY) {
        this._warning();
        if (this.axisXControlRotation) {
          this.camera.rotationOffset += offsetX / this.angularSensibilityX;
        } else if (this.axisYControlRotation) {
          this.camera.rotationOffset += offsetY / this.angularSensibilityX;
        }
        if (this.axisXControlHeight) {
          this.camera.heightOffset += offsetX / this.angularSensibilityY;
        } else if (this.axisYControlHeight) {
          this.camera.heightOffset += offsetY / this.angularSensibilityY;
        }
        if (this.axisXControlRadius) {
          this.camera.radius -= offsetX / this.angularSensibilityY;
        } else if (this.axisYControlRadius) {
          this.camera.radius -= offsetY / this.angularSensibilityY;
        }
      }
      onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {
          return;
        }
        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {
          return;
        }
        let pinchDelta = (pinchSquaredDistance - previousPinchSquaredDistance) / (this.pinchPrecision * (this.angularSensibilityX + this.angularSensibilityY) / 2);
        if (this.pinchDeltaPercentage) {
          pinchDelta *= 0.01 * this.pinchDeltaPercentage;
          if (this.axisPinchControlRotation) {
            this.camera.rotationOffset += pinchDelta * this.camera.rotationOffset;
          }
          if (this.axisPinchControlHeight) {
            this.camera.heightOffset += pinchDelta * this.camera.heightOffset;
          }
          if (this.axisPinchControlRadius) {
            this.camera.radius -= pinchDelta * this.camera.radius;
          }
        } else {
          if (this.axisPinchControlRotation) {
            this.camera.rotationOffset += pinchDelta;
          }
          if (this.axisPinchControlHeight) {
            this.camera.heightOffset += pinchDelta;
          }
          if (this.axisPinchControlRadius) {
            this.camera.radius -= pinchDelta;
          }
        }
      }
      _warning() {
        if (!this.warningEnable || this._warningCounter++ % 100 !== 0) {
          return;
        }
        const warn = "It probably only makes sense to control ONE camera property with each pointer axis. Set 'warningEnable = false' if you are sure. Currently enabled: ";
        if (+this.axisXControlRotation + +this.axisXControlHeight + +this.axisXControlRadius <= 1) {
          Logger.Warn(warn + "axisXControlRotation: " + this.axisXControlRotation + ", axisXControlHeight: " + this.axisXControlHeight + ", axisXControlRadius: " + this.axisXControlRadius);
        }
        if (+this.axisYControlRotation + +this.axisYControlHeight + +this.axisYControlRadius <= 1) {
          Logger.Warn(warn + "axisYControlRotation: " + this.axisYControlRotation + ", axisYControlHeight: " + this.axisYControlHeight + ", axisYControlRadius: " + this.axisYControlRadius);
        }
        if (+this.axisPinchControlRotation + +this.axisPinchControlHeight + +this.axisPinchControlRadius <= 1) {
          Logger.Warn(warn + "axisPinchControlRotation: " + this.axisPinchControlRotation + ", axisPinchControlHeight: " + this.axisPinchControlHeight + ", axisPinchControlRadius: " + this.axisPinchControlRadius);
        }
      }
    };
    __decorate([
      serialize()
    ], FollowCameraPointersInput.prototype, "angularSensibilityX", void 0);
    __decorate([
      serialize()
    ], FollowCameraPointersInput.prototype, "angularSensibilityY", void 0);
    __decorate([
      serialize()
    ], FollowCameraPointersInput.prototype, "pinchPrecision", void 0);
    __decorate([
      serialize()
    ], FollowCameraPointersInput.prototype, "pinchDeltaPercentage", void 0);
    __decorate([
      serialize()
    ], FollowCameraPointersInput.prototype, "axisXControlRadius", void 0);
    __decorate([
      serialize()
    ], FollowCameraPointersInput.prototype, "axisXControlHeight", void 0);
    __decorate([
      serialize()
    ], FollowCameraPointersInput.prototype, "axisXControlRotation", void 0);
    __decorate([
      serialize()
    ], FollowCameraPointersInput.prototype, "axisYControlRadius", void 0);
    __decorate([
      serialize()
    ], FollowCameraPointersInput.prototype, "axisYControlHeight", void 0);
    __decorate([
      serialize()
    ], FollowCameraPointersInput.prototype, "axisYControlRotation", void 0);
    __decorate([
      serialize()
    ], FollowCameraPointersInput.prototype, "axisPinchControlRadius", void 0);
    __decorate([
      serialize()
    ], FollowCameraPointersInput.prototype, "axisPinchControlHeight", void 0);
    __decorate([
      serialize()
    ], FollowCameraPointersInput.prototype, "axisPinchControlRotation", void 0);
    CameraInputTypes["FollowCameraPointersInput"] = FollowCameraPointersInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraKeyboardMoveInput.js
var FreeCameraKeyboardMoveInput;
var init_freeCameraKeyboardMoveInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/freeCameraKeyboardMoveInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_keyboardEvents();
    init_math_vector();
    init_tools();
    FreeCameraKeyboardMoveInput = class {
      constructor() {
        this.keysUp = [38];
        this.keysUpward = [33];
        this.keysDown = [40];
        this.keysDownward = [34];
        this.keysLeft = [37];
        this.keysRight = [39];
        this.rotationSpeed = 0.5;
        this.keysRotateLeft = [];
        this.keysRotateRight = [];
        this.keysRotateUp = [];
        this.keysRotateDown = [];
        this._keys = new Array();
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        if (this._onCanvasBlurObserver) {
          return;
        }
        this._scene = this.camera.getScene();
        this._engine = this._scene.getEngine();
        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {
          this._keys.length = 0;
        });
        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {
          const evt = info.event;
          if (!evt.metaKey) {
            if (info.type === KeyboardEventTypes.KEYDOWN) {
              if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysUpward.indexOf(evt.keyCode) !== -1 || this.keysDownward.indexOf(evt.keyCode) !== -1 || this.keysRotateLeft.indexOf(evt.keyCode) !== -1 || this.keysRotateRight.indexOf(evt.keyCode) !== -1 || this.keysRotateUp.indexOf(evt.keyCode) !== -1 || this.keysRotateDown.indexOf(evt.keyCode) !== -1) {
                const index = this._keys.indexOf(evt.keyCode);
                if (index === -1) {
                  this._keys.push(evt.keyCode);
                }
                if (!noPreventDefault) {
                  evt.preventDefault();
                }
              }
            } else {
              if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysUpward.indexOf(evt.keyCode) !== -1 || this.keysDownward.indexOf(evt.keyCode) !== -1 || this.keysRotateLeft.indexOf(evt.keyCode) !== -1 || this.keysRotateRight.indexOf(evt.keyCode) !== -1 || this.keysRotateUp.indexOf(evt.keyCode) !== -1 || this.keysRotateDown.indexOf(evt.keyCode) !== -1) {
                const index = this._keys.indexOf(evt.keyCode);
                if (index >= 0) {
                  this._keys.splice(index, 1);
                }
                if (!noPreventDefault) {
                  evt.preventDefault();
                }
              }
            }
          }
        });
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        if (this._scene) {
          if (this._onKeyboardObserver) {
            this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
          }
          if (this._onCanvasBlurObserver) {
            this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
          }
          this._onKeyboardObserver = null;
          this._onCanvasBlurObserver = null;
        }
        this._keys.length = 0;
      }
      /**
       * Update the current camera state depending on the inputs that have been used this frame.
       * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
       */
      checkInputs() {
        if (this._onKeyboardObserver) {
          const camera = this.camera;
          for (let index = 0; index < this._keys.length; index++) {
            const keyCode = this._keys[index];
            const speed = camera._computeLocalCameraSpeed();
            if (this.keysLeft.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(-speed, 0, 0);
            } else if (this.keysUp.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, speed);
            } else if (this.keysRight.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(speed, 0, 0);
            } else if (this.keysDown.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, -speed);
            } else if (this.keysUpward.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, speed, 0);
            } else if (this.keysDownward.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, -speed, 0);
            } else if (this.keysRotateLeft.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, 0);
              camera.cameraRotation.y -= this._getLocalRotation();
            } else if (this.keysRotateRight.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, 0);
              camera.cameraRotation.y += this._getLocalRotation();
            } else if (this.keysRotateUp.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, 0);
              camera.cameraRotation.x -= this._getLocalRotation();
            } else if (this.keysRotateDown.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, 0);
              camera.cameraRotation.x += this._getLocalRotation();
            }
            if (camera.getScene().useRightHandedSystem) {
              camera._localDirection.z *= -1;
            }
            camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);
            Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);
            camera.cameraDirection.addInPlace(camera._transformedDirection);
          }
        }
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "FreeCameraKeyboardMoveInput";
      }
      /** @internal */
      _onLostFocus() {
        this._keys.length = 0;
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "keyboard";
      }
      _getLocalRotation() {
        const handednessMultiplier = this.camera._calculateHandednessMultiplier();
        const rotation = this.rotationSpeed * this._engine.getDeltaTime() / 1e3 * handednessMultiplier;
        return rotation;
      }
    };
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysUp", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysUpward", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysDown", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysDownward", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysLeft", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysRight", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "rotationSpeed", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysRotateLeft", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysRotateRight", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysRotateUp", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysRotateDown", void 0);
    CameraInputTypes["FreeCameraKeyboardMoveInput"] = FreeCameraKeyboardMoveInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseInput.js
var FreeCameraMouseInput;
var init_freeCameraMouseInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseInput.js"() {
    init_tslib_es6();
    init_observable();
    init_decorators();
    init_cameraInputsManager();
    init_pointerEvents();
    init_tools();
    FreeCameraMouseInput = class {
      /**
       * Manage the mouse inputs to control the movement of a free camera.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs
       * @param touchEnabled Defines if touch is enabled or not
       */
      constructor(touchEnabled = true) {
        this.touchEnabled = touchEnabled;
        this.buttons = [0, 1, 2];
        this.angularSensibility = 2e3;
        this._previousPosition = null;
        this.onPointerMovedObservable = new Observable();
        this._allowCameraRotation = true;
        this._currentActiveButton = -1;
        this._activePointerId = -1;
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        const engine = this.camera.getEngine();
        const element = engine.getInputElement();
        if (!this._pointerInput) {
          this._pointerInput = (p) => {
            const evt = p.event;
            const isTouch = evt.pointerType === "touch";
            if (!this.touchEnabled && isTouch) {
              return;
            }
            if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {
              return;
            }
            const srcElement = evt.target;
            if (p.type === PointerEventTypes.POINTERDOWN) {
              if (isTouch && this._activePointerId !== -1 || !isTouch && this._currentActiveButton !== -1) {
                return;
              }
              this._activePointerId = evt.pointerId;
              try {
                srcElement?.setPointerCapture(evt.pointerId);
              } catch (e) {
              }
              if (this._currentActiveButton === -1) {
                this._currentActiveButton = evt.button;
              }
              this._previousPosition = {
                x: evt.clientX,
                y: evt.clientY
              };
              if (!noPreventDefault) {
                evt.preventDefault();
                if (element) {
                  element.focus();
                }
              }
              if (engine.isPointerLock && this._onMouseMove) {
                this._onMouseMove(p.event);
              }
            } else if (p.type === PointerEventTypes.POINTERUP) {
              if (isTouch && this._activePointerId !== evt.pointerId || !isTouch && this._currentActiveButton !== evt.button) {
                return;
              }
              try {
                srcElement?.releasePointerCapture(evt.pointerId);
              } catch (e) {
              }
              this._currentActiveButton = -1;
              this._previousPosition = null;
              if (!noPreventDefault) {
                evt.preventDefault();
              }
              this._activePointerId = -1;
            } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {
              if (engine.isPointerLock && this._onMouseMove) {
                this._onMouseMove(p.event);
              } else if (this._previousPosition) {
                const handednessMultiplier = this.camera._calculateHandednessMultiplier();
                const offsetX = (evt.clientX - this._previousPosition.x) * handednessMultiplier;
                const offsetY = (evt.clientY - this._previousPosition.y) * handednessMultiplier;
                if (this._allowCameraRotation) {
                  this.camera.cameraRotation.y += offsetX / this.angularSensibility;
                  this.camera.cameraRotation.x += offsetY / this.angularSensibility;
                }
                this.onPointerMovedObservable.notifyObservers({ offsetX, offsetY });
                this._previousPosition = {
                  x: evt.clientX,
                  y: evt.clientY
                };
                if (!noPreventDefault) {
                  evt.preventDefault();
                }
              }
            }
          };
        }
        this._onMouseMove = (evt) => {
          if (!engine.isPointerLock) {
            return;
          }
          const handednessMultiplier = this.camera._calculateHandednessMultiplier();
          this.camera.cameraRotation.y += evt.movementX * handednessMultiplier / this.angularSensibility;
          this.camera.cameraRotation.x += evt.movementY * handednessMultiplier / this.angularSensibility;
          this._previousPosition = null;
          if (!noPreventDefault) {
            evt.preventDefault();
          }
        };
        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
        if (element) {
          this._contextMenuBind = (evt) => this.onContextMenu(evt);
          element.addEventListener("contextmenu", this._contextMenuBind, false);
        }
      }
      /**
       * Called on JS contextmenu event.
       * Override this method to provide functionality.
       * @param evt the context menu event
       */
      onContextMenu(evt) {
        evt.preventDefault();
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        if (this._observer) {
          this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
          if (this._contextMenuBind) {
            const engine = this.camera.getEngine();
            const element = engine.getInputElement();
            if (element) {
              element.removeEventListener("contextmenu", this._contextMenuBind);
            }
          }
          if (this.onPointerMovedObservable) {
            this.onPointerMovedObservable.clear();
          }
          this._observer = null;
          this._onMouseMove = null;
          this._previousPosition = null;
        }
        this._activePointerId = -1;
        this._currentActiveButton = -1;
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "FreeCameraMouseInput";
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "mouse";
      }
    };
    __decorate([
      serialize()
    ], FreeCameraMouseInput.prototype, "buttons", void 0);
    __decorate([
      serialize()
    ], FreeCameraMouseInput.prototype, "angularSensibility", void 0);
    CameraInputTypes["FreeCameraMouseInput"] = FreeCameraMouseInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseWheelInput.js
var _CameraProperty, FreeCameraMouseWheelInput;
var init_freeCameraMouseWheelInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseWheelInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_BaseCameraMouseWheelInput();
    init_math_vector();
    (function(_CameraProperty2) {
      _CameraProperty2[_CameraProperty2["MoveRelative"] = 0] = "MoveRelative";
      _CameraProperty2[_CameraProperty2["RotateRelative"] = 1] = "RotateRelative";
      _CameraProperty2[_CameraProperty2["MoveScene"] = 2] = "MoveScene";
    })(_CameraProperty || (_CameraProperty = {}));
    FreeCameraMouseWheelInput = class extends BaseCameraMouseWheelInput {
      constructor() {
        super(...arguments);
        this._moveRelative = Vector3.Zero();
        this._rotateRelative = Vector3.Zero();
        this._moveScene = Vector3.Zero();
        this._wheelXAction = _CameraProperty.MoveRelative;
        this._wheelXActionCoordinate = 0;
        this._wheelYAction = _CameraProperty.MoveRelative;
        this._wheelYActionCoordinate = 2;
        this._wheelZAction = null;
        this._wheelZActionCoordinate = null;
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "FreeCameraMouseWheelInput";
      }
      /**
       * Set which movement axis (relative to camera's orientation) the mouse
       * wheel's X axis controls.
       * @param axis The axis to be moved. Set null to clear.
       */
      set wheelXMoveRelative(axis) {
        if (axis === null && this._wheelXAction !== _CameraProperty.MoveRelative) {
          return;
        }
        this._wheelXAction = _CameraProperty.MoveRelative;
        this._wheelXActionCoordinate = axis;
      }
      /**
       * Get the configured movement axis (relative to camera's orientation) the
       * mouse wheel's X axis controls.
       * @returns The configured axis or null if none.
       */
      get wheelXMoveRelative() {
        if (this._wheelXAction !== _CameraProperty.MoveRelative) {
          return null;
        }
        return this._wheelXActionCoordinate;
      }
      /**
       * Set which movement axis (relative to camera's orientation) the mouse
       * wheel's Y axis controls.
       * @param axis The axis to be moved. Set null to clear.
       */
      set wheelYMoveRelative(axis) {
        if (axis === null && this._wheelYAction !== _CameraProperty.MoveRelative) {
          return;
        }
        this._wheelYAction = _CameraProperty.MoveRelative;
        this._wheelYActionCoordinate = axis;
      }
      /**
       * Get the configured movement axis (relative to camera's orientation) the
       * mouse wheel's Y axis controls.
       * @returns The configured axis or null if none.
       */
      get wheelYMoveRelative() {
        if (this._wheelYAction !== _CameraProperty.MoveRelative) {
          return null;
        }
        return this._wheelYActionCoordinate;
      }
      /**
       * Set which movement axis (relative to camera's orientation) the mouse
       * wheel's Z axis controls.
       * @param axis The axis to be moved. Set null to clear.
       */
      set wheelZMoveRelative(axis) {
        if (axis === null && this._wheelZAction !== _CameraProperty.MoveRelative) {
          return;
        }
        this._wheelZAction = _CameraProperty.MoveRelative;
        this._wheelZActionCoordinate = axis;
      }
      /**
       * Get the configured movement axis (relative to camera's orientation) the
       * mouse wheel's Z axis controls.
       * @returns The configured axis or null if none.
       */
      get wheelZMoveRelative() {
        if (this._wheelZAction !== _CameraProperty.MoveRelative) {
          return null;
        }
        return this._wheelZActionCoordinate;
      }
      /**
       * Set which rotation axis (relative to camera's orientation) the mouse
       * wheel's X axis controls.
       * @param axis The axis to be moved. Set null to clear.
       */
      set wheelXRotateRelative(axis) {
        if (axis === null && this._wheelXAction !== _CameraProperty.RotateRelative) {
          return;
        }
        this._wheelXAction = _CameraProperty.RotateRelative;
        this._wheelXActionCoordinate = axis;
      }
      /**
       * Get the configured rotation axis (relative to camera's orientation) the
       * mouse wheel's X axis controls.
       * @returns The configured axis or null if none.
       */
      get wheelXRotateRelative() {
        if (this._wheelXAction !== _CameraProperty.RotateRelative) {
          return null;
        }
        return this._wheelXActionCoordinate;
      }
      /**
       * Set which rotation axis (relative to camera's orientation) the mouse
       * wheel's Y axis controls.
       * @param axis The axis to be moved. Set null to clear.
       */
      set wheelYRotateRelative(axis) {
        if (axis === null && this._wheelYAction !== _CameraProperty.RotateRelative) {
          return;
        }
        this._wheelYAction = _CameraProperty.RotateRelative;
        this._wheelYActionCoordinate = axis;
      }
      /**
       * Get the configured rotation axis (relative to camera's orientation) the
       * mouse wheel's Y axis controls.
       * @returns The configured axis or null if none.
       */
      get wheelYRotateRelative() {
        if (this._wheelYAction !== _CameraProperty.RotateRelative) {
          return null;
        }
        return this._wheelYActionCoordinate;
      }
      /**
       * Set which rotation axis (relative to camera's orientation) the mouse
       * wheel's Z axis controls.
       * @param axis The axis to be moved. Set null to clear.
       */
      set wheelZRotateRelative(axis) {
        if (axis === null && this._wheelZAction !== _CameraProperty.RotateRelative) {
          return;
        }
        this._wheelZAction = _CameraProperty.RotateRelative;
        this._wheelZActionCoordinate = axis;
      }
      /**
       * Get the configured rotation axis (relative to camera's orientation) the
       * mouse wheel's Z axis controls.
       * @returns The configured axis or null if none.
       */
      get wheelZRotateRelative() {
        if (this._wheelZAction !== _CameraProperty.RotateRelative) {
          return null;
        }
        return this._wheelZActionCoordinate;
      }
      /**
       * Set which movement axis (relative to the scene) the mouse wheel's X axis
       * controls.
       * @param axis The axis to be moved. Set null to clear.
       */
      set wheelXMoveScene(axis) {
        if (axis === null && this._wheelXAction !== _CameraProperty.MoveScene) {
          return;
        }
        this._wheelXAction = _CameraProperty.MoveScene;
        this._wheelXActionCoordinate = axis;
      }
      /**
       * Get the configured movement axis (relative to the scene) the mouse wheel's
       * X axis controls.
       * @returns The configured axis or null if none.
       */
      get wheelXMoveScene() {
        if (this._wheelXAction !== _CameraProperty.MoveScene) {
          return null;
        }
        return this._wheelXActionCoordinate;
      }
      /**
       * Set which movement axis (relative to the scene) the mouse wheel's Y axis
       * controls.
       * @param axis The axis to be moved. Set null to clear.
       */
      set wheelYMoveScene(axis) {
        if (axis === null && this._wheelYAction !== _CameraProperty.MoveScene) {
          return;
        }
        this._wheelYAction = _CameraProperty.MoveScene;
        this._wheelYActionCoordinate = axis;
      }
      /**
       * Get the configured movement axis (relative to the scene) the mouse wheel's
       * Y axis controls.
       * @returns The configured axis or null if none.
       */
      get wheelYMoveScene() {
        if (this._wheelYAction !== _CameraProperty.MoveScene) {
          return null;
        }
        return this._wheelYActionCoordinate;
      }
      /**
       * Set which movement axis (relative to the scene) the mouse wheel's Z axis
       * controls.
       * @param axis The axis to be moved. Set null to clear.
       */
      set wheelZMoveScene(axis) {
        if (axis === null && this._wheelZAction !== _CameraProperty.MoveScene) {
          return;
        }
        this._wheelZAction = _CameraProperty.MoveScene;
        this._wheelZActionCoordinate = axis;
      }
      /**
       * Get the configured movement axis (relative to the scene) the mouse wheel's
       * Z axis controls.
       * @returns The configured axis or null if none.
       */
      get wheelZMoveScene() {
        if (this._wheelZAction !== _CameraProperty.MoveScene) {
          return null;
        }
        return this._wheelZActionCoordinate;
      }
      /**
       * Called for each rendered frame.
       */
      checkInputs() {
        if (this._wheelDeltaX === 0 && this._wheelDeltaY === 0 && this._wheelDeltaZ == 0) {
          return;
        }
        this._moveRelative.setAll(0);
        this._rotateRelative.setAll(0);
        this._moveScene.setAll(0);
        this._updateCamera();
        if (this.camera.getScene().useRightHandedSystem) {
          this._moveRelative.z *= -1;
        }
        const cameraTransformMatrix = Matrix.Zero();
        this.camera.getViewMatrix().invertToRef(cameraTransformMatrix);
        const transformedDirection = Vector3.Zero();
        Vector3.TransformNormalToRef(this._moveRelative, cameraTransformMatrix, transformedDirection);
        this.camera.cameraRotation.x += this._rotateRelative.x / 200;
        this.camera.cameraRotation.y += this._rotateRelative.y / 200;
        this.camera.cameraDirection.addInPlace(transformedDirection);
        this.camera.cameraDirection.addInPlace(this._moveScene);
        super.checkInputs();
      }
      /**
       * Update the camera according to any configured properties for the 3
       * mouse-wheel axis.
       */
      _updateCamera() {
        this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate);
        this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate);
        this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate);
      }
      /**
       * Update one property of the camera.
       * @param value
       * @param cameraProperty
       * @param coordinate
       */
      _updateCameraProperty(value, cameraProperty, coordinate) {
        if (value === 0) {
          return;
        }
        if (cameraProperty === null || coordinate === null) {
          return;
        }
        let action = null;
        switch (cameraProperty) {
          case _CameraProperty.MoveRelative:
            action = this._moveRelative;
            break;
          case _CameraProperty.RotateRelative:
            action = this._rotateRelative;
            break;
          case _CameraProperty.MoveScene:
            action = this._moveScene;
            break;
        }
        switch (coordinate) {
          case 0:
            action.set(value, 0, 0);
            break;
          case 1:
            action.set(0, value, 0);
            break;
          case 2:
            action.set(0, 0, value);
            break;
        }
      }
    };
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelXMoveRelative", null);
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelYMoveRelative", null);
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelZMoveRelative", null);
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelXRotateRelative", null);
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelYRotateRelative", null);
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelZRotateRelative", null);
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelXMoveScene", null);
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelYMoveScene", null);
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelZMoveScene", null);
    CameraInputTypes["FreeCameraMouseWheelInput"] = FreeCameraMouseWheelInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraTouchInput.js
var FreeCameraTouchInput;
var init_freeCameraTouchInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/freeCameraTouchInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_pointerEvents();
    init_math_vector();
    init_tools();
    FreeCameraTouchInput = class {
      /**
       * Manage the touch inputs to control the movement of a free camera.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs
       * @param allowMouse Defines if mouse events can be treated as touch events
       */
      constructor(allowMouse = false) {
        this.allowMouse = allowMouse;
        this.touchAngularSensibility = 2e5;
        this.touchMoveSensibility = 250;
        this.singleFingerRotate = false;
        this._offsetX = null;
        this._offsetY = null;
        this._pointerPressed = new Array();
        this._isSafari = Tools.IsSafari();
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        let previousPosition = null;
        if (this._pointerInput === void 0) {
          this._onLostFocus = () => {
            this._offsetX = null;
            this._offsetY = null;
          };
          this._pointerInput = (p) => {
            const evt = p.event;
            const isMouseEvent = evt.pointerType === "mouse" || this._isSafari && typeof evt.pointerType === "undefined";
            if (!this.allowMouse && isMouseEvent) {
              return;
            }
            if (p.type === PointerEventTypes.POINTERDOWN) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
              this._pointerPressed.push(evt.pointerId);
              if (this._pointerPressed.length !== 1) {
                return;
              }
              previousPosition = {
                x: evt.clientX,
                y: evt.clientY
              };
            } else if (p.type === PointerEventTypes.POINTERUP) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
              const index = this._pointerPressed.indexOf(evt.pointerId);
              if (index === -1) {
                return;
              }
              this._pointerPressed.splice(index, 1);
              if (index != 0) {
                return;
              }
              previousPosition = null;
              this._offsetX = null;
              this._offsetY = null;
            } else if (p.type === PointerEventTypes.POINTERMOVE) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
              if (!previousPosition) {
                return;
              }
              const index = this._pointerPressed.indexOf(evt.pointerId);
              if (index != 0) {
                return;
              }
              this._offsetX = evt.clientX - previousPosition.x;
              this._offsetY = -(evt.clientY - previousPosition.y);
            }
          };
        }
        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
        if (this._onLostFocus) {
          const engine = this.camera.getEngine();
          const element = engine.getInputElement();
          if (element) {
            element.addEventListener("blur", this._onLostFocus);
          }
        }
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        if (this._pointerInput) {
          if (this._observer) {
            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
            this._observer = null;
          }
          if (this._onLostFocus) {
            const engine = this.camera.getEngine();
            const element = engine.getInputElement();
            if (element) {
              element.removeEventListener("blur", this._onLostFocus);
            }
            this._onLostFocus = null;
          }
          this._pointerPressed.length = 0;
          this._offsetX = null;
          this._offsetY = null;
        }
      }
      /**
       * Update the current camera state depending on the inputs that have been used this frame.
       * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
       */
      checkInputs() {
        if (this._offsetX === null || this._offsetY === null) {
          return;
        }
        if (this._offsetX === 0 && this._offsetY === 0) {
          return;
        }
        const camera = this.camera;
        const handednessMultiplier = camera._calculateHandednessMultiplier();
        camera.cameraRotation.y = this._offsetX * handednessMultiplier / this.touchAngularSensibility;
        const rotateCamera = this.singleFingerRotate && this._pointerPressed.length === 1 || !this.singleFingerRotate && this._pointerPressed.length > 1;
        if (rotateCamera) {
          camera.cameraRotation.x = -(this._offsetY * handednessMultiplier) / this.touchAngularSensibility;
        } else {
          const speed = camera._computeLocalCameraSpeed();
          const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? speed * this._offsetY / this.touchMoveSensibility : 0);
          Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);
          camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));
        }
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "FreeCameraTouchInput";
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "touch";
      }
    };
    __decorate([
      serialize()
    ], FreeCameraTouchInput.prototype, "touchAngularSensibility", void 0);
    __decorate([
      serialize()
    ], FreeCameraTouchInput.prototype, "touchMoveSensibility", void 0);
    CameraInputTypes["FreeCameraTouchInput"] = FreeCameraTouchInput;
  }
});

// node_modules/@babylonjs/core/Cameras/freeCameraInputsManager.js
var FreeCameraInputsManager;
var init_freeCameraInputsManager = __esm({
  "node_modules/@babylonjs/core/Cameras/freeCameraInputsManager.js"() {
    init_cameraInputsManager();
    init_freeCameraKeyboardMoveInput();
    init_freeCameraMouseInput();
    init_freeCameraMouseWheelInput();
    init_freeCameraTouchInput();
    FreeCameraInputsManager = class extends CameraInputsManager {
      /**
       * Instantiates a new FreeCameraInputsManager.
       * @param camera Defines the camera the inputs belong to
       */
      constructor(camera) {
        super(camera);
        this._mouseInput = null;
        this._mouseWheelInput = null;
      }
      /**
       * Add keyboard input support to the input manager.
       * @returns the current input manager
       */
      addKeyboard() {
        this.add(new FreeCameraKeyboardMoveInput());
        return this;
      }
      /**
       * Add mouse input support to the input manager.
       * @param touchEnabled if the FreeCameraMouseInput should support touch (default: true)
       * @returns the current input manager
       */
      addMouse(touchEnabled = true) {
        if (!this._mouseInput) {
          this._mouseInput = new FreeCameraMouseInput(touchEnabled);
          this.add(this._mouseInput);
        }
        return this;
      }
      /**
       * Removes the mouse input support from the manager
       * @returns the current input manager
       */
      removeMouse() {
        if (this._mouseInput) {
          this.remove(this._mouseInput);
        }
        return this;
      }
      /**
       * Add mouse wheel input support to the input manager.
       * @returns the current input manager
       */
      addMouseWheel() {
        if (!this._mouseWheelInput) {
          this._mouseWheelInput = new FreeCameraMouseWheelInput();
          this.add(this._mouseWheelInput);
        }
        return this;
      }
      /**
       * Removes the mouse wheel input support from the manager
       * @returns the current input manager
       */
      removeMouseWheel() {
        if (this._mouseWheelInput) {
          this.remove(this._mouseWheelInput);
        }
        return this;
      }
      /**
       * Add touch input support to the input manager.
       * @returns the current input manager
       */
      addTouch() {
        this.add(new FreeCameraTouchInput());
        return this;
      }
      /**
       * Remove all attached input methods from a camera
       */
      clear() {
        super.clear();
        this._mouseInput = null;
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/geospatialCameraPointersInput.js
var GeospatialCameraPointersInput;
var init_geospatialCameraPointersInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/geospatialCameraPointersInput.js"() {
    init_orbitCameraPointersInput();
    GeospatialCameraPointersInput = class extends OrbitCameraPointersInput {
      constructor() {
        super(...arguments);
        this._initialPinchSquaredDistance = 0;
        this._pinchCentroid = null;
      }
      getClassName() {
        return "GeospatialCameraPointersInput";
      }
      onButtonDown(evt) {
        this.camera.movement.activeInput = true;
        const scene = this.camera.getScene();
        switch (evt.button) {
          case 0:
            this.camera.movement.startDrag(scene.pointerX, scene.pointerY);
            break;
          default:
            break;
        }
      }
      onTouch(point, offsetX, offsetY) {
        const button = point?.button ?? 0;
        const scene = this.camera.getScene();
        switch (button) {
          case 0:
            this.camera.movement.handleDrag(scene.pointerX, scene.pointerY);
            break;
          case 1:
          // Middle button - tilt camera
          case 2:
            this._handleTilt(offsetX, offsetY);
            break;
        }
      }
      /**
       * Move camera from multitouch (pinch) zoom distances.
       * Zooms towards the centroid (midpoint between the two fingers).
       * @param previousPinchSquaredDistance
       * @param pinchSquaredDistance
       */
      _computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance) {
        const previousDistance = Math.sqrt(previousPinchSquaredDistance);
        const currentDistance = Math.sqrt(pinchSquaredDistance);
        const pinchDelta = currentDistance - previousDistance;
        if (this._pinchCentroid) {
          const scene = this.camera.getScene();
          const engine = scene.getEngine();
          const canvasRect = engine.getInputElementClientRect();
          if (canvasRect) {
            const canvasX = this._pinchCentroid.x - canvasRect.left;
            const canvasY = this._pinchCentroid.y - canvasRect.top;
            const pickResult = scene.pick(canvasX, canvasY, this.camera.movement.pickPredicate);
            if (pickResult?.pickedPoint) {
              const distanceToPoint = this.camera.position.subtract(pickResult.pickedPoint).length();
              const zoomDistance2 = pinchDelta * distanceToPoint * 5e-3;
              const clampedZoom2 = this.camera.limits.clampZoomDistance(zoomDistance2, this.camera.radius, distanceToPoint);
              this.camera.zoomToPoint(pickResult.pickedPoint, clampedZoom2);
              return;
            }
          }
        }
        const zoomDistance = pinchDelta * this.camera.radius * 5e-3;
        const clampedZoom = this.camera.limits.clampZoomDistance(zoomDistance, this.camera.radius);
        this.camera.zoomAlongLookAt(clampedZoom);
      }
      /**
       * Move camera from multi touch panning positions.
       * In geospatialcamera, multi touch panning tilts the globe (whereas single touch will pan/drag it)
       * @param previousMultiTouchPanPosition
       * @param multiTouchPanPosition
       */
      _computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition) {
        if (previousMultiTouchPanPosition && multiTouchPanPosition) {
          const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;
          const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;
          this._handleTilt(moveDeltaX, moveDeltaY);
        }
      }
      onDoubleTap(type) {
        const pickResult = this.camera._scene.pick(this.camera._scene.pointerX, this.camera._scene.pointerY, this.camera.movement.pickPredicate);
        if (pickResult.pickedPoint) {
          void this.camera.flyToPointAsync(pickResult.pickedPoint);
        }
      }
      onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {
        this._pinchCentroid = multiTouchPanPosition;
        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {
          this._initialPinchSquaredDistance = 0;
          this._pinchCentroid = null;
          super.onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);
          return;
        }
        if (this._initialPinchSquaredDistance === 0 && pinchSquaredDistance !== 0) {
          this._initialPinchSquaredDistance = pinchSquaredDistance;
        }
        const cumulativeDelta = Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(this._initialPinchSquaredDistance));
        this._shouldStartPinchZoom = this._twoFingerActivityCount < 20 && cumulativeDelta > this.camera.limits.pinchToPanMax;
        super.onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);
      }
      onButtonUp(_evt) {
        this.camera.movement.stopDrag();
        this.camera.movement.activeInput = false;
        this._initialPinchSquaredDistance = 0;
        this._pinchCentroid = null;
        super.onButtonUp(_evt);
      }
      onLostFocus() {
        this._initialPinchSquaredDistance = 0;
        this._pinchCentroid = null;
        super.onLostFocus();
      }
      _handleTilt(deltaX, deltaY) {
        this.camera.movement.rotationAccumulatedPixels.y -= deltaX;
        this.camera.movement.rotationAccumulatedPixels.x -= deltaY;
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/geospatialCameraMouseWheelInput.js
var GeospatialCameraMouseWheelInput;
var init_geospatialCameraMouseWheelInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/geospatialCameraMouseWheelInput.js"() {
    init_cameraInputsManager();
    init_BaseCameraMouseWheelInput();
    GeospatialCameraMouseWheelInput = class extends BaseCameraMouseWheelInput {
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "GeospatialCameraMouseWheelInput";
      }
      checkInputs() {
        this.camera.movement.handleZoom(this._wheelDeltaY, true);
        super.checkInputs();
      }
    };
    CameraInputTypes["GeospatialCameraMouseWheelInput"] = GeospatialCameraMouseWheelInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/geospatialCameraKeyboardInput.js
var GeospatialCameraKeyboardInput;
var init_geospatialCameraKeyboardInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/geospatialCameraKeyboardInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_keyboardEvents();
    init_tools();
    GeospatialCameraKeyboardInput = class {
      constructor() {
        this.keysUp = [38];
        this.keysDown = [40];
        this.keysLeft = [37];
        this.keysRight = [39];
        this.keysZoomIn = [187, 107];
        this.keysZoomOut = [189, 109];
        this.rotationSensitivity = 1;
        this.panSensitivity = 1;
        this.zoomSensitivity = 1;
        this._keys = new Array();
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        if (this._onCanvasBlurObserver) {
          return;
        }
        this._scene = this.camera.getScene();
        this._engine = this._scene.getEngine();
        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {
          this._keys.length = 0;
        });
        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {
          const evt = info.event;
          if (!evt.metaKey) {
            if (info.type === KeyboardEventTypes.KEYDOWN) {
              this._ctrlPressed = evt.ctrlKey;
              if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysZoomIn.indexOf(evt.keyCode) !== -1 || this.keysZoomOut.indexOf(evt.keyCode) !== -1) {
                const index = this._keys.indexOf(evt.keyCode);
                if (index === -1) {
                  this._keys.push(evt.keyCode);
                }
                if (evt.preventDefault) {
                  if (!noPreventDefault) {
                    evt.preventDefault();
                  }
                }
              }
            } else {
              if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysZoomIn.indexOf(evt.keyCode) !== -1 || this.keysZoomOut.indexOf(evt.keyCode) !== -1) {
                const index = this._keys.indexOf(evt.keyCode);
                if (index >= 0) {
                  this._keys.splice(index, 1);
                }
                if (evt.preventDefault) {
                  if (!noPreventDefault) {
                    evt.preventDefault();
                  }
                }
              }
            }
          }
        });
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        if (this._scene) {
          this._onKeyboardObserver?.remove();
          this._onKeyboardObserver = null;
          this._onCanvasBlurObserver?.remove();
          this._onCanvasBlurObserver = null;
        }
        this._keys.length = 0;
      }
      /**
       * Update the current camera state depending on the inputs that have been used this frame.
       * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
       */
      checkInputs() {
        if (this._onKeyboardObserver) {
          const camera = this.camera;
          for (let index = 0; index < this._keys.length; index++) {
            const keyCode = this._keys[index];
            if (this._ctrlPressed) {
              if (this.keysLeft.indexOf(keyCode) !== -1) {
                camera.movement.rotationAccumulatedPixels.y -= this.rotationSensitivity;
              } else if (this.keysRight.indexOf(keyCode) !== -1) {
                camera.movement.rotationAccumulatedPixels.y += this.rotationSensitivity;
              } else if (this.keysUp.indexOf(keyCode) !== -1) {
                camera.movement.rotationAccumulatedPixels.x -= this.rotationSensitivity;
              } else if (this.keysDown.indexOf(keyCode) !== -1) {
                camera.movement.rotationAccumulatedPixels.x += this.rotationSensitivity;
              }
            } else {
              if (this.keysZoomIn.indexOf(keyCode) !== -1) {
                camera.movement.handleZoom(this.zoomSensitivity, false);
              } else if (this.keysZoomOut.indexOf(keyCode) !== -1) {
                camera.movement.handleZoom(-this.zoomSensitivity, false);
              } else {
                const centerX = this._engine.getRenderWidth() / 2;
                const centerY = this._engine.getRenderHeight() / 2;
                camera.movement.startDrag(centerX, centerY);
                if (this.keysLeft.indexOf(keyCode) !== -1) {
                  camera.movement.handleDrag(centerX + this.panSensitivity, centerY);
                } else if (this.keysRight.indexOf(keyCode) !== -1) {
                  camera.movement.handleDrag(centerX - this.panSensitivity, centerY);
                } else if (this.keysUp.indexOf(keyCode) !== -1) {
                  camera.movement.handleDrag(centerX, centerY + this.panSensitivity);
                } else if (this.keysDown.indexOf(keyCode) !== -1) {
                  camera.movement.handleDrag(centerX, centerY - this.panSensitivity);
                }
                camera.movement.stopDrag();
              }
            }
          }
        }
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "GeospatialCameraKeyboardInput";
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "keyboard";
      }
    };
    __decorate([
      serialize()
    ], GeospatialCameraKeyboardInput.prototype, "keysUp", void 0);
    __decorate([
      serialize()
    ], GeospatialCameraKeyboardInput.prototype, "keysDown", void 0);
    __decorate([
      serialize()
    ], GeospatialCameraKeyboardInput.prototype, "keysLeft", void 0);
    __decorate([
      serialize()
    ], GeospatialCameraKeyboardInput.prototype, "keysRight", void 0);
    __decorate([
      serialize()
    ], GeospatialCameraKeyboardInput.prototype, "keysZoomIn", void 0);
    __decorate([
      serialize()
    ], GeospatialCameraKeyboardInput.prototype, "keysZoomOut", void 0);
    __decorate([
      serialize()
    ], GeospatialCameraKeyboardInput.prototype, "rotationSensitivity", void 0);
    __decorate([
      serialize()
    ], GeospatialCameraKeyboardInput.prototype, "panSensitivity", void 0);
    __decorate([
      serialize()
    ], GeospatialCameraKeyboardInput.prototype, "zoomSensitivity", void 0);
    CameraInputTypes["GeospatialCameraKeyboardInput"] = GeospatialCameraKeyboardInput;
  }
});

// node_modules/@babylonjs/core/Cameras/freeCamera.js
var FreeCamera;
var init_freeCamera = __esm({
  "node_modules/@babylonjs/core/Cameras/freeCamera.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_targetCamera();
    init_freeCameraInputsManager();
    init_tools();
    init_typeStore();
    init_abstractEngine();
    FreeCamera = class extends TargetCamera {
      /**
       * Gets the input sensibility for a mouse input. (default is 2000.0)
       * Higher values reduce sensitivity.
       */
      get angularSensibility() {
        const mouse = this.inputs.attached["mouse"];
        if (mouse) {
          return mouse.angularSensibility;
        }
        return 0;
      }
      /**
       * Sets the input sensibility for a mouse input. (default is 2000.0)
       * Higher values reduce sensitivity.
       */
      set angularSensibility(value) {
        const mouse = this.inputs.attached["mouse"];
        if (mouse) {
          mouse.angularSensibility = value;
        }
      }
      /**
       * Gets or Set the list of keyboard keys used to control the forward move of the camera.
       */
      get keysUp() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysUp;
        }
        return [];
      }
      set keysUp(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysUp = value;
        }
      }
      /**
       * Gets or Set the list of keyboard keys used to control the upward move of the camera.
       */
      get keysUpward() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysUpward;
        }
        return [];
      }
      set keysUpward(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysUpward = value;
        }
      }
      /**
       * Gets or Set the list of keyboard keys used to control the backward move of the camera.
       */
      get keysDown() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysDown;
        }
        return [];
      }
      set keysDown(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysDown = value;
        }
      }
      /**
       * Gets or Set the list of keyboard keys used to control the downward move of the camera.
       */
      get keysDownward() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysDownward;
        }
        return [];
      }
      set keysDownward(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysDownward = value;
        }
      }
      /**
       * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.
       */
      get keysLeft() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysLeft;
        }
        return [];
      }
      set keysLeft(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysLeft = value;
        }
      }
      /**
       * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.
       */
      get keysRight() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysRight;
        }
        return [];
      }
      set keysRight(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysRight = value;
        }
      }
      /**
       * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.
       */
      get keysRotateLeft() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysRotateLeft;
        }
        return [];
      }
      set keysRotateLeft(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysRotateLeft = value;
        }
      }
      /**
       * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.
       */
      get keysRotateRight() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysRotateRight;
        }
        return [];
      }
      set keysRotateRight(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysRotateRight = value;
        }
      }
      /**
       * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.
       */
      get keysRotateUp() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysRotateUp;
        }
        return [];
      }
      set keysRotateUp(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysRotateUp = value;
        }
      }
      /**
       * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.
       */
      get keysRotateDown() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysRotateDown;
        }
        return [];
      }
      set keysRotateDown(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysRotateDown = value;
        }
      }
      /**
       * Instantiates a Free Camera.
       * This represents a free type of camera. It can be useful in First Person Shooter game for instance.
       * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera
       * @param name Define the name of the camera in the scene
       * @param position Define the start position of the camera in the scene
       * @param scene Define the scene the camera belongs to
       * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined
       */
      constructor(name13, position, scene, setActiveOnSceneIfNoneActive = true) {
        super(name13, position, scene, setActiveOnSceneIfNoneActive);
        this.ellipsoid = new Vector3(0.5, 1, 0.5);
        this.ellipsoidOffset = new Vector3(0, 0, 0);
        this.checkCollisions = false;
        this.applyGravity = false;
        this._needMoveForGravity = false;
        this._oldPosition = Vector3.Zero();
        this._diffPosition = Vector3.Zero();
        this._newPosition = Vector3.Zero();
        this._collisionMask = -1;
        this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {
          this._newPosition.copyFrom(newPosition);
          this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);
          if (this._diffPosition.length() > AbstractEngine.CollisionsEpsilon) {
            this.position.addToRef(this._diffPosition, this._deferredPositionUpdate);
            if (!this._deferOnly) {
              this.position.copyFrom(this._deferredPositionUpdate);
            } else {
              this._deferredUpdated = true;
            }
            if (this.onCollide && collidedMesh) {
              this.onCollide(collidedMesh);
            }
          }
        };
        this.inputs = new FreeCameraInputsManager(this);
        this.inputs.addKeyboard().addMouse();
      }
      /**
       * Attached controls to the current camera.
       * @param ignored defines an ignored parameter kept for backward compatibility.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(ignored, noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        this.inputs.attachElement(noPreventDefault);
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        this.inputs.detachElement();
        this.cameraDirection = new Vector3(0, 0, 0);
        this.cameraRotation = new Vector2(0, 0);
      }
      /**
       * Define a collision mask to limit the list of object the camera can collide with
       */
      get collisionMask() {
        return this._collisionMask;
      }
      set collisionMask(mask) {
        this._collisionMask = !isNaN(mask) ? mask : -1;
      }
      /**
       * @internal
       */
      _collideWithWorld(displacement) {
        let globalPosition;
        if (this.parent) {
          globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());
        } else {
          globalPosition = this.position;
        }
        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);
        this._oldPosition.addInPlace(this.ellipsoidOffset);
        const coordinator = this.getScene().collisionCoordinator;
        if (!this._collider) {
          this._collider = coordinator.createCollider();
        }
        this._collider._radius = this.ellipsoid;
        this._collider.collisionMask = this._collisionMask;
        let actualDisplacement = displacement;
        if (this.applyGravity) {
          actualDisplacement = displacement.add(this.getScene().gravity);
        }
        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
      }
      /** @internal */
      _checkInputs() {
        if (!this._localDirection) {
          this._localDirection = Vector3.Zero();
          this._transformedDirection = Vector3.Zero();
        }
        this.inputs.checkInputs();
        super._checkInputs();
      }
      /**
       * Enable movement without a user input. This allows gravity to always be applied.
       */
      set needMoveForGravity(value) {
        this._needMoveForGravity = value;
      }
      /**
       * When true, gravity is applied whether there is user input or not.
       */
      get needMoveForGravity() {
        return this._needMoveForGravity;
      }
      /** @internal */
      _decideIfNeedsToMove() {
        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
      }
      /** @internal */
      _updatePosition() {
        if (this.checkCollisions && this.getScene().collisionsEnabled) {
          this._collideWithWorld(this.cameraDirection);
        } else {
          super._updatePosition();
        }
      }
      /**
       * Destroy the camera and release the current resources hold by it.
       */
      dispose() {
        this.inputs.clear();
        super.dispose();
      }
      /**
       * Gets the current object class name.
       * @returns the class name
       */
      getClassName() {
        return "FreeCamera";
      }
    };
    __decorate([
      serializeAsVector3()
    ], FreeCamera.prototype, "ellipsoid", void 0);
    __decorate([
      serializeAsVector3()
    ], FreeCamera.prototype, "ellipsoidOffset", void 0);
    __decorate([
      serialize()
    ], FreeCamera.prototype, "checkCollisions", void 0);
    __decorate([
      serialize()
    ], FreeCamera.prototype, "applyGravity", void 0);
    RegisterClass("BABYLON.FreeCamera", FreeCamera);
  }
});

// node_modules/@babylonjs/core/Cameras/arcRotateCamera.js
function ComputeAlpha(offset) {
  let alpha = Math.PI / 2;
  if (!(offset.x === 0 && offset.z === 0)) {
    alpha = Math.acos(offset.x / Math.sqrt(Math.pow(offset.x, 2) + Math.pow(offset.z, 2)));
  }
  if (offset.z < 0) {
    alpha = 2 * Math.PI - alpha;
  }
  return alpha;
}
function ComputeBeta(verticalOffset, radius) {
  return Math.acos(verticalOffset / radius);
}
function CheckNaN(value, fallback) {
  return isNaN(value) ? fallback : value;
}
var ArcRotateCamera;
var init_arcRotateCamera = __esm({
  "node_modules/@babylonjs/core/Cameras/arcRotateCamera.js"() {
    init_tslib_es6();
    init_decorators();
    init_observable();
    init_math_vector();
    init_math_scalar_functions();
    init_node();
    init_mesh();
    init_autoRotationBehavior();
    init_bouncingBehavior();
    init_framingBehavior();
    init_camera();
    init_targetCamera();
    init_arcRotateCameraInputsManager();
    init_math_constants();
    init_tools();
    init_typeStore();
    Node.AddNodeConstructor("ArcRotateCamera", (name13, scene) => {
      return () => new ArcRotateCamera(name13, 0, 0, 1, Vector3.Zero(), scene);
    });
    ArcRotateCamera = class _ArcRotateCamera extends TargetCamera {
      /**
       * Defines the target point of the camera.
       * The camera looks towards it from the radius distance.
       */
      get target() {
        return this._target;
      }
      set target(value) {
        this.setTarget(value);
      }
      /**
       * Defines the target transform node of the camera.
       * The camera looks towards it from the radius distance.
       * Please note that setting a target host will disable panning.
       */
      get targetHost() {
        return this._targetHost;
      }
      set targetHost(value) {
        if (value) {
          this.setTarget(value);
        }
      }
      /**
       * Return the current target position of the camera. This value is expressed in local space.
       * @returns the target position
       */
      getTarget() {
        return this.target;
      }
      /**
       * Define the current local position of the camera in the scene
       */
      get position() {
        return this._position;
      }
      set position(newPosition) {
        this.setPosition(newPosition);
      }
      /**
       * The vector the camera should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())
       * Setting this will copy the given vector to the camera's upVector, and set rotation matrices to and from Y up.
       * DO NOT set the up vector using copyFrom or copyFromFloats, as this bypasses setting the above matrices.
       */
      set upVector(vec) {
        if (!this._upToYMatrix) {
          this._yToUpMatrix = new Matrix();
          this._upToYMatrix = new Matrix();
          this._upVector = Vector3.Zero();
        }
        vec.normalize();
        this._upVector.copyFrom(vec);
        this.setMatUp();
      }
      get upVector() {
        return this._upVector;
      }
      /**
       * Sets the Y-up to camera up-vector rotation matrix, and the up-vector to Y-up rotation matrix.
       */
      setMatUp() {
        Matrix.RotationAlignToRef(Vector3.UpReadOnly, this._upVector, this._yToUpMatrix);
        Matrix.RotationAlignToRef(this._upVector, Vector3.UpReadOnly, this._upToYMatrix);
      }
      //-- begin properties for backward compatibility for inputs
      /**
       * Gets or Set the pointer angular sensibility  along the X axis or how fast is the camera rotating.
       */
      get angularSensibilityX() {
        const pointers = this.inputs.attached["pointers"];
        if (pointers) {
          return pointers.angularSensibilityX;
        }
        return 0;
      }
      set angularSensibilityX(value) {
        const pointers = this.inputs.attached["pointers"];
        if (pointers) {
          pointers.angularSensibilityX = value;
        }
      }
      /**
       * Gets or Set the pointer angular sensibility along the Y axis or how fast is the camera rotating.
       */
      get angularSensibilityY() {
        const pointers = this.inputs.attached["pointers"];
        if (pointers) {
          return pointers.angularSensibilityY;
        }
        return 0;
      }
      set angularSensibilityY(value) {
        const pointers = this.inputs.attached["pointers"];
        if (pointers) {
          pointers.angularSensibilityY = value;
        }
      }
      /**
       * Gets or Set the pointer pinch precision or how fast is the camera zooming.
       */
      get pinchPrecision() {
        const pointers = this.inputs.attached["pointers"];
        if (pointers) {
          return pointers.pinchPrecision;
        }
        return 0;
      }
      set pinchPrecision(value) {
        const pointers = this.inputs.attached["pointers"];
        if (pointers) {
          pointers.pinchPrecision = value;
        }
      }
      /**
       * Gets or Set the pointer pinch delta percentage or how fast is the camera zooming.
       * It will be used instead of pinchPrecision if different from 0.
       * It defines the percentage of current camera.radius to use as delta when pinch zoom is used.
       */
      get pinchDeltaPercentage() {
        const pointers = this.inputs.attached["pointers"];
        if (pointers) {
          return pointers.pinchDeltaPercentage;
        }
        return 0;
      }
      set pinchDeltaPercentage(value) {
        const pointers = this.inputs.attached["pointers"];
        if (pointers) {
          pointers.pinchDeltaPercentage = value;
        }
      }
      /**
       * Gets or Set the pointer use natural pinch zoom to override the pinch precision
       * and pinch delta percentage.
       * When useNaturalPinchZoom is true, multi touch zoom will zoom in such
       * that any object in the plane at the camera's target point will scale
       * perfectly with finger motion.
       */
      get useNaturalPinchZoom() {
        const pointers = this.inputs.attached["pointers"];
        if (pointers) {
          return pointers.useNaturalPinchZoom;
        }
        return false;
      }
      set useNaturalPinchZoom(value) {
        const pointers = this.inputs.attached["pointers"];
        if (pointers) {
          pointers.useNaturalPinchZoom = value;
        }
      }
      /**
       * Gets or Set the pointer panning sensibility or how fast is the camera moving.
       */
      get panningSensibility() {
        const pointers = this.inputs.attached["pointers"];
        if (pointers) {
          return pointers.panningSensibility;
        }
        return 0;
      }
      set panningSensibility(value) {
        const pointers = this.inputs.attached["pointers"];
        if (pointers) {
          pointers.panningSensibility = value;
        }
      }
      /**
       * Gets or Set the list of keyboard keys used to control beta angle in a positive direction.
       */
      get keysUp() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysUp;
        }
        return [];
      }
      set keysUp(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysUp = value;
        }
      }
      /**
       * Gets or Set the list of keyboard keys used to control beta angle in a negative direction.
       */
      get keysDown() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysDown;
        }
        return [];
      }
      set keysDown(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysDown = value;
        }
      }
      /**
       * Gets or Set the list of keyboard keys used to control alpha angle in a negative direction.
       */
      get keysLeft() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysLeft;
        }
        return [];
      }
      set keysLeft(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysLeft = value;
        }
      }
      /**
       * Gets or Set the list of keyboard keys used to control alpha angle in a positive direction.
       */
      get keysRight() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysRight;
        }
        return [];
      }
      set keysRight(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysRight = value;
        }
      }
      /**
       * Gets or Set the mouse wheel precision or how fast is the camera zooming.
       */
      get wheelPrecision() {
        const mousewheel = this.inputs.attached["mousewheel"];
        if (mousewheel) {
          return mousewheel.wheelPrecision;
        }
        return 0;
      }
      set wheelPrecision(value) {
        const mousewheel = this.inputs.attached["mousewheel"];
        if (mousewheel) {
          mousewheel.wheelPrecision = value;
        }
      }
      /**
       * Gets or Set the boolean value that controls whether or not the mouse wheel
       * zooms to the location of the mouse pointer or not.  The default is false.
       */
      get zoomToMouseLocation() {
        const mousewheel = this.inputs.attached["mousewheel"];
        if (mousewheel) {
          return mousewheel.zoomToMouseLocation;
        }
        return false;
      }
      set zoomToMouseLocation(value) {
        const mousewheel = this.inputs.attached["mousewheel"];
        if (mousewheel) {
          mousewheel.zoomToMouseLocation = value;
        }
      }
      /**
       * Gets or Set the mouse wheel delta percentage or how fast is the camera zooming.
       * It will be used instead of wheelPrecision if different from 0.
       * It defines the percentage of current camera.radius to use as delta when wheel zoom is used.
       */
      get wheelDeltaPercentage() {
        const mousewheel = this.inputs.attached["mousewheel"];
        if (mousewheel) {
          return mousewheel.wheelDeltaPercentage;
        }
        return 0;
      }
      set wheelDeltaPercentage(value) {
        const mousewheel = this.inputs.attached["mousewheel"];
        if (mousewheel) {
          mousewheel.wheelDeltaPercentage = value;
        }
      }
      /**
       * If true, indicates the camera is currently interpolating to a new pose.
       */
      get isInterpolating() {
        return this._isInterpolating;
      }
      /**
       * Gets the bouncing behavior of the camera if it has been enabled.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior
       */
      get bouncingBehavior() {
        return this._bouncingBehavior;
      }
      /**
       * Defines if the bouncing behavior of the camera is enabled on the camera.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior
       */
      get useBouncingBehavior() {
        return this._bouncingBehavior != null;
      }
      set useBouncingBehavior(value) {
        if (value === this.useBouncingBehavior) {
          return;
        }
        if (value) {
          this._bouncingBehavior = new BouncingBehavior();
          this.addBehavior(this._bouncingBehavior);
        } else if (this._bouncingBehavior) {
          this.removeBehavior(this._bouncingBehavior);
          this._bouncingBehavior = null;
        }
      }
      /**
       * Gets the framing behavior of the camera if it has been enabled.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior
       */
      get framingBehavior() {
        return this._framingBehavior;
      }
      /**
       * Defines if the framing behavior of the camera is enabled on the camera.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior
       */
      get useFramingBehavior() {
        return this._framingBehavior != null;
      }
      set useFramingBehavior(value) {
        if (value === this.useFramingBehavior) {
          return;
        }
        if (value) {
          this._framingBehavior = new FramingBehavior();
          this.addBehavior(this._framingBehavior);
        } else if (this._framingBehavior) {
          this.removeBehavior(this._framingBehavior);
          this._framingBehavior = null;
        }
      }
      /**
       * Gets the auto rotation behavior of the camera if it has been enabled.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior
       */
      get autoRotationBehavior() {
        return this._autoRotationBehavior;
      }
      /**
       * Defines if the auto rotation behavior of the camera is enabled on the camera.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior
       */
      get useAutoRotationBehavior() {
        return this._autoRotationBehavior != null;
      }
      set useAutoRotationBehavior(value) {
        if (value === this.useAutoRotationBehavior) {
          return;
        }
        if (value) {
          this._autoRotationBehavior = new AutoRotationBehavior();
          this.addBehavior(this._autoRotationBehavior);
        } else if (this._autoRotationBehavior) {
          this.removeBehavior(this._autoRotationBehavior);
          this._autoRotationBehavior = null;
        }
      }
      /**
       * Instantiates a new ArcRotateCamera in a given scene
       * @param name Defines the name of the camera
       * @param alpha Defines the camera rotation along the longitudinal axis
       * @param beta Defines the camera rotation along the latitudinal axis
       * @param radius Defines the camera distance from its target
       * @param target Defines the camera target
       * @param scene Defines the scene the camera belongs to
       * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined
       */
      constructor(name13, alpha, beta, radius, target, scene, setActiveOnSceneIfNoneActive = true) {
        super(name13, Vector3.Zero(), scene, setActiveOnSceneIfNoneActive);
        this.inertialAlphaOffset = 0;
        this.inertialBetaOffset = 0;
        this.inertialRadiusOffset = 0;
        this.lowerAlphaLimit = null;
        this.upperAlphaLimit = null;
        this.lowerBetaLimit = 0.01;
        this.upperBetaLimit = Math.PI - 0.01;
        this.lowerRadiusLimit = null;
        this.upperRadiusLimit = null;
        this.lowerTargetYLimit = -Infinity;
        this.inertialPanningX = 0;
        this.inertialPanningY = 0;
        this.pinchToPanMaxDistance = 20;
        this.panningDistanceLimit = null;
        this.panningOriginTarget = Vector3.Zero();
        this.panningInertia = 0.9;
        this.zoomOnFactor = 1;
        this.targetScreenOffset = Vector2.Zero();
        this.allowUpsideDown = true;
        this.useInputToRestoreState = true;
        this.restoreStateInterpolationFactor = 0;
        this._currentInterpolationFactor = 0;
        this._viewMatrix = new Matrix();
        this.panningAxis = new Vector3(1, 1, 0);
        this._transformedDirection = new Vector3();
        this.mapPanning = false;
        this._isInterpolating = false;
        this.onMeshTargetChangedObservable = new Observable();
        this.checkCollisions = false;
        this.collisionRadius = new Vector3(0.5, 0.5, 0.5);
        this._previousPosition = Vector3.Zero();
        this._collisionVelocity = Vector3.Zero();
        this._newPosition = Vector3.Zero();
        this._computationVector = Vector3.Zero();
        this._goalAlpha = NaN;
        this._goalBeta = NaN;
        this._goalRadius = NaN;
        this._goalTarget = new Vector3(NaN, NaN, NaN);
        this._goalTargetScreenOffset = new Vector2(NaN, NaN);
        this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {
          if (!collidedMesh) {
            this._previousPosition.copyFrom(this._position);
          } else {
            this.setPosition(newPosition);
            if (this.onCollide) {
              this.onCollide(collidedMesh);
            }
          }
          const cosa = Math.cos(this.alpha);
          const sina = Math.sin(this.alpha);
          const cosb = Math.cos(this.beta);
          let sinb = Math.sin(this.beta);
          if (sinb === 0) {
            sinb = 1e-4;
          }
          const target2 = this._getTargetPosition();
          this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);
          target2.addToRef(this._computationVector, this._newPosition);
          this._position.copyFrom(this._newPosition);
          let up = this.upVector;
          if (this.allowUpsideDown && this.beta < 0) {
            up = up.clone();
            up = up.negate();
          }
          this._computeViewMatrix(this._position, target2, up);
          this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);
          this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);
          this._collisionTriggered = false;
        };
        this._target = Vector3.Zero();
        if (target) {
          this.setTarget(target);
        }
        this.alpha = alpha;
        this.beta = beta;
        this.radius = radius;
        this.getViewMatrix();
        this.inputs = new ArcRotateCameraInputsManager(this);
        this.inputs.addKeyboard().addMouseWheel().addPointers();
      }
      // Cache
      /** @internal */
      _initCache() {
        super._initCache();
        this._cache._target = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.alpha = void 0;
        this._cache.beta = void 0;
        this._cache.radius = void 0;
        this._cache.targetScreenOffset = Vector2.Zero();
      }
      /**
       * @internal
       */
      _updateCache(ignoreParentClass) {
        if (!ignoreParentClass) {
          super._updateCache();
        }
        this._cache._target.copyFrom(this._getTargetPosition());
        this._cache.alpha = this.alpha;
        this._cache.beta = this.beta;
        this._cache.radius = this.radius;
        this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset);
      }
      _getTargetPosition() {
        if (this._targetHost && this._targetHost.getAbsolutePosition) {
          const pos = this._targetHost.getAbsolutePosition();
          if (this._targetBoundingCenter) {
            pos.addToRef(this._targetBoundingCenter, this._target);
          } else {
            this._target.copyFrom(pos);
          }
        }
        const lockedTargetPosition = this._getLockedTargetPosition();
        if (lockedTargetPosition) {
          return lockedTargetPosition;
        }
        return this._target;
      }
      /**
       * Stores the current state of the camera (alpha, beta, radius and target)
       * @returns the camera itself
       */
      storeState() {
        this._storedAlpha = this.alpha;
        this._storedBeta = this.beta;
        this._storedRadius = this.radius;
        this._storedTarget = this._getTargetPosition().clone();
        this._storedTargetScreenOffset = this.targetScreenOffset.clone();
        return super.storeState();
      }
      /**
       * @internal
       * Restored camera state. You must call storeState() first
       */
      _restoreStateValues() {
        if (this.hasStateStored() && this.restoreStateInterpolationFactor > Epsilon && this.restoreStateInterpolationFactor < 1) {
          this.interpolateTo(this._storedAlpha, this._storedBeta, this._storedRadius, this._storedTarget, this._storedTargetScreenOffset, this.restoreStateInterpolationFactor);
          return true;
        }
        if (!super._restoreStateValues()) {
          return false;
        }
        this.setTarget(this._storedTarget.clone());
        this.alpha = this._storedAlpha;
        this.beta = this._storedBeta;
        this.radius = this._storedRadius;
        this.targetScreenOffset = this._storedTargetScreenOffset.clone();
        this.inertialAlphaOffset = 0;
        this.inertialBetaOffset = 0;
        this.inertialRadiusOffset = 0;
        this.inertialPanningX = 0;
        this.inertialPanningY = 0;
        return true;
      }
      /**
       * Stops any in-progress interpolation.
       */
      stopInterpolation() {
        this._goalAlpha = NaN;
        this._goalBeta = NaN;
        this._goalRadius = NaN;
        this._goalTarget.set(NaN, NaN, NaN);
        this._goalTargetScreenOffset.set(NaN, NaN);
      }
      /**
       * Interpolates the camera to a goal state.
       * @param alpha Defines the goal alpha.
       * @param beta Defines the goal beta.
       * @param radius Defines the goal radius.
       * @param target Defines the goal target.
       * @param targetScreenOffset Defines the goal target screen offset.
       * @param interpolationFactor A value  between 0 and 1 that determines the speed of the interpolation.
       * @remarks Passing undefined for any of the parameters will use the current value (effectively stopping any in-progress interpolation for that parameter).
       *          Passing NaN will not start or stop any interpolation for that parameter (effectively allowing multiple interpolations of different parameters to overlap).
       */
      interpolateTo(alpha = this.alpha, beta = this.beta, radius = this.radius, target = this.target, targetScreenOffset = this.targetScreenOffset, interpolationFactor) {
        this.inertialAlphaOffset = 0;
        this.inertialBetaOffset = 0;
        this.inertialRadiusOffset = 0;
        this.inertialPanningX = 0;
        this.inertialPanningY = 0;
        if (interpolationFactor != null) {
          this._currentInterpolationFactor = interpolationFactor;
        } else if (this.restoreStateInterpolationFactor !== 0) {
          this._currentInterpolationFactor = this.restoreStateInterpolationFactor;
        } else {
          this._currentInterpolationFactor = 0.1;
        }
        this._goalAlpha = CheckNaN(alpha, this._goalAlpha);
        this._goalBeta = CheckNaN(beta, this._goalBeta);
        this._goalRadius = CheckNaN(radius, this._goalRadius);
        this._goalTarget.set(CheckNaN(target.x, this._goalTarget.x), CheckNaN(target.y, this._goalTarget.y), CheckNaN(target.z, this._goalTarget.z));
        this._goalTargetScreenOffset.set(CheckNaN(targetScreenOffset.x, this._goalTargetScreenOffset.x), CheckNaN(targetScreenOffset.y, this._goalTargetScreenOffset.y));
        this._goalAlpha = Clamp(this._goalAlpha, this.lowerAlphaLimit ?? -Infinity, this.upperAlphaLimit ?? Infinity);
        this._goalBeta = Clamp(this._goalBeta, this.lowerBetaLimit ?? -Infinity, this.upperBetaLimit ?? Infinity);
        this._goalRadius = Clamp(this._goalRadius, this.lowerRadiusLimit ?? -Infinity, this.upperRadiusLimit ?? Infinity);
        this._goalTarget.y = Clamp(this._goalTarget.y, this.lowerTargetYLimit ?? -Infinity, Infinity);
        this._isInterpolating = true;
      }
      // Synchronized
      /** @internal */
      _isSynchronizedViewMatrix() {
        if (!super._isSynchronizedViewMatrix()) {
          return false;
        }
        return this._cache._target.equals(this._getTargetPosition()) && this._cache.alpha === this.alpha && this._cache.beta === this.beta && this._cache.radius === this.radius && this._cache.targetScreenOffset.equals(this.targetScreenOffset);
      }
      /**
       * Attached controls to the current camera.
       * @param ignored defines an ignored parameter kept for backward compatibility.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       * @param useCtrlForPanning  Defines whether ctrl is used for panning within the controls
       * @param panningMouseButton Defines whether panning is allowed through mouse click button
       */
      attachControl(ignored, noPreventDefault, useCtrlForPanning = true, panningMouseButton = 2) {
        const args = arguments;
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(args);
        this._useCtrlForPanning = useCtrlForPanning;
        this._panningMouseButton = panningMouseButton;
        if (typeof args[0] === "boolean") {
          if (args.length > 1) {
            this._useCtrlForPanning = args[1];
          }
          if (args.length > 2) {
            this._panningMouseButton = args[2];
          }
        }
        this.inputs.attachElement(noPreventDefault);
        this._reset = () => {
          this.inertialAlphaOffset = 0;
          this.inertialBetaOffset = 0;
          this.inertialRadiusOffset = 0;
          this.inertialPanningX = 0;
          this.inertialPanningY = 0;
        };
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        this.inputs.detachElement();
        if (this._reset) {
          this._reset();
        }
      }
      /** @internal */
      _checkInputs() {
        if (this._collisionTriggered) {
          return;
        }
        this.inputs.checkInputs();
        let hasUserInteractions = false;
        if (this.inertialAlphaOffset !== 0 || this.inertialBetaOffset !== 0 || this.inertialRadiusOffset !== 0) {
          hasUserInteractions = true;
          const directionModifier = this.invertRotation ? -1 : 1;
          const handednessMultiplier = this._calculateHandednessMultiplier();
          let inertialAlphaOffset = this.inertialAlphaOffset * handednessMultiplier;
          if (this.beta < 0) {
            inertialAlphaOffset *= -1;
          }
          this.alpha += inertialAlphaOffset * directionModifier;
          this.beta += this.inertialBetaOffset * directionModifier;
          this.radius -= this.inertialRadiusOffset;
          this.inertialAlphaOffset *= this.inertia;
          this.inertialBetaOffset *= this.inertia;
          this.inertialRadiusOffset *= this.inertia;
          if (Math.abs(this.inertialAlphaOffset) < this._rotationEpsilon) {
            this.inertialAlphaOffset = 0;
          }
          if (Math.abs(this.inertialBetaOffset) < this._rotationEpsilon) {
            this.inertialBetaOffset = 0;
          }
          if (Math.abs(this.inertialRadiusOffset) < this.speed * this._rotationEpsilon) {
            this.inertialRadiusOffset = 0;
          }
        }
        if (this.inertialPanningX !== 0 || this.inertialPanningY !== 0) {
          hasUserInteractions = true;
          const localDirection = new Vector3(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY);
          this._viewMatrix.invertToRef(this._cameraTransformMatrix);
          localDirection.multiplyInPlace(this.panningAxis);
          Vector3.TransformNormalToRef(localDirection, this._cameraTransformMatrix, this._transformedDirection);
          if (this.mapPanning) {
            const up = this.upVector;
            const right = Vector3.CrossToRef(this._transformedDirection, up, this._transformedDirection);
            Vector3.CrossToRef(up, right, this._transformedDirection);
          } else if (!this.panningAxis.y) {
            this._transformedDirection.y = 0;
          }
          if (!this._targetHost) {
            if (this.panningDistanceLimit) {
              this._transformedDirection.addInPlace(this._target);
              const distanceSquared = Vector3.DistanceSquared(this._transformedDirection, this.panningOriginTarget);
              if (distanceSquared <= this.panningDistanceLimit * this.panningDistanceLimit) {
                this._target.copyFrom(this._transformedDirection);
              }
            } else {
              if (this.parent) {
                const m = TmpVectors.Matrix[0];
                this.parent.getWorldMatrix().getRotationMatrixToRef(m);
                m.transposeToRef(m);
                Vector3.TransformCoordinatesToRef(this._transformedDirection, m, this._transformedDirection);
              }
              this._target.addInPlace(this._transformedDirection);
            }
          }
          this.inertialPanningX *= this.panningInertia;
          this.inertialPanningY *= this.panningInertia;
          const inertialPanningLimit = this.speed * this._panningEpsilon;
          if (Math.abs(this.inertialPanningX) < inertialPanningLimit) {
            this.inertialPanningX = 0;
          }
          if (Math.abs(this.inertialPanningY) < inertialPanningLimit) {
            this.inertialPanningY = 0;
          }
        }
        if (hasUserInteractions) {
          this.stopInterpolation();
        } else if (this._isInterpolating) {
          let isInterpolating = false;
          const dt = this._scene.getEngine().getDeltaTime() / 1e3;
          const t = 1 - Math.pow(2, -dt / this._currentInterpolationFactor);
          const goalRadius = CheckNaN(this._goalRadius, this.radius);
          if (!isNaN(this._goalTarget.x) || !isNaN(this._goalTarget.y) || !isNaN(this._goalTarget.z)) {
            const goalTarget = TmpVectors.Vector3[0].set(CheckNaN(this._goalTarget.x, this._target.x), CheckNaN(this._goalTarget.y, this._target.y), CheckNaN(this._goalTarget.z, this._target.z));
            Vector3.LerpToRef(this.target, goalTarget, t, this._target);
            if (Vector3.Distance(this.target, goalTarget) * 10 / goalRadius < Epsilon) {
              this._goalTarget.set(NaN, NaN, NaN);
              this.target.copyFrom(goalTarget);
              this.setTarget(this.target, false, true, true);
            } else {
              isInterpolating = true;
            }
          }
          if (!isNaN(this._goalAlpha) || !isNaN(this._goalBeta)) {
            const goalRotation = Quaternion.RotationAlphaBetaGammaToRef(CheckNaN(this._goalAlpha, this.alpha), CheckNaN(this._goalBeta, this.beta), 0, TmpVectors.Quaternion[0]);
            const currentRotation = Quaternion.RotationAlphaBetaGammaToRef(this.alpha, this.beta, 0, TmpVectors.Quaternion[1]);
            const newRotation = Quaternion.SlerpToRef(currentRotation, goalRotation, t, TmpVectors.Quaternion[2]);
            newRotation.normalize();
            const newAlphaBetaGamma = newRotation.toAlphaBetaGammaToRef(TmpVectors.Vector3[0]);
            this.alpha = newAlphaBetaGamma.x;
            this.beta = newAlphaBetaGamma.y;
            if (newRotation.isApprox(goalRotation, Epsilon / 5)) {
              this._goalAlpha = NaN;
              this._goalBeta = NaN;
              const goalAlphaBetaGamma = goalRotation.toAlphaBetaGammaToRef(TmpVectors.Vector3[0]);
              this.alpha = goalAlphaBetaGamma.x;
              this.beta = goalAlphaBetaGamma.y;
            } else {
              isInterpolating = true;
            }
          }
          if (!isNaN(this._goalRadius)) {
            this.radius += (goalRadius - this.radius) * t;
            if (Math.abs(goalRadius / this.radius - 1) < Epsilon) {
              this._goalRadius = NaN;
              this.radius = goalRadius;
            } else {
              isInterpolating = true;
            }
          }
          if (!isNaN(this._goalTargetScreenOffset.x) || !isNaN(this._goalTargetScreenOffset.y)) {
            const goalTargetScreenOffset = TmpVectors.Vector2[0].set(CheckNaN(this._goalTargetScreenOffset.x, this.targetScreenOffset.x), CheckNaN(this._goalTargetScreenOffset.y, this.targetScreenOffset.y));
            Vector2.LerpToRef(this.targetScreenOffset, goalTargetScreenOffset, t, this.targetScreenOffset);
            if (Vector2.Distance(this.targetScreenOffset, goalTargetScreenOffset) < Epsilon) {
              this._goalTargetScreenOffset.set(NaN, NaN);
              this.targetScreenOffset.copyFrom(goalTargetScreenOffset);
            } else {
              isInterpolating = true;
            }
          }
          this._isInterpolating = isInterpolating;
        }
        this._checkLimits();
        super._checkInputs();
      }
      _checkLimits() {
        if (this.lowerBetaLimit === null || this.lowerBetaLimit === void 0) {
          if (this.allowUpsideDown && this.beta > Math.PI) {
            this.beta = this.beta - 2 * Math.PI;
          }
        } else {
          if (this.beta < this.lowerBetaLimit) {
            this.beta = this.lowerBetaLimit;
          }
        }
        if (this.upperBetaLimit === null || this.upperBetaLimit === void 0) {
          if (this.allowUpsideDown && this.beta < -Math.PI) {
            this.beta = this.beta + 2 * Math.PI;
          }
        } else {
          if (this.beta > this.upperBetaLimit) {
            this.beta = this.upperBetaLimit;
          }
        }
        if (this.lowerAlphaLimit !== null && this.alpha < this.lowerAlphaLimit) {
          this.alpha = this.lowerAlphaLimit;
        }
        if (this.upperAlphaLimit !== null && this.alpha > this.upperAlphaLimit) {
          this.alpha = this.upperAlphaLimit;
        }
        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {
          this.radius = this.lowerRadiusLimit;
          this.inertialRadiusOffset = 0;
        }
        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {
          this.radius = this.upperRadiusLimit;
          this.inertialRadiusOffset = 0;
        }
        this.target.y = Math.max(this.target.y, this.lowerTargetYLimit);
      }
      /**
       * Rebuilds angles (alpha, beta) and radius from the give position and target
       */
      rebuildAnglesAndRadius() {
        this._position.subtractToRef(this._getTargetPosition(), this._computationVector);
        if (this._upVector.x !== 0 || this._upVector.y !== 1 || this._upVector.z !== 0) {
          Vector3.TransformCoordinatesToRef(this._computationVector, this._upToYMatrix, this._computationVector);
        }
        this.radius = this._computationVector.length();
        if (this.radius === 0) {
          this.radius = 1e-4;
        }
        const previousAlpha = this.alpha;
        this.alpha = ComputeAlpha(this._computationVector);
        this.beta = ComputeBeta(this._computationVector.y, this.radius);
        const alphaCorrectionTurns = Math.round((previousAlpha - this.alpha) / (2 * Math.PI));
        this.alpha += alphaCorrectionTurns * 2 * Math.PI;
        this._checkLimits();
      }
      /**
       * Use a position to define the current camera related information like alpha, beta and radius
       * @param position Defines the position to set the camera at
       */
      setPosition(position) {
        if (this._position.equals(position)) {
          return;
        }
        this._position.copyFrom(position);
        this.rebuildAnglesAndRadius();
      }
      /**
       * Defines the target the camera should look at.
       * This will automatically adapt alpha beta and radius to fit within the new target.
       * Please note that setting a target as a mesh will disable panning.
       * @param target Defines the new target as a Vector or a transform node
       * @param toBoundingCenter In case of a mesh target, defines whether to target the mesh position or its bounding information center
       * @param allowSamePosition If false, prevents reapplying the new computed position if it is identical to the current one (optim)
       * @param cloneAlphaBetaRadius If true, replicate the current setup (alpha, beta, radius) on the new target
       */
      setTarget(target, toBoundingCenter = false, allowSamePosition = false, cloneAlphaBetaRadius = false) {
        cloneAlphaBetaRadius = this.overrideCloneAlphaBetaRadius ?? cloneAlphaBetaRadius;
        if (target.computeWorldMatrix) {
          if (toBoundingCenter && target.getBoundingInfo) {
            this._targetBoundingCenter = target.getBoundingInfo().boundingBox.centerWorld.clone();
          } else {
            this._targetBoundingCenter = null;
          }
          target.computeWorldMatrix();
          this._targetHost = target;
          this._target = this._getTargetPosition();
          this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);
        } else {
          const newTarget = target;
          const currentTarget = this._getTargetPosition();
          if (currentTarget && !allowSamePosition && currentTarget.equals(newTarget)) {
            return;
          }
          this._targetHost = null;
          this._target = newTarget;
          this._targetBoundingCenter = null;
          this.onMeshTargetChangedObservable.notifyObservers(null);
        }
        if (!cloneAlphaBetaRadius) {
          this.rebuildAnglesAndRadius();
        }
      }
      /** @internal */
      _getViewMatrix() {
        const cosa = Math.cos(this.alpha);
        const sina = Math.sin(this.alpha);
        const cosb = Math.cos(this.beta);
        let sinb = Math.sin(this.beta);
        if (sinb === 0) {
          sinb = 1e-4;
        }
        if (this.radius === 0) {
          this.radius = 1e-4;
        }
        const target = this._getTargetPosition();
        this._computationVector.copyFromFloats(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb);
        if (this._upVector.x !== 0 || this._upVector.y !== 1 || this._upVector.z !== 0) {
          Vector3.TransformCoordinatesToRef(this._computationVector, this._yToUpMatrix, this._computationVector);
        }
        target.addToRef(this._computationVector, this._newPosition);
        if (this.getScene().collisionsEnabled && this.checkCollisions) {
          const coordinator = this.getScene().collisionCoordinator;
          if (!this._collider) {
            this._collider = coordinator.createCollider();
          }
          this._collider._radius = this.collisionRadius;
          this._newPosition.subtractToRef(this._position, this._collisionVelocity);
          this._collisionTriggered = true;
          coordinator.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
        } else {
          this._position.copyFrom(this._newPosition);
          let up = this.upVector;
          if (this.allowUpsideDown && sinb < 0) {
            up = up.negate();
          }
          this._computeViewMatrix(this._position, target, up);
          this._viewMatrix.addAtIndex(12, this.targetScreenOffset.x);
          this._viewMatrix.addAtIndex(13, this.targetScreenOffset.y);
        }
        this._currentTarget.copyFrom(target);
        return this._viewMatrix;
      }
      /**
       * Zooms on a mesh to be at the min distance where we could see it fully in the current viewport.
       * @param meshes Defines the mesh to zoom on
       * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)
       */
      zoomOn(meshes, doNotUpdateMaxZ = false) {
        meshes = meshes || this.getScene().meshes;
        const minMaxVector = Mesh.MinMax(meshes);
        let distance = this._calculateLowerRadiusFromModelBoundingSphere(minMaxVector.min, minMaxVector.max);
        distance = Math.max(Math.min(distance, this.upperRadiusLimit || Number.MAX_VALUE), this.lowerRadiusLimit || 0);
        this.radius = distance * this.zoomOnFactor;
        if (this.mode === Camera.ORTHOGRAPHIC_CAMERA) {
          const aspectRatio = this.getScene().getEngine().getAspectRatio(this);
          const orthoExtent = distance * this.zoomOnFactor / 2;
          this.orthoLeft = -orthoExtent * aspectRatio;
          this.orthoRight = orthoExtent * aspectRatio;
          this.orthoBottom = -orthoExtent;
          this.orthoTop = orthoExtent;
        }
        this.focusOn({ min: minMaxVector.min, max: minMaxVector.max, distance }, doNotUpdateMaxZ);
      }
      /**
       * Focus on a mesh or a bounding box. This adapts the target and maxRadius if necessary but does not update the current radius.
       * The target will be changed but the radius
       * @param meshesOrMinMaxVectorAndDistance Defines the mesh or bounding info to focus on
       * @param doNotUpdateMaxZ Defines whether or not maxZ should be updated whilst zooming on the mesh (this can happen if the mesh is big and the maxradius pretty small for instance)
       */
      focusOn(meshesOrMinMaxVectorAndDistance, doNotUpdateMaxZ = false) {
        let meshesOrMinMaxVector;
        let distance;
        if (meshesOrMinMaxVectorAndDistance.min === void 0) {
          const meshes = meshesOrMinMaxVectorAndDistance || this.getScene().meshes;
          meshesOrMinMaxVector = Mesh.MinMax(meshes);
          distance = Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);
        } else {
          const minMaxVectorAndDistance = meshesOrMinMaxVectorAndDistance;
          meshesOrMinMaxVector = minMaxVectorAndDistance;
          distance = minMaxVectorAndDistance.distance;
        }
        this._target = Mesh.Center(meshesOrMinMaxVector);
        if (!doNotUpdateMaxZ) {
          this.maxZ = distance * 2;
        }
      }
      /**
       * @override
       * Override Camera.createRigCamera
       * @param name the name of the camera
       * @param cameraIndex the index of the camera in the rig cameras array
       */
      createRigCamera(name13, cameraIndex) {
        let alphaShift = 0;
        switch (this.cameraRigMode) {
          case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
          case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
          case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
          case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:
          case Camera.RIG_MODE_VR:
            alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? 1 : -1);
            break;
          case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
            alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? -1 : 1);
            break;
        }
        const rigCam = new _ArcRotateCamera(name13, this.alpha + alphaShift, this.beta, this.radius, this._target, this.getScene());
        rigCam._cameraRigParams = {};
        rigCam.isRigCamera = true;
        rigCam.rigParent = this;
        rigCam.upVector = this.upVector;
        rigCam.mode = this.mode;
        rigCam.orthoLeft = this.orthoLeft;
        rigCam.orthoRight = this.orthoRight;
        rigCam.orthoBottom = this.orthoBottom;
        rigCam.orthoTop = this.orthoTop;
        return rigCam;
      }
      /**
       * @internal
       * @override
       * Override Camera._updateRigCameras
       */
      _updateRigCameras() {
        const camLeft = this._rigCameras[0];
        const camRight = this._rigCameras[1];
        camLeft.beta = camRight.beta = this.beta;
        switch (this.cameraRigMode) {
          case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
          case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
          case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
          case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:
          case Camera.RIG_MODE_VR:
            camLeft.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;
            camRight.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;
            break;
          case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
            camLeft.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;
            camRight.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;
            break;
        }
        super._updateRigCameras();
      }
      /**
       * @internal
       */
      _calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld, radiusScale = 1) {
        const boxVectorGlobalDiagonal = Vector3.Distance(minimumWorld, maximumWorld);
        const engine = this.getScene().getEngine();
        const aspectRatio = engine.getAspectRatio(this);
        const frustumSlopeY = Math.tan(this.fov / 2);
        const frustumSlopeX = frustumSlopeY * aspectRatio;
        const radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5;
        const radius = radiusWithoutFraming * radiusScale;
        const distanceForHorizontalFrustum = radius * Math.sqrt(1 + 1 / (frustumSlopeX * frustumSlopeX));
        const distanceForVerticalFrustum = radius * Math.sqrt(1 + 1 / (frustumSlopeY * frustumSlopeY));
        return Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);
      }
      /**
       * Destroy the camera and release the current resources hold by it.
       */
      dispose() {
        this.inputs.clear();
        super.dispose();
      }
      /**
       * Gets the current object class name.
       * @returns the class name
       */
      getClassName() {
        return "ArcRotateCamera";
      }
    };
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "alpha", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "beta", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "radius", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "overrideCloneAlphaBetaRadius", void 0);
    __decorate([
      serializeAsVector3("target")
    ], ArcRotateCamera.prototype, "_target", void 0);
    __decorate([
      serializeAsMeshReference("targetHost")
    ], ArcRotateCamera.prototype, "_targetHost", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "inertialAlphaOffset", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "inertialBetaOffset", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "inertialRadiusOffset", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "lowerAlphaLimit", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "upperAlphaLimit", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "lowerBetaLimit", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "upperBetaLimit", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "lowerRadiusLimit", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "upperRadiusLimit", void 0);
    __decorate([
      serialize()
      // eslint-disable-next-line @typescript-eslint/naming-convention
    ], ArcRotateCamera.prototype, "lowerTargetYLimit", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "inertialPanningX", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "inertialPanningY", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "pinchToPanMaxDistance", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "panningDistanceLimit", void 0);
    __decorate([
      serializeAsVector3()
    ], ArcRotateCamera.prototype, "panningOriginTarget", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "panningInertia", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "zoomToMouseLocation", null);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "zoomOnFactor", void 0);
    __decorate([
      serializeAsVector2()
    ], ArcRotateCamera.prototype, "targetScreenOffset", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "allowUpsideDown", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "useInputToRestoreState", void 0);
    __decorate([
      serialize()
    ], ArcRotateCamera.prototype, "restoreStateInterpolationFactor", void 0);
    RegisterClass("BABYLON.ArcRotateCamera", ArcRotateCamera);
  }
});

// node_modules/@babylonjs/core/Cameras/followCameraInputsManager.js
var FollowCameraInputsManager;
var init_followCameraInputsManager = __esm({
  "node_modules/@babylonjs/core/Cameras/followCameraInputsManager.js"() {
    init_logger();
    init_cameraInputsManager();
    init_followCameraKeyboardMoveInput();
    init_followCameraMouseWheelInput();
    init_followCameraPointersInput();
    FollowCameraInputsManager = class extends CameraInputsManager {
      /**
       * Instantiates a new FollowCameraInputsManager.
       * @param camera Defines the camera the inputs belong to
       */
      constructor(camera) {
        super(camera);
      }
      /**
       * Add keyboard input support to the input manager.
       * @returns the current input manager
       */
      addKeyboard() {
        this.add(new FollowCameraKeyboardMoveInput());
        return this;
      }
      /**
       * Add mouse wheel input support to the input manager.
       * @returns the current input manager
       */
      addMouseWheel() {
        this.add(new FollowCameraMouseWheelInput());
        return this;
      }
      /**
       * Add pointers input support to the input manager.
       * @returns the current input manager
       */
      addPointers() {
        this.add(new FollowCameraPointersInput());
        return this;
      }
      /**
       * Add orientation input support to the input manager.
       * @returns the current input manager
       */
      addVRDeviceOrientation() {
        Logger.Warn("DeviceOrientation support not yet implemented for FollowCamera.");
        return this;
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/followCamera.js
var FollowCamera, ArcFollowCamera;
var init_followCamera = __esm({
  "node_modules/@babylonjs/core/Cameras/followCamera.js"() {
    init_tslib_es6();
    init_decorators();
    init_tools();
    init_targetCamera();
    init_math_vector();
    init_node();
    init_followCameraInputsManager();
    init_typeStore();
    Node.AddNodeConstructor("FollowCamera", (name13, scene) => {
      return () => new FollowCamera(name13, Vector3.Zero(), scene);
    });
    Node.AddNodeConstructor("ArcFollowCamera", (name13, scene) => {
      return () => new ArcFollowCamera(name13, 0, 0, 1, null, scene);
    });
    FollowCamera = class extends TargetCamera {
      /**
       * Instantiates the follow camera.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera
       * @param name Define the name of the camera in the scene
       * @param position Define the position of the camera
       * @param scene Define the scene the camera belong to
       * @param lockedTarget Define the target of the camera
       */
      constructor(name13, position, scene, lockedTarget = null) {
        super(name13, position, scene);
        this.radius = 12;
        this.lowerRadiusLimit = null;
        this.upperRadiusLimit = null;
        this.rotationOffset = 0;
        this.lowerRotationOffsetLimit = null;
        this.upperRotationOffsetLimit = null;
        this.heightOffset = 4;
        this.lowerHeightOffsetLimit = null;
        this.upperHeightOffsetLimit = null;
        this.cameraAcceleration = 0.05;
        this.maxCameraSpeed = 20;
        this.lockedTarget = lockedTarget;
        this.inputs = new FollowCameraInputsManager(this);
        this.inputs.addKeyboard().addMouseWheel().addPointers();
      }
      _follow(cameraTarget) {
        if (!cameraTarget) {
          return;
        }
        const rotMatrix = TmpVectors.Matrix[0];
        cameraTarget.absoluteRotationQuaternion.toRotationMatrix(rotMatrix);
        const yRotation = Math.atan2(rotMatrix.m[8], rotMatrix.m[10]);
        const radians = Tools.ToRadians(this.rotationOffset) + yRotation;
        const targetPosition = cameraTarget.getAbsolutePosition();
        const targetX = targetPosition.x + Math.sin(radians) * this.radius;
        const targetZ = targetPosition.z + Math.cos(radians) * this.radius;
        const dx = targetX - this.position.x;
        const dy = targetPosition.y + this.heightOffset - this.position.y;
        const dz = targetZ - this.position.z;
        let vx = dx * this.cameraAcceleration * 2;
        let vy = dy * this.cameraAcceleration;
        let vz = dz * this.cameraAcceleration * 2;
        if (vx > this.maxCameraSpeed || vx < -this.maxCameraSpeed) {
          vx = vx < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;
        }
        if (vy > this.maxCameraSpeed || vy < -this.maxCameraSpeed) {
          vy = vy < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;
        }
        if (vz > this.maxCameraSpeed || vz < -this.maxCameraSpeed) {
          vz = vz < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;
        }
        this.position = new Vector3(this.position.x + vx, this.position.y + vy, this.position.z + vz);
        this.setTarget(targetPosition);
      }
      /**
       * Attached controls to the current camera.
       * @param ignored defines an ignored parameter kept for backward compatibility.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(ignored, noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        this.inputs.attachElement(noPreventDefault);
        this._reset = () => {
        };
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        this.inputs.detachElement();
        if (this._reset) {
          this._reset();
        }
      }
      /** @internal */
      _checkInputs() {
        this.inputs.checkInputs();
        this._checkLimits();
        super._checkInputs();
        if (this.lockedTarget) {
          this._follow(this.lockedTarget);
        }
      }
      _checkLimits() {
        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {
          this.radius = this.lowerRadiusLimit;
        }
        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {
          this.radius = this.upperRadiusLimit;
        }
        if (this.lowerHeightOffsetLimit !== null && this.heightOffset < this.lowerHeightOffsetLimit) {
          this.heightOffset = this.lowerHeightOffsetLimit;
        }
        if (this.upperHeightOffsetLimit !== null && this.heightOffset > this.upperHeightOffsetLimit) {
          this.heightOffset = this.upperHeightOffsetLimit;
        }
        if (this.lowerRotationOffsetLimit !== null && this.rotationOffset < this.lowerRotationOffsetLimit) {
          this.rotationOffset = this.lowerRotationOffsetLimit;
        }
        if (this.upperRotationOffsetLimit !== null && this.rotationOffset > this.upperRotationOffsetLimit) {
          this.rotationOffset = this.upperRotationOffsetLimit;
        }
      }
      /**
       * Gets the camera class name.
       * @returns the class name
       */
      getClassName() {
        return "FollowCamera";
      }
    };
    __decorate([
      serialize()
    ], FollowCamera.prototype, "radius", void 0);
    __decorate([
      serialize()
    ], FollowCamera.prototype, "lowerRadiusLimit", void 0);
    __decorate([
      serialize()
    ], FollowCamera.prototype, "upperRadiusLimit", void 0);
    __decorate([
      serialize()
    ], FollowCamera.prototype, "rotationOffset", void 0);
    __decorate([
      serialize()
    ], FollowCamera.prototype, "lowerRotationOffsetLimit", void 0);
    __decorate([
      serialize()
    ], FollowCamera.prototype, "upperRotationOffsetLimit", void 0);
    __decorate([
      serialize()
    ], FollowCamera.prototype, "heightOffset", void 0);
    __decorate([
      serialize()
    ], FollowCamera.prototype, "lowerHeightOffsetLimit", void 0);
    __decorate([
      serialize()
    ], FollowCamera.prototype, "upperHeightOffsetLimit", void 0);
    __decorate([
      serialize()
    ], FollowCamera.prototype, "cameraAcceleration", void 0);
    __decorate([
      serialize()
    ], FollowCamera.prototype, "maxCameraSpeed", void 0);
    __decorate([
      serializeAsMeshReference("lockedTargetId")
    ], FollowCamera.prototype, "lockedTarget", void 0);
    ArcFollowCamera = class extends TargetCamera {
      /**
       * Instantiates a new ArcFollowCamera
       * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera
       * @param name Define the name of the camera
       * @param alpha Define the rotation angle of the camera around the longitudinal axis
       * @param beta Define the rotation angle of the camera around the elevation axis
       * @param radius Define the radius of the camera from its target point
       * @param target Define the target of the camera
       * @param scene Define the scene the camera belongs to
       */
      constructor(name13, alpha, beta, radius, target, scene) {
        super(name13, Vector3.Zero(), scene);
        this.alpha = alpha;
        this.beta = beta;
        this.radius = radius;
        this._cartesianCoordinates = Vector3.Zero();
        this.setMeshTarget(target);
      }
      /**
       * Sets the mesh to follow with this camera.
       * @param target the target to follow
       */
      setMeshTarget(target) {
        this._meshTarget = target;
        this._follow();
      }
      _follow() {
        if (!this._meshTarget) {
          return;
        }
        this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta);
        this._cartesianCoordinates.y = this.radius * Math.sin(this.beta);
        this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);
        const targetPosition = this._meshTarget.getAbsolutePosition();
        this.position = targetPosition.add(this._cartesianCoordinates);
        this.setTarget(targetPosition);
      }
      /** @internal */
      _checkInputs() {
        super._checkInputs();
        this._follow();
      }
      /**
       * Returns the class name of the object.
       * It is mostly used internally for serialization purposes.
       * @returns the class name
       */
      getClassName() {
        return "ArcFollowCamera";
      }
    };
    RegisterClass("BABYLON.FollowCamera", FollowCamera);
    RegisterClass("BABYLON.ArcFollowCamera", ArcFollowCamera);
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicTexture.js
var init_engine_dynamicTexture = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicTexture.js"() {
    init_tools_functions();
    init_thinEngine();
    init_internalTexture();
    ThinEngine.prototype.createDynamicTexture = function(width, height, generateMipMaps, samplingMode) {
      const texture = new InternalTexture(
        this,
        4
        /* InternalTextureSource.Dynamic */
      );
      texture.baseWidth = width;
      texture.baseHeight = height;
      if (generateMipMaps) {
        width = this.needPOTTextures ? GetExponentOfTwo(width, this._caps.maxTextureSize) : width;
        height = this.needPOTTextures ? GetExponentOfTwo(height, this._caps.maxTextureSize) : height;
      }
      texture.width = width;
      texture.height = height;
      texture.isReady = false;
      texture.generateMipMaps = generateMipMaps;
      texture.samplingMode = samplingMode;
      this.updateTextureSamplingMode(samplingMode, texture);
      this._internalTexturesCache.push(texture);
      return texture;
    };
    ThinEngine.prototype.updateDynamicTexture = function(texture, source, invertY, premulAlpha = false, format, forceBindTexture = false, allowGPUOptimization = false) {
      if (!texture) {
        return;
      }
      const gl = this._gl;
      const target = gl.TEXTURE_2D;
      const wasPreviouslyBound = this._bindTextureDirectly(target, texture, true, forceBindTexture);
      this._unpackFlipY(invertY === void 0 ? texture.invertY : invertY);
      if (premulAlpha) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
      }
      const textureType = this._getWebGLTextureType(texture.type);
      const glformat = this._getInternalFormat(format ? format : texture.format);
      const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, glformat);
      gl.texImage2D(target, 0, internalFormat, glformat, textureType, source);
      if (texture.generateMipMaps) {
        gl.generateMipmap(target);
      }
      if (!wasPreviouslyBound) {
        this._bindTextureDirectly(target, null);
      }
      if (premulAlpha) {
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
      }
      if (format) {
        texture.format = format;
      }
      texture._dynamicTextureSource = source;
      texture._premulAlpha = premulAlpha;
      texture.invertY = invertY || false;
      texture.isReady = true;
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/dynamicTexture.js
var DynamicTexture;
var init_dynamicTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/dynamicTexture.js"() {
    init_logger();
    init_texture();
    init_engine_dynamicTexture();
    DynamicTexture = class _DynamicTexture extends Texture {
      /** @internal */
      constructor(name13, canvasOrSize, sceneOrOptions, generateMipMaps = false, samplingMode = 3, format = 5, invertY) {
        const isScene = !sceneOrOptions || sceneOrOptions._isScene;
        const scene = isScene ? sceneOrOptions : sceneOrOptions?.scene;
        const noMipmap = isScene ? !generateMipMaps : sceneOrOptions;
        super(null, scene, noMipmap, invertY, samplingMode, void 0, void 0, void 0, void 0, format);
        this.name = name13;
        this.wrapU = Texture.CLAMP_ADDRESSMODE;
        this.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._generateMipMaps = generateMipMaps;
        const engine = this._getEngine();
        if (!engine) {
          return;
        }
        if (canvasOrSize.getContext) {
          this._canvas = canvasOrSize;
          this._ownCanvas = false;
          this._texture = engine.createDynamicTexture(this._canvas.width, this._canvas.height, generateMipMaps, samplingMode);
        } else {
          this._canvas = engine.createCanvas(1, 1);
          this._ownCanvas = true;
          const optionsAsSize = canvasOrSize;
          if (optionsAsSize.width || optionsAsSize.width === 0) {
            this._texture = engine.createDynamicTexture(optionsAsSize.width, optionsAsSize.height, generateMipMaps, samplingMode);
          } else {
            this._texture = engine.createDynamicTexture(canvasOrSize, canvasOrSize, generateMipMaps, samplingMode);
          }
        }
        const textureSize = this.getSize();
        if (this._canvas.width !== textureSize.width) {
          this._canvas.width = textureSize.width;
        }
        if (this._canvas.height !== textureSize.height) {
          this._canvas.height = textureSize.height;
        }
        this._context = this._canvas.getContext("2d");
      }
      /**
       * Get the current class name of the texture useful for serialization or dynamic coding.
       * @returns "DynamicTexture"
       */
      getClassName() {
        return "DynamicTexture";
      }
      /**
       * Gets the current state of canRescale
       */
      get canRescale() {
        return true;
      }
      _recreate(textureSize) {
        this._canvas.width = textureSize.width;
        this._canvas.height = textureSize.height;
        this.releaseInternalTexture();
        this._texture = this._getEngine().createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);
      }
      /**
       * Scales the texture
       * @param ratio the scale factor to apply to both width and height
       */
      scale(ratio) {
        const textureSize = this.getSize();
        textureSize.width *= ratio;
        textureSize.height *= ratio;
        this._recreate(textureSize);
      }
      /**
       * Resizes the texture
       * @param width the new width
       * @param height the new height
       */
      scaleTo(width, height) {
        const textureSize = this.getSize();
        textureSize.width = width;
        textureSize.height = height;
        this._recreate(textureSize);
      }
      /**
       * Gets the context of the canvas used by the texture
       * @returns the canvas context of the dynamic texture
       */
      getContext() {
        return this._context;
      }
      /**
       * Clears the texture
       * @param clearColor Defines the clear color to use
       */
      clear(clearColor) {
        const size = this.getSize();
        if (clearColor) {
          this._context.fillStyle = clearColor;
        }
        this._context.clearRect(0, 0, size.width, size.height);
      }
      /**
       * Updates the texture
       * @param invertY defines the direction for the Y axis (default is true - y increases downwards)
       * @param premulAlpha defines if alpha is stored as premultiplied (default is false)
       * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature "allowGPUOptimizationsForGUI" being true)
       */
      update(invertY, premulAlpha = false, allowGPUOptimization = false) {
        if (!this._texture) {
          return;
        }
        this._getEngine().updateDynamicTexture(this._texture, this._canvas, invertY === void 0 ? true : invertY, premulAlpha, this._format || void 0, void 0, allowGPUOptimization);
      }
      /**
       * Draws text onto the texture
       * @param text defines the text to be drawn
       * @param x defines the placement of the text from the left
       * @param y defines the placement of the text from the top when invertY is true and from the bottom when false
       * @param font defines the font to be used with font-style, font-size, font-name
       * @param color defines the color used for the text
       * @param fillColor defines the color for the canvas, use null to not overwrite canvas (this blends with the background to replace, use the clear function)
       * @param invertY defines the direction for the Y axis (default is true - y increases downwards)
       * @param update defines whether texture is immediately update (default is true)
       */
      drawText(text, x, y, font, color, fillColor, invertY, update = true) {
        const size = this.getSize();
        if (fillColor) {
          this._context.fillStyle = fillColor;
          this._context.fillRect(0, 0, size.width, size.height);
        }
        this._context.font = font;
        if (x === null || x === void 0) {
          const textSize = this._context.measureText(text);
          x = (size.width - textSize.width) / 2;
        }
        if (y === null || y === void 0) {
          const fontSize = parseInt(font.replace(/\D/g, ""));
          y = size.height / 2 + fontSize / 3.65;
        }
        this._context.fillStyle = color || "";
        this._context.fillText(text, x, y);
        if (update) {
          this.update(invertY);
        }
      }
      /**
       * Disposes the dynamic texture.
       */
      dispose() {
        super.dispose();
        if (this._ownCanvas) {
          this._canvas?.remove?.();
        }
        this._canvas = null;
        this._context = null;
      }
      /**
       * Clones the texture
       * @returns the clone of the texture.
       */
      clone() {
        const scene = this.getScene();
        if (!scene) {
          return this;
        }
        const textureSize = this.getSize();
        const newTexture = new _DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);
        newTexture.hasAlpha = this.hasAlpha;
        newTexture.level = this.level;
        newTexture.wrapU = this.wrapU;
        newTexture.wrapV = this.wrapV;
        return newTexture;
      }
      /**
       * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized
       * @returns a serialized dynamic texture object
       */
      serialize() {
        const scene = this.getScene();
        if (scene && !scene.isReady()) {
          Logger.Warn("The scene must be ready before serializing the dynamic texture");
        }
        const serializationObject = super.serialize();
        if (_DynamicTexture._IsCanvasElement(this._canvas)) {
          serializationObject.base64String = this._canvas.toDataURL();
        }
        serializationObject.invertY = this._invertY;
        serializationObject.samplingMode = this.samplingMode;
        return serializationObject;
      }
      static _IsCanvasElement(canvas) {
        return canvas.toDataURL !== void 0;
      }
      /** @internal */
      _rebuild() {
        this.update();
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/groundMesh.js
var GroundMesh;
var init_groundMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/groundMesh.js"() {
    init_math_vector();
    init_buffer();
    init_mesh();
    Mesh._GroundMeshParser = (parsedMesh, scene) => {
      return GroundMesh.Parse(parsedMesh, scene);
    };
    GroundMesh = class _GroundMesh extends Mesh {
      constructor(name13, scene) {
        super(name13, scene);
        this.generateOctree = false;
      }
      /**
       * "GroundMesh"
       * @returns "GroundMesh"
       */
      getClassName() {
        return "GroundMesh";
      }
      /**
       * The minimum of x and y subdivisions
       */
      get subdivisions() {
        return Math.min(this._subdivisionsX, this._subdivisionsY);
      }
      /**
       * X subdivisions
       */
      get subdivisionsX() {
        return this._subdivisionsX;
      }
      /**
       * Y subdivisions
       */
      get subdivisionsY() {
        return this._subdivisionsY;
      }
      /**
       * This function will divide the mesh into submeshes and update an octree to help to select the right submeshes
       * for rendering, picking and collision computations. Please note that you must have a decent number of submeshes
       * to get performance improvements when using an octree.
       * @param chunksCount the number of submeshes the mesh will be divided into
       * @param octreeBlocksSize the maximum size of the octree blocks (Default: 32)
       */
      optimize(chunksCount, octreeBlocksSize = 32) {
        this._subdivisionsX = chunksCount;
        this._subdivisionsY = chunksCount;
        this.subdivide(chunksCount);
        const thisAsAny = this;
        if (thisAsAny.createOrUpdateSubmeshesOctree) {
          thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);
        }
      }
      /**
       * Returns a height (y) value in the World system :
       * the ground altitude at the coordinates (x, z) expressed in the World system.
       * @param x x coordinate
       * @param z z coordinate
       * @returns the ground y position if (x, z) are outside the ground surface.
       */
      getHeightAtCoordinates(x, z) {
        const world = this.getWorldMatrix();
        const invMat = TmpVectors.Matrix[5];
        world.invertToRef(invMat);
        const tmpVect = TmpVectors.Vector3[8];
        Vector3.TransformCoordinatesFromFloatsToRef(x, 0, z, invMat, tmpVect);
        x = tmpVect.x;
        z = tmpVect.z;
        if (x < this._minX || x >= this._maxX || z <= this._minZ || z > this._maxZ) {
          return this.position.y;
        }
        if (!this._heightQuads || this._heightQuads.length == 0) {
          this._initHeightQuads();
          this._computeHeightQuads();
        }
        const facet = this._getFacetAt(x, z);
        const y = -(facet.x * x + facet.z * z + facet.w) / facet.y;
        Vector3.TransformCoordinatesFromFloatsToRef(0, y, 0, world, tmpVect);
        return tmpVect.y;
      }
      /**
       * Returns a normalized vector (Vector3) orthogonal to the ground
       * at the ground coordinates (x, z) expressed in the World system.
       * @param x x coordinate
       * @param z z coordinate
       * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.
       */
      getNormalAtCoordinates(x, z) {
        const normal = new Vector3(0, 1, 0);
        this.getNormalAtCoordinatesToRef(x, z, normal);
        return normal;
      }
      /**
       * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground
       * at the ground coordinates (x, z) expressed in the World system.
       * Doesn't update the reference Vector3 if (x, z) are outside the ground surface.
       * @param x x coordinate
       * @param z z coordinate
       * @param ref vector to store the result
       * @returns the GroundMesh.
       */
      getNormalAtCoordinatesToRef(x, z, ref) {
        const world = this.getWorldMatrix();
        const tmpMat = TmpVectors.Matrix[5];
        world.invertToRef(tmpMat);
        const tmpVect = TmpVectors.Vector3[8];
        Vector3.TransformCoordinatesFromFloatsToRef(x, 0, z, tmpMat, tmpVect);
        x = tmpVect.x;
        z = tmpVect.z;
        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {
          return this;
        }
        if (!this._heightQuads || this._heightQuads.length == 0) {
          this._initHeightQuads();
          this._computeHeightQuads();
        }
        const facet = this._getFacetAt(x, z);
        Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);
        return this;
      }
      /**
       * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()
       * if the ground has been updated.
       * This can be used in the render loop.
       * @returns the GroundMesh.
       */
      updateCoordinateHeights() {
        if (!this._heightQuads || this._heightQuads.length == 0) {
          this._initHeightQuads();
        }
        this._computeHeightQuads();
        return this;
      }
      // Returns the element "facet" from the heightQuads array relative to (x, z) local coordinates
      _getFacetAt(x, z) {
        const col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);
        const row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);
        const quad = this._heightQuads[row * this._subdivisionsX + col];
        let facet;
        if (z < quad.slope.x * x + quad.slope.y) {
          facet = quad.facet1;
        } else {
          facet = quad.facet2;
        }
        return facet;
      }
      //  Creates and populates the heightMap array with "facet" elements :
      // a quad is two triangular facets separated by a slope, so a "facet" element is 1 slope + 2 facets
      // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h
      // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0
      // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0
      // Returns the GroundMesh.
      _initHeightQuads() {
        const subdivisionsX = this._subdivisionsX;
        const subdivisionsY = this._subdivisionsY;
        this._heightQuads = [];
        for (let row = 0; row < subdivisionsY; row++) {
          for (let col = 0; col < subdivisionsX; col++) {
            const quad = { slope: Vector2.Zero(), facet1: new Vector4(0, 0, 0, 0), facet2: new Vector4(0, 0, 0, 0) };
            this._heightQuads[row * subdivisionsX + col] = quad;
          }
        }
        return this;
      }
      // Compute each quad element values and update the heightMap array :
      // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h
      // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0
      // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0
      // Returns the GroundMesh.
      _computeHeightQuads() {
        const positions = this.getVerticesData(VertexBuffer.PositionKind);
        if (!positions) {
          return this;
        }
        const v1 = TmpVectors.Vector3[3];
        const v2 = TmpVectors.Vector3[2];
        const v3 = TmpVectors.Vector3[1];
        const v4 = TmpVectors.Vector3[0];
        const v1v2 = TmpVectors.Vector3[4];
        const v1v3 = TmpVectors.Vector3[5];
        const v1v4 = TmpVectors.Vector3[6];
        const norm1 = TmpVectors.Vector3[7];
        const norm2 = TmpVectors.Vector3[8];
        let i = 0;
        let j = 0;
        let k = 0;
        let cd = 0;
        let h = 0;
        let d1 = 0;
        let d2 = 0;
        const subdivisionsX = this._subdivisionsX;
        const subdivisionsY = this._subdivisionsY;
        for (let row = 0; row < subdivisionsY; row++) {
          for (let col = 0; col < subdivisionsX; col++) {
            i = col * 3;
            j = row * (subdivisionsX + 1) * 3;
            k = (row + 1) * (subdivisionsX + 1) * 3;
            v1.x = positions[j + i];
            v1.y = positions[j + i + 1];
            v1.z = positions[j + i + 2];
            v2.x = positions[j + i + 3];
            v2.y = positions[j + i + 4];
            v2.z = positions[j + i + 5];
            v3.x = positions[k + i];
            v3.y = positions[k + i + 1];
            v3.z = positions[k + i + 2];
            v4.x = positions[k + i + 3];
            v4.y = positions[k + i + 4];
            v4.z = positions[k + i + 5];
            cd = (v4.z - v1.z) / (v4.x - v1.x);
            h = v1.z - cd * v1.x;
            v2.subtractToRef(v1, v1v2);
            v3.subtractToRef(v1, v1v3);
            v4.subtractToRef(v1, v1v4);
            Vector3.CrossToRef(v1v4, v1v3, norm1);
            Vector3.CrossToRef(v1v2, v1v4, norm2);
            norm1.normalize();
            norm2.normalize();
            d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);
            d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);
            const quad = this._heightQuads[row * subdivisionsX + col];
            quad.slope.copyFromFloats(cd, h);
            quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);
            quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);
          }
        }
        return this;
      }
      /**
       * Serializes this ground mesh
       * @param serializationObject object to write serialization to
       */
      serialize(serializationObject) {
        super.serialize(serializationObject);
        serializationObject.subdivisionsX = this._subdivisionsX;
        serializationObject.subdivisionsY = this._subdivisionsY;
        serializationObject.minX = this._minX;
        serializationObject.maxX = this._maxX;
        serializationObject.minZ = this._minZ;
        serializationObject.maxZ = this._maxZ;
        serializationObject.width = this._width;
        serializationObject.height = this._height;
      }
      /**
       * Parses a serialized ground mesh
       * @param parsedMesh the serialized mesh
       * @param scene the scene to create the ground mesh in
       * @returns the created ground mesh
       */
      static Parse(parsedMesh, scene) {
        const result = new _GroundMesh(parsedMesh.name, scene);
        result._subdivisionsX = parsedMesh.subdivisionsX || 1;
        result._subdivisionsY = parsedMesh.subdivisionsY || 1;
        result._minX = parsedMesh.minX;
        result._maxX = parsedMesh.maxX;
        result._minZ = parsedMesh.minZ;
        result._maxZ = parsedMesh.maxZ;
        result._width = parsedMesh.width;
        result._height = parsedMesh.height;
        return result;
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/groundBuilder.js
function CreateGroundVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let row, col;
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const subdivisionsX = (options.subdivisionsX || options.subdivisions || 1) | 0;
  const subdivisionsY = (options.subdivisionsY || options.subdivisions || 1) | 0;
  for (row = 0; row <= subdivisionsY; row++) {
    for (col = 0; col <= subdivisionsX; col++) {
      const position = new Vector3(col * width / subdivisionsX - width / 2, 0, (subdivisionsY - row) * height / subdivisionsY - height / 2);
      const normal = new Vector3(0, 1, 0);
      positions.push(position.x, position.y, position.z);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(col / subdivisionsX, useOpenGLOrientationForUV ? row / subdivisionsY : 1 - row / subdivisionsY);
    }
  }
  for (row = 0; row < subdivisionsY; row++) {
    for (col = 0; col < subdivisionsX; col++) {
      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));
      indices.push(col + 1 + row * (subdivisionsX + 1));
      indices.push(col + row * (subdivisionsX + 1));
      indices.push(col + (row + 1) * (subdivisionsX + 1));
      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));
      indices.push(col + row * (subdivisionsX + 1));
    }
  }
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateTiledGroundVertexData(options) {
  const xmin = options.xmin !== void 0 && options.xmin !== null ? options.xmin : -1;
  const zmin = options.zmin !== void 0 && options.zmin !== null ? options.zmin : -1;
  const xmax = options.xmax !== void 0 && options.xmax !== null ? options.xmax : 1;
  const zmax = options.zmax !== void 0 && options.zmax !== null ? options.zmax : 1;
  const subdivisions = options.subdivisions || { w: 1, h: 1 };
  const precision = options.precision || { w: 1, h: 1 };
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let row, col, tileRow, tileCol;
  subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;
  subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;
  precision.w = precision.w < 1 ? 1 : precision.w;
  precision.h = precision.h < 1 ? 1 : precision.h;
  const tileSize = {
    w: (xmax - xmin) / subdivisions.w,
    h: (zmax - zmin) / subdivisions.h
  };
  function applyTile(xTileMin, zTileMin, xTileMax, zTileMax) {
    const base = positions.length / 3;
    const rowLength = precision.w + 1;
    for (row = 0; row < precision.h; row++) {
      for (col = 0; col < precision.w; col++) {
        const square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];
        indices.push(square[1]);
        indices.push(square[2]);
        indices.push(square[3]);
        indices.push(square[0]);
        indices.push(square[1]);
        indices.push(square[3]);
      }
    }
    const position = Vector3.Zero();
    const normal = new Vector3(0, 1, 0);
    for (row = 0; row <= precision.h; row++) {
      position.z = row * (zTileMax - zTileMin) / precision.h + zTileMin;
      for (col = 0; col <= precision.w; col++) {
        position.x = col * (xTileMax - xTileMin) / precision.w + xTileMin;
        position.y = 0;
        positions.push(position.x, position.y, position.z);
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(col / precision.w, row / precision.h);
      }
    }
  }
  for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {
    for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {
      applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);
    }
  }
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateGroundFromHeightMapVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let row, col;
  const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);
  const alphaFilter = options.alphaFilter || 0;
  let invert = false;
  if (options.minHeight > options.maxHeight) {
    invert = true;
    const temp = options.maxHeight;
    options.maxHeight = options.minHeight;
    options.minHeight = temp;
  }
  for (row = 0; row <= options.subdivisions; row++) {
    for (col = 0; col <= options.subdivisions; col++) {
      const position = new Vector3(col * options.width / options.subdivisions - options.width / 2, 0, (options.subdivisions - row) * options.height / options.subdivisions - options.height / 2);
      const heightMapX = (position.x + options.width / 2) / options.width * (options.bufferWidth - 1) | 0;
      const heightMapY = (1 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1) | 0;
      const pos = (heightMapX + heightMapY * options.bufferWidth) * 4;
      let r = options.buffer[pos] / 255;
      let g = options.buffer[pos + 1] / 255;
      let b = options.buffer[pos + 2] / 255;
      const a = options.buffer[pos + 3] / 255;
      if (invert) {
        r = 1 - r;
        g = 1 - g;
        b = 1 - b;
      }
      const gradient = r * filter.r + g * filter.g + b * filter.b;
      if (a >= alphaFilter) {
        position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;
      } else {
        position.y = options.minHeight - Epsilon;
      }
      if (options.heightBuffer) {
        options.heightBuffer[row * (options.subdivisions + 1) + col] = position.y;
      }
      positions.push(position.x, position.y, position.z);
      normals.push(0, 0, 0);
      uvs.push(col / options.subdivisions, 1 - row / options.subdivisions);
    }
  }
  for (row = 0; row < options.subdivisions; row++) {
    for (col = 0; col < options.subdivisions; col++) {
      const idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);
      const idx2 = col + 1 + row * (options.subdivisions + 1);
      const idx3 = col + row * (options.subdivisions + 1);
      const idx4 = col + (row + 1) * (options.subdivisions + 1);
      const isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;
      const isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;
      const isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;
      if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {
        indices.push(idx1);
        indices.push(idx2);
        indices.push(idx3);
      }
      const isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;
      if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {
        indices.push(idx4);
        indices.push(idx1);
        indices.push(idx3);
      }
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateGround(name13, options = {}, scene) {
  const ground = new GroundMesh(name13, scene);
  ground._setReady(false);
  ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;
  ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;
  ground._width = options.width || 1;
  ground._height = options.height || 1;
  ground._maxX = ground._width / 2;
  ground._maxZ = ground._height / 2;
  ground._minX = -ground._maxX;
  ground._minZ = -ground._maxZ;
  const vertexData = CreateGroundVertexData(options);
  vertexData.applyToMesh(ground, options.updatable);
  ground._setReady(true);
  return ground;
}
function CreateTiledGround(name13, options, scene = null) {
  const tiledGround = new Mesh(name13, scene);
  const vertexData = CreateTiledGroundVertexData(options);
  vertexData.applyToMesh(tiledGround, options.updatable);
  return tiledGround;
}
function CreateGroundFromHeightMap(name13, url, options = {}, scene = null) {
  const width = options.width || 10;
  const height = options.height || 10;
  const subdivisions = options.subdivisions || 1 | 0;
  const minHeight = options.minHeight || 0;
  const maxHeight = options.maxHeight || 1;
  const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);
  const alphaFilter = options.alphaFilter || 0;
  const updatable = options.updatable;
  const onReady = options.onReady;
  scene = scene || EngineStore.LastCreatedScene;
  const ground = new GroundMesh(name13, scene);
  ground._subdivisionsX = subdivisions;
  ground._subdivisionsY = subdivisions;
  ground._width = width;
  ground._height = height;
  ground._maxX = ground._width / 2;
  ground._maxZ = ground._height / 2;
  ground._minX = -ground._maxX;
  ground._minZ = -ground._maxZ;
  ground._setReady(false);
  let heightBuffer;
  if (options.passHeightBufferInCallback) {
    heightBuffer = new Float32Array((subdivisions + 1) * (subdivisions + 1));
  }
  const onBufferLoaded = (buffer, bufferWidth, bufferHeight) => {
    const vertexData = CreateGroundFromHeightMapVertexData({
      width,
      height,
      subdivisions,
      minHeight,
      maxHeight,
      colorFilter: filter,
      buffer,
      bufferWidth,
      bufferHeight,
      alphaFilter,
      heightBuffer
    });
    vertexData.applyToMesh(ground, updatable);
    if (onReady) {
      onReady(ground, heightBuffer);
    }
    ground._setReady(true);
  };
  if (typeof url === "string") {
    const onload = (img) => {
      const bufferWidth = img.width;
      const bufferHeight = img.height;
      if (scene.isDisposed) {
        return;
      }
      const buffer = scene?.getEngine().resizeImageBitmap(img, bufferWidth, bufferHeight);
      onBufferLoaded(buffer, bufferWidth, bufferHeight);
    };
    Tools.LoadImage(url, onload, options.onError ? options.onError : () => {
    }, scene.offlineProvider);
  } else {
    onBufferLoaded(url.data, url.width, url.height);
  }
  return ground;
}
var GroundBuilder;
var init_groundBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/groundBuilder.js"() {
    init_math_vector();
    init_math_color();
    init_mesh();
    init_mesh_vertexData();
    init_groundMesh();
    init_tools();
    init_engineStore();
    init_math_constants();
    init_compatibilityOptions();
    GroundBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateGround,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateGroundFromHeightMap,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateTiledGround
    };
    VertexData.CreateGround = CreateGroundVertexData;
    VertexData.CreateTiledGround = CreateTiledGroundVertexData;
    VertexData.CreateGroundFromHeightMap = CreateGroundFromHeightMapVertexData;
    Mesh.CreateGround = (name13, width, height, subdivisions, scene, updatable) => {
      const options = {
        width,
        height,
        subdivisions,
        updatable
      };
      return CreateGround(name13, options, scene);
    };
    Mesh.CreateTiledGround = (name13, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) => {
      const options = {
        xmin,
        zmin,
        xmax,
        zmax,
        subdivisions,
        precision,
        updatable
      };
      return CreateTiledGround(name13, options, scene);
    };
    Mesh.CreateGroundFromHeightMap = (name13, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) => {
      const options = {
        width,
        height,
        subdivisions,
        minHeight,
        maxHeight,
        updatable,
        onReady,
        alphaFilter
      };
      return CreateGroundFromHeightMap(name13, url, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/torusBuilder.js
function CreateTorusVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  const diameter = options.diameter || 1;
  const thickness = options.thickness || 0.5;
  const tessellation = (options.tessellation || 16) | 0;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const stride = tessellation + 1;
  for (let i = 0; i <= tessellation; i++) {
    const u = i / tessellation;
    const outerAngle = i * Math.PI * 2 / tessellation - Math.PI / 2;
    const transform = Matrix.Translation(diameter / 2, 0, 0).multiply(Matrix.RotationY(outerAngle));
    for (let j = 0; j <= tessellation; j++) {
      const v = 1 - j / tessellation;
      const innerAngle = j * Math.PI * 2 / tessellation + Math.PI;
      const dx = Math.cos(innerAngle);
      const dy = Math.sin(innerAngle);
      let normal = new Vector3(dx, dy, 0);
      let position = normal.scale(thickness / 2);
      const textureCoordinate = new Vector2(u, v);
      position = Vector3.TransformCoordinates(position, transform);
      normal = Vector3.TransformNormal(normal, transform);
      positions.push(position.x, position.y, position.z);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(textureCoordinate.x, useOpenGLOrientationForUV ? 1 - textureCoordinate.y : textureCoordinate.y);
      const nextI = (i + 1) % stride;
      const nextJ = (j + 1) % stride;
      indices.push(i * stride + j);
      indices.push(i * stride + nextJ);
      indices.push(nextI * stride + j);
      indices.push(i * stride + nextJ);
      indices.push(nextI * stride + nextJ);
      indices.push(nextI * stride + j);
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateTorus(name13, options = {}, scene) {
  const torus = new Mesh(name13, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  torus._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateTorusVertexData(options);
  vertexData.applyToMesh(torus, options.updatable);
  return torus;
}
var TorusBuilder;
var init_torusBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/torusBuilder.js"() {
    init_math_vector();
    init_mesh();
    init_mesh_vertexData();
    init_compatibilityOptions();
    TorusBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateTorus
    };
    VertexData.CreateTorus = CreateTorusVertexData;
    Mesh.CreateTorus = (name13, diameter, thickness, tessellation, scene, updatable, sideOrientation) => {
      const options = {
        diameter,
        thickness,
        tessellation,
        sideOrientation,
        updatable
      };
      return CreateTorus(name13, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Cameras/geospatialCameraInputsManager.js
var GeospatialCameraInputsManager;
var init_geospatialCameraInputsManager = __esm({
  "node_modules/@babylonjs/core/Cameras/geospatialCameraInputsManager.js"() {
    init_cameraInputsManager();
    init_geospatialCameraPointersInput();
    init_geospatialCameraMouseWheelInput();
    init_geospatialCameraKeyboardInput();
    GeospatialCameraInputsManager = class extends CameraInputsManager {
      /**
       * Instantiates a new GeospatialCameraInputsManager.
       * @param camera Defines the camera the inputs belong to
       */
      constructor(camera) {
        super(camera);
      }
      /**
       * Add mouse input support to the input manager
       * @returns the current input manager
       */
      addMouse() {
        this.add(new GeospatialCameraPointersInput());
        return this;
      }
      /**
       * Add mouse wheel input support to the input manager
       * @returns the current input manager
       */
      addMouseWheel() {
        this.add(new GeospatialCameraMouseWheelInput());
        return this;
      }
      /**
       * Add mouse wheel input support to the input manager
       * @returns the current input manager
       */
      addKeyboard() {
        this.add(new GeospatialCameraKeyboardInput());
        return this;
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/Limits/geospatialLimits.js
var GeospatialLimits;
var init_geospatialLimits = __esm({
  "node_modules/@babylonjs/core/Cameras/Limits/geospatialLimits.js"() {
    init_math_constants();
    init_math_vector();
    init_math_scalar_functions();
    GeospatialLimits = class {
      /**
       * @param planetRadius The radius of the planet
       */
      constructor(planetRadius) {
        this._radiusMin = 10;
        this._radiusMax = Infinity;
        this.pitchMin = Epsilon;
        this.pitchMax = Math.PI / 2 - 0.01;
        this.pitchDisabledRadiusScale = new Vector2(2, 4);
        this.yawMin = -Infinity;
        this.yawMax = Infinity;
        this.pinchToPanMax = 20;
        this._planetRadius = planetRadius;
        this.radiusMax = planetRadius * 4;
      }
      get radiusMin() {
        return this._radiusMin;
      }
      /**
       * Sets the minimum radius
       */
      set radiusMin(value) {
        this._radiusMin = value;
      }
      get radiusMax() {
        return this._radiusMax;
      }
      /**
       * Sets the maximum radius
       */
      set radiusMax(value) {
        this._radiusMax = value;
      }
      /**
       * Gets the planet radius used for altitude/radius conversions
       */
      get planetRadius() {
        return this._planetRadius;
      }
      /** Sets the planet radius and updates the radius limits to maintain current altitude */
      set planetRadius(value) {
        this._planetRadius = value;
      }
      /**
       * Clamps a zoom distance to respect the radius limits.
       * @param zoomDistance The requested zoom distance (positive = zoom in, negative = zoom out)
       * @param currentRadius The current camera radius
       * @param distanceToTarget Optional distance to the zoom target point (used for zoom-in clamping)
       * @returns The clamped zoom distance
       */
      clampZoomDistance(zoomDistance, currentRadius, distanceToTarget) {
        if (zoomDistance > 0) {
          const maxZoomIn = (distanceToTarget ?? currentRadius) - this._radiusMin;
          return Math.min(zoomDistance, Math.max(0, maxZoomIn));
        } else {
          const maxZoomOut = this._radiusMax - currentRadius;
          return Math.max(zoomDistance, -Math.max(0, maxZoomOut));
        }
      }
      /**
       * Computes the effective maximum pitch based on the current camera radius.
       * When pitchDisabledRadiusScale is set, pitch is interpolated from pitchMax to pitchMin
       * as the camera zooms out from x*planetRadius to y*planetRadius.
       * @param currentRadius The current camera radius (distance from planet center)
       * @returns The effective maximum pitch angle
       */
      getEffectivePitchMax(currentRadius) {
        if (!this.pitchDisabledRadiusScale) {
          return this.pitchMax;
        }
        const fullPitchRadius = this.pitchDisabledRadiusScale.x * this._planetRadius;
        const noPitchRadius = this.pitchDisabledRadiusScale.y * this._planetRadius;
        if (currentRadius <= fullPitchRadius) {
          return this.pitchMax;
        } else if (currentRadius >= noPitchRadius) {
          return this.pitchMin;
        } else {
          const t = (currentRadius - fullPitchRadius) / (noPitchRadius - fullPitchRadius);
          const clampedT = Clamp(t, 0, 1);
          return this.pitchMax * (1 - clampedT) + this.pitchMin * clampedT;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/cameraMovement.js
var FrameDurationAt60FPS, CameraMovement;
var init_cameraMovement = __esm({
  "node_modules/@babylonjs/core/Cameras/cameraMovement.js"() {
    init_math_vector();
    init_math_constants();
    FrameDurationAt60FPS = 1e3 / 60;
    CameraMovement = class {
      constructor(scene, _cameraPosition, _behavior) {
        this._cameraPosition = _cameraPosition;
        this._behavior = _behavior;
        this.activeInput = false;
        this.zoomSpeed = 1;
        this.panSpeed = 1;
        this.rotationXSpeed = 1;
        this.rotationYSpeed = 1;
        this._zoomSpeedMultiplier = 1;
        this._panSpeedMultiplier = 1;
        this.zoomInertia = 0.9;
        this.panInertia = 0.9;
        this.rotationInertia = 0.9;
        this.zoomAccumulatedPixels = 0;
        this.panAccumulatedPixels = new Vector3();
        this.rotationAccumulatedPixels = new Vector3();
        this.zoomDeltaCurrentFrame = 0;
        this.panDeltaCurrentFrame = Vector3.Zero();
        this.rotationDeltaCurrentFrame = Vector3.Zero();
        this._zoomVelocity = 0;
        this._panVelocity = new Vector3();
        this._rotationVelocity = new Vector3();
        this._prevFrameTimeMs = FrameDurationAt60FPS;
        this._scene = scene;
      }
      /**
       * When called, will take the accumulated pixel deltas set by input classes and convert them into current frame deltas, stored in currentFrameMovementDelta properties
       * Takes speed, scaling, inertia, and framerate into account to ensure smooth movement
       * Zeros out pixelDeltas before returning
       */
      computeCurrentFrameDeltas() {
        const deltaTimeMs = this._scene.getEngine().getDeltaTime();
        this.panDeltaCurrentFrame.setAll(0);
        this.rotationDeltaCurrentFrame.setAll(0);
        this.zoomDeltaCurrentFrame = 0;
        const hasUserInput = this.panAccumulatedPixels.lengthSquared() > 0 || this.rotationAccumulatedPixels.lengthSquared() > 0 || this.zoomAccumulatedPixels !== 0;
        if (hasUserInput && this._behavior?.isInterpolating) {
          this._behavior.stopAllAnimations();
        }
        this._panVelocity.copyFromFloats(this._calculateCurrentVelocity(this._panVelocity.x, this.panAccumulatedPixels.x, this.panInertia), this._calculateCurrentVelocity(this._panVelocity.y, this.panAccumulatedPixels.y, this.panInertia), this._calculateCurrentVelocity(this._panVelocity.z, this.panAccumulatedPixels.z, this.panInertia));
        this._panVelocity.scaleToRef(this.panSpeed * this._panSpeedMultiplier * deltaTimeMs, this.panDeltaCurrentFrame);
        this._rotationVelocity.copyFromFloats(this._calculateCurrentVelocity(this._rotationVelocity.x, this.rotationAccumulatedPixels.x, this.rotationInertia), this._calculateCurrentVelocity(this._rotationVelocity.y, this.rotationAccumulatedPixels.y, this.rotationInertia), this._calculateCurrentVelocity(this._rotationVelocity.z, this.rotationAccumulatedPixels.z, this.rotationInertia));
        this.rotationDeltaCurrentFrame.copyFromFloats(this._rotationVelocity.x * this.rotationXSpeed * deltaTimeMs, this._rotationVelocity.y * this.rotationYSpeed * deltaTimeMs, this._rotationVelocity.z * this.rotationYSpeed * deltaTimeMs);
        this._zoomVelocity = this._calculateCurrentVelocity(this._zoomVelocity, this.zoomAccumulatedPixels, this.zoomInertia);
        this.zoomDeltaCurrentFrame = this._zoomVelocity * (this.zoomSpeed * this._zoomSpeedMultiplier) * deltaTimeMs;
        this._prevFrameTimeMs = deltaTimeMs;
        this.zoomAccumulatedPixels = 0;
        this.panAccumulatedPixels.setAll(0);
        this.rotationAccumulatedPixels.setAll(0);
      }
      get isInterpolating() {
        return !!this._behavior?.isInterpolating;
      }
      _calculateCurrentVelocity(velocityRef, pixelDelta, inertialDecayFactor) {
        let inputVelocity = velocityRef;
        const deltaTimeMs = this._scene.getEngine().getDeltaTime();
        if (pixelDelta !== 0 || this.activeInput) {
          inputVelocity = pixelDelta / deltaTimeMs;
        } else if (!this.activeInput && inputVelocity !== 0) {
          const frameIndependentDecay = Math.pow(inertialDecayFactor, this._prevFrameTimeMs / FrameDurationAt60FPS);
          inputVelocity *= frameIndependentDecay;
          if (Math.abs(inputVelocity) <= Epsilon) {
            inputVelocity = 0;
          }
        }
        return inputVelocity;
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/geospatialCameraMovement.js
function ClampCenterFromPolesInPlace(center) {
  const sineOfSphericalLatitudeLimit = 0.998749218;
  const centerMagnitude = center.length();
  if (centerMagnitude > Epsilon) {
    const sineSphericalLat = centerMagnitude === 0 ? 0 : center.z / centerMagnitude;
    if (Math.abs(sineSphericalLat) > sineOfSphericalLatitudeLimit) {
      const sineOfClampedSphericalLat = Clamp(sineSphericalLat, -sineOfSphericalLatitudeLimit, sineOfSphericalLatitudeLimit);
      const cosineOfClampedSphericalLat = Math.sqrt(1 - sineOfClampedSphericalLat * sineOfClampedSphericalLat);
      const longitude = Math.atan2(center.y, center.x);
      const newX = centerMagnitude * Math.cos(longitude) * cosineOfClampedSphericalLat;
      const newY = centerMagnitude * Math.sin(longitude) * cosineOfClampedSphericalLat;
      const newZ = centerMagnitude * sineOfClampedSphericalLat;
      center.set(newX, newY, newZ);
    }
  }
  return center;
}
function IntersectRayWithPlaneToRef(ray, plane, ref) {
  const dist = ray.intersectsPlane(plane);
  if (dist !== null && dist >= 0) {
    ray.origin.addToRef(ray.direction.scaleToRef(dist, TmpVectors.Vector3[0]), ref);
    return true;
  }
  return false;
}
function ComputeLocalBasisToRefs(worldPos, refEast, refNorth, refUp) {
  refUp.copyFrom(worldPos).normalize();
  const worldNorth = Vector3.LeftHandedForwardReadOnly;
  Vector3.CrossToRef(worldNorth, refUp, refEast);
  if (refEast.lengthSquared() < Epsilon) {
    Vector3.CrossToRef(Vector3.Right(), refUp, refEast);
  }
  refEast.normalize();
  Vector3.CrossToRef(refUp, refEast, refNorth);
  refNorth.normalize();
}
var GeospatialCameraMovement;
var init_geospatialCameraMovement = __esm({
  "node_modules/@babylonjs/core/Cameras/geospatialCameraMovement.js"() {
    init_cameraMovement();
    init_math_constants();
    init_math_vector();
    init_math_plane();
    init_ray();
    init_math_vector_functions();
    init_math_scalar_functions();
    GeospatialCameraMovement = class extends CameraMovement {
      constructor(scene, limits, cameraPosition, _cameraCenter, _cameraLookAt, pickPredicate, behavior) {
        super(scene, cameraPosition, behavior);
        this.limits = limits;
        this._cameraCenter = _cameraCenter;
        this._cameraLookAt = _cameraLookAt;
        this.zoomToCursor = true;
        this._hitPointRadius = void 0;
        this._dragPlane = new Plane(0, 0, 0, 0);
        this._dragPlaneNormal = Vector3.Zero();
        this._dragPlaneOriginPointEcef = Vector3.Zero();
        this._dragPlaneHitPointLocal = Vector3.Zero();
        this._previousDragPlaneHitPointLocal = Vector3.Zero();
        this.pickPredicate = pickPredicate;
        this._tempPickingRay = new Ray(this._cameraPosition, this._cameraLookAt);
        this.panInertia = 0;
        this.rotationInertia = 0;
        this.rotationXSpeed = Math.PI / 500;
        this.rotationYSpeed = Math.PI / 500;
        this.zoomSpeed = 2;
      }
      startDrag(pointerX, pointerY) {
        const pickResult = this._scene.pick(pointerX, pointerY, this.pickPredicate);
        if (pickResult.pickedPoint && pickResult.ray) {
          this._hitPointRadius = pickResult.pickedPoint.length();
          this._recalculateDragPlaneHitPoint(this._hitPointRadius, pickResult.ray, TmpVectors.Matrix[0]);
          this._previousDragPlaneHitPointLocal.copyFrom(this._dragPlaneHitPointLocal);
        } else {
          this._hitPointRadius = void 0;
        }
      }
      stopDrag() {
        this._hitPointRadius = void 0;
      }
      /**
       * The previous drag plane hit point in local space is stored to compute the movement delta.
       * As the drag movement occurs, we will continuously recalculate this point. The delta between the previous and current hit points is the delta we will apply to the camera's localtranslation
       * @param hitPointRadius The distance between the world origin (center of globe) and the initial drag hit point
       * @param ray The ray from the camera to the new cursor location
       * @param localToEcefResult The matrix to convert from local to ECEF space
       */
      _recalculateDragPlaneHitPoint(hitPointRadius, ray, localToEcefResult) {
        this._cameraPosition.normalizeToRef(this._dragPlaneNormal);
        this._dragPlaneNormal.scaleToRef(hitPointRadius, this._dragPlaneOriginPointEcef);
        ComputeLocalBasisToRefs(this._dragPlaneOriginPointEcef, TmpVectors.Vector3[0], TmpVectors.Vector3[1], TmpVectors.Vector3[2]);
        const localToEcef = Matrix.FromXYZAxesToRef(TmpVectors.Vector3[0], TmpVectors.Vector3[1], TmpVectors.Vector3[2], localToEcefResult);
        localToEcef.setTranslationFromFloats(this._dragPlaneOriginPointEcef.x, this._dragPlaneOriginPointEcef.y, this._dragPlaneOriginPointEcef.z);
        const ecefToLocal = localToEcef.invertToRef(TmpVectors.Matrix[1]);
        Plane.FromPositionAndNormalToRef(this._dragPlaneOriginPointEcef, this._dragPlaneNormal, this._dragPlane);
        if (IntersectRayWithPlaneToRef(ray, this._dragPlane, this._dragPlaneHitPointLocal)) {
          Vector3.TransformCoordinatesToRef(this._dragPlaneHitPointLocal, ecefToLocal, this._dragPlaneHitPointLocal);
        }
      }
      handleDrag(pointerX, pointerY) {
        if (this._hitPointRadius) {
          const pickResult = this._scene.pick(pointerX, pointerY, this.pickPredicate);
          if (pickResult.ray) {
            const localToEcef = TmpVectors.Matrix[0];
            this._recalculateDragPlaneHitPoint(this._hitPointRadius, pickResult.ray, localToEcef);
            const delta = this._dragPlaneHitPointLocal.subtractToRef(this._previousDragPlaneHitPointLocal, TmpVectors.Vector3[6]);
            const maxDragDelta = this._hitPointRadius * 0.1;
            const deltaLength = delta.length();
            if (deltaLength > maxDragDelta) {
              delta.scaleInPlace(maxDragDelta / deltaLength);
            }
            this._previousDragPlaneHitPointLocal.copyFrom(this._dragPlaneHitPointLocal);
            Vector3.TransformNormalToRef(delta, localToEcef, delta);
            this._dragPlaneOriginPointEcef.addInPlace(delta);
            this.panAccumulatedPixels.subtractInPlace(delta);
          }
        }
      }
      /** @override */
      computeCurrentFrameDeltas() {
        const cameraCenter = this._cameraCenter;
        if (this.panAccumulatedPixels.lengthSquared() > Epsilon) {
          const centerRadius = cameraCenter.length();
          const currentRadius = this._cameraPosition.length();
          const sineOfSphericalLat = centerRadius === 0 ? 0 : cameraCenter.z / centerRadius;
          const cosOfSphericalLat = Math.sqrt(1 - Math.min(1, sineOfSphericalLat * sineOfSphericalLat));
          const latitudeDampening = Math.sqrt(Math.abs(cosOfSphericalLat));
          const height = Math.max(currentRadius - centerRadius, Epsilon);
          const latitudeDampeningScale = Math.max(1, centerRadius / height);
          this._panSpeedMultiplier = Clamp(latitudeDampeningScale * latitudeDampening, 0, 1);
        } else {
          this._panSpeedMultiplier = 1;
        }
        let zoomTargetDistance;
        if (this.isDragging || this.rotationAccumulatedPixels.lengthSquared() > Epsilon) {
          this._zoomSpeedMultiplier = 0;
          this._zoomVelocity = 0;
        } else {
          zoomTargetDistance = this.computedPerFrameZoomPickPoint ? Vector3Distance(this._cameraPosition, this.computedPerFrameZoomPickPoint) : void 0;
          this._zoomSpeedMultiplier = (zoomTargetDistance ?? Vector3Distance(this._cameraPosition, cameraCenter)) * 0.01;
        }
        super.computeCurrentFrameDeltas();
      }
      get isDragging() {
        return this._hitPointRadius !== void 0;
      }
      handleZoom(zoomDelta, toCursor) {
        if (zoomDelta !== 0) {
          this.zoomAccumulatedPixels += zoomDelta;
          const pickResult = this._scene.pick(this._scene.pointerX, this._scene.pointerY, this.pickPredicate);
          if (toCursor && pickResult.hit && pickResult.pickedPoint && pickResult.ray && this.zoomToCursor) {
            this.computedPerFrameZoomPickPoint = pickResult.pickedPoint;
          } else {
            const lookPickResult = this.pickAlongVector(this._cameraLookAt);
            this.computedPerFrameZoomPickPoint = lookPickResult?.pickedPoint ?? void 0;
          }
        }
      }
      pickAlongVector(vector) {
        this._tempPickingRay.origin.copyFrom(this._cameraPosition);
        this._tempPickingRay.direction.copyFrom(vector);
        return this._scene.pickWithRay(this._tempPickingRay, this.pickPredicate);
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/geospatialCamera.js
function ComputeLookAtFromYawPitchToRef(yaw, pitch, center, useRightHandedSystem, result) {
  const east = TmpVectors.Vector3[0];
  const north = TmpVectors.Vector3[1];
  const up = TmpVectors.Vector3[2];
  ComputeLocalBasisToRefs(center, east, north, up);
  const sinPitch = Math.sin(pitch);
  const cosPitch = Math.cos(pitch);
  const yawScale = useRightHandedSystem ? 1 : -1;
  const yawQuat = TmpVectors.Quaternion[0];
  Quaternion.RotationAxisToRef(up, yaw * yawScale, yawQuat);
  const horiz = TmpVectors.Vector3[3];
  north.rotateByQuaternionToRef(yawQuat, horiz);
  const t2 = TmpVectors.Vector3[4];
  result.copyFrom(horiz).scaleInPlace(sinPitch).addInPlace(t2.copyFrom(up).scaleInPlace(-cosPitch));
  return result.normalize();
}
function ComputeYawPitchFromLookAtToRef(lookAt, center, useRightHandedSystem, currentYaw, result) {
  const east = TmpVectors.Vector3[6];
  const north = TmpVectors.Vector3[7];
  const up = TmpVectors.Vector3[8];
  ComputeLocalBasisToRefs(center, east, north, up);
  const lookDotUp = Vector3Dot(lookAt, up);
  const cosPitch = -lookDotUp;
  const clampedCosPitch = Clamp(cosPitch, -1, 1);
  const pitch = Math.acos(clampedCosPitch);
  const lookHorizontal = TmpVectors.Vector3[9];
  const scaledUp = TmpVectors.Vector3[10];
  scaledUp.copyFrom(up).scaleInPlace(cosPitch);
  lookHorizontal.copyFrom(lookAt).addInPlace(scaledUp);
  const sinPitch = Math.sin(pitch);
  if (Math.abs(sinPitch) < Epsilon) {
    result.x = currentYaw;
    result.y = pitch;
    return result;
  }
  const horiz = lookHorizontal.scaleInPlace(1 / sinPitch);
  const cosYaw = Vector3Dot(horiz, north);
  const sinYaw = -Vector3Dot(horiz, east);
  const yawScale = useRightHandedSystem ? 1 : -1;
  result.x = Math.atan2(sinYaw, cosYaw) * yawScale;
  result.y = pitch;
  return result;
}
var GeospatialCamera;
var init_geospatialCamera = __esm({
  "node_modules/@babylonjs/core/Cameras/geospatialCamera.js"() {
    init_geospatialCameraInputsManager();
    init_math_vector();
    init_math_constants();
    init_camera();
    init_geospatialLimits();
    init_geospatialCameraMovement();
    init_math_vector_functions();
    init_math_scalar_functions();
    init_interpolatingBehavior();
    GeospatialCamera = class extends Camera {
      constructor(name13, scene, options) {
        super(name13, new Vector3(), scene);
        this._tempPosition = new Vector3();
        this._tempCenter = new Vector3();
        this._viewMatrix = new Matrix();
        this._lookAtVector = new Vector3();
        this._flyToTargets = /* @__PURE__ */ new Map();
        this._collisionVelocity = new Vector3();
        this.perFrameCollisionOffset = new Vector3();
        this.checkCollisions = false;
        this._center = new Vector3();
        this._yaw = 0;
        this._pitch = 0;
        this._radius = 0;
        this._tempVect = new Vector3();
        this._tempEast = new Vector3();
        this._tempNorth = new Vector3();
        this._tempUp = new Vector3();
        this._wasCenterMovingLastFrame = false;
        this._limits = new GeospatialLimits(options.planetRadius);
        this._resetToDefault(this._limits);
        this._flyingBehavior = new InterpolatingBehavior();
        this.addBehavior(this._flyingBehavior);
        this.movement = new GeospatialCameraMovement(scene, this._limits, this.position, this.center, this._lookAtVector, options.pickPredicate, this._flyingBehavior);
        this.inputs = new GeospatialCameraInputsManager(this);
        this.inputs.addMouse().addMouseWheel().addKeyboard();
      }
      /** The point on the globe that we are anchoring around. If no alternate rotation point is supplied, this will represent the center of screen*/
      get center() {
        return this._center;
      }
      /**
       * Sets the camera position to orbit around a new center point
       * @param center The world position (ECEF) to orbit around
       */
      set center(center) {
        this._center.copyFromFloats(center.x, center.y, center.z);
        this._setOrientation(this._yaw, this._pitch, this._radius, this._center);
      }
      /**
       * Gets the camera's yaw (rotation around the geocentric normal) in radians
       */
      get yaw() {
        return this._yaw;
      }
      /**
       * Sets the camera's yaw (rotation around the geocentric normal). Will wrap value to [-, )
       * @param yaw The desired yaw angle in radians (0 = north, /2 = east)
       */
      set yaw(yaw) {
        yaw !== this._yaw && this._setOrientation(yaw, this.pitch, this.radius, this.center);
      }
      /**
       * Gets the camera's pitch (angle from looking straight at globe)
       * Pitch is measured from looking straight down at planet center:
       * - zero pitch = looking straight at planet center (down)
       * - positive pitch = tilting up away from planet
       * - /2 pitch = looking at horizon (perpendicular to geocentric normal)
       */
      get pitch() {
        return this._pitch;
      }
      /**
       * Sets the camera's pitch (angle from looking straight at globe). Will wrap value to [-, )
       * @param pitch The desired pitch angle in radians (0 = looking at planet center, /2 = looking at horizon)
       */
      set pitch(pitch) {
        pitch !== this._pitch && this._setOrientation(this.yaw, pitch, this.radius, this.center);
      }
      get radius() {
        return this._radius;
      }
      /**
       * Sets the camera's distance from the current center point
       * @param radius The desired radius
       */
      set radius(radius) {
        radius !== this._radius && this._setOrientation(this.yaw, this.pitch, radius, this.center);
      }
      _checkLimits() {
        const limits = this.limits;
        this._yaw = Clamp(this._yaw, limits.yawMin, limits.yawMax);
        const effectivePitchMax = limits.getEffectivePitchMax(this._radius);
        this._pitch = Clamp(this._pitch, limits.pitchMin, effectivePitchMax);
        this._radius = Clamp(this._radius, limits.radiusMin, limits.radiusMax);
        ClampCenterFromPolesInPlace(this._center);
      }
      _setOrientation(yaw, pitch, radius, center) {
        this._yaw = NormalizeRadians(yaw);
        this._pitch = NormalizeRadians(pitch);
        this._radius = radius;
        Vector3CopyToRef(center, this._center);
        this._checkLimits();
        ComputeLocalBasisToRefs(this._center, this._tempEast, this._tempNorth, this._tempUp);
        ComputeLookAtFromYawPitchToRef(this._yaw, this._pitch, this._center, this._scene.useRightHandedSystem, this._lookAtVector);
        const right = TmpVectors.Vector3[10];
        Vector3.CrossToRef(this._tempUp, this._lookAtVector, right);
        if (right.lengthSquared() < Epsilon) {
          const horiz = TmpVectors.Vector3[11];
          const yawScale = this._scene.useRightHandedSystem ? 1 : -1;
          const yawQuat = TmpVectors.Quaternion[1];
          Quaternion.RotationAxisToRef(this._tempUp, this._yaw * yawScale, yawQuat);
          this._tempNorth.rotateByQuaternionToRef(yawQuat, horiz);
          Vector3.CrossToRef(horiz, this._lookAtVector, right);
        }
        right.normalize();
        Vector3.CrossToRef(this._lookAtVector, right, this.upVector);
        this.upVector.normalize();
        this._tempVect.copyFrom(this._lookAtVector).scaleInPlace(-this._radius);
        this._tempPosition.copyFrom(this._center).addInPlace(this._tempVect);
        if (this.checkCollisions) {
          this.perFrameCollisionOffset = this._getCollisionOffset(this._tempPosition);
        }
        this._position.copyFrom(this._tempPosition);
        this._isViewMatrixDirty = true;
      }
      /**
       * If camera is actively in flight, will update the target properties and use up the remaining duration from original flyTo call
       *
       * To start a new flyTo curve entirely, call into flyToAsync again (it will stop the inflight animation)
       * @param targetYaw
       * @param targetPitch
       * @param targetRadius
       * @param targetCenter
       */
      updateFlyToDestination(targetYaw, targetPitch, targetRadius, targetCenter) {
        this._flyToTargets.clear();
        const deltaYaw = targetYaw !== void 0 ? NormalizeRadians(NormalizeRadians(targetYaw) - this._yaw) : 0;
        this._flyToTargets.set("yaw", deltaYaw === 0 ? void 0 : this._yaw + deltaYaw);
        this._flyToTargets.set("pitch", targetPitch != void 0 ? NormalizeRadians(targetPitch) : void 0);
        this._flyToTargets.set("radius", targetRadius);
        this._flyToTargets.set("center", targetCenter?.clone());
        this._flyingBehavior.updateProperties(this._flyToTargets);
      }
      /**
       * Animate camera towards passed in property values. If undefined, will use current value
       * @param targetYaw
       * @param targetPitch
       * @param targetRadius
       * @param targetCenter
       * @param flightDurationMs
       * @param easingFunction
       * @param centerHopScale If supplied, will define the parabolic hop height scale for center animation to create a "bounce" effect
       * @returns Promise that will return when the animation is complete (or interuppted by pointer input)
       */
      async flyToAsync(targetYaw, targetPitch, targetRadius, targetCenter, flightDurationMs = 1e3, easingFunction, centerHopScale) {
        this._flyToTargets.clear();
        const deltaYaw = targetYaw !== void 0 ? NormalizeRadians(NormalizeRadians(targetYaw) - this._yaw) : 0;
        this._flyToTargets.set("yaw", deltaYaw === 0 ? void 0 : this._yaw + deltaYaw);
        this._flyToTargets.set("pitch", targetPitch !== void 0 ? NormalizeRadians(targetPitch) : void 0);
        this._flyToTargets.set("radius", targetRadius);
        this._flyToTargets.set("center", targetCenter?.clone());
        let overrideAnimationFunction;
        if (targetCenter !== void 0 && !targetCenter.equals(this.center)) {
          overrideAnimationFunction = (key, animation) => {
            if (key === "center") {
              animation.vector3InterpolateFunction = (startValue, endValue, gradient) => {
                const newCenter = Vector3.SlerpToRef(startValue, endValue, gradient, this._tempCenter);
                if (centerHopScale && centerHopScale > 0) {
                  const hopPeakOffset = centerHopScale * Vector3Distance(startValue, endValue);
                  const hopOffset = hopPeakOffset * Clamp((gradient * gradient - gradient) / -0.25);
                  newCenter.scaleInPlace(1 + hopOffset / newCenter.length());
                }
                return newCenter;
              };
            }
          };
        }
        return await this._flyingBehavior.animatePropertiesAsync(this._flyToTargets, flightDurationMs, easingFunction, overrideAnimationFunction);
      }
      /**
       * Helper function to move camera towards a given point by `distanceScale` of the current camera-to-destination distance (by default 50%).
       * @param destination point to move towards
       * @param distanceScale value between 0 and 1, % of distance to move
       * @param durationMs duration of flight, default 1s
       * @param easingFn optional easing function for flight interpolation of properties
       * @param centerHopScale If supplied, will define the parabolic hop height scale for center animation to create a "bounce" effect
       */
      async flyToPointAsync(destination, distanceScale = 0.5, durationMs = 1e3, easingFn, centerHopScale) {
        const zoomDistance = Vector3Distance(this.position, destination) * distanceScale;
        const newRadius = this._getCenterAndRadiusFromZoomToPoint(destination, zoomDistance, this._tempCenter);
        await this.flyToAsync(void 0, void 0, newRadius, this._tempCenter, durationMs, easingFn, centerHopScale);
      }
      get limits() {
        return this._limits;
      }
      _resetToDefault(limits) {
        const restingAltitude = limits.radiusMax !== Infinity ? limits.radiusMax : limits.planetRadius * 4;
        this.position.copyFromFloats(restingAltitude, 0, 0);
        this._center.copyFromFloats(limits.planetRadius, 0, 0);
        this._radius = Vector3.Distance(this.position, this.center);
        this._tempPosition = new Vector3();
        this._viewMatrix = Matrix.Identity();
        this._center.subtractToRef(this._position, this._lookAtVector).normalize();
        this.upVector = Vector3.Up();
        this._isViewMatrixDirty = true;
        this._setOrientation(this._yaw, this._pitch, this._radius, this._center);
      }
      /** @internal */
      _getViewMatrix() {
        if (!this._isViewMatrixDirty) {
          return this._viewMatrix;
        }
        this._isViewMatrixDirty = false;
        this.upVector.normalize();
        this._lookAtVector.normalize();
        this._position.addInPlace(this.perFrameCollisionOffset);
        this._center.addInPlace(this.perFrameCollisionOffset);
        if (this.getScene().useRightHandedSystem) {
          Matrix.LookAtRHToRef(this.position, this._center, this.upVector, this._viewMatrix);
        } else {
          Matrix.LookAtLHToRef(this.position, this._center, this.upVector, this._viewMatrix);
        }
        return this._viewMatrix;
      }
      /** @internal */
      _isSynchronizedViewMatrix() {
        if (!super._isSynchronizedViewMatrix() || this._isViewMatrixDirty) {
          return false;
        }
        return true;
      }
      _applyGeocentricTranslation() {
        this.center.addToRef(this.movement.panDeltaCurrentFrame, this._tempPosition);
        if (!this.movement.isInterpolating) {
          this._tempPosition.normalize().scaleInPlace(this.center.length());
        }
        this.center = this._tempPosition;
      }
      /**
       * This rotation keeps the camera oriented towards the globe as it orbits around it. This is different from cameraCentricRotation which is when the camera rotates around its own axis
       */
      _applyGeocentricRotation() {
        const rotationDeltaCurrentFrame = this.movement.rotationDeltaCurrentFrame;
        if (rotationDeltaCurrentFrame.x !== 0 || rotationDeltaCurrentFrame.y !== 0) {
          const pitch = rotationDeltaCurrentFrame.x !== 0 ? Clamp(this._pitch + rotationDeltaCurrentFrame.x, 0, 0.5 * Math.PI - Epsilon) : this._pitch;
          const yaw = rotationDeltaCurrentFrame.y !== 0 ? this._yaw + rotationDeltaCurrentFrame.y : this._yaw;
          this._setOrientation(yaw, pitch, this._radius, this._center);
        }
      }
      _getCenterAndRadiusFromZoomToPoint(targetPoint, distance, newCenterResult) {
        const directionToTarget = Vector3SubtractToRef(targetPoint, this._position, TmpVectors.Vector3[0]);
        const distanceToTarget = directionToTarget.length();
        if (distanceToTarget < this.limits.radiusMin) {
          newCenterResult.copyFrom(this._center);
          const requestedRadius = this._radius - distance;
          const newRadius2 = Clamp(requestedRadius, this.limits.radiusMin, this.limits.radiusMax);
          return newRadius2;
        }
        directionToTarget.scaleInPlace(distance / distanceToTarget);
        const newPosition = this._position.addToRef(directionToTarget, TmpVectors.Vector3[1]);
        const projectedDistance = Vector3Dot(directionToTarget, this._lookAtVector);
        const newRadius = this._radius - projectedDistance;
        const newRadiusClamped = Clamp(newRadius, this.limits.radiusMin, this.limits.radiusMax);
        newCenterResult.copyFrom(newPosition).addInPlace(this._lookAtVector.scale(newRadiusClamped));
        return newRadiusClamped;
      }
      /**
       * Apply zoom by moving the camera toward/away from a target point.
       */
      _applyZoom() {
        let zoomDelta = this.movement.zoomDeltaCurrentFrame;
        const pickedPoint = this.movement.computedPerFrameZoomPickPoint;
        zoomDelta = this._clampZoomDelta(zoomDelta, pickedPoint);
        if (Math.abs(zoomDelta) < Epsilon) {
          return;
        }
        if (pickedPoint) {
          this.zoomToPoint(pickedPoint, zoomDelta);
        } else {
          this.zoomAlongLookAt(zoomDelta);
        }
      }
      _clampZoomDelta(zoomDelta, pickedPoint) {
        if (Math.abs(zoomDelta) < Epsilon) {
          return 0;
        }
        const distanceToTarget = pickedPoint ? Vector3Distance(this._position, pickedPoint) : void 0;
        return this.limits.clampZoomDistance(zoomDelta, this._radius, distanceToTarget);
      }
      zoomToPoint(targetPoint, distance) {
        const newRadius = this._getCenterAndRadiusFromZoomToPoint(targetPoint, distance, this._tempCenter);
        this._setOrientation(this._yaw, this._pitch, newRadius, this._tempCenter);
      }
      zoomAlongLookAt(distance) {
        const requestedRadius = this._radius - distance;
        const newRadius = Clamp(requestedRadius, this.limits.radiusMin, this.limits.radiusMax);
        this._setOrientation(this._yaw, this._pitch, newRadius, this._center);
      }
      _checkInputs() {
        this.inputs.checkInputs();
        this.perFrameCollisionOffset.setAll(0);
        this.movement.computeCurrentFrameDeltas();
        let isCenterMoving = false;
        if (this.movement.panDeltaCurrentFrame.lengthSquared() > 0) {
          this._applyGeocentricTranslation();
          isCenterMoving = true;
        }
        if (this.movement.rotationDeltaCurrentFrame.lengthSquared() > 0) {
          this._applyGeocentricRotation();
        }
        if (Math.abs(this.movement.zoomDeltaCurrentFrame) > Epsilon) {
          this._applyZoom();
          isCenterMoving = true;
        }
        this._recalculateCenter(isCenterMoving);
        super._checkInputs();
      }
      _recalculateCenter(isCenterMoving) {
        const shouldRecalculateCenterAfterMove = this._wasCenterMovingLastFrame && !isCenterMoving;
        this._wasCenterMovingLastFrame = isCenterMoving;
        if (shouldRecalculateCenterAfterMove) {
          const newCenter = this.movement.pickAlongVector(this._lookAtVector);
          if (newCenter?.pickedPoint) {
            const centerToOrigin = TmpVectors.Vector3[4];
            centerToOrigin.copyFrom(newCenter.pickedPoint).negateInPlace().normalize();
            const dotProduct = Vector3Dot(this._lookAtVector, centerToOrigin);
            if (dotProduct > 0) {
              const newRadius = Vector3Distance(this._position, newCenter.pickedPoint);
              if (newRadius > Epsilon) {
                const yawPitch = TmpVectors.Vector2[0];
                ComputeYawPitchFromLookAtToRef(this._lookAtVector, newCenter.pickedPoint, this._scene.useRightHandedSystem, this._yaw, yawPitch);
                this._setOrientation(yawPitch.x, yawPitch.y, newRadius, newCenter.pickedPoint);
              }
            }
          }
        }
      }
      /**
       * Allows extended classes to override how collision offset is calculated
       * @param newPosition
       * @returns
       */
      _getCollisionOffset(newPosition) {
        const collisionOffset = TmpVectors.Vector3[6].setAll(0);
        if (!this.checkCollisions || !this._scene.collisionsEnabled) {
          return collisionOffset;
        }
        const coordinator = this.getScene().collisionCoordinator;
        if (!coordinator) {
          return collisionOffset;
        }
        if (!this._collider) {
          this._collider = coordinator.createCollider();
        }
        this._collider._radius.setAll(this.limits.radiusMin);
        newPosition.subtractToRef(this._position, this._collisionVelocity);
        const adjustedPosition = coordinator.getNewPosition(this._position, this._collisionVelocity, this._collider, 3, null, () => {
        }, this.uniqueId);
        adjustedPosition.subtractToRef(newPosition, collisionOffset);
        return collisionOffset;
      }
      attachControl(noPreventDefault) {
        this.inputs.attachElement(noPreventDefault);
      }
      detachControl() {
        this.inputs.detachElement();
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/cylinderBuilder.js
function CreateCylinderVertexData(options) {
  const height = options.height || 2;
  let diameterTop = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;
  let diameterBottom = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;
  diameterTop = diameterTop || 1e-5;
  diameterBottom = diameterBottom || 1e-5;
  const tessellation = (options.tessellation || 24) | 0;
  const subdivisions = (options.subdivisions || 1) | 0;
  const hasRings = options.hasRings ? true : false;
  const enclose = options.enclose ? true : false;
  const cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;
  const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const faceUV = options.faceUV || new Array(3);
  const faceColors = options.faceColors;
  const quadNb = arc !== 1 && enclose ? 2 : 0;
  const ringNb = hasRings ? subdivisions : 1;
  const surfaceNb = 2 + (1 + quadNb) * ringNb;
  let f;
  for (f = 0; f < surfaceNb; f++) {
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  for (f = 0; f < surfaceNb; f++) {
    if (faceUV && faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
  }
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  const colors = [];
  const angleStep = Math.PI * 2 * arc / tessellation;
  let angle;
  let h;
  let radius;
  const tan = (diameterBottom - diameterTop) / 2 / height;
  const ringVertex = Vector3.Zero();
  const ringNormal = Vector3.Zero();
  const ringFirstVertex = Vector3.Zero();
  const ringFirstNormal = Vector3.Zero();
  const quadNormal = Vector3.Zero();
  const y = Axis.Y;
  let i;
  let j;
  let r;
  let ringIdx = 1;
  let s = 1;
  let cs = 0;
  let v = 0;
  for (i = 0; i <= subdivisions; i++) {
    h = i / subdivisions;
    radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;
    ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;
    for (r = 0; r < ringIdx; r++) {
      if (hasRings) {
        s += r;
      }
      if (enclose) {
        s += 2 * r;
      }
      for (j = 0; j <= tessellation; j++) {
        angle = j * angleStep;
        ringVertex.x = Math.cos(-angle) * radius;
        ringVertex.y = -height / 2 + h * height;
        ringVertex.z = Math.sin(-angle) * radius;
        if (diameterTop === 0 && i === subdivisions) {
          ringNormal.x = normals[normals.length - (tessellation + 1) * 3];
          ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];
          ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];
        } else {
          ringNormal.x = ringVertex.x;
          ringNormal.z = ringVertex.z;
          ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;
          ringNormal.normalize();
        }
        if (j === 0) {
          ringFirstVertex.copyFrom(ringVertex);
          ringFirstNormal.copyFrom(ringNormal);
        }
        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);
        normals.push(ringNormal.x, ringNormal.y, ringNormal.z);
        if (hasRings) {
          v = cs !== s ? faceUV[s].y : faceUV[s].w;
        } else {
          v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;
        }
        uvs.push(faceUV[s].x + (faceUV[s].z - faceUV[s].x) * j / tessellation, useOpenGLOrientationForUV ? 1 - v : v);
        if (faceColors) {
          colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);
        }
      }
      if (arc !== 1 && enclose) {
        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);
        positions.push(0, ringVertex.y, 0);
        positions.push(0, ringVertex.y, 0);
        positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);
        Vector3.CrossToRef(y, ringNormal, quadNormal);
        quadNormal.normalize();
        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);
        Vector3.CrossToRef(ringFirstNormal, y, quadNormal);
        quadNormal.normalize();
        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);
        if (hasRings) {
          v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;
        } else {
          v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;
        }
        uvs.push(faceUV[s + 1].x, useOpenGLOrientationForUV ? 1 - v : v);
        uvs.push(faceUV[s + 1].z, useOpenGLOrientationForUV ? 1 - v : v);
        if (hasRings) {
          v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;
        } else {
          v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;
        }
        uvs.push(faceUV[s + 2].x, useOpenGLOrientationForUV ? 1 - v : v);
        uvs.push(faceUV[s + 2].z, useOpenGLOrientationForUV ? 1 - v : v);
        if (faceColors) {
          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);
          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);
          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);
          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);
        }
      }
      if (cs !== s) {
        cs = s;
      }
    }
  }
  const e = arc !== 1 && enclose ? tessellation + 4 : tessellation;
  i = 0;
  for (s = 0; s < subdivisions; s++) {
    let i0 = 0;
    let i1 = 0;
    let i2 = 0;
    let i3 = 0;
    for (j = 0; j < tessellation; j++) {
      i0 = i * (e + 1) + j;
      i1 = (i + 1) * (e + 1) + j;
      i2 = i * (e + 1) + (j + 1);
      i3 = (i + 1) * (e + 1) + (j + 1);
      indices.push(i0, i1, i2);
      indices.push(i3, i2, i1);
    }
    if (arc !== 1 && enclose) {
      indices.push(i0 + 2, i1 + 2, i2 + 2);
      indices.push(i3 + 2, i2 + 2, i1 + 2);
      indices.push(i0 + 4, i1 + 4, i2 + 4);
      indices.push(i3 + 4, i2 + 4, i1 + 4);
    }
    i = hasRings ? i + 2 : i + 1;
  }
  const createCylinderCap = (isTop) => {
    const radius2 = isTop ? diameterTop / 2 : diameterBottom / 2;
    if (radius2 === 0) {
      return;
    }
    let angle2;
    let circleVector;
    let i2;
    const u = isTop ? faceUV[surfaceNb - 1] : faceUV[0];
    let c = null;
    if (faceColors) {
      c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];
    }
    const vbase = positions.length / 3;
    const offset = isTop ? height / 2 : -height / 2;
    const center = new Vector3(0, offset, 0);
    positions.push(center.x, center.y, center.z);
    normals.push(0, isTop ? 1 : -1, 0);
    const v2 = u.y + (u.w - u.y) * 0.5;
    uvs.push(u.x + (u.z - u.x) * 0.5, useOpenGLOrientationForUV ? 1 - v2 : v2);
    if (c) {
      colors.push(c.r, c.g, c.b, c.a);
    }
    const textureScale = new Vector2(0.5, 0.5);
    for (i2 = 0; i2 <= tessellation; i2++) {
      angle2 = Math.PI * 2 * i2 * arc / tessellation;
      const cos = Math.cos(-angle2);
      const sin = Math.sin(-angle2);
      circleVector = new Vector3(cos * radius2, offset, sin * radius2);
      const textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);
      positions.push(circleVector.x, circleVector.y, circleVector.z);
      normals.push(0, isTop ? 1 : -1, 0);
      const v3 = u.y + (u.w - u.y) * textureCoordinate.y;
      uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, useOpenGLOrientationForUV ? 1 - v3 : v3);
      if (c) {
        colors.push(c.r, c.g, c.b, c.a);
      }
    }
    for (i2 = 0; i2 < tessellation; i2++) {
      if (!isTop) {
        indices.push(vbase);
        indices.push(vbase + (i2 + 1));
        indices.push(vbase + (i2 + 2));
      } else {
        indices.push(vbase);
        indices.push(vbase + (i2 + 2));
        indices.push(vbase + (i2 + 1));
      }
    }
  };
  if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {
    createCylinderCap(false);
  }
  if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {
    createCylinderCap(true);
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    vertexData.colors = colors;
  }
  return vertexData;
}
function CreateCylinder(name13, options = {}, scene) {
  const cylinder = new Mesh(name13, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  cylinder._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateCylinderVertexData(options);
  vertexData.applyToMesh(cylinder, options.updatable);
  return cylinder;
}
var CylinderBuilder;
var init_cylinderBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/cylinderBuilder.js"() {
    init_math_vector();
    init_math_color();
    init_mesh();
    init_mesh_vertexData();
    init_scene();
    init_math_axis();
    init_compatibilityOptions();
    CylinderBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateCylinder
    };
    VertexData.CreateCylinder = CreateCylinderVertexData;
    Mesh.CreateCylinder = (name13, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) => {
      if (scene === void 0 || !(scene instanceof Scene)) {
        if (scene !== void 0) {
          sideOrientation = updatable || Mesh.DEFAULTSIDE;
          updatable = scene;
        }
        scene = subdivisions;
        subdivisions = 1;
      }
      const options = {
        height,
        diameterTop,
        diameterBottom,
        tessellation,
        subdivisions,
        sideOrientation,
        updatable
      };
      return CreateCylinder(name13, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Lights/hemisphericLight.js
var HemisphericLight;
var init_hemisphericLight = __esm({
  "node_modules/@babylonjs/core/Lights/hemisphericLight.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_math_color();
    init_node();
    init_light();
    init_typeStore();
    Node.AddNodeConstructor("Light_Type_3", (name13, scene) => {
      return () => new HemisphericLight(name13, Vector3.Zero(), scene);
    });
    HemisphericLight = class extends Light {
      /**
       * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).
       * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.
       * The HemisphericLight can't cast shadows.
       * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
       * @param name The friendly name of the light
       * @param direction The direction of the light reflection
       * @param scene The scene the light belongs to
       * @param dontAddToScene True to not add the light to the scene
       */
      constructor(name13, direction, scene, dontAddToScene) {
        super(name13, scene, dontAddToScene);
        this.groundColor = new Color3(0, 0, 0);
        this.direction = direction || Vector3.Up();
      }
      _buildUniformLayout() {
        this._uniformBuffer.addUniform("vLightData", 4);
        this._uniformBuffer.addUniform("vLightDiffuse", 4);
        this._uniformBuffer.addUniform("vLightSpecular", 4);
        this._uniformBuffer.addUniform("vLightGround", 3);
        this._uniformBuffer.addUniform("shadowsInfo", 3);
        this._uniformBuffer.addUniform("depthValues", 2);
        this._uniformBuffer.create();
      }
      /**
       * Returns the string "HemisphericLight".
       * @returns The class name
       */
      getClassName() {
        return "HemisphericLight";
      }
      /**
       * Sets the HemisphericLight direction towards the passed target (Vector3).
       * Returns the updated direction.
       * @param target The target the direction should point to
       * @returns The computed direction
       */
      setDirectionToTarget(target) {
        this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));
        return this.direction;
      }
      /**
       * Returns the shadow generator associated to the light.
       * @returns Always null for hemispheric lights because it does not support shadows.
       */
      getShadowGenerator() {
        return null;
      }
      /**
       * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).
       * @param _effect The effect to update
       * @param lightIndex The index of the light in the effect to update
       * @returns The hemispheric light
       */
      transferToEffect(_effect, lightIndex) {
        const normalizeDirection = Vector3.Normalize(this.direction);
        this._uniformBuffer.updateFloat4("vLightData", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0, lightIndex);
        this._uniformBuffer.updateColor3("vLightGround", this.groundColor.scale(this.intensity), lightIndex);
        return this;
      }
      transferToNodeMaterialEffect(effect, lightDataUniformName) {
        const normalizeDirection = Vector3.Normalize(this.direction);
        effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);
        return this;
      }
      /**
       * Computes the world matrix of the node
       * @returns the world matrix
       */
      computeWorldMatrix() {
        if (!this._worldMatrix) {
          this._worldMatrix = Matrix.Identity();
        }
        return this._worldMatrix;
      }
      /**
       * Returns the integer 3.
       * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      getTypeID() {
        return Light.LIGHTTYPEID_HEMISPHERICLIGHT;
      }
      /**
       * Prepares the list of defines specific to the light type.
       * @param defines the list of defines
       * @param lightIndex defines the index of the light for the effect
       */
      prepareLightSpecificDefines(defines, lightIndex) {
        defines["HEMILIGHT" + lightIndex] = true;
      }
    };
    __decorate([
      serializeAsColor3()
    ], HemisphericLight.prototype, "groundColor", void 0);
    __decorate([
      serializeAsVector3()
    ], HemisphericLight.prototype, "direction", void 0);
    RegisterClass("BABYLON.HemisphericLight", HemisphericLight);
  }
});

// node_modules/@babylonjs/core/Rendering/utilityLayerRenderer.js
var UtilityLayerRenderer;
var init_utilityLayerRenderer = __esm({
  "node_modules/@babylonjs/core/Rendering/utilityLayerRenderer.js"() {
    init_scene();
    init_observable();
    init_pointerEvents();
    init_pickingInfo();
    init_engineStore();
    init_hemisphericLight();
    init_math_vector();
    init_math_color();
    UtilityLayerRenderer = class _UtilityLayerRenderer {
      /**
       * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)
       * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned
       * @returns the camera that is used when rendering the utility layer
       */
      getRenderCamera(getRigParentIfPossible) {
        if (this._renderCamera) {
          return this._renderCamera;
        } else {
          let activeCam;
          if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {
            activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];
          } else {
            activeCam = this.originalScene.activeCamera;
          }
          if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {
            return activeCam.rigParent;
          }
          return activeCam;
        }
      }
      /**
       * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)
       * @param cam the camera that should be used when rendering the utility layer
       */
      setRenderCamera(cam) {
        this._renderCamera = cam;
      }
      /**
       * @internal
       * Light which used by gizmos to get light shading
       */
      _getSharedGizmoLight() {
        if (!this._sharedGizmoLight) {
          this._sharedGizmoLight = new HemisphericLight("shared gizmo light", new Vector3(0, 1, 0), this.utilityLayerScene);
          this._sharedGizmoLight.intensity = 2;
          this._sharedGizmoLight.groundColor = Color3.Gray();
        }
        return this._sharedGizmoLight;
      }
      /**
       * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)
       */
      static get DefaultUtilityLayer() {
        if (_UtilityLayerRenderer._DefaultUtilityLayer == null) {
          return _UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene);
        }
        return _UtilityLayerRenderer._DefaultUtilityLayer;
      }
      /**
       * Creates an utility layer, and set it as a default utility layer
       * @param scene associated scene
       * @internal
       */
      static _CreateDefaultUtilityLayerFromScene(scene) {
        _UtilityLayerRenderer._DefaultUtilityLayer = new _UtilityLayerRenderer(scene);
        _UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {
          _UtilityLayerRenderer._DefaultUtilityLayer = null;
        });
        return _UtilityLayerRenderer._DefaultUtilityLayer;
      }
      /**
       * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)
       */
      static get DefaultKeepDepthUtilityLayer() {
        if (_UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {
          return _UtilityLayerRenderer._CreateDefaultKeepUtilityLayerFromScene(EngineStore.LastCreatedScene);
        }
        return _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;
      }
      /**
       * Creates an utility layer, and set it as a default utility layer (Depth map of the previous scene is not cleared before drawing on top of it)
       * @param scene associated scene
       * @internal
       */
      static _CreateDefaultKeepUtilityLayerFromScene(scene) {
        _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new _UtilityLayerRenderer(scene);
        _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;
        _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {
          _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;
        });
        return _UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;
      }
      /**
       * Instantiates a UtilityLayerRenderer
       * @param originalScene the original scene that will be rendered on top of
       * @param handleEvents boolean indicating if the utility layer should handle events
       * @param manualRender boolean indicating if the utility layer should render manually.
       */
      constructor(originalScene, handleEvents = true, manualRender = false) {
        this.originalScene = originalScene;
        this.handleEvents = handleEvents;
        this._pointerCaptures = {};
        this._lastPointerEvents = {};
        this._sharedGizmoLight = null;
        this._renderCamera = null;
        this.pickUtilitySceneFirst = true;
        this.shouldRender = true;
        this.onlyCheckPointerDownEvents = true;
        this.processAllEvents = false;
        this.pickingEnabled = true;
        this.onPointerOutObservable = new Observable();
        this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true, useFloatingOrigin: originalScene.floatingOriginMode });
        this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;
        this.utilityLayerScene._allowPostProcessClearColor = false;
        this.utilityLayerScene.postProcessesEnabled = false;
        this.utilityLayerScene.detachControl();
        if (handleEvents) {
          this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo) => {
            if (!this.utilityLayerScene.activeCamera) {
              return;
            }
            if (!this.pickingEnabled) {
              return;
            }
            if (!this.processAllEvents) {
              if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE && prePointerInfo.type !== PointerEventTypes.POINTERUP && prePointerInfo.type !== PointerEventTypes.POINTERDOWN && prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {
                return;
              }
            }
            this.utilityLayerScene.pointerX = originalScene.pointerX;
            this.utilityLayerScene.pointerY = originalScene.pointerY;
            const pointerEvent = prePointerInfo.event;
            if (originalScene.isPointerCaptured(pointerEvent.pointerId)) {
              this._pointerCaptures[pointerEvent.pointerId] = false;
              return;
            }
            const getNearPickDataForScene = (scene) => {
              let scenePick = null;
              if (prePointerInfo.nearInteractionPickingInfo) {
                if (prePointerInfo.nearInteractionPickingInfo.pickedMesh.getScene() == scene) {
                  scenePick = prePointerInfo.nearInteractionPickingInfo;
                } else {
                  scenePick = new PickingInfo();
                }
              } else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {
                scenePick = prePointerInfo.originalPickingInfo;
              } else {
                let previousActiveCamera = null;
                if (this._renderCamera) {
                  previousActiveCamera = scene._activeCamera;
                  scene._activeCamera = this._renderCamera;
                  prePointerInfo.ray = null;
                }
                scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);
                if (previousActiveCamera) {
                  scene._activeCamera = previousActiveCamera;
                }
              }
              return scenePick;
            };
            const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);
            if (!prePointerInfo.ray && utilityScenePick) {
              prePointerInfo.ray = utilityScenePick.ray;
            }
            if (prePointerInfo.originalPickingInfo?.aimTransform && utilityScenePick) {
              utilityScenePick.aimTransform = prePointerInfo.originalPickingInfo.aimTransform;
              utilityScenePick.gripTransform = prePointerInfo.originalPickingInfo.gripTransform;
            }
            this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);
            if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {
              if (!prePointerInfo.skipOnPointerObservable) {
                this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);
              }
              if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {
                this._pointerCaptures[pointerEvent.pointerId] = false;
              }
              return;
            }
            if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {
              if (utilityScenePick && utilityScenePick.hit) {
                if (!prePointerInfo.skipOnPointerObservable) {
                  this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);
                }
                prePointerInfo.skipOnPointerObservable = true;
              }
            } else {
              const originalScenePick = getNearPickDataForScene(originalScene);
              const pointerEvent2 = prePointerInfo.event;
              if (originalScenePick && utilityScenePick) {
                if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {
                  if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {
                    this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
                    prePointerInfo.skipOnPointerObservable = true;
                  } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {
                    this._pointerCaptures[pointerEvent2.pointerId] = true;
                    this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
                  } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {
                    if (this._lastPointerEvents[pointerEvent2.pointerId]) {
                      this.onPointerOutObservable.notifyObservers(pointerEvent2.pointerId);
                      delete this._lastPointerEvents[pointerEvent2.pointerId];
                    }
                    this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
                  }
                } else if (!this._pointerCaptures[pointerEvent2.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {
                  this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent2);
                  if (!prePointerInfo.skipOnPointerObservable) {
                    prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;
                  }
                } else if (!this._pointerCaptures[pointerEvent2.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {
                  if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {
                    this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent2);
                    prePointerInfo.skipOnPointerObservable = true;
                  } else {
                    if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {
                      if (this._lastPointerEvents[pointerEvent2.pointerId]) {
                        this.onPointerOutObservable.notifyObservers(pointerEvent2.pointerId);
                        delete this._lastPointerEvents[pointerEvent2.pointerId];
                      }
                    }
                    this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent2);
                  }
                }
                if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent2.pointerId]) {
                  this._pointerCaptures[pointerEvent2.pointerId] = false;
                }
              }
            }
          });
          if (this._originalPointerObserver) {
            originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);
          }
        }
        this.utilityLayerScene.autoClear = false;
        if (!manualRender) {
          this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add((camera) => {
            if (this.shouldRender && camera == this.getRenderCamera()) {
              this.render();
            }
          });
        }
        this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {
          this.dispose();
        });
        this._updateCamera();
      }
      _notifyObservers(prePointerInfo, pickInfo, pointerEvent) {
        if (!prePointerInfo.skipOnPointerObservable) {
          this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);
          this._lastPointerEvents[pointerEvent.pointerId] = true;
        }
      }
      /**
       * Renders the utility layers scene on top of the original scene
       */
      render() {
        this._updateCamera();
        if (this.utilityLayerScene.activeCamera) {
          const oldScene = this.utilityLayerScene.activeCamera.getScene();
          const camera = this.utilityLayerScene.activeCamera;
          camera._scene = this.utilityLayerScene;
          if (camera.leftCamera) {
            camera.leftCamera._scene = this.utilityLayerScene;
          }
          if (camera.rightCamera) {
            camera.rightCamera._scene = this.utilityLayerScene;
          }
          this.utilityLayerScene.render(false);
          camera._scene = oldScene;
          if (camera.leftCamera) {
            camera.leftCamera._scene = oldScene;
          }
          if (camera.rightCamera) {
            camera.rightCamera._scene = oldScene;
          }
        }
      }
      /**
       * Disposes of the renderer
       */
      dispose() {
        this.onPointerOutObservable.clear();
        if (this._afterRenderObserver) {
          this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);
        }
        if (this._sceneDisposeObserver) {
          this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);
        }
        if (this._originalPointerObserver) {
          this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);
        }
        this.utilityLayerScene.dispose();
      }
      _updateCamera() {
        this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();
        this.utilityLayerScene.activeCamera = this.getRenderCamera();
      }
    };
    UtilityLayerRenderer._DefaultUtilityLayer = null;
    UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;
  }
});

// node_modules/@babylonjs/core/Gizmos/gizmo.js
var GizmoAnchorPoint, GizmoCoordinatesMode, Gizmo;
var init_gizmo = __esm({
  "node_modules/@babylonjs/core/Gizmos/gizmo.js"() {
    init_math_vector();
    init_mesh();
    init_camera();
    init_utilityLayerRenderer();
    init_pointerEvents();
    init_light();
    (function(GizmoAnchorPoint2) {
      GizmoAnchorPoint2[GizmoAnchorPoint2["Origin"] = 0] = "Origin";
      GizmoAnchorPoint2[GizmoAnchorPoint2["Pivot"] = 1] = "Pivot";
    })(GizmoAnchorPoint || (GizmoAnchorPoint = {}));
    (function(GizmoCoordinatesMode2) {
      GizmoCoordinatesMode2[GizmoCoordinatesMode2["World"] = 0] = "World";
      GizmoCoordinatesMode2[GizmoCoordinatesMode2["Local"] = 1] = "Local";
    })(GizmoCoordinatesMode || (GizmoCoordinatesMode = {}));
    Gizmo = class _Gizmo {
      /**
       * Ratio for the scale of the gizmo (Default: 1)
       */
      set scaleRatio(value) {
        this._scaleRatio = value;
      }
      get scaleRatio() {
        return this._scaleRatio;
      }
      /**
       * True when the mouse pointer is hovered a gizmo mesh
       */
      get isHovered() {
        return this._isHovered;
      }
      /**
       * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)
       * * When set, interactions will be enabled
       */
      get attachedMesh() {
        return this._attachedMesh;
      }
      set attachedMesh(value) {
        this._attachedMesh = value;
        if (value) {
          this._attachedNode = value;
        }
        this._rootMesh.setEnabled(value ? true : false);
        this._attachedNodeChanged(value);
      }
      /**
       * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)
       * * When set, interactions will be enabled
       */
      get attachedNode() {
        return this._attachedNode;
      }
      set attachedNode(value) {
        this._attachedNode = value;
        this._attachedMesh = null;
        this._rootMesh.setEnabled(value ? true : false);
        this._attachedNodeChanged(value);
      }
      /**
       * Disposes and replaces the current meshes in the gizmo with the specified mesh
       * @param mesh The mesh to replace the default mesh of the gizmo
       */
      setCustomMesh(mesh) {
        if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {
          throw "When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)";
        }
        const children = this._rootMesh.getChildMeshes();
        for (const c of children) {
          c.dispose();
        }
        mesh.parent = this._rootMesh;
        this._customMeshSet = true;
      }
      /**
       * Additional transform applied to the gizmo.
       * It's useful when the gizmo is attached to a bone: if the bone is part of a skeleton attached to a mesh, you should define the mesh as additionalTransformNode if you want the gizmo to be displayed at the bone's correct location.
       * Otherwise, as the gizmo is relative to the skeleton root, the mesh transformation will not be taken into account.
       */
      get additionalTransformNode() {
        return this._additionalTransformNode;
      }
      set additionalTransformNode(value) {
        this._additionalTransformNode = value;
      }
      /**
       * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)
       * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation
       */
      set updateGizmoRotationToMatchAttachedMesh(value) {
        this._updateGizmoRotationToMatchAttachedMesh = value;
      }
      get updateGizmoRotationToMatchAttachedMesh() {
        return this._updateGizmoRotationToMatchAttachedMesh;
      }
      /**
       * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)
       */
      set updateGizmoPositionToMatchAttachedMesh(value) {
        this._updateGizmoPositionToMatchAttachedMesh = value;
      }
      get updateGizmoPositionToMatchAttachedMesh() {
        return this._updateGizmoPositionToMatchAttachedMesh;
      }
      /**
       * Defines where the gizmo will be positioned if `updateGizmoPositionToMatchAttachedMesh` is enabled.
       * (Default: GizmoAnchorPoint.Origin)
       */
      set anchorPoint(value) {
        this._anchorPoint = value;
      }
      get anchorPoint() {
        return this._anchorPoint;
      }
      /**
       * Set the coordinate system to use. By default it's local.
       * But it's possible for a user to tweak so its local for translation and world for rotation.
       * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`
       */
      set coordinatesMode(coordinatesMode) {
        this._coordinatesMode = coordinatesMode;
        const local = coordinatesMode == 1;
        this.updateGizmoRotationToMatchAttachedMesh = local;
        this.updateGizmoPositionToMatchAttachedMesh = true;
      }
      get coordinatesMode() {
        return this._coordinatesMode;
      }
      /**
       * When set, the gizmo will always appear the same size no matter where the camera is (default: true)
       */
      set updateScale(value) {
        this._updateScale = value;
      }
      get updateScale() {
        return this._updateScale;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _attachedNodeChanged(value) {
      }
      /**
       * Creates a gizmo
       * @param gizmoLayer The utility layer the gizmo will be added to
       */
      constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer) {
        this.gizmoLayer = gizmoLayer;
        this._attachedMesh = null;
        this._attachedNode = null;
        this._customRotationQuaternion = null;
        this._scaleRatio = 1;
        this._isHovered = false;
        this._customMeshSet = false;
        this._updateGizmoRotationToMatchAttachedMesh = true;
        this._updateGizmoPositionToMatchAttachedMesh = true;
        this._anchorPoint = 0;
        this._updateScale = true;
        this._coordinatesMode = 1;
        this._interactionsEnabled = true;
        this._rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);
        this._rootMesh = new Mesh("gizmoRootNode", gizmoLayer.utilityLayerScene);
        this._rootMesh.rotationQuaternion = Quaternion.Identity();
        this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(() => {
          this._update();
        });
      }
      /**
       * posture that the gizmo will be display
       * When set null, default value will be used (Quaternion(0, 0, 0, 1))
       */
      get customRotationQuaternion() {
        return this._customRotationQuaternion;
      }
      set customRotationQuaternion(customRotationQuaternion) {
        this._customRotationQuaternion = customRotationQuaternion;
      }
      /**
       * Updates the gizmo to match the attached mesh's position/rotation
       */
      _update() {
        if (this.attachedNode) {
          let effectiveNode = this.attachedNode;
          if (this.attachedMesh) {
            effectiveNode = this.attachedMesh || this.attachedNode;
          }
          if (this.updateGizmoPositionToMatchAttachedMesh) {
            if (this.anchorPoint == 1 && effectiveNode.getAbsolutePivotPoint) {
              const position = effectiveNode.getAbsolutePivotPoint();
              this._rootMesh.position.copyFrom(position);
            } else {
              const row = effectiveNode.getWorldMatrix().getRow(3);
              const position = row ? row.toVector3() : new Vector3(0, 0, 0);
              this._rootMesh.position.copyFrom(position);
            }
          }
          if (this.updateGizmoRotationToMatchAttachedMesh) {
            const supportedNode = effectiveNode._isMesh || effectiveNode.getClassName() === "AbstractMesh" || effectiveNode.getClassName() === "TransformNode" || effectiveNode.getClassName() === "InstancedMesh";
            const transformNode = supportedNode ? effectiveNode : void 0;
            effectiveNode.getWorldMatrix().decompose(void 0, this._rootMesh.rotationQuaternion, void 0, _Gizmo.PreserveScaling ? transformNode : void 0);
            this._rootMesh.rotationQuaternion.normalize();
          } else {
            if (this._customRotationQuaternion) {
              this._rootMesh.rotationQuaternion.copyFrom(this._customRotationQuaternion);
            } else {
              this._rootMesh.rotationQuaternion.set(0, 0, 0, 1);
            }
          }
          if (this.updateScale) {
            const activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera;
            const cameraPosition = activeCamera.globalPosition;
            this._rootMesh.position.subtractToRef(cameraPosition, TmpVectors.Vector3[0]);
            let scale = this.scaleRatio;
            if (activeCamera.mode == Camera.ORTHOGRAPHIC_CAMERA) {
              if (activeCamera.orthoTop && activeCamera.orthoBottom) {
                const orthoHeight = activeCamera.orthoTop - activeCamera.orthoBottom;
                scale *= orthoHeight;
              }
            } else {
              const camForward = activeCamera.getScene().useRightHandedSystem ? Vector3.RightHandedForwardReadOnly : Vector3.LeftHandedForwardReadOnly;
              const direction = activeCamera.getDirection(camForward);
              scale *= Vector3.Dot(TmpVectors.Vector3[0], direction);
            }
            this._rootMesh.scaling.setAll(scale);
            if (effectiveNode._getWorldMatrixDeterminant() < 0 && !_Gizmo.PreserveScaling) {
              this._rootMesh.scaling.y *= -1;
            }
          } else {
            this._rootMesh.scaling.setAll(this.scaleRatio);
          }
        }
        if (this.additionalTransformNode) {
          this._rootMesh.computeWorldMatrix(true);
          this._rootMesh.getWorldMatrix().multiplyToRef(this.additionalTransformNode.getWorldMatrix(), TmpVectors.Matrix[0]);
          TmpVectors.Matrix[0].decompose(this._rootMesh.scaling, this._rootMesh.rotationQuaternion, this._rootMesh.position);
        }
      }
      /**
       * if transform has a pivot and is not using PostMultiplyPivotMatrix, then the worldMatrix contains the pivot matrix (it's not cancelled at the end)
       * so, when extracting the world matrix component, the translation (and other components) is containing the pivot translation.
       * And the pivot is applied each frame. Removing it anyway here makes it applied only in computeWorldMatrix.
       * @param transform local transform that needs to be transform by the pivot inverse matrix
       * @param localMatrix local matrix that needs to be transform by the pivot inverse matrix
       * @param result resulting matrix transformed by pivot inverse if the transform node is using pivot without using post Multiply Pivot Matrix
       */
      _handlePivotMatrixInverse(transform, localMatrix, result) {
        if (transform.isUsingPivotMatrix() && !transform.isUsingPostMultiplyPivotMatrix()) {
          transform.getPivotMatrix().invertToRef(TmpVectors.Matrix[5]);
          TmpVectors.Matrix[5].multiplyToRef(localMatrix, result);
          return;
        }
        result.copyFrom(localMatrix);
      }
      /**
       * computes the rotation/scaling/position of the transform once the Node world matrix has changed.
       */
      _matrixChanged() {
        if (!this._attachedNode) {
          return;
        }
        if (this._attachedNode._isCamera) {
          const camera = this._attachedNode;
          let worldMatrix;
          let worldMatrixUc;
          if (camera.parent) {
            const parentInv = TmpVectors.Matrix[1];
            camera.parent._worldMatrix.invertToRef(parentInv);
            this._attachedNode._worldMatrix.multiplyToRef(parentInv, TmpVectors.Matrix[0]);
            worldMatrix = TmpVectors.Matrix[0];
          } else {
            worldMatrix = this._attachedNode._worldMatrix;
          }
          if (camera.getScene().useRightHandedSystem) {
            this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, TmpVectors.Matrix[1]);
            worldMatrixUc = TmpVectors.Matrix[1];
          } else {
            worldMatrixUc = worldMatrix;
          }
          worldMatrixUc.decompose(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);
          const inheritsTargetCamera = this._attachedNode.getClassName() === "FreeCamera" || this._attachedNode.getClassName() === "FlyCamera" || this._attachedNode.getClassName() === "ArcFollowCamera" || this._attachedNode.getClassName() === "TargetCamera" || this._attachedNode.getClassName() === "TouchCamera" || this._attachedNode.getClassName() === "UniversalCamera";
          if (inheritsTargetCamera) {
            const targetCamera = this._attachedNode;
            targetCamera.rotation = TmpVectors.Quaternion[0].toEulerAngles();
            if (targetCamera.rotationQuaternion) {
              targetCamera.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);
              targetCamera.rotationQuaternion.normalize();
            }
          }
          camera.position.copyFrom(TmpVectors.Vector3[0]);
        } else if (this._attachedNode._isMesh || this._attachedNode.getClassName() === "AbstractMesh" || this._attachedNode.getClassName() === "TransformNode" || this._attachedNode.getClassName() === "InstancedMesh") {
          const transform = this._attachedNode;
          if (transform.parent) {
            const parentInv = TmpVectors.Matrix[0];
            const localMat = TmpVectors.Matrix[1];
            transform.parent.getWorldMatrix().invertToRef(parentInv);
            this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);
            const matrixToDecompose = TmpVectors.Matrix[4];
            this._handlePivotMatrixInverse(transform, localMat, matrixToDecompose);
            matrixToDecompose.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, _Gizmo.PreserveScaling ? transform : void 0, _Gizmo.UseAbsoluteScaling);
            TmpVectors.Quaternion[0].normalize();
            if (transform.isUsingPivotMatrix()) {
              const r = TmpVectors.Quaternion[1];
              Quaternion.RotationYawPitchRollToRef(transform.rotation.y, transform.rotation.x, transform.rotation.z, r);
              const scaleMatrix = TmpVectors.Matrix[2];
              Matrix.ScalingToRef(transform.scaling.x, transform.scaling.y, transform.scaling.z, scaleMatrix);
              const rotationMatrix = TmpVectors.Matrix[2];
              r.toRotationMatrix(rotationMatrix);
              const pivotMatrix = transform.getPivotMatrix();
              const invPivotMatrix = TmpVectors.Matrix[3];
              pivotMatrix.invertToRef(invPivotMatrix);
              pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);
              TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, TmpVectors.Matrix[5]);
              TmpVectors.Matrix[5].multiplyToRef(invPivotMatrix, TmpVectors.Matrix[6]);
              TmpVectors.Matrix[6].getTranslationToRef(TmpVectors.Vector3[1]);
              transform.position.subtractInPlace(TmpVectors.Vector3[1]);
            }
          } else {
            const matrixToDecompose = TmpVectors.Matrix[4];
            this._handlePivotMatrixInverse(transform, this._attachedNode._worldMatrix, matrixToDecompose);
            matrixToDecompose.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, _Gizmo.PreserveScaling ? transform : void 0, _Gizmo.UseAbsoluteScaling);
          }
          TmpVectors.Vector3[0].scaleInPlace(1 / transform.scalingDeterminant);
          transform.scaling.copyFrom(TmpVectors.Vector3[0]);
          if (!transform.billboardMode) {
            if (transform.rotationQuaternion) {
              transform.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);
              transform.rotationQuaternion.normalize();
            } else {
              transform.rotation = TmpVectors.Quaternion[0].toEulerAngles();
            }
          }
        } else if (this._attachedNode.getClassName() === "Bone") {
          const bone = this._attachedNode;
          const parent = bone.getParent();
          if (parent) {
            const invParent = TmpVectors.Matrix[0];
            const boneLocalMatrix = TmpVectors.Matrix[1];
            parent.getFinalMatrix().invertToRef(invParent);
            bone.getFinalMatrix().multiplyToRef(invParent, boneLocalMatrix);
            const lmat = bone.getLocalMatrix();
            lmat.copyFrom(boneLocalMatrix);
          } else {
            const lmat = bone.getLocalMatrix();
            lmat.copyFrom(bone.getFinalMatrix());
          }
          bone.markAsDirty();
        } else {
          const light = this._attachedNode;
          if (light.getTypeID) {
            const type = light.getTypeID();
            if (type === Light.LIGHTTYPEID_DIRECTIONALLIGHT || type === Light.LIGHTTYPEID_SPOTLIGHT || type === Light.LIGHTTYPEID_POINTLIGHT) {
              const parent = light.parent;
              if (parent) {
                const invParent = TmpVectors.Matrix[0];
                const nodeLocalMatrix = TmpVectors.Matrix[1];
                parent.getWorldMatrix().invertToRef(invParent);
                light.getWorldMatrix().multiplyToRef(invParent, nodeLocalMatrix);
                nodeLocalMatrix.decompose(void 0, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);
              } else {
                this._attachedNode._worldMatrix.decompose(void 0, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);
              }
              light.position = new Vector3(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z);
              if (light.direction) {
                light.direction = new Vector3(light.direction.x, light.direction.y, light.direction.z);
              }
            }
          }
        }
      }
      /**
       * refresh gizmo mesh material
       * @param gizmoMeshes
       * @param material material to apply
       */
      _setGizmoMeshMaterial(gizmoMeshes, material) {
        if (gizmoMeshes) {
          for (const m of gizmoMeshes) {
            m.material = material;
            if (m.color) {
              m.color = material.diffuseColor;
            }
          }
        }
      }
      /**
       * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.
       * @param gizmoLayer The utility layer the gizmo will be added to
       * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI
       * @returns {Observer<PointerInfo>} pointerObserver
       */
      static GizmoAxisPointerObserver(gizmoLayer, gizmoAxisCache) {
        let dragging = false;
        let activeDragButton = -1;
        let forcePointerUp = false;
        const pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
          if (pointerInfo.pickInfo) {
            forcePointerUp = dragging && pointerInfo.event.button !== -1 && pointerInfo.event.button !== activeDragButton;
            if (forcePointerUp || pointerInfo.type === PointerEventTypes.POINTERUP) {
              gizmoAxisCache.forEach((cache) => {
                cache.active = false;
                dragging = false;
                activeDragButton = -1;
                for (const m of cache.gizmoMeshes) {
                  m.material = cache.dragBehavior.enabled ? cache.material : cache.disableMaterial;
                  if (m.color) {
                    m.color = cache.material.diffuseColor;
                  }
                }
              });
            } else if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {
              if (dragging) {
                return;
              }
              gizmoAxisCache.forEach((cache) => {
                if (cache.colliderMeshes && cache.gizmoMeshes) {
                  const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh) != -1;
                  const material = cache.dragBehavior.enabled ? isHovered || cache.active ? cache.hoverMaterial : cache.material : cache.disableMaterial;
                  for (const m of cache.gizmoMeshes) {
                    m.material = material;
                    if (m.color) {
                      m.color = material.diffuseColor;
                    }
                  }
                }
              });
            } else if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {
              if (gizmoAxisCache.has(pointerInfo.pickInfo.pickedMesh?.parent)) {
                dragging = true;
                activeDragButton = pointerInfo.event.button;
                const statusMap = gizmoAxisCache.get(pointerInfo.pickInfo.pickedMesh?.parent);
                statusMap.active = true;
                gizmoAxisCache.forEach((cache) => {
                  const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh) != -1;
                  const material = (isHovered || cache.active) && cache.dragBehavior.enabled ? cache.hoverMaterial : cache.disableMaterial;
                  for (const m of cache.gizmoMeshes) {
                    m.material = material;
                    if (m.color) {
                      m.color = material.diffuseColor;
                    }
                  }
                });
              }
            }
          }
        });
        return pointerObserver;
      }
      /**
       * Disposes of the gizmo
       */
      dispose() {
        this._rootMesh.dispose();
        if (this._beforeRenderObserver) {
          this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);
        }
      }
    };
    Gizmo.PreserveScaling = false;
    Gizmo.UseAbsoluteScaling = true;
  }
});

// node_modules/@babylonjs/core/Gizmos/axisDragGizmo.js
var AxisDragGizmo;
var init_axisDragGizmo = __esm({
  "node_modules/@babylonjs/core/Gizmos/axisDragGizmo.js"() {
    init_observable();
    init_transformNode();
    init_mesh();
    init_cylinderBuilder();
    init_pointerDragBehavior();
    init_gizmo();
    init_utilityLayerRenderer();
    init_standardMaterial();
    init_math_color();
    init_math_vector();
    AxisDragGizmo = class _AxisDragGizmo extends Gizmo {
      /** Default material used to render when gizmo is not disabled or hovered */
      get coloredMaterial() {
        return this._coloredMaterial;
      }
      /** Material used to render when gizmo is hovered with mouse*/
      get hoverMaterial() {
        return this._hoverMaterial;
      }
      /** Material used to render when gizmo is disabled. typically grey.*/
      get disableMaterial() {
        return this._disableMaterial;
      }
      /**
       * @internal
       */
      static _CreateArrow(scene, material, thickness = 1, isCollider = false) {
        const arrow = new TransformNode("arrow", scene);
        const cylinder = CreateCylinder("cylinder", {
          diameterTop: 0,
          height: 0.075,
          diameterBottom: 0.0375 * (1 + (thickness - 1) / 4),
          tessellation: 96
        }, scene);
        const line = CreateCylinder("cylinder", {
          diameterTop: 5e-3 * thickness,
          height: 0.275,
          diameterBottom: 5e-3 * thickness,
          tessellation: 96
        }, scene);
        cylinder.parent = arrow;
        cylinder.material = material;
        cylinder.rotation.x = Math.PI / 2;
        cylinder.position.z += 0.3;
        line.parent = arrow;
        line.material = material;
        line.position.z += 0.275 / 2;
        line.rotation.x = Math.PI / 2;
        if (isCollider) {
          line.visibility = 0;
          cylinder.visibility = 0;
        }
        return arrow;
      }
      /**
       * @internal
       */
      static _CreateArrowInstance(scene, arrow) {
        const instance = new TransformNode("arrow", scene);
        for (const mesh of arrow.getChildMeshes()) {
          const childInstance = mesh.createInstance(mesh.name);
          childInstance.parent = instance;
        }
        return instance;
      }
      /**
       * Creates an AxisDragGizmo
       * @param dragAxis The axis which the gizmo will be able to drag on
       * @param color The color of the gizmo
       * @param gizmoLayer The utility layer the gizmo will be added to
       * @param parent
       * @param thickness display gizmo axis thickness
       * @param hoverColor The color of the gizmo when hovering over and dragging
       * @param disableColor The Color of the gizmo when its disabled
       */
      constructor(dragAxis, color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, parent = null, thickness = 1, hoverColor = Color3.Yellow(), disableColor = Color3.Gray()) {
        super(gizmoLayer);
        this._pointerObserver = null;
        this.snapDistance = 0;
        this.onSnapObservable = new Observable();
        this._isEnabled = true;
        this._parent = null;
        this._dragging = false;
        this._parent = parent;
        this._coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        this._coloredMaterial.diffuseColor = color;
        this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));
        this._hoverMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        this._hoverMaterial.diffuseColor = hoverColor;
        this._disableMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        this._disableMaterial.diffuseColor = disableColor;
        this._disableMaterial.alpha = 0.4;
        const arrow = _AxisDragGizmo._CreateArrow(gizmoLayer.utilityLayerScene, this._coloredMaterial, thickness);
        const collider = _AxisDragGizmo._CreateArrow(gizmoLayer.utilityLayerScene, this._coloredMaterial, thickness + 4, true);
        this._gizmoMesh = new Mesh("", gizmoLayer.utilityLayerScene);
        this._gizmoMesh.addChild(arrow);
        this._gizmoMesh.addChild(collider);
        this._gizmoMesh.lookAt(this._rootMesh.position.add(dragAxis));
        this._gizmoMesh.scaling.scaleInPlace(1 / 3);
        this._gizmoMesh.parent = this._rootMesh;
        let currentSnapDragDistance = 0;
        const tmpSnapEvent = { snapDistance: 0 };
        this.dragBehavior = new PointerDragBehavior({ dragAxis });
        this.dragBehavior.moveAttached = false;
        this.dragBehavior.updateDragPlane = false;
        this._rootMesh.addBehavior(this.dragBehavior);
        this.dragBehavior.onDragObservable.add((event) => {
          if (this.attachedNode) {
            let matrixChanged = false;
            if (this.snapDistance == 0) {
              this.attachedNode.getWorldMatrix().getTranslationToRef(TmpVectors.Vector3[2]);
              TmpVectors.Vector3[2].addInPlace(event.delta);
              if (this.dragBehavior.validateDrag(TmpVectors.Vector3[2])) {
                if (this.attachedNode.position) {
                  this.attachedNode.position.addInPlaceFromFloats(event.delta.x, event.delta.y, event.delta.z);
                }
                this.attachedNode.getWorldMatrix().addTranslationFromFloats(event.delta.x, event.delta.y, event.delta.z);
                this.attachedNode.updateCache();
                matrixChanged = true;
              }
            } else {
              currentSnapDragDistance += event.dragDistance;
              if (Math.abs(currentSnapDragDistance) > this.snapDistance) {
                const dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);
                currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;
                event.delta.normalizeToRef(TmpVectors.Vector3[1]);
                TmpVectors.Vector3[1].scaleInPlace(this.snapDistance * dragSteps);
                this.attachedNode.getWorldMatrix().getTranslationToRef(TmpVectors.Vector3[2]);
                TmpVectors.Vector3[2].addInPlace(TmpVectors.Vector3[1]);
                if (this.dragBehavior.validateDrag(TmpVectors.Vector3[2])) {
                  this.attachedNode.getWorldMatrix().addTranslationFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[1].z);
                  this.attachedNode.updateCache();
                  tmpSnapEvent.snapDistance = this.snapDistance * dragSteps * Math.sign(currentSnapDragDistance);
                  this.onSnapObservable.notifyObservers(tmpSnapEvent);
                  matrixChanged = true;
                }
              }
            }
            if (matrixChanged) {
              this._matrixChanged();
            }
          }
        });
        this.dragBehavior.onDragStartObservable.add(() => {
          this._dragging = true;
        });
        this.dragBehavior.onDragEndObservable.add(() => {
          this._dragging = false;
        });
        const light = gizmoLayer._getSharedGizmoLight();
        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));
        const cache = {
          gizmoMeshes: arrow.getChildMeshes(),
          colliderMeshes: collider.getChildMeshes(),
          material: this._coloredMaterial,
          hoverMaterial: this._hoverMaterial,
          disableMaterial: this._disableMaterial,
          active: false,
          dragBehavior: this.dragBehavior
        };
        this._parent?.addToAxisCache(collider, cache);
        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
          if (this._customMeshSet) {
            return;
          }
          this._isHovered = !!(cache.colliderMeshes.indexOf(pointerInfo?.pickInfo?.pickedMesh) != -1);
          if (!this._parent) {
            const material = this.dragBehavior.enabled ? this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial : this._disableMaterial;
            this._setGizmoMeshMaterial(cache.gizmoMeshes, material);
          }
        });
        this.dragBehavior.onEnabledObservable.add((newState) => {
          this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? cache.material : cache.disableMaterial);
        });
      }
      _attachedNodeChanged(value) {
        if (this.dragBehavior) {
          this.dragBehavior.enabled = value ? true : false;
        }
      }
      /**
       * If the gizmo is enabled
       */
      set isEnabled(value) {
        this._isEnabled = value;
        if (!value) {
          this.attachedMesh = null;
          this.attachedNode = null;
        } else {
          if (this._parent) {
            this.attachedMesh = this._parent.attachedMesh;
            this.attachedNode = this._parent.attachedNode;
          }
        }
      }
      get isEnabled() {
        return this._isEnabled;
      }
      /**
       * Disposes of the gizmo
       */
      dispose() {
        this.onSnapObservable.clear();
        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
        this.dragBehavior.detach();
        if (this._gizmoMesh) {
          this._gizmoMesh.dispose();
        }
        const mats = [this._coloredMaterial, this._hoverMaterial, this._disableMaterial];
        for (const matl of mats) {
          if (matl) {
            matl.dispose();
          }
        }
        super.dispose();
      }
    };
  }
});

// node_modules/@babylonjs/core/Debug/axesViewer.js
var AxesViewer;
var init_axesViewer = __esm({
  "node_modules/@babylonjs/core/Debug/axesViewer.js"() {
    init_math_vector();
    init_standardMaterial();
    init_axisDragGizmo();
    init_math_color();
    init_engineStore();
    AxesViewer = class _AxesViewer {
      /**
       * Gets or sets a number used to scale line length
       */
      get scaleLines() {
        return this._scaleLines;
      }
      set scaleLines(value) {
        this._scaleLines = value;
        this._xAxis.scaling.setAll(this._scaleLines * this._scaleLinesFactor);
        this._yAxis.scaling.setAll(this._scaleLines * this._scaleLinesFactor);
        this._zAxis.scaling.setAll(this._scaleLines * this._scaleLinesFactor);
      }
      /** Gets the node hierarchy used to render x-axis */
      get xAxis() {
        return this._xAxis;
      }
      /** Gets the node hierarchy used to render y-axis */
      get yAxis() {
        return this._yAxis;
      }
      /** Gets the node hierarchy used to render z-axis */
      get zAxis() {
        return this._zAxis;
      }
      /**
       * Creates a new AxesViewer
       * @param scene defines the hosting scene
       * @param scaleLines defines a number used to scale line length (1 by default)
       * @param renderingGroupId defines a number used to set the renderingGroupId of the meshes (2 by default)
       * @param xAxis defines the node hierarchy used to render the x-axis
       * @param yAxis defines the node hierarchy used to render the y-axis
       * @param zAxis defines the node hierarchy used to render the z-axis
       * @param lineThickness The line thickness to use when creating the arrow. defaults to 1.
       */
      constructor(scene, scaleLines = 1, renderingGroupId = 2, xAxis, yAxis, zAxis, lineThickness = 1) {
        this._scaleLinesFactor = 4;
        this._instanced = false;
        this.scene = null;
        this._scaleLines = 1;
        scene = scene || EngineStore.LastCreatedScene;
        if (!scene) {
          return;
        }
        if (!xAxis) {
          const redColoredMaterial = new StandardMaterial("xAxisMaterial", scene);
          redColoredMaterial.disableLighting = true;
          redColoredMaterial.emissiveColor = Color3.Red().scale(0.5);
          xAxis = AxisDragGizmo._CreateArrow(scene, redColoredMaterial, lineThickness);
        }
        if (!yAxis) {
          const greenColoredMaterial = new StandardMaterial("yAxisMaterial", scene);
          greenColoredMaterial.disableLighting = true;
          greenColoredMaterial.emissiveColor = Color3.Green().scale(0.5);
          yAxis = AxisDragGizmo._CreateArrow(scene, greenColoredMaterial, lineThickness);
        }
        if (!zAxis) {
          const blueColoredMaterial = new StandardMaterial("zAxisMaterial", scene);
          blueColoredMaterial.disableLighting = true;
          blueColoredMaterial.emissiveColor = Color3.Blue().scale(0.5);
          zAxis = AxisDragGizmo._CreateArrow(scene, blueColoredMaterial, lineThickness);
        }
        this._xAxis = xAxis;
        this._yAxis = yAxis;
        this._zAxis = zAxis;
        this.scaleLines = scaleLines;
        if (renderingGroupId != null) {
          _AxesViewer._SetRenderingGroupId(this._xAxis, renderingGroupId);
          _AxesViewer._SetRenderingGroupId(this._yAxis, renderingGroupId);
          _AxesViewer._SetRenderingGroupId(this._zAxis, renderingGroupId);
        }
        this.scene = scene;
        this.update(new Vector3(), Vector3.Right(), Vector3.Up(), Vector3.Forward());
      }
      /**
       * Force the viewer to update
       * @param position defines the position of the viewer
       * @param xaxis defines the x axis of the viewer
       * @param yaxis defines the y axis of the viewer
       * @param zaxis defines the z axis of the viewer
       */
      update(position, xaxis, yaxis, zaxis) {
        this._xAxis.position.copyFrom(position);
        this._xAxis.setDirection(xaxis);
        this._yAxis.position.copyFrom(position);
        this._yAxis.setDirection(yaxis);
        this._zAxis.position.copyFrom(position);
        this._zAxis.setDirection(zaxis);
      }
      /**
       * Creates an instance of this axes viewer.
       * @returns a new axes viewer with instanced meshes
       */
      createInstance() {
        const xAxis = AxisDragGizmo._CreateArrowInstance(this.scene, this._xAxis);
        const yAxis = AxisDragGizmo._CreateArrowInstance(this.scene, this._yAxis);
        const zAxis = AxisDragGizmo._CreateArrowInstance(this.scene, this._zAxis);
        const axesViewer = new _AxesViewer(this.scene, this.scaleLines, null, xAxis, yAxis, zAxis);
        axesViewer._instanced = true;
        return axesViewer;
      }
      /** Releases resources */
      dispose() {
        if (this._xAxis) {
          this._xAxis.dispose(false, !this._instanced);
        }
        if (this._yAxis) {
          this._yAxis.dispose(false, !this._instanced);
        }
        if (this._zAxis) {
          this._zAxis.dispose(false, !this._instanced);
        }
        this.scene = null;
      }
      static _SetRenderingGroupId(node, id) {
        const meshes = node.getChildMeshes();
        for (const mesh of meshes) {
          mesh.renderingGroupId = id;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Debug/debugLayer.js
var DebugLayerTab, DebugLayer;
var init_debugLayer = __esm({
  "node_modules/@babylonjs/core/Debug/debugLayer.js"() {
    init_tools();
    init_observable();
    init_scene();
    init_engineStore();
    init_abstractEngine();
    Object.defineProperty(Scene.prototype, "debugLayer", {
      get: function() {
        if (!this._debugLayer) {
          this._debugLayer = new DebugLayer(this);
        }
        return this._debugLayer;
      },
      enumerable: true,
      configurable: true
    });
    (function(DebugLayerTab2) {
      DebugLayerTab2[DebugLayerTab2["Properties"] = 0] = "Properties";
      DebugLayerTab2[DebugLayerTab2["Debug"] = 1] = "Debug";
      DebugLayerTab2[DebugLayerTab2["Statistics"] = 2] = "Statistics";
      DebugLayerTab2[DebugLayerTab2["Tools"] = 3] = "Tools";
      DebugLayerTab2[DebugLayerTab2["Settings"] = 4] = "Settings";
    })(DebugLayerTab || (DebugLayerTab = {}));
    DebugLayer = class _DebugLayer {
      /**
       * Observable triggered when a property is changed through the inspector.
       */
      get onPropertyChangedObservable() {
        if (this.BJSINSPECTOR && this.BJSINSPECTOR.Inspector) {
          return this.BJSINSPECTOR.Inspector.OnPropertyChangedObservable;
        }
        if (!this._onPropertyChangedObservable) {
          this._onPropertyChangedObservable = new Observable();
        }
        return this._onPropertyChangedObservable;
      }
      /**
       * Observable triggered when the selection is changed through the inspector.
       */
      get onSelectionChangedObservable() {
        if (this.BJSINSPECTOR && this.BJSINSPECTOR.Inspector) {
          return this.BJSINSPECTOR.Inspector.OnSelectionChangeObservable;
        }
        if (!this._onSelectionChangedObservable) {
          this._onSelectionChangedObservable = new Observable();
        }
        return this._onSelectionChangedObservable;
      }
      /**
       * Instantiates a new debug layer.
       * The debug layer (aka Inspector) is the go to tool in order to better understand
       * what is happening in your scene
       * @see https://doc.babylonjs.com/toolsAndResources/inspector
       * @param scene Defines the scene to inspect
       */
      constructor(scene) {
        this.BJSINSPECTOR = this._getGlobalInspector();
        this._scene = scene || EngineStore.LastCreatedScene;
        if (!this._scene) {
          return;
        }
        this._scene.onDisposeObservable.add(() => {
          if (this._scene._debugLayer) {
            this._scene._debugLayer.hide();
          }
        });
      }
      /**
       * Creates the inspector window.
       * @param config
       */
      _createInspector(config) {
        if (this.isVisible()) {
          return;
        }
        if (this._onPropertyChangedObservable) {
          for (const observer of this._onPropertyChangedObservable.observers) {
            this.BJSINSPECTOR.Inspector.OnPropertyChangedObservable.add(observer);
          }
          this._onPropertyChangedObservable.clear();
          this._onPropertyChangedObservable = void 0;
        }
        if (this._onSelectionChangedObservable) {
          for (const observer of this._onSelectionChangedObservable.observers) {
            this.BJSINSPECTOR.Inspector.OnSelectionChangedObservable.add(observer);
          }
          this._onSelectionChangedObservable.clear();
          this._onSelectionChangedObservable = void 0;
        }
        const userOptions = {
          ..._DebugLayer.Config,
          ...config
        };
        this.BJSINSPECTOR = this.BJSINSPECTOR || this._getGlobalInspector();
        this.BJSINSPECTOR.Inspector.Show(this._scene, userOptions);
      }
      /**
       * Select a specific entity in the scene explorer and highlight a specific block in that entity property grid
       * @param entity defines the entity to select
       * @param lineContainerTitles defines the specific blocks to highlight (could be a string or an array of strings)
       */
      select(entity, lineContainerTitles) {
        if (this.BJSINSPECTOR) {
          if (lineContainerTitles) {
            if (Object.prototype.toString.call(lineContainerTitles) == "[object String]") {
              this.BJSINSPECTOR.Inspector.MarkLineContainerTitleForHighlighting(lineContainerTitles);
            } else {
              this.BJSINSPECTOR.Inspector.MarkMultipleLineContainerTitlesForHighlighting(lineContainerTitles);
            }
          }
          if (!this.BJSINSPECTOR.Inspector.IsVisible) {
            const waitAndCheck = () => {
              setTimeout(() => {
                if (this.BJSINSPECTOR.Inspector.IsVisible) {
                  this.select(entity, lineContainerTitles);
                } else {
                  waitAndCheck();
                }
              }, 100);
            };
            waitAndCheck();
          } else {
            this.BJSINSPECTOR.Inspector.OnSelectionChangeObservable.notifyObservers(entity);
          }
        }
      }
      /**
       * Get the inspector from bundle or global
       * @returns the inspector instance if found otherwise, null
       */
      _getGlobalInspector() {
        if (typeof INSPECTOR !== "undefined") {
          return INSPECTOR;
        }
        if (typeof BABYLON !== "undefined" && typeof BABYLON.Inspector !== "undefined") {
          return BABYLON;
        }
        return void 0;
      }
      /**
       * Get if the inspector is visible or not.
       * @returns true if visible otherwise, false
       */
      isVisible() {
        return this.BJSINSPECTOR && this.BJSINSPECTOR.Inspector.IsVisible;
      }
      /**
       * Hide the inspector and close its window.
       */
      hide() {
        if (this.BJSINSPECTOR) {
          this.BJSINSPECTOR.Inspector.Hide();
        }
      }
      /**
       * Get the number of opened panes in the inspector
       */
      get openedPanes() {
        if (this.BJSINSPECTOR) {
          return this.BJSINSPECTOR.Inspector._OpenedPane;
        }
        return 0;
      }
      /**
       * Update the scene in the inspector
       */
      setAsActiveScene() {
        if (this.BJSINSPECTOR) {
          this.BJSINSPECTOR.Inspector._SetNewScene(this._scene);
        }
      }
      popupSceneExplorer() {
        if (this.BJSINSPECTOR) {
          this.BJSINSPECTOR.Inspector.PopupSceneExplorer();
        }
      }
      popupInspector() {
        if (this.BJSINSPECTOR) {
          this.BJSINSPECTOR.Inspector.PopupInspector();
        }
      }
      popupEmbed() {
        if (this.BJSINSPECTOR) {
          this.BJSINSPECTOR.Inspector.PopupEmbed();
        }
      }
      /**
       * Launch the debugLayer.
       * @param config Define the configuration of the inspector
       * @returns a promise fulfilled when the debug layer is visible
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      async show(config) {
        return await new Promise((resolve) => {
          if (typeof this.BJSINSPECTOR == "undefined") {
            const inspectorUrl = config && config.inspectorURL ? config.inspectorURL : _DebugLayer.InspectorURL;
            Tools.LoadBabylonScript(inspectorUrl, () => {
              this._createInspector(config);
              resolve(this);
            });
          } else {
            this._createInspector(config);
            resolve(this);
          }
        });
      }
    };
    DebugLayer.InspectorURL = `${Tools._DefaultCdnUrl}/v${AbstractEngine.Version}/inspector/babylon.inspector.bundle.js`;
    DebugLayer.Config = {
      overlay: false,
      showExplorer: true,
      showInspector: true,
      embedMode: false,
      handleResize: true,
      enablePopup: true
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js
function CreateBoxVertexData(options) {
  const nbFaces = 6;
  let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
  const normals = [
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0
  ];
  const uvs = [];
  let positions = [];
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const depth = options.depth || options.size || 1;
  const wrap = options.wrap || false;
  let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;
  let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;
  topBaseAt = (topBaseAt + 4) % 4;
  bottomBaseAt = (bottomBaseAt + 4) % 4;
  const topOrder = [2, 0, 3, 1];
  const bottomOrder = [2, 0, 1, 3];
  let topIndex = topOrder[topBaseAt];
  let bottomIndex = bottomOrder[bottomBaseAt];
  let basePositions = [
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1
  ];
  if (wrap) {
    indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];
    basePositions = [
      -1,
      1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1
    ];
    let topFaceBase = [
      [1, 1, 1],
      [-1, 1, 1],
      [-1, 1, -1],
      [1, 1, -1]
    ];
    let bottomFaceBase = [
      [-1, -1, 1],
      [1, -1, 1],
      [1, -1, -1],
      [-1, -1, -1]
    ];
    const topFaceOrder = [17, 18, 19, 16];
    const bottomFaceOrder = [22, 23, 20, 21];
    while (topIndex > 0) {
      topFaceBase.unshift(topFaceBase.pop());
      topFaceOrder.unshift(topFaceOrder.pop());
      topIndex--;
    }
    while (bottomIndex > 0) {
      bottomFaceBase.unshift(bottomFaceBase.pop());
      bottomFaceOrder.unshift(bottomFaceOrder.pop());
      bottomIndex--;
    }
    topFaceBase = topFaceBase.flat();
    bottomFaceBase = bottomFaceBase.flat();
    basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);
    indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);
    indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);
  }
  const scaleArray = [width / 2, height / 2, depth / 2];
  positions = basePositions.reduce((accumulator, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const faceUV = options.faceUV || new Array(6);
  const faceColors = options.faceColors;
  const colors = [];
  for (let f = 0; f < 6; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  for (let index = 0; index < nbFaces; index++) {
    uvs.push(faceUV[index].z, useOpenGLOrientationForUV ? 1 - faceUV[index].w : faceUV[index].w);
    uvs.push(faceUV[index].x, useOpenGLOrientationForUV ? 1 - faceUV[index].w : faceUV[index].w);
    uvs.push(faceUV[index].x, useOpenGLOrientationForUV ? 1 - faceUV[index].y : faceUV[index].y);
    uvs.push(faceUV[index].z, useOpenGLOrientationForUV ? 1 - faceUV[index].y : faceUV[index].y);
    if (faceColors) {
      for (let c = 0; c < 4; c++) {
        colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
}
function CreateSegmentedBoxVertexData(options) {
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const depth = options.depth || options.size || 1;
  const widthSegments = (options.widthSegments || options.segments || 1) | 0;
  const heightSegments = (options.heightSegments || options.segments || 1) | 0;
  const depthSegments = (options.depthSegments || options.segments || 1) | 0;
  const rotationMatrix = new Matrix();
  const translationMatrix = new Matrix();
  const transformMatrix = new Matrix();
  const bottomPlane = CreateGroundVertexData({ width, height: depth, subdivisionsX: widthSegments, subdivisionsY: depthSegments });
  Matrix.TranslationToRef(0, -height / 2, 0, translationMatrix);
  Matrix.RotationZToRef(Math.PI, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  bottomPlane.transform(transformMatrix);
  const topPlane = CreateGroundVertexData({ width, height: depth, subdivisionsX: widthSegments, subdivisionsY: depthSegments });
  Matrix.TranslationToRef(0, height / 2, 0, transformMatrix);
  topPlane.transform(transformMatrix);
  const negXPlane = CreateGroundVertexData({ width: height, height: depth, subdivisionsX: heightSegments, subdivisionsY: depthSegments });
  Matrix.TranslationToRef(-width / 2, 0, 0, translationMatrix);
  Matrix.RotationZToRef(Math.PI / 2, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  negXPlane.transform(transformMatrix);
  const posXPlane = CreateGroundVertexData({ width: height, height: depth, subdivisionsX: heightSegments, subdivisionsY: depthSegments });
  Matrix.TranslationToRef(width / 2, 0, 0, translationMatrix);
  Matrix.RotationZToRef(-Math.PI / 2, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  posXPlane.transform(transformMatrix);
  const negZPlane = CreateGroundVertexData({ width, height, subdivisionsX: widthSegments, subdivisionsY: heightSegments });
  Matrix.TranslationToRef(0, 0, -depth / 2, translationMatrix);
  Matrix.RotationXToRef(-Math.PI / 2, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  negZPlane.transform(transformMatrix);
  const posZPlane = CreateGroundVertexData({ width, height, subdivisionsX: widthSegments, subdivisionsY: heightSegments });
  Matrix.TranslationToRef(0, 0, depth / 2, translationMatrix);
  Matrix.RotationXToRef(Math.PI / 2, rotationMatrix);
  rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);
  posZPlane.transform(transformMatrix);
  bottomPlane.merge([topPlane, posXPlane, negXPlane, negZPlane, posZPlane], true);
  return bottomPlane;
}
function CreateBox(name13, options = {}, scene = null) {
  const box = new Mesh(name13, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  box._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateBoxVertexData(options);
  vertexData.applyToMesh(box, options.updatable);
  return box;
}
var BoxBuilder;
var init_boxBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js"() {
    init_math_vector();
    init_math_color();
    init_mesh();
    init_mesh_vertexData();
    init_compatibilityOptions();
    init_groundBuilder();
    BoxBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateBox
    };
    VertexData.CreateBox = CreateBoxVertexData;
    Mesh.CreateBox = (name13, size, scene = null, updatable, sideOrientation) => {
      const options = {
        size,
        sideOrientation,
        updatable
      };
      return CreateBox(name13, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/sphereBuilder.js
function CreateSphereVertexData(options) {
  const segments = (options.segments || 32) | 0;
  const diameterX = options.diameterX || options.diameter || 1;
  const diameterY = options.diameterY || options.diameter || 1;
  const diameterZ = options.diameterZ || options.diameter || 1;
  const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  const slice = options.slice && options.slice <= 0 ? 1 : options.slice || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const dedupTopBottomIndices = !!options.dedupTopBottomIndices;
  const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);
  const totalZRotationSteps = 2 + segments;
  const totalYRotationSteps = 2 * totalZRotationSteps;
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {
    const normalizedZ = zRotationStep / totalZRotationSteps;
    const angleZ = normalizedZ * Math.PI * slice;
    for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {
      const normalizedY = yRotationStep / totalYRotationSteps;
      const angleY = normalizedY * Math.PI * 2 * arc;
      const rotationZ = Matrix.RotationZ(-angleZ);
      const rotationY = Matrix.RotationY(angleY);
      const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);
      const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);
      const vertex = complete.multiply(radius);
      const normal = complete.divide(radius).normalize();
      positions.push(vertex.x, vertex.y, vertex.z);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(normalizedY, useOpenGLOrientationForUV ? 1 - normalizedZ : normalizedZ);
    }
    if (zRotationStep > 0) {
      const verticesCount = positions.length / 3;
      for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {
        if (dedupTopBottomIndices) {
          if (zRotationStep > 1) {
            indices.push(firstIndex);
            indices.push(firstIndex + 1);
            indices.push(firstIndex + totalYRotationSteps + 1);
          }
          if (zRotationStep < totalZRotationSteps || slice < 1) {
            indices.push(firstIndex + totalYRotationSteps + 1);
            indices.push(firstIndex + 1);
            indices.push(firstIndex + totalYRotationSteps + 2);
          }
        } else {
          indices.push(firstIndex);
          indices.push(firstIndex + 1);
          indices.push(firstIndex + totalYRotationSteps + 1);
          indices.push(firstIndex + totalYRotationSteps + 1);
          indices.push(firstIndex + 1);
          indices.push(firstIndex + totalYRotationSteps + 2);
        }
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateSphere(name13, options = {}, scene = null) {
  const sphere = new Mesh(name13, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  sphere._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateSphereVertexData(options);
  vertexData.applyToMesh(sphere, options.updatable);
  return sphere;
}
var SphereBuilder;
var init_sphereBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/sphereBuilder.js"() {
    init_math_vector();
    init_mesh();
    init_mesh_vertexData();
    init_compatibilityOptions();
    SphereBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateSphere
    };
    VertexData.CreateSphere = CreateSphereVertexData;
    Mesh.CreateSphere = (name13, segments, diameter, scene, updatable, sideOrientation) => {
      const options = {
        segments,
        diameterX: diameter,
        diameterY: diameter,
        diameterZ: diameter,
        sideOrientation,
        updatable
      };
      return CreateSphere(name13, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Physics/v1/physicsJoint.js
var PhysicsJoint, DistanceJoint, MotorEnabledJoint, HingeJoint, Hinge2Joint;
var init_physicsJoint = __esm({
  "node_modules/@babylonjs/core/Physics/v1/physicsJoint.js"() {
    PhysicsJoint = class {
      /**
       * Initializes the physics joint
       * @param type The type of the physics joint
       * @param jointData The data for the physics joint
       */
      constructor(type, jointData) {
        this.type = type;
        this.jointData = jointData;
        jointData.nativeParams = jointData.nativeParams || {};
      }
      /**
       * Gets the physics joint
       */
      get physicsJoint() {
        return this._physicsJoint;
      }
      /**
       * Sets the physics joint
       */
      set physicsJoint(newJoint) {
        this._physicsJoint = newJoint;
      }
      /**
       * Sets the physics plugin
       */
      set physicsPlugin(physicsPlugin) {
        this._physicsPlugin = physicsPlugin;
      }
      /**
       * Execute a function that is physics-plugin specific.
       * @param {Function} func the function that will be executed.
       *                        It accepts two parameters: the physics world and the physics joint
       */
      executeNativeFunction(func) {
        func(this._physicsPlugin.world, this._physicsJoint);
      }
    };
    PhysicsJoint.DistanceJoint = 0;
    PhysicsJoint.HingeJoint = 1;
    PhysicsJoint.BallAndSocketJoint = 2;
    PhysicsJoint.WheelJoint = 3;
    PhysicsJoint.SliderJoint = 4;
    PhysicsJoint.PrismaticJoint = 5;
    PhysicsJoint.UniversalJoint = 6;
    PhysicsJoint.Hinge2Joint = PhysicsJoint.WheelJoint;
    PhysicsJoint.PointToPointJoint = 8;
    PhysicsJoint.SpringJoint = 9;
    PhysicsJoint.LockJoint = 10;
    DistanceJoint = class extends PhysicsJoint {
      /**
       *
       * @param jointData The data for the Distance-Joint
       */
      constructor(jointData) {
        super(PhysicsJoint.DistanceJoint, jointData);
      }
      /**
       * Update the predefined distance.
       * @param maxDistance The maximum preferred distance
       * @param minDistance The minimum preferred distance
       */
      updateDistance(maxDistance, minDistance) {
        this._physicsPlugin.updateDistanceJoint(this, maxDistance, minDistance);
      }
    };
    MotorEnabledJoint = class extends PhysicsJoint {
      /**
       * Initializes the Motor-Enabled Joint
       * @param type The type of the joint
       * @param jointData The physical joint data for the joint
       */
      constructor(type, jointData) {
        super(type, jointData);
      }
      /**
       * Set the motor values.
       * Attention, this function is plugin specific. Engines won't react 100% the same.
       * @param force the force to apply
       * @param maxForce max force for this motor.
       */
      setMotor(force, maxForce) {
        this._physicsPlugin.setMotor(this, force || 0, maxForce);
      }
      /**
       * Set the motor's limits.
       * Attention, this function is plugin specific. Engines won't react 100% the same.
       * @param upperLimit The upper limit of the motor
       * @param lowerLimit The lower limit of the motor
       */
      setLimit(upperLimit, lowerLimit) {
        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);
      }
    };
    HingeJoint = class extends MotorEnabledJoint {
      /**
       * Initializes the Hinge-Joint
       * @param jointData The joint data for the Hinge-Joint
       */
      constructor(jointData) {
        super(PhysicsJoint.HingeJoint, jointData);
      }
      /**
       * Set the motor values.
       * Attention, this function is plugin specific. Engines won't react 100% the same.
       * @param {number} force the force to apply
       * @param {number} maxForce max force for this motor.
       */
      setMotor(force, maxForce) {
        this._physicsPlugin.setMotor(this, force || 0, maxForce);
      }
      /**
       * Set the motor's limits.
       * Attention, this function is plugin specific. Engines won't react 100% the same.
       * @param upperLimit The upper limit of the motor
       * @param lowerLimit The lower limit of the motor
       */
      setLimit(upperLimit, lowerLimit) {
        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);
      }
    };
    Hinge2Joint = class extends MotorEnabledJoint {
      /**
       * Initializes the Hinge2-Joint
       * @param jointData The joint data for the Hinge2-Joint
       */
      constructor(jointData) {
        super(PhysicsJoint.Hinge2Joint, jointData);
      }
      /**
       * Set the motor values.
       * Attention, this function is plugin specific. Engines won't react 100% the same.
       * @param targetSpeed the speed the motor is to reach
       * @param maxForce max force for this motor.
       * @param motorIndex motor's index, 0 or 1.
       */
      setMotor(targetSpeed, maxForce, motorIndex = 0) {
        this._physicsPlugin.setMotor(this, targetSpeed || 0, maxForce, motorIndex);
      }
      /**
       * Set the motor limits.
       * Attention, this function is plugin specific. Engines won't react 100% the same.
       * @param upperLimit the upper limit
       * @param lowerLimit lower limit
       * @param motorIndex the motor's index, 0 or 1.
       */
      setLimit(upperLimit, lowerLimit, motorIndex = 0) {
        this._physicsPlugin.setLimit(this, upperLimit, lowerLimit, motorIndex);
      }
    };
  }
});

// node_modules/@babylonjs/core/Physics/v1/physicsImpostor.js
var PhysicsImpostor;
var init_physicsImpostor = __esm({
  "node_modules/@babylonjs/core/Physics/v1/physicsImpostor.js"() {
    init_logger();
    init_arrayTools();
    init_math_vector();
    init_abstractMesh();
    init_mesh();
    init_physicsJoint();
    Mesh._PhysicsImpostorParser = function(scene, physicObject, jsonObject) {
      return new PhysicsImpostor(physicObject, jsonObject.physicsImpostor, {
        mass: jsonObject.physicsMass,
        friction: jsonObject.physicsFriction,
        restitution: jsonObject.physicsRestitution
      }, scene);
    };
    PhysicsImpostor = class _PhysicsImpostor {
      /**
       * Specifies if the physics imposter is disposed
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Gets the mass of the physics imposter
       */
      get mass() {
        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyMass(this) : 0;
      }
      set mass(value) {
        this.setMass(value);
      }
      /**
       * Gets the coefficient of friction
       */
      get friction() {
        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyFriction(this) : 0;
      }
      /**
       * Sets the coefficient of friction
       */
      set friction(value) {
        if (!this._physicsEngine) {
          return;
        }
        this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);
      }
      /**
       * Gets the coefficient of restitution
       */
      get restitution() {
        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this) : 0;
      }
      /**
       * Sets the coefficient of restitution
       */
      set restitution(value) {
        if (!this._physicsEngine) {
          return;
        }
        this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);
      }
      /**
       * Gets the pressure of a soft body; only supported by the AmmoJSPlugin
       */
      get pressure() {
        if (!this._physicsEngine) {
          return 0;
        }
        const plugin = this._physicsEngine.getPhysicsPlugin();
        if (!plugin.setBodyPressure) {
          return 0;
        }
        return plugin.getBodyPressure(this);
      }
      /**
       * Sets the pressure of a soft body; only supported by the AmmoJSPlugin
       */
      set pressure(value) {
        if (!this._physicsEngine) {
          return;
        }
        const plugin = this._physicsEngine.getPhysicsPlugin();
        if (!plugin.setBodyPressure) {
          return;
        }
        plugin.setBodyPressure(this, value);
      }
      /**
       * Gets the stiffness of a soft body; only supported by the AmmoJSPlugin
       */
      get stiffness() {
        if (!this._physicsEngine) {
          return 0;
        }
        const plugin = this._physicsEngine.getPhysicsPlugin();
        if (!plugin.getBodyStiffness) {
          return 0;
        }
        return plugin.getBodyStiffness(this);
      }
      /**
       * Sets the stiffness of a soft body; only supported by the AmmoJSPlugin
       */
      set stiffness(value) {
        if (!this._physicsEngine) {
          return;
        }
        const plugin = this._physicsEngine.getPhysicsPlugin();
        if (!plugin.setBodyStiffness) {
          return;
        }
        plugin.setBodyStiffness(this, value);
      }
      /**
       * Gets the velocityIterations of a soft body; only supported by the AmmoJSPlugin
       */
      get velocityIterations() {
        if (!this._physicsEngine) {
          return 0;
        }
        const plugin = this._physicsEngine.getPhysicsPlugin();
        if (!plugin.getBodyVelocityIterations) {
          return 0;
        }
        return plugin.getBodyVelocityIterations(this);
      }
      /**
       * Sets the velocityIterations of a soft body; only supported by the AmmoJSPlugin
       */
      set velocityIterations(value) {
        if (!this._physicsEngine) {
          return;
        }
        const plugin = this._physicsEngine.getPhysicsPlugin();
        if (!plugin.setBodyVelocityIterations) {
          return;
        }
        plugin.setBodyVelocityIterations(this, value);
      }
      /**
       * Gets the positionIterations of a soft body; only supported by the AmmoJSPlugin
       */
      get positionIterations() {
        if (!this._physicsEngine) {
          return 0;
        }
        const plugin = this._physicsEngine.getPhysicsPlugin();
        if (!plugin.getBodyPositionIterations) {
          return 0;
        }
        return plugin.getBodyPositionIterations(this);
      }
      /**
       * Sets the positionIterations of a soft body; only supported by the AmmoJSPlugin
       */
      set positionIterations(value) {
        if (!this._physicsEngine) {
          return;
        }
        const plugin = this._physicsEngine.getPhysicsPlugin();
        if (!plugin.setBodyPositionIterations) {
          return;
        }
        plugin.setBodyPositionIterations(this, value);
      }
      /**
       * Initializes the physics imposter
       * @param object The physics-enabled object used as the physics imposter
       * @param type The type of the physics imposter. Types are available as static members of this class.
       * @param _options The options for the physics imposter
       * @param _scene The Babylon scene
       */
      constructor(object, type, _options = { mass: 0 }, _scene) {
        this.object = object;
        this.type = type;
        this._options = _options;
        this._scene = _scene;
        this._pluginData = {};
        this._bodyUpdateRequired = false;
        this._onBeforePhysicsStepCallbacks = new Array();
        this._onAfterPhysicsStepCallbacks = new Array();
        this._onPhysicsCollideCallbacks = [];
        this._deltaPosition = Vector3.Zero();
        this._isDisposed = false;
        this.soft = false;
        this.segments = 0;
        this._tmpQuat = new Quaternion();
        this._tmpQuat2 = new Quaternion();
        this.beforeStep = () => {
          if (!this._physicsEngine) {
            return;
          }
          this.object.translate(this._deltaPosition, -1);
          if (this._deltaRotationConjugated && this.object.rotationQuaternion) {
            this.object.rotationQuaternion.multiplyToRef(this._deltaRotationConjugated, this.object.rotationQuaternion);
          }
          this.object.computeWorldMatrix(false);
          if (this.object.parent && this.object.rotationQuaternion) {
            this.getParentsRotation();
            this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this._tmpQuat);
          } else {
            this._tmpQuat.copyFrom(this.object.rotationQuaternion || new Quaternion());
          }
          if (!this._options.disableBidirectionalTransformation) {
            if (this.object.rotationQuaternion) {
              this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(
                this,
                /*bInfo.boundingBox.centerWorld*/
                this.object.getAbsolutePosition(),
                this._tmpQuat
              );
            }
          }
          for (const func of this._onBeforePhysicsStepCallbacks) {
            func(this);
          }
        };
        this.afterStep = () => {
          if (!this._physicsEngine) {
            return;
          }
          for (const func of this._onAfterPhysicsStepCallbacks) {
            func(this);
          }
          this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(this);
          if (this.object.parent && this.object.rotationQuaternion) {
            this.getParentsRotation();
            this._tmpQuat.conjugateInPlace();
            this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this.object.rotationQuaternion);
          }
          this.object.setAbsolutePosition(this.object.position);
          if (this._deltaRotation) {
            if (this.object.rotationQuaternion) {
              this.object.rotationQuaternion.multiplyToRef(this._deltaRotation, this.object.rotationQuaternion);
            }
            this._deltaPosition.applyRotationQuaternionToRef(this._deltaRotation, _PhysicsImpostor._TmpVecs[0]);
            this.object.translate(_PhysicsImpostor._TmpVecs[0], 1);
          } else {
            this.object.translate(this._deltaPosition, 1);
          }
          this.object.computeWorldMatrix(true);
        };
        this.onCollideEvent = null;
        this.onCollide = (e) => {
          if (!this._onPhysicsCollideCallbacks.length && !this.onCollideEvent) {
            return;
          }
          if (!this._physicsEngine) {
            return;
          }
          const otherImpostor = this._physicsEngine.getImpostorWithPhysicsBody(e.body);
          if (otherImpostor) {
            if (this.onCollideEvent) {
              this.onCollideEvent(this, otherImpostor);
            }
            const callbacks = this._onPhysicsCollideCallbacks.filter((obj) => {
              return obj.otherImpostors.indexOf(otherImpostor) !== -1;
            });
            for (const obj of callbacks) {
              obj.callback(this, otherImpostor, e.point, e.distance, e.impulse, e.normal);
            }
          }
        };
        if (!this.object) {
          Logger.Error("No object was provided. A physics object is obligatory");
          return;
        }
        if (this.object.parent && _options.mass !== 0) {
          Logger.Warn("A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur.");
        }
        if (!this._scene && object.getScene) {
          this._scene = object.getScene();
        }
        if (!this._scene) {
          return;
        }
        if (this.type > 100) {
          this.soft = true;
        }
        this._physicsEngine = this._scene.getPhysicsEngine();
        if (!this._physicsEngine) {
          Logger.Error("Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.");
        } else {
          if (!this.object.rotationQuaternion) {
            if (this.object.rotation) {
              this.object.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);
            } else {
              this.object.rotationQuaternion = new Quaternion();
            }
          }
          this._options.mass = _options.mass === void 0 ? 0 : _options.mass;
          this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;
          this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;
          if (this.soft) {
            this._options.mass = this._options.mass > 0 ? this._options.mass : 1;
            this._options.pressure = _options.pressure === void 0 ? 200 : _options.pressure;
            this._options.stiffness = _options.stiffness === void 0 ? 1 : _options.stiffness;
            this._options.velocityIterations = _options.velocityIterations === void 0 ? 20 : _options.velocityIterations;
            this._options.positionIterations = _options.positionIterations === void 0 ? 20 : _options.positionIterations;
            this._options.fixedPoints = _options.fixedPoints === void 0 ? 0 : _options.fixedPoints;
            this._options.margin = _options.margin === void 0 ? 0 : _options.margin;
            this._options.damping = _options.damping === void 0 ? 0 : _options.damping;
            this._options.path = _options.path === void 0 ? null : _options.path;
            this._options.shape = _options.shape === void 0 ? null : _options.shape;
          }
          this._joints = [];
          if (!this.object.parent || this._options.ignoreParent) {
            this._init();
          } else if (this.object.parent.physicsImpostor) {
            Logger.Warn("You must affect impostors to children before affecting impostor to parent.");
          }
        }
      }
      /**
       * This function will completely initialize this impostor.
       * It will create a new body - but only if this mesh has no parent.
       * If it has, this impostor will not be used other than to define the impostor
       * of the child mesh.
       * @internal
       */
      _init() {
        if (!this._physicsEngine) {
          return;
        }
        this._physicsEngine.removeImpostor(this);
        this.physicsBody = null;
        this._parent = this._parent || this._getPhysicsParent();
        if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {
          this._physicsEngine.addImpostor(this);
        }
      }
      _getPhysicsParent() {
        if (this.object.parent instanceof AbstractMesh) {
          const parentMesh = this.object.parent;
          return parentMesh.physicsImpostor;
        }
        return null;
      }
      /**
       * Should a new body be generated.
       * @returns boolean specifying if body initialization is required
       */
      isBodyInitRequired() {
        return this._bodyUpdateRequired || !this._physicsBody && (!this._parent || !!this._options.ignoreParent);
      }
      /**
       * Sets the updated scaling
       */
      setScalingUpdated() {
        this.forceUpdate();
      }
      /**
       * Force a regeneration of this or the parent's impostor's body.
       * Use with caution - This will remove all previously-instantiated joints.
       */
      forceUpdate() {
        this._init();
        if (this.parent && !this._options.ignoreParent) {
          this.parent.forceUpdate();
        }
      }
      /*public get mesh(): AbstractMesh {
          return this._mesh;
      }*/
      /**
       * Gets the body that holds this impostor. Either its own, or its parent.
       */
      get physicsBody() {
        return this._parent && !this._options.ignoreParent ? this._parent.physicsBody : this._physicsBody;
      }
      /**
       * Get the parent of the physics imposter
       * @returns Physics imposter or null
       */
      get parent() {
        return !this._options.ignoreParent && this._parent ? this._parent : null;
      }
      /**
       * Sets the parent of the physics imposter
       */
      set parent(value) {
        this._parent = value;
      }
      /**
       * Set the physics body. Used mainly by the physics engine/plugin
       */
      set physicsBody(physicsBody) {
        if (this._physicsBody && this._physicsEngine) {
          this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);
        }
        this._physicsBody = physicsBody;
        this.resetUpdateFlags();
      }
      /**
       * Resets the update flags
       */
      resetUpdateFlags() {
        this._bodyUpdateRequired = false;
      }
      /**
       * Gets the object extents
       * @returns the object extents
       */
      getObjectExtents() {
        if (this.object.getBoundingInfo) {
          const q = this.object.rotationQuaternion;
          const scaling = this.object.scaling.clone();
          this.object.rotationQuaternion = _PhysicsImpostor.IDENTITY_QUATERNION;
          const worldMatrix = this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);
          if (worldMatrix) {
            worldMatrix.decompose(scaling, void 0, void 0);
          }
          const boundingInfo = this.object.getBoundingInfo();
          const size = boundingInfo.boundingBox.extendSize.scale(2).multiplyInPlace(scaling);
          size.x = Math.abs(size.x);
          size.y = Math.abs(size.y);
          size.z = Math.abs(size.z);
          this.object.rotationQuaternion = q;
          if (this.object.computeWorldMatrix) {
            this.object.computeWorldMatrix(true);
          }
          return size;
        } else {
          return _PhysicsImpostor.DEFAULT_OBJECT_SIZE;
        }
      }
      /**
       * Gets the object center
       * @returns The object center
       */
      getObjectCenter() {
        if (this.object.getBoundingInfo) {
          const boundingInfo = this.object.getBoundingInfo();
          return boundingInfo.boundingBox.centerWorld;
        } else {
          return this.object.position;
        }
      }
      /**
       * Get a specific parameter from the options parameters
       * @param paramName The object parameter name
       * @returns The object parameter
       */
      getParam(paramName) {
        return this._options[paramName];
      }
      /**
       * Sets a specific parameter in the options given to the physics plugin
       * @param paramName The parameter name
       * @param value The value of the parameter
       */
      setParam(paramName, value) {
        this._options[paramName] = value;
        this._bodyUpdateRequired = true;
      }
      /**
       * Specifically change the body's mass. Won't recreate the physics body object
       * @param mass The mass of the physics imposter
       */
      setMass(mass) {
        if (this.getParam("mass") !== mass) {
          this.setParam("mass", mass);
        }
        if (this._physicsEngine) {
          this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);
        }
      }
      /**
       * Gets the linear velocity
       * @returns  linear velocity or null
       */
      getLinearVelocity() {
        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this) : Vector3.Zero();
      }
      /**
       * Sets the linear velocity
       * @param velocity  linear velocity or null
       */
      setLinearVelocity(velocity) {
        if (this._physicsEngine) {
          this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);
        }
      }
      /**
       * Gets the angular velocity
       * @returns angular velocity or null
       */
      getAngularVelocity() {
        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this) : Vector3.Zero();
      }
      /**
       * Sets the angular velocity
       * @param velocity The velocity or null
       */
      setAngularVelocity(velocity) {
        if (this._physicsEngine) {
          this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);
        }
      }
      /**
       * Execute a function with the physics plugin native code
       * Provide a function the will have two variables - the world object and the physics body object
       * @param func The function to execute with the physics plugin native code
       */
      executeNativeFunction(func) {
        if (this._physicsEngine) {
          func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);
        }
      }
      /**
       * Register a function that will be executed before the physics world is stepping forward
       * @param func The function to execute before the physics world is stepped forward
       */
      registerBeforePhysicsStep(func) {
        this._onBeforePhysicsStepCallbacks.push(func);
      }
      /**
       * Unregister a function that will be executed before the physics world is stepping forward
       * @param func The function to execute before the physics world is stepped forward
       */
      unregisterBeforePhysicsStep(func) {
        const index = this._onBeforePhysicsStepCallbacks.indexOf(func);
        if (index > -1) {
          this._onBeforePhysicsStepCallbacks.splice(index, 1);
        } else {
          Logger.Warn("Function to remove was not found");
        }
      }
      /**
       * Register a function that will be executed after the physics step
       * @param func The function to execute after physics step
       */
      registerAfterPhysicsStep(func) {
        this._onAfterPhysicsStepCallbacks.push(func);
      }
      /**
       * Unregisters a function that will be executed after the physics step
       * @param func The function to execute after physics step
       */
      unregisterAfterPhysicsStep(func) {
        const index = this._onAfterPhysicsStepCallbacks.indexOf(func);
        if (index > -1) {
          this._onAfterPhysicsStepCallbacks.splice(index, 1);
        } else {
          Logger.Warn("Function to remove was not found");
        }
      }
      /**
       * register a function that will be executed when this impostor collides against a different body
       * @param collideAgainst Physics imposter, or array of physics imposters to collide against
       * @param func Callback that is executed on collision
       */
      registerOnPhysicsCollide(collideAgainst, func) {
        const collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
        this._onPhysicsCollideCallbacks.push({ callback: func, otherImpostors: collidedAgainstList });
      }
      /**
       * Unregisters the physics imposter's collision callback
       * @param collideAgainst The physics object to collide against
       * @param func Callback to execute on collision
       */
      unregisterOnPhysicsCollide(collideAgainst, func) {
        const collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
        let index = -1;
        const found = this._onPhysicsCollideCallbacks.some((cbDef, idx) => {
          if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {
            const sameList = cbDef.otherImpostors.every((impostor) => {
              return collidedAgainstList.indexOf(impostor) > -1;
            });
            if (sameList) {
              index = idx;
            }
            return sameList;
          }
          return false;
        });
        if (found) {
          this._onPhysicsCollideCallbacks.splice(index, 1);
        } else {
          Logger.Warn("Function to remove was not found");
        }
      }
      /**
       * Get the parent rotation
       * @returns The parent rotation
       */
      getParentsRotation() {
        let parent = this.object.parent;
        this._tmpQuat.copyFromFloats(0, 0, 0, 1);
        while (parent) {
          if (parent.rotationQuaternion) {
            this._tmpQuat2.copyFrom(parent.rotationQuaternion);
          } else {
            Quaternion.RotationYawPitchRollToRef(parent.rotation.y, parent.rotation.x, parent.rotation.z, this._tmpQuat2);
          }
          this._tmpQuat.multiplyToRef(this._tmpQuat2, this._tmpQuat);
          parent = parent.parent;
        }
        return this._tmpQuat;
      }
      /**
       * Apply a force
       * @param force The force to apply
       * @param contactPoint The contact point for the force
       * @returns The physics imposter
       */
      applyForce(force, contactPoint) {
        if (this._physicsEngine) {
          this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);
        }
        return this;
      }
      /**
       * Apply an impulse
       * @param force The impulse force
       * @param contactPoint The contact point for the impulse force
       * @returns The physics imposter
       */
      applyImpulse(force, contactPoint) {
        if (this._physicsEngine) {
          this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);
        }
        return this;
      }
      /**
       * A help function to create a joint
       * @param otherImpostor A physics imposter used to create a joint
       * @param jointType The type of joint
       * @param jointData The data for the joint
       * @returns The physics imposter
       */
      createJoint(otherImpostor, jointType, jointData) {
        const joint = new PhysicsJoint(jointType, jointData);
        this.addJoint(otherImpostor, joint);
        return this;
      }
      /**
       * Add a joint to this impostor with a different impostor
       * @param otherImpostor A physics imposter used to add a joint
       * @param joint The joint to add
       * @returns The physics imposter
       */
      addJoint(otherImpostor, joint) {
        this._joints.push({
          otherImpostor,
          joint
        });
        if (this._physicsEngine) {
          this._physicsEngine.addJoint(this, otherImpostor, joint);
        }
        return this;
      }
      /**
       * Add an anchor to a cloth impostor
       * @param otherImpostor rigid impostor to anchor to
       * @param width ratio across width from 0 to 1
       * @param height ratio up height from 0 to 1
       * @param influence the elasticity between cloth impostor and anchor from 0, very stretchy to 1, little stretch
       * @param noCollisionBetweenLinkedBodies when true collisions between cloth impostor and anchor are ignored; default false
       * @returns impostor the soft imposter
       */
      addAnchor(otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies) {
        if (!this._physicsEngine) {
          return this;
        }
        const plugin = this._physicsEngine.getPhysicsPlugin();
        if (!plugin.appendAnchor) {
          return this;
        }
        if (this._physicsEngine) {
          plugin.appendAnchor(this, otherImpostor, width, height, influence, noCollisionBetweenLinkedBodies);
        }
        return this;
      }
      /**
       * Add a hook to a rope impostor
       * @param otherImpostor rigid impostor to anchor to
       * @param length ratio across rope from 0 to 1
       * @param influence the elasticity between rope impostor and anchor from 0, very stretchy to 1, little stretch
       * @param noCollisionBetweenLinkedBodies when true collisions between soft impostor and anchor are ignored; default false
       * @returns impostor the rope imposter
       */
      addHook(otherImpostor, length, influence, noCollisionBetweenLinkedBodies) {
        if (!this._physicsEngine) {
          return this;
        }
        const plugin = this._physicsEngine.getPhysicsPlugin();
        if (!plugin.appendAnchor) {
          return this;
        }
        if (this._physicsEngine) {
          plugin.appendHook(this, otherImpostor, length, influence, noCollisionBetweenLinkedBodies);
        }
        return this;
      }
      /**
       * Will keep this body still, in a sleep mode.
       * @returns the physics imposter
       */
      sleep() {
        if (this._physicsEngine) {
          this._physicsEngine.getPhysicsPlugin().sleepBody(this);
        }
        return this;
      }
      /**
       * Wake the body up.
       * @returns The physics imposter
       */
      wakeUp() {
        if (this._physicsEngine) {
          this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);
        }
        return this;
      }
      /**
       * Clones the physics imposter
       * @param newObject The physics imposter clones to this physics-enabled object
       * @returns A nullable physics imposter
       */
      clone(newObject) {
        if (!newObject) {
          return null;
        }
        return new _PhysicsImpostor(newObject, this.type, this._options, this._scene);
      }
      /**
       * Disposes the physics imposter
       */
      dispose() {
        if (!this._physicsEngine) {
          return;
        }
        for (const j of this._joints) {
          if (this._physicsEngine) {
            this._physicsEngine.removeJoint(this, j.otherImpostor, j.joint);
          }
        }
        this._physicsEngine.removeImpostor(this);
        if (this.parent) {
          this.parent.forceUpdate();
        }
        this._isDisposed = true;
      }
      /**
       * Sets the delta position
       * @param position The delta position amount
       */
      setDeltaPosition(position) {
        this._deltaPosition.copyFrom(position);
      }
      /**
       * Sets the delta rotation
       * @param rotation The delta rotation amount
       */
      setDeltaRotation(rotation) {
        if (!this._deltaRotation) {
          this._deltaRotation = new Quaternion();
        }
        this._deltaRotation.copyFrom(rotation);
        this._deltaRotationConjugated = this._deltaRotation.conjugate();
      }
      /**
       * Gets the box size of the physics imposter and stores the result in the input parameter
       * @param result Stores the box size
       * @returns The physics imposter
       */
      getBoxSizeToRef(result) {
        if (this._physicsEngine) {
          this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);
        }
        return this;
      }
      /**
       * Gets the radius of the physics imposter
       * @returns Radius of the physics imposter
       */
      getRadius() {
        return this._physicsEngine ? this._physicsEngine.getPhysicsPlugin().getRadius(this) : 0;
      }
      /**
       * Sync a bone with this impostor
       * @param bone The bone to sync to the impostor.
       * @param boneMesh The mesh that the bone is influencing.
       * @param jointPivot The pivot of the joint / bone in local space.
       * @param distToJoint Optional distance from the impostor to the joint.
       * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
       */
      syncBoneWithImpostor(bone, boneMesh, jointPivot, distToJoint, adjustRotation) {
        const tempVec = _PhysicsImpostor._TmpVecs[0];
        const mesh = this.object;
        if (mesh.rotationQuaternion) {
          if (adjustRotation) {
            const tempQuat = _PhysicsImpostor._TmpQuat;
            mesh.rotationQuaternion.multiplyToRef(adjustRotation, tempQuat);
            bone.setRotationQuaternion(tempQuat, 1, boneMesh);
          } else {
            bone.setRotationQuaternion(mesh.rotationQuaternion, 1, boneMesh);
          }
        }
        tempVec.x = 0;
        tempVec.y = 0;
        tempVec.z = 0;
        if (jointPivot) {
          tempVec.x = jointPivot.x;
          tempVec.y = jointPivot.y;
          tempVec.z = jointPivot.z;
          bone.getDirectionToRef(tempVec, boneMesh, tempVec);
          if (distToJoint === void 0 || distToJoint === null) {
            distToJoint = jointPivot.length();
          }
          tempVec.x *= distToJoint;
          tempVec.y *= distToJoint;
          tempVec.z *= distToJoint;
        }
        if (bone.getParent()) {
          tempVec.addInPlace(mesh.getAbsolutePosition());
          bone.setAbsolutePosition(tempVec, boneMesh);
        } else {
          boneMesh.setAbsolutePosition(mesh.getAbsolutePosition());
          boneMesh.position.x -= tempVec.x;
          boneMesh.position.y -= tempVec.y;
          boneMesh.position.z -= tempVec.z;
        }
      }
      /**
       * Sync impostor to a bone
       * @param bone The bone that the impostor will be synced to.
       * @param boneMesh The mesh that the bone is influencing.
       * @param jointPivot The pivot of the joint / bone in local space.
       * @param distToJoint Optional distance from the impostor to the joint.
       * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.
       * @param boneAxis Optional vector3 axis the bone is aligned with
       */
      syncImpostorWithBone(bone, boneMesh, jointPivot, distToJoint, adjustRotation, boneAxis) {
        const mesh = this.object;
        if (mesh.rotationQuaternion) {
          if (adjustRotation) {
            const tempQuat = _PhysicsImpostor._TmpQuat;
            bone.getRotationQuaternionToRef(1, boneMesh, tempQuat);
            tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);
          } else {
            bone.getRotationQuaternionToRef(1, boneMesh, mesh.rotationQuaternion);
          }
        }
        const pos = _PhysicsImpostor._TmpVecs[0];
        const boneDir = _PhysicsImpostor._TmpVecs[1];
        if (!boneAxis) {
          boneAxis = _PhysicsImpostor._TmpVecs[2];
          boneAxis.x = 0;
          boneAxis.y = 1;
          boneAxis.z = 0;
        }
        bone.getDirectionToRef(boneAxis, boneMesh, boneDir);
        bone.getAbsolutePositionToRef(boneMesh, pos);
        if ((distToJoint === void 0 || distToJoint === null) && jointPivot) {
          distToJoint = jointPivot.length();
        }
        if (distToJoint !== void 0 && distToJoint !== null) {
          pos.x += boneDir.x * distToJoint;
          pos.y += boneDir.y * distToJoint;
          pos.z += boneDir.z * distToJoint;
        }
        mesh.setAbsolutePosition(pos);
      }
    };
    PhysicsImpostor.DEFAULT_OBJECT_SIZE = new Vector3(1, 1, 1);
    PhysicsImpostor.IDENTITY_QUATERNION = Quaternion.Identity();
    PhysicsImpostor._TmpVecs = BuildArray(3, Vector3.Zero);
    PhysicsImpostor._TmpQuat = Quaternion.Identity();
    PhysicsImpostor.NoImpostor = 0;
    PhysicsImpostor.SphereImpostor = 1;
    PhysicsImpostor.BoxImpostor = 2;
    PhysicsImpostor.PlaneImpostor = 3;
    PhysicsImpostor.MeshImpostor = 4;
    PhysicsImpostor.CapsuleImpostor = 6;
    PhysicsImpostor.CylinderImpostor = 7;
    PhysicsImpostor.ParticleImpostor = 8;
    PhysicsImpostor.HeightmapImpostor = 9;
    PhysicsImpostor.ConvexHullImpostor = 10;
    PhysicsImpostor.CustomImpostor = 100;
    PhysicsImpostor.RopeImpostor = 101;
    PhysicsImpostor.ClothImpostor = 102;
    PhysicsImpostor.SoftbodyImpostor = 103;
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/capsuleBuilder.js
function CreateCapsuleVertexData(options = {
  subdivisions: 2,
  tessellation: 16,
  height: 1,
  radius: 0.25,
  capSubdivisions: 6
}) {
  const subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1) | 0;
  const tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3) | 0;
  const height = Math.max(options.height ? options.height : 1, 0);
  const radius = Math.max(options.radius ? options.radius : 0.25, 0);
  const capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1) | 0;
  const radialSegments = tessellation;
  const heightSegments = subdivisions;
  const radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0);
  const radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0);
  const heightMinusCaps = height - (radiusTop + radiusBottom);
  const thetaStart = 0;
  const thetaLength = 2 * Math.PI;
  const capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);
  const capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);
  const alpha = Math.acos((radiusBottom - radiusTop) / height);
  let indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  let index = 0;
  const indexArray = [], halfHeight = heightMinusCaps * 0.5;
  const pi2 = Math.PI * 0.5;
  let x, y;
  const normal = Vector3.Zero();
  const vertex = Vector3.Zero();
  const cosAlpha = Math.cos(alpha);
  const sinAlpha = Math.sin(alpha);
  const coneLength = new Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha).subtract(new Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha)).length();
  const vl = radiusTop * alpha + coneLength + radiusBottom * (pi2 - alpha);
  let v = 0;
  for (y = 0; y <= capsTopSegments; y++) {
    const indexRow = [];
    const a = pi2 - alpha * (y / capsTopSegments);
    v += radiusTop * alpha / capsTopSegments;
    const cosA = Math.cos(a);
    const sinA = Math.sin(a);
    const _radius = cosA * radiusTop;
    for (x = 0; x <= radialSegments; x++) {
      const u = x / radialSegments;
      const theta = u * thetaLength + thetaStart;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      vertex.x = _radius * sinTheta;
      vertex.y = halfHeight + sinA * radiusTop;
      vertex.z = _radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, useOpenGLOrientationForUV ? v / vl : 1 - v / vl);
      indexRow.push(index);
      index++;
    }
    indexArray.push(indexRow);
  }
  const coneHeight = height - radiusTop - radiusBottom + cosAlpha * radiusTop - cosAlpha * radiusBottom;
  const slope = sinAlpha * (radiusBottom - radiusTop) / coneHeight;
  for (y = 1; y <= heightSegments; y++) {
    const indexRow = [];
    v += coneLength / heightSegments;
    const _radius = sinAlpha * (y * (radiusBottom - radiusTop) / heightSegments + radiusTop);
    for (x = 0; x <= radialSegments; x++) {
      const u = x / radialSegments;
      const theta = u * thetaLength + thetaStart;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      vertex.x = _radius * sinTheta;
      vertex.y = halfHeight + cosAlpha * radiusTop - y * coneHeight / heightSegments;
      vertex.z = _radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.set(sinTheta, slope, cosTheta).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, useOpenGLOrientationForUV ? v / vl : 1 - v / vl);
      indexRow.push(index);
      index++;
    }
    indexArray.push(indexRow);
  }
  for (y = 1; y <= capsBottomSegments; y++) {
    const indexRow = [];
    const a = pi2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);
    v += radiusBottom * alpha / capsBottomSegments;
    const cosA = Math.cos(a);
    const sinA = Math.sin(a);
    const _radius = cosA * radiusBottom;
    for (x = 0; x <= radialSegments; x++) {
      const u = x / radialSegments;
      const theta = u * thetaLength + thetaStart;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      vertex.x = _radius * sinTheta;
      vertex.y = -halfHeight + sinA * radiusBottom;
      vertex.z = _radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, useOpenGLOrientationForUV ? v / vl : 1 - v / vl);
      indexRow.push(index);
      index++;
    }
    indexArray.push(indexRow);
  }
  for (x = 0; x < radialSegments; x++) {
    for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {
      const i1 = indexArray[y][x];
      const i2 = indexArray[y + 1][x];
      const i3 = indexArray[y + 1][x + 1];
      const i4 = indexArray[y][x + 1];
      indices.push(i1);
      indices.push(i2);
      indices.push(i4);
      indices.push(i2);
      indices.push(i3);
      indices.push(i4);
    }
  }
  indices = indices.reverse();
  if (options.orientation && !options.orientation.equals(Vector3.Up())) {
    const m = new Matrix();
    options.orientation.clone().scale(Math.PI * 0.5).cross(Vector3.Up()).toQuaternion().toRotationMatrix(m);
    const v2 = Vector3.Zero();
    for (let i = 0; i < vertices.length; i += 3) {
      v2.set(vertices[i], vertices[i + 1], vertices[i + 2]);
      Vector3.TransformCoordinatesToRef(v2.clone(), m, v2);
      vertices[i] = v2.x;
      vertices[i + 1] = v2.y;
      vertices[i + 2] = v2.z;
    }
  }
  const vDat = new VertexData();
  vDat.positions = vertices;
  vDat.normals = normals;
  vDat.uvs = uvs;
  vDat.indices = indices;
  return vDat;
}
function CreateCapsule(name13, options = {
  orientation: Vector3.Up(),
  subdivisions: 2,
  tessellation: 16,
  height: 1,
  radius: 0.25,
  capSubdivisions: 6,
  updatable: false
}, scene = null) {
  const capsule = new Mesh(name13, scene);
  const vertexData = CreateCapsuleVertexData(options);
  vertexData.applyToMesh(capsule, options.updatable);
  return capsule;
}
var CapsuleBuilder;
var init_capsuleBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/capsuleBuilder.js"() {
    init_mesh_vertexData();
    init_math_vector();
    init_mesh();
    init_compatibilityOptions();
    CapsuleBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateCapsule
    };
    Mesh.CreateCapsule = (name13, options, scene) => {
      return CreateCapsule(name13, options, scene);
    };
    VertexData.CreateCapsule = CreateCapsuleVertexData;
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/ribbonBuilder.js
function CreateRibbonVertexData(options) {
  let pathArray = options.pathArray;
  const closeArray = options.closeArray || false;
  const closePath = options.closePath || false;
  const invertUV = options.invertUV || false;
  const defaultOffset = Math.floor(pathArray[0].length / 2);
  let offset = options.offset || defaultOffset;
  offset = offset > defaultOffset ? defaultOffset : Math.floor(offset);
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const customUV = options.uvs;
  const customColors = options.colors;
  const positions = [];
  const indices = [];
  const normals = [];
  const uvs = [];
  const us = [];
  const vs = [];
  const uTotalDistance = [];
  const vTotalDistance = [];
  let minlg;
  const lg = [];
  const idx = [];
  let p;
  let i;
  let j;
  if (pathArray.length < 2) {
    const ar1 = [];
    const ar2 = [];
    for (i = 0; i < pathArray[0].length - offset; i++) {
      ar1.push(pathArray[0][i]);
      ar2.push(pathArray[0][i + offset]);
    }
    pathArray = [ar1, ar2];
  }
  let idc = 0;
  const closePathCorr = closePath ? 1 : 0;
  const closeArrayCorr = closeArray ? 1 : 0;
  let path;
  let l;
  minlg = pathArray[0].length;
  let vectlg;
  let dist;
  for (p = 0; p < pathArray.length + closeArrayCorr; p++) {
    uTotalDistance[p] = 0;
    us[p] = [0];
    path = p === pathArray.length ? pathArray[0] : pathArray[p];
    l = path.length;
    minlg = minlg < l ? minlg : l;
    j = 0;
    while (j < l) {
      positions.push(path[j].x, path[j].y, path[j].z);
      if (j > 0) {
        vectlg = path[j].subtract(path[j - 1]).length();
        dist = vectlg + uTotalDistance[p];
        us[p].push(dist);
        uTotalDistance[p] = dist;
      }
      j++;
    }
    if (closePath) {
      j--;
      positions.push(path[0].x, path[0].y, path[0].z);
      vectlg = path[j].subtract(path[0]).length();
      dist = vectlg + uTotalDistance[p];
      us[p].push(dist);
      uTotalDistance[p] = dist;
    }
    lg[p] = l + closePathCorr;
    idx[p] = idc;
    idc += l + closePathCorr;
  }
  let path1;
  let path2;
  let vertex1 = null;
  let vertex2 = null;
  for (i = 0; i < minlg + closePathCorr; i++) {
    vTotalDistance[i] = 0;
    vs[i] = [0];
    for (p = 0; p < pathArray.length - 1 + closeArrayCorr; p++) {
      path1 = pathArray[p];
      path2 = p === pathArray.length - 1 ? pathArray[0] : pathArray[p + 1];
      if (i === minlg) {
        vertex1 = path1[0];
        vertex2 = path2[0];
      } else {
        vertex1 = path1[i];
        vertex2 = path2[i];
      }
      vectlg = vertex2.subtract(vertex1).length();
      dist = vectlg + vTotalDistance[i];
      vs[i].push(dist);
      vTotalDistance[i] = dist;
    }
  }
  let u;
  let v;
  if (customUV) {
    for (p = 0; p < customUV.length; p++) {
      uvs.push(customUV[p].x, useOpenGLOrientationForUV ? 1 - customUV[p].y : customUV[p].y);
    }
  } else {
    for (p = 0; p < pathArray.length + closeArrayCorr; p++) {
      for (i = 0; i < minlg + closePathCorr; i++) {
        u = uTotalDistance[p] != 0 ? us[p][i] / uTotalDistance[p] : 0;
        v = vTotalDistance[i] != 0 ? vs[i][p] / vTotalDistance[i] : 0;
        if (invertUV) {
          uvs.push(v, u);
        } else {
          uvs.push(u, useOpenGLOrientationForUV ? 1 - v : v);
        }
      }
    }
  }
  p = 0;
  let pi = 0;
  let l1 = lg[p] - 1;
  let l2 = lg[p + 1] - 1;
  let min = l1 < l2 ? l1 : l2;
  let shft = idx[1] - idx[0];
  const path1nb = lg.length - 1;
  while (pi <= min && p < path1nb) {
    indices.push(pi, pi + shft, pi + 1);
    indices.push(pi + shft + 1, pi + 1, pi + shft);
    pi += 1;
    if (pi === min) {
      p++;
      shft = idx[p + 1] - idx[p];
      l1 = lg[p] - 1;
      l2 = lg[p + 1] - 1;
      pi = idx[p];
      min = l1 < l2 ? l1 + pi : l2 + pi;
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  if (closePath) {
    let indexFirst = 0;
    let indexLast = 0;
    for (p = 0; p < pathArray.length; p++) {
      indexFirst = idx[p] * 3;
      if (p + 1 < pathArray.length) {
        indexLast = (idx[p + 1] - 1) * 3;
      } else {
        indexLast = normals.length - 3;
      }
      normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;
      normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;
      normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;
      const l3 = Math.sqrt(normals[indexFirst] * normals[indexFirst] + normals[indexFirst + 1] * normals[indexFirst + 1] + normals[indexFirst + 2] * normals[indexFirst + 2]);
      normals[indexFirst] /= l3;
      normals[indexFirst + 1] /= l3;
      normals[indexFirst + 2] /= l3;
      normals[indexLast] = normals[indexFirst];
      normals[indexLast + 1] = normals[indexFirst + 1];
      normals[indexLast + 2] = normals[indexFirst + 2];
    }
  }
  if (closeArray) {
    let indexFirst = idx[0] * 3;
    let indexLast = idx[pathArray.length] * 3;
    for (i = 0; i < minlg + closePathCorr; i++) {
      normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;
      normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;
      normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;
      const l3 = Math.sqrt(normals[indexFirst] * normals[indexFirst] + normals[indexFirst + 1] * normals[indexFirst + 1] + normals[indexFirst + 2] * normals[indexFirst + 2]);
      normals[indexFirst] /= l3;
      normals[indexFirst + 1] /= l3;
      normals[indexFirst + 2] /= l3;
      normals[indexLast] = normals[indexFirst];
      normals[indexLast + 1] = normals[indexFirst + 1];
      normals[indexLast + 2] = normals[indexFirst + 2];
      indexFirst += 3;
      indexLast += 3;
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  let colors = null;
  if (customColors) {
    colors = new Float32Array(customColors.length * 4);
    for (let c = 0; c < customColors.length; c++) {
      colors[c * 4] = customColors[c].r;
      colors[c * 4 + 1] = customColors[c].g;
      colors[c * 4 + 2] = customColors[c].b;
      colors[c * 4 + 3] = customColors[c].a;
    }
  }
  const vertexData = new VertexData();
  const positions32 = new Float32Array(positions);
  const normals32 = new Float32Array(normals);
  const uvs32 = new Float32Array(uvs);
  vertexData.indices = indices;
  vertexData.positions = positions32;
  vertexData.normals = normals32;
  vertexData.uvs = uvs32;
  if (colors) {
    vertexData.set(colors, VertexBuffer.ColorKind);
  }
  if (closePath) {
    vertexData._idx = idx;
  }
  return vertexData;
}
function CreateRibbon(name13, options, scene = null) {
  const pathArray = options.pathArray;
  const closeArray = options.closeArray;
  const closePath = options.closePath;
  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  const instance = options.instance;
  const updatable = options.updatable;
  if (instance) {
    const minimum = TmpVectors.Vector3[0].setAll(Number.MAX_VALUE);
    const maximum = TmpVectors.Vector3[1].setAll(-Number.MAX_VALUE);
    const positionFunction = (positions2) => {
      let minlg = pathArray[0].length;
      const mesh = instance;
      let i = 0;
      const ns = mesh._originalBuilderSideOrientation === Mesh.DOUBLESIDE ? 2 : 1;
      for (let si = 1; si <= ns; ++si) {
        for (let p = 0; p < pathArray.length; ++p) {
          const path = pathArray[p];
          const l = path.length;
          minlg = minlg < l ? minlg : l;
          for (let j = 0; j < minlg; ++j) {
            const pathPoint = path[j];
            positions2[i] = pathPoint.x;
            positions2[i + 1] = pathPoint.y;
            positions2[i + 2] = pathPoint.z;
            minimum.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);
            maximum.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);
            i += 3;
          }
          if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {
            const pathPoint = path[0];
            positions2[i] = pathPoint.x;
            positions2[i + 1] = pathPoint.y;
            positions2[i + 2] = pathPoint.z;
            i += 3;
          }
        }
      }
    };
    const positions = instance.getVerticesData(VertexBuffer.PositionKind);
    positionFunction(positions);
    if (instance.hasBoundingInfo) {
      instance.getBoundingInfo().reConstruct(minimum, maximum, instance._worldMatrix);
    } else {
      instance.buildBoundingInfo(minimum, maximum, instance._worldMatrix);
    }
    instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
    if (options.colors) {
      const colors = instance.getVerticesData(VertexBuffer.ColorKind);
      for (let c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {
        const color = options.colors[c];
        colors[colorIndex] = color.r;
        colors[colorIndex + 1] = color.g;
        colors[colorIndex + 2] = color.b;
        colors[colorIndex + 3] = color.a;
      }
      instance.updateVerticesData(VertexBuffer.ColorKind, colors, false, false);
    }
    if (options.uvs) {
      const uvs = instance.getVerticesData(VertexBuffer.UVKind);
      for (let i = 0; i < options.uvs.length; i++) {
        uvs[i * 2] = options.uvs[i].x;
        uvs[i * 2 + 1] = useOpenGLOrientationForUV ? 1 - options.uvs[i].y : options.uvs[i].y;
      }
      instance.updateVerticesData(VertexBuffer.UVKind, uvs, false, false);
    }
    if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {
      const indices = instance.getIndices();
      const normals = instance.getVerticesData(VertexBuffer.NormalKind);
      const params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;
      VertexData.ComputeNormals(positions, indices, normals, params);
      if (instance._creationDataStorage && instance._creationDataStorage.closePath) {
        let indexFirst = 0;
        let indexLast = 0;
        for (let p = 0; p < pathArray.length; p++) {
          indexFirst = instance._creationDataStorage.idx[p] * 3;
          if (p + 1 < pathArray.length) {
            indexLast = (instance._creationDataStorage.idx[p + 1] - 1) * 3;
          } else {
            indexLast = normals.length - 3;
          }
          normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;
          normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;
          normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;
          normals[indexLast] = normals[indexFirst];
          normals[indexLast + 1] = normals[indexFirst + 1];
          normals[indexLast + 2] = normals[indexFirst + 2];
        }
      }
      if (!instance.areNormalsFrozen) {
        instance.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);
      }
    }
    return instance;
  } else {
    const ribbon = new Mesh(name13, scene);
    ribbon._originalBuilderSideOrientation = sideOrientation;
    ribbon._creationDataStorage = new _CreationDataStorage();
    const vertexData = CreateRibbonVertexData(options);
    if (closePath) {
      ribbon._creationDataStorage.idx = vertexData._idx;
    }
    ribbon._creationDataStorage.closePath = closePath;
    ribbon._creationDataStorage.closeArray = closeArray;
    vertexData.applyToMesh(ribbon, updatable);
    return ribbon;
  }
}
var RibbonBuilder;
var init_ribbonBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/ribbonBuilder.js"() {
    init_math_vector();
    init_mesh();
    init_buffer();
    init_mesh_vertexData();
    init_compatibilityOptions();
    RibbonBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateRibbon
    };
    VertexData.CreateRibbon = CreateRibbonVertexData;
    Mesh.CreateRibbon = (name13, pathArray, closeArray = false, closePath, offset, scene, updatable = false, sideOrientation, instance) => {
      return CreateRibbon(name13, {
        pathArray,
        closeArray,
        closePath,
        offset,
        updatable,
        sideOrientation,
        instance
      }, scene);
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/discBuilder.js
function CreateDiscVertexData(options) {
  const positions = [];
  const indices = [];
  const normals = [];
  const uvs = [];
  const radius = options.radius || 0.5;
  const tessellation = options.tessellation || 64;
  const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  positions.push(0, 0, 0);
  uvs.push(0.5, 0.5);
  const theta = Math.PI * 2 * arc;
  const step = arc === 1 ? theta / tessellation : theta / (tessellation - 1);
  let a = 0;
  for (let t = 0; t < tessellation; t++) {
    const x = Math.cos(a);
    const y = Math.sin(a);
    const u = (x + 1) / 2;
    const v = (1 - y) / 2;
    positions.push(radius * x, radius * y, 0);
    uvs.push(u, useOpenGLOrientationForUV ? 1 - v : v);
    a += step;
  }
  if (arc === 1) {
    positions.push(positions[3], positions[4], positions[5]);
    uvs.push(uvs[2], useOpenGLOrientationForUV ? 1 - uvs[3] : uvs[3]);
  }
  const vertexNb = positions.length / 3;
  for (let i = 1; i < vertexNb - 1; i++) {
    indices.push(i + 1, 0, i);
  }
  VertexData.ComputeNormals(positions, indices, normals);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateDisc(name13, options = {}, scene = null) {
  const disc = new Mesh(name13, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  disc._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateDiscVertexData(options);
  vertexData.applyToMesh(disc, options.updatable);
  return disc;
}
var DiscBuilder;
var init_discBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/discBuilder.js"() {
    init_mesh();
    init_mesh_vertexData();
    init_compatibilityOptions();
    DiscBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateDisc
    };
    VertexData.CreateDisc = CreateDiscVertexData;
    Mesh.CreateDisc = (name13, radius, tessellation, scene = null, updatable, sideOrientation) => {
      const options = {
        radius,
        tessellation,
        sideOrientation,
        updatable
      };
      return CreateDisc(name13, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/tiledPlaneBuilder.js
function CreateTiledPlaneVertexData(options) {
  const flipTile = options.pattern || Mesh.NO_FLIP;
  const tileWidth = options.tileWidth || options.tileSize || 1;
  const tileHeight = options.tileHeight || options.tileSize || 1;
  const alignH = options.alignHorizontal || 0;
  const alignV = options.alignVertical || 0;
  const width = options.width || options.size || 1;
  const tilesX = Math.floor(width / tileWidth);
  let offsetX = width - tilesX * tileWidth;
  const height = options.height || options.size || 1;
  const tilesY = Math.floor(height / tileHeight);
  let offsetY = height - tilesY * tileHeight;
  const halfWidth = tileWidth * tilesX / 2;
  const halfHeight = tileHeight * tilesY / 2;
  let adjustX = 0;
  let adjustY = 0;
  let startX = 0;
  let startY = 0;
  let endX = 0;
  let endY = 0;
  if (offsetX > 0 || offsetY > 0) {
    startX = -halfWidth;
    startY = -halfHeight;
    endX = halfWidth;
    endY = halfHeight;
    switch (alignH) {
      case Mesh.CENTER:
        offsetX /= 2;
        startX -= offsetX;
        endX += offsetX;
        break;
      case Mesh.LEFT:
        endX += offsetX;
        adjustX = -offsetX / 2;
        break;
      case Mesh.RIGHT:
        startX -= offsetX;
        adjustX = offsetX / 2;
        break;
    }
    switch (alignV) {
      case Mesh.CENTER:
        offsetY /= 2;
        startY -= offsetY;
        endY += offsetY;
        break;
      case Mesh.BOTTOM:
        endY += offsetY;
        adjustY = -offsetY / 2;
        break;
      case Mesh.TOP:
        startY -= offsetY;
        adjustY = offsetY / 2;
        break;
    }
  }
  const positions = [];
  const normals = [];
  const uvBase = [];
  uvBase[0] = [0, 0, 1, 0, 1, 1, 0, 1];
  uvBase[1] = [0, 0, 1, 0, 1, 1, 0, 1];
  if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
    uvBase[1] = [1, 1, 0, 1, 0, 0, 1, 0];
  }
  if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
    uvBase[1] = [1, 0, 0, 0, 0, 1, 1, 1];
  }
  if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
    uvBase[1] = [0, 1, 1, 1, 1, 0, 0, 0];
  }
  let uvs = [];
  const colors = [];
  const indices = [];
  let index = 0;
  for (let y = 0; y < tilesY; y++) {
    for (let x = 0; x < tilesX; x++) {
      positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
      positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
      positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
      positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
        uvs = uvs.concat(uvBase[(x % 2 + y % 2) % 2]);
      } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvs = uvs.concat(uvBase[y % 2]);
      } else {
        uvs = uvs.concat(uvBase[0]);
      }
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      index += 4;
    }
  }
  if (offsetX > 0 || offsetY > 0) {
    const partialBottomRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.TOP);
    const partialTopRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.BOTTOM);
    const partialLeftCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.RIGHT);
    const partialRightCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.LEFT);
    let uvPart = [];
    let a, b, c, d;
    if (partialBottomRow && partialLeftCol) {
      positions.push(startX + adjustX, startY + adjustY, 0);
      positions.push(-halfWidth + adjustX, startY + adjustY, 0);
      positions.push(-halfWidth + adjustX, startY + offsetY + adjustY, 0);
      positions.push(startX + adjustX, startY + offsetY + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      index += 4;
      a = 1 - offsetX / tileWidth;
      b = 1 - offsetY / tileHeight;
      c = 1;
      d = 1;
      uvPart = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_ROW) {
        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_ROW) {
        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      uvs = uvs.concat(uvPart);
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
    }
    if (partialBottomRow && partialRightCol) {
      positions.push(halfWidth + adjustX, startY + adjustY, 0);
      positions.push(endX + adjustX, startY + adjustY, 0);
      positions.push(endX + adjustX, startY + offsetY + adjustY, 0);
      positions.push(halfWidth + adjustX, startY + offsetY + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      index += 4;
      a = 0;
      b = 1 - offsetY / tileHeight;
      c = offsetX / tileWidth;
      d = 1;
      uvPart = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.ROTATE_TILE && tilesX % 2 === 0) {
        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.FLIP_TILE && tilesX % 2 === 0) {
        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesX % 2 === 0) {
        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      uvs = uvs.concat(uvPart);
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
    }
    if (partialTopRow && partialLeftCol) {
      positions.push(startX + adjustX, halfHeight + adjustY, 0);
      positions.push(-halfWidth + adjustX, halfHeight + adjustY, 0);
      positions.push(-halfWidth + adjustX, endY + adjustY, 0);
      positions.push(startX + adjustX, endY + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      index += 4;
      a = 1 - offsetX / tileWidth;
      b = 0;
      c = 1;
      d = offsetY / tileHeight;
      uvPart = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.ROTATE_TILE && tilesY % 1 === 0) {
        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_TILE && tilesY % 2 === 0) {
        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesY % 2 === 0) {
        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      uvs = uvs.concat(uvPart);
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
    }
    if (partialTopRow && partialRightCol) {
      positions.push(halfWidth + adjustX, halfHeight + adjustY, 0);
      positions.push(endX + adjustX, halfHeight + adjustY, 0);
      positions.push(endX + adjustX, endY + adjustY, 0);
      positions.push(halfWidth + adjustX, endY + adjustY, 0);
      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
      index += 4;
      a = 0;
      b = 0;
      c = offsetX / tileWidth;
      d = offsetY / tileHeight;
      uvPart = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.ROTATE_TILE && (tilesY + tilesX) % 2 === 1) {
        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_TILE && (tilesY + tilesX) % 2 === 1) {
        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY + tilesX) % 2 === 1) {
        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      uvs = uvs.concat(uvPart);
      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
    }
    if (partialBottomRow) {
      const uvBaseBR = [];
      a = 0;
      b = 1 - offsetY / tileHeight;
      c = 1;
      d = 1;
      uvBaseBR[0] = [a, b, c, b, c, d, a, d];
      uvBaseBR[1] = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
        uvBaseBR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
        uvBaseBR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvBaseBR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      for (let x = 0; x < tilesX; x++) {
        positions.push(-halfWidth + x * tileWidth + adjustX, startY + adjustY, 0);
        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + adjustY, 0);
        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + offsetY + adjustY, 0);
        positions.push(-halfWidth + x * tileWidth + adjustX, startY + offsetY + adjustY, 0);
        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
        index += 4;
        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
          uvs = uvs.concat(uvBaseBR[(x + 1) % 2]);
        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
          uvs = uvs.concat(uvBaseBR[1]);
        } else {
          uvs = uvs.concat(uvBaseBR[0]);
        }
        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      }
    }
    if (partialTopRow) {
      const uvBaseTR = [];
      a = 0;
      b = 0;
      c = 1;
      d = offsetY / tileHeight;
      uvBaseTR[0] = [a, b, c, b, c, d, a, d];
      uvBaseTR[1] = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
        uvBaseTR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
        uvBaseTR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvBaseTR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      for (let x = 0; x < tilesX; x++) {
        positions.push(-halfWidth + x * tileWidth + adjustX, endY - offsetY + adjustY, 0);
        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY - offsetY + adjustY, 0);
        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY + adjustY, 0);
        positions.push(-halfWidth + x * tileWidth + adjustX, endY + adjustY, 0);
        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
        index += 4;
        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
          uvs = uvs.concat(uvBaseTR[(x + tilesY) % 2]);
        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
          uvs = uvs.concat(uvBaseTR[tilesY % 2]);
        } else {
          uvs = uvs.concat(uvBaseTR[0]);
        }
        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      }
    }
    if (partialLeftCol) {
      const uvBaseLC = [];
      a = 1 - offsetX / tileWidth;
      b = 0;
      c = 1;
      d = 1;
      uvBaseLC[0] = [a, b, c, b, c, d, a, d];
      uvBaseLC[1] = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
        uvBaseLC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
        uvBaseLC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvBaseLC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      for (let y = 0; y < tilesY; y++) {
        positions.push(startX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
        positions.push(startX + offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
        positions.push(startX + offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
        positions.push(startX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
        index += 4;
        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
          uvs = uvs.concat(uvBaseLC[(y + 1) % 2]);
        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
          uvs = uvs.concat(uvBaseLC[y % 2]);
        } else {
          uvs = uvs.concat(uvBaseLC[0]);
        }
        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      }
    }
    if (partialRightCol) {
      const uvBaseRC = [];
      a = 0;
      b = 0;
      c = offsetX / tileHeight;
      d = 1;
      uvBaseRC[0] = [a, b, c, b, c, d, a, d];
      uvBaseRC[1] = [a, b, c, b, c, d, a, d];
      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {
        uvBaseRC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];
      }
      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {
        uvBaseRC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];
      }
      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
        uvBaseRC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];
      }
      for (let y = 0; y < tilesY; y++) {
        positions.push(endX - offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
        positions.push(endX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);
        positions.push(endX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
        positions.push(endX - offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);
        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);
        index += 4;
        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {
          uvs = uvs.concat(uvBaseRC[(y + tilesX) % 2]);
        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {
          uvs = uvs.concat(uvBaseRC[y % 2]);
        } else {
          uvs = uvs.concat(uvBaseRC[0]);
        }
        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);
      }
    }
  }
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
  vertexData.colors = totalColors;
  return vertexData;
}
function CreateTiledPlane(name13, options, scene = null) {
  const plane = new Mesh(name13, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  plane._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateTiledPlaneVertexData(options);
  vertexData.applyToMesh(plane, options.updatable);
  return plane;
}
var TiledPlaneBuilder;
var init_tiledPlaneBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/tiledPlaneBuilder.js"() {
    init_mesh();
    init_mesh_vertexData();
    TiledPlaneBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateTiledPlane
    };
    VertexData.CreateTiledPlane = CreateTiledPlaneVertexData;
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/tiledBoxBuilder.js
function CreateTiledBoxVertexData(options) {
  const nbFaces = 6;
  const faceUV = options.faceUV || new Array(6);
  const faceColors = options.faceColors;
  const flipTile = options.pattern || Mesh.NO_FLIP;
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const depth = options.depth || options.size || 1;
  const tileWidth = options.tileWidth || options.tileSize || 1;
  const tileHeight = options.tileHeight || options.tileSize || 1;
  const alignH = options.alignHorizontal || 0;
  const alignV = options.alignVertical || 0;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  for (let f = 0; f < nbFaces; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  const halfWidth = width / 2;
  const halfHeight = height / 2;
  const halfDepth = depth / 2;
  const faceVertexData = [];
  for (let f = 0; f < 2; f++) {
    faceVertexData[f] = CreateTiledPlaneVertexData({
      pattern: flipTile,
      tileWidth,
      tileHeight,
      width,
      height,
      alignVertical: alignV,
      alignHorizontal: alignH,
      sideOrientation
    });
  }
  for (let f = 2; f < 4; f++) {
    faceVertexData[f] = CreateTiledPlaneVertexData({
      pattern: flipTile,
      tileWidth,
      tileHeight,
      width: depth,
      height,
      alignVertical: alignV,
      alignHorizontal: alignH,
      sideOrientation
    });
  }
  let baseAlignV = alignV;
  if (alignV === Mesh.BOTTOM) {
    baseAlignV = Mesh.TOP;
  } else if (alignV === Mesh.TOP) {
    baseAlignV = Mesh.BOTTOM;
  }
  for (let f = 4; f < 6; f++) {
    faceVertexData[f] = CreateTiledPlaneVertexData({
      pattern: flipTile,
      tileWidth,
      tileHeight,
      width,
      height: depth,
      alignVertical: baseAlignV,
      alignHorizontal: alignH,
      sideOrientation
    });
  }
  const positions = [];
  const normals = [];
  let uvs = [];
  let indices = [];
  const colors = [];
  const facePositions = [];
  const faceNormals = [];
  const newFaceUV = [];
  let lu = 0;
  let li = 0;
  for (let f = 0; f < nbFaces; f++) {
    const len = faceVertexData[f].positions.length;
    facePositions[f] = [];
    faceNormals[f] = [];
    for (let p = 0; p < len / 3; p++) {
      facePositions[f].push(new Vector3(faceVertexData[f].positions[3 * p], faceVertexData[f].positions[3 * p + 1], faceVertexData[f].positions[3 * p + 2]));
      faceNormals[f].push(new Vector3(faceVertexData[f].normals[3 * p], faceVertexData[f].normals[3 * p + 1], faceVertexData[f].normals[3 * p + 2]));
    }
    lu = faceVertexData[f].uvs.length;
    newFaceUV[f] = [];
    for (let i = 0; i < lu; i += 2) {
      newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs[i];
      newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs[i + 1];
      if (useOpenGLOrientationForUV) {
        newFaceUV[f][i + 1] = 1 - newFaceUV[f][i + 1];
      }
    }
    uvs = uvs.concat(newFaceUV[f]);
    indices = indices.concat(faceVertexData[f].indices.map((x) => x + li));
    li += facePositions[f].length;
    if (faceColors) {
      const color = faceColors[f];
      for (let p = 0; p < facePositions[f].length; p++) {
        colors.push(color.r, color.g, color.b, color.a);
      }
    }
  }
  const faceTransforms = [
    // FRONT
    { m: Matrix.RotationY(Math.PI), t: new Vector3(0, 0, halfDepth), op: OP_ADD },
    // BACK
    { m: Matrix.Identity(), t: new Vector3(0, 0, halfDepth), op: OP_SUB },
    // RIGHT
    { m: Matrix.RotationY(-Math.PI / 2), t: new Vector3(halfWidth, 0, 0), op: OP_ADD },
    // LEFT
    { m: Matrix.RotationY(Math.PI / 2), t: new Vector3(halfWidth, 0, 0), op: OP_SUB },
    // TOP
    { m: Matrix.RotationX(Math.PI / 2), t: new Vector3(0, halfHeight, 0), op: OP_ADD },
    // BOTTOM
    { m: Matrix.RotationX(-Math.PI / 2), t: new Vector3(0, halfHeight, 0), op: OP_SUB }
  ];
  for (let f = 0; f < nbFaces; f++) {
    const { m, t, op } = faceTransforms[f];
    for (const v of facePositions[f]) {
      const p = Vector3.TransformCoordinates(v, m);
      const final = op === OP_ADD ? p.add(t) : p.subtract(t);
      positions.push(final.x, final.y, final.z);
    }
    for (const n of faceNormals[f]) {
      const nn = Vector3.TransformNormal(n, m);
      normals.push(nn.x, nn.y, nn.z);
    }
  }
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
}
function CreateTiledBox(name13, options, scene = null) {
  const box = new Mesh(name13, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  box._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateTiledBoxVertexData(options);
  vertexData.applyToMesh(box, options.updatable);
  return box;
}
var OP_ADD, OP_SUB, TiledBoxBuilder;
var init_tiledBoxBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/tiledBoxBuilder.js"() {
    init_math_vector();
    init_math_color();
    init_mesh();
    init_mesh_vertexData();
    init_tiledPlaneBuilder();
    init_compatibilityOptions();
    OP_ADD = 1;
    OP_SUB = -1;
    TiledBoxBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateTiledBox
    };
    VertexData.CreateTiledBox = CreateTiledBoxVertexData;
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/torusKnotBuilder.js
function CreateTorusKnotVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  const radius = options.radius || 2;
  const tube = options.tube || 0.5;
  const radialSegments = options.radialSegments || 32;
  const tubularSegments = options.tubularSegments || 32;
  const p = options.p || 2;
  const q = options.q || 3;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const getPos = (angle) => {
    const cu = Math.cos(angle);
    const su = Math.sin(angle);
    const quOverP = q / p * angle;
    const cs = Math.cos(quOverP);
    const tx = radius * (2 + cs) * 0.5 * cu;
    const ty = radius * (2 + cs) * su * 0.5;
    const tz = radius * Math.sin(quOverP) * 0.5;
    return new Vector3(tx, ty, tz);
  };
  let i;
  let j;
  for (i = 0; i <= radialSegments; i++) {
    const modI = i % radialSegments;
    const u = modI / radialSegments * 2 * p * Math.PI;
    const p1 = getPos(u);
    const p2 = getPos(u + 0.01);
    const tang = p2.subtract(p1);
    let n = p2.add(p1);
    const bitan = Vector3.Cross(tang, n);
    n = Vector3.Cross(bitan, tang);
    bitan.normalize();
    n.normalize();
    for (j = 0; j < tubularSegments; j++) {
      const modJ = j % tubularSegments;
      const v = modJ / tubularSegments * 2 * Math.PI;
      const cx = -tube * Math.cos(v);
      const cy = tube * Math.sin(v);
      positions.push(p1.x + cx * n.x + cy * bitan.x);
      positions.push(p1.y + cx * n.y + cy * bitan.y);
      positions.push(p1.z + cx * n.z + cy * bitan.z);
      uvs.push(i / radialSegments);
      uvs.push(useOpenGLOrientationForUV ? 1 - j / tubularSegments : j / tubularSegments);
    }
  }
  for (i = 0; i < radialSegments; i++) {
    for (j = 0; j < tubularSegments; j++) {
      const jNext = (j + 1) % tubularSegments;
      const a = i * tubularSegments + j;
      const b = (i + 1) * tubularSegments + j;
      const c = (i + 1) * tubularSegments + jNext;
      const d = i * tubularSegments + jNext;
      indices.push(d);
      indices.push(b);
      indices.push(a);
      indices.push(d);
      indices.push(c);
      indices.push(b);
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateTorusKnot(name13, options = {}, scene) {
  const torusKnot = new Mesh(name13, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  torusKnot._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateTorusKnotVertexData(options);
  vertexData.applyToMesh(torusKnot, options.updatable);
  return torusKnot;
}
var TorusKnotBuilder;
var init_torusKnotBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/torusKnotBuilder.js"() {
    init_math_vector();
    init_mesh();
    init_mesh_vertexData();
    init_compatibilityOptions();
    TorusKnotBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateTorusKnot
    };
    VertexData.CreateTorusKnot = CreateTorusKnotVertexData;
    Mesh.CreateTorusKnot = (name13, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) => {
      const options = {
        radius,
        tube,
        radialSegments,
        tubularSegments,
        p,
        q,
        sideOrientation,
        updatable
      };
      return CreateTorusKnot(name13, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/linesBuilder.js
function CreateLineSystemVertexData(options) {
  const indices = [];
  const positions = [];
  const lines = options.lines;
  const colors = options.colors;
  const vertexColors = [];
  let idx = 0;
  for (let l = 0; l < lines.length; l++) {
    const points = lines[l];
    for (let index = 0; index < points.length; index++) {
      const { x, y, z } = points[index];
      positions.push(x, y, z);
      if (colors) {
        const color = colors[l];
        const { r, g, b, a } = color[index];
        vertexColors.push(r, g, b, a);
      }
      if (index > 0) {
        indices.push(idx - 1);
        indices.push(idx);
      }
      idx++;
    }
  }
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  if (colors) {
    vertexData.colors = vertexColors;
  }
  return vertexData;
}
function CreateDashedLinesVertexData(options) {
  const dashSize = options.dashSize || 3;
  const gapSize = options.gapSize || 1;
  const dashNb = options.dashNb || 200;
  const points = options.points;
  const positions = [];
  const indices = [];
  const curvect = Vector3.Zero();
  let lg = 0;
  let nb = 0;
  let shft = 0;
  let dashshft = 0;
  let curshft = 0;
  let idx = 0;
  let i = 0;
  for (i = 0; i < points.length - 1; i++) {
    points[i + 1].subtractToRef(points[i], curvect);
    lg += curvect.length();
  }
  shft = lg / dashNb;
  dashshft = dashSize * shft / (dashSize + gapSize);
  for (i = 0; i < points.length - 1; i++) {
    points[i + 1].subtractToRef(points[i], curvect);
    nb = Math.floor(curvect.length() / shft);
    curvect.normalize();
    for (let j = 0; j < nb; j++) {
      curshft = shft * j;
      positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);
      positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);
      indices.push(idx, idx + 1);
      idx += 2;
    }
  }
  const vertexData = new VertexData();
  vertexData.positions = positions;
  vertexData.indices = indices;
  return vertexData;
}
function CreateLineSystem(name13, options, scene = null) {
  const instance = options.instance;
  const lines = options.lines;
  const colors = options.colors;
  if (instance) {
    const positions = instance.getVerticesData(VertexBuffer.PositionKind);
    let vertexColor;
    let lineColors;
    if (colors) {
      vertexColor = instance.getVerticesData(VertexBuffer.ColorKind);
    }
    let i = 0;
    let c = 0;
    for (let l = 0; l < lines.length; l++) {
      const points = lines[l];
      for (let p = 0; p < points.length; p++) {
        positions[i] = points[p].x;
        positions[i + 1] = points[p].y;
        positions[i + 2] = points[p].z;
        if (colors && vertexColor) {
          lineColors = colors[l];
          vertexColor[c] = lineColors[p].r;
          vertexColor[c + 1] = lineColors[p].g;
          vertexColor[c + 2] = lineColors[p].b;
          vertexColor[c + 3] = lineColors[p].a;
          c += 4;
        }
        i += 3;
      }
    }
    instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
    if (colors && vertexColor) {
      instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);
    }
    instance.refreshBoundingInfo();
    return instance;
  }
  const useVertexColor = colors ? true : false;
  const lineSystem = new LinesMesh(name13, scene, null, void 0, void 0, useVertexColor, options.useVertexAlpha, options.material);
  const vertexData = CreateLineSystemVertexData(options);
  vertexData.applyToMesh(lineSystem, options.updatable);
  return lineSystem;
}
function CreateLines(name13, options, scene = null) {
  const colors = options.colors ? [options.colors] : null;
  const lines = CreateLineSystem(name13, { lines: [options.points], updatable: options.updatable, instance: options.instance, colors, useVertexAlpha: options.useVertexAlpha, material: options.material }, scene);
  return lines;
}
function CreateDashedLines(name13, options, scene = null) {
  const points = options.points;
  const instance = options.instance;
  const gapSize = options.gapSize || 1;
  const dashSize = options.dashSize || 3;
  if (instance) {
    const positionFunction = (positions) => {
      const curvect = Vector3.Zero();
      const nbSeg = positions.length / 6;
      let lg = 0;
      let nb = 0;
      let shft = 0;
      let dashshft = 0;
      let curshft = 0;
      let p = 0;
      let i = 0;
      let j = 0;
      for (i = 0; i < points.length - 1; i++) {
        points[i + 1].subtractToRef(points[i], curvect);
        lg += curvect.length();
      }
      shft = lg / nbSeg;
      const dashSize2 = instance._creationDataStorage.dashSize;
      const gapSize2 = instance._creationDataStorage.gapSize;
      dashshft = dashSize2 * shft / (dashSize2 + gapSize2);
      for (i = 0; i < points.length - 1; i++) {
        points[i + 1].subtractToRef(points[i], curvect);
        nb = Math.floor(curvect.length() / shft);
        curvect.normalize();
        j = 0;
        while (j < nb && p < positions.length) {
          curshft = shft * j;
          positions[p] = points[i].x + curshft * curvect.x;
          positions[p + 1] = points[i].y + curshft * curvect.y;
          positions[p + 2] = points[i].z + curshft * curvect.z;
          positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;
          positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;
          positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;
          p += 6;
          j++;
        }
      }
      while (p < positions.length) {
        positions[p] = points[i].x;
        positions[p + 1] = points[i].y;
        positions[p + 2] = points[i].z;
        p += 3;
      }
    };
    if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {
      Logger.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored.");
    }
    instance.updateMeshPositions(positionFunction, false);
    return instance;
  }
  const dashedLines = new LinesMesh(name13, scene, null, void 0, void 0, void 0, options.useVertexAlpha, options.material);
  const vertexData = CreateDashedLinesVertexData(options);
  vertexData.applyToMesh(dashedLines, options.updatable);
  dashedLines._creationDataStorage = new _CreationDataStorage();
  dashedLines._creationDataStorage.dashSize = dashSize;
  dashedLines._creationDataStorage.gapSize = gapSize;
  return dashedLines;
}
var LinesBuilder;
var init_linesBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/linesBuilder.js"() {
    init_math_vector();
    init_mesh();
    init_mesh_vertexData();
    init_linesMesh();
    init_buffer();
    init_logger();
    LinesBuilder = {
      CreateDashedLines,
      CreateLineSystem,
      CreateLines
    };
    VertexData.CreateLineSystem = CreateLineSystemVertexData;
    VertexData.CreateDashedLines = CreateDashedLinesVertexData;
    Mesh.CreateLines = (name13, points, scene = null, updatable = false, instance = null) => {
      const options = {
        points,
        updatable,
        instance
      };
      return CreateLines(name13, options, scene);
    };
    Mesh.CreateDashedLines = (name13, points, dashSize, gapSize, dashNb, scene = null, updatable, instance) => {
      const options = {
        points,
        dashSize,
        gapSize,
        dashNb,
        updatable,
        instance
      };
      return CreateDashedLines(name13, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/shapeBuilder.js
function ExtrudeShape(name13, options, scene = null) {
  const path = options.path;
  const shape = options.shape;
  const scale = options.scale || 1;
  const rotation = options.rotation || 0;
  const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;
  const updatable = options.updatable;
  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  const instance = options.instance || null;
  const invertUV = options.invertUV || false;
  const closeShape = options.closeShape || false;
  const closePath = options.closePath || false;
  const capFunction = options.capFunction || null;
  return ExtrudeShapeGeneric(name13, shape, path, scale, rotation, null, null, closePath, closeShape, cap, false, scene, updatable ? true : false, sideOrientation, instance, invertUV, options.frontUVs || null, options.backUVs || null, options.firstNormal || null, options.adjustFrame ? true : false, capFunction);
}
function ExtrudeShapeCustom(name13, options, scene = null) {
  const path = options.path;
  const shape = options.shape;
  const tmpVector3 = Vector3.Zero();
  const scaleFunction = (i, distance) => {
    const s = options.scaleFunction?.(i, distance) ?? 1;
    return tmpVector3.copyFromFloats(s, s, s);
  };
  const rotationFunction = options.rotationFunction || (() => {
    return 0;
  });
  const ribbonCloseArray = options.closePath || options.ribbonCloseArray || false;
  const ribbonClosePath = options.closeShape || options.ribbonClosePath || false;
  const cap = options.cap === 0 ? 0 : options.cap || Mesh.NO_CAP;
  const updatable = options.updatable;
  const firstNormal = options.firstNormal || null;
  const adjustFrame = options.adjustFrame || false;
  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  const instance = options.instance;
  const invertUV = options.invertUV || false;
  const capFunction = options.capFunction || null;
  return ExtrudeShapeGeneric(name13, shape, path, null, null, options.scaleVectorFunction ?? scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, true, scene, updatable ? true : false, sideOrientation, instance || null, invertUV, options.frontUVs || null, options.backUVs || null, firstNormal, adjustFrame, capFunction || null);
}
function ExtrudeShapeGeneric(name13, shape, curve, scale, rotation, scaleFunction, rotateFunction, rbCA, rbCP, cap, custom, scene, updtbl, side, instance, invertUV, frontUVs, backUVs, firstNormal, adjustFrame, capFunction) {
  const extrusionPathArray = (shape2, curve2, path3D2, shapePaths, scale2, rotation2, scaleFunction2, rotateFunction2, cap2, custom2, adjustFrame2) => {
    const tangents = path3D2.getTangents();
    const normals = path3D2.getNormals();
    const binormals = path3D2.getBinormals();
    const distances = path3D2.getDistances();
    if (adjustFrame2) {
      for (let i = 0; i < tangents.length; i++) {
        if (tangents[i].x == 0 && tangents[i].y == 0 && tangents[i].z == 0) {
          tangents[i].copyFrom(tangents[i - 1]);
        }
        if (normals[i].x == 0 && normals[i].y == 0 && normals[i].z == 0) {
          normals[i].copyFrom(normals[i - 1]);
        }
        if (binormals[i].x == 0 && binormals[i].y == 0 && binormals[i].z == 0) {
          binormals[i].copyFrom(binormals[i - 1]);
        }
        if (i > 0) {
          let v = tangents[i - 1];
          if (Vector3.Dot(v, tangents[i]) < 0) {
            tangents[i].scaleInPlace(-1);
          }
          v = normals[i - 1];
          if (Vector3.Dot(v, normals[i]) < 0) {
            normals[i].scaleInPlace(-1);
          }
          v = binormals[i - 1];
          if (Vector3.Dot(v, binormals[i]) < 0) {
            binormals[i].scaleInPlace(-1);
          }
        }
      }
    }
    let angle = 0;
    const returnScale = () => {
      return scale2 !== null ? scale2 : Vector3.OneReadOnly;
    };
    const returnRotation = () => {
      return rotation2 !== null ? rotation2 : 0;
    };
    const rotate = custom2 && rotateFunction2 ? rotateFunction2 : returnRotation;
    const scl = custom2 && scaleFunction2 ? scaleFunction2 : returnScale;
    let index = cap2 === Mesh.NO_CAP || cap2 === Mesh.CAP_END ? 0 : 2;
    const rotationMatrix = TmpVectors.Matrix[0];
    for (let i = 0; i < curve2.length; i++) {
      const shapePath = [];
      const angleStep = rotate(i, distances[i]);
      const scaleRatio = scl(i, distances[i]);
      Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);
      for (let p = 0; p < shape2.length; p++) {
        const planed = tangents[i].scale(shape2[p].z).add(normals[i].scale(shape2[p].x)).add(binormals[i].scale(shape2[p].y));
        const rotated = Vector3.Zero();
        Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);
        rotated.multiplyInPlace(scaleRatio).addInPlace(curve2[i]);
        shapePath[p] = rotated;
      }
      shapePaths[index] = shapePath;
      angle += angleStep;
      index++;
    }
    const defaultCapPath = (shapePath) => {
      const pointCap = Array();
      const barycenter = Vector3.Zero();
      let i;
      for (i = 0; i < shapePath.length; i++) {
        barycenter.addInPlace(shapePath[i]);
      }
      barycenter.scaleInPlace(1 / shapePath.length);
      for (i = 0; i < shapePath.length; i++) {
        pointCap.push(barycenter);
      }
      return pointCap;
    };
    const capPath = capFunction || defaultCapPath;
    switch (cap2) {
      case Mesh.NO_CAP:
        break;
      case Mesh.CAP_START:
        shapePaths[0] = capPath(shapePaths[2]);
        shapePaths[1] = shapePaths[2];
        break;
      case Mesh.CAP_END:
        shapePaths[index] = shapePaths[index - 1];
        shapePaths[index + 1] = capPath(shapePaths[index - 1]);
        break;
      case Mesh.CAP_ALL:
        shapePaths[0] = capPath(shapePaths[2]);
        shapePaths[1] = shapePaths[2];
        shapePaths[index] = shapePaths[index - 1];
        shapePaths[index + 1] = capPath(shapePaths[index - 1]);
        break;
      default:
        break;
    }
    return shapePaths;
  };
  const scaleVector = scale !== null ? new Vector3(scale, scale, scale) : null;
  let path3D;
  let pathArray;
  if (instance) {
    const storage = instance._creationDataStorage;
    path3D = firstNormal ? storage.path3D.update(curve, firstNormal) : storage.path3D.update(curve);
    pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scaleVector, rotation, scaleFunction, rotateFunction, storage.cap, custom, adjustFrame);
    instance = CreateRibbon("", { pathArray, closeArray: false, closePath: false, offset: 0, updatable: false, sideOrientation: 0, instance }, scene || void 0);
    return instance;
  }
  path3D = firstNormal ? new Path3D(curve, firstNormal) : new Path3D(curve);
  const newShapePaths = new Array();
  cap = cap < 0 || cap > 3 ? 0 : cap;
  pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scaleVector, rotation, scaleFunction, rotateFunction, cap, custom, adjustFrame);
  const extrudedGeneric = CreateRibbon(name13, {
    pathArray,
    closeArray: rbCA,
    closePath: rbCP,
    updatable: updtbl,
    sideOrientation: side,
    invertUV,
    frontUVs: frontUVs || void 0,
    backUVs: backUVs || void 0
  }, scene);
  extrudedGeneric._creationDataStorage.pathArray = pathArray;
  extrudedGeneric._creationDataStorage.path3D = path3D;
  extrudedGeneric._creationDataStorage.cap = cap;
  return extrudedGeneric;
}
var ShapeBuilder;
var init_shapeBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/shapeBuilder.js"() {
    init_math_vector();
    init_mesh();
    init_ribbonBuilder();
    init_math_path();
    ShapeBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      ExtrudeShape,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      ExtrudeShapeCustom
    };
    Mesh.ExtrudeShape = (name13, shape, path, scale, rotation, cap, scene = null, updatable, sideOrientation, instance) => {
      const options = {
        shape,
        path,
        scale,
        rotation,
        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,
        sideOrientation,
        instance,
        updatable
      };
      return ExtrudeShape(name13, options, scene);
    };
    Mesh.ExtrudeShapeCustom = (name13, shape, path, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, scene, updatable, sideOrientation, instance) => {
      const options = {
        shape,
        path,
        scaleFunction,
        rotationFunction,
        ribbonCloseArray,
        ribbonClosePath,
        cap: cap === 0 ? 0 : cap || Mesh.NO_CAP,
        sideOrientation,
        instance,
        updatable
      };
      return ExtrudeShapeCustom(name13, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/latheBuilder.js
function CreateLathe(name13, options, scene = null) {
  const arc = options.arc ? options.arc <= 0 || options.arc > 1 ? 1 : options.arc : 1;
  const closed = options.closed === void 0 ? true : options.closed;
  const shape = options.shape;
  const radius = options.radius || 1;
  const tessellation = options.tessellation || 64;
  const clip = options.clip || 0;
  const updatable = options.updatable;
  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  const cap = options.cap || Mesh.NO_CAP;
  const pi2 = Math.PI * 2;
  const paths = [];
  const invertUV = options.invertUV || false;
  let i = 0;
  let p = 0;
  const step = pi2 / tessellation * arc;
  let rotated;
  let path;
  for (i = 0; i <= tessellation - clip; i++) {
    path = [];
    if (cap == Mesh.CAP_START || cap == Mesh.CAP_ALL) {
      path.push(new Vector3(0, shape[0].y, 0));
      path.push(new Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));
    }
    for (p = 0; p < shape.length; p++) {
      rotated = new Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);
      path.push(rotated);
    }
    if (cap == Mesh.CAP_END || cap == Mesh.CAP_ALL) {
      path.push(new Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));
      path.push(new Vector3(0, shape[shape.length - 1].y, 0));
    }
    paths.push(path);
  }
  const lathe = CreateRibbon(name13, { pathArray: paths, closeArray: closed, sideOrientation, updatable, invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs }, scene);
  return lathe;
}
var LatheBuilder;
var init_latheBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/latheBuilder.js"() {
    init_math_vector();
    init_mesh();
    init_ribbonBuilder();
    LatheBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateLathe
    };
    Mesh.CreateLathe = (name13, shape, radius, tessellation, scene, updatable, sideOrientation) => {
      const options = {
        shape,
        radius,
        tessellation,
        sideOrientation,
        updatable
      };
      return CreateLathe(name13, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/tubeBuilder.js
function CreateTube(name13, options, scene = null) {
  const path = options.path;
  let instance = options.instance;
  let radius = 1;
  if (options.radius !== void 0) {
    radius = options.radius;
  } else if (instance) {
    radius = instance._creationDataStorage.radius;
  }
  const tessellation = options.tessellation || 64 | 0;
  const radiusFunction = options.radiusFunction || null;
  let cap = options.cap || Mesh.NO_CAP;
  const invertUV = options.invertUV || false;
  const updatable = options.updatable;
  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  options.arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  const tubePathArray = (path2, path3D2, circlePaths, radius2, tessellation2, radiusFunction2, cap2, arc) => {
    const tangents = path3D2.getTangents();
    const normals = path3D2.getNormals();
    const distances = path3D2.getDistances();
    const pi2 = Math.PI * 2;
    const step = pi2 / tessellation2 * arc;
    const returnRadius = () => radius2;
    const radiusFunctionFinal = radiusFunction2 || returnRadius;
    let circlePath;
    let rad;
    let normal;
    let rotated;
    const rotationMatrix = TmpVectors.Matrix[0];
    let index = cap2 === Mesh.NO_CAP || cap2 === Mesh.CAP_END ? 0 : 2;
    for (let i = 0; i < path2.length; i++) {
      rad = radiusFunctionFinal(i, distances[i]);
      circlePath = Array();
      normal = normals[i];
      for (let t = 0; t < tessellation2; t++) {
        Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);
        rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();
        Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);
        rotated.scaleInPlace(rad).addInPlace(path2[i]);
        circlePath[t] = rotated;
      }
      circlePaths[index] = circlePath;
      index++;
    }
    const capPath = (nbPoints, pathIndex) => {
      const pointCap = Array();
      for (let i = 0; i < nbPoints; i++) {
        pointCap.push(path2[pathIndex]);
      }
      return pointCap;
    };
    switch (cap2) {
      case Mesh.NO_CAP:
        break;
      case Mesh.CAP_START:
        circlePaths[0] = capPath(tessellation2, 0);
        circlePaths[1] = circlePaths[2].slice(0);
        break;
      case Mesh.CAP_END:
        circlePaths[index] = circlePaths[index - 1].slice(0);
        circlePaths[index + 1] = capPath(tessellation2, path2.length - 1);
        break;
      case Mesh.CAP_ALL:
        circlePaths[0] = capPath(tessellation2, 0);
        circlePaths[1] = circlePaths[2].slice(0);
        circlePaths[index] = circlePaths[index - 1].slice(0);
        circlePaths[index + 1] = capPath(tessellation2, path2.length - 1);
        break;
      default:
        break;
    }
    return circlePaths;
  };
  let path3D;
  let pathArray;
  if (instance) {
    const storage = instance._creationDataStorage;
    const arc = options.arc || storage.arc;
    path3D = storage.path3D.update(path);
    pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);
    instance = CreateRibbon("", { pathArray, instance });
    storage.path3D = path3D;
    storage.pathArray = pathArray;
    storage.arc = arc;
    storage.radius = radius;
    return instance;
  }
  path3D = new Path3D(path);
  const newPathArray = new Array();
  cap = cap < 0 || cap > 3 ? 0 : cap;
  pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);
  const tube = CreateRibbon(name13, {
    pathArray,
    closePath: true,
    closeArray: false,
    updatable,
    sideOrientation,
    invertUV,
    frontUVs: options.frontUVs,
    backUVs: options.backUVs
  }, scene);
  tube._creationDataStorage.pathArray = pathArray;
  tube._creationDataStorage.path3D = path3D;
  tube._creationDataStorage.tessellation = tessellation;
  tube._creationDataStorage.cap = cap;
  tube._creationDataStorage.arc = options.arc;
  tube._creationDataStorage.radius = radius;
  return tube;
}
var TubeBuilder;
var init_tubeBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/tubeBuilder.js"() {
    init_math_vector();
    init_mesh();
    init_ribbonBuilder();
    init_math_path();
    TubeBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateTube
    };
    Mesh.CreateTube = (name13, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) => {
      const options = {
        path,
        radius,
        tessellation,
        radiusFunction,
        arc: 1,
        cap,
        updatable,
        sideOrientation,
        instance
      };
      return CreateTube(name13, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/polyhedronBuilder.js
function CreatePolyhedronVertexData(options) {
  const polyhedra = [];
  polyhedra[0] = {
    vertex: [
      [0, 0, 1.732051],
      [1.632993, 0, -0.5773503],
      [-0.8164966, 1.414214, -0.5773503],
      [-0.8164966, -1.414214, -0.5773503]
    ],
    face: [
      [0, 1, 2],
      [0, 2, 3],
      [0, 3, 1],
      [1, 3, 2]
    ]
  };
  polyhedra[1] = {
    vertex: [
      [0, 0, 1.414214],
      [1.414214, 0, 0],
      [0, 1.414214, 0],
      [-1.414214, 0, 0],
      [0, -1.414214, 0],
      [0, 0, -1.414214]
    ],
    face: [
      [0, 1, 2],
      [0, 2, 3],
      [0, 3, 4],
      [0, 4, 1],
      [1, 4, 5],
      [1, 5, 2],
      [2, 5, 3],
      [3, 5, 4]
    ]
  };
  polyhedra[2] = {
    vertex: [
      [0, 0, 1.070466],
      [0.7136442, 0, 0.7978784],
      [-0.3568221, 0.618034, 0.7978784],
      [-0.3568221, -0.618034, 0.7978784],
      [0.7978784, 0.618034, 0.3568221],
      [0.7978784, -0.618034, 0.3568221],
      [-0.9341724, 0.381966, 0.3568221],
      [0.1362939, 1, 0.3568221],
      [0.1362939, -1, 0.3568221],
      [-0.9341724, -0.381966, 0.3568221],
      [0.9341724, 0.381966, -0.3568221],
      [0.9341724, -0.381966, -0.3568221],
      [-0.7978784, 0.618034, -0.3568221],
      [-0.1362939, 1, -0.3568221],
      [-0.1362939, -1, -0.3568221],
      [-0.7978784, -0.618034, -0.3568221],
      [0.3568221, 0.618034, -0.7978784],
      [0.3568221, -0.618034, -0.7978784],
      [-0.7136442, 0, -0.7978784],
      [0, 0, -1.070466]
    ],
    face: [
      [0, 1, 4, 7, 2],
      [0, 2, 6, 9, 3],
      [0, 3, 8, 5, 1],
      [1, 5, 11, 10, 4],
      [2, 7, 13, 12, 6],
      [3, 9, 15, 14, 8],
      [4, 10, 16, 13, 7],
      [5, 8, 14, 17, 11],
      [6, 12, 18, 15, 9],
      [10, 11, 17, 19, 16],
      [12, 13, 16, 19, 18],
      [14, 15, 18, 19, 17]
    ]
  };
  polyhedra[3] = {
    vertex: [
      [0, 0, 1.175571],
      [1.051462, 0, 0.5257311],
      [0.3249197, 1, 0.5257311],
      [-0.8506508, 0.618034, 0.5257311],
      [-0.8506508, -0.618034, 0.5257311],
      [0.3249197, -1, 0.5257311],
      [0.8506508, 0.618034, -0.5257311],
      [0.8506508, -0.618034, -0.5257311],
      [-0.3249197, 1, -0.5257311],
      [-1.051462, 0, -0.5257311],
      [-0.3249197, -1, -0.5257311],
      [0, 0, -1.175571]
    ],
    face: [
      [0, 1, 2],
      [0, 2, 3],
      [0, 3, 4],
      [0, 4, 5],
      [0, 5, 1],
      [1, 5, 7],
      [1, 7, 6],
      [1, 6, 2],
      [2, 6, 8],
      [2, 8, 3],
      [3, 8, 9],
      [3, 9, 4],
      [4, 9, 10],
      [4, 10, 5],
      [5, 10, 7],
      [6, 7, 11],
      [6, 11, 8],
      [7, 10, 11],
      [8, 11, 9],
      [9, 11, 10]
    ]
  };
  polyhedra[4] = {
    vertex: [
      [0, 0, 1.070722],
      [0.7148135, 0, 0.7971752],
      [-0.104682, 0.7071068, 0.7971752],
      [-0.6841528, 0.2071068, 0.7971752],
      [-0.104682, -0.7071068, 0.7971752],
      [0.6101315, 0.7071068, 0.5236279],
      [1.04156, 0.2071068, 0.1367736],
      [0.6101315, -0.7071068, 0.5236279],
      [-0.3574067, 1, 0.1367736],
      [-0.7888348, -0.5, 0.5236279],
      [-0.9368776, 0.5, 0.1367736],
      [-0.3574067, -1, 0.1367736],
      [0.3574067, 1, -0.1367736],
      [0.9368776, -0.5, -0.1367736],
      [0.7888348, 0.5, -0.5236279],
      [0.3574067, -1, -0.1367736],
      [-0.6101315, 0.7071068, -0.5236279],
      [-1.04156, -0.2071068, -0.1367736],
      [-0.6101315, -0.7071068, -0.5236279],
      [0.104682, 0.7071068, -0.7971752],
      [0.6841528, -0.2071068, -0.7971752],
      [0.104682, -0.7071068, -0.7971752],
      [-0.7148135, 0, -0.7971752],
      [0, 0, -1.070722]
    ],
    face: [
      [0, 2, 3],
      [1, 6, 5],
      [4, 9, 11],
      [7, 15, 13],
      [8, 16, 10],
      [12, 14, 19],
      [17, 22, 18],
      [20, 21, 23],
      [0, 1, 5, 2],
      [0, 3, 9, 4],
      [0, 4, 7, 1],
      [1, 7, 13, 6],
      [2, 5, 12, 8],
      [2, 8, 10, 3],
      [3, 10, 17, 9],
      [4, 11, 15, 7],
      [5, 6, 14, 12],
      [6, 13, 20, 14],
      [8, 12, 19, 16],
      [9, 17, 18, 11],
      [10, 16, 22, 17],
      [11, 18, 21, 15],
      [13, 15, 21, 20],
      [14, 20, 23, 19],
      [16, 19, 23, 22],
      [18, 22, 23, 21]
    ]
  };
  polyhedra[5] = {
    vertex: [
      [0, 0, 1.322876],
      [1.309307, 0, 0.1889822],
      [-0.9819805, 0.8660254, 0.1889822],
      [0.1636634, -1.299038, 0.1889822],
      [0.3273268, 0.8660254, -0.9449112],
      [-0.8183171, -0.4330127, -0.9449112]
    ],
    face: [
      [0, 3, 1],
      [2, 4, 5],
      [0, 1, 4, 2],
      [0, 2, 5, 3],
      [1, 3, 5, 4]
    ]
  };
  polyhedra[6] = {
    vertex: [
      [0, 0, 1.159953],
      [1.013464, 0, 0.5642542],
      [-0.3501431, 0.9510565, 0.5642542],
      [-0.7715208, -0.6571639, 0.5642542],
      [0.6633206, 0.9510565, -0.03144481],
      [0.8682979, -0.6571639, -0.3996071],
      [-1.121664, 0.2938926, -0.03144481],
      [-0.2348831, -1.063314, -0.3996071],
      [0.5181548, 0.2938926, -0.9953061],
      [-0.5850262, -0.112257, -0.9953061]
    ],
    face: [
      [0, 1, 4, 2],
      [0, 2, 6, 3],
      [1, 5, 8, 4],
      [3, 6, 9, 7],
      [5, 7, 9, 8],
      [0, 3, 7, 5, 1],
      [2, 4, 8, 9, 6]
    ]
  };
  polyhedra[7] = {
    vertex: [
      [0, 0, 1.118034],
      [0.8944272, 0, 0.6708204],
      [-0.2236068, 0.8660254, 0.6708204],
      [-0.7826238, -0.4330127, 0.6708204],
      [0.6708204, 0.8660254, 0.2236068],
      [1.006231, -0.4330127, -0.2236068],
      [-1.006231, 0.4330127, 0.2236068],
      [-0.6708204, -0.8660254, -0.2236068],
      [0.7826238, 0.4330127, -0.6708204],
      [0.2236068, -0.8660254, -0.6708204],
      [-0.8944272, 0, -0.6708204],
      [0, 0, -1.118034]
    ],
    face: [
      [0, 1, 4, 2],
      [0, 2, 6, 3],
      [1, 5, 8, 4],
      [3, 6, 10, 7],
      [5, 9, 11, 8],
      [7, 10, 11, 9],
      [0, 3, 7, 9, 5, 1],
      [2, 4, 8, 11, 10, 6]
    ]
  };
  polyhedra[8] = {
    vertex: [
      [-0.729665, 0.670121, 0.319155],
      [-0.655235, -0.29213, -0.754096],
      [-0.093922, -0.607123, 0.537818],
      [0.702196, 0.595691, 0.485187],
      [0.776626, -0.36656, -0.588064]
    ],
    face: [
      [1, 4, 2],
      [0, 1, 2],
      [3, 0, 2],
      [4, 3, 2],
      [4, 1, 0, 3]
    ]
  };
  polyhedra[9] = {
    vertex: [
      [-0.868849, -0.100041, 0.61257],
      [-0.329458, 0.976099, 0.28078],
      [-0.26629, -0.013796, -0.477654],
      [-0.13392, -1.034115, 0.229829],
      [0.738834, 0.707117, -0.307018],
      [0.859683, -0.535264, -0.338508]
    ],
    face: [
      [3, 0, 2],
      [5, 3, 2],
      [4, 5, 2],
      [1, 4, 2],
      [0, 1, 2],
      [0, 3, 5, 4, 1]
    ]
  };
  polyhedra[10] = {
    vertex: [
      [-0.610389, 0.243975, 0.531213],
      [-0.187812, -0.48795, -0.664016],
      [-0.187812, 0.9759, -0.664016],
      [0.187812, -0.9759, 0.664016],
      [0.798201, 0.243975, 0.132803]
    ],
    face: [
      [1, 3, 0],
      [3, 4, 0],
      [3, 1, 4],
      [0, 2, 1],
      [0, 4, 2],
      [2, 4, 1]
    ]
  };
  polyhedra[11] = {
    vertex: [
      [-1.028778, 0.392027, -0.048786],
      [-0.640503, -0.646161, 0.621837],
      [-0.125162, -0.395663, -0.540059],
      [4683e-6, 0.888447, -0.651988],
      [0.125161, 0.395663, 0.540059],
      [0.632925, -0.791376, 0.433102],
      [1.031672, 0.157063, -0.354165]
    ],
    face: [
      [3, 2, 0],
      [2, 1, 0],
      [2, 5, 1],
      [0, 4, 3],
      [0, 1, 4],
      [4, 1, 5],
      [2, 3, 6],
      [3, 4, 6],
      [5, 2, 6],
      [4, 5, 6]
    ]
  };
  polyhedra[12] = {
    vertex: [
      [-0.669867, 0.334933, -0.529576],
      [-0.669867, 0.334933, 0.529577],
      [-0.4043, 1.212901, 0],
      [-0.334933, -0.669867, -0.529576],
      [-0.334933, -0.669867, 0.529577],
      [0.334933, 0.669867, -0.529576],
      [0.334933, 0.669867, 0.529577],
      [0.4043, -1.212901, 0],
      [0.669867, -0.334933, -0.529576],
      [0.669867, -0.334933, 0.529577]
    ],
    face: [
      [8, 9, 7],
      [6, 5, 2],
      [3, 8, 7],
      [5, 0, 2],
      [4, 3, 7],
      [0, 1, 2],
      [9, 4, 7],
      [1, 6, 2],
      [9, 8, 5, 6],
      [8, 3, 0, 5],
      [3, 4, 1, 0],
      [4, 9, 6, 1]
    ]
  };
  polyhedra[13] = {
    vertex: [
      [-0.931836, 0.219976, -0.264632],
      [-0.636706, 0.318353, 0.692816],
      [-0.613483, -0.735083, -0.264632],
      [-0.326545, 0.979634, 0],
      [-0.318353, -0.636706, 0.692816],
      [-0.159176, 0.477529, -0.856368],
      [0.159176, -0.477529, -0.856368],
      [0.318353, 0.636706, 0.692816],
      [0.326545, -0.979634, 0],
      [0.613482, 0.735082, -0.264632],
      [0.636706, -0.318353, 0.692816],
      [0.931835, -0.219977, -0.264632]
    ],
    face: [
      [11, 10, 8],
      [7, 9, 3],
      [6, 11, 8],
      [9, 5, 3],
      [2, 6, 8],
      [5, 0, 3],
      [4, 2, 8],
      [0, 1, 3],
      [10, 4, 8],
      [1, 7, 3],
      [10, 11, 9, 7],
      [11, 6, 5, 9],
      [6, 2, 0, 5],
      [2, 4, 1, 0],
      [4, 10, 7, 1]
    ]
  };
  polyhedra[14] = {
    vertex: [
      [-0.93465, 0.300459, -0.271185],
      [-0.838689, -0.260219, -0.516017],
      [-0.711319, 0.717591, 0.128359],
      [-0.710334, -0.156922, 0.080946],
      [-0.599799, 0.556003, -0.725148],
      [-0.503838, -4675e-6, -0.969981],
      [-0.487004, 0.26021, 0.48049],
      [-0.460089, -0.750282, -0.512622],
      [-0.376468, 0.973135, -0.325605],
      [-0.331735, -0.646985, 0.084342],
      [-0.254001, 0.831847, 0.530001],
      [-0.125239, -0.494738, -0.966586],
      [0.029622, 0.027949, 0.730817],
      [0.056536, -0.982543, -0.262295],
      [0.08085, 1.087391, 0.076037],
      [0.125583, -0.532729, 0.485984],
      [0.262625, 0.599586, 0.780328],
      [0.391387, -0.726999, -0.716259],
      [0.513854, -0.868287, 0.139347],
      [0.597475, 0.85513, 0.326364],
      [0.641224, 0.109523, 0.783723],
      [0.737185, -0.451155, 0.538891],
      [0.848705, -0.612742, -0.314616],
      [0.976075, 0.365067, 0.32976],
      [1.072036, -0.19561, 0.084927]
    ],
    face: [
      [15, 18, 21],
      [12, 20, 16],
      [6, 10, 2],
      [3, 0, 1],
      [9, 7, 13],
      [2, 8, 4, 0],
      [0, 4, 5, 1],
      [1, 5, 11, 7],
      [7, 11, 17, 13],
      [13, 17, 22, 18],
      [18, 22, 24, 21],
      [21, 24, 23, 20],
      [20, 23, 19, 16],
      [16, 19, 14, 10],
      [10, 14, 8, 2],
      [15, 9, 13, 18],
      [12, 15, 21, 20],
      [6, 12, 16, 10],
      [3, 6, 2, 0],
      [9, 3, 1, 7],
      [9, 15, 12, 6, 3],
      [22, 17, 11, 5, 4, 8, 14, 19, 23, 24]
    ]
  };
  const type = options.type && (options.type < 0 || options.type >= polyhedra.length) ? 0 : options.type || 0;
  const size = options.size;
  const sizeX = options.sizeX || size || 1;
  const sizeY = options.sizeY || size || 1;
  const sizeZ = options.sizeZ || size || 1;
  const data = options.custom || polyhedra[type];
  const nbfaces = data.face.length;
  const faceUV = options.faceUV || new Array(nbfaces);
  const faceColors = options.faceColors;
  const flat = options.flat === void 0 ? true : options.flat;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const positions = [];
  const indices = [];
  const normals = [];
  const uvs = [];
  const colors = [];
  let index = 0;
  let faceIdx = 0;
  const indexes = [];
  let i = 0;
  let f = 0;
  let u, v, ang, x, y, tmp;
  if (flat) {
    for (f = 0; f < nbfaces; f++) {
      if (faceColors && faceColors[f] === void 0) {
        faceColors[f] = new Color4(1, 1, 1, 1);
      }
      if (faceUV && faceUV[f] === void 0) {
        faceUV[f] = new Vector4(0, 0, 1, 1);
      }
    }
  }
  if (!flat) {
    for (i = 0; i < data.vertex.length; i++) {
      positions.push(data.vertex[i][0] * sizeX, data.vertex[i][1] * sizeY, data.vertex[i][2] * sizeZ);
      uvs.push(0, useOpenGLOrientationForUV ? 1 : 0);
    }
    for (f = 0; f < nbfaces; f++) {
      for (i = 0; i < data.face[f].length - 2; i++) {
        indices.push(data.face[f][0], data.face[f][i + 2], data.face[f][i + 1]);
      }
    }
  } else {
    for (f = 0; f < nbfaces; f++) {
      const fl = data.face[f].length;
      ang = 2 * Math.PI / fl;
      x = 0.5 * Math.tan(ang / 2);
      y = 0.5;
      for (i = 0; i < fl; i++) {
        positions.push(data.vertex[data.face[f][i]][0] * sizeX, data.vertex[data.face[f][i]][1] * sizeY, data.vertex[data.face[f][i]][2] * sizeZ);
        indexes.push(index);
        index++;
        u = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * (0.5 + x);
        v = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * (y - 0.5);
        uvs.push(u, useOpenGLOrientationForUV ? 1 - v : v);
        tmp = x * Math.cos(ang) - y * Math.sin(ang);
        y = x * Math.sin(ang) + y * Math.cos(ang);
        x = tmp;
        if (faceColors) {
          colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);
        }
      }
      for (i = 0; i < fl - 2; i++) {
        indices.push(indexes[0 + faceIdx], indexes[i + 2 + faceIdx], indexes[i + 1 + faceIdx]);
      }
      faceIdx += fl;
    }
  }
  VertexData.ComputeNormals(positions, indices, normals);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.positions = positions;
  vertexData.indices = indices;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors && flat) {
    vertexData.colors = colors;
  }
  return vertexData;
}
function CreatePolyhedron(name13, options = {}, scene = null) {
  const polyhedron = new Mesh(name13, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  polyhedron._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreatePolyhedronVertexData(options);
  vertexData.applyToMesh(polyhedron, options.updatable);
  return polyhedron;
}
var PolyhedronBuilder;
var init_polyhedronBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/polyhedronBuilder.js"() {
    init_math_vector();
    init_math_color();
    init_mesh();
    init_mesh_vertexData();
    init_compatibilityOptions();
    PolyhedronBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreatePolyhedron
    };
    VertexData.CreatePolyhedron = CreatePolyhedronVertexData;
    Mesh.CreatePolyhedron = (name13, options, scene) => {
      return CreatePolyhedron(name13, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/icoSphereBuilder.js
function CreateIcoSphereVertexData(options) {
  const sideOrientation = options.sideOrientation || VertexData.DEFAULTSIDE;
  const radius = options.radius || 1;
  const flat = options.flat === void 0 ? true : options.flat;
  const subdivisions = (options.subdivisions || 4) | 0;
  const radiusX = options.radiusX || radius;
  const radiusY = options.radiusY || radius;
  const radiusZ = options.radiusZ || radius;
  const t = (1 + Math.sqrt(5)) / 2;
  const icoVertices = [
    -1,
    t,
    -0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    // v0-3
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    -1,
    t,
    0,
    1,
    t,
    // v4-7
    t,
    0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    -1
    // v8-11
  ];
  const icoIndices = [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    12,
    22,
    23,
    1,
    5,
    20,
    5,
    11,
    4,
    23,
    22,
    13,
    22,
    18,
    6,
    7,
    1,
    8,
    14,
    21,
    4,
    14,
    4,
    2,
    16,
    13,
    6,
    15,
    6,
    19,
    3,
    8,
    9,
    4,
    21,
    5,
    13,
    17,
    23,
    6,
    13,
    22,
    19,
    6,
    18,
    9,
    8,
    1
  ];
  const verticesUnaliasId = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    // vertex alias
    0,
    // 12: 0 + 12
    2,
    // 13: 2 + 11
    3,
    // 14: 3 + 11
    3,
    // 15: 3 + 12
    3,
    // 16: 3 + 13
    4,
    // 17: 4 + 13
    7,
    // 18: 7 + 11
    8,
    // 19: 8 + 11
    9,
    // 20: 9 + 11
    9,
    // 21: 9 + 12
    10,
    // 22: A + 12
    11
    // 23: B + 12
  ];
  const icoVertexuv = [
    5,
    1,
    3,
    1,
    6,
    4,
    0,
    0,
    // v0-3
    5,
    3,
    4,
    2,
    2,
    2,
    4,
    0,
    // v4-7
    2,
    0,
    1,
    1,
    6,
    0,
    6,
    2,
    // v8-11
    // vertex alias (for same vertex on different faces)
    0,
    4,
    // 12: 0 + 12
    3,
    3,
    // 13: 2 + 11
    4,
    4,
    // 14: 3 + 11
    3,
    1,
    // 15: 3 + 12
    4,
    2,
    // 16: 3 + 13
    4,
    4,
    // 17: 4 + 13
    0,
    2,
    // 18: 7 + 11
    1,
    1,
    // 19: 8 + 11
    2,
    2,
    // 20: 9 + 11
    3,
    3,
    // 21: 9 + 12
    1,
    3,
    // 22: A + 12
    2,
    4
    // 23: B + 12
  ];
  const ustep = 138 / 1024;
  const vstep = 239 / 1024;
  const uoffset = 60 / 1024;
  const voffset = 26 / 1024;
  const islandUoffset = -40 / 1024;
  const islandVoffset = 20 / 1024;
  const island = [
    0,
    0,
    0,
    0,
    1,
    //  0 - 4
    0,
    0,
    1,
    1,
    0,
    //  5 - 9
    0,
    0,
    1,
    1,
    0,
    //  10 - 14
    0,
    1,
    1,
    1,
    0
    //  15 - 19
  ];
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  let currentIndice = 0;
  const faceVertexPos = new Array(3);
  const faceVertexUv = new Array(3);
  let v012;
  for (v012 = 0; v012 < 3; v012++) {
    faceVertexPos[v012] = Vector3.Zero();
    faceVertexUv[v012] = Vector2.Zero();
  }
  for (let face = 0; face < 20; face++) {
    for (v012 = 0; v012 < 3; v012++) {
      const vId = icoIndices[3 * face + v012];
      faceVertexPos[v012].copyFromFloats(icoVertices[3 * verticesUnaliasId[vId]], icoVertices[3 * verticesUnaliasId[vId] + 1], icoVertices[3 * verticesUnaliasId[vId] + 2]);
      faceVertexPos[v012].normalize();
      faceVertexUv[v012].copyFromFloats(icoVertexuv[2 * vId] * ustep + uoffset + island[face] * islandUoffset, icoVertexuv[2 * vId + 1] * vstep + voffset + island[face] * islandVoffset);
    }
    const interpVertex = (i1, i2, c1, c2) => {
      const posX0 = Vector3.Lerp(faceVertexPos[0], faceVertexPos[2], i2 / subdivisions);
      const posX1 = Vector3.Lerp(faceVertexPos[1], faceVertexPos[2], i2 / subdivisions);
      const posInterp = subdivisions === i2 ? faceVertexPos[2] : Vector3.Lerp(posX0, posX1, i1 / (subdivisions - i2));
      posInterp.normalize();
      let vertexNormal;
      if (flat) {
        const centroidX0 = Vector3.Lerp(faceVertexPos[0], faceVertexPos[2], c2 / subdivisions);
        const centroidX1 = Vector3.Lerp(faceVertexPos[1], faceVertexPos[2], c2 / subdivisions);
        vertexNormal = Vector3.Lerp(centroidX0, centroidX1, c1 / (subdivisions - c2));
      } else {
        vertexNormal = new Vector3(posInterp.x, posInterp.y, posInterp.z);
      }
      vertexNormal.x /= radiusX;
      vertexNormal.y /= radiusY;
      vertexNormal.z /= radiusZ;
      vertexNormal.normalize();
      const uvX0 = Vector2.Lerp(faceVertexUv[0], faceVertexUv[2], i2 / subdivisions);
      const uvX1 = Vector2.Lerp(faceVertexUv[1], faceVertexUv[2], i2 / subdivisions);
      const uvInterp = subdivisions === i2 ? faceVertexUv[2] : Vector2.Lerp(uvX0, uvX1, i1 / (subdivisions - i2));
      positions.push(posInterp.x * radiusX, posInterp.y * radiusY, posInterp.z * radiusZ);
      normals.push(vertexNormal.x, vertexNormal.y, vertexNormal.z);
      uvs.push(uvInterp.x, useOpenGLOrientationForUV ? 1 - uvInterp.y : uvInterp.y);
      indices.push(currentIndice);
      currentIndice++;
    };
    for (let i2 = 0; i2 < subdivisions; i2++) {
      for (let i1 = 0; i1 + i2 < subdivisions; i1++) {
        interpVertex(i1, i2, i1 + 1 / 3, i2 + 1 / 3);
        interpVertex(i1 + 1, i2, i1 + 1 / 3, i2 + 1 / 3);
        interpVertex(i1, i2 + 1, i1 + 1 / 3, i2 + 1 / 3);
        if (i1 + i2 + 1 < subdivisions) {
          interpVertex(i1 + 1, i2, i1 + 2 / 3, i2 + 2 / 3);
          interpVertex(i1 + 1, i2 + 1, i1 + 2 / 3, i2 + 2 / 3);
          interpVertex(i1, i2 + 1, i1 + 2 / 3, i2 + 2 / 3);
        }
      }
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateIcoSphere(name13, options = {}, scene = null) {
  const sphere = new Mesh(name13, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  sphere._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateIcoSphereVertexData(options);
  vertexData.applyToMesh(sphere, options.updatable);
  return sphere;
}
var IcoSphereBuilder;
var init_icoSphereBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/icoSphereBuilder.js"() {
    init_math_vector();
    init_mesh();
    init_mesh_vertexData();
    init_compatibilityOptions();
    IcoSphereBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateIcoSphere
    };
    VertexData.CreateIcoSphere = CreateIcoSphereVertexData;
    Mesh.CreateIcoSphere = (name13, options, scene) => {
      return CreateIcoSphere(name13, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/decalBuilder.js
function CreateDecal(name13, sourceMesh, options) {
  const hasSkeleton = !!sourceMesh.skeleton;
  const hasMorphTargets = !!sourceMesh.morphTargetManager?.numTargets;
  const useLocalComputation = options.localMode || hasSkeleton;
  const indices = sourceMesh.getIndices();
  const positions = hasSkeleton || hasMorphTargets ? sourceMesh.getPositionData(true, true) : sourceMesh.getVerticesData(VertexBuffer.PositionKind);
  const normals = hasSkeleton || hasMorphTargets ? sourceMesh.getNormalsData(true, true) : sourceMesh.getVerticesData(VertexBuffer.NormalKind);
  const localPositions = useLocalComputation ? hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.PositionKind) : positions : null;
  const localNormals = useLocalComputation ? hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.NormalKind) : normals : null;
  const uvs = sourceMesh.getVerticesData(VertexBuffer.UVKind);
  const matIndices = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesKind) : null;
  const matWeights = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsKind) : null;
  const matIndicesExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;
  const matWeightsExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;
  const position = options.position || Vector3.Zero();
  let normal = options.normal || Vector3.Up();
  const size = options.size || Vector3.One();
  const angle = options.angle || 0;
  if (!normal) {
    const target = new Vector3(0, 0, 1);
    const camera = sourceMesh.getScene().activeCamera;
    const cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());
    normal = camera.globalPosition.subtract(cameraWorldTarget);
  }
  const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;
  const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);
  const pitch = Math.atan2(normal.y, len);
  const vertexData = new VertexData();
  vertexData.indices = [];
  vertexData.positions = [];
  vertexData.normals = [];
  vertexData.uvs = [];
  vertexData.matricesIndices = hasSkeleton ? [] : null;
  vertexData.matricesWeights = hasSkeleton ? [] : null;
  vertexData.matricesIndicesExtra = matIndicesExtra ? [] : null;
  vertexData.matricesWeightsExtra = matWeightsExtra ? [] : null;
  let currentVertexDataIndex = 0;
  const extractDecalVector3 = (indexId, transformMatrix) => {
    const result = new DecalVertex();
    if (!indices || !positions || !normals) {
      return result;
    }
    const vertexId = indices[indexId];
    result.vertexIdx = vertexId * 3;
    result.vertexIdxForBones = vertexId * 4;
    result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);
    Vector3.TransformCoordinatesToRef(result.position, transformMatrix, result.position);
    result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);
    Vector3.TransformNormalToRef(result.normal, transformMatrix, result.normal);
    if (options.captureUVS && uvs) {
      const v = uvs[vertexId * 2 + 1];
      result.uv = new Vector2(uvs[vertexId * 2], useOpenGLOrientationForUV ? 1 - v : v);
    }
    return result;
  };
  const emptyArray = [0, 0, 0, 0];
  const clip = (vertices, axis) => {
    if (vertices.length === 0) {
      return vertices;
    }
    const clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));
    const indexOf = (arr, val, start, num) => {
      for (let i = 0; i < num; ++i) {
        if (arr[start + i] === val) {
          return start + i;
        }
      }
      return -1;
    };
    const clipVertices = (v0, v1) => {
      const clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);
      let indices2 = emptyArray;
      let weights = emptyArray;
      if (matIndices && matWeights) {
        const mat0Index = v0.matrixIndicesOverride ? 0 : v0.vertexIdxForBones;
        const v0Indices = v0.matrixIndicesOverride ?? matIndices;
        const v0Weights = v0.matrixWeightsOverride ?? matWeights;
        const mat1Index = v1.matrixIndicesOverride ? 0 : v1.vertexIdxForBones;
        const v1Indices = v1.matrixIndicesOverride ?? matIndices;
        const v1Weights = v1.matrixWeightsOverride ?? matWeights;
        indices2 = [0, 0, 0, 0];
        weights = [0, 0, 0, 0];
        let index = 0;
        for (let i = 0; i < 4; ++i) {
          if (v0Weights[mat0Index + i] > 0) {
            const idx = indexOf(v1Indices, v0Indices[mat0Index + i], mat1Index, 4);
            indices2[index] = v0Indices[mat0Index + i];
            weights[index] = Lerp(v0Weights[mat0Index + i], idx >= 0 ? v1Weights[idx] : 0, clipFactor);
            index++;
          }
        }
        for (let i = 0; i < 4 && index < 4; ++i) {
          const ind = v1Indices[mat1Index + i];
          if (indexOf(v0Indices, ind, mat0Index, 4) !== -1) {
            continue;
          }
          indices2[index] = ind;
          weights[index] = Lerp(0, v1Weights[mat1Index + i], clipFactor);
          index++;
        }
        const sumw = weights[0] + weights[1] + weights[2] + weights[3];
        weights[0] /= sumw;
        weights[1] /= sumw;
        weights[2] /= sumw;
        weights[3] /= sumw;
      }
      const v0LocalPositionX = v0.localPositionOverride ? v0.localPositionOverride[0] : localPositions?.[v0.vertexIdx] ?? 0;
      const v0LocalPositionY = v0.localPositionOverride ? v0.localPositionOverride[1] : localPositions?.[v0.vertexIdx + 1] ?? 0;
      const v0LocalPositionZ = v0.localPositionOverride ? v0.localPositionOverride[2] : localPositions?.[v0.vertexIdx + 2] ?? 0;
      const v1LocalPositionX = v1.localPositionOverride ? v1.localPositionOverride[0] : localPositions?.[v1.vertexIdx] ?? 0;
      const v1LocalPositionY = v1.localPositionOverride ? v1.localPositionOverride[1] : localPositions?.[v1.vertexIdx + 1] ?? 0;
      const v1LocalPositionZ = v1.localPositionOverride ? v1.localPositionOverride[2] : localPositions?.[v1.vertexIdx + 2] ?? 0;
      const v0LocalNormalX = v0.localNormalOverride ? v0.localNormalOverride[0] : localNormals?.[v0.vertexIdx] ?? 0;
      const v0LocalNormalY = v0.localNormalOverride ? v0.localNormalOverride[1] : localNormals?.[v0.vertexIdx + 1] ?? 0;
      const v0LocalNormalZ = v0.localNormalOverride ? v0.localNormalOverride[2] : localNormals?.[v0.vertexIdx + 2] ?? 0;
      const v1LocalNormalX = v1.localNormalOverride ? v1.localNormalOverride[0] : localNormals?.[v1.vertexIdx] ?? 0;
      const v1LocalNormalY = v1.localNormalOverride ? v1.localNormalOverride[1] : localNormals?.[v1.vertexIdx + 1] ?? 0;
      const v1LocalNormalZ = v1.localNormalOverride ? v1.localNormalOverride[2] : localNormals?.[v1.vertexIdx + 2] ?? 0;
      const interpNormalX = v0LocalNormalX + (v1LocalNormalX - v0LocalNormalX) * clipFactor;
      const interpNormalY = v0LocalNormalY + (v1LocalNormalY - v0LocalNormalY) * clipFactor;
      const interpNormalZ = v0LocalNormalZ + (v1LocalNormalZ - v0LocalNormalZ) * clipFactor;
      const norm = Math.sqrt(interpNormalX * interpNormalX + interpNormalY * interpNormalY + interpNormalZ * interpNormalZ);
      return new DecalVertex(Vector3.Lerp(v0.position, v1.position, clipFactor), Vector3.Lerp(v0.normal, v1.normal, clipFactor).normalize(), Vector2.Lerp(v0.uv, v1.uv, clipFactor), -1, -1, localPositions ? [
        v0LocalPositionX + (v1LocalPositionX - v0LocalPositionX) * clipFactor,
        v0LocalPositionY + (v1LocalPositionY - v0LocalPositionY) * clipFactor,
        v0LocalPositionZ + (v1LocalPositionZ - v0LocalPositionZ) * clipFactor
      ] : null, localNormals ? [interpNormalX / norm, interpNormalY / norm, interpNormalZ / norm] : null, indices2, weights);
    };
    let clipResult = null;
    if (vertices.length > 3) {
      clipResult = [];
    }
    for (let index = 0; index < vertices.length; index += 3) {
      let total = 0;
      let nV1 = null;
      let nV2 = null;
      let nV3 = null;
      let nV4 = null;
      const d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;
      const d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;
      const d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;
      const v1Out = d1 > 0;
      const v2Out = d2 > 0;
      const v3Out = d3 > 0;
      total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);
      switch (total) {
        case 0:
          if (vertices.length > 3) {
            clipResult.push(vertices[index]);
            clipResult.push(vertices[index + 1]);
            clipResult.push(vertices[index + 2]);
          } else {
            clipResult = vertices;
          }
          break;
        case 1:
          clipResult = clipResult ?? new Array();
          if (v1Out) {
            nV1 = vertices[index + 1];
            nV2 = vertices[index + 2];
            nV3 = clipVertices(vertices[index], nV1);
            nV4 = clipVertices(vertices[index], nV2);
          }
          if (v2Out) {
            nV1 = vertices[index];
            nV2 = vertices[index + 2];
            nV3 = clipVertices(vertices[index + 1], nV1);
            nV4 = clipVertices(vertices[index + 1], nV2);
            clipResult.push(nV3);
            clipResult.push(nV2.clone());
            clipResult.push(nV1.clone());
            clipResult.push(nV2.clone());
            clipResult.push(nV3.clone());
            clipResult.push(nV4);
            break;
          }
          if (v3Out) {
            nV1 = vertices[index];
            nV2 = vertices[index + 1];
            nV3 = clipVertices(vertices[index + 2], nV1);
            nV4 = clipVertices(vertices[index + 2], nV2);
          }
          if (nV1 && nV2 && nV3 && nV4) {
            clipResult.push(nV1.clone());
            clipResult.push(nV2.clone());
            clipResult.push(nV3);
            clipResult.push(nV4);
            clipResult.push(nV3.clone());
            clipResult.push(nV2.clone());
          }
          break;
        case 2:
          clipResult = clipResult ?? new Array();
          if (!v1Out) {
            nV1 = vertices[index].clone();
            nV2 = clipVertices(nV1, vertices[index + 1]);
            nV3 = clipVertices(nV1, vertices[index + 2]);
            clipResult.push(nV1);
            clipResult.push(nV2);
            clipResult.push(nV3);
          }
          if (!v2Out) {
            nV1 = vertices[index + 1].clone();
            nV2 = clipVertices(nV1, vertices[index + 2]);
            nV3 = clipVertices(nV1, vertices[index]);
            clipResult.push(nV1);
            clipResult.push(nV2);
            clipResult.push(nV3);
          }
          if (!v3Out) {
            nV1 = vertices[index + 2].clone();
            nV2 = clipVertices(nV1, vertices[index]);
            nV3 = clipVertices(nV1, vertices[index + 1]);
            clipResult.push(nV1);
            clipResult.push(nV2);
            clipResult.push(nV3);
          }
          break;
        case 3:
          break;
      }
    }
    return clipResult;
  };
  const sourceMeshAsMesh = sourceMesh instanceof Mesh ? sourceMesh : null;
  const matrixData = sourceMeshAsMesh?._thinInstanceDataStorage.matrixData;
  const numMatrices = sourceMeshAsMesh?.thinInstanceCount || 1;
  const thinInstanceMatrix = TmpVectors.Matrix[0];
  thinInstanceMatrix.copyFrom(Matrix.IdentityReadOnly);
  for (let m = 0; m < numMatrices; ++m) {
    if (sourceMeshAsMesh?.hasThinInstances && matrixData) {
      const ofst = m * 16;
      thinInstanceMatrix.setRowFromFloats(0, matrixData[ofst + 0], matrixData[ofst + 1], matrixData[ofst + 2], matrixData[ofst + 3]);
      thinInstanceMatrix.setRowFromFloats(1, matrixData[ofst + 4], matrixData[ofst + 5], matrixData[ofst + 6], matrixData[ofst + 7]);
      thinInstanceMatrix.setRowFromFloats(2, matrixData[ofst + 8], matrixData[ofst + 9], matrixData[ofst + 10], matrixData[ofst + 11]);
      thinInstanceMatrix.setRowFromFloats(3, matrixData[ofst + 12], matrixData[ofst + 13], matrixData[ofst + 14], matrixData[ofst + 15]);
    }
    const decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));
    const inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);
    const meshWorldMatrix = sourceMesh.getWorldMatrix();
    const transformMatrix = thinInstanceMatrix.multiply(meshWorldMatrix).multiply(inverseDecalWorldMatrix);
    const oneFaceVertices = new Array(3);
    for (let index = 0; index < indices.length; index += 3) {
      let faceVertices = oneFaceVertices;
      faceVertices[0] = extractDecalVector3(index, transformMatrix);
      faceVertices[1] = extractDecalVector3(index + 1, transformMatrix);
      faceVertices[2] = extractDecalVector3(index + 2, transformMatrix);
      if (options.cullBackFaces) {
        if (-faceVertices[0].normal.z <= 0 && -faceVertices[1].normal.z <= 0 && -faceVertices[2].normal.z <= 0) {
          continue;
        }
      }
      faceVertices = clip(faceVertices, XpAxis);
      if (!faceVertices) {
        continue;
      }
      faceVertices = clip(faceVertices, XnAxis);
      if (!faceVertices) {
        continue;
      }
      faceVertices = clip(faceVertices, YpAxis);
      if (!faceVertices) {
        continue;
      }
      faceVertices = clip(faceVertices, YnAxis);
      if (!faceVertices) {
        continue;
      }
      faceVertices = clip(faceVertices, ZpAxis);
      if (!faceVertices) {
        continue;
      }
      faceVertices = clip(faceVertices, ZnAxis);
      if (!faceVertices) {
        continue;
      }
      for (let vIndex = 0; vIndex < faceVertices.length; vIndex++) {
        const vertex = faceVertices[vIndex];
        vertexData.indices.push(currentVertexDataIndex);
        if (useLocalComputation) {
          if (vertex.localPositionOverride) {
            vertexData.positions[currentVertexDataIndex * 3] = vertex.localPositionOverride[0];
            vertexData.positions[currentVertexDataIndex * 3 + 1] = vertex.localPositionOverride[1];
            vertexData.positions[currentVertexDataIndex * 3 + 2] = vertex.localPositionOverride[2];
          } else if (localPositions) {
            vertexData.positions[currentVertexDataIndex * 3] = localPositions[vertex.vertexIdx];
            vertexData.positions[currentVertexDataIndex * 3 + 1] = localPositions[vertex.vertexIdx + 1];
            vertexData.positions[currentVertexDataIndex * 3 + 2] = localPositions[vertex.vertexIdx + 2];
          }
          if (vertex.localNormalOverride) {
            vertexData.normals[currentVertexDataIndex * 3] = vertex.localNormalOverride[0];
            vertexData.normals[currentVertexDataIndex * 3 + 1] = vertex.localNormalOverride[1];
            vertexData.normals[currentVertexDataIndex * 3 + 2] = vertex.localNormalOverride[2];
          } else if (localNormals) {
            vertexData.normals[currentVertexDataIndex * 3] = localNormals[vertex.vertexIdx];
            vertexData.normals[currentVertexDataIndex * 3 + 1] = localNormals[vertex.vertexIdx + 1];
            vertexData.normals[currentVertexDataIndex * 3 + 2] = localNormals[vertex.vertexIdx + 2];
          }
        } else {
          vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);
          vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);
        }
        if (vertexData.matricesIndices && vertexData.matricesWeights) {
          if (vertex.matrixIndicesOverride) {
            vertexData.matricesIndices[currentVertexDataIndex * 4] = vertex.matrixIndicesOverride[0];
            vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = vertex.matrixIndicesOverride[1];
            vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = vertex.matrixIndicesOverride[2];
            vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = vertex.matrixIndicesOverride[3];
          } else {
            if (matIndices) {
              vertexData.matricesIndices[currentVertexDataIndex * 4] = matIndices[vertex.vertexIdxForBones];
              vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = matIndices[vertex.vertexIdxForBones + 1];
              vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = matIndices[vertex.vertexIdxForBones + 2];
              vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = matIndices[vertex.vertexIdxForBones + 3];
            }
            if (matIndicesExtra && vertexData.matricesIndicesExtra) {
              vertexData.matricesIndicesExtra[currentVertexDataIndex * 4] = matIndicesExtra[vertex.vertexIdxForBones];
              vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 1] = matIndicesExtra[vertex.vertexIdxForBones + 1];
              vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 2] = matIndicesExtra[vertex.vertexIdxForBones + 2];
              vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 3] = matIndicesExtra[vertex.vertexIdxForBones + 3];
            }
          }
          if (vertex.matrixWeightsOverride) {
            vertexData.matricesWeights[currentVertexDataIndex * 4] = vertex.matrixWeightsOverride[0];
            vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = vertex.matrixWeightsOverride[1];
            vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = vertex.matrixWeightsOverride[2];
            vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = vertex.matrixWeightsOverride[3];
          } else {
            if (matWeights) {
              vertexData.matricesWeights[currentVertexDataIndex * 4] = matWeights[vertex.vertexIdxForBones];
              vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = matWeights[vertex.vertexIdxForBones + 1];
              vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = matWeights[vertex.vertexIdxForBones + 2];
              vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = matWeights[vertex.vertexIdxForBones + 3];
            }
            if (matWeightsExtra && vertexData.matricesWeightsExtra) {
              vertexData.matricesWeightsExtra[currentVertexDataIndex * 4] = matWeightsExtra[vertex.vertexIdxForBones];
              vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 1] = matWeightsExtra[vertex.vertexIdxForBones + 1];
              vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 2] = matWeightsExtra[vertex.vertexIdxForBones + 2];
              vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 3] = matWeightsExtra[vertex.vertexIdxForBones + 3];
            }
          }
        }
        if (!options.captureUVS) {
          vertexData.uvs.push(0.5 + vertex.position.x / size.x);
          const v = 0.5 + vertex.position.y / size.y;
          vertexData.uvs.push(useOpenGLOrientationForUV ? 1 - v : v);
        } else {
          vertex.uv.toArray(vertexData.uvs, currentVertexDataIndex * 2);
        }
        currentVertexDataIndex++;
      }
    }
  }
  if (vertexData.indices.length === 0) {
    vertexData.indices = null;
  }
  if (vertexData.positions.length === 0) {
    vertexData.positions = null;
  }
  if (vertexData.normals.length === 0) {
    vertexData.normals = null;
  }
  if (vertexData.uvs.length === 0) {
    vertexData.uvs = null;
  }
  if (vertexData.matricesIndices?.length === 0) {
    vertexData.matricesIndices = null;
  }
  if (vertexData.matricesWeights?.length === 0) {
    vertexData.matricesWeights = null;
  }
  if (vertexData.matricesIndicesExtra?.length === 0) {
    vertexData.matricesIndicesExtra = null;
  }
  if (vertexData.matricesWeightsExtra?.length === 0) {
    vertexData.matricesWeightsExtra = null;
  }
  const decal = new Mesh(name13, sourceMesh.getScene());
  vertexData.applyToMesh(decal);
  if (useLocalComputation) {
    decal.skeleton = sourceMesh.skeleton;
    decal.parent = sourceMesh;
  } else {
    decal.position = position.clone();
    decal.rotation = new Vector3(pitch, yaw, angle);
  }
  decal.computeWorldMatrix(true);
  decal.refreshBoundingInfo(true, true);
  return decal;
}
var XpAxis, XnAxis, YpAxis, YnAxis, ZpAxis, ZnAxis, DecalVertex, DecalBuilder;
var init_decalBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/decalBuilder.js"() {
    init_math_vector();
    init_math_scalar_functions();
    init_mesh();
    init_buffer();
    init_mesh_vertexData();
    init_compatibilityOptions();
    XpAxis = new Vector3(1, 0, 0);
    XnAxis = new Vector3(-1, 0, 0);
    YpAxis = new Vector3(0, 1, 0);
    YnAxis = new Vector3(0, -1, 0);
    ZpAxis = new Vector3(0, 0, 1);
    ZnAxis = new Vector3(0, 0, -1);
    DecalVertex = class _DecalVertex {
      constructor(position = Vector3.Zero(), normal = Vector3.Up(), uv = Vector2.Zero(), vertexIdx = 0, vertexIdxForBones = 0, localPositionOverride = null, localNormalOverride = null, matrixIndicesOverride = null, matrixWeightsOverride = null) {
        this.position = position;
        this.normal = normal;
        this.uv = uv;
        this.vertexIdx = vertexIdx;
        this.vertexIdxForBones = vertexIdxForBones;
        this.localPositionOverride = localPositionOverride;
        this.localNormalOverride = localNormalOverride;
        this.matrixIndicesOverride = matrixIndicesOverride;
        this.matrixWeightsOverride = matrixWeightsOverride;
      }
      clone() {
        return new _DecalVertex(this.position.clone(), this.normal.clone(), this.uv.clone(), this.vertexIdx, this.vertexIdxForBones, this.localPositionOverride?.slice(), this.localNormalOverride?.slice(), this.matrixIndicesOverride?.slice(), this.matrixWeightsOverride?.slice());
      }
    };
    DecalBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateDecal
    };
    Mesh.CreateDecal = (name13, sourceMesh, position, normal, size, angle) => {
      const options = {
        position,
        normal,
        size,
        angle
      };
      return CreateDecal(name13, sourceMesh, options);
    };
  }
});

// node_modules/@babylonjs/core/Maths/math.isovector.js
var _IsoVector;
var init_math_isovector = __esm({
  "node_modules/@babylonjs/core/Maths/math.isovector.js"() {
    init_logger();
    init_math_vector();
    _IsoVector = class __IsoVector {
      /**
       * Creates a new isovector from the given x and y coordinates
       * @param x defines the first coordinate, must be an integer
       * @param y defines the second coordinate, must be an integer
       */
      constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
        if (x !== Math.floor(x)) {
          x = Math.floor(x);
          Logger.Warn("x is not an integer, floor(x) used");
        }
        if (y !== Math.floor(y)) {
          y = Math.floor(y);
          Logger.Warn("y is not an integer, floor(y) used");
        }
      }
      // Operators
      /**
       * Gets a new IsoVector copied from the IsoVector
       * @returns a new IsoVector
       */
      clone() {
        return new __IsoVector(this.x, this.y);
      }
      /**
       * Rotates one IsoVector 60 degrees counter clockwise about another
       * Please note that this is an in place operation
       * @param other an IsoVector a center of rotation
       * @returns the rotated IsoVector
       */
      rotate60About(other) {
        const x = this.x;
        this.x = other.x + other.y - this.y;
        this.y = x + this.y - other.x;
        return this;
      }
      /**
       * Rotates one IsoVector 60 degrees clockwise about another
       * Please note that this is an in place operation
       * @param other an IsoVector as center of rotation
       * @returns the rotated IsoVector
       */
      rotateNeg60About(other) {
        const x = this.x;
        this.x = x + this.y - other.y;
        this.y = other.x + other.y - x;
        return this;
      }
      /**
       * For an equilateral triangle OAB with O at isovector (0, 0) and A at isovector (m, n)
       * Rotates one IsoVector 120 degrees counter clockwise about the center of the triangle
       * Please note that this is an in place operation
       * @param m integer a measure a Primary triangle of order (m, n) m > n
       * @param n >= 0 integer a measure for a Primary triangle of order (m, n)
       * @returns the rotated IsoVector
       */
      rotate120(m, n) {
        if (m !== Math.floor(m)) {
          m = Math.floor(m);
          Logger.Warn("m not an integer only floor(m) used");
        }
        if (n !== Math.floor(n)) {
          n = Math.floor(n);
          Logger.Warn("n not an integer only floor(n) used");
        }
        const x = this.x;
        this.x = m - x - this.y;
        this.y = n + x;
        return this;
      }
      /**
       * For an equilateral triangle OAB with O at isovector (0, 0) and A at isovector (m, n)
       * Rotates one IsoVector 120 degrees clockwise about the center of the triangle
       * Please note that this is an in place operation
       * @param m integer a measure a Primary triangle of order (m, n) m > n
       * @param n >= 0 integer a measure for a Primary triangle of order (m, n)
       * @returns the rotated IsoVector
       */
      rotateNeg120(m, n) {
        if (m !== Math.floor(m)) {
          m = Math.floor(m);
          Logger.Warn("m is not an integer, floor(m) used");
        }
        if (n !== Math.floor(n)) {
          n = Math.floor(n);
          Logger.Warn("n is not an integer,   floor(n) used");
        }
        const x = this.x;
        this.x = this.y - n;
        this.y = m + n - x - this.y;
        return this;
      }
      /**
       * Transforms an IsoVector to one in Cartesian 3D space based on an isovector
       * @param origin an IsoVector
       * @param isoGridSize
       * @returns Point as a Vector3
       */
      toCartesianOrigin(origin, isoGridSize) {
        const point = Vector3.Zero();
        point.x = origin.x + 2 * this.x * isoGridSize + this.y * isoGridSize;
        point.y = origin.y + Math.sqrt(3) * this.y * isoGridSize;
        return point;
      }
      // Statics
      /**
       * Gets a new IsoVector(0, 0)
       * @returns a new IsoVector
       */
      static Zero() {
        return new __IsoVector(0, 0);
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/geodesicMesh.js
var _PrimaryIsoTriangle, PolyhedronData, GeodesicData;
var init_geodesicMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/geodesicMesh.js"() {
    init_math_vector();
    init_math_scalar_functions();
    init_math_constants();
    init_math_isovector();
    _PrimaryIsoTriangle = class {
      constructor() {
        this.cartesian = [];
        this.vertices = [];
        this.max = [];
        this.min = [];
        this.closestTo = [];
        this.innerFacets = [];
        this.isoVecsABOB = [];
        this.isoVecsOBOA = [];
        this.isoVecsBAOA = [];
        this.vertexTypes = [];
        this.IDATA = new PolyhedronData("icosahedron", "Regular", [
          [0, PHI, -1],
          [-PHI, 1, 0],
          [-1, 0, -PHI],
          [1, 0, -PHI],
          [PHI, 1, 0],
          [0, PHI, 1],
          [-1, 0, PHI],
          [-PHI, -1, 0],
          [0, -PHI, -1],
          [PHI, -1, 0],
          [1, 0, PHI],
          [0, -PHI, 1]
        ], [
          [0, 2, 1],
          [0, 3, 2],
          [0, 4, 3],
          [0, 5, 4],
          [0, 1, 5],
          [7, 6, 1],
          [8, 7, 2],
          [9, 8, 3],
          [10, 9, 4],
          [6, 10, 5],
          [2, 7, 1],
          [3, 8, 2],
          [4, 9, 3],
          [5, 10, 4],
          [1, 6, 5],
          [11, 6, 7],
          [11, 7, 8],
          [11, 8, 9],
          [11, 9, 10],
          [11, 10, 6]
        ]);
      }
      /**
       * Creates the PrimaryIsoTriangle Triangle OAB
       * @param m an integer
       * @param n an integer
       */
      //operators
      setIndices() {
        let indexCount = 12;
        const vecToidx = {};
        const m = this.m;
        const n = this.n;
        let g = m;
        let m1 = 1;
        let n1 = 0;
        if (n !== 0) {
          g = HighestCommonFactor(m, n);
        }
        m1 = m / g;
        n1 = n / g;
        let fr;
        let rot;
        let O;
        let A;
        let B;
        const oVec = _IsoVector.Zero();
        const aVec = new _IsoVector(m, n);
        const bVec = new _IsoVector(-n, m + n);
        const oaVec = _IsoVector.Zero();
        const abVec = _IsoVector.Zero();
        const obVec = _IsoVector.Zero();
        let verts = [];
        let idx;
        let idxR;
        let isoId;
        let isoIdR;
        const closestTo = [];
        const vDist = this.vertByDist;
        const matchIdx = (f, fr2, isoId2, isoIdR2) => {
          idx = f + "|" + isoId2;
          idxR = fr2 + "|" + isoIdR2;
          if (!(idx in vecToidx || idxR in vecToidx)) {
            vecToidx[idx] = indexCount;
            vecToidx[idxR] = indexCount;
            indexCount++;
          } else if (idx in vecToidx && !(idxR in vecToidx)) {
            vecToidx[idxR] = vecToidx[idx];
          } else if (idxR in vecToidx && !(idx in vecToidx)) {
            vecToidx[idx] = vecToidx[idxR];
          }
          if (vDist[isoId2][0] > 2) {
            closestTo[vecToidx[idx]] = [-vDist[isoId2][0], vDist[isoId2][1], vecToidx[idx]];
          } else {
            closestTo[vecToidx[idx]] = [verts[vDist[isoId2][0]], vDist[isoId2][1], vecToidx[idx]];
          }
        };
        this.IDATA.edgematch = [
          [1, "B"],
          [2, "B"],
          [3, "B"],
          [4, "B"],
          [0, "B"],
          [10, "O", 14, "A"],
          [11, "O", 10, "A"],
          [12, "O", 11, "A"],
          [13, "O", 12, "A"],
          [14, "O", 13, "A"],
          [0, "O"],
          [1, "O"],
          [2, "O"],
          [3, "O"],
          [4, "O"],
          [19, "B", 5, "A"],
          [15, "B", 6, "A"],
          [16, "B", 7, "A"],
          [17, "B", 8, "A"],
          [18, "B", 9, "A"]
        ];
        for (let f = 0; f < 20; f++) {
          verts = this.IDATA.face[f];
          O = verts[2];
          A = verts[1];
          B = verts[0];
          isoId = oVec.x + "|" + oVec.y;
          idx = f + "|" + isoId;
          if (!(idx in vecToidx)) {
            vecToidx[idx] = O;
            closestTo[O] = [verts[vDist[isoId][0]], vDist[isoId][1]];
          }
          isoId = aVec.x + "|" + aVec.y;
          idx = f + "|" + isoId;
          if (!(idx in vecToidx)) {
            vecToidx[idx] = A;
            closestTo[A] = [verts[vDist[isoId][0]], vDist[isoId][1]];
          }
          isoId = bVec.x + "|" + bVec.y;
          idx = f + "|" + isoId;
          if (!(idx in vecToidx)) {
            vecToidx[idx] = B;
            closestTo[B] = [verts[vDist[isoId][0]], vDist[isoId][1]];
          }
          fr = this.IDATA.edgematch[f][0];
          rot = this.IDATA.edgematch[f][1];
          if (rot === "B") {
            for (let i = 1; i < g; i++) {
              abVec.x = m - i * (m1 + n1);
              abVec.y = n + i * m1;
              obVec.x = -i * n1;
              obVec.y = i * (m1 + n1);
              isoId = abVec.x + "|" + abVec.y;
              isoIdR = obVec.x + "|" + obVec.y;
              matchIdx(f, fr, isoId, isoIdR);
            }
          }
          if (rot === "O") {
            for (let i = 1; i < g; i++) {
              obVec.x = -i * n1;
              obVec.y = i * (m1 + n1);
              oaVec.x = i * m1;
              oaVec.y = i * n1;
              isoId = obVec.x + "|" + obVec.y;
              isoIdR = oaVec.x + "|" + oaVec.y;
              matchIdx(f, fr, isoId, isoIdR);
            }
          }
          fr = this.IDATA.edgematch[f][2];
          rot = this.IDATA.edgematch[f][3];
          if (rot && rot === "A") {
            for (let i = 1; i < g; i++) {
              oaVec.x = i * m1;
              oaVec.y = i * n1;
              abVec.x = m - (g - i) * (m1 + n1);
              abVec.y = n + (g - i) * m1;
              isoId = oaVec.x + "|" + oaVec.y;
              isoIdR = abVec.x + "|" + abVec.y;
              matchIdx(f, fr, isoId, isoIdR);
            }
          }
          for (let i = 0; i < this.vertices.length; i++) {
            isoId = this.vertices[i].x + "|" + this.vertices[i].y;
            idx = f + "|" + isoId;
            if (!(idx in vecToidx)) {
              vecToidx[idx] = indexCount++;
              if (vDist[isoId][0] > 2) {
                closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];
              } else {
                closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];
              }
            }
          }
        }
        this.closestTo = closestTo;
        this.vecToidx = vecToidx;
      }
      calcCoeffs() {
        const m = this.m;
        const n = this.n;
        const thirdR3 = Math.sqrt(3) / 3;
        const LSQD = m * m + n * n + m * n;
        this.coau = (m + n) / LSQD;
        this.cobu = -n / LSQD;
        this.coav = -thirdR3 * (m - n) / LSQD;
        this.cobv = thirdR3 * (2 * m + n) / LSQD;
      }
      createInnerFacets() {
        const m = this.m;
        const n = this.n;
        for (let y = 0; y < n + m + 1; y++) {
          for (let x = this.min[y]; x < this.max[y] + 1; x++) {
            if (x < this.max[y] && x < this.max[y + 1] + 1) {
              this.innerFacets.push(["|" + x + "|" + y, "|" + x + "|" + (y + 1), "|" + (x + 1) + "|" + y]);
            }
            if (y > 0 && x < this.max[y - 1] && x + 1 < this.max[y] + 1) {
              this.innerFacets.push(["|" + x + "|" + y, "|" + (x + 1) + "|" + y, "|" + (x + 1) + "|" + (y - 1)]);
            }
          }
        }
      }
      edgeVecsABOB() {
        const m = this.m;
        const n = this.n;
        const B = new _IsoVector(-n, m + n);
        for (let y = 1; y < m + n; y++) {
          const point = new _IsoVector(this.min[y], y);
          const prev = new _IsoVector(this.min[y - 1], y - 1);
          const next = new _IsoVector(this.min[y + 1], y + 1);
          const pointR = point.clone();
          const prevR = prev.clone();
          const nextR = next.clone();
          pointR.rotate60About(B);
          prevR.rotate60About(B);
          nextR.rotate60About(B);
          const maxPoint = new _IsoVector(this.max[pointR.y], pointR.y);
          const maxPrev = new _IsoVector(this.max[pointR.y - 1], pointR.y - 1);
          const maxLeftPrev = new _IsoVector(this.max[pointR.y - 1] - 1, pointR.y - 1);
          if (pointR.x !== maxPoint.x || pointR.y !== maxPoint.y) {
            if (pointR.x !== maxPrev.x) {
              this.vertexTypes.push([1, 0, 0]);
              this.isoVecsABOB.push([point, maxPrev, maxLeftPrev]);
              this.vertexTypes.push([1, 0, 0]);
              this.isoVecsABOB.push([point, maxLeftPrev, maxPoint]);
            } else if (pointR.y === nextR.y) {
              this.vertexTypes.push([1, 1, 0]);
              this.isoVecsABOB.push([point, prev, maxPrev]);
              this.vertexTypes.push([1, 0, 1]);
              this.isoVecsABOB.push([point, maxPrev, next]);
            } else {
              this.vertexTypes.push([1, 1, 0]);
              this.isoVecsABOB.push([point, prev, maxPrev]);
              this.vertexTypes.push([1, 0, 0]);
              this.isoVecsABOB.push([point, maxPrev, maxPoint]);
            }
          }
        }
      }
      mapABOBtoOBOA() {
        const point = new _IsoVector(0, 0);
        for (let i = 0; i < this.isoVecsABOB.length; i++) {
          const temp = [];
          for (let j = 0; j < 3; j++) {
            point.x = this.isoVecsABOB[i][j].x;
            point.y = this.isoVecsABOB[i][j].y;
            if (this.vertexTypes[i][j] === 0) {
              point.rotateNeg120(this.m, this.n);
            }
            temp.push(point.clone());
          }
          this.isoVecsOBOA.push(temp);
        }
      }
      mapABOBtoBAOA() {
        const point = new _IsoVector(0, 0);
        for (let i = 0; i < this.isoVecsABOB.length; i++) {
          const temp = [];
          for (let j = 0; j < 3; j++) {
            point.x = this.isoVecsABOB[i][j].x;
            point.y = this.isoVecsABOB[i][j].y;
            if (this.vertexTypes[i][j] === 1) {
              point.rotate120(this.m, this.n);
            }
            temp.push(point.clone());
          }
          this.isoVecsBAOA.push(temp);
        }
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      MapToFace(faceNb, geodesicData) {
        const F = this.IDATA.face[faceNb];
        const oidx = F[2];
        const aidx = F[1];
        const bidx = F[0];
        const O = Vector3.FromArray(this.IDATA.vertex[oidx]);
        const A = Vector3.FromArray(this.IDATA.vertex[aidx]);
        const B = Vector3.FromArray(this.IDATA.vertex[bidx]);
        const OA = A.subtract(O);
        const OB = B.subtract(O);
        const x = OA.scale(this.coau).add(OB.scale(this.cobu));
        const y = OA.scale(this.coav).add(OB.scale(this.cobv));
        const mapped = [];
        let idx;
        let tempVec = TmpVectors.Vector3[0];
        for (let i = 0; i < this.cartesian.length; i++) {
          tempVec = x.scale(this.cartesian[i].x).add(y.scale(this.cartesian[i].y)).add(O);
          mapped[i] = [tempVec.x, tempVec.y, tempVec.z];
          idx = faceNb + "|" + this.vertices[i].x + "|" + this.vertices[i].y;
          geodesicData.vertex[this.vecToidx[idx]] = [tempVec.x, tempVec.y, tempVec.z];
        }
      }
      //statics
      /**Creates a primary triangle
       * @internal
       */
      build(m, n) {
        const vertices = [];
        const O = _IsoVector.Zero();
        const A = new _IsoVector(m, n);
        const B = new _IsoVector(-n, m + n);
        vertices.push(O, A, B);
        for (let y2 = n; y2 < m + 1; y2++) {
          for (let x2 = 0; x2 < m + 1 - y2; x2++) {
            vertices.push(new _IsoVector(x2, y2));
          }
        }
        if (n > 0) {
          const g = HighestCommonFactor(m, n);
          const m1 = m / g;
          const n1 = n / g;
          for (let i = 1; i < g; i++) {
            vertices.push(new _IsoVector(i * m1, i * n1));
            vertices.push(new _IsoVector(-i * n1, i * (m1 + n1)));
            vertices.push(new _IsoVector(m - i * (m1 + n1), n + i * m1));
          }
          const ratio = m / n;
          for (let y2 = 1; y2 < n; y2++) {
            for (let x2 = 0; x2 < y2 * ratio; x2++) {
              vertices.push(new _IsoVector(x2, y2));
              vertices.push(new _IsoVector(x2, y2).rotate120(m, n));
              vertices.push(new _IsoVector(x2, y2).rotateNeg120(m, n));
            }
          }
        }
        vertices.sort((a, b) => {
          return a.x - b.x;
        });
        vertices.sort((a, b) => {
          return a.y - b.y;
        });
        const min = new Array(m + n + 1);
        const max = new Array(m + n + 1);
        for (let i = 0; i < min.length; i++) {
          min[i] = Infinity;
          max[i] = -Infinity;
        }
        let y = 0;
        let x = 0;
        const len = vertices.length;
        for (let i = 0; i < len; i++) {
          x = vertices[i].x;
          y = vertices[i].y;
          min[y] = Math.min(x, min[y]);
          max[y] = Math.max(x, max[y]);
        }
        const distFrom = (vert, primVert) => {
          const v = vert.clone();
          if (primVert === "A") {
            v.rotateNeg120(m, n);
          }
          if (primVert === "B") {
            v.rotate120(m, n);
          }
          if (v.x < 0) {
            return v.y;
          }
          return v.x + v.y;
        };
        const cartesian = [];
        const distFromO = [];
        const distFromA = [];
        const distFromB = [];
        const vertByDist = {};
        const vertData = [];
        let closest = -1;
        let dist = -1;
        for (let i = 0; i < len; i++) {
          cartesian[i] = vertices[i].toCartesianOrigin(new _IsoVector(0, 0), 0.5);
          distFromO[i] = distFrom(vertices[i], "O");
          distFromA[i] = distFrom(vertices[i], "A");
          distFromB[i] = distFrom(vertices[i], "B");
          if (distFromO[i] === distFromA[i] && distFromA[i] === distFromB[i]) {
            closest = 3;
            dist = distFromO[i];
          } else if (distFromO[i] === distFromA[i]) {
            closest = 4;
            dist = distFromO[i];
          } else if (distFromA[i] === distFromB[i]) {
            closest = 5;
            dist = distFromA[i];
          } else if (distFromB[i] === distFromO[i]) {
            closest = 6;
            dist = distFromO[i];
          }
          if (distFromO[i] < distFromA[i] && distFromO[i] < distFromB[i]) {
            closest = 2;
            dist = distFromO[i];
          }
          if (distFromA[i] < distFromO[i] && distFromA[i] < distFromB[i]) {
            closest = 1;
            dist = distFromA[i];
          }
          if (distFromB[i] < distFromA[i] && distFromB[i] < distFromO[i]) {
            closest = 0;
            dist = distFromB[i];
          }
          vertData.push([closest, dist, vertices[i].x, vertices[i].y]);
        }
        vertData.sort((a, b) => {
          return a[2] - b[2];
        });
        vertData.sort((a, b) => {
          return a[3] - b[3];
        });
        vertData.sort((a, b) => {
          return a[1] - b[1];
        });
        vertData.sort((a, b) => {
          return a[0] - b[0];
        });
        for (let v = 0; v < vertData.length; v++) {
          vertByDist[vertData[v][2] + "|" + vertData[v][3]] = [vertData[v][0], vertData[v][1], v];
        }
        this.m = m;
        this.n = n;
        this.vertices = vertices;
        this.vertByDist = vertByDist;
        this.cartesian = cartesian;
        this.min = min;
        this.max = max;
        return this;
      }
    };
    PolyhedronData = class {
      constructor(name13, category, vertex, face) {
        this.name = name13;
        this.category = category;
        this.vertex = vertex;
        this.face = face;
      }
    };
    GeodesicData = class _GeodesicData extends PolyhedronData {
      /**
       * @internal
       */
      innerToData(face, primTri) {
        for (let i = 0; i < primTri.innerFacets.length; i++) {
          this.face.push(primTri.innerFacets[i].map((el) => primTri.vecToidx[face + el]));
        }
      }
      /**
       * @internal
       */
      mapABOBtoDATA(faceNb, primTri) {
        const fr = primTri.IDATA.edgematch[faceNb][0];
        for (let i = 0; i < primTri.isoVecsABOB.length; i++) {
          const temp = [];
          for (let j = 0; j < 3; j++) {
            if (primTri.vertexTypes[i][j] === 0) {
              temp.push(faceNb + "|" + primTri.isoVecsABOB[i][j].x + "|" + primTri.isoVecsABOB[i][j].y);
            } else {
              temp.push(fr + "|" + primTri.isoVecsABOB[i][j].x + "|" + primTri.isoVecsABOB[i][j].y);
            }
          }
          this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);
        }
      }
      /**
       * @internal
       */
      mapOBOAtoDATA(faceNb, primTri) {
        const fr = primTri.IDATA.edgematch[faceNb][0];
        for (let i = 0; i < primTri.isoVecsOBOA.length; i++) {
          const temp = [];
          for (let j = 0; j < 3; j++) {
            if (primTri.vertexTypes[i][j] === 1) {
              temp.push(faceNb + "|" + primTri.isoVecsOBOA[i][j].x + "|" + primTri.isoVecsOBOA[i][j].y);
            } else {
              temp.push(fr + "|" + primTri.isoVecsOBOA[i][j].x + "|" + primTri.isoVecsOBOA[i][j].y);
            }
          }
          this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);
        }
      }
      /**
       * @internal
       */
      mapBAOAtoDATA(faceNb, primTri) {
        const fr = primTri.IDATA.edgematch[faceNb][2];
        for (let i = 0; i < primTri.isoVecsBAOA.length; i++) {
          const temp = [];
          for (let j = 0; j < 3; j++) {
            if (primTri.vertexTypes[i][j] === 1) {
              temp.push(faceNb + "|" + primTri.isoVecsBAOA[i][j].x + "|" + primTri.isoVecsBAOA[i][j].y);
            } else {
              temp.push(fr + "|" + primTri.isoVecsBAOA[i][j].x + "|" + primTri.isoVecsBAOA[i][j].y);
            }
          }
          this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);
        }
      }
      /**
       * @internal
       */
      orderData(primTri) {
        const nearTo = [];
        for (let i = 0; i < 13; i++) {
          nearTo[i] = [];
        }
        const close = primTri.closestTo;
        for (let i = 0; i < close.length; i++) {
          if (close[i][0] > -1) {
            if (close[i][1] > 0) {
              nearTo[close[i][0]].push([i, close[i][1]]);
            }
          } else {
            nearTo[12].push([i, close[i][0]]);
          }
        }
        const near = [];
        for (let i = 0; i < 12; i++) {
          near[i] = i;
        }
        let nearIndex = 12;
        for (let i = 0; i < 12; i++) {
          nearTo[i].sort((a, b) => {
            return a[1] - b[1];
          });
          for (let j = 0; j < nearTo[i].length; j++) {
            near[nearTo[i][j][0]] = nearIndex++;
          }
        }
        for (let j = 0; j < nearTo[12].length; j++) {
          near[nearTo[12][j][0]] = nearIndex++;
        }
        for (let i = 0; i < this.vertex.length; i++) {
          this.vertex[i].push(near[i]);
        }
        this.vertex.sort((a, b) => {
          return a[3] - b[3];
        });
        for (let i = 0; i < this.vertex.length; i++) {
          this.vertex[i].pop();
        }
        for (let i = 0; i < this.face.length; i++) {
          for (let j = 0; j < this.face[i].length; j++) {
            this.face[i][j] = near[this.face[i][j]];
          }
        }
        this.sharedNodes = nearTo[12].length;
        this.poleNodes = this.vertex.length - this.sharedNodes;
      }
      /**
       * @internal
       */
      setOrder(m, faces) {
        const adjVerts = [];
        const dualFaces = [];
        let face = faces.pop();
        dualFaces.push(face);
        let index = this.face[face].indexOf(m);
        index = (index + 2) % 3;
        let v = this.face[face][index];
        adjVerts.push(v);
        let f = 0;
        while (faces.length > 0) {
          face = faces[f];
          if (this.face[face].indexOf(v) > -1) {
            index = (this.face[face].indexOf(v) + 1) % 3;
            v = this.face[face][index];
            adjVerts.push(v);
            dualFaces.push(face);
            faces.splice(f, 1);
            f = 0;
          } else {
            f++;
          }
        }
        this.adjacentFaces.push(adjVerts);
        return dualFaces;
      }
      /**
       * @internal
       */
      toGoldbergPolyhedronData() {
        const goldbergPolyhedronData = new PolyhedronData("GeoDual", "Goldberg", [], []);
        goldbergPolyhedronData.name = "GD dual";
        const verticesNb = this.vertex.length;
        const map = new Array(verticesNb);
        for (let v = 0; v < verticesNb; v++) {
          map[v] = [];
        }
        for (let f = 0; f < this.face.length; f++) {
          for (let i = 0; i < 3; i++) {
            map[this.face[f][i]].push(f);
          }
        }
        let cx = 0;
        let cy = 0;
        let cz = 0;
        let face = [];
        let vertex = [];
        this.adjacentFaces = [];
        for (let m = 0; m < map.length; m++) {
          goldbergPolyhedronData.face[m] = this.setOrder(m, map[m].concat([]));
          for (const el of map[m]) {
            cx = 0;
            cy = 0;
            cz = 0;
            face = this.face[el];
            for (let i = 0; i < 3; i++) {
              vertex = this.vertex[face[i]];
              cx += vertex[0];
              cy += vertex[1];
              cz += vertex[2];
            }
            goldbergPolyhedronData.vertex[el] = [cx / 3, cy / 3, cz / 3];
          }
        }
        return goldbergPolyhedronData;
      }
      //statics
      /**Builds the data for a Geodesic Polyhedron from a primary triangle
       * @param primTri the primary triangle
       * @internal
       */
      static BuildGeodesicData(primTri) {
        const geodesicData = new _GeodesicData("Geodesic-m-n", "Geodesic", [
          [0, PHI, -1],
          [-PHI, 1, 0],
          [-1, 0, -PHI],
          [1, 0, -PHI],
          [PHI, 1, 0],
          [0, PHI, 1],
          [-1, 0, PHI],
          [-PHI, -1, 0],
          [0, -PHI, -1],
          [PHI, -1, 0],
          [1, 0, PHI],
          [0, -PHI, 1]
        ], []);
        primTri.setIndices();
        primTri.calcCoeffs();
        primTri.createInnerFacets();
        primTri.edgeVecsABOB();
        primTri.mapABOBtoOBOA();
        primTri.mapABOBtoBAOA();
        for (let f = 0; f < primTri.IDATA.face.length; f++) {
          primTri.MapToFace(f, geodesicData);
          geodesicData.innerToData(f, primTri);
          if (primTri.IDATA.edgematch[f][1] === "B") {
            geodesicData.mapABOBtoDATA(f, primTri);
          }
          if (primTri.IDATA.edgematch[f][1] === "O") {
            geodesicData.mapOBOAtoDATA(f, primTri);
          }
          if (primTri.IDATA.edgematch[f][3] === "A") {
            geodesicData.mapBAOAtoDATA(f, primTri);
          }
        }
        geodesicData.orderData(primTri);
        const radius = 1;
        geodesicData.vertex = geodesicData.vertex.map(function(el) {
          const a = el[0];
          const b = el[1];
          const c = el[2];
          const d = Math.sqrt(a * a + b * b + c * c);
          el[0] *= radius / d;
          el[1] *= radius / d;
          el[2] *= radius / d;
          return el;
        });
        return geodesicData;
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/geodesicBuilder.js
function CreateGeodesic(name13, options, scene = null) {
  let m = options.m || 1;
  if (m !== Math.floor(m)) {
    m = Math.floor(m);
    Logger.Warn("m not an integer only floor(m) used");
  }
  let n = options.n || 0;
  if (n !== Math.floor(n)) {
    n = Math.floor(n);
    Logger.Warn("n not an integer only floor(n) used");
  }
  if (n > m) {
    const temp = n;
    n = m;
    m = temp;
    Logger.Warn("n > m therefore m and n swapped");
  }
  const primTri = new _PrimaryIsoTriangle();
  primTri.build(m, n);
  const geodesicData = GeodesicData.BuildGeodesicData(primTri);
  const geoOptions = {
    custom: geodesicData,
    size: options.size,
    sizeX: options.sizeX,
    sizeY: options.sizeY,
    sizeZ: options.sizeZ,
    faceUV: options.faceUV,
    faceColors: options.faceColors,
    flat: options.flat,
    updatable: options.updatable,
    sideOrientation: options.sideOrientation,
    frontUVs: options.frontUVs,
    backUVs: options.backUVs
  };
  const geodesic = CreatePolyhedron(name13, geoOptions, scene);
  return geodesic;
}
var init_geodesicBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/geodesicBuilder.js"() {
    init_polyhedronBuilder();
    init_logger();
    init_geodesicMesh();
  }
});

// node_modules/@babylonjs/core/Meshes/goldbergMesh.js
var GoldbergMesh;
var init_goldbergMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/goldbergMesh.js"() {
    init_math_vector();
    init_buffer();
    init_mesh();
    init_math_color();
    init_logger();
    Mesh._GoldbergMeshParser = (parsedMesh, scene) => {
      return GoldbergMesh.Parse(parsedMesh, scene);
    };
    GoldbergMesh = class _GoldbergMesh extends Mesh {
      constructor() {
        super(...arguments);
        this.goldbergData = {
          faceColors: [],
          faceCenters: [],
          faceZaxis: [],
          faceXaxis: [],
          faceYaxis: [],
          nbSharedFaces: 0,
          nbUnsharedFaces: 0,
          nbFaces: 0,
          nbFacesAtPole: 0,
          adjacentFaces: []
        };
      }
      /**
       * Gets the related Goldberg face from pole infos
       * @param poleOrShared Defines the pole index or the shared face index if the fromPole parameter is passed in
       * @param fromPole Defines an optional pole index to find the related info from
       * @returns the goldberg face number
       */
      relatedGoldbergFace(poleOrShared, fromPole) {
        if (fromPole === void 0) {
          if (poleOrShared > this.goldbergData.nbUnsharedFaces - 1) {
            Logger.Warn("Maximum number of unshared faces used");
            poleOrShared = this.goldbergData.nbUnsharedFaces - 1;
          }
          return this.goldbergData.nbUnsharedFaces + poleOrShared;
        }
        if (poleOrShared > 11) {
          Logger.Warn("Last pole used");
          poleOrShared = 11;
        }
        if (fromPole > this.goldbergData.nbFacesAtPole - 1) {
          Logger.Warn("Maximum number of faces at a pole used");
          fromPole = this.goldbergData.nbFacesAtPole - 1;
        }
        return 12 + poleOrShared * this.goldbergData.nbFacesAtPole + fromPole;
      }
      _changeGoldbergFaceColors(colorRange) {
        for (let i = 0; i < colorRange.length; i++) {
          const min = colorRange[i][0];
          const max = colorRange[i][1];
          const col = colorRange[i][2];
          for (let f = min; f < max + 1; f++) {
            this.goldbergData.faceColors[f] = col;
          }
        }
        const newCols = [];
        for (let f = 0; f < 12; f++) {
          for (let i = 0; i < 5; i++) {
            newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);
          }
        }
        for (let f = 12; f < this.goldbergData.faceColors.length; f++) {
          for (let i = 0; i < 6; i++) {
            newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);
          }
        }
        return newCols;
      }
      /**
       * Set new goldberg face colors
       * @param colorRange the new color to apply to the mesh
       */
      setGoldbergFaceColors(colorRange) {
        const newCols = this._changeGoldbergFaceColors(colorRange);
        this.setVerticesData(VertexBuffer.ColorKind, newCols);
      }
      /**
       * Updates new goldberg face colors
       * @param colorRange the new color to apply to the mesh
       */
      updateGoldbergFaceColors(colorRange) {
        const newCols = this._changeGoldbergFaceColors(colorRange);
        this.updateVerticesData(VertexBuffer.ColorKind, newCols);
      }
      _changeGoldbergFaceUVs(uvRange) {
        const uvs = this.getVerticesData(VertexBuffer.UVKind);
        for (let i = 0; i < uvRange.length; i++) {
          const min = uvRange[i][0];
          const max = uvRange[i][1];
          const center = uvRange[i][2];
          const radius = uvRange[i][3];
          const angle = uvRange[i][4];
          const points5 = [];
          const points6 = [];
          let u;
          let v;
          for (let p = 0; p < 5; p++) {
            u = center.x + radius * Math.cos(angle + p * Math.PI / 2.5);
            v = center.y + radius * Math.sin(angle + p * Math.PI / 2.5);
            if (u < 0) {
              u = 0;
            }
            if (u > 1) {
              u = 1;
            }
            points5.push(u, v);
          }
          for (let p = 0; p < 6; p++) {
            u = center.x + radius * Math.cos(angle + p * Math.PI / 3);
            v = center.y + radius * Math.sin(angle + p * Math.PI / 3);
            if (u < 0) {
              u = 0;
            }
            if (u > 1) {
              u = 1;
            }
            points6.push(u, v);
          }
          for (let f = min; f < Math.min(12, max + 1); f++) {
            for (let p = 0; p < 5; p++) {
              uvs[10 * f + 2 * p] = points5[2 * p];
              uvs[10 * f + 2 * p + 1] = points5[2 * p + 1];
            }
          }
          for (let f = Math.max(12, min); f < max + 1; f++) {
            for (let p = 0; p < 6; p++) {
              uvs[12 * f - 24 + 2 * p] = points6[2 * p];
              uvs[12 * f - 23 + 2 * p] = points6[2 * p + 1];
            }
          }
        }
        return uvs;
      }
      /**
       * set new goldberg face UVs
       * @param uvRange the new UVs to apply to the mesh
       */
      setGoldbergFaceUVs(uvRange) {
        const newUVs = this._changeGoldbergFaceUVs(uvRange);
        this.setVerticesData(VertexBuffer.UVKind, newUVs);
      }
      /**
       * Updates new goldberg face UVs
       * @param uvRange the new UVs to apply to the mesh
       */
      updateGoldbergFaceUVs(uvRange) {
        const newUVs = this._changeGoldbergFaceUVs(uvRange);
        this.updateVerticesData(VertexBuffer.UVKind, newUVs);
      }
      /**
       * Places a mesh on a particular face of the goldberg polygon
       * @param mesh Defines the mesh to position
       * @param face Defines the face to position onto
       * @param position Defines the position relative to the face we are positioning the mesh onto
       */
      placeOnGoldbergFaceAt(mesh, face, position) {
        const orientation = Vector3.RotationFromAxis(this.goldbergData.faceXaxis[face], this.goldbergData.faceYaxis[face], this.goldbergData.faceZaxis[face]);
        mesh.rotation = orientation;
        mesh.position = this.goldbergData.faceCenters[face].add(this.goldbergData.faceXaxis[face].scale(position.x)).add(this.goldbergData.faceYaxis[face].scale(position.y)).add(this.goldbergData.faceZaxis[face].scale(position.z));
      }
      /**
       * Serialize current mesh
       * @param serializationObject defines the object which will receive the serialization data
       */
      serialize(serializationObject) {
        super.serialize(serializationObject);
        serializationObject.type = "GoldbergMesh";
        const goldbergData = {};
        goldbergData.adjacentFaces = this.goldbergData.adjacentFaces;
        goldbergData.nbSharedFaces = this.goldbergData.nbSharedFaces;
        goldbergData.nbUnsharedFaces = this.goldbergData.nbUnsharedFaces;
        goldbergData.nbFaces = this.goldbergData.nbFaces;
        goldbergData.nbFacesAtPole = this.goldbergData.nbFacesAtPole;
        if (this.goldbergData.faceColors) {
          goldbergData.faceColors = [];
          for (const color of this.goldbergData.faceColors) {
            goldbergData.faceColors.push(color.asArray());
          }
        }
        if (this.goldbergData.faceCenters) {
          goldbergData.faceCenters = [];
          for (const vector of this.goldbergData.faceCenters) {
            goldbergData.faceCenters.push(vector.asArray());
          }
        }
        if (this.goldbergData.faceZaxis) {
          goldbergData.faceZaxis = [];
          for (const vector of this.goldbergData.faceZaxis) {
            goldbergData.faceZaxis.push(vector.asArray());
          }
        }
        if (this.goldbergData.faceYaxis) {
          goldbergData.faceYaxis = [];
          for (const vector of this.goldbergData.faceYaxis) {
            goldbergData.faceYaxis.push(vector.asArray());
          }
        }
        if (this.goldbergData.faceXaxis) {
          goldbergData.faceXaxis = [];
          for (const vector of this.goldbergData.faceXaxis) {
            goldbergData.faceXaxis.push(vector.asArray());
          }
        }
        serializationObject.goldbergData = goldbergData;
      }
      /**
       * Parses a serialized goldberg mesh
       * @param parsedMesh the serialized mesh
       * @param scene the scene to create the goldberg mesh in
       * @returns the created goldberg mesh
       */
      static Parse(parsedMesh, scene) {
        const goldbergData = parsedMesh.goldbergData;
        goldbergData.faceColors = goldbergData.faceColors.map((el) => Color4.FromArray(el));
        goldbergData.faceCenters = goldbergData.faceCenters.map((el) => Vector3.FromArray(el));
        goldbergData.faceZaxis = goldbergData.faceZaxis.map((el) => Vector3.FromArray(el));
        goldbergData.faceXaxis = goldbergData.faceXaxis.map((el) => Vector3.FromArray(el));
        goldbergData.faceYaxis = goldbergData.faceYaxis.map((el) => Vector3.FromArray(el));
        const goldberg = new _GoldbergMesh(parsedMesh.name, scene);
        goldberg.goldbergData = goldbergData;
        return goldberg;
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/goldbergBuilder.js
function CreateGoldbergVertexData(options, goldbergData) {
  const size = options.size;
  const sizeX = options.sizeX || size || 1;
  const sizeY = options.sizeY || size || 1;
  const sizeZ = options.sizeZ || size || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const positions = [];
  const indices = [];
  const normals = [];
  const uvs = [];
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let v = 0; v < goldbergData.vertex.length; v++) {
    minX = Math.min(minX, goldbergData.vertex[v][0] * sizeX);
    maxX = Math.max(maxX, goldbergData.vertex[v][0] * sizeX);
    minY = Math.min(minY, goldbergData.vertex[v][1] * sizeY);
    maxY = Math.max(maxY, goldbergData.vertex[v][1] * sizeY);
  }
  let index = 0;
  for (let f = 0; f < goldbergData.face.length; f++) {
    const verts = goldbergData.face[f];
    const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);
    const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);
    const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);
    const ba = b.subtract(a);
    const ca = c.subtract(a);
    const norm = Vector3.Cross(ca, ba).normalize();
    for (let v = 0; v < verts.length; v++) {
      normals.push(norm.x, norm.y, norm.z);
      const pdata = goldbergData.vertex[verts[v]];
      positions.push(pdata[0] * sizeX, pdata[1] * sizeY, pdata[2] * sizeZ);
      const vCoord = (pdata[1] * sizeY - minY) / (maxY - minY);
      uvs.push((pdata[0] * sizeX - minX) / (maxX - minX), useOpenGLOrientationForUV ? 1 - vCoord : vCoord);
    }
    for (let v = 0; v < verts.length - 2; v++) {
      indices.push(index, index + v + 2, index + v + 1);
    }
    index += verts.length;
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);
  const vertexData = new VertexData();
  vertexData.positions = positions;
  vertexData.indices = indices;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateGoldberg(name13, options, scene = null) {
  const size = options.size;
  const sizeX = options.sizeX || size || 1;
  const sizeY = options.sizeY || size || 1;
  const sizeZ = options.sizeZ || size || 1;
  let m = options.m || 1;
  if (m !== Math.floor(m)) {
    m = Math.floor(m);
    Logger.Warn("m not an integer only floor(m) used");
  }
  let n = options.n || 0;
  if (n !== Math.floor(n)) {
    n = Math.floor(n);
    Logger.Warn("n not an integer only floor(n) used");
  }
  if (n > m) {
    const temp = n;
    n = m;
    m = temp;
    Logger.Warn("n > m therefore m and n swapped");
  }
  const primTri = new _PrimaryIsoTriangle();
  primTri.build(m, n);
  const geodesicData = GeodesicData.BuildGeodesicData(primTri);
  const goldbergData = geodesicData.toGoldbergPolyhedronData();
  const goldberg = new GoldbergMesh(name13, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  goldberg._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateGoldbergVertexData(options, goldbergData);
  vertexData.applyToMesh(goldberg, options.updatable);
  goldberg.goldbergData.nbSharedFaces = geodesicData.sharedNodes;
  goldberg.goldbergData.nbUnsharedFaces = geodesicData.poleNodes;
  goldberg.goldbergData.adjacentFaces = geodesicData.adjacentFaces;
  goldberg.goldbergData.nbFaces = goldberg.goldbergData.nbSharedFaces + goldberg.goldbergData.nbUnsharedFaces;
  goldberg.goldbergData.nbFacesAtPole = (goldberg.goldbergData.nbUnsharedFaces - 12) / 12;
  for (let f = 0; f < geodesicData.vertex.length; f++) {
    goldberg.goldbergData.faceCenters.push(Vector3.FromArray(geodesicData.vertex[f]));
    goldberg.goldbergData.faceCenters[f].x *= sizeX;
    goldberg.goldbergData.faceCenters[f].y *= sizeY;
    goldberg.goldbergData.faceCenters[f].z *= sizeZ;
    goldberg.goldbergData.faceColors.push(new Color4(1, 1, 1, 1));
  }
  for (let f = 0; f < goldbergData.face.length; f++) {
    const verts = goldbergData.face[f];
    const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);
    const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);
    const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);
    const ba = b.subtract(a);
    const ca = c.subtract(a);
    const norm = Vector3.Cross(ca, ba).normalize();
    const z = Vector3.Cross(ca, norm).normalize();
    goldberg.goldbergData.faceXaxis.push(ca.normalize());
    goldberg.goldbergData.faceYaxis.push(norm);
    goldberg.goldbergData.faceZaxis.push(z);
  }
  return goldberg;
}
var init_goldbergBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/goldbergBuilder.js"() {
    init_math_vector();
    init_math_color();
    init_mesh();
    init_mesh_vertexData();
    init_logger();
    init_geodesicMesh();
    init_goldbergMesh();
    init_compatibilityOptions();
  }
});

// node_modules/@babylonjs/core/Meshes/meshBuilder.js
var MeshBuilder;
var init_meshBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/meshBuilder.js"() {
    init_ribbonBuilder();
    init_discBuilder();
    init_boxBuilder();
    init_tiledBoxBuilder();
    init_sphereBuilder();
    init_cylinderBuilder();
    init_torusBuilder();
    init_torusKnotBuilder();
    init_linesBuilder();
    init_polygonBuilder();
    init_shapeBuilder();
    init_latheBuilder();
    init_planeBuilder();
    init_tiledPlaneBuilder();
    init_groundBuilder();
    init_tubeBuilder();
    init_polyhedronBuilder();
    init_icoSphereBuilder();
    init_decalBuilder();
    init_capsuleBuilder();
    init_geodesicBuilder();
    init_goldbergBuilder();
    init_textBuilder();
    MeshBuilder = {
      CreateBox,
      CreateTiledBox,
      CreateSphere,
      CreateDisc,
      CreateIcoSphere,
      CreateRibbon,
      CreateCylinder,
      CreateTorus,
      CreateTorusKnot,
      CreateLineSystem,
      CreateLines,
      CreateDashedLines,
      ExtrudeShape,
      ExtrudeShapeCustom,
      CreateLathe,
      CreateTiledPlane,
      CreatePlane,
      CreateGround,
      CreateTiledGround,
      CreateGroundFromHeightMap,
      CreatePolygon,
      ExtrudePolygon,
      CreateTube,
      CreatePolyhedron,
      CreateGeodesic,
      CreateGoldberg,
      CreateDecal,
      CreateCapsule,
      CreateText
    };
  }
});

// node_modules/@babylonjs/core/Debug/physicsViewer.js
var PhysicsViewer;
var init_physicsViewer = __esm({
  "node_modules/@babylonjs/core/Debug/physicsViewer.js"() {
    init_mesh();
    init_boxBuilder();
    init_sphereBuilder();
    init_math_vector();
    init_math_color();
    init_engineStore();
    init_standardMaterial();
    init_physicsImpostor();
    init_utilityLayerRenderer();
    init_cylinderBuilder();
    init_capsuleBuilder();
    init_logger();
    init_mesh_vertexData();
    init_meshBuilder();
    init_axesViewer();
    init_transformNode();
    init_math_constants();
    PhysicsViewer = class {
      /**
       * Creates a new PhysicsViewer
       * @param scene defines the hosting scene
       * @param size Physics V2 size scalar
       * @param utilityLayer The utility layer the viewer will be added to
       */
      constructor(scene, size, utilityLayer = UtilityLayerRenderer.DefaultUtilityLayer) {
        this._impostors = [];
        this._meshes = [];
        this._bodies = [];
        this._inertiaBodies = [];
        this._constraints = [];
        this._bodyMeshes = [];
        this._inertiaMeshes = [];
        this._constraintMeshes = [];
        this._numMeshes = 0;
        this._numBodies = 0;
        this._numInertiaBodies = 0;
        this._numConstraints = 0;
        this._ownUtilityLayer = false;
        this._debugMeshMeshes = new Array();
        this._constraintAxesSize = 0.4;
        this._constraintAngularSize = 0.4;
        this._scene = scene || EngineStore.LastCreatedScene;
        if (!this._scene) {
          return;
        }
        const physicEngine = this._scene.getPhysicsEngine();
        if (physicEngine) {
          this._physicsEnginePlugin = physicEngine.getPhysicsPlugin();
        }
        if (utilityLayer) {
          this._utilityLayer = utilityLayer;
        } else {
          this._utilityLayer = new UtilityLayerRenderer(this._scene, false);
          this._utilityLayer.pickUtilitySceneFirst = false;
          this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;
          this._ownUtilityLayer = true;
        }
        if (size) {
          this._constraintAxesSize = 0.4 * size;
          this._constraintAngularSize = 0.4 * size;
        }
      }
      /**
       * Updates the debug meshes of the physics engine.
       *
       * This code is useful for synchronizing the debug meshes of the physics engine with the physics impostor and mesh.
       * It checks if the impostor is disposed and if the plugin version is 1, then it syncs the mesh with the impostor.
       * This ensures that the debug meshes are up to date with the physics engine.
       */
      _updateDebugMeshes() {
        const plugin = this._physicsEnginePlugin;
        if (plugin?.getPluginVersion() === 1) {
          this._updateDebugMeshesV1();
        } else {
          this._updateDebugMeshesV2();
        }
      }
      /**
       * Updates the debug meshes of the physics engine.
       *
       * This method is useful for synchronizing the debug meshes with the physics impostors.
       * It iterates through the impostors and meshes, and if the plugin version is 1, it syncs the mesh with the impostor.
       * This ensures that the debug meshes accurately reflect the physics impostors, which is important for debugging the physics engine.
       */
      _updateDebugMeshesV1() {
        const plugin = this._physicsEnginePlugin;
        for (let i = 0; i < this._numMeshes; i++) {
          const impostor = this._impostors[i];
          if (!impostor) {
            continue;
          }
          if (impostor.isDisposed) {
            this.hideImpostor(this._impostors[i--]);
          } else {
            if (impostor.type === PhysicsImpostor.MeshImpostor) {
              continue;
            }
            const mesh = this._meshes[i];
            if (mesh && plugin) {
              plugin.syncMeshWithImpostor(mesh, impostor);
            }
          }
        }
      }
      /**
       * Updates the debug meshes of the physics engine for V2 plugin.
       *
       * This method is useful for synchronizing the debug meshes of the physics engine with the current state of the bodies.
       * It iterates through the bodies array and updates the debug meshes with the current transform of each body.
       * This ensures that the debug meshes accurately reflect the current state of the physics engine.
       */
      _updateDebugMeshesV2() {
        const plugin = this._physicsEnginePlugin;
        for (let i = 0; i < this._numBodies; ) {
          const body = this._bodies[i];
          if (body && body.isDisposed && this.hideBody(body)) {
            continue;
          }
          const transform = this._bodyMeshes[i];
          if (body && transform) {
            plugin.syncTransform(body, transform);
          }
          i++;
        }
      }
      _updateInertiaMeshes() {
        for (let i = 0; i < this._numInertiaBodies; ) {
          const body = this._inertiaBodies[i];
          if (body && body.isDisposed && this.hideInertia(body)) {
            continue;
          }
          const mesh = this._inertiaMeshes[i];
          if (body && mesh) {
            this._updateDebugInertia(body, mesh);
          }
          i++;
        }
      }
      _updateDebugInertia(body, inertiaMesh) {
        const inertiaMatrixRef = Matrix.Identity();
        const transformMatrixRef = Matrix.Identity();
        const finalMatrixRef = Matrix.Identity();
        if (body._pluginDataInstances.length) {
          const inertiaAsMesh = inertiaMesh;
          const inertiaMeshMatrixData = inertiaAsMesh._thinInstanceDataStorage.matrixData;
          const bodyTransformMatrixData = body.transformNode._thinInstanceDataStorage.matrixData;
          for (let i = 0; i < body._pluginDataInstances.length; i++) {
            const props = body.getMassProperties(i);
            this._getMeshDebugInertiaMatrixToRef(props, inertiaMatrixRef);
            Matrix.FromArrayToRef(bodyTransformMatrixData, i * 16, transformMatrixRef);
            inertiaMatrixRef.multiplyToRef(transformMatrixRef, finalMatrixRef);
            finalMatrixRef.copyToArray(inertiaMeshMatrixData, i * 16);
          }
          inertiaAsMesh.thinInstanceBufferUpdated("matrix");
        } else {
          const props = body.getMassProperties();
          this._getMeshDebugInertiaMatrixToRef(props, inertiaMatrixRef);
          body.transformNode.rotationQuaternion?.toRotationMatrix(transformMatrixRef);
          transformMatrixRef.setTranslation(body.transformNode.position);
          if (body.transformNode.parent) {
            const parentTransform = body.transformNode.parent.computeWorldMatrix(true);
            transformMatrixRef.multiplyToRef(parentTransform, transformMatrixRef);
          }
          inertiaMatrixRef.multiplyToRef(transformMatrixRef, inertiaMatrixRef);
          inertiaMatrixRef.decomposeToTransformNode(inertiaMesh);
        }
      }
      _updateDebugConstraints() {
        for (let i = 0; i < this._numConstraints; i++) {
          const constraint = this._constraints[i];
          const mesh = this._constraintMeshes[i];
          if (constraint && mesh) {
            this._updateDebugConstraint(constraint, mesh[0]);
          }
        }
      }
      /**
       * Given a scaling vector, make all of its components
       * 1, preserving the sign
       * @param scaling
       */
      _makeScalingUnitInPlace(scaling) {
        if (Math.abs(scaling.x - 1) > Epsilon) {
          scaling.x = 1 * Math.sign(scaling.x);
        }
        if (Math.abs(scaling.y - 1) > Epsilon) {
          scaling.y = 1 * Math.sign(scaling.y);
        }
        if (Math.abs(scaling.z - 1) > Epsilon) {
          scaling.z = 1 * Math.sign(scaling.z);
        }
      }
      _updateDebugConstraint(constraint, parentingMesh) {
        if (!constraint._initOptions) {
          return;
        }
        const { pivotA, pivotB, axisA, axisB, perpAxisA, perpAxisB } = constraint._initOptions;
        if (!pivotA || !pivotB || !axisA || !axisB || !perpAxisA || !perpAxisB) {
          return;
        }
        const descendants = parentingMesh.getDescendants(true);
        for (const parentConstraintMesh of descendants) {
          const parentCoordSystemNode = parentConstraintMesh.getDescendants(true)[0];
          const childCoordSystemNode = parentConstraintMesh.getDescendants(true)[1];
          const { parentBody, parentBodyIndex } = parentCoordSystemNode.metadata;
          const { childBody, childBodyIndex } = childCoordSystemNode.metadata;
          const parentTransform = this._getTransformFromBodyToRef(parentBody, TmpVectors.Matrix[0], parentBodyIndex);
          const childTransform = this._getTransformFromBodyToRef(childBody, TmpVectors.Matrix[1], childBodyIndex);
          parentTransform.decomposeToTransformNode(parentCoordSystemNode);
          this._makeScalingUnitInPlace(parentCoordSystemNode.scaling);
          childTransform.decomposeToTransformNode(childCoordSystemNode);
          this._makeScalingUnitInPlace(childCoordSystemNode.scaling);
          const parentTransformNode = parentCoordSystemNode.getDescendants(true)[0];
          parentTransformNode.position.copyFrom(pivotA);
          const childTransformNode = childCoordSystemNode.getDescendants(true)[0];
          childTransformNode.position.copyFrom(pivotB);
          Quaternion.FromRotationMatrixToRef(Matrix.FromXYZAxesToRef(axisA, perpAxisA, Vector3.CrossToRef(axisA, perpAxisA, TmpVectors.Vector3[0]), TmpVectors.Matrix[0]), parentTransformNode.rotationQuaternion);
          Quaternion.FromRotationMatrixToRef(Matrix.FromXYZAxesToRef(axisB, perpAxisB, Vector3.CrossToRef(axisB, perpAxisB, TmpVectors.Vector3[1]), TmpVectors.Matrix[1]), childTransformNode.rotationQuaternion);
        }
      }
      /**
       * Renders a specified physic impostor
       * @param impostor defines the impostor to render
       * @param targetMesh defines the mesh represented by the impostor
       * @returns the new debug mesh used to render the impostor
       */
      showImpostor(impostor, targetMesh) {
        if (!this._scene) {
          return null;
        }
        for (let i = 0; i < this._numMeshes; i++) {
          if (this._impostors[i] == impostor) {
            return null;
          }
        }
        const debugMesh = this._getDebugMesh(impostor, targetMesh);
        if (debugMesh) {
          this._impostors[this._numMeshes] = impostor;
          this._meshes[this._numMeshes] = debugMesh;
          if (this._numMeshes === 0) {
            this._renderFunction = () => this._updateDebugMeshes();
            this._scene.registerBeforeRender(this._renderFunction);
          }
          this._numMeshes++;
        }
        return debugMesh;
      }
      /**
       * Shows a debug mesh for a given physics body.
       * @param body The physics body to show.
       * @returns The debug mesh, or null if the body is already shown.
       *
       * This function is useful for visualizing the physics body in the scene.
       * It creates a debug mesh for the given body and adds it to the scene.
       * It also registers a before render function to update the debug mesh position and rotation.
       */
      showBody(body) {
        if (!this._scene) {
          return null;
        }
        for (let i = 0; i < this._numBodies; i++) {
          if (this._bodies[i] == body) {
            return null;
          }
        }
        const debugMesh = this._getDebugBodyMesh(body);
        if (debugMesh) {
          this._bodies[this._numBodies] = body;
          this._bodyMeshes[this._numBodies] = debugMesh;
          if (this._numBodies === 0) {
            this._renderFunction = () => this._updateDebugMeshes();
            this._scene.registerBeforeRender(this._renderFunction);
          }
          this._numBodies++;
        }
        return debugMesh;
      }
      /**
       * Shows a debug box corresponding to the inertia of a given body
       * @param body the physics body used to get the inertia
       * @returns the debug mesh used to show the inertia, or null if the body is already shown
       */
      showInertia(body) {
        if (!this._scene) {
          return null;
        }
        for (let i = 0; i < this._numInertiaBodies; i++) {
          if (this._inertiaBodies[i] == body) {
            return null;
          }
        }
        const debugMesh = this._getDebugInertiaMesh(body);
        if (debugMesh) {
          this._inertiaBodies[this._numInertiaBodies] = body;
          this._inertiaMeshes[this._numInertiaBodies] = debugMesh;
          if (this._numInertiaBodies === 0) {
            this._inertiaRenderFunction = () => this._updateInertiaMeshes();
            this._scene.registerBeforeRender(this._inertiaRenderFunction);
          }
          this._numInertiaBodies++;
        }
        return debugMesh;
      }
      /**
       * Shows a debug mesh for a given physics constraint.
       * @param constraint the physics constraint to show
       * @returns the debug mesh, or null if the constraint is already shown
       */
      showConstraint(constraint) {
        if (!this._scene) {
          return null;
        }
        for (let i = 0; i < this._numConstraints; i++) {
          if (this._constraints[i] == constraint) {
            return null;
          }
        }
        const debugMesh = this._getDebugConstraintMesh(constraint);
        if (debugMesh) {
          this._constraints[this._numConstraints] = constraint;
          this._constraintMeshes[this._numConstraints] = debugMesh;
          if (this._numConstraints === 0) {
            this._constraintRenderFunction = () => this._updateDebugConstraints();
            this._scene.registerBeforeRender(this._constraintRenderFunction);
          }
          this._numConstraints++;
        }
        return debugMesh ? debugMesh[0] : null;
      }
      /**
       * Hides an impostor from the scene.
       * @param impostor - The impostor to hide.
       *
       * This method is useful for hiding an impostor from the scene. It removes the
       * impostor from the utility layer scene, disposes the mesh, and removes the
       * impostor from the list of impostors. If the impostor is the last one in the
       * list, it also unregisters the render function.
       */
      hideImpostor(impostor) {
        if (!impostor || !this._scene || !this._utilityLayer) {
          return;
        }
        let removed = false;
        const utilityLayerScene = this._utilityLayer.utilityLayerScene;
        for (let i = 0; i < this._numMeshes; i++) {
          if (this._impostors[i] == impostor) {
            const mesh = this._meshes[i];
            if (!mesh) {
              continue;
            }
            utilityLayerScene.removeMesh(mesh);
            mesh.dispose();
            const index = this._debugMeshMeshes.indexOf(mesh);
            if (index > -1) {
              this._debugMeshMeshes.splice(index, 1);
            }
            this._numMeshes--;
            if (this._numMeshes > 0) {
              this._meshes[i] = this._meshes[this._numMeshes];
              this._impostors[i] = this._impostors[this._numMeshes];
              this._meshes[this._numMeshes] = null;
              this._impostors[this._numMeshes] = null;
            } else {
              this._meshes[0] = null;
              this._impostors[0] = null;
            }
            removed = true;
            break;
          }
        }
        if (removed && this._numMeshes === 0) {
          this._scene.unregisterBeforeRender(this._renderFunction);
        }
      }
      /**
       * Hides a body from the physics engine.
       * @param body - The body to hide.
       * @returns true if body actually removed
       *
       * This function is useful for hiding a body from the physics engine.
       * It removes the body from the utility layer scene and disposes the mesh associated with it.
       * It also unregisters the render function if the number of bodies is 0.
       * This is useful for hiding a body from the physics engine without deleting it.
       */
      hideBody(body) {
        if (!body || !this._scene || !this._utilityLayer) {
          return false;
        }
        let removed = false;
        const utilityLayerScene = this._utilityLayer.utilityLayerScene;
        for (let i = 0; i < this._numBodies; i++) {
          if (this._bodies[i] === body) {
            const mesh = this._bodyMeshes[i];
            if (!mesh) {
              continue;
            }
            utilityLayerScene.removeMesh(mesh);
            mesh.dispose();
            this._numBodies--;
            if (this._numBodies > 0) {
              this._bodyMeshes[i] = this._bodyMeshes[this._numBodies];
              this._bodies[i] = this._bodies[this._numBodies];
              this._bodyMeshes[this._numBodies] = null;
              this._bodies[this._numBodies] = null;
            } else {
              this._bodyMeshes[0] = null;
              this._bodies[0] = null;
            }
            removed = true;
            break;
          }
        }
        if (removed && this._numBodies === 0) {
          this._scene.unregisterBeforeRender(this._renderFunction);
        }
        return removed;
      }
      /**
       * Hides a body's inertia from the viewer utility layer
       * @param body the body to hide
       * @returns true if inertia actually removed
       */
      hideInertia(body) {
        if (!body || !this._scene || !this._utilityLayer) {
          return false;
        }
        let removed = false;
        const utilityLayerScene = this._utilityLayer.utilityLayerScene;
        for (let i = 0; i < this._numInertiaBodies; i++) {
          if (this._inertiaBodies[i] === body) {
            const mesh = this._inertiaMeshes[i];
            if (!mesh) {
              continue;
            }
            utilityLayerScene.removeMesh(mesh);
            mesh.dispose();
            this._inertiaBodies.splice(i, 1);
            this._inertiaMeshes.splice(i, 1);
            this._numInertiaBodies--;
            removed = true;
            break;
          }
        }
        if (removed && this._numInertiaBodies === 0) {
          this._scene.unregisterBeforeRender(this._inertiaRenderFunction);
        }
        return removed;
      }
      /**
       * Hide a physics constraint from the viewer utility layer
       * @param constraint the constraint to hide
       */
      hideConstraint(constraint) {
        if (!constraint || !this._scene || !this._utilityLayer) {
          return;
        }
        let removed = false;
        const utilityLayerScene = this._utilityLayer.utilityLayerScene;
        for (let i = 0; i < this._numConstraints; i++) {
          if (this._constraints[i] === constraint) {
            const meshes = this._constraintMeshes[i];
            if (!meshes) {
              continue;
            }
            for (const mesh of meshes) {
              utilityLayerScene.removeMesh(mesh);
              mesh.dispose();
            }
            this._constraints.splice(i, 1);
            this._constraintMeshes.splice(i, 1);
            this._numConstraints--;
            if (this._numConstraints > 0) {
              this._constraints[i] = this._constraints[this._numConstraints];
              this._constraintMeshes[i] = this._constraintMeshes[this._numConstraints];
              this._constraints[this._numConstraints] = null;
              this._constraintMeshes[this._numConstraints] = null;
            } else {
              this._constraints[0] = null;
              this._constraintMeshes[0] = null;
            }
            removed = true;
            break;
          }
        }
        if (removed && this._numConstraints === 0) {
          this._scene.unregisterBeforeRender(this._constraintRenderFunction);
        }
      }
      _getDebugMaterial(scene) {
        if (!this._debugMaterial) {
          this._debugMaterial = new StandardMaterial("", scene);
          this._debugMaterial.wireframe = true;
          this._debugMaterial.emissiveColor = Color3.White();
          this._debugMaterial.disableLighting = true;
        }
        return this._debugMaterial;
      }
      _getDebugInertiaMaterial(scene) {
        if (!this._debugInertiaMaterial) {
          this._debugInertiaMaterial = new StandardMaterial("", scene);
          this._debugInertiaMaterial.disableLighting = true;
          this._debugInertiaMaterial.alpha = 0;
        }
        return this._debugInertiaMaterial;
      }
      _getDebugAxisColoredMaterial(axisNumber, scene) {
        const material = new StandardMaterial("", scene);
        material.emissiveColor = axisNumber == 0 ? Color3.Red() : axisNumber == 1 ? Color3.Green() : Color3.Blue();
        material.disableLighting = true;
        return material;
      }
      _getDebugBoxMesh(scene) {
        if (!this._debugBoxMesh) {
          this._debugBoxMesh = CreateBox("physicsBodyBoxViewMesh", { size: 1 }, scene);
          this._debugBoxMesh.rotationQuaternion = Quaternion.Identity();
          this._debugBoxMesh.material = this._getDebugMaterial(scene);
          this._debugBoxMesh.setEnabled(false);
        }
        return this._debugBoxMesh.createInstance("physicsBodyBoxViewInstance");
      }
      _getDebugSphereMesh(scene) {
        if (!this._debugSphereMesh) {
          this._debugSphereMesh = CreateSphere("physicsBodySphereViewMesh", { diameter: 1 }, scene);
          this._debugSphereMesh.rotationQuaternion = Quaternion.Identity();
          this._debugSphereMesh.material = this._getDebugMaterial(scene);
          this._debugSphereMesh.setEnabled(false);
        }
        return this._debugSphereMesh.createInstance("physicsBodySphereViewInstance");
      }
      _getDebugCapsuleMesh(scene) {
        if (!this._debugCapsuleMesh) {
          this._debugCapsuleMesh = CreateCapsule("physicsBodyCapsuleViewMesh", { height: 1 }, scene);
          this._debugCapsuleMesh.rotationQuaternion = Quaternion.Identity();
          this._debugCapsuleMesh.material = this._getDebugMaterial(scene);
          this._debugCapsuleMesh.setEnabled(false);
        }
        return this._debugCapsuleMesh.createInstance("physicsBodyCapsuleViewInstance");
      }
      _getDebugCylinderMesh(scene) {
        if (!this._debugCylinderMesh) {
          this._debugCylinderMesh = CreateCylinder("physicsBodyCylinderViewMesh", { diameterTop: 1, diameterBottom: 1, height: 1 }, scene);
          this._debugCylinderMesh.rotationQuaternion = Quaternion.Identity();
          this._debugCylinderMesh.material = this._getDebugMaterial(scene);
          this._debugCylinderMesh.setEnabled(false);
        }
        return this._debugCylinderMesh.createInstance("physicsBodyCylinderViewInstance");
      }
      _getDebugMeshMesh(mesh, scene) {
        const wireframeOver = new Mesh(mesh.name, scene, null, mesh);
        wireframeOver.setParent(mesh);
        wireframeOver.position = Vector3.Zero();
        wireframeOver.material = this._getDebugMaterial(scene);
        this._debugMeshMeshes.push(wireframeOver);
        return wireframeOver;
      }
      _getDebugMesh(impostor, targetMesh) {
        if (!this._utilityLayer) {
          return null;
        }
        if (targetMesh && targetMesh.parent && targetMesh.parent.physicsImpostor) {
          return null;
        }
        let mesh = null;
        const utilityLayerScene = this._utilityLayer.utilityLayerScene;
        if (!impostor.physicsBody) {
          Logger.Warn("Unable to get physicsBody of impostor. It might be initialized later by its parent's impostor.");
          return null;
        }
        switch (impostor.type) {
          case PhysicsImpostor.BoxImpostor:
            mesh = this._getDebugBoxMesh(utilityLayerScene);
            impostor.getBoxSizeToRef(mesh.scaling);
            break;
          case PhysicsImpostor.SphereImpostor: {
            mesh = this._getDebugSphereMesh(utilityLayerScene);
            const radius = impostor.getRadius();
            mesh.scaling.x = radius * 2;
            mesh.scaling.y = radius * 2;
            mesh.scaling.z = radius * 2;
            break;
          }
          case PhysicsImpostor.CapsuleImpostor: {
            mesh = this._getDebugCapsuleMesh(utilityLayerScene);
            const bi = impostor.object.getBoundingInfo();
            mesh.scaling.x = (bi.boundingBox.maximum.x - bi.boundingBox.minimum.x) * 2 * impostor.object.scaling.x;
            mesh.scaling.y = (bi.boundingBox.maximum.y - bi.boundingBox.minimum.y) * impostor.object.scaling.y;
            mesh.scaling.z = (bi.boundingBox.maximum.z - bi.boundingBox.minimum.z) * 2 * impostor.object.scaling.z;
            break;
          }
          case PhysicsImpostor.MeshImpostor:
            if (targetMesh) {
              mesh = this._getDebugMeshMesh(targetMesh, utilityLayerScene);
            }
            break;
          case PhysicsImpostor.NoImpostor:
            if (targetMesh) {
              const childMeshes = targetMesh.getChildMeshes().filter((c) => {
                return c.physicsImpostor ? 1 : 0;
              });
              for (const m of childMeshes) {
                if (m.physicsImpostor && m.getClassName() === "Mesh") {
                  const boundingInfo = m.getBoundingInfo();
                  const min = boundingInfo.boundingBox.minimum;
                  const max = boundingInfo.boundingBox.maximum;
                  switch (m.physicsImpostor.type) {
                    case PhysicsImpostor.BoxImpostor:
                      mesh = this._getDebugBoxMesh(utilityLayerScene);
                      mesh.position.copyFrom(min);
                      mesh.position.addInPlace(max);
                      mesh.position.scaleInPlace(0.5);
                      break;
                    case PhysicsImpostor.SphereImpostor:
                      mesh = this._getDebugSphereMesh(utilityLayerScene);
                      break;
                    case PhysicsImpostor.CylinderImpostor:
                      mesh = this._getDebugCylinderMesh(utilityLayerScene);
                      break;
                    default:
                      mesh = null;
                      break;
                  }
                  if (mesh) {
                    mesh.scaling.x = max.x - min.x;
                    mesh.scaling.y = max.y - min.y;
                    mesh.scaling.z = max.z - min.z;
                    mesh.parent = m;
                  }
                }
              }
            } else {
              Logger.Warn("No target mesh parameter provided for NoImpostor. Skipping.");
            }
            mesh = null;
            break;
          case PhysicsImpostor.CylinderImpostor: {
            mesh = this._getDebugCylinderMesh(utilityLayerScene);
            const bi = impostor.object.getBoundingInfo();
            mesh.scaling.x = (bi.boundingBox.maximum.x - bi.boundingBox.minimum.x) * impostor.object.scaling.x;
            mesh.scaling.y = (bi.boundingBox.maximum.y - bi.boundingBox.minimum.y) * impostor.object.scaling.y;
            mesh.scaling.z = (bi.boundingBox.maximum.z - bi.boundingBox.minimum.z) * impostor.object.scaling.z;
            break;
          }
        }
        return mesh;
      }
      /**
       * Creates a debug mesh for a given physics body
       * @param body The physics body to create the debug mesh for
       * @returns The created debug mesh or null if the utility layer is not available
       *
       * This code is useful for creating a debug mesh for a given physics body.
       * It creates a Mesh object with a VertexData object containing the positions and indices
       * of the geometry of the body. The mesh is then assigned a debug material from the utility layer scene.
       * This allows for visualizing the physics body in the scene.
       */
      _getDebugBodyMesh(body) {
        if (!this._utilityLayer) {
          return null;
        }
        const utilityLayerScene = this._utilityLayer.utilityLayerScene;
        const mesh = new Mesh("custom", utilityLayerScene);
        const vertexData = new VertexData();
        const geometry = body.getGeometry();
        vertexData.positions = geometry.positions;
        vertexData.indices = geometry.indices;
        vertexData.applyToMesh(mesh);
        if (body._pluginDataInstances) {
          const instanceBuffer = new Float32Array(body._pluginDataInstances.length * 16);
          mesh.thinInstanceSetBuffer("matrix", instanceBuffer, 16, false);
        }
        mesh.material = this._getDebugMaterial(utilityLayerScene);
        return mesh;
      }
      _getMeshDebugInertiaMatrixToRef(massProps, matrix) {
        const orientation = massProps.inertiaOrientation ?? Quaternion.Identity();
        const inertiaLocal = massProps.inertia ?? Vector3.Zero();
        const center = massProps.centerOfMass ?? Vector3.Zero();
        const betaSqrd = (inertiaLocal.x - inertiaLocal.y + inertiaLocal.z) * 6;
        const beta = Math.sqrt(Math.max(betaSqrd, 0));
        const gammaSqrd = inertiaLocal.x * 12 - betaSqrd;
        const gamma = Math.sqrt(Math.max(gammaSqrd, 0));
        const alphaSqrd = inertiaLocal.z * 12 - betaSqrd;
        const alpha = Math.sqrt(Math.max(alphaSqrd, 0));
        const extents = TmpVectors.Vector3[0];
        extents.set(alpha, beta, gamma);
        const scaling = Matrix.ScalingToRef(extents.x, extents.y, extents.z, TmpVectors.Matrix[0]);
        const rotation = orientation.toRotationMatrix(TmpVectors.Matrix[1]);
        const translation = Matrix.TranslationToRef(center.x, center.y, center.z, TmpVectors.Matrix[2]);
        scaling.multiplyToRef(rotation, matrix);
        matrix.multiplyToRef(translation, matrix);
        return matrix;
      }
      _getDebugInertiaMesh(body) {
        if (!this._utilityLayer) {
          return null;
        }
        const utilityLayerScene = this._utilityLayer.utilityLayerScene;
        const inertiaBoxMesh = MeshBuilder.CreateBox("custom", { size: 1 }, utilityLayerScene);
        const matrixRef = Matrix.Identity();
        if (body._pluginDataInstances.length) {
          const instanceBuffer = new Float32Array(body._pluginDataInstances.length * 16);
          for (let i = 0; i < body._pluginDataInstances.length; ++i) {
            const props = body.getMassProperties(i);
            this._getMeshDebugInertiaMatrixToRef(props, matrixRef);
            matrixRef.copyToArray(instanceBuffer, i * 16);
          }
          inertiaBoxMesh.thinInstanceSetBuffer("matrix", instanceBuffer, 16, false);
        } else {
          const props = body.getMassProperties();
          this._getMeshDebugInertiaMatrixToRef(props, matrixRef);
          matrixRef.decomposeToTransformNode(inertiaBoxMesh);
        }
        inertiaBoxMesh.enableEdgesRendering();
        inertiaBoxMesh.edgesWidth = 2;
        inertiaBoxMesh.edgesColor = new Color4(1, 0, 1, 1);
        inertiaBoxMesh.material = this._getDebugInertiaMaterial(utilityLayerScene);
        return inertiaBoxMesh;
      }
      _getTransformFromBodyToRef(body, matrix, instanceIndex) {
        const tnode = body.transformNode;
        if (instanceIndex && instanceIndex >= 0) {
          return Matrix.FromArrayToRef(tnode._thinInstanceDataStorage.matrixData, instanceIndex, matrix);
        } else {
          return matrix.copyFrom(tnode.getWorldMatrix());
        }
      }
      _createAngularConstraintMesh(minLimit, maxLimit, axisNumber, parent, scene) {
        const arcAngle = (maxLimit - minLimit) / (Math.PI * 2);
        const mesh = MeshBuilder.CreateCylinder("ConstraintCylinder", { height: 1e-4, diameter: 3 * this._constraintAngularSize, arc: arcAngle }, scene);
        mesh.material = this._getDebugAxisColoredMaterial(axisNumber, scene);
        mesh.parent = parent;
        const parentScaling = parent.absoluteScaling;
        switch (axisNumber) {
          case 0:
            mesh.rotation.z = Math.PI * 0.5;
            mesh.rotation.x = -minLimit + Math.PI * 0.5;
            mesh.scaling.x = 1 / parentScaling.x;
            mesh.scaling.y = 1 / parentScaling.z;
            mesh.scaling.z = 1 / parentScaling.y;
            break;
          case 1:
            mesh.rotation.y = Math.PI * 1.5 + minLimit;
            mesh.scaling.x = 1 / parentScaling.z;
            mesh.scaling.y = 1 / parentScaling.y;
            mesh.scaling.z = 1 / parentScaling.x;
            break;
          case 2:
            mesh.rotation.x = Math.PI * 0.5;
            mesh.scaling.x = 1 / parentScaling.x;
            mesh.scaling.y = 1 / parentScaling.z;
            mesh.scaling.z = 1 / parentScaling.y;
            break;
        }
        return mesh;
      }
      _createCage(parent, scene) {
        const cage = MeshBuilder.CreateBox("cage", { size: 1 }, scene);
        cage.setPivotPoint(new Vector3(-0.5, -0.5, -0.5));
        const transparentMaterial = new StandardMaterial("cage_material", scene);
        transparentMaterial.alpha = 0;
        cage.material = transparentMaterial;
        cage.enableEdgesRendering();
        cage.edgesWidth = 4;
        cage.edgesColor = new Color4(1, 1, 1, 1);
        cage.parent = parent;
        return cage;
      }
      _getDebugConstraintMesh(constraint) {
        if (!this._utilityLayer) {
          return null;
        }
        const utilityLayerScene = this._utilityLayer.utilityLayerScene;
        if (!constraint._initOptions) {
          return null;
        }
        const { pivotA, pivotB, axisA, axisB, perpAxisA, perpAxisB } = constraint._initOptions;
        if (!pivotA || !pivotB || !axisA || !axisB || !perpAxisA || !perpAxisB) {
          return null;
        }
        const parentingMesh = new Mesh("parentingDebugConstraint", utilityLayerScene);
        const bodiesUsingConstraint = constraint.getBodiesUsingConstraint();
        const parentedConstraintMeshes = [];
        parentedConstraintMeshes.push(parentingMesh);
        for (const bodyPairInfo of bodiesUsingConstraint) {
          const parentOfPair = new TransformNode("parentOfPair", utilityLayerScene);
          parentOfPair.parent = parentingMesh;
          const { parentBody, parentBodyIndex, childBody, childBodyIndex } = bodyPairInfo;
          const parentTransform = this._getTransformFromBodyToRef(parentBody, TmpVectors.Matrix[0], parentBodyIndex);
          const childTransform = this._getTransformFromBodyToRef(childBody, TmpVectors.Matrix[1], childBodyIndex);
          const parentCoordSystemNode = new TransformNode("parentCoordSystem", utilityLayerScene);
          parentCoordSystemNode.parent = parentOfPair;
          parentCoordSystemNode.metadata = { parentBody, parentBodyIndex };
          parentTransform.decomposeToTransformNode(parentCoordSystemNode);
          const childCoordSystemNode = new TransformNode("childCoordSystem", utilityLayerScene);
          childCoordSystemNode.parent = parentOfPair;
          childCoordSystemNode.metadata = { childBody, childBodyIndex };
          childTransform.decomposeToTransformNode(childCoordSystemNode);
          const rotTransformParent = Quaternion.FromRotationMatrix(Matrix.FromXYZAxesToRef(axisA, perpAxisA, axisA.cross(perpAxisA), TmpVectors.Matrix[0]));
          const rotTransformChild = Quaternion.FromRotationMatrix(Matrix.FromXYZAxesToRef(axisB, perpAxisB, axisB.cross(perpAxisB), TmpVectors.Matrix[0]));
          const translateTransformParent = pivotA;
          const translateTransformChild = pivotB;
          const parentTransformNode = new TransformNode("constraint_parent", utilityLayerScene);
          parentTransformNode.position.copyFrom(translateTransformParent);
          parentTransformNode.rotationQuaternion = rotTransformParent;
          parentTransformNode.parent = parentCoordSystemNode;
          const childTransformNode = new TransformNode("constraint_child", utilityLayerScene);
          childTransformNode.parent = childCoordSystemNode;
          childTransformNode.position.copyFrom(translateTransformChild);
          childTransformNode.rotationQuaternion = rotTransformChild;
          const parentAxes = new AxesViewer(utilityLayerScene, this._constraintAxesSize);
          parentAxes.xAxis.parent = parentTransformNode;
          parentAxes.yAxis.parent = parentTransformNode;
          parentAxes.zAxis.parent = parentTransformNode;
          const childAxes = new AxesViewer(utilityLayerScene, this._constraintAxesSize);
          childAxes.xAxis.parent = childTransformNode;
          childAxes.yAxis.parent = childTransformNode;
          childAxes.zAxis.parent = childTransformNode;
          const engine = this._physicsEnginePlugin;
          const constraintAxisAngular = [
            3,
            4,
            5
            /* PhysicsConstraintAxis.ANGULAR_Z */
          ];
          const constraintAxisLinear = [
            0,
            1,
            2
            /* PhysicsConstraintAxis.LINEAR_Z */
          ];
          const constraintAxis = [constraintAxisAngular, constraintAxisLinear];
          const lockCount = [0, 0];
          for (let angularLinear = 0; angularLinear < 2; angularLinear++) {
            for (let axis = 0; axis < 3; axis++) {
              const constraintAxisValue = constraintAxis[angularLinear][axis];
              const axisMode = engine.getAxisMode(constraint, constraintAxisValue);
              if (axisMode == 2) {
                lockCount[angularLinear]++;
              }
            }
          }
          if (lockCount[1] != 3) {
            const cage = this._createCage(parentTransformNode, utilityLayerScene);
            const min = TmpVectors.Vector3[0];
            const max = TmpVectors.Vector3[1];
            const limited = [false, false, false];
            limited[0] = engine.getAxisMode(
              constraint,
              0
              /* PhysicsConstraintAxis.LINEAR_X */
            ) == 1;
            limited[1] = engine.getAxisMode(
              constraint,
              1
              /* PhysicsConstraintAxis.LINEAR_Y */
            ) == 1;
            limited[2] = engine.getAxisMode(
              constraint,
              2
              /* PhysicsConstraintAxis.LINEAR_Z */
            ) == 1;
            min.x = limited[0] ? engine.getAxisMinLimit(
              constraint,
              0
              /* PhysicsConstraintAxis.LINEAR_X */
            ) : 0;
            max.x = limited[0] ? engine.getAxisMaxLimit(
              constraint,
              0
              /* PhysicsConstraintAxis.LINEAR_X */
            ) : 0;
            min.y = limited[1] ? engine.getAxisMinLimit(
              constraint,
              1
              /* PhysicsConstraintAxis.LINEAR_Y */
            ) : 0;
            max.y = limited[1] ? engine.getAxisMaxLimit(
              constraint,
              1
              /* PhysicsConstraintAxis.LINEAR_Y */
            ) : 0;
            min.z = limited[2] ? engine.getAxisMinLimit(
              constraint,
              2
              /* PhysicsConstraintAxis.LINEAR_Z */
            ) : 0;
            max.z = limited[2] ? engine.getAxisMaxLimit(
              constraint,
              2
              /* PhysicsConstraintAxis.LINEAR_Z */
            ) : 0;
            cage.position.x = min.x + 0.5;
            cage.position.y = min.y + 0.5;
            cage.position.z = min.z + 0.5;
            cage.scaling.x = max.x - min.x + Epsilon;
            cage.scaling.y = max.y - min.y + Epsilon;
            cage.scaling.z = max.z - min.z + Epsilon;
            parentedConstraintMeshes.push(cage);
          }
          if (lockCount[0] != 3) {
            for (let axisIndex = 0; axisIndex < 3; axisIndex++) {
              const axis = constraintAxisAngular[axisIndex];
              const axisMode = engine.getAxisMode(constraint, axis);
              let minLimit = 0;
              let maxLimit = Math.PI * 2;
              if (axisMode == 1) {
                minLimit = engine.getAxisMinLimit(constraint, axis);
                maxLimit = engine.getAxisMaxLimit(constraint, axis);
              }
              if (axisMode != 2 && constraint.options.pivotB) {
                const mesh = this._createAngularConstraintMesh(minLimit, maxLimit, axisIndex, childBody.transformNode, utilityLayerScene);
                mesh.position.copyFrom(constraint.options.pivotB);
                parentedConstraintMeshes.push(mesh);
              }
            }
          }
        }
        return parentedConstraintMeshes;
      }
      /**
       * Clean up physics debug display
       */
      dispose() {
        for (let index = this._numMeshes - 1; index >= 0; index--) {
          this.hideImpostor(this._impostors[0]);
        }
        for (let index = this._numBodies - 1; index >= 0; index--) {
          this.hideBody(this._bodies[0]);
        }
        for (let index = this._numInertiaBodies - 1; index >= 0; index--) {
          this.hideInertia(this._inertiaBodies[0]);
        }
        if (this._debugBoxMesh) {
          this._debugBoxMesh.dispose();
        }
        if (this._debugSphereMesh) {
          this._debugSphereMesh.dispose();
        }
        if (this._debugCylinderMesh) {
          this._debugCylinderMesh.dispose();
        }
        if (this._debugMaterial) {
          this._debugMaterial.dispose();
        }
        this._impostors.length = 0;
        this._scene = null;
        this._physicsEnginePlugin = null;
        if (this._ownUtilityLayer && this._utilityLayer) {
          this._utilityLayer.dispose();
          this._utilityLayer = null;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Debug/skeletonViewer.js
var SkeletonViewer;
var init_skeletonViewer = __esm({
  "node_modules/@babylonjs/core/Debug/skeletonViewer.js"() {
    init_math_vector();
    init_math_color();
    init_mesh();
    init_linesBuilder();
    init_utilityLayerRenderer();
    init_material();
    init_shaderMaterial();
    init_dynamicTexture();
    init_buffer();
    init_effect();
    init_sphereBuilder();
    init_shapeBuilder();
    init_transformNode();
    init_logger();
    SkeletonViewer = class _SkeletonViewer {
      /** public static method to create a BoneWeight Shader
       * @param options The constructor options
       * @param scene The scene that the shader is scoped to
       * @returns The created ShaderMaterial
       * @see http://www.babylonjs-playground.com/#1BZJVJ#395
       */
      static CreateBoneWeightShader(options, scene) {
        const skeleton = options.skeleton;
        const colorBase = options.colorBase ?? Color3.Black();
        const colorZero = options.colorZero ?? Color3.Blue();
        const colorQuarter = options.colorQuarter ?? Color3.Green();
        const colorHalf = options.colorHalf ?? Color3.Yellow();
        const colorFull = options.colorFull ?? Color3.Red();
        const targetBoneIndex = options.targetBoneIndex ?? 0;
        Effect.ShadersStore["boneWeights:" + skeleton.name + "VertexShader"] = `precision highp float;

        attribute vec3 position;
        attribute vec2 uv;

        uniform mat4 view;
        uniform mat4 projection;
        uniform mat4 worldViewProjection;

        #include<bonesDeclaration>
        #if NUM_BONE_INFLUENCERS == 0
            attribute vec4 matricesIndices;
            attribute vec4 matricesWeights;
        #endif
        #include<bakedVertexAnimationDeclaration>

        #include<instancesDeclaration>

        varying vec3 vColor;

        uniform vec3 colorBase;
        uniform vec3 colorZero;
        uniform vec3 colorQuarter;
        uniform vec3 colorHalf;
        uniform vec3 colorFull;

        uniform float targetBoneIndex;

        void main() {
            vec3 positionUpdated = position;

            #include<instancesVertex>
            #include<bonesVertex>
            #include<bakedVertexAnimation>

            vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);

            vec3 color = colorBase;
            float totalWeight = 0.;
            if(matricesIndices[0] == targetBoneIndex && matricesWeights[0] > 0.){
                totalWeight += matricesWeights[0];
            }
            if(matricesIndices[1] == targetBoneIndex && matricesWeights[1] > 0.){
                totalWeight += matricesWeights[1];
            }
            if(matricesIndices[2] == targetBoneIndex && matricesWeights[2] > 0.){
                totalWeight += matricesWeights[2];
            }
            if(matricesIndices[3] == targetBoneIndex && matricesWeights[3] > 0.){
                totalWeight += matricesWeights[3];
            }

            color = mix(color, colorZero, smoothstep(0., 0.25, totalWeight));
            color = mix(color, colorQuarter, smoothstep(0.25, 0.5, totalWeight));
            color = mix(color, colorHalf, smoothstep(0.5, 0.75, totalWeight));
            color = mix(color, colorFull, smoothstep(0.75, 1.0, totalWeight));
            vColor = color;

        gl_Position = projection * view * worldPos;
        }`;
        Effect.ShadersStore["boneWeights:" + skeleton.name + "FragmentShader"] = `
            precision highp float;
            varying vec3 vPosition;

            varying vec3 vColor;

            void main() {
                vec4 color = vec4(vColor, 1.0);
                gl_FragColor = color;
            }
        `;
        const shader13 = new ShaderMaterial("boneWeight:" + skeleton.name, scene, {
          vertex: "boneWeights:" + skeleton.name,
          fragment: "boneWeights:" + skeleton.name
        }, {
          attributes: ["position", "normal", "matricesIndices", "matricesWeights"],
          uniforms: [
            "world",
            "worldView",
            "worldViewProjection",
            "view",
            "projection",
            "viewProjection",
            "colorBase",
            "colorZero",
            "colorQuarter",
            "colorHalf",
            "colorFull",
            "targetBoneIndex"
          ]
        });
        shader13.setColor3("colorBase", colorBase);
        shader13.setColor3("colorZero", colorZero);
        shader13.setColor3("colorQuarter", colorQuarter);
        shader13.setColor3("colorHalf", colorHalf);
        shader13.setColor3("colorFull", colorFull);
        shader13.setFloat("targetBoneIndex", targetBoneIndex);
        shader13.getClassName = () => {
          return "BoneWeightShader";
        };
        shader13.transparencyMode = Material.MATERIAL_OPAQUE;
        return shader13;
      }
      /** public static method to create a BoneWeight Shader
       * @param options The constructor options
       * @param scene The scene that the shader is scoped to
       * @returns The created ShaderMaterial
       */
      static CreateSkeletonMapShader(options, scene) {
        const skeleton = options.skeleton;
        const colorMap = options.colorMap ?? [
          {
            color: new Color3(1, 0.38, 0.18),
            location: 0
          },
          {
            color: new Color3(0.59, 0.18, 1),
            location: 0.2
          },
          {
            color: new Color3(0.59, 1, 0.18),
            location: 0.4
          },
          {
            color: new Color3(1, 0.87, 0.17),
            location: 0.6
          },
          {
            color: new Color3(1, 0.17, 0.42),
            location: 0.8
          },
          {
            color: new Color3(0.17, 0.68, 1),
            location: 1
          }
        ];
        const bufferWidth = skeleton.bones.length + 1;
        const colorMapBuffer = _SkeletonViewer._CreateBoneMapColorBuffer(bufferWidth, colorMap, scene);
        const shader13 = new ShaderMaterial("boneWeights:" + skeleton.name, scene, {
          vertexSource: `precision highp float;

            attribute vec3 position;
            attribute vec2 uv;

            uniform mat4 view;
            uniform mat4 projection;
            uniform mat4 worldViewProjection;
            uniform float colorMap[` + skeleton.bones.length * 4 + `];

            #include<bonesDeclaration>
            #if NUM_BONE_INFLUENCERS == 0
                attribute vec4 matricesIndices;
                attribute vec4 matricesWeights;
            #endif
            #include<bakedVertexAnimationDeclaration>
            #include<instancesDeclaration>

            varying vec3 vColor;

            void main() {
                vec3 positionUpdated = position;

                #include<instancesVertex>
                #include<bonesVertex>
                #include<bakedVertexAnimation>

                vec3 color = vec3(0.);
                bool first = true;

                for (int i = 0; i < 4; i++) {
                    int boneIdx = int(matricesIndices[i]);
                    float boneWgt = matricesWeights[i];

                    vec3 c = vec3(colorMap[boneIdx * 4 + 0], colorMap[boneIdx * 4 + 1], colorMap[boneIdx * 4 + 2]);

                    if (boneWgt > 0.) {
                        if (first) {
                            first = false;
                            color = c;
                        } else {
                            color = mix(color, c, boneWgt);
                        }
                    }
                }

                vColor = color;

                vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);

                gl_Position = projection * view * worldPos;
            }`,
          fragmentSource: `
            precision highp float;
            varying vec3 vColor;

            void main() {
                vec4 color = vec4( vColor, 1.0 );
                gl_FragColor = color;
            }
            `
        }, {
          attributes: ["position", "normal", "matricesIndices", "matricesWeights"],
          uniforms: ["world", "worldView", "worldViewProjection", "view", "projection", "viewProjection", "colorMap"]
        });
        shader13.setFloats("colorMap", colorMapBuffer);
        shader13.getClassName = () => {
          return "SkeletonMapShader";
        };
        shader13.transparencyMode = Material.MATERIAL_OPAQUE;
        return shader13;
      }
      /** private static method to create a BoneWeight Shader
       * @param size The size of the buffer to create (usually the bone count)
       * @param colorMap The gradient data to generate
       * @param scene The scene that the shader is scoped to
       * @returns an Array of floats from the color gradient values
       */
      static _CreateBoneMapColorBuffer(size, colorMap, scene) {
        const tempGrad = new DynamicTexture("temp", { width: size, height: 1 }, scene, false);
        const ctx = tempGrad.getContext();
        const grad = ctx.createLinearGradient(0, 0, size, 0);
        for (const stop of colorMap) {
          grad.addColorStop(stop.location, stop.color.toHexString());
        }
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, size, 1);
        tempGrad.update();
        const buffer = [];
        const data = ctx.getImageData(0, 0, size, 1).data;
        const rUnit = 1 / 255;
        for (let i = 0; i < data.length; i++) {
          buffer.push(data[i] * rUnit);
        }
        tempGrad.dispose();
        return buffer;
      }
      /** Gets the Scene. */
      get scene() {
        return this._scene;
      }
      /** Gets the utilityLayer. */
      get utilityLayer() {
        return this._utilityLayer;
      }
      /** Checks Ready Status. */
      get isReady() {
        return this._ready;
      }
      /** Sets Ready Status. */
      set ready(value) {
        this._ready = value;
      }
      /** Gets the debugMesh */
      get debugMesh() {
        return this._debugMesh;
      }
      /** Sets the debugMesh */
      set debugMesh(value) {
        this._debugMesh = value;
      }
      /** Gets the displayMode */
      get displayMode() {
        return this.options.displayMode || _SkeletonViewer.DISPLAY_LINES;
      }
      /** Sets the displayMode */
      set displayMode(value) {
        if (value > _SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {
          value = _SkeletonViewer.DISPLAY_LINES;
        }
        this.options.displayMode = value;
      }
      /**
       * Creates a new SkeletonViewer
       * @param skeleton defines the skeleton to render
       * @param mesh defines the mesh attached to the skeleton
       * @param scene defines the hosting scene
       * @param autoUpdateBonesMatrices defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)
       * @param renderingGroupId defines the rendering group id to use with the viewer
       * @param options All of the extra constructor options for the SkeletonViewer
       */
      constructor(skeleton, mesh, scene, autoUpdateBonesMatrices = true, renderingGroupId = 3, options = {}) {
        this.skeleton = skeleton;
        this.mesh = mesh;
        this.autoUpdateBonesMatrices = autoUpdateBonesMatrices;
        this.renderingGroupId = renderingGroupId;
        this.options = options;
        this.color = Color3.White();
        this._debugLines = new Array();
        this._localAxes = null;
        this._isEnabled = true;
        this._obs = null;
        this._scene = scene;
        this._ready = false;
        options.pauseAnimations = options.pauseAnimations ?? true;
        options.returnToRest = options.returnToRest ?? false;
        options.displayMode = options.displayMode ?? _SkeletonViewer.DISPLAY_LINES;
        options.displayOptions = options.displayOptions ?? {};
        options.displayOptions.midStep = options.displayOptions.midStep ?? 0.235;
        options.displayOptions.midStepFactor = options.displayOptions.midStepFactor ?? 0.155;
        options.displayOptions.sphereBaseSize = options.displayOptions.sphereBaseSize ?? 0.15;
        options.displayOptions.sphereScaleUnit = options.displayOptions.sphereScaleUnit ?? 2;
        options.displayOptions.sphereFactor = options.displayOptions.sphereFactor ?? 0.865;
        options.displayOptions.spurFollowsChild = options.displayOptions.spurFollowsChild ?? false;
        options.displayOptions.showLocalAxes = options.displayOptions.showLocalAxes ?? false;
        options.displayOptions.localAxesSize = options.displayOptions.localAxesSize ?? 0.075;
        options.computeBonesUsingShaders = options.computeBonesUsingShaders ?? true;
        options.useAllBones = options.useAllBones ?? true;
        this._boneIndices = /* @__PURE__ */ new Set();
        if (!options.useAllBones) {
          const initialMeshBoneIndices = mesh?.getVerticesData(VertexBuffer.MatricesIndicesKind);
          const initialMeshBoneWeights = mesh?.getVerticesData(VertexBuffer.MatricesWeightsKind);
          if (initialMeshBoneIndices && initialMeshBoneWeights) {
            for (let i = 0; i < initialMeshBoneIndices.length; ++i) {
              const index = initialMeshBoneIndices[i], weight = initialMeshBoneWeights[i];
              if (weight !== 0) {
                this._boneIndices.add(index);
              }
            }
          }
        }
        this._utilityLayer = new UtilityLayerRenderer(this._scene, false);
        this._utilityLayer.pickUtilitySceneFirst = false;
        this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;
        let displayMode = this.options.displayMode || 0;
        if (displayMode > _SkeletonViewer.DISPLAY_SPHERE_AND_SPURS) {
          displayMode = _SkeletonViewer.DISPLAY_LINES;
        }
        this.displayMode = displayMode;
        this.update();
        this._bindObs();
      }
      /** The Dynamic bindings for the update functions */
      _bindObs() {
        switch (this.displayMode) {
          case _SkeletonViewer.DISPLAY_LINES: {
            this._obs = this.scene.onBeforeRenderObservable.add(() => {
              this._displayLinesUpdate();
            });
            break;
          }
        }
      }
      /** Update the viewer to sync with current skeleton state, only used to manually update. */
      update() {
        switch (this.displayMode) {
          case _SkeletonViewer.DISPLAY_LINES: {
            this._displayLinesUpdate();
            break;
          }
          case _SkeletonViewer.DISPLAY_SPHERES: {
            this._buildSpheresAndSpurs(true);
            break;
          }
          case _SkeletonViewer.DISPLAY_SPHERE_AND_SPURS: {
            this._buildSpheresAndSpurs(false);
            break;
          }
        }
        this._buildLocalAxes();
      }
      /** Gets or sets a boolean indicating if the viewer is enabled */
      set isEnabled(value) {
        if (this.isEnabled === value) {
          return;
        }
        this._isEnabled = value;
        if (this.debugMesh) {
          this.debugMesh.setEnabled(value);
        }
        if (value && !this._obs) {
          this._bindObs();
        } else if (!value && this._obs) {
          this.scene.onBeforeRenderObservable.remove(this._obs);
          this._obs = null;
        }
      }
      get isEnabled() {
        return this._isEnabled;
      }
      _getBonePosition(position, bone, meshMat, x = 0, y = 0, z = 0) {
        const tmat = TmpVectors.Matrix[0];
        const parentBone = bone.getParent();
        tmat.copyFrom(bone.getLocalMatrix());
        if (x !== 0 || y !== 0 || z !== 0) {
          const tmat2 = TmpVectors.Matrix[1];
          Matrix.IdentityToRef(tmat2);
          tmat2.setTranslationFromFloats(x, y, z);
          tmat2.multiplyToRef(tmat, tmat);
        }
        if (parentBone) {
          tmat.multiplyToRef(parentBone.getAbsoluteMatrix(), tmat);
        }
        tmat.multiplyToRef(meshMat, tmat);
        position.x = tmat.m[12];
        position.y = tmat.m[13];
        position.z = tmat.m[14];
      }
      _getLinesForBonesWithLength(bones, mesh) {
        const len = bones.length;
        let matrix;
        let meshPos;
        if (mesh) {
          matrix = mesh.getWorldMatrix();
          meshPos = mesh.position;
        } else {
          matrix = new Matrix();
          meshPos = bones[0].position;
        }
        let idx = 0;
        for (let i = 0; i < len; i++) {
          const bone = bones[i];
          let points = this._debugLines[idx];
          if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {
            continue;
          }
          if (!points) {
            points = [Vector3.Zero(), Vector3.Zero()];
            this._debugLines[idx] = points;
          }
          this._getBonePosition(points[0], bone, matrix);
          this._getBonePosition(points[1], bone, matrix, 0, bone.length, 0);
          points[0].subtractInPlace(meshPos);
          points[1].subtractInPlace(meshPos);
          idx++;
        }
      }
      _getLinesForBonesNoLength(bones) {
        const len = bones.length;
        let boneNum = 0;
        const mesh = this.mesh;
        let transformNode;
        let meshPos;
        if (mesh) {
          transformNode = mesh;
          meshPos = mesh.position;
        } else {
          transformNode = new TransformNode("");
          meshPos = bones[0].position;
        }
        for (let i = len - 1; i >= 0; i--) {
          const childBone = bones[i];
          const parentBone = childBone.getParent();
          if (!parentBone || !this._boneIndices.has(childBone.getIndex()) && !this.options.useAllBones) {
            continue;
          }
          let points = this._debugLines[boneNum];
          if (!points) {
            points = [Vector3.Zero(), Vector3.Zero()];
            this._debugLines[boneNum] = points;
          }
          childBone.getAbsolutePositionToRef(transformNode, points[0]);
          parentBone.getAbsolutePositionToRef(transformNode, points[1]);
          points[0].subtractInPlace(meshPos);
          points[1].subtractInPlace(meshPos);
          boneNum++;
        }
        if (!mesh) {
          transformNode.dispose();
        }
      }
      /**
       * function to revert the mesh and scene back to the initial state.
       * @param animationState
       */
      _revert(animationState) {
        if (this.options.pauseAnimations) {
          this.scene.animationsEnabled = animationState;
          this.utilityLayer.utilityLayerScene.animationsEnabled = animationState;
        }
      }
      /**
       * function to get the absolute bind pose of a bone by accumulating transformations up the bone hierarchy.
       * @param bone
       * @param matrix
       */
      _getAbsoluteBindPoseToRef(bone, matrix) {
        if (bone === null || bone._index === -1) {
          matrix.copyFrom(Matrix.Identity());
          return;
        }
        this._getAbsoluteBindPoseToRef(bone.getParent(), matrix);
        bone.getBindMatrix().multiplyToRef(matrix, matrix);
        return;
      }
      _createSpur(anchorPoint, bone, childPoint, childBone, displayOptions, utilityLayerScene) {
        const dir = childPoint.subtract(anchorPoint);
        const h = dir.length();
        const up = dir.normalize().scale(h);
        const midStep = displayOptions.midStep || 0.165;
        const midStepFactor = displayOptions.midStepFactor || 0.215;
        const up0 = up.scale(midStep);
        const spur = ExtrudeShapeCustom("skeletonViewer", {
          shape: [new Vector3(1, -1, 0), new Vector3(1, 1, 0), new Vector3(-1, 1, 0), new Vector3(-1, -1, 0), new Vector3(1, -1, 0)],
          path: [Vector3.Zero(), up0, up],
          scaleFunction: (i) => {
            switch (i) {
              case 0:
              case 2:
                return 0;
              case 1:
                return h * midStepFactor;
            }
            return 0;
          },
          sideOrientation: Mesh.DEFAULTSIDE,
          updatable: false
        }, utilityLayerScene);
        const numVertices = spur.getTotalVertices();
        const mwk = [], mik = [];
        for (let i = 0; i < numVertices; i++) {
          mwk.push(1, 0, 0, 0);
          if (childBone && displayOptions.spurFollowsChild && i > 9) {
            mik.push(childBone.getIndex(), 0, 0, 0);
          } else {
            mik.push(bone.getIndex(), 0, 0, 0);
          }
        }
        spur.position = anchorPoint.clone();
        spur.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);
        spur.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);
        spur.convertToFlatShadedMesh();
        return spur;
      }
      _getBoundingSphereForBone(boneIndex) {
        if (!this.mesh) {
          return null;
        }
        const positions = this.mesh.getVerticesData(VertexBuffer.PositionKind);
        const indices = this.mesh.getIndices();
        const boneWeights = this.mesh.getVerticesData(VertexBuffer.MatricesWeightsKind);
        const boneIndices = this.mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);
        if (!positions || !indices || !boneWeights || !boneIndices) {
          return null;
        }
        const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        let found = 0;
        for (let i = 0; i < indices.length; ++i) {
          const vertexIndex = indices[i];
          for (let b = 0; b < 4; ++b) {
            const bIndex = boneIndices[vertexIndex * 4 + b];
            const bWeight = boneWeights[vertexIndex * 4 + b];
            if (bIndex === boneIndex && bWeight > 1e-5) {
              Vector3.FromArrayToRef(positions, vertexIndex * 3, TmpVectors.Vector3[0]);
              min.minimizeInPlace(TmpVectors.Vector3[0]);
              max.maximizeInPlace(TmpVectors.Vector3[0]);
              found++;
              break;
            }
          }
        }
        return found > 1 ? {
          center: Vector3.Center(min, max),
          radius: Vector3.Distance(min, max) / 2
        } : null;
      }
      /**
       * function to build and bind sphere joint points and spur bone representations.
       * @param spheresOnly
       */
      _buildSpheresAndSpurs(spheresOnly = true) {
        if (this._debugMesh) {
          this._debugMesh.dispose();
          this._debugMesh = null;
          this.ready = false;
        }
        this._ready = false;
        const utilityLayerScene = this.utilityLayer?.utilityLayerScene;
        const bones = this.skeleton.bones;
        const spheres = [];
        const spurs = [];
        const animationState = this.scene.animationsEnabled;
        try {
          if (this.options.pauseAnimations) {
            this.scene.animationsEnabled = false;
            utilityLayerScene.animationsEnabled = false;
          }
          if (this.options.returnToRest) {
            this.skeleton.returnToRest();
          }
          if (this.autoUpdateBonesMatrices) {
            this.skeleton.computeAbsoluteMatrices();
          }
          let longestBoneLength = Number.NEGATIVE_INFINITY;
          const displayOptions = this.options.displayOptions || {};
          for (let i = 0; i < bones.length; i++) {
            const bone = bones[i];
            if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {
              continue;
            }
            const boneAbsoluteBindPoseTransform = new Matrix();
            this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);
            const anchorPoint = new Vector3();
            boneAbsoluteBindPoseTransform.decompose(void 0, void 0, anchorPoint);
            if (bone.children.length > 0) {
              for (const bc of bone.children) {
                const childAbsoluteBindPoseTransform = new Matrix();
                bc.getLocalMatrix().multiplyToRef(boneAbsoluteBindPoseTransform, childAbsoluteBindPoseTransform);
                const childPoint = new Vector3();
                childAbsoluteBindPoseTransform.decompose(void 0, void 0, childPoint);
                const distanceFromParent = Vector3.Distance(anchorPoint, childPoint);
                if (distanceFromParent > longestBoneLength) {
                  longestBoneLength = distanceFromParent;
                }
                if (spheresOnly) {
                  return;
                }
                spurs.push(this._createSpur(anchorPoint, bone, childPoint, bc, displayOptions, utilityLayerScene));
              }
            } else {
              const boundingSphere = this._getBoundingSphereForBone(bone.getIndex());
              if (boundingSphere) {
                if (boundingSphere.radius > longestBoneLength) {
                  longestBoneLength = boundingSphere.radius;
                }
                if (!spheresOnly) {
                  let childPoint;
                  const parentBone = bone.getParent();
                  if (parentBone) {
                    this._getAbsoluteBindPoseToRef(parentBone, boneAbsoluteBindPoseTransform);
                    boneAbsoluteBindPoseTransform.decompose(void 0, void 0, TmpVectors.Vector3[0]);
                    childPoint = anchorPoint.subtract(TmpVectors.Vector3[0]).normalize().scale(boundingSphere.radius).add(anchorPoint);
                  } else {
                    childPoint = boundingSphere.center.subtract(anchorPoint).normalize().scale(boundingSphere.radius).add(anchorPoint);
                  }
                  spurs.push(this._createSpur(anchorPoint, bone, childPoint, null, displayOptions, utilityLayerScene));
                }
              }
            }
            const sphereBaseSize = displayOptions.sphereBaseSize || 0.2;
            const sphere = CreateSphere("skeletonViewer", {
              segments: 6,
              diameter: sphereBaseSize,
              updatable: true
            }, utilityLayerScene);
            const numVertices = sphere.getTotalVertices();
            const mwk = [], mik = [];
            for (let i2 = 0; i2 < numVertices; i2++) {
              mwk.push(1, 0, 0, 0);
              mik.push(bone.getIndex(), 0, 0, 0);
            }
            sphere.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);
            sphere.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);
            sphere.position = anchorPoint.clone();
            spheres.push([sphere, bone]);
          }
          const sphereScaleUnit = displayOptions.sphereScaleUnit || 2;
          const sphereFactor = displayOptions.sphereFactor || 0.85;
          const meshes = [];
          for (let i = 0; i < spheres.length; i++) {
            const [sphere, bone] = spheres[i];
            const scale = 1 / (sphereScaleUnit / longestBoneLength);
            let _stepsOut = 0;
            let _b = bone;
            while (_b.getParent() && _b.getParent().getIndex() !== -1) {
              _stepsOut++;
              _b = _b.getParent();
            }
            sphere.scaling.scaleInPlace(scale * Math.pow(sphereFactor, _stepsOut));
            meshes.push(sphere);
          }
          this.debugMesh = Mesh.MergeMeshes(meshes.concat(spurs), true, true);
          if (this.debugMesh) {
            this.debugMesh.renderingGroupId = this.renderingGroupId;
            this.debugMesh.skeleton = this.skeleton;
            this.debugMesh.parent = this.mesh;
            this.debugMesh.computeBonesUsingShaders = this.options.computeBonesUsingShaders ?? true;
            this.debugMesh.alwaysSelectAsActiveMesh = true;
          }
          const light = this.utilityLayer._getSharedGizmoLight();
          light.intensity = 0.7;
          this._revert(animationState);
          this.ready = true;
        } catch (err) {
          Logger.Error(err);
          this._revert(animationState);
          this.dispose();
        }
      }
      _buildLocalAxes() {
        if (this._localAxes) {
          this._localAxes.dispose();
        }
        this._localAxes = null;
        const displayOptions = this.options.displayOptions || {};
        if (!displayOptions.showLocalAxes) {
          return;
        }
        const targetScene = this._utilityLayer.utilityLayerScene;
        const size = displayOptions.localAxesSize || 0.075;
        const lines = [];
        const colors = [];
        const red = new Color4(1, 0, 0, 1);
        const green = new Color4(0, 1, 0, 1);
        const blue = new Color4(0, 0, 1, 1);
        const mwk = [];
        const mik = [];
        const vertsPerBone = 6;
        for (const i in this.skeleton.bones) {
          const bone = this.skeleton.bones[i];
          if (bone._index === -1 || !this._boneIndices.has(bone.getIndex()) && !this.options.useAllBones) {
            continue;
          }
          const boneAbsoluteBindPoseTransform = new Matrix();
          const boneOrigin = new Vector3();
          this._getAbsoluteBindPoseToRef(bone, boneAbsoluteBindPoseTransform);
          boneAbsoluteBindPoseTransform.decompose(void 0, TmpVectors.Quaternion[0], boneOrigin);
          const m = new Matrix();
          TmpVectors.Quaternion[0].toRotationMatrix(m);
          const boneAxisX = Vector3.TransformCoordinates(new Vector3(0 + size, 0, 0), m);
          const boneAxisY = Vector3.TransformCoordinates(new Vector3(0, 0 + size, 0), m);
          const boneAxisZ = Vector3.TransformCoordinates(new Vector3(0, 0, 0 + size), m);
          const axisX = [boneOrigin, boneOrigin.add(boneAxisX)];
          const axisY = [boneOrigin, boneOrigin.add(boneAxisY)];
          const axisZ = [boneOrigin, boneOrigin.add(boneAxisZ)];
          const linePoints = [axisX, axisY, axisZ];
          const lineColors = [
            [red, red],
            [green, green],
            [blue, blue]
          ];
          lines.push(...linePoints);
          colors.push(...lineColors);
          for (let j = 0; j < vertsPerBone; j++) {
            mwk.push(1, 0, 0, 0);
            mik.push(bone.getIndex(), 0, 0, 0);
          }
        }
        this._localAxes = CreateLineSystem("localAxes", { lines, colors, updatable: true }, targetScene);
        this._localAxes.setVerticesData(VertexBuffer.MatricesWeightsKind, mwk, false);
        this._localAxes.setVerticesData(VertexBuffer.MatricesIndicesKind, mik, false);
        this._localAxes.skeleton = this.skeleton;
        this._localAxes.renderingGroupId = this.renderingGroupId + 1;
        this._localAxes.parent = this.mesh;
        this._localAxes.computeBonesUsingShaders = this.options.computeBonesUsingShaders ?? true;
      }
      /** Update the viewer to sync with current skeleton state, only used for the line display. */
      _displayLinesUpdate() {
        if (!this._utilityLayer) {
          return;
        }
        if (this.autoUpdateBonesMatrices) {
          this.skeleton.computeAbsoluteMatrices();
        }
        if (this.skeleton.bones[0].length === void 0) {
          this._getLinesForBonesNoLength(this.skeleton.bones);
        } else {
          this._getLinesForBonesWithLength(this.skeleton.bones, this.mesh);
        }
        const targetScene = this._utilityLayer.utilityLayerScene;
        if (targetScene) {
          if (!this._debugMesh) {
            this._debugMesh = CreateLineSystem("", { lines: this._debugLines, updatable: true, instance: null }, targetScene);
            this._debugMesh.renderingGroupId = this.renderingGroupId;
          } else {
            CreateLineSystem("", { lines: this._debugLines, updatable: true, instance: this._debugMesh }, targetScene);
          }
          if (this.mesh) {
            this._debugMesh.position.copyFrom(this.mesh.position);
          } else {
            this._debugMesh.position.copyFrom(this.skeleton.bones[0].position);
          }
          this._debugMesh.color = this.color;
        }
      }
      /** Changes the displayMode of the skeleton viewer
       * @param mode The displayMode numerical value
       */
      changeDisplayMode(mode) {
        const wasEnabled = this.isEnabled ? true : false;
        if (this.displayMode !== mode) {
          this.isEnabled = false;
          if (this._debugMesh) {
            this._debugMesh.dispose();
            this._debugMesh = null;
            this.ready = false;
          }
          this.displayMode = mode;
          this.update();
          this._bindObs();
          this.isEnabled = wasEnabled;
        }
      }
      /** Sets a display option of the skeleton viewer
       *
       * | Option           | Type    | Default | Description |
       * | ---------------- | ------- | ------- | ----------- |
       * | midStep          | float   | 0.235   | A percentage between a bone and its child that determines the widest part of a spur. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |
       * | midStepFactor    | float   | 0.15    | Mid step width expressed as a factor of the length. A value of 0.5 makes the spur width half of the spur length. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |
       * | sphereBaseSize   | float   | 2       | Sphere base size. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |
       * | sphereScaleUnit  | float   | 0.865   | Sphere scale factor used to scale spheres in relation to the longest bone. Only used when `displayMode` is set to `DISPLAY_SPHERE_AND_SPURS`. |
       * | spurFollowsChild | boolean | false   | Whether a spur should attach its far end to the child bone. |
       * | showLocalAxes    | boolean | false   | Displays local axes on all bones. |
       * | localAxesSize    | float   | 0.075   | Determines the length of each local axis. |
       *
       * @param option String of the option name
       * @param value The numerical option value
       */
      changeDisplayOptions(option, value) {
        const wasEnabled = this.isEnabled ? true : false;
        this.options.displayOptions[option] = value;
        this.isEnabled = false;
        if (this._debugMesh) {
          this._debugMesh.dispose();
          this._debugMesh = null;
          this.ready = false;
        }
        this.update();
        this._bindObs();
        this.isEnabled = wasEnabled;
      }
      /** Release associated resources */
      dispose() {
        this.isEnabled = false;
        if (this._debugMesh) {
          this._debugMesh.dispose();
          this._debugMesh = null;
        }
        if (this._utilityLayer) {
          this._utilityLayer.dispose();
          this._utilityLayer = null;
        }
        this.ready = false;
      }
    };
    SkeletonViewer.DISPLAY_LINES = 0;
    SkeletonViewer.DISPLAY_SPHERES = 1;
    SkeletonViewer.DISPLAY_SPHERE_AND_SPURS = 2;
  }
});

// node_modules/@babylonjs/core/FrameGraph/frameGraphTypes.js
var backbufferColorTextureHandle, backbufferDepthStencilTextureHandle;
var init_frameGraphTypes = __esm({
  "node_modules/@babylonjs/core/FrameGraph/frameGraphTypes.js"() {
    backbufferColorTextureHandle = 0;
    backbufferDepthStencilTextureHandle = 1;
  }
});

// node_modules/@babylonjs/core/FrameGraph/Passes/pass.js
var FrameGraphPass;
var init_pass = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Passes/pass.js"() {
    FrameGraphPass = class {
      /** @internal */
      constructor(name13, _parentTask, _context) {
        this.name = name13;
        this._parentTask = _parentTask;
        this._context = _context;
        this.disabled = false;
      }
      /**
       * Initializes the pass.
       * This function is called once after the frame graph has been built
       * @param func The function to initialize the pass.
       */
      setInitializeFunc(func) {
        this._initFunc = func;
      }
      /**
       * Sets the function to execute when the pass is executed
       * @param func The function to execute when the pass is executed
       */
      setExecuteFunc(func) {
        this._executeFunc = func;
      }
      /** @internal */
      _execute() {
        if (!this.disabled) {
          this._executeFunc(this._context);
        }
      }
      /** @internal */
      _initialize() {
        this._initFunc?.(this._context);
      }
      /** @internal */
      _isValid() {
        return this._executeFunc !== void 0 ? null : "Execute function is not set (call setExecuteFunc to set it)";
      }
      /** @internal */
      _dispose() {
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/Passes/objectListPass.js
var FrameGraphObjectListPass;
var init_objectListPass = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Passes/objectListPass.js"() {
    init_pass();
    FrameGraphObjectListPass = class extends FrameGraphPass {
      /**
       * Checks if a pass is an object list pass.
       * @param pass The pass to check.
       * @returns True if the pass is an object list pass, else false.
       */
      static IsObjectListPass(pass) {
        return pass.setObjectList !== void 0;
      }
      /**
       * Gets the object list used by the pass.
       */
      get objectList() {
        return this._objectList;
      }
      /**
       * Sets the object list to use for the pass.
       * @param objectList The object list to use for the pass.
       */
      setObjectList(objectList) {
        this._objectList = objectList;
      }
      /** @internal */
      constructor(name13, parentTask, context, engine) {
        super(name13, parentTask, context);
        this._engine = engine;
      }
      /** @internal */
      _isValid() {
        const errMsg = super._isValid();
        return errMsg ? errMsg : this._objectList !== void 0 ? null : "Object list is not set (call setObjectList to set it)";
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/Passes/renderPass.js
var FrameGraphRenderPass;
var init_renderPass = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Passes/renderPass.js"() {
    init_pass();
    FrameGraphRenderPass = class extends FrameGraphPass {
      /**
       * Checks if a pass is a render pass.
       * @param pass The pass to check.
       * @returns True if the pass is a render pass, else false.
       */
      static IsRenderPass(pass) {
        return pass.setRenderTarget !== void 0;
      }
      /**
       * Gets the handle(s) of the render target(s) used by the render pass.
       */
      get renderTarget() {
        return this._renderTarget;
      }
      /**
       * Gets the handle of the render target depth used by the render pass.
       */
      get renderTargetDepth() {
        return this._renderTargetDepth;
      }
      /**
       * Gets the frame graph render target used by the render pass.
       */
      get frameGraphRenderTarget() {
        return this._frameGraphRenderTarget;
      }
      /** @internal */
      constructor(name13, parentTask, context, engine) {
        super(name13, parentTask, context);
        this._dependencies = /* @__PURE__ */ new Set();
        this.depthReadOnly = false;
        this.stencilReadOnly = false;
        this._engine = engine;
      }
      /**
       * Sets the render target(s) to use for rendering.
       * @param renderTargetHandle The render target to use for rendering, or an array of render targets to use for multi render target rendering.
       */
      setRenderTarget(renderTargetHandle) {
        this._renderTarget = renderTargetHandle;
      }
      /**
       * Sets the render target depth to use for rendering.
       * @param renderTargetHandle The render target depth to use for rendering.
       */
      setRenderTargetDepth(renderTargetHandle) {
        this._renderTargetDepth = renderTargetHandle;
      }
      /**
       * Adds dependencies to the render pass.
       * @param dependencies The dependencies to add.
       */
      addDependencies(dependencies) {
        if (dependencies === void 0) {
          return;
        }
        if (Array.isArray(dependencies)) {
          for (const dependency of dependencies) {
            this._dependencies.add(dependency);
          }
        } else {
          this._dependencies.add(dependencies);
        }
      }
      /**
       * Collects the dependencies of the render pass.
       * @param dependencies The set of dependencies to update.
       */
      collectDependencies(dependencies) {
        const iterator = this._dependencies.keys();
        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
          dependencies.add(key.value);
        }
        if (this._renderTarget !== void 0) {
          if (Array.isArray(this._renderTarget)) {
            for (const handle of this._renderTarget) {
              if (handle !== void 0) {
                dependencies.add(handle);
              }
            }
          } else {
            dependencies.add(this._renderTarget);
          }
        }
        if (this._renderTargetDepth !== void 0) {
          dependencies.add(this._renderTargetDepth);
        }
      }
      /**
       * Sets the output layer and face indices for multi-render target rendering.
       * @param indices The array of layer and face indices.
       */
      setOutputLayerAndFaceIndices(indices) {
        const renderTargetWrapper = this.frameGraphRenderTarget.renderTargetWrapper;
        if (renderTargetWrapper) {
          for (const index of indices) {
            renderTargetWrapper.setLayerAndFaceIndex(index.targetIndex, index.layerIndex, index.faceIndex);
          }
        }
      }
      /** @internal */
      _initialize() {
        this._frameGraphRenderTarget = this._context.createRenderTarget(this.name, this._renderTarget, this._renderTargetDepth, this.depthReadOnly, this.stencilReadOnly);
        super._initialize();
      }
      /** @internal */
      _execute() {
        const currentDebugMarkers = this._context.enableDebugMarkers;
        this._context.enableDebugMarkers = !this._parentTask._disableDebugMarkers;
        this._context.bindRenderTarget(this._frameGraphRenderTarget);
        super._execute();
        this._context.restoreDefaultFramebuffer();
        this._context.enableDebugMarkers = currentDebugMarkers;
      }
      /** @internal */
      _isValid() {
        const errMsg = super._isValid();
        return errMsg ? errMsg : this._renderTarget !== void 0 || this.renderTargetDepth !== void 0 ? null : "Render target and render target depth cannot both be undefined.";
      }
      /** @internal */
      _dispose() {
        this._frameGraphRenderTarget?.dispose();
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/frameGraphTask.js
var FrameGraphTask;
var init_frameGraphTask = __esm({
  "node_modules/@babylonjs/core/FrameGraph/frameGraphTask.js"() {
    init_objectListPass();
    init_renderPass();
    init_observable();
    FrameGraphTask = class {
      /**
       * The name of the task.
       */
      get name() {
        return this._name;
      }
      set name(value) {
        this._name = value;
      }
      /**
       * Whether the task is disabled.
       */
      get disabled() {
        return this._disabled;
      }
      set disabled(value) {
        this._disabled = value;
      }
      /**
       * Gets the passes of the task.
       */
      get passes() {
        return this._passes;
      }
      /**
       * Gets the disabled passes of the task.
       */
      get passesDisabled() {
        return this._passesDisabled;
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "FrameGraphTask";
      }
      /**
       * This function is called once after the task has been added to the frame graph and before the frame graph is built for the first time.
       * This allows you to initialize asynchronous resources, which is not possible in the constructor.
       * @returns A promise that resolves when the initialization is complete.
       */
      // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
      initAsync() {
        return Promise.resolve();
      }
      /**
       * Checks if the task is ready to be executed.
       * @returns True if the task is ready to be executed, else false.
       */
      isReady() {
        return true;
      }
      /**
       * Disposes of the task.
       */
      dispose() {
        this._reset();
        this.onTexturesAllocatedObservable.clear();
        this.onBeforeTaskExecute.clear();
        this.onAfterTaskExecute.clear();
      }
      /**
       * Constructs a new frame graph task.
       * @param name The name of the task.
       * @param frameGraph The frame graph this task is associated with.
       */
      constructor(name13, frameGraph) {
        this._passes = [];
        this._passesDisabled = [];
        this._disabled = false;
        this._disableDebugMarkers = false;
        this.onTexturesAllocatedObservable = new Observable();
        this.onBeforeTaskExecute = new Observable();
        this.onAfterTaskExecute = new Observable();
        this.name = name13;
        this._frameGraph = frameGraph;
        this._reset();
      }
      /** @internal */
      _reset() {
        for (const pass of this._passes) {
          pass._dispose();
        }
        for (const pass of this._passesDisabled) {
          pass._dispose();
        }
        this._passes.length = 0;
        this._passesDisabled.length = 0;
      }
      /** @internal */
      _addPass(pass, disabled) {
        if (disabled) {
          this._passesDisabled.push(pass);
        } else {
          this._passes.push(pass);
        }
      }
      /** @internal */
      _checkTask() {
        let outputTexture = null;
        let outputDepthTexture = null;
        let outputObjectList;
        for (const pass of this._passes) {
          const errMsg = pass._isValid();
          if (errMsg) {
            throw new Error(`Pass "${pass.name}" is not valid. ${errMsg}`);
          }
          if (FrameGraphRenderPass.IsRenderPass(pass)) {
            const handles = Array.isArray(pass.renderTarget) ? pass.renderTarget : [pass.renderTarget];
            outputTexture = [];
            for (const handle of handles) {
              if (handle !== void 0) {
                outputTexture.push(this._frameGraph.textureManager.getTextureFromHandle(handle));
              }
            }
            outputDepthTexture = pass.renderTargetDepth !== void 0 ? this._frameGraph.textureManager.getTextureFromHandle(pass.renderTargetDepth) : null;
          } else if (FrameGraphObjectListPass.IsObjectListPass(pass)) {
            outputObjectList = pass.objectList;
          }
        }
        let disabledOutputTexture = null;
        let disabledOutputTextureHandle = [];
        let disabledOutputDepthTexture = null;
        let disabledOutputObjectList;
        for (const pass of this._passesDisabled) {
          const errMsg = pass._isValid();
          if (errMsg) {
            throw new Error(`Pass "${pass.name}" is not valid. ${errMsg}`);
          }
          if (FrameGraphRenderPass.IsRenderPass(pass)) {
            const handles = Array.isArray(pass.renderTarget) ? pass.renderTarget : [pass.renderTarget];
            disabledOutputTexture = [];
            for (const handle of handles) {
              if (handle !== void 0) {
                disabledOutputTexture.push(this._frameGraph.textureManager.getTextureFromHandle(handle));
              }
            }
            disabledOutputTextureHandle = handles;
            disabledOutputDepthTexture = pass.renderTargetDepth !== void 0 ? this._frameGraph.textureManager.getTextureFromHandle(pass.renderTargetDepth) : null;
          } else if (FrameGraphObjectListPass.IsObjectListPass(pass)) {
            disabledOutputObjectList = pass.objectList;
          }
        }
        if (this._passesDisabled.length > 0) {
          if (!this._checkSameRenderTarget(outputTexture, disabledOutputTexture)) {
            let ok = true;
            for (const handle of disabledOutputTextureHandle) {
              if (handle !== void 0 && !this._frameGraph.textureManager.isHistoryTexture(handle)) {
                ok = false;
                break;
              }
            }
            if (!ok) {
              throw new Error(`The output texture of the task "${this.name}" is different when it is enabled or disabled.`);
            }
          }
          if (outputDepthTexture !== disabledOutputDepthTexture && disabledOutputDepthTexture !== null) {
            throw new Error(`The output depth texture of the task "${this.name}" is different when it is enabled or disabled.`);
          }
          if (outputObjectList !== disabledOutputObjectList && disabledOutputObjectList !== null) {
            throw new Error(`The output object list of the task "${this.name}" is different when it is enabled or disabled.`);
          }
        }
      }
      /** @internal */
      _execute() {
        const passes = this._disabled && this._passesDisabled.length > 0 ? this._passesDisabled : this._passes;
        this.onBeforeTaskExecute.notifyObservers(this);
        if (!this._disableDebugMarkers) {
          this._frameGraph.engine._debugPushGroup?.(`${this.getClassName()} (${this.name})`);
        }
        for (const pass of passes) {
          pass._execute();
        }
        if (!this._disableDebugMarkers) {
          this._frameGraph.engine._debugPopGroup?.();
        }
        this.onAfterTaskExecute.notifyObservers(this);
      }
      /** @internal */
      _initializePasses() {
        if (!this._disableDebugMarkers) {
          this._frameGraph.engine._debugPushGroup?.(`${this.getClassName()} (${this.name})`);
        }
        for (const pass of this._passes) {
          pass._initialize();
        }
        for (const pass of this._passesDisabled) {
          pass._initialize();
        }
        if (!this._disableDebugMarkers) {
          this._frameGraph.engine._debugPopGroup?.();
        }
      }
      _checkSameRenderTarget(src, dst) {
        if (src === null || dst === null) {
          return src === dst;
        }
        if (src.length !== dst.length) {
          return false;
        }
        for (let i = 0; i < src.length; i++) {
          if (src[i] !== dst[i]) {
            return false;
          }
        }
        return true;
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/multiRenderTarget.js
var MultiRenderTarget;
var init_multiRenderTarget = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/multiRenderTarget.js"() {
    init_texture();
    init_renderTargetTexture();
    init_engine_multiRender();
    MultiRenderTarget = class extends RenderTargetTexture {
      /**
       * Get if draw buffers (render textures) are currently supported by the used hardware and browser.
       */
      get isSupported() {
        return this._engine?.getCaps().drawBuffersExtension ?? false;
      }
      /**
       * Get the list of textures generated by the multi render target.
       */
      get textures() {
        return this._textures;
      }
      /**
       * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.
       */
      get count() {
        return this._count;
      }
      /**
       * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set
       */
      get depthTexture() {
        return this._textures[this._textures.length - 1];
      }
      /**
       * Set the wrapping mode on U of all the textures we are rendering to.
       * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
       */
      set wrapU(wrap) {
        if (this._textures) {
          for (let i = 0; i < this._textures.length; i++) {
            this._textures[i].wrapU = wrap;
          }
        }
      }
      /**
       * Set the wrapping mode on V of all the textures we are rendering to.
       * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
       */
      set wrapV(wrap) {
        if (this._textures) {
          for (let i = 0; i < this._textures.length; i++) {
            this._textures[i].wrapV = wrap;
          }
        }
      }
      /**
       * Instantiate a new multi render target texture.
       * A multi render target, like a render target provides the ability to render to a texture.
       * Unlike the render target, it can render to several draw buffers (render textures) in one draw.
       * This is specially interesting in deferred rendering or for any effects requiring more than
       * just one color from a single pass.
       * @param name Define the name of the texture
       * @param size Define the size of the buffers to render to
       * @param count Define the number of target we are rendering into
       * @param scene Define the scene the texture belongs to
       * @param options Define the options used to create the multi render target
       * @param textureNames Define the names to set to the textures (if count \> 0 - optional)
       */
      constructor(name13, size, count, scene, options, textureNames) {
        const generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;
        const generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;
        const depthTextureFormat = options && options.depthTextureFormat ? options.depthTextureFormat : 15;
        const doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === void 0 ? true : options.doNotChangeAspectRatio;
        const drawOnlyOnFirstAttachmentByDefault = options && options.drawOnlyOnFirstAttachmentByDefault ? options.drawOnlyOnFirstAttachmentByDefault : false;
        super(name13, size, scene, generateMipMaps, doNotChangeAspectRatio, void 0, void 0, void 0, void 0, void 0, void 0, void 0, true);
        if (!this.isSupported) {
          this.dispose();
          return;
        }
        this._textureNames = textureNames;
        const types = [];
        const samplingModes = [];
        const useSRGBBuffers = [];
        const formats = [];
        const targetTypes = [];
        const faceIndex = [];
        const layerIndex = [];
        const layerCounts = [];
        this._initTypes(count, types, samplingModes, useSRGBBuffers, formats, targetTypes, faceIndex, layerIndex, layerCounts, options);
        const generateDepthBuffer = !options || options.generateDepthBuffer === void 0 ? true : options.generateDepthBuffer;
        const generateStencilBuffer = !options || options.generateStencilBuffer === void 0 ? false : options.generateStencilBuffer;
        const samples = options && options.samples ? options.samples : 1;
        this._multiRenderTargetOptions = {
          samplingModes,
          generateMipMaps,
          generateDepthBuffer,
          generateStencilBuffer,
          generateDepthTexture,
          depthTextureFormat,
          types,
          textureCount: count,
          useSRGBBuffers,
          samples,
          formats,
          targetTypes,
          faceIndex,
          layerIndex,
          layerCounts,
          labels: textureNames,
          label: name13
        };
        this._count = count;
        this._drawOnlyOnFirstAttachmentByDefault = drawOnlyOnFirstAttachmentByDefault;
        if (count > 0) {
          this._createInternalTextures();
          this._createTextures(textureNames);
        }
      }
      _initTypes(count, types, samplingModes, useSRGBBuffers, formats, targets, faceIndex, layerIndex, layerCounts, options) {
        for (let i = 0; i < count; i++) {
          if (options && options.types && options.types[i] !== void 0) {
            types.push(options.types[i]);
          } else {
            types.push(options && options.defaultType ? options.defaultType : 0);
          }
          if (options && options.samplingModes && options.samplingModes[i] !== void 0) {
            samplingModes.push(options.samplingModes[i]);
          } else {
            samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);
          }
          if (options && options.useSRGBBuffers && options.useSRGBBuffers[i] !== void 0) {
            useSRGBBuffers.push(options.useSRGBBuffers[i]);
          } else {
            useSRGBBuffers.push(false);
          }
          if (options && options.formats && options.formats[i] !== void 0) {
            formats.push(options.formats[i]);
          } else {
            formats.push(5);
          }
          if (options && options.targetTypes && options.targetTypes[i] !== void 0) {
            targets.push(options.targetTypes[i]);
          } else {
            targets.push(3553);
          }
          if (options && options.faceIndex && options.faceIndex[i] !== void 0) {
            faceIndex.push(options.faceIndex[i]);
          } else {
            faceIndex.push(0);
          }
          if (options && options.layerIndex && options.layerIndex[i] !== void 0) {
            layerIndex.push(options.layerIndex[i]);
          } else {
            layerIndex.push(0);
          }
          if (options && options.layerCounts && options.layerCounts[i] !== void 0) {
            layerCounts.push(options.layerCounts[i]);
          } else {
            layerCounts.push(1);
          }
        }
      }
      _createInternaTextureIndexMapping() {
        const mapMainInternalTexture2Index = {};
        const mapInternalTexture2MainIndex = [];
        if (!this._renderTarget) {
          return mapInternalTexture2MainIndex;
        }
        const internalTextures = this._renderTarget.textures;
        for (let i = 0; i < internalTextures.length; i++) {
          const texture = internalTextures[i];
          if (!texture) {
            continue;
          }
          const mainIndex = mapMainInternalTexture2Index[texture.uniqueId];
          if (mainIndex !== void 0) {
            mapInternalTexture2MainIndex[i] = mainIndex;
          } else {
            mapMainInternalTexture2Index[texture.uniqueId] = i;
          }
        }
        return mapInternalTexture2MainIndex;
      }
      /**
       * @internal
       */
      _rebuild(fromContextLost = false, forceFullRebuild = false, textureNames) {
        if (this._count < 1 || fromContextLost) {
          return;
        }
        const mapInternalTexture2MainIndex = this._createInternaTextureIndexMapping();
        this.releaseInternalTextures();
        this._createInternalTextures();
        if (forceFullRebuild) {
          this._releaseTextures();
          this._createTextures(textureNames);
        }
        const internalTextures = this._renderTarget.textures;
        for (let i = 0; i < internalTextures.length; i++) {
          const texture = this._textures[i];
          if (mapInternalTexture2MainIndex[i] !== void 0) {
            this._renderTarget.setTexture(internalTextures[mapInternalTexture2MainIndex[i]], i);
          }
          texture._texture = internalTextures[i];
          if (texture._texture) {
            texture._noMipmap = !texture._texture.useMipMaps;
            texture._useSRGBBuffer = texture._texture._useSRGBBuffer;
          }
        }
        if (this.samples !== 1) {
          this._renderTarget.setSamples(this.samples, !this._drawOnlyOnFirstAttachmentByDefault, true);
        }
      }
      _createInternalTextures() {
        this._renderTarget = this._getEngine().createMultipleRenderTarget(this._size, this._multiRenderTargetOptions, !this._drawOnlyOnFirstAttachmentByDefault);
        this._texture = this._renderTarget.texture;
      }
      _releaseTextures() {
        if (this._textures) {
          for (let i = 0; i < this._textures.length; i++) {
            this._textures[i]._texture = null;
            this._textures[i].dispose();
          }
        }
      }
      _createTextures(textureNames) {
        const internalTextures = this._renderTarget.textures;
        this._textures = [];
        for (let i = 0; i < internalTextures.length; i++) {
          const texture = new Texture(null, this.getScene());
          if (textureNames?.[i]) {
            texture.name = textureNames[i];
          }
          texture._texture = internalTextures[i];
          if (texture._texture) {
            texture._noMipmap = !texture._texture.useMipMaps;
            texture._useSRGBBuffer = texture._texture._useSRGBBuffer;
          }
          this._textures.push(texture);
        }
      }
      /**
       * Replaces an internal texture within the MRT. Useful to share textures between MultiRenderTarget.
       * @param texture The new texture to set in the MRT
       * @param index The index of the texture to replace
       * @param disposePrevious Set to true if the previous internal texture should be disposed
       */
      setInternalTexture(texture, index, disposePrevious = true) {
        if (!this.renderTarget) {
          return;
        }
        if (index === 0) {
          this._texture = texture;
        }
        this.renderTarget.setTexture(texture, index, disposePrevious);
        if (!this.textures[index]) {
          this.textures[index] = new Texture(null, this.getScene());
          this.textures[index].name = this._textureNames?.[index] ?? this.textures[index].name;
        }
        this.textures[index]._texture = texture;
        this.textures[index]._noMipmap = !texture.useMipMaps;
        this.textures[index]._useSRGBBuffer = texture._useSRGBBuffer;
        this._count = this.renderTarget.textures ? this.renderTarget.textures.length : 0;
        if (this._multiRenderTargetOptions.types) {
          this._multiRenderTargetOptions.types[index] = texture.type;
        }
        if (this._multiRenderTargetOptions.samplingModes) {
          this._multiRenderTargetOptions.samplingModes[index] = texture.samplingMode;
        }
        if (this._multiRenderTargetOptions.useSRGBBuffers) {
          this._multiRenderTargetOptions.useSRGBBuffers[index] = texture._useSRGBBuffer;
        }
        if (this._multiRenderTargetOptions.targetTypes && this._multiRenderTargetOptions.targetTypes[index] !== -1) {
          let target = 0;
          if (texture.is2DArray) {
            target = 35866;
          } else if (texture.isCube) {
            target = 34067;
          } else if (texture.is3D) {
            target = 32879;
          } else {
            target = 3553;
          }
          this._multiRenderTargetOptions.targetTypes[index] = target;
        }
      }
      /**
       * Changes an attached texture's face index or layer.
       * @param index The index of the texture to modify the attachment of
       * @param layerIndex The layer index of the texture to be attached to the framebuffer
       * @param faceIndex The face index of the texture to be attached to the framebuffer
       */
      setLayerAndFaceIndex(index, layerIndex = -1, faceIndex = -1) {
        if (!this.textures[index] || !this.renderTarget) {
          return;
        }
        if (this._multiRenderTargetOptions.layerIndex) {
          this._multiRenderTargetOptions.layerIndex[index] = layerIndex;
        }
        if (this._multiRenderTargetOptions.faceIndex) {
          this._multiRenderTargetOptions.faceIndex[index] = faceIndex;
        }
        this.renderTarget.setLayerAndFaceIndex(index, layerIndex, faceIndex);
      }
      /**
       * Changes every attached texture's face index or layer.
       * @param layerIndices The layer indices of the texture to be attached to the framebuffer
       * @param faceIndices The face indices of the texture to be attached to the framebuffer
       */
      setLayerAndFaceIndices(layerIndices, faceIndices) {
        if (!this.renderTarget) {
          return;
        }
        this._multiRenderTargetOptions.layerIndex = layerIndices;
        this._multiRenderTargetOptions.faceIndex = faceIndices;
        this.renderTarget.setLayerAndFaceIndices(layerIndices, faceIndices);
      }
      /**
       * Define the number of samples used if MSAA is enabled.
       */
      get samples() {
        return this._samples;
      }
      set samples(value) {
        if (this._renderTarget) {
          this._samples = this._renderTarget.setSamples(value);
        } else {
          this._samples = value;
        }
      }
      /**
       * Resize all the textures in the multi render target.
       * Be careful as it will recreate all the data in the new texture.
       * @param size Define the new size
       */
      resize(size) {
        this._processSizeParameter(size);
        this._rebuild(false, void 0, this._textureNames);
      }
      /**
       * Changes the number of render targets in this MRT
       * Be careful as it will recreate all the data in the new texture.
       * @param count new texture count
       * @param options Specifies texture types and sampling modes for new textures
       * @param textureNames Specifies the names of the textures (optional)
       */
      updateCount(count, options, textureNames) {
        this._multiRenderTargetOptions.textureCount = count;
        this._count = count;
        const types = [];
        const samplingModes = [];
        const useSRGBBuffers = [];
        const formats = [];
        const targetTypes = [];
        const faceIndex = [];
        const layerIndex = [];
        const layerCounts = [];
        this._textureNames = textureNames;
        this._initTypes(count, types, samplingModes, useSRGBBuffers, formats, targetTypes, faceIndex, layerIndex, layerCounts, options);
        this._multiRenderTargetOptions.types = types;
        this._multiRenderTargetOptions.samplingModes = samplingModes;
        this._multiRenderTargetOptions.useSRGBBuffers = useSRGBBuffers;
        this._multiRenderTargetOptions.formats = formats;
        this._multiRenderTargetOptions.targetTypes = targetTypes;
        this._multiRenderTargetOptions.faceIndex = faceIndex;
        this._multiRenderTargetOptions.layerIndex = layerIndex;
        this._multiRenderTargetOptions.layerCounts = layerCounts;
        this._multiRenderTargetOptions.labels = textureNames;
        this._rebuild(false, true, textureNames);
      }
      _unbindFrameBuffer(engine, faceIndex) {
        if (this._renderTarget) {
          engine.unBindMultiColorAttachmentFramebuffer(this._renderTarget, this.isCube, () => {
            this.onAfterRenderObservable.notifyObservers(faceIndex);
          });
        }
      }
      /**
       * Dispose the render targets and their associated resources
       * @param doNotDisposeInternalTextures if set to true, internal textures won't be disposed (default: false).
       */
      dispose(doNotDisposeInternalTextures = false) {
        this._releaseTextures();
        if (!doNotDisposeInternalTextures) {
          this.releaseInternalTextures();
        } else {
          this._texture = null;
        }
        super.dispose();
      }
      /**
       * Release all the underlying texture used as draw buffers (render textures).
       */
      releaseInternalTextures() {
        const internalTextures = this._renderTarget?.textures;
        if (!internalTextures) {
          return;
        }
        for (let i = internalTextures.length - 1; i >= 0; i--) {
          this._textures[i]._texture = null;
        }
        this._renderTarget?.dispose();
        this._renderTarget = null;
      }
    };
  }
});

// node_modules/@babylonjs/core/Rendering/thinDepthPeelingRenderer.js
var ThinDepthPeelingRenderer;
var init_thinDepthPeelingRenderer = __esm({
  "node_modules/@babylonjs/core/Rendering/thinDepthPeelingRenderer.js"() {
    init_multiRenderTarget();
    init_math_color();
    init_smartArray();
    init_thinTexture();
    init_effectRenderer();
    init_material();
    init_engine_multiRender();
    ThinDepthPeelingRenderer = class _ThinDepthPeelingRenderer {
      /**
       * Number of depth peeling passes. As we are using dual depth peeling, each pass two levels of transparency are processed.
       */
      get passCount() {
        return this._passCount;
      }
      set passCount(count) {
        if (this._passCount === count) {
          return;
        }
        this._passCount = count;
        this._createRenderPassIds();
      }
      /**
       * Instructs the renderer to use render passes. It is an optimization that makes the rendering faster for some engines (like WebGPU) but that consumes more memory, so it is disabled by default.
       */
      get useRenderPasses() {
        return this._useRenderPasses;
      }
      set useRenderPasses(usePasses) {
        if (this._useRenderPasses === usePasses) {
          return;
        }
        this._useRenderPasses = usePasses;
        this._createRenderPassIds();
      }
      /**
       * Add a mesh in the exclusion list to prevent it to be handled by the depth peeling renderer
       * @param mesh The mesh to exclude from the depth peeling renderer
       */
      addExcludedMesh(mesh) {
        if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {
          this._excludedMeshes.push(mesh.uniqueId);
        }
      }
      /**
       * Remove a mesh from the exclusion list of the depth peeling renderer
       * @param mesh The mesh to remove
       */
      removeExcludedMesh(mesh) {
        const index = this._excludedMeshes.indexOf(mesh.uniqueId);
        if (index !== -1) {
          this._excludedMeshes.splice(index, 1);
        }
      }
      /**
       * Gets the shader language used in this renderer
       */
      get shaderLanguage() {
        return this._shaderLanguage;
      }
      /**
       * Sets the render target wrapper we will blend the transparent objects onto
       */
      get blendOutput() {
        return this._blendOutput;
      }
      set blendOutput(blendOutput) {
        this._blendOutput = blendOutput;
        this._disposeTextures();
        if (blendOutput) {
          this._createTextures();
        }
      }
      /**
       * Instanciates the depth peeling renderer
       * @param scene Scene to attach to
       * @param passCount Number of depth layers to peel
       * @returns The depth peeling renderer
       */
      constructor(scene, passCount = 5) {
        this._depthMrts = [];
        this._thinTextures = [];
        this._colorMrts = [];
        this._currentPingPongState = 0;
        this._layoutCacheFormat = [[true], [true, true], [true, true, true]];
        this._layoutCache = [];
        this._candidateSubMeshes = new SmartArray(10);
        this._excludedSubMeshes = new SmartArray(10);
        this._excludedMeshes = [];
        this._colorCache = [
          new Color4(_ThinDepthPeelingRenderer._DEPTH_CLEAR_VALUE, _ThinDepthPeelingRenderer._DEPTH_CLEAR_VALUE, 0, 0),
          new Color4(-_ThinDepthPeelingRenderer._MIN_DEPTH, _ThinDepthPeelingRenderer._MAX_DEPTH, 0, 0),
          new Color4(0, 0, 0, 0)
        ];
        this._shaderLanguage = 0;
        this._scene = scene;
        this._engine = scene.getEngine();
        this._passCount = passCount;
        for (let i = 0; i < this._layoutCacheFormat.length; ++i) {
          this._layoutCache[i] = this._engine.buildTextureLayout(this._layoutCacheFormat[i]);
        }
        this._renderPassIds = [];
        this.useRenderPasses = false;
        if (this._engine.isWebGPU) {
          this._shaderLanguage = 1;
        }
        this._createEffects("oitFinalSimpleBlend", ["uFrontColor"]);
      }
      _createRenderPassIds() {
        this._releaseRenderPassIds();
        if (this._useRenderPasses) {
          for (let i = 0; i < this._passCount + 1; ++i) {
            if (!this._renderPassIds[i]) {
              this._renderPassIds[i] = this._engine.createRenderPassId(`DepthPeelingRenderer - pass #${i}`);
            }
          }
        }
      }
      _releaseRenderPassIds() {
        for (let i = 0; i < this._renderPassIds.length; ++i) {
          this._engine.releaseRenderPassId(this._renderPassIds[i]);
        }
        this._renderPassIds = [];
      }
      _getTextureSize() {
        if (this._blendOutput) {
          return {
            width: this._blendOutput.width,
            height: this._blendOutput.height
          };
        }
        return { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() };
      }
      _createTextures() {
        const size = this._getTextureSize();
        this._depthMrts = [
          new MultiRenderTarget("depthPeelingDepth0MRT", size, 3, this._scene, void 0, [
            "depthPeelingDepth0MRT_depth",
            "depthPeelingDepth0MRT_frontColor",
            "depthPeelingDepth0MRT_backColor"
          ]),
          new MultiRenderTarget("depthPeelingDepth1MRT", size, 3, this._scene, void 0, [
            "depthPeelingDepth1MRT_depth",
            "depthPeelingDepth1MRT_frontColor",
            "depthPeelingDepth1MRT_backColor"
          ])
        ];
        this._colorMrts = [
          new MultiRenderTarget("depthPeelingColor0MRT", size, 2, this._scene, { generateDepthBuffer: false }, [
            "depthPeelingColor0MRT_frontColor",
            "depthPeelingColor0MRT_backColor"
          ]),
          new MultiRenderTarget("depthPeelingColor1MRT", size, 2, this._scene, { generateDepthBuffer: false }, [
            "depthPeelingColor1MRT_frontColor",
            "depthPeelingColor1MRT_backColor"
          ])
        ];
        this._blendBackMrt = new MultiRenderTarget("depthPeelingBackMRT", size, 1, this._scene, { generateDepthBuffer: false }, ["depthPeelingBackMRT_blendBack"]);
        if (this._blendOutput) {
          this._blendBackMrt.setInternalTexture(this._blendOutput.texture, 0);
        }
        const optionsArray = [
          {
            format: 7,
            samplingMode: 1,
            type: this._engine.getCaps().textureFloatLinearFiltering ? 1 : 2,
            label: "DepthPeelingRenderer-DepthTexture"
          },
          {
            format: 5,
            samplingMode: 1,
            type: 2,
            label: "DepthPeelingRenderer-ColorTexture"
          }
        ];
        for (let i = 0; i < 2; i++) {
          const depthTexture = this._engine._createInternalTexture(size, optionsArray[0], false);
          const frontColorTexture = this._engine._createInternalTexture(size, optionsArray[1], false);
          const backColorTexture = this._engine._createInternalTexture(size, optionsArray[1], false);
          this._depthMrts[i].setInternalTexture(depthTexture, 0);
          this._depthMrts[i].setInternalTexture(frontColorTexture, 1);
          this._depthMrts[i].setInternalTexture(backColorTexture, 2);
          this._colorMrts[i].setInternalTexture(frontColorTexture, 0);
          this._colorMrts[i].setInternalTexture(backColorTexture, 1);
          this._thinTextures.push(new ThinTexture(depthTexture), new ThinTexture(frontColorTexture), new ThinTexture(backColorTexture));
        }
        if (this._blendOutput) {
          this._blendOutput.shareDepth(this._depthMrts[0].renderTarget);
        }
      }
      _disposeTextures() {
        for (let i = 0; i < this._thinTextures.length; i++) {
          this._thinTextures[i].dispose();
        }
        for (let i = 0; i < this._depthMrts.length; i++) {
          this._depthMrts[i].dispose(true);
          this._colorMrts[i].dispose(true);
          this._blendBackMrt.dispose(true);
        }
        this._thinTextures = [];
        this._colorMrts = [];
        this._depthMrts = [];
      }
      _createEffects(finalEffectFragmentShaderName, finalEffectSamplerNames) {
        this._blendBackEffectWrapper = new EffectWrapper({
          fragmentShader: "oitBackBlend",
          useShaderStore: true,
          engine: this._engine,
          samplerNames: ["uBackColor"],
          uniformNames: [],
          shaderLanguage: this._shaderLanguage,
          extraInitializationsAsync: async () => {
            if (this._shaderLanguage === 1) {
              await import("./oitBackBlend.fragment-YJXY4BN6.js");
            } else {
              await import("./oitBackBlend.fragment-EOR4RZXL.js");
            }
          }
        });
        this._blendBackEffectWrapperPingPong = new EffectWrapper({
          fragmentShader: "oitBackBlend",
          useShaderStore: true,
          engine: this._engine,
          samplerNames: ["uBackColor"],
          uniformNames: [],
          shaderLanguage: this._shaderLanguage,
          extraInitializationsAsync: async () => {
            if (this._shaderLanguage === 1) {
              await import("./oitBackBlend.fragment-YJXY4BN6.js");
            } else {
              await import("./oitBackBlend.fragment-EOR4RZXL.js");
            }
          }
        });
        this._finalEffectWrapper = new EffectWrapper({
          fragmentShader: finalEffectFragmentShaderName,
          useShaderStore: true,
          engine: this._engine,
          samplerNames: finalEffectSamplerNames,
          uniformNames: [],
          shaderLanguage: this._shaderLanguage,
          extraInitializationsAsync: async () => {
            if (this._shaderLanguage === 1) {
              await import("./oitFinalSimpleBlend.fragment-FRY7NJOZ.js");
            } else {
              await import("./oitFinalSimpleBlend.fragment-3T2FAQBA.js");
            }
          }
        });
        this._effectRenderer = new EffectRenderer(this._engine);
      }
      /**
       * Links to the prepass renderer
       * @param _prePassRenderer The scene PrePassRenderer
       */
      setPrePassRenderer(_prePassRenderer) {
      }
      /**
       * Binds depth peeling textures on an effect
       * @param effect The effect to bind textures on
       */
      bind(effect) {
        effect.setTexture("oitDepthSampler", this._thinTextures[this._currentPingPongState * 3]);
        effect.setTexture("oitFrontColorSampler", this._thinTextures[this._currentPingPongState * 3 + 1]);
      }
      _renderSubMeshes(transparentSubMeshes) {
        let mapMaterialContext;
        if (this._useRenderPasses) {
          mapMaterialContext = {};
        }
        for (let j = 0; j < transparentSubMeshes.length; j++) {
          const material = transparentSubMeshes.data[j].getMaterial();
          let previousShaderHotSwapping = true;
          let previousBFC = false;
          const subMesh = transparentSubMeshes.data[j];
          let drawWrapper;
          let firstDraw = false;
          if (this._useRenderPasses) {
            drawWrapper = subMesh._getDrawWrapper();
            firstDraw = !drawWrapper;
          }
          if (material) {
            previousShaderHotSwapping = material.allowShaderHotSwapping;
            previousBFC = material.backFaceCulling;
            material.allowShaderHotSwapping = false;
            material.backFaceCulling = false;
          }
          subMesh.render(false);
          if (firstDraw) {
            drawWrapper = subMesh._getDrawWrapper();
            if (drawWrapper.materialContext) {
              let newMaterialContext = mapMaterialContext[drawWrapper.materialContext.uniqueId];
              if (!newMaterialContext) {
                newMaterialContext = mapMaterialContext[drawWrapper.materialContext.uniqueId] = this._engine.createMaterialContext();
              }
              subMesh._getDrawWrapper().materialContext = newMaterialContext;
            }
          }
          if (material) {
            material.allowShaderHotSwapping = previousShaderHotSwapping;
            material.backFaceCulling = previousBFC;
          }
        }
      }
      _finalCompose(writeId) {
        this._engine.bindFramebuffer(this._blendOutput);
        this._engine.setAlphaMode(7);
        this._engine.depthCullingState.depthMask = false;
        this._engine.depthCullingState.depthTest = false;
        this._engine.applyStates();
        this._engine.enableEffect(this._finalEffectWrapper.drawWrapper);
        this._finalEffectWrapper.effect.setTexture("uFrontColor", this._thinTextures[writeId * 3 + 1]);
        this._effectRenderer.render(this._finalEffectWrapper);
      }
      /**
       * Checks if the depth peeling renderer is ready to render transparent meshes
       * @returns true if the depth peeling renderer is ready to render the transparent meshes
       */
      isReady() {
        return this._blendBackEffectWrapper.effect.isReady() && this._blendBackEffectWrapperPingPong.effect.isReady() && this._finalEffectWrapper.effect.isReady();
      }
      _beforeRender() {
      }
      _afterRender() {
      }
      _noTransparentMeshes() {
      }
      /**
       * Renders transparent submeshes with depth peeling
       * @param transparentSubMeshes List of transparent meshes to render
       * @returns The array of submeshes that could not be handled by this renderer
       */
      render(transparentSubMeshes) {
        this._candidateSubMeshes.length = 0;
        this._excludedSubMeshes.length = 0;
        if (!this.isReady()) {
          return this._excludedSubMeshes;
        }
        if (this._scene.activeCamera) {
          this._engine.setViewport(this._scene.activeCamera.viewport);
        }
        for (let i = 0; i < transparentSubMeshes.length; i++) {
          const subMesh = transparentSubMeshes.data[i];
          const material = subMesh.getMaterial();
          const fillMode = material && subMesh.getRenderingMesh()._getRenderingFillMode(material.fillMode);
          if (material && (fillMode === Material.TriangleFanDrawMode || fillMode === Material.TriangleFillMode || fillMode === Material.TriangleStripDrawMode) && this._excludedMeshes.indexOf(subMesh.getMesh().uniqueId) === -1) {
            this._candidateSubMeshes.push(subMesh);
          } else {
            this._excludedSubMeshes.push(subMesh);
          }
        }
        if (!this._candidateSubMeshes.length) {
          this._noTransparentMeshes();
          return this._excludedSubMeshes;
        }
        const currentRenderPassId = this._engine.currentRenderPassId;
        this._beforeRender();
        if (this._useRenderPasses) {
          this._engine.currentRenderPassId = this._renderPassIds[0];
        }
        this._engine.bindFramebuffer(this._depthMrts[0].renderTarget);
        this._engine.bindAttachments(this._layoutCache[0]);
        this._engine.clear(this._colorCache[0], true, false, false);
        this._engine.unBindFramebuffer(this._depthMrts[0].renderTarget);
        this._engine.bindFramebuffer(this._depthMrts[1].renderTarget);
        this._engine.bindAttachments(this._layoutCache[0]);
        this._engine.clear(this._colorCache[1], true, false, false);
        this._engine.unBindFramebuffer(this._depthMrts[1].renderTarget);
        this._engine.bindFramebuffer(this._colorMrts[0].renderTarget);
        this._engine.bindAttachments(this._layoutCache[1]);
        this._engine.clear(this._colorCache[2], true, false, false);
        this._engine.unBindFramebuffer(this._colorMrts[0].renderTarget);
        this._engine.bindFramebuffer(this._colorMrts[1].renderTarget);
        this._engine.bindAttachments(this._layoutCache[1]);
        this._engine.clear(this._colorCache[2], true, false, false);
        this._engine.unBindFramebuffer(this._colorMrts[1].renderTarget);
        this._engine.bindFramebuffer(this._depthMrts[0].renderTarget);
        this._engine.bindAttachments(this._layoutCache[0]);
        this._engine.setAlphaMode(11);
        this._engine.setAlphaEquation(3);
        this._engine.depthCullingState.depthMask = false;
        this._engine.depthCullingState.depthTest = true;
        this._engine.applyStates();
        this._currentPingPongState = 1;
        this._renderSubMeshes(this._candidateSubMeshes);
        this._engine.unBindFramebuffer(this._depthMrts[0].renderTarget);
        this._scene.resetCachedMaterial();
        let readId = 0;
        let writeId = 0;
        for (let i = 0; i < this._passCount; i++) {
          readId = i % 2;
          writeId = 1 - readId;
          this._currentPingPongState = readId;
          if (this._useRenderPasses) {
            this._engine.currentRenderPassId = this._renderPassIds[i + 1];
          }
          if (this._scene.activeCamera) {
            this._engine.setViewport(this._scene.activeCamera.viewport);
          }
          this._engine.bindFramebuffer(this._depthMrts[writeId].renderTarget);
          this._engine.bindAttachments(this._layoutCache[0]);
          this._engine.clear(this._colorCache[0], true, false, false);
          this._engine.unBindFramebuffer(this._depthMrts[writeId].renderTarget);
          this._engine.bindFramebuffer(this._colorMrts[writeId].renderTarget);
          this._engine.bindAttachments(this._layoutCache[1]);
          this._engine.clear(this._colorCache[2], true, false, false);
          this._engine.unBindFramebuffer(this._colorMrts[writeId].renderTarget);
          this._engine.bindFramebuffer(this._depthMrts[writeId].renderTarget);
          this._engine.bindAttachments(this._layoutCache[2]);
          this._engine.setAlphaMode(11);
          this._engine.setAlphaEquation(3);
          this._engine.depthCullingState.depthTest = false;
          this._engine.applyStates();
          this._renderSubMeshes(this._candidateSubMeshes);
          this._engine.unBindFramebuffer(this._depthMrts[writeId].renderTarget);
          this._scene.resetCachedMaterial();
          this._engine.bindFramebuffer(this._blendBackMrt.renderTarget);
          this._engine.bindAttachments(this._layoutCache[0]);
          this._engine.setAlphaEquation(0);
          this._engine.setAlphaMode(17);
          this._engine.applyStates();
          const blendBackEffectWrapper = writeId === 0 || !this._useRenderPasses ? this._blendBackEffectWrapper : this._blendBackEffectWrapperPingPong;
          this._engine.enableEffect(blendBackEffectWrapper.drawWrapper);
          blendBackEffectWrapper.effect.setTexture("uBackColor", this._thinTextures[writeId * 3 + 2]);
          this._effectRenderer.render(blendBackEffectWrapper);
          this._engine.unBindFramebuffer(this._blendBackMrt.renderTarget);
        }
        this._engine.currentRenderPassId = currentRenderPassId;
        this._finalCompose(writeId);
        this._engine.setAlphaMode(0);
        this._engine.depthCullingState.depthMask = true;
        this._engine.depthCullingState.depthTest = true;
        this._afterRender();
        return this._excludedSubMeshes;
      }
      /**
       * Disposes the depth peeling renderer and associated resources
       */
      dispose() {
        this._disposeTextures();
        this._blendBackEffectWrapper.dispose();
        this._finalEffectWrapper.dispose();
        this._effectRenderer.dispose();
        this._releaseRenderPassIds();
      }
    };
    ThinDepthPeelingRenderer._DEPTH_CLEAR_VALUE = -99999;
    ThinDepthPeelingRenderer._MIN_DEPTH = 0;
    ThinDepthPeelingRenderer._MAX_DEPTH = 1;
  }
});

// node_modules/@babylonjs/core/FrameGraph/frameGraphRenderTarget.js
var FrameGraphRenderTarget;
var init_frameGraphRenderTarget = __esm({
  "node_modules/@babylonjs/core/FrameGraph/frameGraphRenderTarget.js"() {
    FrameGraphRenderTarget = class {
      constructor(name13, textureManager, renderTargets, renderTargetDepth) {
        this._isBackBuffer = false;
        this.name = name13;
        this._textureManager = textureManager;
        this._renderTargets = renderTargets === void 0 ? void 0 : Array.isArray(renderTargets) ? renderTargets : [renderTargets];
        this._renderTargetDepth = renderTargetDepth;
      }
      get renderTargetWrapper() {
        if (this._isBackBuffer) {
          return void 0;
        }
        if (!this._renderTargetWrapper) {
          const engine = this._textureManager.engine;
          const textureHandle = this._renderTargets === void 0 || this._renderTargets.length === 0 ? this._renderTargetDepth : this._renderTargets[0];
          if (this._textureManager.isBackbuffer(textureHandle)) {
            this._isBackBuffer = true;
            return void 0;
          }
          const textureDescription = this._textureManager.getTextureDescription(textureHandle);
          const creationOptionsForTexture = {
            textureCount: this._renderTargets?.length ?? 0,
            generateDepthBuffer: false,
            label: this.name,
            samples: textureDescription.options.samples ?? 1,
            dontCreateTextures: true
          };
          this._renderTargetWrapper = engine.createMultipleRenderTarget(textureDescription.size, creationOptionsForTexture, true);
          for (let i = 0; i < creationOptionsForTexture.textureCount; i++) {
            const handle = this._renderTargets[i];
            const texture = this._textureManager.getTextureFromHandle(handle);
            if (!texture) {
              throw new Error(`FrameGraphRenderTarget.renderTargetWrapper: Failed to get texture from handle. handle: ${handle}, name: ${this.name}, index: ${i}, renderTargets: ${this._renderTargets}`);
            }
            texture.incrementReferences();
            this._renderTargetWrapper.setTexture(texture, i, false);
          }
          if (this._renderTargetDepth !== void 0) {
            this._renderTargetWrapper.setDepthStencilTexture(this._textureManager.getTextureFromHandle(this._renderTargetDepth), false);
          }
        }
        return this._renderTargetWrapper;
      }
      equals(other) {
        const src = this._renderTargets;
        const dst = other._renderTargets;
        if (src !== void 0 && dst !== void 0) {
          if (src.length !== dst.length) {
            return false;
          }
          for (let i = 0; i < src.length; i++) {
            if (src[i] !== dst[i]) {
              return false;
            }
          }
        } else if (src === void 0 && dst !== void 0 || src !== void 0 && dst === void 0) {
          return false;
        }
        return this._renderTargetDepth === other._renderTargetDepth;
      }
      dispose() {
        this._renderTargetWrapper?.dispose();
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/frameGraphTaskMultiRenderTarget.js
var FrameGraphTaskMultiRenderTarget;
var init_frameGraphTaskMultiRenderTarget = __esm({
  "node_modules/@babylonjs/core/FrameGraph/frameGraphTaskMultiRenderTarget.js"() {
    init_frameGraphTask();
    FrameGraphTaskMultiRenderTarget = class extends FrameGraphTask {
      constructor() {
        super(...arguments);
        this._layerAndFaceIndicesUpdated = false;
      }
      /**
       * Sets the output layer and face indices for multi-target rendering.
       * @param indices The array of layer and face indices.
       */
      setOutputLayerAndFaceIndices(indices) {
        this._outputLayerAndFaceIndices = indices;
        this._layerAndFaceIndicesUpdated = indices.length > 0;
      }
      _updateLayerAndFaceIndices(pass) {
        if (this._layerAndFaceIndicesUpdated) {
          pass.setOutputLayerAndFaceIndices(this._outputLayerAndFaceIndices);
          this._layerAndFaceIndicesUpdated = false;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/Tasks/Rendering/objectRendererTask.js
var FrameGraphObjectRendererTask;
var init_objectRendererTask = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Tasks/Rendering/objectRendererTask.js"() {
    init_frameGraphTypes();
    init_frameGraphTaskMultiRenderTarget();
    init_objectRenderer();
    init_thinDepthPeelingRenderer();
    init_renderingManager();
    init_frameGraphRenderTarget();
    init_lightConstants();
    FrameGraphObjectRendererTask = class extends FrameGraphTaskMultiRenderTarget {
      /**
       * Gets or sets the camera used to render the objects.
       */
      get camera() {
        return this._camera;
      }
      set camera(camera) {
        this._camera = camera;
        this._renderer.activeCamera = this.camera;
      }
      /**
       * If image processing should be disabled (default is false).
       * false means that the default image processing configuration will be applied (the one from the scene)
       */
      get disableImageProcessing() {
        return this._disableImageProcessing;
      }
      set disableImageProcessing(value) {
        if (value === this._disableImageProcessing) {
          return;
        }
        this._disableImageProcessing = value;
        this._renderer.disableImageProcessing = value;
      }
      /**
       * Defines if meshes should be rendered (default is true).
       */
      get renderMeshes() {
        return this._renderMeshes;
      }
      set renderMeshes(value) {
        if (value === this._renderMeshes) {
          return;
        }
        this._renderMeshes = value;
        this._renderer.renderMeshes = value;
      }
      /**
       * Defines if depth only meshes should be rendered (default is true). Always subject to the renderMeshes property, though.
       */
      get renderDepthOnlyMeshes() {
        return this._renderDepthOnlyMeshes;
      }
      set renderDepthOnlyMeshes(value) {
        if (value === this._renderDepthOnlyMeshes) {
          return;
        }
        this._renderDepthOnlyMeshes = value;
        this._renderer.renderDepthOnlyMeshes = value;
      }
      /**
       * Defines if opaque meshes should be rendered (default is true). Always subject to the renderMeshes property, though.
       */
      get renderOpaqueMeshes() {
        return this._renderOpaqueMeshes;
      }
      set renderOpaqueMeshes(value) {
        if (value === this._renderOpaqueMeshes) {
          return;
        }
        this._renderOpaqueMeshes = value;
        this._renderer.renderOpaqueMeshes = value;
      }
      /**
       * Defines if alpha test meshes should be rendered (default is true). Always subject to the renderMeshes property, though.
       */
      get renderAlphaTestMeshes() {
        return this._renderAlphaTestMeshes;
      }
      set renderAlphaTestMeshes(value) {
        if (value === this._renderAlphaTestMeshes) {
          return;
        }
        this._renderAlphaTestMeshes = value;
        this._renderer.renderAlphaTestMeshes = value;
      }
      /**
       * Defines if transparent meshes should be rendered (default is true). Always subject to the renderMeshes property, though.
       */
      get renderTransparentMeshes() {
        return this._renderTransparentMeshes;
      }
      set renderTransparentMeshes(value) {
        if (value === this._renderTransparentMeshes) {
          return;
        }
        this._renderTransparentMeshes = value;
        this._renderer.renderTransparentMeshes = value;
      }
      /**
       * Defines if Order Independent Transparency should be used for transparent meshes (default is false).
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      get useOITForTransparentMeshes() {
        return this._useOITForTransparentMeshes;
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      set useOITForTransparentMeshes(value) {
        if (value === this._useOITForTransparentMeshes) {
          return;
        }
        this._useOITForTransparentMeshes = value;
        this._renderer.customRenderTransparentSubMeshes = this._useOITForTransparentMeshes ? this._renderTransparentMeshesWithOIT.bind(this) : void 0;
        this._oitRenderer.blendOutput = value && this._rtForOrderIndependentTransparency ? this._rtForOrderIndependentTransparency.renderTargetWrapper : null;
      }
      /**
       * Defines the number of passes to use for Order Independent Transparency (default is 5).
       */
      get oitPassCount() {
        return this._oitRenderer.passCount;
      }
      set oitPassCount(value) {
        if (value === this._oitRenderer.passCount) {
          return;
        }
        this._oitRenderer.passCount = value;
      }
      /**
       * Defines if particles should be rendered (default is true).
       */
      get renderParticles() {
        return this._renderParticles;
      }
      set renderParticles(value) {
        if (value === this._renderParticles) {
          return;
        }
        this._renderParticles = value;
        this._renderer.renderParticles = value;
      }
      /**
       * Defines if sprites should be rendered (default is true).
       */
      get renderSprites() {
        return this._renderSprites;
      }
      set renderSprites(value) {
        if (value === this._renderSprites) {
          return;
        }
        this._renderSprites = value;
        this._renderer.renderSprites = value;
      }
      /**
       * Forces checking the layerMask property even if a custom list of meshes is provided (ie. if renderList is not undefined). Default is true.
       */
      get forceLayerMaskCheck() {
        return this._forceLayerMaskCheck;
      }
      set forceLayerMaskCheck(value) {
        if (value === this._forceLayerMaskCheck) {
          return;
        }
        this._forceLayerMaskCheck = value;
        this._renderer.forceLayerMaskCheck = value;
      }
      /**
       * Enables the rendering of bounding boxes for meshes (still subject to Mesh.showBoundingBox or scene.forceShowBoundingBoxes). Default is true.
       */
      get enableBoundingBoxRendering() {
        return this._enableBoundingBoxRendering;
      }
      set enableBoundingBoxRendering(value) {
        if (value === this._enableBoundingBoxRendering) {
          return;
        }
        this._enableBoundingBoxRendering = value;
        this._renderer.enableBoundingBoxRendering = value;
      }
      /**
       * Enables the rendering of outlines/overlays for meshes (still subject to Mesh.renderOutline/Mesh.renderOverlay). Default is true.
       */
      get enableOutlineRendering() {
        return this._enableOutlineRendering;
      }
      set enableOutlineRendering(value) {
        if (value === this._enableOutlineRendering) {
          return;
        }
        this._enableOutlineRendering = value;
        this._renderer.enableOutlineRendering = value;
      }
      /**
       * The object renderer used to render the objects.
       */
      get objectRenderer() {
        return this._renderer;
      }
      get name() {
        return this._name;
      }
      set name(value) {
        this._name = value;
        if (this._renderer) {
          this._renderer.name = value;
        }
      }
      /**
       * Constructs a new object renderer task.
       * @param name The name of the task.
       * @param frameGraph The frame graph the task belongs to.
       * @param scene The scene the frame graph is associated with.
       * @param options The options of the object renderer.
       * @param existingObjectRenderer An existing object renderer to use (optional). If provided, the options parameter will be ignored.
       */
      constructor(name13, frameGraph, scene, options, existingObjectRenderer) {
        super(name13, frameGraph);
        this.shadowGenerators = [];
        this.depthTest = true;
        this.depthWrite = true;
        this.disableShadows = false;
        this._disableImageProcessing = false;
        this.isMainObjectRenderer = false;
        this._renderMeshes = true;
        this._renderDepthOnlyMeshes = true;
        this._renderOpaqueMeshes = true;
        this._renderAlphaTestMeshes = true;
        this._renderTransparentMeshes = true;
        this._useOITForTransparentMeshes = false;
        this._renderParticles = true;
        this._renderSprites = true;
        this._forceLayerMaskCheck = true;
        this._enableBoundingBoxRendering = true;
        this._enableOutlineRendering = true;
        this.resolveMSAAColors = true;
        this.resolveMSAADepth = false;
        this._onBeforeRenderObservable = null;
        this._onAfterRenderObservable = null;
        this._externalObjectRenderer = false;
        this._scene = scene;
        this._engine = scene.getEngine();
        this._externalObjectRenderer = !!existingObjectRenderer;
        this._renderer = existingObjectRenderer ?? new ObjectRenderer(name13, scene, options);
        this.name = name13;
        this._renderer.disableImageProcessing = this._disableImageProcessing;
        this._renderer.renderParticles = this._renderParticles;
        this._renderer.renderSprites = this._renderSprites;
        this._renderer.enableBoundingBoxRendering = this._enableBoundingBoxRendering;
        this._renderer.forceLayerMaskCheck = this._forceLayerMaskCheck;
        if (!this._externalObjectRenderer) {
          this._renderer.onBeforeRenderingManagerRenderObservable.add(() => {
            if (!this._renderer.options.doNotChangeAspectRatio) {
              scene.updateTransformMatrix(true);
            }
          });
        }
        this._oitRenderer = new ThinDepthPeelingRenderer(scene);
        this._oitRenderer.useRenderPasses = true;
        this.outputTexture = this._frameGraph.textureManager.createDanglingHandle();
        this.outputDepthTexture = this._frameGraph.textureManager.createDanglingHandle();
        this.onBeforeTaskExecute.add(() => {
          this._disableDebugMarkers = this._engine._enableGPUDebugMarkers && this._sceneHasClusteredLights();
        });
      }
      isReady() {
        this._renderer.renderList = this.objectList.meshes;
        this._renderer.particleSystemList = this.objectList.particleSystems;
        return this._renderer.isReadyForRendering(this._textureWidth, this._textureHeight);
      }
      getClassName() {
        return "FrameGraphObjectRendererTask";
      }
      record(skipCreationOfDisabledPasses = false, additionalExecute) {
        this._checkParameters();
        const targetTextures = this._getTargetHandles();
        const depthEnabled = this._checkTextureCompatibility(targetTextures);
        this._resolveDanglingHandles(targetTextures);
        this._setLightsForShadow();
        this._rtForOrderIndependentTransparency?.dispose();
        const pass = this._frameGraph.addRenderPass(this.name);
        pass.setRenderTarget(targetTextures);
        pass.setRenderTargetDepth(this.depthTexture);
        pass.setInitializeFunc(() => {
          this._rtForOrderIndependentTransparency = new FrameGraphRenderTarget(this.name + "_oitRT", this._frameGraph.textureManager, this.targetTexture, this.depthTexture);
        });
        pass.setExecuteFunc((context) => {
          this._renderer.renderList = this.objectList.meshes;
          this._renderer.particleSystemList = this.objectList.particleSystems;
          this._updateLayerAndFaceIndices(pass);
          const renderTargetWrapper = pass.frameGraphRenderTarget.renderTargetWrapper;
          if (renderTargetWrapper) {
            renderTargetWrapper.resolveMSAAColors = this.resolveMSAAColors;
            renderTargetWrapper.resolveMSAADepth = this.resolveMSAADepth;
          }
          if (this._useOITForTransparentMeshes && this._oitRenderer.blendOutput !== this._rtForOrderIndependentTransparency.renderTargetWrapper) {
            this._oitRenderer.blendOutput = this._rtForOrderIndependentTransparency.renderTargetWrapper;
          }
          const boundingBoxRenderer = this.getBoundingBoxRenderer?.();
          const currentBoundingBoxMeshList = boundingBoxRenderer && boundingBoxRenderer.renderList.length > 0 ? boundingBoxRenderer.renderList.data.slice() : [];
          if (boundingBoxRenderer) {
            currentBoundingBoxMeshList.length = boundingBoxRenderer.renderList.length;
          }
          const attachments = this._prepareRendering(context, depthEnabled);
          const currentOITRenderer = this._scene._depthPeelingRenderer;
          this._scene._depthPeelingRenderer = this._oitRenderer;
          const camera = this._renderer.activeCamera;
          if (camera && camera.cameraRigMode !== 0 && !camera._renderingMultiview) {
            for (let index = 0; index < camera._rigCameras.length; index++) {
              const rigCamera = camera._rigCameras[index];
              rigCamera.rigParent = void 0;
              this._renderer.activeCamera = rigCamera;
              context.pushDebugGroup(`Render objects for camera rig ${index} "${rigCamera.name}"`);
              context.bindRenderTarget(pass.frameGraphRenderTarget);
              attachments && context.bindAttachments(attachments);
              context.render(this._renderer, this._textureWidth, this._textureHeight, true);
              context.popDebugGroup();
              rigCamera.rigParent = camera;
            }
            this._renderer.activeCamera = camera;
          } else {
            context.pushDebugGroup(`Render objects for camera "${this._renderer.activeCamera?.name ?? "undefined"}"`);
            context.bindRenderTarget(pass.frameGraphRenderTarget);
            attachments && context.bindAttachments(attachments);
            context.render(this._renderer, this._textureWidth, this._textureHeight, true);
            context.popDebugGroup();
          }
          additionalExecute?.(context);
          this._scene._depthPeelingRenderer = currentOITRenderer;
          if (boundingBoxRenderer) {
            boundingBoxRenderer.renderList.data = currentBoundingBoxMeshList;
            boundingBoxRenderer.renderList.length = currentBoundingBoxMeshList.length;
          }
        });
        if (!skipCreationOfDisabledPasses) {
          const passDisabled = this._frameGraph.addRenderPass(this.name + "_disabled", true);
          passDisabled.setRenderTarget(targetTextures);
          passDisabled.setRenderTargetDepth(this.depthTexture);
          passDisabled.setExecuteFunc((_context) => {
          });
        }
        return pass;
      }
      dispose() {
        this._renderer.onBeforeRenderObservable.remove(this._onBeforeRenderObservable);
        this._renderer.onAfterRenderObservable.remove(this._onAfterRenderObservable);
        if (!this._externalObjectRenderer) {
          this._renderer.dispose();
        }
        this._oitRenderer.dispose();
        this._rtForOrderIndependentTransparency?.dispose();
        super.dispose();
      }
      _resolveDanglingHandles(targetTextures) {
        if (targetTextures.length > 0) {
          this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture, targetTextures[0]);
        }
        if (this.depthTexture !== void 0) {
          this._frameGraph.textureManager.resolveDanglingHandle(this.outputDepthTexture, this.depthTexture);
        }
      }
      _checkParameters() {
        if (this.targetTexture === void 0 || this.objectList === void 0 || this.camera === void 0) {
          throw new Error(`FrameGraphObjectRendererTask ${this.name}: targetTexture, objectList, and camera are required`);
        }
      }
      _checkTextureCompatibility(targetTextures) {
        const className = this.getClassName();
        let outputTextureDescription = targetTextures.length > 0 ? this._frameGraph.textureManager.getTextureDescription(targetTextures[0]) : null;
        let depthEnabled = false;
        if (this.depthTexture !== void 0) {
          if (outputTextureDescription && this.depthTexture !== backbufferDepthStencilTextureHandle && targetTextures[0] === backbufferColorTextureHandle) {
            throw new Error(`${className} ${this.name}: the back buffer depth/stencil texture is the only depth texture allowed when the target is the back buffer color`);
          }
          const depthTextureDescription = this._frameGraph.textureManager.getTextureDescription(this.depthTexture);
          if (!outputTextureDescription) {
            outputTextureDescription = depthTextureDescription;
          }
          if (depthTextureDescription.options.samples !== outputTextureDescription.options.samples) {
            throw new Error(`${className} ${this.name}: the depth texture "${depthTextureDescription.options.labels?.[0] ?? "noname"}" (${depthTextureDescription.options.samples} samples) and the output texture "${outputTextureDescription.options.labels?.[0] ?? "noname"}" (${outputTextureDescription.options.samples} samples) must have the same number of samples`);
          }
          if (depthTextureDescription.size.width !== outputTextureDescription.size.width || depthTextureDescription.size.height !== outputTextureDescription.size.height) {
            throw new Error(`${className} ${this.name}: the depth texture (size: ${depthTextureDescription.size.width}x${depthTextureDescription.size.height}) and the target texture (size: ${outputTextureDescription.size.width}x${outputTextureDescription.size.height}) must have the same dimensions.`);
          }
          depthEnabled = true;
        }
        this._textureWidth = outputTextureDescription?.size.width ?? 1;
        this._textureHeight = outputTextureDescription?.size.height ?? 1;
        return depthEnabled;
      }
      _getTargetHandles() {
        return Array.isArray(this.targetTexture) ? this.targetTexture : [this.targetTexture];
      }
      _prepareRendering(context, depthEnabled) {
        context.setDepthStates(this.depthTest && depthEnabled, this.depthWrite && depthEnabled);
        return null;
      }
      _setLightsForShadow() {
        const lightsForShadow = /* @__PURE__ */ new Set();
        const shadowEnabled = /* @__PURE__ */ new Map();
        if (this.shadowGenerators) {
          for (const shadowGeneratorTask of this.shadowGenerators) {
            const shadowGenerator = shadowGeneratorTask.shadowGenerator;
            const light = shadowGenerator.getLight();
            if (light.isEnabled() && light.shadowEnabled) {
              lightsForShadow.add(light);
              if (shadowGeneratorTask.getClassName() === "FrameGraphCascadedShadowGeneratorTask") {
                light._shadowGenerators.set(shadowGeneratorTask.camera, shadowGenerator);
              } else {
                light._shadowGenerators.set(null, shadowGenerator);
              }
            }
          }
        }
        this._renderer.onBeforeRenderObservable.remove(this._onBeforeRenderObservable);
        this._onBeforeRenderObservable = this._renderer.onBeforeRenderObservable.add(() => {
          for (let i = 0; i < this._scene.lights.length; i++) {
            const light = this._scene.lights[i];
            if (!light.setShadowProjectionMatrix) {
              continue;
            }
            shadowEnabled.set(light, light.shadowEnabled);
            light.shadowEnabled = !this.disableShadows && lightsForShadow.has(light);
          }
        });
        this._renderer.onAfterRenderObservable.remove(this._onAfterRenderObservable);
        this._onAfterRenderObservable = this._renderer.onAfterRenderObservable.add(() => {
          for (let i = 0; i < this._scene.lights.length; i++) {
            const light = this._scene.lights[i];
            if (!light.setShadowProjectionMatrix) {
              continue;
            }
            light.shadowEnabled = shadowEnabled.get(light);
          }
        });
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      _renderTransparentMeshesWithOIT(transparentSubMeshes) {
        const renderingGroups = this._renderer.renderingManager.renderingGroups;
        const saveOIT = this._scene._useOrderIndependentTransparency;
        this._scene._useOrderIndependentTransparency = true;
        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {
          const renderingGroup = renderingGroups[index];
          if (!renderingGroup || renderingGroup._empty) {
            continue;
          }
          const excludedMeshes = this._oitRenderer.render(transparentSubMeshes);
          if (excludedMeshes.length) {
            renderingGroup._renderTransparent(excludedMeshes);
          }
        }
        this._scene._useOrderIndependentTransparency = saveOIT;
      }
      _sceneHasClusteredLights() {
        for (const light of this._scene.lights) {
          if (light.getTypeID() === LightConstants.LIGHTTYPEID_CLUSTERED_CONTAINER && light.isSupported) {
            return true;
          }
        }
        return false;
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/Tasks/Rendering/utilityLayerRendererTask.js
var FrameGraphUtilityLayerRendererTask;
var init_utilityLayerRendererTask = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Tasks/Rendering/utilityLayerRendererTask.js"() {
    init_frameGraphTask();
    init_utilityLayerRenderer();
    FrameGraphUtilityLayerRendererTask = class extends FrameGraphTask {
      /**
       * The camera used to render the utility layer.
       */
      get camera() {
        return this._camera;
      }
      set camera(value) {
        this._camera = value;
        this.layer.setRenderCamera(value);
        this.layer.utilityLayerScene.activeCamera = value;
      }
      /**
       * Creates a new utility layer renderer task.
       * @param name The name of the task.
       * @param frameGraph The frame graph the task belongs to.
       * @param scene The scene the task belongs to.
       * @param handleEvents If the utility layer should handle events.
       */
      constructor(name13, frameGraph, scene, handleEvents = true) {
        super(name13, frameGraph);
        this.layer = new UtilityLayerRenderer(scene, handleEvents, true);
        this.layer.utilityLayerScene._useCurrentFrameBuffer = true;
        this.outputTexture = this._frameGraph.textureManager.createDanglingHandle();
      }
      getClassName() {
        return "FrameGraphUtilityLayerRendererTask";
      }
      record() {
        if (!this.targetTexture || !this.camera) {
          throw new Error(`FrameGraphUtilityLayerRendererTask "${this.name}": targetTexture and camera are required`);
        }
        this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture, this.targetTexture);
        const pass = this._frameGraph.addRenderPass(this.name);
        pass.setRenderTarget(this.outputTexture);
        pass.setExecuteFunc((context) => {
          context.render(this.layer);
        });
        const passDisabled = this._frameGraph.addRenderPass(this.name + "_disabled", true);
        passDisabled.setRenderTarget(this.outputTexture);
        passDisabled.setExecuteFunc((_context) => {
        });
      }
      dispose() {
        this.layer.dispose();
        super.dispose();
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/frameGraphUtils.js
function FindMainCamera(frameGraph) {
  const mainObjectRenderer = FrameGraphUtils.FindMainObjectRenderer(frameGraph);
  if (mainObjectRenderer) {
    return mainObjectRenderer.camera;
  }
  const tasks = frameGraph.tasks;
  for (let i = tasks.length - 1; i >= 0; i--) {
    const task = tasks[i];
    if (task instanceof FrameGraphUtilityLayerRendererTask) {
      return task.camera;
    }
  }
  return null;
}
function FindMainObjectRenderer(frameGraph) {
  const objectRenderers = frameGraph.getTasksByType(FrameGraphObjectRendererTask);
  let fallbackRenderer = null;
  for (let i = objectRenderers.length - 1; i >= 0; --i) {
    const meshes = objectRenderers[i].objectList.meshes;
    if (objectRenderers[i].isMainObjectRenderer) {
      return objectRenderers[i];
    }
    if ((!meshes || meshes.length > 0) && !fallbackRenderer) {
      fallbackRenderer = objectRenderers[i];
    }
  }
  return fallbackRenderer;
}
function CreateUtilityLayerRenderer(frameFraph, handleEvents = true) {
  const scene = frameFraph.scene;
  const layer = new UtilityLayerRenderer(scene, handleEvents, true);
  layer.utilityLayerScene.activeCamera = scene.activeCamera;
  let camera = FrameGraphUtils.FindMainCamera(scene.frameGraph);
  if (!camera && scene.cameras.length > 0) {
    camera = scene.cameras[0];
  }
  if (camera) {
    layer.setRenderCamera(camera);
    layer.utilityLayerScene.activeCamera = camera;
  }
  const gizmoLayerRenderObserver = scene.onAfterRenderObservable.add(() => {
    layer.render();
  });
  layer.utilityLayerScene.onDisposeObservable.addOnce(() => {
    scene.onAfterRenderObservable.remove(gizmoLayerRenderObserver);
  });
  return layer;
}
var FrameGraphUtils;
var init_frameGraphUtils = __esm({
  "node_modules/@babylonjs/core/FrameGraph/frameGraphUtils.js"() {
    init_objectRendererTask();
    init_utilityLayerRendererTask();
    init_utilityLayerRenderer();
    FrameGraphUtils = {
      /**
       * Looks for the main camera used by the frame graph.
       * We assume that the camera used by the the last rendering task in the graph is the main camera.
       * @param frameGraph The frame graph to search in
       * @returns The main camera used by the frame graph, or null if not found
       */
      FindMainCamera,
      /**
       * Looks for the main object renderer task in the frame graph.
       * We assume that the last object renderer task that has an object list with meshes is the main object renderer.
       * @param frameGraph The frame graph to search in
       * @returns The main object renderer of the frame graph, or null if not found
       */
      FindMainObjectRenderer,
      /**
       * Creates a utility layer renderer compatible with the given frame graph.
       * @param frameFraph The frame graph to create the utility layer renderer for
       * @param handleEvents True if the utility layer renderer should handle events, false otherwise
       * @returns The created utility layer renderer
       */
      CreateUtilityLayerRenderer
    };
  }
});

// node_modules/@babylonjs/core/Debug/directionalLightFrustumViewer.js
var DirectionalLightFrustumViewer;
var init_directionalLightFrustumViewer = __esm({
  "node_modules/@babylonjs/core/Debug/directionalLightFrustumViewer.js"() {
    init_standardMaterial();
    init_math_color();
    init_math_vector();
    init_linesBuilder();
    init_mesh();
    init_mesh_vertexData();
    init_transformNode();
    init_frameGraphUtils();
    DirectionalLightFrustumViewer = class {
      /**
       * Gets or sets the transparency of the frustum planes
       */
      get transparency() {
        return this._transparency;
      }
      set transparency(alpha) {
        this._transparency = alpha;
        for (let i = 6; i < 12; ++i) {
          this._lightHelperFrustumMeshes[i].material.alpha = alpha;
        }
      }
      /**
       * true to display the edges of the frustum
       */
      get showLines() {
        return this._showLines;
      }
      set showLines(show) {
        if (this._showLines === show) {
          return;
        }
        this._showLines = show;
        for (let i = 0; i < 6; ++i) {
          this._lightHelperFrustumMeshes[i].setEnabled(show);
        }
      }
      /**
       * true to display the planes of the frustum
       */
      get showPlanes() {
        return this._showPlanes;
      }
      set showPlanes(show) {
        if (this._showPlanes === show) {
          return;
        }
        this._showPlanes = show;
        for (let i = 6; i < 12; ++i) {
          this._lightHelperFrustumMeshes[i].setEnabled(show);
        }
      }
      /**
       * Creates a new frustum viewer
       * @param light directional light to display the frustum for
       * @param camera camera used to retrieve the minZ / maxZ values if the shadowMinZ/shadowMaxZ values of the light are not setup
       */
      constructor(light, camera = null) {
        this._oldPosition = new Vector3(Number.NaN, Number.NaN, Number.NaN);
        this._oldDirection = new Vector3(Number.NaN, Number.NaN, Number.NaN);
        this._transparency = 0.3;
        this._showLines = true;
        this._showPlanes = true;
        this._scene = light.getScene();
        this._light = light;
        this._camera = camera;
        this._inverseViewMatrix = Matrix.Identity();
        this._lightHelperFrustumMeshes = [];
        this._createGeometry();
        this.show();
        this.update();
      }
      /**
       * Shows the frustum
       */
      show() {
        if (this._scene.frameGraph) {
          this._removeMeshesFromFrameGraph(this._scene.frameGraph);
          this._addMeshesToFrameGraph(this._scene.frameGraph);
        }
        this._lightHelperFrustumMeshes.forEach((mesh, index) => {
          mesh.setEnabled(index < 6 && this._showLines || index >= 6 && this._showPlanes);
        });
        this._oldPosition.set(Number.NaN, Number.NaN, Number.NaN);
        this._visible = true;
      }
      /**
       * Hides the frustum
       */
      hide() {
        if (this._scene.frameGraph) {
          this._removeMeshesFromFrameGraph(this._scene.frameGraph);
        }
        for (const mesh of this._lightHelperFrustumMeshes) {
          mesh.setEnabled(false);
        }
        this._visible = false;
      }
      _addMeshesToFrameGraph(frameGraph) {
        const objectRenderer = FrameGraphUtils.FindMainObjectRenderer(frameGraph);
        if (objectRenderer && objectRenderer.objectList.meshes) {
          for (const mesh of this._lightHelperFrustumMeshes) {
            objectRenderer.objectList.meshes.push(mesh);
          }
        }
      }
      _removeMeshesFromFrameGraph(frameGraph) {
        const objectRenderer = FrameGraphUtils.FindMainObjectRenderer(frameGraph);
        if (objectRenderer && objectRenderer.objectList.meshes) {
          for (const mesh of this._lightHelperFrustumMeshes) {
            const index = objectRenderer.objectList.meshes.indexOf(mesh);
            if (index !== -1) {
              objectRenderer.objectList.meshes.splice(index, 1);
            }
          }
        }
      }
      /**
       * Updates the frustum.
       * Call this method to update the frustum view if the light has changed position/direction
       */
      update() {
        if (!this._visible) {
          return;
        }
        if (this._oldPosition.equals(this._light.position) && this._oldDirection.equals(this._light.direction) && this._oldAutoCalc === this._light.autoCalcShadowZBounds && this._oldMinZ === this._light.shadowMinZ && this._oldMaxZ === this._light.shadowMaxZ && this._oldOrthoLeft === this._light.orthoLeft && this._oldOrthoRight === this._light.orthoRight && this._oldOrthoTop === this._light.orthoTop && this._oldOrthoBottom === this._light.orthoBottom) {
          return;
        }
        this._oldPosition.copyFrom(this._light.position);
        this._oldDirection.copyFrom(this._light.direction);
        this._oldAutoCalc = this._light.autoCalcShadowZBounds;
        this._oldMinZ = this._light.shadowMinZ;
        this._oldMaxZ = this._light.shadowMaxZ;
        this._oldOrthoLeft = this._light.orthoLeft;
        this._oldOrthoRight = this._light.orthoRight;
        this._oldOrthoTop = this._light.orthoTop;
        this._oldOrthoBottom = this._light.orthoBottom;
        TmpVectors.Vector3[0].set(this._light.orthoLeft, this._light.orthoBottom, this._light.shadowMinZ !== void 0 ? this._light.shadowMinZ : this._camera?.minZ ?? 0);
        TmpVectors.Vector3[1].set(this._light.orthoRight, this._light.orthoTop, this._light.shadowMaxZ !== void 0 ? this._light.shadowMaxZ : this._camera?.maxZ ?? 1e4);
        const invLightView = this._getInvertViewMatrix();
        TmpVectors.Vector3[2].copyFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[0].z);
        TmpVectors.Vector3[3].copyFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z);
        TmpVectors.Vector3[4].copyFromFloats(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z);
        TmpVectors.Vector3[5].copyFromFloats(TmpVectors.Vector3[0].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[0].z);
        Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[2], invLightView, TmpVectors.Vector3[2]);
        Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[3], invLightView, TmpVectors.Vector3[3]);
        Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[4], invLightView, TmpVectors.Vector3[4]);
        Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[5], invLightView, TmpVectors.Vector3[5]);
        TmpVectors.Vector3[6].copyFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[1].z);
        TmpVectors.Vector3[7].copyFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[1].z);
        TmpVectors.Vector3[8].copyFromFloats(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[1].z);
        TmpVectors.Vector3[9].copyFromFloats(TmpVectors.Vector3[0].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[1].z);
        Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[6], invLightView, TmpVectors.Vector3[6]);
        Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[7], invLightView, TmpVectors.Vector3[7]);
        Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[8], invLightView, TmpVectors.Vector3[8]);
        Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[9], invLightView, TmpVectors.Vector3[9]);
        CreateLines("nearlines", { updatable: true, points: this._nearLinesPoints, instance: this._lightHelperFrustumMeshes[0] }, this._scene);
        CreateLines("farlines", { updatable: true, points: this._farLinesPoints, instance: this._lightHelperFrustumMeshes[1] }, this._scene);
        CreateLines("trlines", { updatable: true, points: this._trLinesPoints, instance: this._lightHelperFrustumMeshes[2] }, this._scene);
        CreateLines("brlines", { updatable: true, points: this._brLinesPoints, instance: this._lightHelperFrustumMeshes[3] }, this._scene);
        CreateLines("tllines", { updatable: true, points: this._tlLinesPoints, instance: this._lightHelperFrustumMeshes[4] }, this._scene);
        CreateLines("bllines", { updatable: true, points: this._blLinesPoints, instance: this._lightHelperFrustumMeshes[5] }, this._scene);
        TmpVectors.Vector3[2].toArray(this._nearPlaneVertices, 0);
        TmpVectors.Vector3[3].toArray(this._nearPlaneVertices, 3);
        TmpVectors.Vector3[4].toArray(this._nearPlaneVertices, 6);
        TmpVectors.Vector3[5].toArray(this._nearPlaneVertices, 9);
        this._lightHelperFrustumMeshes[6].geometry?.updateVerticesDataDirectly("position", this._nearPlaneVertices, 0);
        TmpVectors.Vector3[6].toArray(this._farPlaneVertices, 0);
        TmpVectors.Vector3[7].toArray(this._farPlaneVertices, 3);
        TmpVectors.Vector3[8].toArray(this._farPlaneVertices, 6);
        TmpVectors.Vector3[9].toArray(this._farPlaneVertices, 9);
        this._lightHelperFrustumMeshes[7].geometry?.updateVerticesDataDirectly("position", this._farPlaneVertices, 0);
        TmpVectors.Vector3[2].toArray(this._rightPlaneVertices, 0);
        TmpVectors.Vector3[6].toArray(this._rightPlaneVertices, 3);
        TmpVectors.Vector3[7].toArray(this._rightPlaneVertices, 6);
        TmpVectors.Vector3[3].toArray(this._rightPlaneVertices, 9);
        this._lightHelperFrustumMeshes[8].geometry?.updateVerticesDataDirectly("position", this._rightPlaneVertices, 0);
        TmpVectors.Vector3[5].toArray(this._leftPlaneVertices, 0);
        TmpVectors.Vector3[9].toArray(this._leftPlaneVertices, 3);
        TmpVectors.Vector3[8].toArray(this._leftPlaneVertices, 6);
        TmpVectors.Vector3[4].toArray(this._leftPlaneVertices, 9);
        this._lightHelperFrustumMeshes[9].geometry?.updateVerticesDataDirectly("position", this._leftPlaneVertices, 0);
        TmpVectors.Vector3[2].toArray(this._topPlaneVertices, 0);
        TmpVectors.Vector3[6].toArray(this._topPlaneVertices, 3);
        TmpVectors.Vector3[9].toArray(this._topPlaneVertices, 6);
        TmpVectors.Vector3[5].toArray(this._topPlaneVertices, 9);
        this._lightHelperFrustumMeshes[10].geometry?.updateVerticesDataDirectly("position", this._topPlaneVertices, 0);
        TmpVectors.Vector3[3].toArray(this._bottomPlaneVertices, 0);
        TmpVectors.Vector3[7].toArray(this._bottomPlaneVertices, 3);
        TmpVectors.Vector3[8].toArray(this._bottomPlaneVertices, 6);
        TmpVectors.Vector3[4].toArray(this._bottomPlaneVertices, 9);
        this._lightHelperFrustumMeshes[11].geometry?.updateVerticesDataDirectly("position", this._bottomPlaneVertices, 0);
      }
      /**
       * Dispose of the class / remove the frustum view
       */
      dispose() {
        if (this._scene.frameGraph) {
          this._removeMeshesFromFrameGraph(this._scene.frameGraph);
        }
        for (const mesh of this._lightHelperFrustumMeshes) {
          mesh.material?.dispose();
          mesh.dispose();
        }
        this._rootNode.dispose();
      }
      _createGeometry() {
        this._rootNode = new TransformNode("directionalLightHelperRoot_" + this._light.name, this._scene);
        this._rootNode.parent = this._light.parent;
        this._nearLinesPoints = [TmpVectors.Vector3[0], TmpVectors.Vector3[1], TmpVectors.Vector3[2], TmpVectors.Vector3[3], TmpVectors.Vector3[4]];
        const nearLines = CreateLines("nearlines", { updatable: true, points: this._nearLinesPoints }, this._scene);
        nearLines.parent = this._rootNode;
        nearLines.alwaysSelectAsActiveMesh = true;
        this._farLinesPoints = [TmpVectors.Vector3[5], TmpVectors.Vector3[6], TmpVectors.Vector3[7], TmpVectors.Vector3[8], TmpVectors.Vector3[9]];
        const farLines = CreateLines("farlines", { updatable: true, points: this._farLinesPoints }, this._scene);
        farLines.parent = this._rootNode;
        farLines.alwaysSelectAsActiveMesh = true;
        this._trLinesPoints = [TmpVectors.Vector3[10], TmpVectors.Vector3[11]];
        const trLines = CreateLines("trlines", { updatable: true, points: this._trLinesPoints }, this._scene);
        trLines.parent = this._rootNode;
        trLines.alwaysSelectAsActiveMesh = true;
        this._brLinesPoints = [TmpVectors.Vector3[12], TmpVectors.Vector3[0]];
        const brLines = CreateLines("brlines", { updatable: true, points: this._brLinesPoints }, this._scene);
        brLines.parent = this._rootNode;
        brLines.alwaysSelectAsActiveMesh = true;
        this._tlLinesPoints = [TmpVectors.Vector3[1], TmpVectors.Vector3[2]];
        const tlLines = CreateLines("tllines", { updatable: true, points: this._tlLinesPoints }, this._scene);
        tlLines.parent = this._rootNode;
        tlLines.alwaysSelectAsActiveMesh = true;
        this._blLinesPoints = [TmpVectors.Vector3[3], TmpVectors.Vector3[4]];
        const blLines = CreateLines("bllines", { updatable: true, points: this._blLinesPoints }, this._scene);
        blLines.parent = this._rootNode;
        blLines.alwaysSelectAsActiveMesh = true;
        this._lightHelperFrustumMeshes.push(nearLines, farLines, trLines, brLines, tlLines, blLines);
        const makePlane = (name13, color, positions) => {
          const plane = new Mesh(name13 + "plane", this._scene);
          const mat = new StandardMaterial(name13 + "PlaneMat", this._scene);
          plane.material = mat;
          plane.parent = this._rootNode;
          plane.alwaysSelectAsActiveMesh = true;
          mat.emissiveColor = color;
          mat.alpha = this.transparency;
          mat.backFaceCulling = false;
          mat.disableLighting = true;
          const indices = [0, 1, 2, 0, 2, 3];
          const vertexData = new VertexData();
          vertexData.positions = positions;
          vertexData.indices = indices;
          vertexData.applyToMesh(plane, true);
          this._lightHelperFrustumMeshes.push(plane);
        };
        this._nearPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        this._farPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        this._rightPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        this._leftPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        this._topPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        this._bottomPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        makePlane("near", new Color3(1, 0, 0), this._nearPlaneVertices);
        makePlane("far", new Color3(0.3, 0, 0), this._farPlaneVertices);
        makePlane("right", new Color3(0, 1, 0), this._rightPlaneVertices);
        makePlane("left", new Color3(0, 0.3, 0), this._leftPlaneVertices);
        makePlane("top", new Color3(0, 0, 1), this._topPlaneVertices);
        makePlane("bottom", new Color3(0, 0, 0.3), this._bottomPlaneVertices);
        this._nearLinesPoints[0] = TmpVectors.Vector3[2];
        this._nearLinesPoints[1] = TmpVectors.Vector3[3];
        this._nearLinesPoints[2] = TmpVectors.Vector3[4];
        this._nearLinesPoints[3] = TmpVectors.Vector3[5];
        this._nearLinesPoints[4] = TmpVectors.Vector3[2];
        this._farLinesPoints[0] = TmpVectors.Vector3[6];
        this._farLinesPoints[1] = TmpVectors.Vector3[7];
        this._farLinesPoints[2] = TmpVectors.Vector3[8];
        this._farLinesPoints[3] = TmpVectors.Vector3[9];
        this._farLinesPoints[4] = TmpVectors.Vector3[6];
        this._trLinesPoints[0] = TmpVectors.Vector3[2];
        this._trLinesPoints[1] = TmpVectors.Vector3[6];
        this._brLinesPoints[0] = TmpVectors.Vector3[3];
        this._brLinesPoints[1] = TmpVectors.Vector3[7];
        this._tlLinesPoints[0] = TmpVectors.Vector3[4];
        this._tlLinesPoints[1] = TmpVectors.Vector3[8];
        this._blLinesPoints[0] = TmpVectors.Vector3[5];
        this._blLinesPoints[1] = TmpVectors.Vector3[9];
      }
      _getInvertViewMatrix() {
        Matrix.LookAtLHToRef(this._light.position, this._light.position.add(this._light.direction), Vector3.UpReadOnly, this._inverseViewMatrix);
        this._inverseViewMatrix.invertToRef(this._inverseViewMatrix);
        return this._inverseViewMatrix;
      }
    };
  }
});

// node_modules/@babylonjs/core/Instrumentation/timeToken.js
var _TimeToken;
var init_timeToken = __esm({
  "node_modules/@babylonjs/core/Instrumentation/timeToken.js"() {
    _TimeToken = class {
      constructor() {
        this._timeElapsedQueryEnded = false;
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.timeQuery.js
var init_abstractEngine_timeQuery = __esm({
  "node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.timeQuery.js"() {
    init_abstractEngine();
    init_perfCounter();
    AbstractEngine.prototype.getGPUFrameTimeCounter = function() {
      if (!this._gpuFrameTime) {
        this._gpuFrameTime = new PerfCounter();
      }
      return this._gpuFrameTime;
    };
    AbstractEngine.prototype.captureGPUFrameTime = function(value) {
    };
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.query.js
var init_engine_query = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.query.js"() {
    init_thinEngine();
    init_abstractMesh();
    init_timeToken();
    init_abstractEngine_timeQuery();
    init_abstractEngine_query();
    ThinEngine.prototype.createQuery = function() {
      const query = this._gl.createQuery();
      if (!query) {
        throw new Error("Unable to create Occlusion Query");
      }
      return query;
    };
    ThinEngine.prototype.deleteQuery = function(query) {
      this._gl.deleteQuery(query);
      return this;
    };
    ThinEngine.prototype.isQueryResultAvailable = function(query) {
      return this._gl.getQueryParameter(query, this._gl.QUERY_RESULT_AVAILABLE);
    };
    ThinEngine.prototype.getQueryResult = function(query) {
      return this._gl.getQueryParameter(query, this._gl.QUERY_RESULT);
    };
    ThinEngine.prototype.beginOcclusionQuery = function(algorithmType, query) {
      const glAlgorithm = this._getGlAlgorithmType(algorithmType);
      this._gl.beginQuery(glAlgorithm, query);
      return true;
    };
    ThinEngine.prototype.endOcclusionQuery = function(algorithmType) {
      const glAlgorithm = this._getGlAlgorithmType(algorithmType);
      this._gl.endQuery(glAlgorithm);
      return this;
    };
    ThinEngine.prototype._createTimeQuery = function() {
      const timerQuery = this.getCaps().timerQuery;
      if (timerQuery.createQueryEXT) {
        return timerQuery.createQueryEXT();
      }
      return this.createQuery();
    };
    ThinEngine.prototype._deleteTimeQuery = function(query) {
      const timerQuery = this.getCaps().timerQuery;
      if (timerQuery.deleteQueryEXT) {
        timerQuery.deleteQueryEXT(query);
        return;
      }
      this.deleteQuery(query);
    };
    ThinEngine.prototype._getTimeQueryResult = function(query) {
      const timerQuery = this.getCaps().timerQuery;
      if (timerQuery.getQueryObjectEXT) {
        return timerQuery.getQueryObjectEXT(query, timerQuery.QUERY_RESULT_EXT);
      }
      return this.getQueryResult(query);
    };
    ThinEngine.prototype._getTimeQueryAvailability = function(query) {
      const timerQuery = this.getCaps().timerQuery;
      if (timerQuery.getQueryObjectEXT) {
        return timerQuery.getQueryObjectEXT(query, timerQuery.QUERY_RESULT_AVAILABLE_EXT);
      }
      return this.isQueryResultAvailable(query);
    };
    ThinEngine.prototype.startTimeQuery = function() {
      const caps = this.getCaps();
      const timerQuery = caps.timerQuery;
      if (!timerQuery) {
        return null;
      }
      const token = new _TimeToken();
      this._gl.getParameter(timerQuery.GPU_DISJOINT_EXT);
      if (caps.canUseTimestampForTimerQuery) {
        token._startTimeQuery = this._createTimeQuery();
        if (token._startTimeQuery) {
          timerQuery.queryCounterEXT(token._startTimeQuery, timerQuery.TIMESTAMP_EXT);
        }
      } else {
        if (this._currentNonTimestampToken) {
          return this._currentNonTimestampToken;
        }
        token._timeElapsedQuery = this._createTimeQuery();
        if (token._timeElapsedQuery) {
          if (timerQuery.beginQueryEXT) {
            timerQuery.beginQueryEXT(timerQuery.TIME_ELAPSED_EXT, token._timeElapsedQuery);
          } else {
            this._gl.beginQuery(timerQuery.TIME_ELAPSED_EXT, token._timeElapsedQuery);
          }
        }
        this._currentNonTimestampToken = token;
      }
      return token;
    };
    ThinEngine.prototype.endTimeQuery = function(token) {
      const caps = this.getCaps();
      const timerQuery = caps.timerQuery;
      if (!timerQuery || !token) {
        return -1;
      }
      if (caps.canUseTimestampForTimerQuery) {
        if (!token._startTimeQuery) {
          return -1;
        }
        if (!token._endTimeQuery) {
          token._endTimeQuery = this._createTimeQuery();
          if (token._endTimeQuery) {
            timerQuery.queryCounterEXT(token._endTimeQuery, timerQuery.TIMESTAMP_EXT);
          }
        }
      } else if (!token._timeElapsedQueryEnded) {
        if (!token._timeElapsedQuery) {
          return -1;
        }
        if (timerQuery.endQueryEXT) {
          timerQuery.endQueryEXT(timerQuery.TIME_ELAPSED_EXT);
        } else {
          this._gl.endQuery(timerQuery.TIME_ELAPSED_EXT);
          this._currentNonTimestampToken = null;
        }
        token._timeElapsedQueryEnded = true;
      }
      const disjoint = this._gl.getParameter(timerQuery.GPU_DISJOINT_EXT);
      let available = false;
      if (token._endTimeQuery) {
        available = this._getTimeQueryAvailability(token._endTimeQuery);
      } else if (token._timeElapsedQuery) {
        available = this._getTimeQueryAvailability(token._timeElapsedQuery);
      }
      if (available && !disjoint) {
        let result = 0;
        if (caps.canUseTimestampForTimerQuery) {
          if (!token._startTimeQuery || !token._endTimeQuery) {
            return -1;
          }
          const timeStart = this._getTimeQueryResult(token._startTimeQuery);
          const timeEnd = this._getTimeQueryResult(token._endTimeQuery);
          result = timeEnd - timeStart;
          this._deleteTimeQuery(token._startTimeQuery);
          this._deleteTimeQuery(token._endTimeQuery);
          token._startTimeQuery = null;
          token._endTimeQuery = null;
        } else {
          if (!token._timeElapsedQuery) {
            return -1;
          }
          result = this._getTimeQueryResult(token._timeElapsedQuery);
          this._deleteTimeQuery(token._timeElapsedQuery);
          token._timeElapsedQuery = null;
          token._timeElapsedQueryEnded = false;
        }
        return result;
      }
      return -1;
    };
    ThinEngine.prototype.captureGPUFrameTime = function(value) {
      if (value === this._captureGPUFrameTime) {
        return;
      }
      this._captureGPUFrameTime = value;
      if (value) {
        const gpuFrameTime = this.getGPUFrameTimeCounter();
        this._onBeginFrameObserver = this.onBeginFrameObservable.add(() => {
          if (!this._gpuFrameTimeToken) {
            this._gpuFrameTimeToken = this.startTimeQuery();
          }
        });
        this._onEndFrameObserver = this.onEndFrameObservable.add(() => {
          if (!this._gpuFrameTimeToken) {
            return;
          }
          const time = this.endTimeQuery(this._gpuFrameTimeToken);
          if (time > -1) {
            this._gpuFrameTimeToken = null;
            gpuFrameTime.fetchNewFrame();
            gpuFrameTime.addCount(time, true);
          }
        });
      } else {
        this.onBeginFrameObservable.remove(this._onBeginFrameObserver);
        this._onBeginFrameObserver = null;
        this.onEndFrameObservable.remove(this._onEndFrameObserver);
        this._onEndFrameObserver = null;
      }
    };
    ThinEngine.prototype._getGlAlgorithmType = function(algorithmType) {
      return algorithmType === AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE ? this._gl.ANY_SAMPLES_PASSED_CONSERVATIVE : this._gl.ANY_SAMPLES_PASSED;
    };
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.transformFeedback.js
var _forceTransformFeedbackToBundle;
var init_engine_transformFeedback = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.transformFeedback.js"() {
    init_engine();
    _forceTransformFeedbackToBundle = true;
    Engine.prototype.createTransformFeedback = function() {
      const transformFeedback = this._gl.createTransformFeedback();
      if (!transformFeedback) {
        throw new Error("Unable to create Transform Feedback");
      }
      return transformFeedback;
    };
    Engine.prototype.deleteTransformFeedback = function(value) {
      this._gl.deleteTransformFeedback(value);
    };
    Engine.prototype.bindTransformFeedback = function(value) {
      this._gl.bindTransformFeedback(this._gl.TRANSFORM_FEEDBACK, value);
    };
    Engine.prototype.beginTransformFeedback = function(usePoints = true) {
      this._gl.beginTransformFeedback(usePoints ? this._gl.POINTS : this._gl.TRIANGLES);
    };
    Engine.prototype.endTransformFeedback = function() {
      this._gl.endTransformFeedback();
    };
    Engine.prototype.setTranformFeedbackVaryings = function(program, value) {
      this._gl.transformFeedbackVaryings(program, value, this._gl.INTERLEAVED_ATTRIBS);
    };
    Engine.prototype.bindTransformFeedbackBuffer = function(value) {
      this._gl.bindBufferBase(this._gl.TRANSFORM_FEEDBACK_BUFFER, 0, value ? value.underlyingResource : null);
    };
    Engine.prototype.readTransformFeedbackBuffer = function(target) {
      this._gl.getBufferSubData(this._gl.TRANSFORM_FEEDBACK_BUFFER, 0, target);
    };
  }
});

// node_modules/@babylonjs/core/Misc/copyTextureToTexture.js
var ConversionMode, CopyTextureToTexture;
var init_copyTextureToTexture = __esm({
  "node_modules/@babylonjs/core/Misc/copyTextureToTexture.js"() {
    init_effectRenderer();
    (function(ConversionMode2) {
      ConversionMode2[ConversionMode2["None"] = 0] = "None";
      ConversionMode2[ConversionMode2["ToLinearSpace"] = 1] = "ToLinearSpace";
      ConversionMode2[ConversionMode2["ToGammaSpace"] = 2] = "ToGammaSpace";
    })(ConversionMode || (ConversionMode = {}));
    CopyTextureToTexture = class {
      /**
       * Gets the shader language
       */
      get shaderLanguage() {
        return this._shaderLanguage;
      }
      /**
       * Gets the effect wrapper used for the copy
       */
      get effectWrapper() {
        return this._effectWrapper;
      }
      /**
       * Gets or sets the source texture
       */
      get source() {
        return this._source;
      }
      set source(texture) {
        this._source = texture;
      }
      /**
       * Gets or sets the LOD level to copy from the source texture
       */
      get lodLevel() {
        return this._lodLevel;
      }
      set lodLevel(level) {
        this._lodLevel = level;
      }
      _textureIsInternal(texture) {
        return texture.getInternalTexture === void 0;
      }
      /**
       * Constructs a new instance of the class
       * @param engine The engine to use for the copy
       * @param isDepthTexture True means that we should write (using gl_FragDepth) into the depth texture attached to the destination (default: false)
       * @param sameSizeCopy True means that the copy will be done without any sampling (more efficient, but requires the source and destination to be of the same size) (default: false)
       */
      constructor(engine, isDepthTexture = false, sameSizeCopy = false) {
        this._shaderLanguage = 0;
        this._shadersLoaded = false;
        this._engine = engine;
        this._isDepthTexture = isDepthTexture;
        this._lodLevel = 0;
        this._conversion = 0;
        this._renderer = new EffectRenderer(engine);
        this._initShaderSourceAsync(isDepthTexture, sameSizeCopy);
      }
      async _initShaderSourceAsync(isDepthTexture, sameSizeCopy) {
        const engine = this._engine;
        if (engine.isWebGPU) {
          this._shaderLanguage = 1;
          await import("./copyTextureToTexture.fragment-ZLPEL3MI.js");
        } else {
          await import("./copyTextureToTexture.fragment-FIGJUY45.js");
        }
        this._shadersLoaded = true;
        const defines = [];
        if (isDepthTexture) {
          defines.push("#define DEPTH_TEXTURE");
        }
        if (sameSizeCopy) {
          defines.push("#define NO_SAMPLER");
        }
        this._effectWrapper = new EffectWrapper({
          engine,
          name: "CopyTextureToTexture",
          fragmentShader: "copyTextureToTexture",
          useShaderStore: true,
          uniformNames: ["conversion", "lodLevel"],
          samplerNames: ["textureSampler"],
          defines,
          shaderLanguage: this._shaderLanguage
        });
        this._effectWrapper.onApplyObservable.add(() => {
          if (isDepthTexture) {
            engine.setState(false);
            engine.setDepthBuffer(true);
            engine.depthCullingState.depthMask = true;
            engine.depthCullingState.depthFunc = 519;
          } else {
            engine.depthCullingState.depthMask = false;
          }
          if (this._textureIsInternal(this._source)) {
            this._effectWrapper.effect._bindTexture("textureSampler", this._source);
          } else {
            this._effectWrapper.effect.setTexture("textureSampler", this._source);
          }
          this._effectWrapper.effect.setFloat("conversion", this._conversion);
          this._effectWrapper.effect.setFloat("lodLevel", this._lodLevel);
        });
      }
      /**
       * Indicates if the effect is ready to be used for the copy
       * @returns true if "copy" can be called without delay, else false
       */
      isReady() {
        return this._shadersLoaded && !!this._effectWrapper?.effect?.isReady();
      }
      /**
       * Copy one texture into another
       * @param source The source texture
       * @param destination The destination texture. If null, copy the source to the currently bound framebuffer
       * @param conversion The conversion mode that should be applied when copying
       * @param lod The LOD level to copy from the source texture
       * @returns
       */
      copy(source, destination = null, conversion = 0, lod = 0) {
        if (!this.isReady()) {
          return false;
        }
        this._source = source;
        this._conversion = conversion;
        this._lodLevel = lod;
        const engineDepthFunc = this._engine.getDepthFunction();
        const engineDepthMask = this._engine.getDepthWrite();
        this._renderer.render(this._effectWrapper, destination);
        this._engine.setDepthWrite(engineDepthMask);
        if (this._isDepthTexture && engineDepthFunc) {
          this._engine.setDepthFunction(engineDepthFunc);
        }
        return true;
      }
      /**
       * Releases all the resources used by the class
       */
      dispose() {
        this._effectWrapper?.dispose();
        this._renderer.dispose();
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/frameGraphContext.js
var FrameGraphContext;
var init_frameGraphContext = __esm({
  "node_modules/@babylonjs/core/FrameGraph/frameGraphContext.js"() {
    FrameGraphContext = class {
      /** @internal */
      constructor(_engine, _textureManager, _scene) {
        this._engine = _engine;
        this._textureManager = _textureManager;
        this._scene = _scene;
        this.enableDebugMarkers = true;
      }
      /**
       * Renders a component without managing the render target.
       * Use this method when you have a component that handles its own rendering logic which is not fully integrated into the frame graph system.
       * @param component The component to render.
       * @param intermediateRendering If true, the scene's intermediate rendering flag will be set to true during the render call (default: true)
       */
      renderUnmanaged(component, intermediateRendering = true) {
        const currentRenderTarget = this._engine._currentRenderTarget;
        this._scene.incrementRenderId();
        this._scene.resetCachedMaterial();
        this._scene._intermediateRendering = intermediateRendering;
        component.render();
        this._scene._intermediateRendering = false;
        if (this._engine._currentRenderTarget !== currentRenderTarget) {
          if (!currentRenderTarget) {
            this._engine.restoreDefaultFramebuffer();
          } else {
            this._engine.bindFramebuffer(currentRenderTarget);
          }
        }
      }
      /**
       * Gets a texture from a handle.
       * Note that if the texture is a history texture, the read texture for the current frame will be returned.
       * @param handle The handle of the texture
       * @returns The texture or null if not found
       */
      getTextureFromHandle(handle) {
        return this._textureManager.getTextureFromHandle(handle);
      }
      /**
       * Pushes a debug group to the engine's debug stack.
       * @param name The name of the debug group
       */
      pushDebugGroup(name13) {
        this.enableDebugMarkers && this._engine._debugPushGroup?.(name13);
      }
      /**
       * Pops a debug group from the engine's debug stack.
       */
      popDebugGroup() {
        this.enableDebugMarkers && this._engine._debugPopGroup?.();
      }
      /**
       * Inserts a debug marker in the engine's debug stack.
       * @param text The text of the debug marker
       */
      insertDebugMarker(text) {
        this.enableDebugMarkers && this._engine._debugInsertMarker?.(text);
      }
      /**
       * Saves the current depth states (depth testing and depth writing)
       */
      saveDepthStates() {
        this._depthTest = this._engine.getDepthBuffer();
        this._depthWrite = this._engine.getDepthWrite();
      }
      /**
       * Restores the depth states saved by saveDepthStates
       */
      restoreDepthStates() {
        this._engine.setDepthBuffer(this._depthTest);
        this._engine.setDepthWrite(this._depthWrite);
      }
      /**
       * Sets the depth states for the current render target
       * @param depthTest If true, depth testing is enabled
       * @param depthWrite If true, depth writing is enabled
       */
      setDepthStates(depthTest, depthWrite) {
        this._engine.setDepthBuffer(depthTest);
        this._engine.setDepthWrite(depthWrite);
      }
      /**
       * Sets the current viewport
       * @param viewport defines the viewport element to be used
       * @param requiredWidth defines the width required for rendering. If not provided, the width of the render texture is used.
       * @param requiredHeight defines the height required for rendering. If not provided the height of the render texture is used.
       */
      setViewport(viewport, requiredWidth, requiredHeight) {
        this._engine.setViewport(viewport, requiredHeight, requiredWidth);
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/frameGraphRenderContext.js
var SamplingModeHasMipMapFiltering, FrameGraphRenderContext;
var init_frameGraphRenderContext = __esm({
  "node_modules/@babylonjs/core/FrameGraph/frameGraphRenderContext.js"() {
    init_effectRenderer();
    init_copyTextureToTexture();
    init_frameGraphContext();
    init_textureHelper_functions();
    SamplingModeHasMipMapFiltering = [
      false,
      // not used
      false,
      // TEXTURE_NEAREST_SAMPLINGMODE / TEXTURE_NEAREST_NEAREST
      false,
      // TEXTURE_BILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR
      true,
      // TEXTURE_TRILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR_MIPLINEAR
      true,
      // TEXTURE_NEAREST_NEAREST_MIPNEAREST
      true,
      // TEXTURE_NEAREST_LINEAR_MIPNEAREST
      true,
      // TEXTURE_NEAREST_LINEAR_MIPLINEAR
      false,
      // TEXTURE_NEAREST_LINEAR
      true,
      // TEXTURE_NEAREST_NEAREST_MIPLINEAR
      true,
      // TEXTURE_LINEAR_NEAREST_MIPNEAREST
      true,
      // TEXTURE_LINEAR_NEAREST_MIPLINEAR
      true,
      // TEXTURE_LINEAR_LINEAR_MIPNEAREST
      false
      // TEXTURE_LINEAR_NEAREST
    ];
    FrameGraphRenderContext = class _FrameGraphRenderContext extends FrameGraphContext {
      static _IsObjectRenderer(value) {
        return value.initRender !== void 0;
      }
      /** @internal */
      constructor(engine, textureManager, scene) {
        super(engine, textureManager, scene);
        this._renderTargetIsBound = true;
        this._effectRenderer = new EffectRenderer(this._engine);
        this._effectRendererBack = new EffectRenderer(this._engine, {
          positions: [1, 1, -1, 1, -1, -1, 1, -1],
          indices: [0, 2, 1, 0, 3, 2]
        });
        this._copyTexture = new CopyTextureToTexture(this._engine);
        this._copyDepthTexture = new CopyTextureToTexture(this._engine, true);
      }
      /**
       * Checks whether a texture handle points to the backbuffer's color or depth texture
       * @param handle The handle to check
       * @returns True if the handle points to the backbuffer's color or depth texture, otherwise false
       */
      isBackbuffer(handle) {
        return this._textureManager._isBackbuffer(handle);
      }
      /**
       * Checks whether a texture handle points to the backbuffer's color texture
       * @param handle The handle to check
       * @returns True if the handle points to the backbuffer's color texture, otherwise false
       */
      isBackbufferColor(handle) {
        return this._textureManager.isBackbufferColor(handle);
      }
      /**
       * Checks whether a texture handle points to the backbuffer's depth texture
       * @param handle The handle to check
       * @returns True if the handle points to the backbuffer's depth texture, otherwise false
       */
      isBackbufferDepthStencil(handle) {
        return this._textureManager.isBackbufferDepthStencil(handle);
      }
      /**
       * Creates a (frame graph) render target wrapper
       * Note that renderTargets or renderTargetDepth can be undefined, but not both at the same time!
       * @param name Name of the render target wrapper
       * @param renderTargets Render target handles (textures) to use
       * @param renderTargetDepth Render target depth handle (texture) to use
       * @param depthReadOnly If true, the depth buffer will be read-only
       * @param stencilReadOnly If true, the stencil buffer will be read-only
       * @returns The created render target wrapper
       */
      createRenderTarget(name13, renderTargets, renderTargetDepth, depthReadOnly, stencilReadOnly) {
        return this._textureManager.createRenderTarget(name13, renderTargets, renderTargetDepth, depthReadOnly, stencilReadOnly);
      }
      /**
       * Clears the current render buffer or the current render target (if any is set up)
       * @param color Defines the color to use
       * @param backBuffer Defines if the back buffer must be cleared
       * @param depth Defines if the depth buffer must be cleared
       * @param stencil Defines if the stencil buffer must be cleared
       * @param stencilClearValue Defines the value to use to clear the stencil buffer (default is 0)
       */
      clear(color, backBuffer, depth, stencil, stencilClearValue = 0) {
        this._applyRenderTarget();
        this._engine.clear(color, backBuffer, depth, stencil, stencilClearValue);
      }
      /**
       * Clears the color attachments of the current render target
       * @param color Defines the color to use
       * @param attachments The attachments to clear
       */
      clearColorAttachments(color, attachments) {
        this._applyRenderTarget();
        this._engine.bindAttachments(attachments);
        this._engine.clear(color, true, false, false);
      }
      /**
       * Clears all attachments (color(s) + depth/stencil) of the current render target
       * @param color Defines the color to use
       * @param attachments The attachments to clear
       * @param backBuffer Defines if the back buffer must be cleared
       * @param depth Defines if the depth buffer must be cleared
       * @param stencil Defines if the stencil buffer must be cleared
       * @param stencilClearValue Defines the value to use to clear the stencil buffer (default is 0)
       */
      clearAttachments(color, attachments, backBuffer, depth, stencil, stencilClearValue = 0) {
        this._applyRenderTarget();
        this._engine.bindAttachments(attachments);
        this._engine.clear(color, backBuffer, depth, stencil, stencilClearValue);
      }
      /**
       * Binds the attachments to the current render target
       * @param attachments The attachments to bind
       */
      bindAttachments(attachments) {
        this._applyRenderTarget();
        this._engine.bindAttachments(attachments);
      }
      /**
       * Generates mipmaps for the current render target
       * @param handle Optional handle of the texture to generate mipmaps for (if not provided, will generate mipmaps for all textures in the current render target)
       */
      generateMipMaps(handle) {
        if (handle !== void 0) {
          const internalTexture = this._textureManager.getTextureFromHandle(handle);
          if (internalTexture) {
            this._engine.generateMipmaps(internalTexture);
          }
          return;
        }
        if (this._currentRenderTarget?.renderTargetWrapper === void 0) {
          return;
        }
        if (this._engine._currentRenderTarget && (!this._engine.isWebGPU || this._renderTargetIsBound)) {
          this._engine.unBindFramebuffer(this._engine._currentRenderTarget);
          this._renderTargetIsBound = false;
        }
        const textures = this._currentRenderTarget.renderTargetWrapper.textures;
        if (textures) {
          for (const texture of textures) {
            this._engine.generateMipmaps(texture);
          }
        }
      }
      /**
       * Sets the texture sampling mode for a given texture handle
       * @param handle Handle of the texture to set the sampling mode for
       * @param samplingMode Sampling mode to set
       */
      setTextureSamplingMode(handle, samplingMode) {
        const internalTexture = this._textureManager.getTextureFromHandle(handle);
        if (internalTexture && internalTexture.samplingMode !== samplingMode) {
          internalTexture.useMipMaps = SamplingModeHasMipMapFiltering[samplingMode];
          this._engine.updateTextureSamplingMode(samplingMode, internalTexture);
        }
      }
      /**
       * Binds a texture handle to a given effect (resolves the handle to a texture and binds it to the effect)
       * @param effect The effect to bind the texture to
       * @param name The name of the texture in the effect
       * @param handle The handle of the texture to bind
       */
      bindTextureHandle(effect, name13, handle) {
        let texture;
        const historyEntry = this._textureManager._historyTextures.get(handle);
        if (historyEntry) {
          texture = historyEntry.textures[historyEntry.index];
          if (this._currentRenderTarget !== void 0 && this._currentRenderTarget.renderTargetWrapper !== void 0 && this._currentRenderTarget.renderTargetWrapper.textures.includes(texture)) {
            texture = historyEntry.textures[historyEntry.index ^ 1];
          }
        } else {
          texture = this._textureManager._textures.get(handle).texture;
        }
        effect._bindTexture(name13, texture);
      }
      /**
       * Applies a full-screen effect to the current render target
       * @param drawWrapper The draw wrapper containing the effect to apply
       * @param customBindings The custom bindings to use when applying the effect (optional)
       * @param stencilState The stencil state to use when applying the effect (optional)
       * @param disableColorWrite If true, color write will be disabled when applying the effect (optional)
       * @param drawBackFace If true, the fullscreen quad will be drawn as a back face (in CW - optional)
       * @param depthTest If true, depth testing will be enabled when applying the effect (default is false)
       * @param noViewport If true, the current viewport will be left unchanged (optional). If false or undefined, the viewport will be set to the full render target size.
       * @returns True if the effect was applied, otherwise false (effect not ready)
       */
      applyFullScreenEffect(drawWrapper, customBindings, stencilState, disableColorWrite, drawBackFace, depthTest, noViewport) {
        if (!drawWrapper.effect?.isReady()) {
          return false;
        }
        this._applyRenderTarget();
        const engineDepthMask = this._engine.getDepthWrite();
        const engineDepthFunc = this._engine.getDepthFunction();
        const effectRenderer = drawBackFace ? this._effectRendererBack : this._effectRenderer;
        effectRenderer.saveStates();
        if (!noViewport) {
          effectRenderer.setViewport();
        }
        this._engine.enableEffect(drawWrapper);
        this._engine.setState(false, void 0, void 0, void 0, void 0, stencilState);
        this._engine.setDepthBuffer(!!depthTest);
        if (disableColorWrite) {
          this._engine.setColorWrite(false);
        }
        this._engine.setDepthWrite(false);
        effectRenderer.bindBuffers(drawWrapper.effect);
        customBindings?.();
        effectRenderer.draw();
        effectRenderer.restoreStates();
        if (disableColorWrite) {
          this._engine.setColorWrite(true);
        }
        this._engine.setDepthWrite(engineDepthMask);
        if (engineDepthFunc) {
          this._engine.setDepthFunction(engineDepthFunc);
        }
        this._engine.setAlphaMode(0);
        return true;
      }
      /**
       * Copies a texture to the current render target
       * @param sourceTexture The source texture to copy from
       * @param forceCopyToBackbuffer If true, the copy will be done to the back buffer regardless of the current render target
       * @param noViewport If true, the current viewport will be left unchanged (optional). If false or undefined, the viewport will be set to the full render target size.
       * @param lodLevel The LOD level to use when copying the texture (default: 0).
       */
      copyTexture(sourceTexture, forceCopyToBackbuffer = false, noViewport, lodLevel = 0) {
        if (forceCopyToBackbuffer) {
          this.bindRenderTarget();
        }
        const texture = this._textureManager.getTextureFromHandle(sourceTexture, true);
        const copyTexture = IsDepthTexture(texture.format) ? this._copyDepthTexture : this._copyTexture;
        copyTexture.source = texture;
        copyTexture.lodLevel = lodLevel;
        this.applyFullScreenEffect(copyTexture.effectWrapper.drawWrapper, () => {
          copyTexture.effectWrapper.onApplyObservable.notifyObservers({});
        }, void 0, void 0, void 0, void 0, noViewport);
      }
      /**
       * Renders a RenderTargetTexture or a layer
       * @param object The RenderTargetTexture/Layer to render
       * @param viewportWidth The width of the viewport (optional for Layer, but mandatory for ObjectRenderer)
       * @param viewportHeight The height of the viewport (optional for Layer, but mandatory for ObjectRenderer)
       * @param restoreDefaultFramebuffer If true, the default framebuffer will be restored after rendering (default: false)
       */
      render(object, viewportWidth, viewportHeight, restoreDefaultFramebuffer = false) {
        if (_FrameGraphRenderContext._IsObjectRenderer(object)) {
          this._scene._intermediateRendering = true;
          if (object.shouldRender()) {
            this._scene.incrementRenderId();
            this._scene.resetCachedMaterial();
            object.prepareRenderList();
            object.initRender(viewportWidth, viewportHeight);
            this._applyRenderTarget();
            object.render();
            object.finishRender();
            if (restoreDefaultFramebuffer) {
              this.restoreDefaultFramebuffer();
            }
          }
          this._scene._intermediateRendering = false;
        } else {
          this._applyRenderTarget();
          object.render();
        }
      }
      /**
       * Binds a render target texture so that upcoming draw calls will render to it
       * Note: it is a lazy operation, so the render target will only be bound when needed. This way, it is possible to call
       *   this method several times with different render targets without incurring the cost of binding if no draw calls are made
       * @param renderTarget The handle of the render target texture to bind (default: undefined, meaning "back buffer"). Pass an array for MRT rendering.
       * @param applyImmediately If true, the render target will be applied immediately (otherwise it will be applied at first use). Default is false (delayed application).
       */
      bindRenderTarget(renderTarget, applyImmediately = false) {
        this._currentRenderTarget = renderTarget?.renderTargetWrapper === void 0 ? void 0 : renderTarget;
        this._renderTargetIsBound = false;
        if (applyImmediately) {
          this._applyRenderTarget();
        }
      }
      /**
       * Restores the default framebuffer (back buffer) as the current render target
       */
      restoreDefaultFramebuffer() {
        this._engine.restoreDefaultFramebuffer();
        this._renderTargetIsBound = false;
        this._currentRenderTarget = void 0;
      }
      /** @internal */
      _applyRenderTarget() {
        if (this._renderTargetIsBound) {
          return;
        }
        const renderTargetWrapper = this._currentRenderTarget?.renderTargetWrapper;
        if (renderTargetWrapper === void 0) {
          if (this._engine._currentRenderTarget) {
            this._engine.restoreDefaultFramebuffer();
          }
        } else if (this._engine._currentRenderTarget !== renderTargetWrapper) {
          if (this._engine._currentRenderTarget) {
            this._engine.unBindFramebuffer(this._engine._currentRenderTarget);
          }
          this._engine.bindFramebuffer(renderTargetWrapper);
        }
        this._renderTargetIsBound = true;
      }
      /** @internal */
      _isReady() {
        return this._copyTexture.isReady() && this._copyDepthTexture.isReady();
      }
      /** @internal */
      _dispose() {
        this._effectRenderer.dispose();
        this._effectRendererBack.dispose();
        this._copyTexture.dispose();
        this._copyDepthTexture.dispose();
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/textureCreationOptions.js
function textureSizeIsObject(size) {
  return size.width !== void 0;
}
function getDimensionsFromTextureSize(size) {
  if (textureSizeIsObject(size)) {
    return { width: size.width, height: size.height };
  }
  return { width: size, height: size };
}
var init_textureCreationOptions = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/textureCreationOptions.js"() {
  }
});

// node_modules/@babylonjs/core/FrameGraph/frameGraphTextureManager.js
var FrameGraphTextureNamespace, FrameGraphTextureManager;
var init_frameGraphTextureManager = __esm({
  "node_modules/@babylonjs/core/FrameGraph/frameGraphTextureManager.js"() {
    init_textureCreationOptions();
    init_texture();
    init_frameGraphTypes();
    init_frameGraphRenderTarget();
    init_renderPass();
    init_logger();
    init_textureHelper_functions();
    (function(FrameGraphTextureNamespace2) {
      FrameGraphTextureNamespace2[FrameGraphTextureNamespace2["Task"] = 0] = "Task";
      FrameGraphTextureNamespace2[FrameGraphTextureNamespace2["Graph"] = 1] = "Graph";
      FrameGraphTextureNamespace2[FrameGraphTextureNamespace2["External"] = 2] = "External";
    })(FrameGraphTextureNamespace || (FrameGraphTextureNamespace = {}));
    FrameGraphTextureManager = class _FrameGraphTextureManager {
      /**
       * Constructs a new instance of the texture manager
       * @param engine The engine to use
       * @param _debugTextures If true, debug textures will be created so that they are visible in the inspector
       * @param _scene The scene the manager belongs to
       */
      constructor(engine, _debugTextures = false, _scene) {
        this.engine = engine;
        this._debugTextures = _debugTextures;
        this._scene = _scene;
        this._textures = /* @__PURE__ */ new Map();
        this._historyTextures = /* @__PURE__ */ new Map();
        this._isRecordingTask = false;
        this.showDebugLogsForTextureAllcationOptimization = false;
        this._backBufferTextureEntry = null;
        this._backBufferDepthStencilTextureEntry = null;
        this._backBufferTextureOverriden = false;
        this._addSystemTextures();
      }
      /**
       * Checks if a handle is a backbuffer handle (color or depth/stencil)
       * @param handle The handle to check
       * @returns True if the handle is a backbuffer handle
       */
      isBackbuffer(handle) {
        if (this._backBufferTextureOverriden) {
          return false;
        }
        return this._isBackbuffer(handle);
      }
      /** @internal */
      _isBackbuffer(handle) {
        if (handle === backbufferColorTextureHandle || handle === backbufferDepthStencilTextureHandle) {
          return true;
        }
        const textureEntry = this._textures.get(handle);
        if (!textureEntry) {
          return false;
        }
        return textureEntry.refHandle === backbufferColorTextureHandle || textureEntry.refHandle === backbufferDepthStencilTextureHandle;
      }
      /**
       * Checks if a handle is a backbuffer color handle
       * @param handle The handle to check
       * @returns True if the handle is a backbuffer color handle
       */
      isBackbufferColor(handle) {
        if (this._backBufferTextureOverriden) {
          return false;
        }
        if (handle === backbufferColorTextureHandle) {
          return true;
        }
        const textureEntry = this._textures.get(handle);
        if (!textureEntry) {
          return false;
        }
        return textureEntry.refHandle === backbufferColorTextureHandle;
      }
      /**
       * Checks if a handle is a backbuffer depth/stencil handle
       * @param handle The handle to check
       * @returns True if the handle is a backbuffer depth/stencil handle
       */
      isBackbufferDepthStencil(handle) {
        if (this._backBufferTextureOverriden) {
          return false;
        }
        if (handle === backbufferDepthStencilTextureHandle) {
          return true;
        }
        const textureEntry = this._textures.get(handle);
        if (!textureEntry) {
          return false;
        }
        return textureEntry.refHandle === backbufferDepthStencilTextureHandle;
      }
      /**
       * Checks if a handle is a history texture (or points to a history texture, for a dangling handle)
       * @param handle The handle to check
       * @param checkAllTextures If false (default), the function will check if the handle is the main handle of a history texture (the first handle of the history texture).
       *   If true, the function will also check if the handle is one of the other handles of a history texture.
       * @returns True if the handle is a history texture, otherwise false
       */
      isHistoryTexture(handle, checkAllTextures = false) {
        const entry = this._textures.get(handle);
        if (!entry) {
          return false;
        }
        handle = entry.refHandle ?? handle;
        if (!checkAllTextures) {
          return this._historyTextures.has(handle);
        }
        return this._textures.get(handle)?.historyTexture === true;
      }
      /**
       * Gets the creation options of a texture
       * @param handle Handle of the texture
       * @param preserveHistoryTextureFlag If true, the isHistoryTexture flag in the returned creation options will be the same as when the texture was created (default: false)
       * @returns The creation options of the texture
       */
      getTextureCreationOptions(handle, preserveHistoryTextureFlag = false) {
        handle = this._textures.get(handle)?.refHandle ?? handle;
        const entry = this._textures.get(handle);
        const creationOptions = entry.creationOptions;
        return {
          size: textureSizeIsObject(creationOptions.size) ? { ...creationOptions.size } : creationOptions.size,
          sizeIsPercentage: creationOptions.sizeIsPercentage,
          options: _FrameGraphTextureManager.CloneTextureOptions(creationOptions.options, entry.textureIndex),
          isHistoryTexture: preserveHistoryTextureFlag ? creationOptions.isHistoryTexture : false
        };
      }
      /**
       * Gets the description of a texture
       * @param handle Handle of the texture
       * @returns The description of the texture
       */
      getTextureDescription(handle) {
        const creationOptions = this.getTextureCreationOptions(handle);
        const size = !creationOptions.sizeIsPercentage ? textureSizeIsObject(creationOptions.size) ? creationOptions.size : { width: creationOptions.size, height: creationOptions.size } : this.getAbsoluteDimensions(creationOptions.size);
        return {
          size,
          options: creationOptions.options
        };
      }
      /**
       * Gets a texture handle or creates a new texture if the handle is not provided.
       * If handle is not provided, newTextureName and creationOptions must be provided.
       * @param handle If provided, will simply return the handle
       * @param newTextureName Name of the new texture to create
       * @param creationOptions Options to use when creating the new texture
       * @returns The handle to the texture.
       */
      getTextureHandleOrCreateTexture(handle, newTextureName, creationOptions) {
        if (handle === void 0) {
          if (newTextureName === void 0 || creationOptions === void 0) {
            throw new Error("getTextureHandleOrCreateTexture: Either handle or newTextureName and creationOptions must be provided.");
          }
          return this.createRenderTargetTexture(newTextureName, creationOptions);
        }
        return handle;
      }
      /**
       * Gets a texture from a handle.
       * Note that if the texture is a history texture, the read texture for the current frame will be returned, except if historyGetWriteTexture is true.
       * @param handle The handle of the texture
       * @param historyGetWriteTexture If true and the texture is a history texture, the write texture for the current frame will be returned (default: false)
       * @returns The texture or null if not found
       */
      getTextureFromHandle(handle, historyGetWriteTexture) {
        const entry = this._textures.get(handle);
        const refHandle = entry?.refHandle;
        const finalEntry = refHandle !== void 0 ? this._textures.get(refHandle) : entry;
        const finalHandle = refHandle !== void 0 ? refHandle : handle;
        const historyEntry = this._historyTextures.get(finalHandle);
        if (historyEntry) {
          return historyEntry.textures[historyGetWriteTexture ? historyEntry.index : historyEntry.index ^ 1];
        }
        return finalEntry.texture;
      }
      /**
       * Imports a texture into the texture manager
       * @param name Name of the texture
       * @param texture Texture to import
       * @param handle Existing handle to use for the texture. If not provided (default), a new handle will be created.
       * @returns The handle to the texture
       */
      importTexture(name13, texture, handle) {
        if (handle !== void 0) {
          this._freeEntry(handle);
        }
        const creationOptions = {
          size: { width: texture.width, height: texture.height },
          sizeIsPercentage: false,
          isHistoryTexture: false,
          options: {
            createMipMaps: texture.generateMipMaps,
            samples: texture.samples,
            types: [texture.type],
            formats: [texture.format],
            useSRGBBuffers: [texture._useSRGBBuffer],
            creationFlags: [texture._creationFlags],
            labels: texture.label ? [texture.label] : ["imported"]
          }
        };
        return this._createHandleForTexture(name13, texture, creationOptions, FrameGraphTextureNamespace.External, handle);
      }
      /**
       * Creates a new render target texture
       * If multiple textures are described in FrameGraphTextureCreationOptions, the handle of the first texture is returned, handle+1 is the handle of the second texture, etc.
       * @param name Name of the texture
       * @param creationOptions Options to use when creating the texture
       * @param handle Existing handle to use for the texture. If not provided (default), a new handle will be created.
       * @returns The handle to the texture
       */
      createRenderTargetTexture(name13, creationOptions, handle) {
        return this._createHandleForTexture(name13, null, {
          size: textureSizeIsObject(creationOptions.size) ? { ...creationOptions.size } : creationOptions.size,
          sizeIsPercentage: creationOptions.sizeIsPercentage,
          isHistoryTexture: creationOptions.isHistoryTexture,
          options: _FrameGraphTextureManager.CloneTextureOptions(creationOptions.options, void 0, true)
        }, this._isRecordingTask ? FrameGraphTextureNamespace.Task : FrameGraphTextureNamespace.Graph, handle);
      }
      /**
       * Creates a (frame graph) render target wrapper
       * Note that renderTargets or renderTargetDepth can be undefined, but not both at the same time!
       * @param name Name of the render target wrapper
       * @param renderTargets Render target handles (textures) to use
       * @param renderTargetDepth Render target depth handle (texture) to use
       * @param depthReadOnly If true, the depth buffer will be read-only
       * @param stencilReadOnly If true, the stencil buffer will be read-only
       * @returns The created render target wrapper
       */
      createRenderTarget(name13, renderTargets, renderTargetDepth, depthReadOnly, stencilReadOnly) {
        const renderTarget = new FrameGraphRenderTarget(name13, this, renderTargets, renderTargetDepth);
        const rtw = renderTarget.renderTargetWrapper;
        if (rtw !== void 0) {
          rtw.depthReadOnly = !!depthReadOnly;
          rtw.stencilReadOnly = !!stencilReadOnly;
          if (renderTargets) {
            const handles = Array.isArray(renderTargets) ? renderTargets : [renderTargets];
            for (let i = 0; i < handles.length; i++) {
              let handle = handles[i];
              handle = this._textures.get(handle)?.refHandle ?? handle;
              const historyEntry = this._historyTextures.get(handle);
              if (historyEntry) {
                historyEntry.references.push({ renderTargetWrapper: rtw, textureIndex: i });
                rtw.setTexture(historyEntry.textures[historyEntry.index], i, false);
              }
            }
          }
        }
        return renderTarget;
      }
      /**
       * Creates a handle which is not associated with any texture.
       * Call resolveDanglingHandle to associate the handle with a valid texture handle.
       * @returns The dangling handle
       */
      createDanglingHandle() {
        return _FrameGraphTextureManager._Counter++;
      }
      /**
       * Associates a texture with a dangling handle
       * @param danglingHandle The dangling handle
       * @param handle The handle to associate with the dangling handle (if not provided, a new texture handle will be created, using the newTextureName and creationOptions parameters)
       * @param newTextureName The name of the new texture to create (if handle is not provided)
       * @param creationOptions The options to use when creating the new texture (if handle is not provided)
       */
      resolveDanglingHandle(danglingHandle, handle, newTextureName, creationOptions) {
        if (handle === void 0) {
          if (newTextureName === void 0 || creationOptions === void 0) {
            throw new Error("resolveDanglingHandle: Either handle or newTextureName and creationOptions must be provided.");
          }
          this.createRenderTargetTexture(newTextureName, creationOptions, danglingHandle);
          return;
        }
        const textureEntry = this._textures.get(handle);
        if (textureEntry === void 0) {
          throw new Error(`resolveDanglingHandle: Handle ${handle} does not exist!`);
        }
        handle = textureEntry.refHandle ?? handle;
        this._textures.set(danglingHandle, {
          texture: textureEntry.texture,
          refHandle: handle,
          name: textureEntry.name,
          creationOptions: {
            size: { ...textureEntry.creationOptions.size },
            options: _FrameGraphTextureManager.CloneTextureOptions(textureEntry.creationOptions.options),
            sizeIsPercentage: textureEntry.creationOptions.sizeIsPercentage,
            isHistoryTexture: false
          },
          namespace: textureEntry.namespace,
          textureIndex: textureEntry.textureIndex
        });
      }
      /**
       * Gets the absolute dimensions of a texture.
       * @param size The size of the texture. Width and height must be expressed as a percentage of the screen size (100=100%)!
       * @param screenWidth The width of the screen (default: the width of the rendering canvas)
       * @param screenHeight The height of the screen (default: the height of the rendering canvas)
       * @returns The absolute dimensions of the texture
       */
      getAbsoluteDimensions(size, screenWidth, screenHeight) {
        if (this._backBufferTextureOverriden) {
          const backbufferColorTextureSize = this._textures.get(backbufferColorTextureHandle).creationOptions.size;
          screenWidth ?? (screenWidth = backbufferColorTextureSize.width);
          screenHeight ?? (screenHeight = backbufferColorTextureSize.height);
        } else {
          screenWidth ?? (screenWidth = this.engine.getRenderWidth(true));
          screenHeight ?? (screenHeight = this.engine.getRenderHeight(true));
        }
        const { width, height } = getDimensionsFromTextureSize(size);
        return {
          width: Math.floor(width * screenWidth / 100),
          height: Math.floor(height * screenHeight / 100)
        };
      }
      /**
       * Gets the absolute dimensions of a texture from its handle or creation options.
       * @param handleOrCreationOptions The handle or creation options of the texture
       * @returns The absolute dimensions of the texture
       */
      getTextureAbsoluteDimensions(handleOrCreationOptions) {
        if (typeof handleOrCreationOptions === "number") {
          handleOrCreationOptions = this.getTextureCreationOptions(handleOrCreationOptions);
        }
        return !handleOrCreationOptions.sizeIsPercentage ? textureSizeIsObject(handleOrCreationOptions.size) ? handleOrCreationOptions.size : { width: handleOrCreationOptions.size, height: handleOrCreationOptions.size } : this.getAbsoluteDimensions(handleOrCreationOptions.size);
      }
      /**
       * Calculates the total byte size of all textures used by the frame graph texture manager (including external textures)
       * @param optimizedSize True if the calculation should not factor in aliased textures
       * @param outputWidth The output width of the frame graph. Will be used to calculate the size of percentage-based textures
       * @param outputHeight The output height of the frame graph. Will be used to calculate the size of percentage-based textures
       * @returns The total size of all textures
       */
      computeTotalTextureSize(optimizedSize, outputWidth, outputHeight) {
        let totalSize = 0;
        this._textures.forEach((entry, handle) => {
          if (!this._backBufferTextureOverriden && (handle === backbufferColorTextureHandle || handle === backbufferDepthStencilTextureHandle) || entry.refHandle !== void 0) {
            return;
          }
          if (optimizedSize && entry.aliasHandle !== void 0) {
            return;
          }
          const options = entry.creationOptions;
          const textureIndex = entry.textureIndex || 0;
          const dimensions = options.sizeIsPercentage ? this.getAbsoluteDimensions(options.size, outputWidth, outputHeight) : getDimensionsFromTextureSize(options.size);
          const blockInfo = _FrameGraphTextureManager._GetTextureBlockInformation(options.options.types?.[textureIndex] ?? 0, options.options.formats[textureIndex]);
          const textureByteSize = Math.ceil(dimensions.width / blockInfo.width) * Math.ceil(dimensions.height / blockInfo.height) * blockInfo.length;
          let byteSize = textureByteSize;
          if (options.options.createMipMaps) {
            byteSize = Math.floor(byteSize * 4 / 3);
          }
          if ((options.options.samples || 1) > 1) {
            byteSize += textureByteSize;
          }
          totalSize += byteSize;
        });
        return totalSize;
      }
      /**
       * True if the back buffer texture has been overriden by a call to setBackBufferTexture
       */
      get backBufferTextureOverriden() {
        return this._backBufferTextureOverriden;
      }
      /**
       * Overrides the default back buffer color/depth-stencil textures used by the frame graph.
       * Note that if both textureCreationOptions and depthStencilTextureCreationOptions are provided,
       * the engine will use them to create the back buffer color and depth/stencil textures respectively.
       * In that case, width and height are ignored.
       * @param width The width of the back buffer color/depth-stencil texture (if 0, the engine's current back buffer color/depth-stencil texture width will be used)
       * @param height The height of the back buffer color/depth-stencil texture (if 0, the engine's current back buffer color/depth-stencil texture height will be used)
       * @param textureCreationOptions The color texture creation options (optional)
       * @param depthStencilTextureCreationOptions The depth/stencil texture creation options (optional)
       */
      setBackBufferTextures(width, height, textureCreationOptions, depthStencilTextureCreationOptions) {
        if ((width === 0 || height === 0) && (!textureCreationOptions || !depthStencilTextureCreationOptions)) {
          if (this._backBufferTextureOverriden) {
            let entry = this._textures.get(backbufferColorTextureHandle);
            entry.texture?.dispose();
            entry.texture = null;
            entry.debug?.dispose();
            entry.debug = void 0;
            entry = this._textures.get(backbufferDepthStencilTextureHandle);
            entry.texture?.dispose();
            entry.texture = null;
            entry.debug?.dispose();
            entry.debug = void 0;
          }
          this._backBufferTextureEntry = null;
          this._backBufferDepthStencilTextureEntry = null;
          this._backBufferTextureOverriden = false;
          this._addSystemTextures();
          return;
        }
        this._backBufferTextureOverriden = true;
        const size = { width, height };
        this._backBufferTextureEntry = {
          name: "backbuffer color",
          texture: null,
          creationOptions: textureCreationOptions ?? {
            size,
            options: {
              createMipMaps: false,
              samples: this.engine.getCreationOptions().antialias ? 4 : 1,
              types: [0],
              formats: [5],
              useSRGBBuffers: [false],
              creationFlags: [0],
              labels: ["backbuffer color"]
            },
            sizeIsPercentage: false
          },
          namespace: FrameGraphTextureNamespace.Graph,
          lifespan: {
            firstTask: Number.MAX_VALUE,
            lastTask: 0
          }
        };
        this._backBufferTextureEntry.textureDescriptionHash = this._createTextureDescriptionHash(this._backBufferTextureEntry.creationOptions);
        this._backBufferDepthStencilTextureEntry = {
          name: "backbuffer depth/stencil",
          texture: null,
          creationOptions: depthStencilTextureCreationOptions ?? {
            size,
            options: {
              createMipMaps: false,
              samples: this.engine.getCreationOptions().antialias ? 4 : 1,
              types: [0],
              formats: [this.engine.isStencilEnable ? 13 : 14],
              useSRGBBuffers: [false],
              creationFlags: [0],
              labels: ["backbuffer depth/stencil"]
            },
            sizeIsPercentage: false
          },
          namespace: FrameGraphTextureNamespace.Graph,
          lifespan: {
            firstTask: Number.MAX_VALUE,
            lastTask: 0
          }
        };
        this._backBufferDepthStencilTextureEntry.textureDescriptionHash = this._createTextureDescriptionHash(this._backBufferDepthStencilTextureEntry.creationOptions);
        this._addSystemTextures();
      }
      /**
       * Resets the back buffer color/depth-stencil textures to the default (the engine's current back buffer textures)
       * It has no effect if setBackBufferTextures has not been called before.
       */
      resetBackBufferTextures() {
        this.setBackBufferTextures(0, 0);
      }
      /**
       * Returns true if the texture manager has at least one history texture
       */
      get hasHistoryTextures() {
        return this._historyTextures.size > 0;
      }
      /** @internal */
      _dispose() {
        this._releaseTextures();
      }
      /** @internal */
      _allocateTextures(tasks) {
        if (tasks) {
          this._optimizeTextureAllocation(tasks);
        }
        this._textures.forEach((entry) => {
          if (!entry.texture) {
            if (entry.refHandle !== void 0) {
              const refEntry = this._textures.get(entry.refHandle);
              entry.texture = refEntry.texture;
              entry.texture?.incrementReferences();
              if (refEntry.refHandle === backbufferColorTextureHandle) {
                entry.refHandle = backbufferColorTextureHandle;
              }
              if (refEntry.refHandle === backbufferDepthStencilTextureHandle) {
                entry.refHandle = backbufferDepthStencilTextureHandle;
              }
            } else if (entry.namespace !== FrameGraphTextureNamespace.External) {
              if (entry.aliasHandle !== void 0) {
                const aliasEntry = this._textures.get(entry.aliasHandle);
                entry.texture = aliasEntry.texture;
                entry.texture.incrementReferences();
              } else {
                const creationOptions = entry.creationOptions;
                const size = getDimensionsFromTextureSize(creationOptions.sizeIsPercentage ? this.getAbsoluteDimensions(creationOptions.size) : creationOptions.size);
                const textureIndex = entry.textureIndex || 0;
                const targetType = creationOptions.options.targetTypes?.[textureIndex] ?? 3553;
                const is3D = targetType === 32879;
                const isArray = targetType === 35866 || targetType === 3735928559;
                const layerCount = creationOptions.options.layerCounts?.[textureIndex] ?? 0;
                const internalTextureCreationOptions = {
                  createMipMaps: creationOptions.options.createMipMaps,
                  samples: creationOptions.options.samples,
                  type: creationOptions.options.types?.[textureIndex],
                  format: creationOptions.options.formats?.[textureIndex],
                  useSRGBBuffer: creationOptions.options.useSRGBBuffers?.[textureIndex],
                  creationFlags: creationOptions.options.creationFlags?.[textureIndex],
                  label: creationOptions.options.labels?.[textureIndex] ?? `${entry.name}${textureIndex > 0 ? "#" + textureIndex : ""}`,
                  samplingMode: 1,
                  createMSAATexture: creationOptions.options.samples > 1,
                  isCube: targetType === 34067 || targetType === 3735928559
                };
                const isDepthTexture = IsDepthTexture(internalTextureCreationOptions.format);
                const hasStencil = HasStencilAspect(internalTextureCreationOptions.format);
                const source = isDepthTexture && hasStencil ? 12 : isDepthTexture || hasStencil ? 14 : 5;
                const internalTexture = this.engine._createInternalTexture({ width: size.width, height: size.height, depth: is3D ? layerCount : void 0, layers: isArray ? layerCount : void 0 }, internalTextureCreationOptions, false, source);
                if (isDepthTexture) {
                  internalTexture.type = GetTypeForDepthTexture(internalTexture.format);
                }
                entry.texture = internalTexture;
              }
            }
          }
          if (entry.texture && entry.refHandle === void 0) {
            entry.debug?.dispose();
            entry.debug = this._createDebugTexture(entry.name, entry.texture);
          }
        });
        this._historyTextures.forEach((entry) => {
          for (let i = 0; i < entry.handles.length; i++) {
            entry.textures[i] = this._textures.get(entry.handles[i]).texture;
          }
        });
      }
      /** @internal */
      _releaseTextures(releaseAll = true) {
        this._textures.forEach((entry, handle) => {
          if (entry.lifespan) {
            entry.lifespan.firstTask = Number.MAX_VALUE;
            entry.lifespan.lastTask = 0;
          }
          entry.aliasHandle = void 0;
          if (releaseAll || entry.namespace !== FrameGraphTextureNamespace.External) {
            entry.debug?.dispose();
            entry.debug = void 0;
          }
          if (entry.namespace === FrameGraphTextureNamespace.External) {
            return;
          }
          entry.texture?.dispose();
          entry.texture = null;
          if (releaseAll || entry.namespace === FrameGraphTextureNamespace.Task) {
            this._textures.delete(handle);
            this._historyTextures.delete(handle);
          }
        });
        this._historyTextures.forEach((entry) => {
          for (let i = 0; i < entry.handles.length; i++) {
            entry.textures[i] = null;
          }
        });
        if (releaseAll) {
          this._textures.clear();
          this._historyTextures.clear();
          this._addSystemTextures();
        }
      }
      /** @internal */
      _updateHistoryTextures() {
        this._historyTextures.forEach((entry) => {
          entry.index = entry.index ^ 1;
          const currentTexture = entry.textures[entry.index];
          if (currentTexture) {
            for (const { renderTargetWrapper, textureIndex } of entry.references) {
              renderTargetWrapper.setTexture(currentTexture, textureIndex, false);
            }
          }
        });
      }
      _addSystemTextures() {
        const size = { width: this.engine.getRenderWidth(true), height: this.engine.getRenderHeight(true) };
        this._textures.set(backbufferColorTextureHandle, this._backBufferTextureEntry ?? {
          name: "backbuffer color",
          texture: null,
          creationOptions: {
            size,
            options: {
              createMipMaps: false,
              samples: this.engine.getCreationOptions().antialias ? 4 : 1,
              types: [0],
              // todo? get from engine
              formats: [5],
              // todo? get from engine
              useSRGBBuffers: [false],
              creationFlags: [0],
              labels: ["backbuffer color"]
            },
            sizeIsPercentage: false
          },
          namespace: FrameGraphTextureNamespace.External
        });
        this._textures.set(backbufferDepthStencilTextureHandle, this._backBufferDepthStencilTextureEntry ?? {
          name: "backbuffer depth/stencil",
          texture: null,
          creationOptions: {
            size,
            options: {
              createMipMaps: false,
              samples: this.engine.getCreationOptions().antialias ? 4 : 1,
              types: [0],
              // todo? get from engine
              formats: [16],
              // todo? get from engine
              useSRGBBuffers: [false],
              creationFlags: [0],
              labels: ["backbuffer depth/stencil"]
            },
            sizeIsPercentage: false
          },
          namespace: FrameGraphTextureNamespace.External
        });
      }
      _createDebugTexture(name13, texture) {
        if (!this._debugTextures) {
          return;
        }
        const textureDebug = new Texture(null, this._scene);
        textureDebug.name = name13;
        textureDebug._texture = texture;
        textureDebug._texture.incrementReferences();
        return textureDebug;
      }
      _freeEntry(handle) {
        const entry = this._textures.get(handle);
        if (entry) {
          entry.debug?.dispose();
          this._textures.delete(handle);
        }
      }
      _createHandleForTexture(name13, texture, creationOptions, namespace, handle, textureIndex) {
        handle = handle ?? _FrameGraphTextureManager._Counter++;
        textureIndex = textureIndex || 0;
        const textureName = creationOptions.isHistoryTexture ? `${name13} ping` : name13;
        let label = creationOptions.options.labels?.[textureIndex] ?? "";
        if (label === textureName) {
          label = "";
        }
        const textureEntry = {
          texture,
          name: `${textureName}${label ? " " + label : ""}`,
          creationOptions: {
            size: textureSizeIsObject(creationOptions.size) ? creationOptions.size : { width: creationOptions.size, height: creationOptions.size },
            options: creationOptions.options,
            sizeIsPercentage: creationOptions.sizeIsPercentage,
            isHistoryTexture: creationOptions.isHistoryTexture
          },
          namespace,
          textureIndex,
          textureDescriptionHash: this._createTextureDescriptionHash(creationOptions),
          lifespan: {
            firstTask: Number.MAX_VALUE,
            lastTask: 0
          },
          historyTexture: creationOptions.isHistoryTexture
        };
        this._textures.set(handle, textureEntry);
        if (namespace === FrameGraphTextureNamespace.External) {
          return handle;
        }
        if (creationOptions.isHistoryTexture) {
          const pongCreationOptions = {
            size: { ...textureEntry.creationOptions.size },
            options: { ...textureEntry.creationOptions.options },
            sizeIsPercentage: textureEntry.creationOptions.sizeIsPercentage,
            isHistoryTexture: false
          };
          const pongTexture = this._createHandleForTexture(`${name13} pong`, null, pongCreationOptions, namespace);
          this._textures.get(pongTexture).historyTexture = true;
          this._historyTextures.set(handle, { textures: [null, null], handles: [handle, pongTexture], index: 0, references: [] });
          return handle;
        }
        if (creationOptions.options.types && creationOptions.options.types.length > 1 && textureIndex === 0) {
          const textureCount = creationOptions.options.types.length;
          const creationOptionsForTexture = {
            size: textureSizeIsObject(creationOptions.size) ? creationOptions.size : { width: creationOptions.size, height: creationOptions.size },
            options: creationOptions.options,
            sizeIsPercentage: creationOptions.sizeIsPercentage
          };
          for (let i = 1; i < textureCount; i++) {
            this._createHandleForTexture(textureName, null, creationOptionsForTexture, namespace, handle + i, i);
          }
          _FrameGraphTextureManager._Counter += textureCount - 1;
        }
        return handle;
      }
      _createTextureDescriptionHash(options) {
        const hash = [];
        hash.push(textureSizeIsObject(options.size) ? `${options.size.width}_${options.size.height}` : `${options.size}`);
        hash.push(options.sizeIsPercentage ? "%" : "A");
        hash.push(options.options.createMipMaps ? "M" : "N");
        hash.push(options.options.samples ? `${options.options.samples}` : "S1");
        hash.push(options.options.targetTypes ? options.options.targetTypes.join("_") : `${3553}`);
        hash.push(options.options.types ? options.options.types.join("_") : `${0}`);
        hash.push(options.options.formats ? options.options.formats.join("_") : `${5}`);
        hash.push(options.options.layerCounts ? options.options.layerCounts.join("_") : `0`);
        hash.push(options.options.useSRGBBuffers ? options.options.useSRGBBuffers.join("_") : "false");
        hash.push(options.options.creationFlags ? options.options.creationFlags.join("_") : "0");
        return hash.join("_");
      }
      _optimizeTextureAllocation(tasks) {
        this._computeTextureLifespan(tasks);
        if (this.showDebugLogsForTextureAllcationOptimization) {
          Logger.Log(`================== Optimization of texture allocation ==================`);
        }
        const cache = /* @__PURE__ */ new Map();
        const iterator = this._textures.keys();
        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
          const textureHandle = key.value;
          const textureEntry = this._textures.get(textureHandle);
          if (textureEntry.refHandle !== void 0 || textureEntry.namespace === FrameGraphTextureNamespace.External || this.isHistoryTexture(textureHandle, true)) {
            continue;
          }
          const textureHash = textureEntry.textureDescriptionHash;
          const textureLifespan = textureEntry.lifespan;
          const cacheEntries = cache.get(textureHash);
          if (cacheEntries) {
            let cacheEntryFound = false;
            for (const cacheEntry of cacheEntries) {
              const [sourceHandle, lifespanArray] = cacheEntry;
              let overlapped = false;
              for (const lifespan of lifespanArray) {
                if (lifespan.firstTask <= textureLifespan.lastTask && lifespan.lastTask >= textureLifespan.firstTask) {
                  overlapped = true;
                  break;
                }
              }
              if (!overlapped) {
                if (this.showDebugLogsForTextureAllcationOptimization) {
                  Logger.Log(`Texture ${textureHandle} (${textureEntry.name}) reuses cache entry ${sourceHandle}`);
                }
                lifespanArray.push(textureLifespan);
                textureEntry.aliasHandle = sourceHandle;
                cacheEntryFound = true;
                break;
              }
            }
            if (!cacheEntryFound) {
              cacheEntries.push([textureHandle, [textureLifespan]]);
            }
          } else {
            cache.set(textureHash, [[textureHandle, [textureLifespan]]]);
          }
        }
      }
      // Loop through all task/pass dependencies and compute the lifespan of each texture (that is, the first task/pass that uses it and the last task/pass that uses it)
      _computeTextureLifespan(tasks) {
        if (this.showDebugLogsForTextureAllcationOptimization) {
          Logger.Log(`================== Dump of texture dependencies for all tasks/passes ==================`);
        }
        for (let t = 0; t < tasks.length; ++t) {
          const task = tasks[t];
          if (task.passes.length > 0) {
            this._computeTextureLifespanForPasses(task, t, task.passes);
          }
          if (task.passesDisabled.length > 0) {
            this._computeTextureLifespanForPasses(task, t, task.passesDisabled);
          }
          if (task.dependencies) {
            if (this.showDebugLogsForTextureAllcationOptimization) {
              Logger.Log(`task#${t} (${task.name}), global dependencies`);
            }
            this._updateLifespan(t * 100 + 99, task.dependencies);
          }
        }
        if (this.showDebugLogsForTextureAllcationOptimization) {
          Logger.Log(`================== Texture lifespans ==================`);
          const iterator = this._textures.keys();
          for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
            const textureHandle = key.value;
            const textureEntry = this._textures.get(textureHandle);
            if (textureEntry.refHandle !== void 0 || textureEntry.namespace === FrameGraphTextureNamespace.External || this._historyTextures.has(textureHandle)) {
              continue;
            }
            Logger.Log(`${textureHandle} (${textureEntry.name}): ${textureEntry.lifespan.firstTask} - ${textureEntry.lifespan.lastTask}`);
          }
        }
      }
      _computeTextureLifespanForPasses(task, taskIndex, passes) {
        for (let p = 0; p < passes.length; ++p) {
          const dependencies = /* @__PURE__ */ new Set();
          const pass = passes[p];
          if (!FrameGraphRenderPass.IsRenderPass(pass)) {
            continue;
          }
          pass.collectDependencies(dependencies);
          if (this.showDebugLogsForTextureAllcationOptimization) {
            Logger.Log(`task#${taskIndex} (${task.name}), pass#${p} (${pass.name})`);
          }
          this._updateLifespan(taskIndex * 100 + p, dependencies);
        }
      }
      _updateLifespan(passOrderNum, dependencies) {
        const iterator = dependencies.keys();
        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
          const textureHandle = key.value;
          if (this.isBackbuffer(textureHandle)) {
            continue;
          }
          let textureEntry = this._textures.get(textureHandle);
          if (!textureEntry) {
            throw new Error(`FrameGraph._computeTextureLifespan: Texture handle "${textureHandle}" not found in the texture manager. Make sure you didn't forget to add a task in the frame graph.`);
          }
          let handle = textureHandle;
          while (textureEntry.refHandle !== void 0) {
            handle = textureEntry.refHandle;
            textureEntry = this._textures.get(handle);
            if (!textureEntry) {
              throw new Error(`FrameGraph._computeTextureLifespan: Texture handle "${handle}" not found in the texture manager (source handle="${textureHandle}"). Make sure you didn't forget to add a task in the frame graph.`);
            }
          }
          if (textureEntry.namespace === FrameGraphTextureNamespace.External || this._historyTextures.has(handle)) {
            continue;
          }
          if (this.showDebugLogsForTextureAllcationOptimization) {
            Logger.Log(`    ${handle} (${textureEntry.name})`);
          }
          textureEntry.lifespan.firstTask = Math.min(textureEntry.lifespan.firstTask, passOrderNum);
          textureEntry.lifespan.lastTask = Math.max(textureEntry.lifespan.lastTask, passOrderNum);
        }
      }
      /**
       * Clones a texture options
       * @param options The options to clone
       * @param textureIndex The index of the texture in the types, formats, etc array of FrameGraphTextureOptions. If not provided, all options are cloned.
       * @param preserveLabels True if the labels should be preserved (default: false)
       * @returns The cloned options
       */
      static CloneTextureOptions(options, textureIndex, preserveLabels) {
        return textureIndex !== void 0 ? {
          createMipMaps: options.createMipMaps,
          samples: options.samples,
          targetTypes: options.targetTypes ? [options.targetTypes[textureIndex]] : void 0,
          types: options.types ? [options.types[textureIndex]] : void 0,
          formats: options.formats ? [options.formats[textureIndex]] : void 0,
          layerCounts: options.layerCounts ? [options.layerCounts[textureIndex]] : void 0,
          useSRGBBuffers: options.useSRGBBuffers ? [options.useSRGBBuffers[textureIndex]] : void 0,
          creationFlags: options.creationFlags ? [options.creationFlags[textureIndex]] : void 0,
          labels: options.labels ? [options.labels[textureIndex]] : void 0
        } : {
          createMipMaps: options.createMipMaps,
          samples: options.samples,
          targetTypes: options.targetTypes ? [...options.targetTypes] : void 0,
          types: options.types ? [...options.types] : void 0,
          formats: options.formats ? [...options.formats] : void 0,
          layerCounts: options.layerCounts ? [...options.layerCounts] : void 0,
          useSRGBBuffers: options.useSRGBBuffers ? [...options.useSRGBBuffers] : void 0,
          creationFlags: options.creationFlags ? [...options.creationFlags] : void 0,
          labels: options.labels && preserveLabels ? [...options.labels] : void 0
        };
      }
      /**
       * Gets the texture block information.
       * @param type Type of the texture.
       * @param format Format of the texture.
       * @returns The texture block information. You can calculate the byte size of the texture by doing: Math.ceil(width / blockInfo.width) * Math.ceil(height / blockInfo.height) * blockInfo.length
       */
      static _GetTextureBlockInformation(type, format) {
        switch (format) {
          case 15:
            return { width: 1, height: 1, length: 2 };
          case 16:
            return { width: 1, height: 1, length: 3 };
          case 13:
            return { width: 1, height: 1, length: 4 };
          case 14:
            return { width: 1, height: 1, length: 4 };
          case 18:
            return { width: 1, height: 1, length: 5 };
          case 19:
            return { width: 1, height: 1, length: 1 };
          case 36492:
            return { width: 4, height: 4, length: 16 };
          case 36495:
            return { width: 4, height: 4, length: 16 };
          case 36494:
            return { width: 4, height: 4, length: 16 };
          case 33779:
            return { width: 4, height: 4, length: 16 };
          case 33778:
            return { width: 4, height: 4, length: 16 };
          case 33777:
          case 33776:
            return { width: 4, height: 4, length: 8 };
          case 37808:
            return { width: 4, height: 4, length: 16 };
          case 36196:
          case 37492:
            return { width: 4, height: 4, length: 8 };
          case 37496:
            return { width: 4, height: 4, length: 16 };
        }
        switch (type) {
          case 3:
          case 0:
            switch (format) {
              case 6:
              case 8:
              case 0:
              case 1:
              case 2:
                return { width: 1, height: 1, length: 1 };
              case 7:
              case 9:
                return { width: 1, height: 1, length: 2 };
              case 4:
              case 10:
                return { width: 1, height: 1, length: 3 };
              case 11:
                return { width: 1, height: 1, length: 4 };
              default:
                return { width: 1, height: 1, length: 4 };
            }
          case 4:
          case 5:
            switch (format) {
              case 8:
                return { width: 1, height: 1, length: 2 };
              case 9:
                return { width: 1, height: 1, length: 4 };
              case 10:
                return { width: 1, height: 1, length: 6 };
              case 11:
                return { width: 1, height: 1, length: 8 };
              default:
                return { width: 1, height: 1, length: 8 };
            }
          case 6:
          case 7:
            switch (format) {
              case 8:
                return { width: 1, height: 1, length: 4 };
              case 9:
                return { width: 1, height: 1, length: 8 };
              case 10:
                return { width: 1, height: 1, length: 12 };
              case 11:
                return { width: 1, height: 1, length: 16 };
              default:
                return { width: 1, height: 1, length: 16 };
            }
          case 1:
            switch (format) {
              case 6:
                return { width: 1, height: 1, length: 4 };
              case 7:
                return { width: 1, height: 1, length: 8 };
              case 4:
                return { width: 1, height: 1, length: 12 };
              case 5:
                return { width: 1, height: 1, length: 16 };
              default:
                return { width: 1, height: 1, length: 16 };
            }
          case 2:
            switch (format) {
              case 6:
                return { width: 1, height: 1, length: 2 };
              case 7:
                return { width: 1, height: 1, length: 4 };
              case 4:
                return { width: 1, height: 1, length: 6 };
              case 5:
                return { width: 1, height: 1, length: 8 };
              default:
                return { width: 1, height: 1, length: 8 };
            }
          case 10:
            return { width: 1, height: 1, length: 2 };
          case 13:
            switch (format) {
              case 5:
              case 11:
                return { width: 1, height: 1, length: 4 };
              default:
                return { width: 1, height: 1, length: 4 };
            }
          case 14:
            switch (format) {
              case 5:
              case 11:
                return { width: 1, height: 1, length: 4 };
              default:
                return { width: 1, height: 1, length: 4 };
            }
          case 8:
            return { width: 1, height: 1, length: 2 };
          case 9:
            return { width: 1, height: 1, length: 2 };
          case 11:
            switch (format) {
              case 5:
                return { width: 1, height: 1, length: 4 };
              case 11:
                return { width: 1, height: 1, length: 4 };
              default:
                return { width: 1, height: 1, length: 4 };
            }
        }
        return { width: 1, height: 1, length: 4 };
      }
    };
    FrameGraphTextureManager._Counter = 2;
  }
});

// node_modules/@babylonjs/core/FrameGraph/frameGraph.js
var FrameGraphPassType, FrameGraph;
var init_frameGraph = __esm({
  "node_modules/@babylonjs/core/FrameGraph/frameGraph.js"() {
    init_pass();
    init_renderPass();
    init_objectListPass();
    init_frameGraphRenderContext();
    init_frameGraphContext();
    init_frameGraphTextureManager();
    init_observable();
    init_timingTools();
    init_logger();
    init_uniqueIdGenerator();
    (function(FrameGraphPassType2) {
      FrameGraphPassType2[FrameGraphPassType2["Normal"] = 0] = "Normal";
      FrameGraphPassType2[FrameGraphPassType2["Render"] = 1] = "Render";
      FrameGraphPassType2[FrameGraphPassType2["ObjectList"] = 2] = "ObjectList";
    })(FrameGraphPassType || (FrameGraphPassType = {}));
    FrameGraph = class {
      /**
       * Gets the engine used by the frame graph
       */
      get engine() {
        return this._engine;
      }
      /**
       * Gets the scene used by the frame graph
       */
      get scene() {
        return this._scene;
      }
      /**
       * Gets the list of tasks in the frame graph
       */
      get tasks() {
        return this._tasks;
      }
      /**
       * Gets the node render graph linked to the frame graph (if any)
       * @returns the linked node render graph or null if none
       */
      getLinkedNodeRenderGraph() {
        return this._linkedNodeRenderGraph;
      }
      /**
       * Constructs the frame graph
       * @param scene defines the scene the frame graph is associated with
       * @param debugTextures defines a boolean indicating that textures created by the frame graph should be visible in the inspector (default is false)
       * @param _linkedNodeRenderGraph defines the linked node render graph (if any)
       */
      constructor(scene, debugTextures = false, _linkedNodeRenderGraph = null) {
        this._linkedNodeRenderGraph = _linkedNodeRenderGraph;
        this._tasks = [];
        this._initAsyncPromises = [];
        this._currentProcessedTask = null;
        this._whenReadyAsyncCancel = null;
        this.name = "Frame Graph";
        this.uniqueId = UniqueIdGenerator.UniqueId;
        this.optimizeTextureAllocation = true;
        this.onBuildObservable = new Observable();
        this.pausedExecution = false;
        this._scene = scene;
        this._engine = scene.getEngine();
        this._importPromise = this._engine.isWebGPU ? import("./engine.multiRender-USU4SGT5.js") : import("./engine.multiRender-NZ2AWJPZ.js");
        this.textureManager = new FrameGraphTextureManager(this._engine, debugTextures, scene);
        this._passContext = new FrameGraphContext(this._engine, this.textureManager, scene);
        this._renderContext = new FrameGraphRenderContext(this._engine, this.textureManager, scene);
        this._scene.addFrameGraph(this);
      }
      /**
       * Gets the class name of the frame graph
       * @returns the class name
       */
      getClassName() {
        return "FrameGraph";
      }
      /**
       * Gets a task by name
       * @param name Name of the task to get
       * @returns The task or undefined if not found
       */
      getTaskByName(name13) {
        return this._tasks.find((t) => t.name === name13);
      }
      /**
       * Gets all tasks of a specific type
       * @param taskType Type of the task(s) to get
       * @returns The list of tasks of the specified type
       */
      getTasksByType(taskType) {
        return this._tasks.filter((t) => t instanceof taskType);
      }
      /**
       * Gets all tasks of a specific type, based on their class name
       * @param taskClassName Class name(s) of the task(s) to get
       * @returns The list of tasks of the specified type
       */
      getTasksByClassName(taskClassName) {
        return Array.isArray(taskClassName) ? this._tasks.filter((t) => taskClassName.includes(t.getClassName())) : this._tasks.filter((t) => t.getClassName() === taskClassName);
      }
      /**
       * Adds a task to the frame graph
       * @param task Task to add
       */
      addTask(task) {
        if (this._currentProcessedTask !== null) {
          throw new Error(`FrameGraph.addTask: Can't add the task "${task.name}" while another task is currently building (task: ${this._currentProcessedTask.name}).`);
        }
        this._tasks.push(task);
        this._initAsyncPromises.push(task.initAsync());
      }
      /**
       * Adds a pass to a task. This method can only be called during a Task.record execution.
       * @param name The name of the pass
       * @param whenTaskDisabled If true, the pass will be added to the list of passes to execute when the task is disabled (default is false)
       * @returns The render pass created
       */
      addPass(name13, whenTaskDisabled = false) {
        return this._addPass(name13, FrameGraphPassType.Normal, whenTaskDisabled);
      }
      /**
       * Adds a render pass to a task. This method can only be called during a Task.record execution.
       * @param name The name of the pass
       * @param whenTaskDisabled If true, the pass will be added to the list of passes to execute when the task is disabled (default is false)
       * @returns The render pass created
       */
      addRenderPass(name13, whenTaskDisabled = false) {
        return this._addPass(name13, FrameGraphPassType.Render, whenTaskDisabled);
      }
      /**
       * Adds an object list pass to a task. This method can only be called during a Task.record execution.
       * @param name The name of the pass
       * @param whenTaskDisabled If true, the pass will be added to the list of passes to execute when the task is disabled (default is false)
       * @returns The object list pass created
       */
      addObjectListPass(name13, whenTaskDisabled = false) {
        return this._addPass(name13, FrameGraphPassType.ObjectList, whenTaskDisabled);
      }
      _addPass(name13, passType, whenTaskDisabled = false) {
        if (!this._currentProcessedTask) {
          throw new Error("FrameGraph: A pass must be created during a Task.record execution only.");
        }
        let pass;
        switch (passType) {
          case FrameGraphPassType.Render:
            pass = new FrameGraphRenderPass(name13, this._currentProcessedTask, this._renderContext, this._engine);
            break;
          case FrameGraphPassType.ObjectList:
            pass = new FrameGraphObjectListPass(name13, this._currentProcessedTask, this._passContext, this._engine);
            break;
          default:
            pass = new FrameGraphPass(name13, this._currentProcessedTask, this._passContext);
            break;
        }
        this._currentProcessedTask._addPass(pass, whenTaskDisabled);
        return pass;
      }
      /** @internal */
      async _whenAsynchronousInitializationDoneAsync() {
        if (this._initAsyncPromises.length > 0) {
          await Promise.all(this._initAsyncPromises);
          this._initAsyncPromises.length = 0;
        }
      }
      /**
       * Builds the frame graph.
       * This method should be called after all tasks have been added to the frame graph (FrameGraph.addTask) and before the graph is executed (FrameGraph.execute).
       * @param waitForReadiness If true, the method will wait for the frame graph to be ready before returning (default is true)
       */
      async buildAsync(waitForReadiness = true) {
        this.textureManager._releaseTextures(false);
        this.pausedExecution = true;
        try {
          await this._importPromise;
          await this._whenAsynchronousInitializationDoneAsync();
          for (const task of this._tasks) {
            task._reset();
            this._currentProcessedTask = task;
            this.textureManager._isRecordingTask = true;
            task.record();
            this.textureManager._isRecordingTask = false;
            this._currentProcessedTask = null;
          }
          this.textureManager._allocateTextures(this.optimizeTextureAllocation ? this._tasks : void 0);
          for (const task of this._tasks) {
            task._checkTask();
          }
          for (const task of this._tasks) {
            task.onTexturesAllocatedObservable.notifyObservers(this._renderContext);
          }
          for (const task of this._tasks) {
            task._initializePasses();
          }
          this.onBuildObservable.notifyObservers(this);
          if (waitForReadiness) {
            await this.whenReadyAsync();
          }
        } catch (e) {
          this._tasks.length = 0;
          this._currentProcessedTask = null;
          this.textureManager._isRecordingTask = false;
          throw e;
        } finally {
          this.pausedExecution = false;
        }
      }
      /**
       * Checks if the frame graph is ready to be executed.
       * Note that you can use the whenReadyAsync method to wait for the frame graph to be ready.
       * @returns True if the frame graph is ready to be executed, else false
       */
      isReady() {
        let ready = this._renderContext._isReady();
        for (const task of this._tasks) {
          ready && (ready = task.isReady());
        }
        return ready;
      }
      /**
       * Returns a promise that resolves when the frame graph is ready to be executed.
       * In general, calling await buildAsync() should suffice, as this function also waits for readiness by default.
       * @param timeStep Time step in ms between retries (default is 16)
       * @param maxTimeout Maximum time in ms to wait for the graph to be ready (default is 10000)
       * @returns The promise that resolves when the graph is ready
       */
      async whenReadyAsync(timeStep = 16, maxTimeout = 1e4) {
        let firstNotReadyTask = null;
        return await new Promise((resolve, reject) => {
          this._whenReadyAsyncCancel = _RetryWithInterval(() => {
            let ready = this._renderContext._isReady();
            for (const task of this._tasks) {
              const taskIsReady = task.isReady();
              if (!taskIsReady && !firstNotReadyTask) {
                firstNotReadyTask = task;
              }
              ready && (ready = taskIsReady);
            }
            return ready;
          }, () => {
            this._whenReadyAsyncCancel = null;
            resolve();
          }, (err, isTimeout) => {
            this._whenReadyAsyncCancel = null;
            if (!isTimeout) {
              Logger.Error("FrameGraph: An unexpected error occurred while waiting for the frame graph to be ready.");
              if (err) {
                Logger.Error(err);
                if (err.stack) {
                  Logger.Error(err.stack);
                }
              }
            } else {
              Logger.Error(`FrameGraph: Timeout while waiting for the frame graph to be ready.${firstNotReadyTask ? ` First task not ready: ${firstNotReadyTask.name}` : ""}`);
              if (err) {
                Logger.Error(err);
              }
            }
            reject(new Error(err));
          }, timeStep, maxTimeout);
        });
      }
      /**
       * Executes the frame graph.
       */
      execute() {
        if (this.pausedExecution) {
          return;
        }
        this._renderContext.restoreDefaultFramebuffer();
        this.textureManager._updateHistoryTextures();
        for (const task of this._tasks) {
          task._execute();
        }
        this._renderContext.restoreDefaultFramebuffer();
      }
      /**
       * Clears the frame graph (remove the tasks and release the textures).
       * The frame graph can be built again after this method is called.
       */
      clear() {
        this._whenReadyAsyncCancel?.();
        this._whenReadyAsyncCancel = null;
        for (const task of this._tasks) {
          task._reset();
        }
        this._tasks.length = 0;
        this.textureManager._releaseTextures();
        this._currentProcessedTask = null;
      }
      /**
       * Disposes the frame graph
       */
      dispose() {
        this._whenReadyAsyncCancel?.();
        this._whenReadyAsyncCancel = null;
        this.clear();
        this.textureManager._dispose();
        this._renderContext._dispose();
        this._scene.removeFrameGraph(this);
      }
    };
  }
});

// node_modules/@babylonjs/core/Decorators/nodeDecorator.js
function editableInPropertyPage(displayName, propertyType = 0, groupName = "PROPERTIES", options) {
  return (target, propertyKey) => {
    let propStore = target._propStore;
    if (!propStore) {
      propStore = [];
      target._propStore = propStore;
    }
    propStore.push({
      propertyName: propertyKey,
      displayName,
      type: propertyType,
      groupName,
      options: options ?? {},
      className: target.getClassName()
    });
  };
}
var PropertyTypeForEdition;
var init_nodeDecorator = __esm({
  "node_modules/@babylonjs/core/Decorators/nodeDecorator.js"() {
    (function(PropertyTypeForEdition2) {
      PropertyTypeForEdition2[PropertyTypeForEdition2["Boolean"] = 0] = "Boolean";
      PropertyTypeForEdition2[PropertyTypeForEdition2["Float"] = 1] = "Float";
      PropertyTypeForEdition2[PropertyTypeForEdition2["Int"] = 2] = "Int";
      PropertyTypeForEdition2[PropertyTypeForEdition2["Vector2"] = 3] = "Vector2";
      PropertyTypeForEdition2[PropertyTypeForEdition2["Vector3"] = 4] = "Vector3";
      PropertyTypeForEdition2[PropertyTypeForEdition2["List"] = 5] = "List";
      PropertyTypeForEdition2[PropertyTypeForEdition2["Color3"] = 6] = "Color3";
      PropertyTypeForEdition2[PropertyTypeForEdition2["Color4"] = 7] = "Color4";
      PropertyTypeForEdition2[PropertyTypeForEdition2["SamplingMode"] = 8] = "SamplingMode";
      PropertyTypeForEdition2[PropertyTypeForEdition2["TextureFormat"] = 9] = "TextureFormat";
      PropertyTypeForEdition2[PropertyTypeForEdition2["TextureType"] = 10] = "TextureType";
      PropertyTypeForEdition2[PropertyTypeForEdition2["String"] = 11] = "String";
      PropertyTypeForEdition2[PropertyTypeForEdition2["Matrix"] = 12] = "Matrix";
      PropertyTypeForEdition2[PropertyTypeForEdition2["Viewport"] = 13] = "Viewport";
    })(PropertyTypeForEdition || (PropertyTypeForEdition = {}));
  }
});

// node_modules/@babylonjs/core/Lights/shadowLight.js
var ShadowLight;
var init_shadowLight = __esm({
  "node_modules/@babylonjs/core/Lights/shadowLight.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_light();
    init_math_axis();
    ShadowLight = class extends Light {
      constructor() {
        super(...arguments);
        this._needProjectionMatrixCompute = true;
        this._viewMatrix = Matrix.Identity();
        this._projectionMatrix = Matrix.Identity();
      }
      _setPosition(value) {
        this._position = value;
      }
      /**
       * Sets the position the shadow will be casted from. Also use as the light position for both
       * point and spot lights.
       */
      get position() {
        return this._position;
      }
      /**
       * Sets the position the shadow will be casted from. Also use as the light position for both
       * point and spot lights.
       */
      set position(value) {
        this._setPosition(value);
      }
      _setDirection(value) {
        this._direction = value;
      }
      /**
       * In 2d mode (needCube being false), gets the direction used to cast the shadow.
       * Also use as the light direction on spot and directional lights.
       */
      get direction() {
        return this._direction;
      }
      /**
       * In 2d mode (needCube being false), sets the direction used to cast the shadow.
       * Also use as the light direction on spot and directional lights.
       */
      set direction(value) {
        this._setDirection(value);
      }
      /**
       * Gets the shadow projection clipping minimum z value.
       */
      get shadowMinZ() {
        return this._shadowMinZ;
      }
      /**
       * Sets the shadow projection clipping minimum z value.
       */
      set shadowMinZ(value) {
        this._shadowMinZ = value;
        this.forceProjectionMatrixCompute();
      }
      /**
       * Sets the shadow projection clipping maximum z value.
       */
      get shadowMaxZ() {
        return this._shadowMaxZ;
      }
      /**
       * Gets the shadow projection clipping maximum z value.
       */
      set shadowMaxZ(value) {
        this._shadowMaxZ = value;
        this.forceProjectionMatrixCompute();
      }
      /**
       * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
       * @returns true if the information has been computed, false if it does not need to (no parenting)
       */
      computeTransformedInformation() {
        if (this.parent && this.parent.getWorldMatrix) {
          if (!this.transformedPosition) {
            this.transformedPosition = Vector3.Zero();
          }
          Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);
          if (this.direction) {
            if (!this.transformedDirection) {
              this.transformedDirection = Vector3.Zero();
            }
            Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);
          }
          return true;
        }
        return false;
      }
      /**
       * Return the depth scale used for the shadow map.
       * @returns the depth scale.
       */
      getDepthScale() {
        return 50;
      }
      /**
       * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.
       * @param faceIndex The index of the face we are computed the direction to generate shadow
       * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getShadowDirection(faceIndex) {
        return this.transformedDirection ? this.transformedDirection : this.direction;
      }
      /**
       * If computeTransformedInformation has been called, returns the ShadowLight absolute position in the world. Otherwise, returns the local position.
       * @returns the position vector in world space
       */
      getAbsolutePosition() {
        return this.transformedPosition ? this.transformedPosition : this.position;
      }
      /**
       * Sets the ShadowLight direction toward the passed target.
       * @param target The point to target in local space
       * @returns the updated ShadowLight direction
       */
      setDirectionToTarget(target) {
        this.direction = Vector3.Normalize(target.subtract(this.position));
        return this.direction;
      }
      /**
       * Returns the light rotation in euler definition.
       * @returns the x y z rotation in local space.
       */
      getRotation() {
        this.direction.normalize();
        const xaxis = Vector3.Cross(this.direction, Axis.Y);
        const yaxis = Vector3.Cross(xaxis, this.direction);
        return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);
      }
      /**
       * Returns whether or not the shadow generation require a cube texture or a 2d texture.
       * @returns true if a cube texture needs to be use
       */
      needCube() {
        return false;
      }
      /**
       * Detects if the projection matrix requires to be recomputed this frame.
       * @returns true if it requires to be recomputed otherwise, false.
       */
      needProjectionMatrixCompute() {
        return this._needProjectionMatrixCompute;
      }
      /**
       * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
       */
      forceProjectionMatrixCompute() {
        this._needProjectionMatrixCompute = true;
      }
      /** @internal */
      _initCache() {
        super._initCache();
        this._cache.position = Vector3.Zero();
      }
      /** @internal */
      _isSynchronized() {
        if (!this._cache.position.equals(this.position)) {
          return false;
        }
        return true;
      }
      /**
       * Computes the world matrix of the node
       * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
       * @returns the world matrix
       */
      computeWorldMatrix(force) {
        if (!force && this.isSynchronized()) {
          this._currentRenderId = this.getScene().getRenderId();
          return this._worldMatrix;
        }
        this._updateCache();
        this._cache.position.copyFrom(this.position);
        if (!this._worldMatrix) {
          this._worldMatrix = Matrix.Identity();
        }
        Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);
        if (this.parent && this.parent.getWorldMatrix) {
          this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);
          this._markSyncedWithParent();
        }
        this._worldMatrixDeterminantIsDirty = true;
        return this._worldMatrix;
      }
      /**
       * Gets the minZ used for shadow according to both the scene and the light.
       * @param activeCamera The camera we are returning the min for
       * @returns the depth min z
       */
      getDepthMinZ(activeCamera) {
        return this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera?.minZ || 0;
      }
      /**
       * Gets the maxZ used for shadow according to both the scene and the light.
       * @param activeCamera The camera we are returning the max for
       * @returns the depth max z
       */
      getDepthMaxZ(activeCamera) {
        return this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera?.maxZ || 1e4;
      }
      /**
       * Sets the shadow projection matrix in parameter to the generated projection matrix.
       * @param matrix The matrix to updated with the projection information
       * @param viewMatrix The transform matrix of the light
       * @param renderList The list of mesh to render in the map
       * @returns The current light
       */
      setShadowProjectionMatrix(matrix, viewMatrix, renderList) {
        if (this.customProjectionMatrixBuilder) {
          this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);
        } else {
          this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);
        }
        return this;
      }
      /** @internal */
      _syncParentEnabledState() {
        super._syncParentEnabledState();
        if (!this.parent || !this.parent.getWorldMatrix) {
          this.transformedPosition = null;
          this.transformedDirection = null;
        }
      }
      /**
       * Returns the view matrix.
       * @param faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.
       * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
       */
      getViewMatrix(faceIndex) {
        const lightDirection = TmpVectors.Vector3[0];
        let lightPosition = this.position;
        if (this.computeTransformedInformation()) {
          lightPosition = this.transformedPosition;
        }
        Vector3.NormalizeToRef(this.getShadowDirection(faceIndex), lightDirection);
        if (Math.abs(Vector3.Dot(lightDirection, Vector3.Up())) === 1) {
          lightDirection.z = 1e-13;
        }
        const lightTarget = TmpVectors.Vector3[1];
        lightPosition.addToRef(lightDirection, lightTarget);
        Matrix.LookAtLHToRef(lightPosition, lightTarget, Vector3.Up(), this._viewMatrix);
        return this._viewMatrix;
      }
      /**
       * Returns the projection matrix.
       * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).
       * @param viewMatrix The view transform matrix of the light (optional).
       * @param renderList The list of meshes to take into account when calculating the projection matrix (optional).
       * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
       */
      getProjectionMatrix(viewMatrix, renderList) {
        this.setShadowProjectionMatrix(this._projectionMatrix, viewMatrix ?? this._viewMatrix, renderList ?? []);
        return this._projectionMatrix;
      }
    };
    __decorate([
      serializeAsVector3()
    ], ShadowLight.prototype, "position", null);
    __decorate([
      serializeAsVector3()
    ], ShadowLight.prototype, "direction", null);
    __decorate([
      serialize()
    ], ShadowLight.prototype, "shadowMinZ", null);
    __decorate([
      serialize()
    ], ShadowLight.prototype, "shadowMaxZ", null);
  }
});

// node_modules/@babylonjs/core/Lights/directionalLight.js
var DirectionalLight;
var init_directionalLight = __esm({
  "node_modules/@babylonjs/core/Lights/directionalLight.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_node();
    init_light();
    init_shadowLight();
    init_typeStore();
    Node.AddNodeConstructor("Light_Type_1", (name13, scene) => {
      return () => new DirectionalLight(name13, Vector3.Zero(), scene);
    });
    DirectionalLight = class extends ShadowLight {
      /**
       * Fix frustum size for the shadow generation. This is disabled if the value is 0.
       */
      get shadowFrustumSize() {
        return this._shadowFrustumSize;
      }
      /**
       * Specifies a fix frustum size for the shadow generation.
       */
      set shadowFrustumSize(value) {
        this._shadowFrustumSize = value;
        this.forceProjectionMatrixCompute();
      }
      /**
       * Gets the shadow projection scale against the optimal computed one.
       * 0.1 by default which means that the projection window is increase by 10% from the optimal size.
       * This does not impact in fixed frustum size (shadowFrustumSize being set)
       */
      get shadowOrthoScale() {
        return this._shadowOrthoScale;
      }
      /**
       * Sets the shadow projection scale against the optimal computed one.
       * 0.1 by default which means that the projection window is increase by 10% from the optimal size.
       * This does not impact in fixed frustum size (shadowFrustumSize being set)
       */
      set shadowOrthoScale(value) {
        this._shadowOrthoScale = value;
        this.forceProjectionMatrixCompute();
      }
      /**
       * Gets or sets the orthoLeft property used to build the light frustum
       */
      get orthoLeft() {
        return this._orthoLeft;
      }
      set orthoLeft(left) {
        this._orthoLeft = left;
      }
      /**
       * Gets or sets the orthoRight property used to build the light frustum
       */
      get orthoRight() {
        return this._orthoRight;
      }
      set orthoRight(right) {
        this._orthoRight = right;
      }
      /**
       * Gets or sets the orthoTop property used to build the light frustum
       */
      get orthoTop() {
        return this._orthoTop;
      }
      set orthoTop(top) {
        this._orthoTop = top;
      }
      /**
       * Gets or sets the orthoBottom property used to build the light frustum
       */
      get orthoBottom() {
        return this._orthoBottom;
      }
      set orthoBottom(bottom) {
        this._orthoBottom = bottom;
      }
      /**
       * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).
       * The directional light is emitted from everywhere in the given direction.
       * It can cast shadows.
       * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
       * @param name The friendly name of the light
       * @param direction The direction of the light
       * @param scene The scene the light belongs to
       * @param dontAddToScene True to not add the light to the scene
       */
      constructor(name13, direction, scene, dontAddToScene) {
        super(name13, scene, dontAddToScene);
        this._shadowFrustumSize = 0;
        this._shadowOrthoScale = 0.1;
        this.autoUpdateExtends = true;
        this.autoCalcShadowZBounds = false;
        this._orthoLeft = Number.MAX_VALUE;
        this._orthoRight = Number.MIN_VALUE;
        this._orthoTop = Number.MIN_VALUE;
        this._orthoBottom = Number.MAX_VALUE;
        this.position = direction.scale(-1);
        this.direction = direction;
      }
      /**
       * Returns the string "DirectionalLight".
       * @returns The class name
       */
      getClassName() {
        return "DirectionalLight";
      }
      /**
       * Returns the integer 1.
       * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      getTypeID() {
        return Light.LIGHTTYPEID_DIRECTIONALLIGHT;
      }
      /**
       * Sets the passed matrix "matrix" as projection matrix for the shadows cast by the light according to the passed view matrix.
       * Returns the DirectionalLight Shadow projection matrix.
       * @param matrix
       * @param viewMatrix
       * @param renderList
       */
      _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {
        if (this.shadowFrustumSize > 0) {
          this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);
        } else {
          this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);
        }
      }
      /**
       * Sets the passed matrix "matrix" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.
       * Returns the DirectionalLight Shadow projection matrix.
       * @param matrix
       */
      _setDefaultFixedFrustumShadowProjectionMatrix(matrix) {
        const activeCamera = this.getScene().activeCamera;
        Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera ? activeCamera.minZ : 0, this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera ? activeCamera.maxZ : 1e4, matrix, this.getScene().getEngine().isNDCHalfZRange);
      }
      /**
       * Sets the passed matrix "matrix" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.
       * Returns the DirectionalLight Shadow projection matrix.
       * @param matrix
       * @param viewMatrix
       * @param renderList
       */
      _setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList) {
        const activeCamera = this.getScene().activeCamera;
        if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {
          const tempVector3 = Vector3.Zero();
          this._orthoLeft = Number.MAX_VALUE;
          this._orthoRight = -Number.MAX_VALUE;
          this._orthoTop = -Number.MAX_VALUE;
          this._orthoBottom = Number.MAX_VALUE;
          let shadowMinZ = Number.MAX_VALUE;
          let shadowMaxZ = -Number.MAX_VALUE;
          for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
            const mesh = renderList[meshIndex];
            if (!mesh) {
              continue;
            }
            const boundingInfo = mesh.getBoundingInfo();
            const boundingBox = boundingInfo.boundingBox;
            for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {
              Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);
              if (tempVector3.x < this._orthoLeft) {
                this._orthoLeft = tempVector3.x;
              }
              if (tempVector3.y < this._orthoBottom) {
                this._orthoBottom = tempVector3.y;
              }
              if (tempVector3.x > this._orthoRight) {
                this._orthoRight = tempVector3.x;
              }
              if (tempVector3.y > this._orthoTop) {
                this._orthoTop = tempVector3.y;
              }
              if (this.autoCalcShadowZBounds) {
                if (tempVector3.z < shadowMinZ) {
                  shadowMinZ = tempVector3.z;
                }
                if (tempVector3.z > shadowMaxZ) {
                  shadowMaxZ = tempVector3.z;
                }
              }
            }
          }
          if (this.autoCalcShadowZBounds) {
            this._shadowMinZ = shadowMinZ;
            this._shadowMaxZ = shadowMaxZ;
          }
        }
        const xOffset = this._orthoRight - this._orthoLeft;
        const yOffset = this._orthoTop - this._orthoBottom;
        const minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera?.minZ || 0;
        const maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera?.maxZ || 1e4;
        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
        Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);
      }
      _buildUniformLayout() {
        this._uniformBuffer.addUniform("vLightData", 4);
        this._uniformBuffer.addUniform("vLightDiffuse", 4);
        this._uniformBuffer.addUniform("vLightSpecular", 4);
        this._uniformBuffer.addUniform("shadowsInfo", 3);
        this._uniformBuffer.addUniform("depthValues", 2);
        this._uniformBuffer.create();
      }
      /**
       * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.
       * @param effect The effect to update
       * @param lightIndex The index of the light in the effect to update
       * @returns The directional light
       */
      transferToEffect(effect, lightIndex) {
        if (this.computeTransformedInformation()) {
          this._uniformBuffer.updateFloat4("vLightData", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);
          return this;
        }
        this._uniformBuffer.updateFloat4("vLightData", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);
        return this;
      }
      transferToNodeMaterialEffect(effect, lightDataUniformName) {
        if (this.computeTransformedInformation()) {
          effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);
          return this;
        }
        effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);
        return this;
      }
      /**
       * Gets the minZ used for shadow according to both the scene and the light.
       *
       * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
       * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
       * (when not using reverse depth buffer / NDC half Z range)
       * @param _activeCamera The camera we are returning the min for (not used)
       * @returns the depth min z
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getDepthMinZ(_activeCamera) {
        const engine = this._scene.getEngine();
        return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
      }
      /**
       * Gets the maxZ used for shadow according to both the scene and the light.
       *
       * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
       * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
       * (when not using reverse depth buffer / NDC half Z range)
       * @param _activeCamera The camera we are returning the max for
       * @returns the depth max z
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getDepthMaxZ(_activeCamera) {
        const engine = this._scene.getEngine();
        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
      }
      /**
       * Prepares the list of defines specific to the light type.
       * @param defines the list of defines
       * @param lightIndex defines the index of the light for the effect
       */
      prepareLightSpecificDefines(defines, lightIndex) {
        defines["DIRLIGHT" + lightIndex] = true;
      }
    };
    __decorate([
      serialize()
    ], DirectionalLight.prototype, "shadowFrustumSize", null);
    __decorate([
      serialize()
    ], DirectionalLight.prototype, "shadowOrthoScale", null);
    __decorate([
      serialize()
    ], DirectionalLight.prototype, "autoUpdateExtends", void 0);
    __decorate([
      serialize()
    ], DirectionalLight.prototype, "autoCalcShadowZBounds", void 0);
    __decorate([
      serialize("orthoLeft")
    ], DirectionalLight.prototype, "_orthoLeft", void 0);
    __decorate([
      serialize("orthoRight")
    ], DirectionalLight.prototype, "_orthoRight", void 0);
    __decorate([
      serialize("orthoTop")
    ], DirectionalLight.prototype, "_orthoTop", void 0);
    __decorate([
      serialize("orthoBottom")
    ], DirectionalLight.prototype, "_orthoBottom", void 0);
    RegisterClass("BABYLON.DirectionalLight", DirectionalLight);
  }
});

// node_modules/@babylonjs/core/Layers/thinEffectLayer.js
var ThinGlowBlurPostProcess, ThinEffectLayer;
var init_thinEffectLayer = __esm({
  "node_modules/@babylonjs/core/Layers/thinEffectLayer.js"() {
    init_observable();
    init_math_color();
    init_engineStore();
    init_buffer();
    init_effectRenderer();
    init_material();
    init_effectFallbacks();
    init_drawWrapper();
    init_clipPlaneMaterialHelper();
    init_materialHelper_functions();
    init_objectRenderer();
    init_engine();
    ThinGlowBlurPostProcess = class _ThinGlowBlurPostProcess extends EffectWrapper {
      constructor(name13, engine = null, direction, kernel, options) {
        super({
          ...options,
          name: name13,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinGlowBlurPostProcess.FragmentUrl,
          uniforms: _ThinGlowBlurPostProcess.Uniforms
        });
        this.direction = direction;
        this.kernel = kernel;
        this.textureWidth = 0;
        this.textureHeight = 0;
      }
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(import("./glowBlurPostProcess.fragment-5X3IMKZX.js"));
        } else {
          list.push(import("./glowBlurPostProcess.fragment-C5WIMY7G.js"));
        }
        super._gatherImports(useWebGPU, list);
      }
      bind() {
        super.bind();
        this._drawWrapper.effect.setFloat2("screenSize", this.textureWidth, this.textureHeight);
        this._drawWrapper.effect.setVector2("direction", this.direction);
        this._drawWrapper.effect.setFloat("blurWidth", this.kernel);
      }
    };
    ThinGlowBlurPostProcess.FragmentUrl = "glowBlurPostProcess";
    ThinGlowBlurPostProcess.Uniforms = ["screenSize", "direction", "blurWidth"];
    ThinEffectLayer = class _ThinEffectLayer {
      /**
       * Gets/sets the camera attached to the layer.
       */
      get camera() {
        return this._options.camera;
      }
      set camera(camera) {
        this._options.camera = camera;
      }
      /**
       * Gets the rendering group id the layer should render in.
       */
      get renderingGroupId() {
        return this._options.renderingGroupId;
      }
      set renderingGroupId(renderingGroupId) {
        this._options.renderingGroupId = renderingGroupId;
      }
      /**
       * Gets the object renderer used to render objects in the layer
       */
      get objectRenderer() {
        return this._objectRenderer;
      }
      /**
       * Gets the shader language used in this material.
       */
      get shaderLanguage() {
        return this._shaderLanguage;
      }
      /**
       * Sets a specific material to be used to render a mesh/a list of meshes in the layer
       * @param mesh mesh or array of meshes
       * @param material material to use by the layer when rendering the mesh(es). If undefined is passed, the specific material created by the layer will be used.
       */
      setMaterialForRendering(mesh, material) {
        this._objectRenderer.setMaterialForRendering(mesh, material);
        if (Array.isArray(mesh)) {
          for (let i = 0; i < mesh.length; ++i) {
            const currentMesh = mesh[i];
            if (!material) {
              delete this._materialForRendering[currentMesh.uniqueId];
            } else {
              this._materialForRendering[currentMesh.uniqueId] = [currentMesh, material];
            }
          }
        } else {
          if (!material) {
            delete this._materialForRendering[mesh.uniqueId];
          } else {
            this._materialForRendering[mesh.uniqueId] = [mesh, material];
          }
        }
      }
      /**
       * Gets the intensity of the effect for a specific mesh.
       * @param mesh The mesh to get the effect intensity for
       * @returns The intensity of the effect for the mesh
       */
      getEffectIntensity(mesh) {
        return this._effectIntensity[mesh.uniqueId] ?? 1;
      }
      /**
       * Sets the intensity of the effect for a specific mesh.
       * @param mesh The mesh to set the effect intensity for
       * @param intensity The intensity of the effect for the mesh
       */
      setEffectIntensity(mesh, intensity) {
        this._effectIntensity[mesh.uniqueId] = intensity;
      }
      /**
       * Instantiates a new effect Layer
       * @param name The name of the layer
       * @param scene The scene to use the layer in
       * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
       * @param dontCheckIfReady Specifies if the layer should disable checking whether all the post processes are ready (default: false). To save performance, this should be set to true and you should call `isReady` manually before rendering to the layer.
       * @param _additionalImportShadersAsync Additional shaders to import when the layer is created
       */
      constructor(name13, scene, forceGLSL = false, dontCheckIfReady = false, _additionalImportShadersAsync) {
        this._additionalImportShadersAsync = _additionalImportShadersAsync;
        this._vertexBuffers = {};
        this._dontCheckIfReady = false;
        this._shouldRender = true;
        this._emissiveTextureAndColor = { texture: null, color: new Color4() };
        this._effectIntensity = {};
        this._postProcesses = [];
        this.neutralColor = new Color4();
        this.isEnabled = true;
        this.disableBoundingBoxesFromEffectLayer = false;
        this.onDisposeObservable = new Observable();
        this.onBeforeRenderLayerObservable = new Observable();
        this.onBeforeComposeObservable = new Observable();
        this.onBeforeRenderMeshToEffect = new Observable();
        this.onAfterRenderMeshToEffect = new Observable();
        this.onAfterComposeObservable = new Observable();
        this.onBeforeBlurObservable = new Observable();
        this.onAfterBlurObservable = new Observable();
        this._shaderLanguage = 0;
        this._materialForRendering = {};
        this._shadersLoaded = false;
        this.name = name13;
        this._scene = scene || EngineStore.LastCreatedScene;
        this._dontCheckIfReady = dontCheckIfReady;
        const engine = this._scene.getEngine();
        if (engine.isWebGPU && !forceGLSL && !_ThinEffectLayer.ForceGLSL) {
          this._shaderLanguage = 1;
        }
        this._engine = this._scene.getEngine();
        this._mergeDrawWrapper = [];
        this._generateIndexBuffer();
        this._generateVertexBuffer();
      }
      /**
       * Get the effect name of the layer.
       * @returns The effect name
       */
      getEffectName() {
        return "";
      }
      /**
       * Checks for the readiness of the element composing the layer.
       * @param _subMesh the mesh to check for
       * @param _useInstances specify whether or not to use instances to render the mesh
       * @returns true if ready otherwise, false
       */
      isReady(_subMesh, _useInstances) {
        return true;
      }
      /**
       * Returns whether or not the layer needs stencil enabled during the mesh rendering.
       * @returns true if the effect requires stencil during the main canvas render pass.
       */
      needStencil() {
        return false;
      }
      /** @internal */
      _createMergeEffect() {
        throw new Error("Effect Layer: no merge effect defined");
      }
      /** @internal */
      _createTextureAndPostProcesses() {
      }
      /** @internal */
      _internalCompose(_effect, _renderIndex) {
      }
      /** @internal */
      _setEmissiveTextureAndColor(_mesh, _subMesh, _material) {
      }
      /** @internal */
      _numInternalDraws() {
        return 1;
      }
      /** @internal */
      _init(options) {
        this._options = {
          mainTextureRatio: 0.5,
          mainTextureFixedSize: 0,
          mainTextureType: 0,
          alphaBlendingMode: 2,
          camera: null,
          renderingGroupId: -1,
          ...options
        };
        this._createObjectRenderer();
      }
      _generateIndexBuffer() {
        const indices = [];
        indices.push(0);
        indices.push(1);
        indices.push(2);
        indices.push(0);
        indices.push(2);
        indices.push(3);
        this._indexBuffer = this._engine.createIndexBuffer(indices);
      }
      _generateVertexBuffer() {
        const vertices = [];
        vertices.push(1, 1);
        vertices.push(-1, 1);
        vertices.push(-1, -1);
        vertices.push(1, -1);
        const vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);
        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;
      }
      _createObjectRenderer() {
        this._objectRenderer = new ObjectRenderer(`ObjectRenderer for thin effect layer ${this.name}`, this._scene, {
          doNotChangeAspectRatio: true
        });
        this._objectRenderer.activeCamera = this._options.camera;
        this._objectRenderer.renderParticles = false;
        this._objectRenderer.renderList = null;
        const hasBoundingBoxRenderer = !!this._scene.getBoundingBoxRenderer;
        let boundingBoxRendererEnabled = false;
        if (hasBoundingBoxRenderer) {
          this._objectRenderer.onBeforeRenderObservable.add(() => {
            boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;
            this._scene.getBoundingBoxRenderer().enabled = !this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;
          });
          this._objectRenderer.onAfterRenderObservable.add(() => {
            this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;
          });
        }
        this._objectRenderer.customIsReadyFunction = (mesh, refreshRate, preWarm) => {
          if ((preWarm || refreshRate === 0) && mesh.subMeshes) {
            for (let i = 0; i < mesh.subMeshes.length; ++i) {
              const subMesh = mesh.subMeshes[i];
              const material = subMesh.getMaterial();
              const renderingMesh = subMesh.getRenderingMesh();
              if (!material) {
                continue;
              }
              const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
              const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;
              this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);
              if (!this._isSubMeshReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {
                return false;
              }
            }
          }
          return true;
        };
        this._objectRenderer.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {
          this.onBeforeRenderLayerObservable.notifyObservers(this);
          let index;
          const engine = this._scene.getEngine();
          if (depthOnlySubMeshes.length) {
            engine.setColorWrite(false);
            for (index = 0; index < depthOnlySubMeshes.length; index++) {
              this._renderSubMesh(depthOnlySubMeshes.data[index]);
            }
            engine.setColorWrite(true);
          }
          for (index = 0; index < opaqueSubMeshes.length; index++) {
            this._renderSubMesh(opaqueSubMeshes.data[index]);
          }
          for (index = 0; index < alphaTestSubMeshes.length; index++) {
            this._renderSubMesh(alphaTestSubMeshes.data[index]);
          }
          const previousAlphaMode = engine.getAlphaMode();
          for (index = 0; index < transparentSubMeshes.length; index++) {
            const subMesh = transparentSubMeshes.data[index];
            const material = subMesh.getMaterial();
            if (material && material.needDepthPrePass) {
              const engine2 = material.getScene().getEngine();
              engine2.setColorWrite(false);
              this._renderSubMesh(subMesh);
              engine2.setColorWrite(true);
            }
            this._renderSubMesh(subMesh, true);
          }
          engine.setAlphaMode(previousAlphaMode);
        };
      }
      /** @internal */
      _addCustomEffectDefines(_defines) {
      }
      /** @internal */
      _internalIsSubMeshReady(subMesh, useInstances, emissiveTexture) {
        const engine = this._scene.getEngine();
        const mesh = subMesh.getMesh();
        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];
        if (renderingMaterial) {
          return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);
        }
        const material = subMesh.getMaterial();
        if (!material) {
          return false;
        }
        if (this._useMeshMaterial(subMesh.getRenderingMesh())) {
          return material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);
        }
        const defines = [];
        const attribs = [VertexBuffer.PositionKind];
        let uv1 = false;
        let uv2 = false;
        const color = false;
        if (material) {
          const needAlphaTest = material.needAlphaTestingForMesh(mesh);
          const diffuseTexture = material.getAlphaTestTexture();
          const needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);
          if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {
            defines.push("#define DIFFUSE");
            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && diffuseTexture.coordinatesIndex === 1) {
              defines.push("#define DIFFUSEUV2");
              uv2 = true;
            } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
              defines.push("#define DIFFUSEUV1");
              uv1 = true;
            }
            if (needAlphaTest) {
              defines.push("#define ALPHATEST");
              defines.push("#define ALPHATESTVALUE 0.4");
            }
            if (!diffuseTexture.gammaSpace) {
              defines.push("#define DIFFUSE_ISLINEAR");
            }
          }
          const opacityTexture = material.opacityTexture;
          if (opacityTexture) {
            defines.push("#define OPACITY");
            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && opacityTexture.coordinatesIndex === 1) {
              defines.push("#define OPACITYUV2");
              uv2 = true;
            } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
              defines.push("#define OPACITYUV1");
              uv1 = true;
            }
          }
        }
        if (emissiveTexture) {
          defines.push("#define EMISSIVE");
          if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && emissiveTexture.coordinatesIndex === 1) {
            defines.push("#define EMISSIVEUV2");
            uv2 = true;
          } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
            defines.push("#define EMISSIVEUV1");
            uv1 = true;
          }
          if (!emissiveTexture.gammaSpace) {
            defines.push("#define EMISSIVE_ISLINEAR");
          }
        }
        if (mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha && material.transparencyMode !== Material.MATERIAL_OPAQUE) {
          attribs.push(VertexBuffer.ColorKind);
          defines.push("#define VERTEXALPHA");
        }
        if (uv1) {
          attribs.push(VertexBuffer.UVKind);
          defines.push("#define UV1");
        }
        if (uv2) {
          attribs.push(VertexBuffer.UV2Kind);
          defines.push("#define UV2");
        }
        const fallbacks = new EffectFallbacks();
        if (mesh.useBones && mesh.computeBonesUsingShaders) {
          attribs.push(VertexBuffer.MatricesIndicesKind);
          attribs.push(VertexBuffer.MatricesWeightsKind);
          if (mesh.numBoneInfluencers > 4) {
            attribs.push(VertexBuffer.MatricesIndicesExtraKind);
            attribs.push(VertexBuffer.MatricesWeightsExtraKind);
          }
          defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
          const skeleton = mesh.skeleton;
          if (skeleton && skeleton.isUsingTextureForMatrices) {
            defines.push("#define BONETEXTURE");
          } else {
            defines.push("#define BonesPerMesh " + (skeleton ? skeleton.bones.length + 1 : 0));
          }
          if (mesh.numBoneInfluencers > 0) {
            fallbacks.addCPUSkinningFallback(0, mesh);
          }
        } else {
          defines.push("#define NUM_BONE_INFLUENCERS 0");
        }
        const numMorphInfluencers = mesh.morphTargetManager ? PrepareDefinesAndAttributesForMorphTargets(
          mesh.morphTargetManager,
          defines,
          attribs,
          mesh,
          true,
          // usePositionMorph
          false,
          // useNormalMorph
          false,
          // useTangentMorph
          uv1,
          // useUVMorph
          uv2,
          // useUV2Morph
          color
          // useColorMorph
        ) : 0;
        if (useInstances) {
          defines.push("#define INSTANCES");
          PushAttributesForInstances(attribs);
          if (subMesh.getRenderingMesh().hasThinInstances) {
            defines.push("#define THIN_INSTANCES");
          }
        }
        PrepareStringDefinesForClipPlanes(material, this._scene, defines);
        this._addCustomEffectDefines(defines);
        const drawWrapper = subMesh._getDrawWrapper(void 0, true);
        const cachedDefines = drawWrapper.defines;
        const join = defines.join("\n");
        if (cachedDefines !== join) {
          const uniforms = [
            "world",
            "mBones",
            "viewProjection",
            "glowColor",
            "morphTargetInfluences",
            "morphTargetCount",
            "boneTextureWidth",
            "diffuseMatrix",
            "emissiveMatrix",
            "opacityMatrix",
            "opacityIntensity",
            "morphTargetTextureInfo",
            "morphTargetTextureIndices",
            "glowIntensity"
          ];
          AddClipPlaneUniforms(uniforms);
          drawWrapper.setEffect(this._engine.createEffect("glowMapGeneration", attribs, uniforms, ["diffuseSampler", "emissiveSampler", "opacitySampler", "boneSampler", "morphTargets"], join, fallbacks, void 0, void 0, { maxSimultaneousMorphTargets: numMorphInfluencers }, this._shaderLanguage, this._shadersLoaded ? void 0 : async () => {
            await this._importShadersAsync();
            this._shadersLoaded = true;
          }), join);
        }
        const effectIsReady = drawWrapper.effect.isReady();
        return effectIsReady && (this._dontCheckIfReady || !this._dontCheckIfReady && this.isLayerReady());
      }
      /** @internal */
      _isSubMeshReady(subMesh, useInstances, emissiveTexture) {
        return this._internalIsSubMeshReady(subMesh, useInstances, emissiveTexture);
      }
      async _importShadersAsync() {
        if (this._shaderLanguage === 1) {
          await Promise.all([import("./glowMapGeneration.vertex-3X2JSWQD.js"), import("./glowMapGeneration.fragment-BX76WR7A.js")]);
        } else {
          await Promise.all([import("./glowMapGeneration.vertex-ZKX3LNU6.js"), import("./glowMapGeneration.fragment-KCIZRTYV.js")]);
        }
        this._additionalImportShadersAsync?.();
      }
      /** @internal */
      _internalIsLayerReady() {
        let isReady = true;
        for (let i = 0; i < this._postProcesses.length; i++) {
          isReady = this._postProcesses[i].isReady() && isReady;
        }
        const numDraws = this._numInternalDraws();
        for (let i = 0; i < numDraws; ++i) {
          let currentEffect = this._mergeDrawWrapper[i];
          if (!currentEffect) {
            currentEffect = this._mergeDrawWrapper[i] = new DrawWrapper(this._engine);
            currentEffect.setEffect(this._createMergeEffect());
          }
          isReady = currentEffect.effect.isReady() && isReady;
        }
        return isReady;
      }
      /**
       * Checks if the layer is ready to be used.
       * @returns true if the layer is ready to be used
       */
      isLayerReady() {
        return this._internalIsLayerReady();
      }
      /**
       * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.
       * @returns true if the rendering was successful
       */
      compose() {
        if (!this._dontCheckIfReady && !this.isLayerReady()) {
          return false;
        }
        const engine = this._scene.getEngine();
        const numDraws = this._numInternalDraws();
        this.onBeforeComposeObservable.notifyObservers(this);
        const previousAlphaMode = engine.getAlphaMode();
        for (let i = 0; i < numDraws; ++i) {
          const currentEffect = this._mergeDrawWrapper[i];
          engine.enableEffect(currentEffect);
          engine.setState(false);
          engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect.effect);
          engine.setAlphaMode(this._options.alphaBlendingMode);
          this._internalCompose(currentEffect.effect, i);
        }
        engine.setAlphaMode(previousAlphaMode);
        this.onAfterComposeObservable.notifyObservers(this);
        return true;
      }
      /** @internal */
      _internalHasMesh(mesh) {
        if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {
          return true;
        }
        return false;
      }
      /**
       * Determine if a given mesh will be used in the current effect.
       * @param mesh mesh to test
       * @returns true if the mesh will be used
       */
      hasMesh(mesh) {
        return this._internalHasMesh(mesh);
      }
      /** @internal */
      _internalShouldRender() {
        return this.isEnabled && this._shouldRender;
      }
      /**
       * Returns true if the layer contains information to display, otherwise false.
       * @returns true if the glow layer should be rendered
       */
      shouldRender() {
        return this._internalShouldRender();
      }
      /** @internal */
      _shouldRenderMesh(_mesh) {
        return true;
      }
      /** @internal */
      _internalCanRenderMesh(mesh, material) {
        return !material.needAlphaBlendingForMesh(mesh);
      }
      /** @internal */
      _canRenderMesh(mesh, material) {
        return this._internalCanRenderMesh(mesh, material);
      }
      _renderSubMesh(subMesh, enableAlphaMode = false) {
        if (!this._internalShouldRender()) {
          return;
        }
        const material = subMesh.getMaterial();
        const ownerMesh = subMesh.getMesh();
        const replacementMesh = subMesh.getReplacementMesh();
        const renderingMesh = subMesh.getRenderingMesh();
        const effectiveMesh = subMesh.getEffectiveMesh();
        const scene = this._scene;
        const engine = scene.getEngine();
        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
        if (!material) {
          return;
        }
        if (!this._canRenderMesh(renderingMesh, material)) {
          return;
        }
        let sideOrientation = material._getEffectiveOrientation(renderingMesh);
        const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();
        if (mainDeterminant < 0) {
          sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
        }
        const reverse = sideOrientation === Material.ClockWiseSideOrientation;
        engine.setState(material.backFaceCulling, material.zOffset, void 0, reverse, material.cullBackFaces, void 0, material.zOffsetUnits);
        const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);
        if (batch.mustReturn) {
          return;
        }
        if (!this._shouldRenderMesh(renderingMesh)) {
          return;
        }
        const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;
        this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);
        this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);
        if (this._useMeshMaterial(renderingMesh)) {
          subMesh.getMaterial()._glowModeEnabled = true;
          renderingMesh.render(subMesh, enableAlphaMode, replacementMesh || void 0);
          subMesh.getMaterial()._glowModeEnabled = false;
        } else if (this._isSubMeshReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {
          const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];
          let drawWrapper = subMesh._getDrawWrapper();
          if (!drawWrapper && renderingMaterial) {
            drawWrapper = renderingMaterial._getDrawWrapper();
          }
          if (!drawWrapper) {
            return;
          }
          const effect = drawWrapper.effect;
          engine.enableEffect(drawWrapper);
          if (!hardwareInstancedRendering) {
            renderingMesh._bind(subMesh, effect, material.fillMode);
          }
          if (!renderingMaterial) {
            effect.setMatrix("viewProjection", scene.getTransformMatrix());
            effect.setMatrix("world", effectiveMesh.getWorldMatrix());
            effect.setFloat4("glowColor", this._emissiveTextureAndColor.color.r, this._emissiveTextureAndColor.color.g, this._emissiveTextureAndColor.color.b, this._emissiveTextureAndColor.color.a);
          } else {
            renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);
          }
          if (!renderingMaterial) {
            const needAlphaTest = material.needAlphaTestingForMesh(effectiveMesh);
            const diffuseTexture = material.getAlphaTestTexture();
            const needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);
            if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {
              effect.setTexture("diffuseSampler", diffuseTexture);
              const textureMatrix = diffuseTexture.getTextureMatrix();
              if (textureMatrix) {
                effect.setMatrix("diffuseMatrix", textureMatrix);
              }
            }
            const opacityTexture = material.opacityTexture;
            if (opacityTexture) {
              effect.setTexture("opacitySampler", opacityTexture);
              effect.setFloat("opacityIntensity", opacityTexture.level);
              const textureMatrix = opacityTexture.getTextureMatrix();
              if (textureMatrix) {
                effect.setMatrix("opacityMatrix", textureMatrix);
              }
            }
            if (this._emissiveTextureAndColor.texture) {
              effect.setTexture("emissiveSampler", this._emissiveTextureAndColor.texture);
              effect.setMatrix("emissiveMatrix", this._emissiveTextureAndColor.texture.getTextureMatrix());
            }
            if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
              const skeleton = renderingMesh.skeleton;
              if (skeleton.isUsingTextureForMatrices) {
                const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);
                if (!boneTexture) {
                  return;
                }
                effect.setTexture("boneSampler", boneTexture);
                effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
              } else {
                effect.setMatrices("mBones", skeleton.getTransformMatrices(renderingMesh));
              }
            }
            BindMorphTargetParameters(renderingMesh, effect);
            if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
              renderingMesh.morphTargetManager._bind(effect);
            }
            if (enableAlphaMode) {
              engine.setAlphaMode(material.alphaMode);
            }
            effect.setFloat("glowIntensity", this.getEffectIntensity(renderingMesh));
            BindClipPlane(effect, material, scene);
          }
          renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => effect.setMatrix("world", world));
        } else {
          this._objectRenderer.resetRefreshCounter();
        }
        this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);
      }
      /** @internal */
      _useMeshMaterial(_mesh) {
        return false;
      }
      /** @internal */
      _rebuild() {
        const vb = this._vertexBuffers[VertexBuffer.PositionKind];
        if (vb) {
          vb._rebuild();
        }
        this._generateIndexBuffer();
      }
      /**
       * Dispose the effect layer and free resources.
       */
      dispose() {
        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
        if (vertexBuffer) {
          vertexBuffer.dispose();
          this._vertexBuffers[VertexBuffer.PositionKind] = null;
        }
        if (this._indexBuffer) {
          this._scene.getEngine()._releaseBuffer(this._indexBuffer);
          this._indexBuffer = null;
        }
        for (const drawWrapper of this._mergeDrawWrapper) {
          drawWrapper.dispose();
        }
        this._mergeDrawWrapper = [];
        this._objectRenderer.dispose();
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
        this.onBeforeRenderLayerObservable.clear();
        this.onBeforeComposeObservable.clear();
        this.onBeforeRenderMeshToEffect.clear();
        this.onAfterRenderMeshToEffect.clear();
        this.onAfterComposeObservable.clear();
      }
    };
    ThinEffectLayer.ForceGLSL = false;
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinBlurPostProcess.js
var ThinBlurPostProcess;
var init_thinBlurPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinBlurPostProcess.js"() {
    init_effectRenderer();
    init_engine();
    ThinBlurPostProcess = class _ThinBlurPostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(Promise.all([import("./kernelBlur.fragment-W5KTMEXB.js"), import("./kernelBlur.vertex-6CWOOWFJ.js")]));
        } else {
          list.push(Promise.all([import("./kernelBlur.fragment-OEXD7P6U.js"), import("./kernelBlur.vertex-VJGSC64A.js")]));
        }
      }
      /**
       * Constructs a new blur post process
       * @param name Name of the effect
       * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
       * @param direction Direction in which to apply the blur
       * @param kernel Kernel size of the blur
       * @param options Options to configure the effect
       */
      constructor(name13, engine = null, direction, kernel, options) {
        const blockCompilationFinal = !!options?.blockCompilation;
        super({
          ...options,
          name: name13,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinBlurPostProcess.FragmentUrl,
          uniforms: _ThinBlurPostProcess.Uniforms,
          samplers: _ThinBlurPostProcess.Samplers,
          vertexUrl: _ThinBlurPostProcess.VertexUrl,
          blockCompilation: true
        });
        this._packedFloat = false;
        this._staticDefines = "";
        this.textureWidth = 0;
        this.textureHeight = 0;
        this._staticDefines = options ? Array.isArray(options.defines) ? options.defines.join("\n") : options.defines || "" : "";
        this.options.blockCompilation = blockCompilationFinal;
        if (direction !== void 0) {
          this.direction = direction;
        }
        if (kernel !== void 0) {
          this.kernel = kernel;
        }
      }
      /**
       * Sets the length in pixels of the blur sample region
       */
      set kernel(v) {
        if (this._idealKernel === v) {
          return;
        }
        v = Math.max(v, 1);
        this._idealKernel = v;
        this._kernel = this._nearestBestKernel(v);
        if (!this.options.blockCompilation) {
          this._updateParameters();
        }
      }
      /**
       * Gets the length in pixels of the blur sample region
       */
      get kernel() {
        return this._idealKernel;
      }
      /**
       * Sets whether or not the blur needs to unpack/repack floats
       */
      set packedFloat(v) {
        if (this._packedFloat === v) {
          return;
        }
        this._packedFloat = v;
        if (!this.options.blockCompilation) {
          this._updateParameters();
        }
      }
      /**
       * Gets whether or not the blur is unpacking/repacking floats
       */
      get packedFloat() {
        return this._packedFloat;
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        this._drawWrapper.effect.setFloat2("delta", 1 / this.textureWidth * this.direction.x, 1 / this.textureHeight * this.direction.y);
      }
      /** @internal */
      _updateParameters(onCompiled, onError) {
        const n = this._kernel;
        const centerIndex = (n - 1) / 2;
        let offsets = [];
        let weights = [];
        let totalWeight = 0;
        for (let i = 0; i < n; i++) {
          const u = i / (n - 1);
          const w = this._gaussianWeight(u * 2 - 1);
          offsets[i] = i - centerIndex;
          weights[i] = w;
          totalWeight += w;
        }
        for (let i = 0; i < weights.length; i++) {
          weights[i] /= totalWeight;
        }
        const linearSamplingWeights = [];
        const linearSamplingOffsets = [];
        const linearSamplingMap = [];
        for (let i = 0; i <= centerIndex; i += 2) {
          const j = Math.min(i + 1, Math.floor(centerIndex));
          const singleCenterSample = i === j;
          if (singleCenterSample) {
            linearSamplingMap.push({ o: offsets[i], w: weights[i] });
          } else {
            const sharedCell = j === centerIndex;
            const weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);
            const offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);
            if (offsetLinear === 0) {
              linearSamplingMap.push({ o: offsets[i], w: weights[i] });
              linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });
            } else {
              linearSamplingMap.push({ o: offsetLinear, w: weightLinear });
              linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });
            }
          }
        }
        for (let i = 0; i < linearSamplingMap.length; i++) {
          linearSamplingOffsets[i] = linearSamplingMap[i].o;
          linearSamplingWeights[i] = linearSamplingMap[i].w;
        }
        offsets = linearSamplingOffsets;
        weights = linearSamplingWeights;
        const maxVaryingRows = this.options.engine.getCaps().maxVaryingVectors - (this.options.shaderLanguage === 1 ? 1 : 0);
        const freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1;
        let varyingCount = Math.min(offsets.length, freeVaryingVec2);
        let defines = "";
        defines += this._staticDefines;
        if (this._staticDefines.indexOf("DOF") != -1) {
          defines += `#define CENTER_WEIGHT ${this._glslFloat(weights[varyingCount - 1])}
`;
          varyingCount--;
        }
        for (let i = 0; i < varyingCount; i++) {
          defines += `#define KERNEL_OFFSET${i} ${this._glslFloat(offsets[i])}
`;
          defines += `#define KERNEL_WEIGHT${i} ${this._glslFloat(weights[i])}
`;
        }
        let depCount = 0;
        for (let i = freeVaryingVec2; i < offsets.length; i++) {
          defines += `#define KERNEL_DEP_OFFSET${depCount} ${this._glslFloat(offsets[i])}
`;
          defines += `#define KERNEL_DEP_WEIGHT${depCount} ${this._glslFloat(weights[i])}
`;
          depCount++;
        }
        if (this.packedFloat) {
          defines += `#define PACKEDFLOAT 1`;
        }
        this.options.blockCompilation = false;
        this.updateEffect(defines, null, null, {
          varyingCount,
          depCount
        }, onCompiled, onError);
      }
      /**
       * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.
       * Other odd kernels optimize correctly but require proportionally more samples, even kernels are
       * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we
       * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.
       * The gaps between physical kernels are compensated for in the weighting of the samples
       * @param idealKernel Ideal blur kernel.
       * @returns Nearest best kernel.
       */
      _nearestBestKernel(idealKernel) {
        const v = Math.round(idealKernel);
        for (const k of [v, v - 1, v + 1, v - 2, v + 2]) {
          if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {
            return Math.max(k, 3);
          }
        }
        return Math.max(v, 3);
      }
      /**
       * Calculates the value of a Gaussian distribution with sigma 3 at a given point.
       * @param x The point on the Gaussian distribution to sample.
       * @returns the value of the Gaussian function at x.
       */
      _gaussianWeight(x) {
        const sigma = 1 / 3;
        const denominator = Math.sqrt(2 * Math.PI) * sigma;
        const exponent = -(x * x / (2 * sigma * sigma));
        const weight = 1 / denominator * Math.exp(exponent);
        return weight;
      }
      /**
       * Generates a string that can be used as a floating point number in GLSL.
       * @param x Value to print.
       * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).
       * @returns GLSL float string.
       */
      _glslFloat(x, decimalFigures = 8) {
        return x.toFixed(decimalFigures).replace(/0+$/, "");
      }
    };
    ThinBlurPostProcess.VertexUrl = "kernelBlur";
    ThinBlurPostProcess.FragmentUrl = "kernelBlur";
    ThinBlurPostProcess.Uniforms = ["delta", "direction"];
    ThinBlurPostProcess.Samplers = ["circleOfConfusionSampler"];
  }
});

// node_modules/@babylonjs/core/Layers/thinGlowLayer.js
var ThinGlowLayer;
var init_thinGlowLayer = __esm({
  "node_modules/@babylonjs/core/Layers/thinGlowLayer.js"() {
    init_math_vector();
    init_buffer();
    init_material();
    init_thinEffectLayer();
    init_math_color();
    init_thinBlurPostProcess();
    ThinGlowLayer = class _ThinGlowLayer extends ThinEffectLayer {
      /**
       * Gets the ldrMerge option.
       */
      get ldrMerge() {
        return this._options.ldrMerge;
      }
      /**
       * Sets the kernel size of the blur.
       */
      set blurKernelSize(value) {
        if (value === this._options.blurKernelSize) {
          return;
        }
        this._options.blurKernelSize = value;
        const effectiveKernel = this._getEffectiveBlurKernelSize();
        this._horizontalBlurPostprocess1.kernel = effectiveKernel;
        this._verticalBlurPostprocess1.kernel = effectiveKernel;
        this._horizontalBlurPostprocess2.kernel = effectiveKernel;
        this._verticalBlurPostprocess2.kernel = effectiveKernel;
      }
      /**
       * Gets the kernel size of the blur.
       */
      get blurKernelSize() {
        return this._options.blurKernelSize;
      }
      /**
       * Sets the glow intensity.
       */
      set intensity(value) {
        this._intensity = value;
      }
      /**
       * Gets the glow intensity.
       */
      get intensity() {
        return this._intensity;
      }
      /**
       * Instantiates a new glow Layer and references it to the scene.
       * @param name The name of the layer
       * @param scene The scene to use the layer in
       * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)
       * @param dontCheckIfReady Specifies if the layer should disable checking whether all the post processes are ready (default: false). To save performance, this should be set to true and you should call `isReady` manually before rendering to the layer.
       */
      constructor(name13, scene, options, dontCheckIfReady = false) {
        super(name13, scene, false, dontCheckIfReady);
        this._intensity = 1;
        this._includedOnlyMeshes = [];
        this._excludedMeshes = [];
        this._meshesUsingTheirOwnMaterials = [];
        this._renderPassId = 0;
        this.neutralColor = new Color4(0, 0, 0, 1);
        this._options = {
          mainTextureRatio: 0.5,
          mainTextureFixedSize: 0,
          mainTextureType: 0,
          blurKernelSize: 32,
          camera: null,
          renderingGroupId: -1,
          ldrMerge: false,
          alphaBlendingMode: 1,
          excludeByDefault: false,
          ...options
        };
        this._init(this._options);
        if (dontCheckIfReady) {
          this._createTextureAndPostProcesses();
        }
      }
      /**
       * Gets the class name of the thin glow layer
       * @returns the string with the class name of the glow layer
       */
      getClassName() {
        return "GlowLayer";
      }
      async _importShadersAsync() {
        if (this._shaderLanguage === 1) {
          await Promise.all([
            import("./glowMapMerge.fragment-6V3D62ER.js"),
            import("./glowMapMerge.vertex-NXELN2WO.js"),
            import("./glowBlurPostProcess.fragment-5X3IMKZX.js")
          ]);
        } else {
          await Promise.all([import("./glowMapMerge.fragment-X3AVFWEG.js"), import("./glowMapMerge.vertex-BF5P5I4Y.js"), import("./glowBlurPostProcess.fragment-C5WIMY7G.js")]);
        }
        await super._importShadersAsync();
      }
      getEffectName() {
        return _ThinGlowLayer.EffectName;
      }
      /** @internal */
      _internalShouldRender() {
        if (this._options.excludeByDefault && !this._includedOnlyMeshes.length) {
          return false;
        }
        return super._internalShouldRender();
      }
      _createMergeEffect() {
        let defines = "#define EMISSIVE \n";
        if (this._options.ldrMerge) {
          defines += "#define LDR \n";
        }
        return this._engine.createEffect("glowMapMerge", [VertexBuffer.PositionKind], ["offset"], ["textureSampler", "textureSampler2"], defines, void 0, void 0, void 0, void 0, this.shaderLanguage, this._shadersLoaded ? void 0 : async () => {
          await this._importShadersAsync();
          this._shadersLoaded = true;
        });
      }
      _createTextureAndPostProcesses() {
        const effectiveKernel = this._getEffectiveBlurKernelSize();
        this._horizontalBlurPostprocess1 = new ThinBlurPostProcess("GlowLayerHBP1", this._scene.getEngine(), new Vector2(1, 0), effectiveKernel);
        this._verticalBlurPostprocess1 = new ThinBlurPostProcess("GlowLayerVBP1", this._scene.getEngine(), new Vector2(0, 1), effectiveKernel);
        this._horizontalBlurPostprocess2 = new ThinBlurPostProcess("GlowLayerHBP2", this._scene.getEngine(), new Vector2(1, 0), effectiveKernel);
        this._verticalBlurPostprocess2 = new ThinBlurPostProcess("GlowLayerVBP2", this._scene.getEngine(), new Vector2(0, 1), effectiveKernel);
        this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];
      }
      _getEffectiveBlurKernelSize() {
        return this._options.blurKernelSize / 2;
      }
      isReady(subMesh, useInstances) {
        const material = subMesh.getMaterial();
        const mesh = subMesh.getRenderingMesh();
        if (!material || !mesh) {
          return false;
        }
        const emissiveTexture = material.emissiveTexture;
        return super._isSubMeshReady(subMesh, useInstances, emissiveTexture);
      }
      _canRenderMesh(_mesh, _material) {
        return true;
      }
      _internalCompose(effect) {
        this.bindTexturesForCompose(effect);
        effect.setFloat("offset", this._intensity);
        const engine = this._engine;
        const previousStencilBuffer = engine.getStencilBuffer();
        engine.setStencilBuffer(false);
        engine.drawElementsType(Material.TriangleFillMode, 0, 6);
        engine.setStencilBuffer(previousStencilBuffer);
      }
      _setEmissiveTextureAndColor(mesh, subMesh, material) {
        let textureLevel = 1;
        if (this.customEmissiveTextureSelector) {
          this._emissiveTextureAndColor.texture = this.customEmissiveTextureSelector(mesh, subMesh, material);
        } else {
          if (material) {
            this._emissiveTextureAndColor.texture = material.emissiveTexture;
            if (this._emissiveTextureAndColor.texture) {
              textureLevel = this._emissiveTextureAndColor.texture.level;
            }
          } else {
            this._emissiveTextureAndColor.texture = null;
          }
        }
        if (this.customEmissiveColorSelector) {
          this.customEmissiveColorSelector(mesh, subMesh, material, this._emissiveTextureAndColor.color);
        } else {
          if (material.emissiveColor) {
            const emissiveIntensity = material.emissiveIntensity ?? 1;
            textureLevel *= emissiveIntensity;
            this._emissiveTextureAndColor.color.set(material.emissiveColor.r * textureLevel, material.emissiveColor.g * textureLevel, material.emissiveColor.b * textureLevel, material.alpha);
          } else {
            this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);
          }
        }
      }
      _shouldRenderMesh(mesh) {
        return this.hasMesh(mesh);
      }
      _addCustomEffectDefines(defines) {
        defines.push("#define GLOW");
      }
      /**
       * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.
       * This will not have an effect if meshes are excluded by default (see setExcludedByDefault).
       * @param mesh The mesh to exclude from the glow layer
       */
      addExcludedMesh(mesh) {
        if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {
          this._excludedMeshes.push(mesh.uniqueId);
        }
      }
      /**
       * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.
       * This will not have an effect if meshes are excluded by default (see setExcludedByDefault).
       * @param mesh The mesh to remove
       */
      removeExcludedMesh(mesh) {
        const index = this._excludedMeshes.indexOf(mesh.uniqueId);
        if (index !== -1) {
          this._excludedMeshes.splice(index, 1);
        }
      }
      /**
       * Add a mesh in the inclusion list to impact or being impacted by the glow layer.
       * @param mesh The mesh to include in the glow layer
       */
      addIncludedOnlyMesh(mesh) {
        if (this._includedOnlyMeshes.indexOf(mesh.uniqueId) === -1) {
          this._includedOnlyMeshes.push(mesh.uniqueId);
        }
      }
      /**
       * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.
       * @param mesh The mesh to remove
       */
      removeIncludedOnlyMesh(mesh) {
        const index = this._includedOnlyMeshes.indexOf(mesh.uniqueId);
        if (index !== -1) {
          this._includedOnlyMeshes.splice(index, 1);
        }
      }
      /**
       * Set the excluded by default option.
       * If true, all meshes will be excluded by default unless they are added to the inclusion list.
       * @param value The boolean value to set the excluded by default option to
       */
      setExcludedByDefault(value) {
        this._options.excludeByDefault = value;
      }
      hasMesh(mesh) {
        if (!super.hasMesh(mesh)) {
          return false;
        }
        if (this._includedOnlyMeshes.length) {
          return this._includedOnlyMeshes.indexOf(mesh.uniqueId) !== -1;
        }
        if (this._excludedMeshes.length) {
          return this._excludedMeshes.indexOf(mesh.uniqueId) === -1;
        }
        return true;
      }
      _useMeshMaterial(mesh) {
        if (mesh.material?._supportGlowLayer) {
          return true;
        }
        if (this._meshesUsingTheirOwnMaterials.length == 0) {
          return false;
        }
        return this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId) > -1;
      }
      /**
       * Add a mesh to be rendered through its own material and not with emissive only.
       * @param mesh The mesh for which we need to use its material
       */
      referenceMeshToUseItsOwnMaterial(mesh) {
        mesh.resetDrawCache(this._renderPassId);
        this._meshesUsingTheirOwnMaterials.push(mesh.uniqueId);
        mesh.onDisposeObservable.add(() => {
          this._disposeMesh(mesh);
        });
      }
      /**
       * Remove a mesh from being rendered through its own material and not with emissive only.
       * @param mesh The mesh for which we need to not use its material
       * @param renderPassId The render pass id used when rendering the mesh
       */
      unReferenceMeshFromUsingItsOwnMaterial(mesh, renderPassId) {
        let index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);
        while (index >= 0) {
          this._meshesUsingTheirOwnMaterials.splice(index, 1);
          index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);
        }
        mesh.resetDrawCache(renderPassId);
      }
      /** @internal */
      _disposeMesh(mesh) {
        this.removeIncludedOnlyMesh(mesh);
        this.removeExcludedMesh(mesh);
      }
    };
    ThinGlowLayer.EffectName = "GlowLayer";
    ThinGlowLayer.DefaultBlurKernelSize = 32;
  }
});

// node_modules/@babylonjs/core/FrameGraph/Tasks/PostProcesses/postProcessTask.js
var FrameGraphPostProcessTask;
var init_postProcessTask = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Tasks/PostProcesses/postProcessTask.js"() {
    init_frameGraphTask();
    FrameGraphPostProcessTask = class extends FrameGraphTask {
      /**
       * The draw wrapper used by the post process
       */
      get drawWrapper() {
        return this._postProcessDrawWrapper;
      }
      /**
       * Constructs a new post process task.
       * @param name Name of the task.
       * @param frameGraph The frame graph this task is associated with.
       * @param postProcess The post process to apply.
       */
      constructor(name13, frameGraph, postProcess) {
        super(name13, frameGraph);
        this.sourceSamplingMode = 2;
        this.depthReadOnly = false;
        this.stencilReadOnly = false;
        this.disableColorWrite = false;
        this.drawBackFace = false;
        this.depthTest = true;
        this.postProcess = postProcess;
        this._postProcessDrawWrapper = this.postProcess.drawWrapper;
        this.outputTexture = this._frameGraph.textureManager.createDanglingHandle();
        this.outputDepthAttachmentTexture = this._frameGraph.textureManager.createDanglingHandle();
      }
      isReady() {
        return this.postProcess.isReady();
      }
      getClassName() {
        return "FrameGraphPostProcessTask";
      }
      record(skipCreationOfDisabledPasses = false, additionalExecute, additionalBindings) {
        if (this.sourceTexture === void 0 && this.targetTexture === void 0) {
          throw new Error(`FrameGraphPostProcessTask "${this.name}": sourceTexture or targetTexture is required`);
        }
        const sourceTextureCreationOptions = this.sourceTexture !== void 0 ? this._frameGraph.textureManager.getTextureCreationOptions(this.sourceTexture) : void 0;
        if (sourceTextureCreationOptions) {
          sourceTextureCreationOptions.options.samples = 1;
        }
        this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture, this.targetTexture, this.name, sourceTextureCreationOptions);
        if (this.depthAttachmentTexture !== void 0) {
          this._frameGraph.textureManager.resolveDanglingHandle(this.outputDepthAttachmentTexture, this.depthAttachmentTexture);
        }
        if (sourceTextureCreationOptions) {
          const sourceSize = this._frameGraph.textureManager.getTextureAbsoluteDimensions(sourceTextureCreationOptions);
          this._sourceWidth = sourceSize.width;
          this._sourceHeight = sourceSize.height;
        }
        const outputTextureDescription = this._frameGraph.textureManager.getTextureDescription(this.outputTexture);
        this._outputWidth = outputTextureDescription.size.width;
        this._outputHeight = outputTextureDescription.size.height;
        const pass = this._frameGraph.addRenderPass(this.name);
        pass.depthReadOnly = this.depthReadOnly;
        pass.stencilReadOnly = this.stencilReadOnly;
        pass.addDependencies(this.sourceTexture);
        pass.setRenderTarget(this.outputTexture);
        pass.setRenderTargetDepth(this.depthAttachmentTexture);
        pass.setExecuteFunc((context) => {
          context.pushDebugGroup(`Apply post-process (${this.name})`);
          if (this.sourceTexture !== void 0) {
            context.setTextureSamplingMode(this.sourceTexture, this.sourceSamplingMode);
          }
          additionalExecute?.(context);
          if (this.viewport) {
            context.setViewport(this.viewport);
          }
          context.applyFullScreenEffect(this._postProcessDrawWrapper, () => {
            if (this.sourceTexture !== void 0) {
              context.bindTextureHandle(this._postProcessDrawWrapper.effect, "textureSampler", this.sourceTexture);
            }
            additionalBindings?.(context);
            this.postProcess.bind();
          }, this.stencilState, this.disableColorWrite, this.drawBackFace, this.depthTest, this.viewport !== void 0);
          context.restoreDefaultFramebuffer();
          context.popDebugGroup();
        });
        if (!skipCreationOfDisabledPasses) {
          const passDisabled = this._frameGraph.addRenderPass(this.name + "_disabled", true);
          passDisabled.depthReadOnly = this.depthReadOnly;
          passDisabled.stencilReadOnly = this.stencilReadOnly;
          passDisabled.addDependencies(this.sourceTexture);
          passDisabled.setRenderTarget(this.outputTexture);
          passDisabled.setRenderTargetDepth(this.depthAttachmentTexture);
          passDisabled.setExecuteFunc((context) => {
            if (this.sourceTexture !== void 0) {
              if (this.viewport) {
                context.setViewport(this.viewport);
              }
              context.copyTexture(this.sourceTexture, void 0, this.viewport !== void 0);
            }
          });
        }
        return pass;
      }
      dispose() {
        this.postProcess.dispose();
        super.dispose();
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinExtractHighlightsPostProcess.js
var ThinExtractHighlightsPostProcess;
var init_thinExtractHighlightsPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinExtractHighlightsPostProcess.js"() {
    init_effectRenderer();
    init_math_constants();
    init_engine();
    ThinExtractHighlightsPostProcess = class _ThinExtractHighlightsPostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(import("./extractHighlights.fragment-ZJ3JNJ45.js"));
        } else {
          list.push(import("./extractHighlights.fragment-PGY4CUFX.js"));
        }
      }
      /**
       * Constructs a new extract highlights post process
       * @param name Name of the effect
       * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
       * @param options Options to configure the effect
       */
      constructor(name13, engine = null, options) {
        super({
          ...options,
          name: name13,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinExtractHighlightsPostProcess.FragmentUrl,
          uniforms: _ThinExtractHighlightsPostProcess.Uniforms
        });
        this.threshold = 0.9;
        this._exposure = 1;
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        const effect = this._drawWrapper.effect;
        effect.setFloat("threshold", Math.pow(this.threshold, ToGammaSpace));
        effect.setFloat("exposure", this._exposure);
      }
    };
    ThinExtractHighlightsPostProcess.FragmentUrl = "extractHighlights";
    ThinExtractHighlightsPostProcess.Uniforms = ["threshold", "exposure"];
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinBloomMergePostProcess.js
var ThinBloomMergePostProcess;
var init_thinBloomMergePostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinBloomMergePostProcess.js"() {
    init_effectRenderer();
    init_engine();
    ThinBloomMergePostProcess = class _ThinBloomMergePostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(import("./bloomMerge.fragment-TQIELORT.js"));
        } else {
          list.push(import("./bloomMerge.fragment-VOWSWIVA.js"));
        }
      }
      constructor(name13, engine = null, options) {
        super({
          ...options,
          name: name13,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinBloomMergePostProcess.FragmentUrl,
          uniforms: _ThinBloomMergePostProcess.Uniforms,
          samplers: _ThinBloomMergePostProcess.Samplers
        });
        this.weight = 1;
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        this._drawWrapper.effect.setFloat("bloomWeight", this.weight);
      }
    };
    ThinBloomMergePostProcess.FragmentUrl = "bloomMerge";
    ThinBloomMergePostProcess.Uniforms = ["bloomWeight"];
    ThinBloomMergePostProcess.Samplers = ["bloomBlur"];
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinBloomEffect.js
var ThinBloomEffect;
var init_thinBloomEffect = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinBloomEffect.js"() {
    init_thinBloomMergePostProcess();
    init_math_vector();
    init_thinBlurPostProcess();
    init_thinExtractHighlightsPostProcess();
    ThinBloomEffect = class {
      /**
       * The luminance threshold to find bright areas of the image to bloom.
       */
      get threshold() {
        return this._downscale.threshold;
      }
      set threshold(value) {
        this._downscale.threshold = value;
      }
      /**
       * The strength of the bloom.
       */
      get weight() {
        return this._merge.weight;
      }
      set weight(value) {
        this._merge.weight = value;
      }
      /**
       * Specifies the size of the bloom blur kernel, relative to the final output size
       */
      get kernel() {
        return this._blurX.kernel / this.scale;
      }
      set kernel(value) {
        this._blurX.kernel = value * this.scale;
        this._blurY.kernel = value * this.scale;
      }
      /**
       * Creates a new instance of @see ThinBloomEffect
       * @param name The name of the bloom render effect
       * @param engine The engine which the render effect will be applied. (default: current engine)
       * @param scale The ratio of the blur texture to the input texture that should be used to compute the bloom.
       * @param blockCompilation If shaders should not be compiled when the effect is created (default: false)
       */
      constructor(name13, engine, scale, blockCompilation = false) {
        this.scale = scale;
        this._downscale = new ThinExtractHighlightsPostProcess(name13 + "_downscale", engine, { blockCompilation });
        this._blurX = new ThinBlurPostProcess(name13 + "_blurX", engine, new Vector2(1, 0), 10, { blockCompilation });
        this._blurY = new ThinBlurPostProcess(name13 + "_blurY", engine, new Vector2(0, 1), 10, { blockCompilation });
        this._merge = new ThinBloomMergePostProcess(name13 + "_merge", engine, { blockCompilation });
      }
      /**
       * Checks if the effect is ready to be used
       * @returns if the effect is ready
       */
      isReady() {
        return this._downscale.isReady() && this._blurX.isReady() && this._blurY.isReady() && this._merge.isReady();
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinChromaticAberrationPostProcess.js
var ThinChromaticAberrationPostProcess;
var init_thinChromaticAberrationPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinChromaticAberrationPostProcess.js"() {
    init_effectRenderer();
    init_engine();
    init_math_vector();
    ThinChromaticAberrationPostProcess = class _ThinChromaticAberrationPostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(import("./chromaticAberration.fragment-OOMWR4WD.js"));
        } else {
          list.push(import("./chromaticAberration.fragment-J2CV5K6B.js"));
        }
      }
      /**
       * Constructs a new chromatic aberration post process
       * @param name Name of the effect
       * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
       * @param options Options to configure the effect
       */
      constructor(name13, engine = null, options) {
        super({
          ...options,
          name: name13,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinChromaticAberrationPostProcess.FragmentUrl,
          uniforms: _ThinChromaticAberrationPostProcess.Uniforms
        });
        this.aberrationAmount = 30;
        this.radialIntensity = 0;
        this.direction = new Vector2(0.707, 0.707);
        this.centerPosition = new Vector2(0.5, 0.5);
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        const effect = this._drawWrapper.effect;
        effect.setFloat("chromatic_aberration", this.aberrationAmount);
        effect.setFloat("screen_width", this.screenWidth);
        effect.setFloat("screen_height", this.screenHeight);
        effect.setFloat("radialIntensity", this.radialIntensity);
        effect.setFloat2("direction", this.direction.x, this.direction.y);
        effect.setFloat2("centerPosition", this.centerPosition.x, this.centerPosition.y);
      }
    };
    ThinChromaticAberrationPostProcess.FragmentUrl = "chromaticAberration";
    ThinChromaticAberrationPostProcess.Uniforms = ["chromatic_aberration", "screen_width", "screen_height", "direction", "radialIntensity", "centerPosition"];
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinCircleOfConfusionPostProcess.js
var ThinCircleOfConfusionPostProcess;
var init_thinCircleOfConfusionPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinCircleOfConfusionPostProcess.js"() {
    init_effectRenderer();
    init_engine();
    ThinCircleOfConfusionPostProcess = class _ThinCircleOfConfusionPostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(import("./circleOfConfusion.fragment-VJA6OOLN.js"));
        } else {
          list.push(import("./circleOfConfusion.fragment-5ZBORZTM.js"));
        }
      }
      /**
       * Constructs a new circle of confusion post process
       * @param name Name of the effect
       * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
       * @param options Options to configure the effect
       */
      constructor(name13, engine = null, options) {
        super({
          ...options,
          name: name13,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinCircleOfConfusionPostProcess.FragmentUrl,
          uniforms: _ThinCircleOfConfusionPostProcess.Uniforms,
          samplers: _ThinCircleOfConfusionPostProcess.Samplers,
          defines: options?.depthNotNormalized ? _ThinCircleOfConfusionPostProcess.DefinesDepthNotNormalized : void 0
        });
        this.lensSize = 50;
        this.fStop = 1.4;
        this.focusDistance = 2e3;
        this.focalLength = 50;
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        const options = this.options;
        const effect = this._drawWrapper.effect;
        if (!options.depthNotNormalized) {
          effect.setFloat2("cameraMinMaxZ", this.camera.minZ, this.camera.maxZ - this.camera.minZ);
        }
        const aperture = this.lensSize / this.fStop;
        const cocPrecalculation = aperture * this.focalLength / (this.focusDistance - this.focalLength);
        effect.setFloat("focusDistance", this.focusDistance);
        effect.setFloat("cocPrecalculation", cocPrecalculation);
      }
    };
    ThinCircleOfConfusionPostProcess.FragmentUrl = "circleOfConfusion";
    ThinCircleOfConfusionPostProcess.Uniforms = ["cameraMinMaxZ", "focusDistance", "cocPrecalculation"];
    ThinCircleOfConfusionPostProcess.Samplers = ["depthSampler"];
    ThinCircleOfConfusionPostProcess.DefinesDepthNotNormalized = "#define COC_DEPTH_NOT_NORMALIZED";
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinDepthOfFieldBlurPostProcess.js
var ThinDepthOfFieldBlurPostProcess;
var init_thinDepthOfFieldBlurPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinDepthOfFieldBlurPostProcess.js"() {
    init_thinBlurPostProcess();
    ThinDepthOfFieldBlurPostProcess = class extends ThinBlurPostProcess {
      constructor(name13, engine = null, direction, kernel, options) {
        super(name13, engine, direction, kernel, {
          ...options,
          defines: `#define DOF 1
`
        });
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinDepthOfFieldMergePostProcess.js
var ThinDepthOfFieldMergePostProcess;
var init_thinDepthOfFieldMergePostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinDepthOfFieldMergePostProcess.js"() {
    init_effectRenderer();
    init_engine();
    ThinDepthOfFieldMergePostProcess = class _ThinDepthOfFieldMergePostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(import("./depthOfFieldMerge.fragment-W7F33SF4.js"));
        } else {
          list.push(import("./depthOfFieldMerge.fragment-QOZSSY4R.js"));
        }
      }
      constructor(name13, engine = null, options) {
        super({
          ...options,
          name: name13,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinDepthOfFieldMergePostProcess.FragmentUrl,
          samplers: _ThinDepthOfFieldMergePostProcess.Samplers
        });
      }
    };
    ThinDepthOfFieldMergePostProcess.FragmentUrl = "depthOfFieldMerge";
    ThinDepthOfFieldMergePostProcess.Samplers = ["circleOfConfusionSampler", "blurStep0", "blurStep1", "blurStep2"];
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinDepthOfFieldEffect.js
var ThinDepthOfFieldEffectBlurLevel, ThinDepthOfFieldEffect;
var init_thinDepthOfFieldEffect = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinDepthOfFieldEffect.js"() {
    init_thinDepthOfFieldBlurPostProcess();
    init_thinCircleOfConfusionPostProcess();
    init_thinDepthOfFieldMergePostProcess();
    init_math_vector();
    (function(ThinDepthOfFieldEffectBlurLevel2) {
      ThinDepthOfFieldEffectBlurLevel2[ThinDepthOfFieldEffectBlurLevel2["Low"] = 0] = "Low";
      ThinDepthOfFieldEffectBlurLevel2[ThinDepthOfFieldEffectBlurLevel2["Medium"] = 1] = "Medium";
      ThinDepthOfFieldEffectBlurLevel2[ThinDepthOfFieldEffectBlurLevel2["High"] = 2] = "High";
    })(ThinDepthOfFieldEffectBlurLevel || (ThinDepthOfFieldEffectBlurLevel = {}));
    ThinDepthOfFieldEffect = class {
      /**
       * The focal the length of the camera used in the effect in scene units/1000 (eg. millimeter)
       */
      set focalLength(value) {
        this._circleOfConfusion.focalLength = value;
      }
      get focalLength() {
        return this._circleOfConfusion.focalLength;
      }
      /**
       * F-Stop of the effect's camera. The diameter of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
       */
      set fStop(value) {
        this._circleOfConfusion.fStop = value;
      }
      get fStop() {
        return this._circleOfConfusion.fStop;
      }
      /**
       * Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
       */
      set focusDistance(value) {
        this._circleOfConfusion.focusDistance = value;
      }
      get focusDistance() {
        return this._circleOfConfusion.focusDistance;
      }
      /**
       * Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diameter of the resulting aperture can be computed by lensSize/fStop.
       */
      set lensSize(value) {
        this._circleOfConfusion.lensSize = value;
      }
      get lensSize() {
        return this._circleOfConfusion.lensSize;
      }
      /**
       * Creates a new instance of @see ThinDepthOfFieldEffect
       * @param name The name of the depth of field render effect
       * @param engine The engine which the render effect will be applied. (default: current engine)
       * @param blurLevel The quality of the effect. (default: DepthOfFieldEffectBlurLevel.Low)
       * @param depthNotNormalized If the (view) depth used in circle of confusion post-process is normalized (0.0 to 1.0 from near to far) or not (0 to camera max distance) (default: false)
       * @param blockCompilation If shaders should not be compiled when the effect is created (default: false)
       */
      constructor(name13, engine, blurLevel = 0, depthNotNormalized = false, blockCompilation = false) {
        this._depthOfFieldBlurX = [];
        this._depthOfFieldBlurY = [];
        this._circleOfConfusion = new ThinCircleOfConfusionPostProcess(name13, engine, { depthNotNormalized, blockCompilation });
        this.blurLevel = blurLevel;
        let blurCount = 1;
        let kernelSize = 15;
        switch (blurLevel) {
          case 2: {
            blurCount = 3;
            kernelSize = 51;
            break;
          }
          case 1: {
            blurCount = 2;
            kernelSize = 31;
            break;
          }
          default: {
            kernelSize = 15;
            blurCount = 1;
            break;
          }
        }
        const adjustedKernelSize = kernelSize / Math.pow(2, blurCount - 1);
        let ratio = 1;
        for (let i = 0; i < blurCount; i++) {
          this._depthOfFieldBlurY.push([new ThinDepthOfFieldBlurPostProcess(name13, engine, new Vector2(0, 1), adjustedKernelSize, { blockCompilation }), ratio]);
          ratio = 0.75 / Math.pow(2, i);
          this._depthOfFieldBlurX.push([new ThinDepthOfFieldBlurPostProcess(name13, engine, new Vector2(1, 0), adjustedKernelSize, { blockCompilation }), ratio]);
        }
        this._dofMerge = new ThinDepthOfFieldMergePostProcess(name13, engine, { blockCompilation });
      }
      /**
       * Checks if the effect is ready to be used
       * @returns if the effect is ready
       */
      isReady() {
        let isReady = this._circleOfConfusion.isReady() && this._dofMerge.isReady();
        for (let i = 0; i < this._depthOfFieldBlurX.length; i++) {
          isReady = isReady && this._depthOfFieldBlurX[i][0].isReady() && this._depthOfFieldBlurY[i][0].isReady();
        }
        return isReady;
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinFXAAPostProcess.js
var ThinFXAAPostProcess;
var init_thinFXAAPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinFXAAPostProcess.js"() {
    init_effectRenderer();
    init_engine();
    init_math_vector();
    ThinFXAAPostProcess = class _ThinFXAAPostProcess extends EffectWrapper {
      static _GetDefines(engine) {
        if (!engine) {
          return null;
        }
        const driverInfo = engine.extractDriverInfo();
        if (driverInfo.toLowerCase().indexOf("mali") > -1) {
          return "#define MALI 1\n";
        }
        return null;
      }
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(Promise.all([import("./fxaa.fragment-X5GVPEKZ.js"), import("./fxaa.vertex-PYPE4UIT.js")]));
        } else {
          list.push(Promise.all([import("./fxaa.fragment-QDDXYWFN.js"), import("./fxaa.vertex-CCRXC74Q.js")]));
        }
      }
      /**
       * Constructs a new FXAA post process
       * @param name Name of the effect
       * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
       * @param options Options to configure the effect
       */
      constructor(name13, engine = null, options) {
        const localOptions = {
          ...options,
          name: name13,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          vertexShader: _ThinFXAAPostProcess.VertexUrl,
          fragmentShader: _ThinFXAAPostProcess.FragmentUrl,
          uniforms: _ThinFXAAPostProcess.Uniforms
        };
        super({
          ...localOptions,
          defines: _ThinFXAAPostProcess._GetDefines(localOptions.engine)
        });
        this.texelSize = new Vector2(0, 0);
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        this._drawWrapper.effect.setFloat2("texelSize", this.texelSize.x, this.texelSize.y);
      }
    };
    ThinFXAAPostProcess.VertexUrl = "fxaa";
    ThinFXAAPostProcess.FragmentUrl = "fxaa";
    ThinFXAAPostProcess.Uniforms = ["texelSize"];
  }
});

// node_modules/@babylonjs/core/FrameGraph/Tasks/PostProcesses/fxaaTask.js
var FrameGraphFXAATask;
var init_fxaaTask = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Tasks/PostProcesses/fxaaTask.js"() {
    init_thinFXAAPostProcess();
    init_postProcessTask();
    FrameGraphFXAATask = class extends FrameGraphPostProcessTask {
      /**
       * Constructs a new FXAA task.
       * @param name The name of the task.
       * @param frameGraph The frame graph this task is associated with.
       * @param thinPostProcess The thin post process to use for the FXAA effect. If not provided, a new one will be created.
       */
      constructor(name13, frameGraph, thinPostProcess) {
        super(name13, frameGraph, thinPostProcess || new ThinFXAAPostProcess(name13, frameGraph.engine));
      }
      getClassName() {
        return "FrameGraphFXAATask";
      }
      record(skipCreationOfDisabledPasses = false, additionalExecute, additionalBindings) {
        const pass = super.record(skipCreationOfDisabledPasses, additionalExecute, additionalBindings);
        this.postProcess.texelSize.x = 1 / this._sourceWidth;
        this.postProcess.texelSize.y = 1 / this._sourceHeight;
        return pass;
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinGrainPostProcess.js
var ThinGrainPostProcess;
var init_thinGrainPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinGrainPostProcess.js"() {
    init_effectRenderer();
    init_engine();
    ThinGrainPostProcess = class _ThinGrainPostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(import("./grain.fragment-5P65ZMZ6.js"));
        } else {
          list.push(import("./grain.fragment-2J4CACWU.js"));
        }
      }
      /**
       * Constructs a new grain post process
       * @param name Name of the effect
       * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
       * @param options Options to configure the effect
       */
      constructor(name13, engine = null, options) {
        super({
          ...options,
          name: name13,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinGrainPostProcess.FragmentUrl,
          uniforms: _ThinGrainPostProcess.Uniforms
        });
        this.intensity = 30;
        this.animated = false;
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        this._drawWrapper.effect.setFloat("intensity", this.intensity);
        this._drawWrapper.effect.setFloat("animatedSeed", this.animated ? Math.random() + 1 : 1);
      }
    };
    ThinGrainPostProcess.FragmentUrl = "grain";
    ThinGrainPostProcess.Uniforms = ["intensity", "animatedSeed"];
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinImageProcessingPostProcess.js
var ThinImageProcessingPostProcess;
var init_thinImageProcessingPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinImageProcessingPostProcess.js"() {
    init_effectRenderer();
    init_engine();
    init_engineStore();
    init_imageProcessingConfiguration();
    ThinImageProcessingPostProcess = class _ThinImageProcessingPostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(import("./imageProcessing.fragment-BQAQSEMR.js"));
        } else {
          list.push(import("./imageProcessing.fragment-RL7QL5XQ.js"));
        }
      }
      /**
       * Gets the image processing configuration used either in this material.
       */
      get imageProcessingConfiguration() {
        return this._imageProcessingConfiguration;
      }
      /**
       * Sets the Default image processing configuration used either in the this material.
       *
       * If sets to null, the scene one is in use.
       */
      set imageProcessingConfiguration(value) {
        value.applyByPostProcess = true;
        this._attachImageProcessingConfiguration(value);
      }
      /**
       * Attaches a new image processing configuration to the PBR Material.
       * @param configuration
       * @param doNotBuild
       */
      _attachImageProcessingConfiguration(configuration, doNotBuild = false) {
        if (configuration === this._imageProcessingConfiguration) {
          return;
        }
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        if (!configuration) {
          let scene = this.options.scene;
          if (!scene) {
            const engine = this.options.engine;
            if (engine && engine.scenes) {
              const scenes = engine.scenes;
              scene = scenes[scenes.length - 1];
            } else {
              scene = EngineStore.LastCreatedScene;
            }
          }
          if (scene) {
            this._imageProcessingConfiguration = scene.imageProcessingConfiguration;
          } else {
            this._imageProcessingConfiguration = new ImageProcessingConfiguration();
          }
        } else {
          this._imageProcessingConfiguration = configuration;
        }
        if (this._imageProcessingConfiguration) {
          this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
            this._updateParameters();
          });
        }
        if (!doNotBuild) {
          this._updateParameters();
        }
      }
      /**
       * Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .
       */
      get colorCurves() {
        return this.imageProcessingConfiguration.colorCurves;
      }
      /**
       * Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .
       */
      set colorCurves(value) {
        this.imageProcessingConfiguration.colorCurves = value;
      }
      /**
       * Gets whether the color curves effect is enabled.
       */
      get colorCurvesEnabled() {
        return this.imageProcessingConfiguration.colorCurvesEnabled;
      }
      /**
       * Sets whether the color curves effect is enabled.
       */
      set colorCurvesEnabled(value) {
        this.imageProcessingConfiguration.colorCurvesEnabled = value;
      }
      /**
       * Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
       */
      get colorGradingTexture() {
        return this.imageProcessingConfiguration.colorGradingTexture;
      }
      /**
       * Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
       */
      set colorGradingTexture(value) {
        this.imageProcessingConfiguration.colorGradingTexture = value;
      }
      /**
       * Gets whether the color grading effect is enabled.
       */
      get colorGradingEnabled() {
        return this.imageProcessingConfiguration.colorGradingEnabled;
      }
      /**
       * Gets whether the color grading effect is enabled.
       */
      set colorGradingEnabled(value) {
        this.imageProcessingConfiguration.colorGradingEnabled = value;
      }
      /**
       * Gets exposure used in the effect.
       */
      get exposure() {
        return this.imageProcessingConfiguration.exposure;
      }
      /**
       * Sets exposure used in the effect.
       */
      set exposure(value) {
        this.imageProcessingConfiguration.exposure = value;
      }
      /**
       * Gets whether tonemapping is enabled or not.
       */
      get toneMappingEnabled() {
        return this._imageProcessingConfiguration.toneMappingEnabled;
      }
      /**
       * Sets whether tonemapping is enabled or not
       */
      set toneMappingEnabled(value) {
        this._imageProcessingConfiguration.toneMappingEnabled = value;
      }
      /**
       * Gets the type of tone mapping effect.
       */
      get toneMappingType() {
        return this._imageProcessingConfiguration.toneMappingType;
      }
      /**
       * Sets the type of tone mapping effect.
       */
      set toneMappingType(value) {
        this._imageProcessingConfiguration.toneMappingType = value;
      }
      /**
       * Gets contrast used in the effect.
       */
      get contrast() {
        return this.imageProcessingConfiguration.contrast;
      }
      /**
       * Sets contrast used in the effect.
       */
      set contrast(value) {
        this.imageProcessingConfiguration.contrast = value;
      }
      /**
       * Gets Vignette stretch size.
       */
      get vignetteStretch() {
        return this.imageProcessingConfiguration.vignetteStretch;
      }
      /**
       * Sets Vignette stretch size.
       */
      set vignetteStretch(value) {
        this.imageProcessingConfiguration.vignetteStretch = value;
      }
      /**
       * Gets Vignette center X Offset.
       * @deprecated use vignetteCenterX instead
       */
      get vignetteCentreX() {
        return this.imageProcessingConfiguration.vignetteCenterX;
      }
      /**
       * Sets Vignette center X Offset.
       * @deprecated use vignetteCenterX instead
       */
      set vignetteCentreX(value) {
        this.imageProcessingConfiguration.vignetteCenterX = value;
      }
      /**
       * Gets Vignette center Y Offset.
       * @deprecated use vignetteCenterY instead
       */
      get vignetteCentreY() {
        return this.imageProcessingConfiguration.vignetteCenterY;
      }
      /**
       * Sets Vignette center Y Offset.
       * @deprecated use vignetteCenterY instead
       */
      set vignetteCentreY(value) {
        this.imageProcessingConfiguration.vignetteCenterY = value;
      }
      /**
       * Vignette center Y Offset.
       */
      get vignetteCenterY() {
        return this.imageProcessingConfiguration.vignetteCenterY;
      }
      set vignetteCenterY(value) {
        this.imageProcessingConfiguration.vignetteCenterY = value;
      }
      /**
       * Vignette center X Offset.
       */
      get vignetteCenterX() {
        return this.imageProcessingConfiguration.vignetteCenterX;
      }
      set vignetteCenterX(value) {
        this.imageProcessingConfiguration.vignetteCenterX = value;
      }
      /**
       * Gets Vignette weight or intensity of the vignette effect.
       */
      get vignetteWeight() {
        return this.imageProcessingConfiguration.vignetteWeight;
      }
      /**
       * Sets Vignette weight or intensity of the vignette effect.
       */
      set vignetteWeight(value) {
        this.imageProcessingConfiguration.vignetteWeight = value;
      }
      /**
       * Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
       * if vignetteEnabled is set to true.
       */
      get vignetteColor() {
        return this.imageProcessingConfiguration.vignetteColor;
      }
      /**
       * Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
       * if vignetteEnabled is set to true.
       */
      set vignetteColor(value) {
        this.imageProcessingConfiguration.vignetteColor = value;
      }
      /**
       * Gets Camera field of view used by the Vignette effect.
       */
      get vignetteCameraFov() {
        return this.imageProcessingConfiguration.vignetteCameraFov;
      }
      /**
       * Sets Camera field of view used by the Vignette effect.
       */
      set vignetteCameraFov(value) {
        this.imageProcessingConfiguration.vignetteCameraFov = value;
      }
      /**
       * Gets the vignette blend mode allowing different kind of effect.
       */
      get vignetteBlendMode() {
        return this.imageProcessingConfiguration.vignetteBlendMode;
      }
      /**
       * Sets the vignette blend mode allowing different kind of effect.
       */
      set vignetteBlendMode(value) {
        this.imageProcessingConfiguration.vignetteBlendMode = value;
      }
      /**
       * Gets whether the vignette effect is enabled.
       */
      get vignetteEnabled() {
        return this.imageProcessingConfiguration.vignetteEnabled;
      }
      /**
       * Sets whether the vignette effect is enabled.
       */
      set vignetteEnabled(value) {
        this.imageProcessingConfiguration.vignetteEnabled = value;
      }
      /**
       * Gets intensity of the dithering effect.
       */
      get ditheringIntensity() {
        return this.imageProcessingConfiguration.ditheringIntensity;
      }
      /**
       * Sets intensity of the dithering effect.
       */
      set ditheringIntensity(value) {
        this.imageProcessingConfiguration.ditheringIntensity = value;
      }
      /**
       * Gets whether the dithering effect is enabled.
       */
      get ditheringEnabled() {
        return this.imageProcessingConfiguration.ditheringEnabled;
      }
      /**
       * Sets whether the dithering effect is enabled.
       */
      set ditheringEnabled(value) {
        this.imageProcessingConfiguration.ditheringEnabled = value;
      }
      /**
       * Gets whether the input of the processing is in Gamma or Linear Space.
       */
      get fromLinearSpace() {
        return this._fromLinearSpace;
      }
      /**
       * Sets whether the input of the processing is in Gamma or Linear Space.
       */
      set fromLinearSpace(value) {
        if (this._fromLinearSpace === value) {
          return;
        }
        this._fromLinearSpace = value;
        this._updateParameters();
      }
      /**
       * * Gets the width of the output texture used to store the result of the post process.
       */
      get outputTextureWidth() {
        return this.imageProcessingConfiguration.outputTextureWidth;
      }
      /**
       * * Sets the width of the output texture used to store the result of the post process.
       */
      set outputTextureWidth(value) {
        this.imageProcessingConfiguration.outputTextureWidth = value;
      }
      /**
       * * Gets the height of the output texture used to store the result of the post process.
       */
      get outputTextureHeight() {
        return this.imageProcessingConfiguration.outputTextureHeight;
      }
      /**
       * * Sets the height of the output texture used to store the result of the post process.
       */
      set outputTextureHeight(value) {
        this.imageProcessingConfiguration.outputTextureHeight = value;
      }
      /**
       * Constructs a new image processing post process
       * @param name Name of the effect
       * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
       * @param options Options to configure the effect
       */
      constructor(name13, engine = null, options) {
        super({
          ...options,
          name: name13,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinImageProcessingPostProcess.FragmentUrl
        });
        this._fromLinearSpace = true;
        this._defines = {
          IMAGEPROCESSING: false,
          VIGNETTE: false,
          VIGNETTEBLENDMODEMULTIPLY: false,
          VIGNETTEBLENDMODEOPAQUE: false,
          TONEMAPPING: 0,
          CONTRAST: false,
          COLORCURVES: false,
          COLORGRADING: false,
          COLORGRADING3D: false,
          FROMLINEARSPACE: false,
          SAMPLER3DGREENDEPTH: false,
          SAMPLER3DBGRMAP: false,
          DITHER: false,
          IMAGEPROCESSINGPOSTPROCESS: false,
          EXPOSURE: false,
          SKIPFINALCOLORCLAMP: false
        };
        const imageProcessingConfiguration = options?.imageProcessingConfiguration;
        if (imageProcessingConfiguration) {
          imageProcessingConfiguration.applyByPostProcess = true;
          this._attachImageProcessingConfiguration(imageProcessingConfiguration, true);
          this._updateParameters();
        } else {
          this._attachImageProcessingConfiguration(null, true);
          this.imageProcessingConfiguration.applyByPostProcess = true;
        }
      }
      /**
       * @internal
       */
      _updateParameters() {
        this._defines.FROMLINEARSPACE = this._fromLinearSpace;
        this.imageProcessingConfiguration.prepareDefines(this._defines, true);
        let defines = "";
        for (const prop in this._defines) {
          const value = this._defines[prop];
          const type = typeof value;
          switch (type) {
            case "number":
            case "string":
              defines += `#define ${prop} ${value};
`;
              break;
            default:
              if (value) {
                defines += `#define ${prop};
`;
              }
              break;
          }
        }
        const samplers = ["textureSampler"];
        const uniforms = ["scale"];
        if (ImageProcessingConfiguration) {
          ImageProcessingConfiguration.PrepareSamplers(samplers, this._defines);
          ImageProcessingConfiguration.PrepareUniforms(uniforms, this._defines);
        }
        this.updateEffect(defines, uniforms, samplers);
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        this.imageProcessingConfiguration.bind(this.effect, this.overrideAspectRatio);
      }
      dispose() {
        super.dispose();
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        if (this._imageProcessingConfiguration) {
          this.imageProcessingConfiguration.applyByPostProcess = false;
        }
      }
    };
    ThinImageProcessingPostProcess.FragmentUrl = "imageProcessing";
  }
});

// node_modules/@babylonjs/core/FrameGraph/Tasks/PostProcesses/passTask.js
var FrameGraphPassTask, FrameGraphPassCubeTask;
var init_passTask = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Tasks/PostProcesses/passTask.js"() {
    init_postProcessTask();
    init_thinPassPostProcess();
    FrameGraphPassTask = class extends FrameGraphPostProcessTask {
      /**
       * Constructs a new pass task.
       * @param name The name of the task.
       * @param frameGraph The frame graph this task is associated with.
       * @param thinPostProcess The thin post process to use for the pass effect. If not provided, a new one will be created.
       */
      constructor(name13, frameGraph, thinPostProcess) {
        super(name13, frameGraph, thinPostProcess || new ThinPassPostProcess(name13, frameGraph.engine));
      }
      getClassName() {
        return "FrameGraphPassTask";
      }
    };
    FrameGraphPassCubeTask = class extends FrameGraphPostProcessTask {
      /**
       * Constructs a new pass cube task.
       * @param name The name of the task.
       * @param frameGraph The frame graph this task is associated with.
       * @param thinPostProcess The thin post process to use for the pass cube effect. If not provided, a new one will be created.
       */
      constructor(name13, frameGraph, thinPostProcess) {
        super(name13, frameGraph, thinPostProcess || new ThinPassCubePostProcess(name13, frameGraph.engine));
      }
      getClassName() {
        return "FrameGraphPassCubeTask";
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinSharpenPostProcess.js
var ThinSharpenPostProcess;
var init_thinSharpenPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinSharpenPostProcess.js"() {
    init_effectRenderer();
    init_engine();
    ThinSharpenPostProcess = class _ThinSharpenPostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(import("./sharpen.fragment-THAFQJQD.js"));
        } else {
          list.push(import("./sharpen.fragment-Z2IXJVCZ.js"));
        }
      }
      /**
       * Constructs a new sharpen post process
       * @param name Name of the effect
       * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
       * @param options Options to configure the effect
       */
      constructor(name13, engine = null, options) {
        super({
          ...options,
          name: name13,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinSharpenPostProcess.FragmentUrl,
          uniforms: _ThinSharpenPostProcess.Uniforms
        });
        this.colorAmount = 1;
        this.edgeAmount = 0.3;
        this.textureWidth = 0;
        this.textureHeight = 0;
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        const effect = this._drawWrapper.effect;
        effect.setFloat2("screenSize", this.textureWidth, this.textureHeight);
        effect.setFloat2("sharpnessAmounts", this.edgeAmount, this.colorAmount);
      }
    };
    ThinSharpenPostProcess.FragmentUrl = "sharpen";
    ThinSharpenPostProcess.Uniforms = ["sharpnessAmounts", "screenSize"];
  }
});

// node_modules/@babylonjs/core/PostProcesses/blurPostProcess.js
var BlurPostProcess;
var init_blurPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/blurPostProcess.js"() {
    init_tslib_es6();
    init_postProcess();
    init_texture();
    init_typeStore();
    init_decorators();
    init_decorators_serialization();
    init_thinBlurPostProcess();
    BlurPostProcess = class _BlurPostProcess extends PostProcess {
      /** The direction in which to blur the image. */
      get direction() {
        return this._effectWrapper.direction;
      }
      set direction(value) {
        this._effectWrapper.direction = value;
      }
      /**
       * Sets the length in pixels of the blur sample region
       */
      set kernel(v) {
        this._effectWrapper.kernel = v;
      }
      /**
       * Gets the length in pixels of the blur sample region
       */
      get kernel() {
        return this._effectWrapper.kernel;
      }
      /**
       * Sets whether or not the blur needs to unpack/repack floats
       */
      set packedFloat(v) {
        this._effectWrapper.packedFloat = v;
      }
      /**
       * Gets whether or not the blur is unpacking/repacking floats
       */
      get packedFloat() {
        return this._effectWrapper.packedFloat;
      }
      /**
       * Gets a string identifying the name of the class
       * @returns "BlurPostProcess" string
       */
      getClassName() {
        return "BlurPostProcess";
      }
      /**
       * Creates a new instance BlurPostProcess
       * @param name The name of the effect.
       * @param direction The direction in which to blur the image.
       * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.
       * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
       * @param camera The camera to apply the render pass to.
       * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
       * @param engine The engine which the post process will be applied. (default: current engine)
       * @param reusable If the post process can be reused on the same frame. (default: false)
       * @param textureType Type of textures used when performing the post process. (default: 0)
       * @param defines
       * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
       * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)
       */
      constructor(name13, direction, kernel, options, camera = null, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable, textureType = 0, defines = "", blockCompilation = false, textureFormat = 5) {
        const blockCompilationFinal = typeof options === "number" ? blockCompilation : !!options.blockCompilation;
        const localOptions = {
          uniforms: ThinBlurPostProcess.Uniforms,
          samplers: ThinBlurPostProcess.Samplers,
          size: typeof options === "number" ? options : void 0,
          camera,
          samplingMode,
          engine,
          reusable,
          textureType,
          vertexUrl: ThinBlurPostProcess.VertexUrl,
          indexParameters: { varyingCount: 0, depCount: 0 },
          textureFormat,
          defines,
          ...options,
          blockCompilation: true
        };
        super(name13, ThinBlurPostProcess.FragmentUrl, {
          effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinBlurPostProcess(name13, engine, void 0, void 0, localOptions) : void 0,
          ...localOptions
        });
        this._effectWrapper.options.blockCompilation = blockCompilationFinal;
        this.direction = direction;
        this.onApplyObservable.add(() => {
          this._effectWrapper.textureWidth = this._outputTexture ? this._outputTexture.width : this.width;
          this._effectWrapper.textureHeight = this._outputTexture ? this._outputTexture.height : this.height;
        });
        this.kernel = kernel;
      }
      updateEffect(_defines = null, _uniforms = null, _samplers = null, _indexParameters, onCompiled, onError) {
        this._effectWrapper._updateParameters(onCompiled, onError);
      }
      /**
       * @internal
       */
      static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
        return SerializationHelper.Parse(() => {
          return new _BlurPostProcess(parsedPostProcess.name, parsedPostProcess.direction, parsedPostProcess.kernel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, void 0, false);
        }, parsedPostProcess, scene, rootUrl);
      }
    };
    __decorate([
      serializeAsVector2()
    ], BlurPostProcess.prototype, "direction", null);
    __decorate([
      serialize()
    ], BlurPostProcess.prototype, "kernel", null);
    __decorate([
      serialize()
    ], BlurPostProcess.prototype, "packedFloat", null);
    RegisterClass("BABYLON.BlurPostProcess", BlurPostProcess);
  }
});

// node_modules/@babylonjs/core/Lights/Shadows/shadowGenerator.js
var ShadowGenerator;
var init_shadowGenerator = __esm({
  "node_modules/@babylonjs/core/Lights/Shadows/shadowGenerator.js"() {
    init_math_vector();
    init_math_color();
    init_buffer();
    init_light();
    init_texture();
    init_renderTargetTexture();
    init_postProcess();
    init_blurPostProcess();
    init_observable();
    init_devTools();
    init_effectFallbacks();
    init_renderingManager();
    init_drawWrapper();
    init_clipPlaneMaterialHelper();
    init_materialHelper_functions();
    init_floatingOriginMatrixOverrides();
    ShadowGenerator = class _ShadowGenerator {
      /**
       * Gets the bias: offset applied on the depth preventing acnea (in light direction).
       */
      get bias() {
        return this._bias;
      }
      /**
       * Sets the bias: offset applied on the depth preventing acnea (in light direction).
       */
      set bias(bias) {
        this._bias = bias;
      }
      /**
       * Gets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportional to the light/normal angle).
       */
      get normalBias() {
        return this._normalBias;
      }
      /**
       * Sets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportional to the light/normal angle).
       */
      set normalBias(normalBias) {
        this._normalBias = normalBias;
      }
      /**
       * Gets the blur box offset: offset applied during the blur pass.
       * Only useful if useKernelBlur = false
       */
      get blurBoxOffset() {
        return this._blurBoxOffset;
      }
      /**
       * Sets the blur box offset: offset applied during the blur pass.
       * Only useful if useKernelBlur = false
       */
      set blurBoxOffset(value) {
        if (this._blurBoxOffset === value) {
          return;
        }
        this._blurBoxOffset = value;
        this._disposeBlurPostProcesses();
      }
      /**
       * Gets the blur scale: scale of the blurred texture compared to the main shadow map.
       * 2 means half of the size.
       */
      get blurScale() {
        return this._blurScale;
      }
      /**
       * Sets the blur scale: scale of the blurred texture compared to the main shadow map.
       * 2 means half of the size.
       */
      set blurScale(value) {
        if (this._blurScale === value) {
          return;
        }
        this._blurScale = value;
        this._disposeBlurPostProcesses();
      }
      /**
       * Gets the blur kernel: kernel size of the blur pass.
       * Only useful if useKernelBlur = true
       */
      get blurKernel() {
        return this._blurKernel;
      }
      /**
       * Sets the blur kernel: kernel size of the blur pass.
       * Only useful if useKernelBlur = true
       */
      set blurKernel(value) {
        if (this._blurKernel === value) {
          return;
        }
        this._blurKernel = value;
        this._disposeBlurPostProcesses();
      }
      /**
       * Gets whether the blur pass is a kernel blur (if true) or box blur.
       * Only useful in filtered mode (useBlurExponentialShadowMap...)
       */
      get useKernelBlur() {
        return this._useKernelBlur;
      }
      /**
       * Sets whether the blur pass is a kernel blur (if true) or box blur.
       * Only useful in filtered mode (useBlurExponentialShadowMap...)
       */
      set useKernelBlur(value) {
        if (this._useKernelBlur === value) {
          return;
        }
        this._useKernelBlur = value;
        this._disposeBlurPostProcesses();
      }
      /**
       * Gets the depth scale used in ESM mode.
       */
      get depthScale() {
        return this._depthScale !== void 0 ? this._depthScale : this._light.getDepthScale();
      }
      /**
       * Sets the depth scale used in ESM mode.
       * This can override the scale stored on the light.
       */
      set depthScale(value) {
        this._depthScale = value;
      }
      _validateFilter(filter) {
        return filter;
      }
      /**
       * Gets the current mode of the shadow generator (normal, PCF, ESM...).
       * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
       */
      get filter() {
        return this._filter;
      }
      /**
       * Sets the current mode of the shadow generator (normal, PCF, ESM...).
       * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
       */
      set filter(value) {
        value = this._validateFilter(value);
        if (this._light.needCube()) {
          if (value === _ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {
            this.useExponentialShadowMap = true;
            return;
          } else if (value === _ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
            this.useCloseExponentialShadowMap = true;
            return;
          } else if (value === _ShadowGenerator.FILTER_PCF || value === _ShadowGenerator.FILTER_PCSS) {
            this.usePoissonSampling = true;
            return;
          }
        }
        if (value === _ShadowGenerator.FILTER_PCF || value === _ShadowGenerator.FILTER_PCSS) {
          if (!this._scene.getEngine()._features.supportShadowSamplers) {
            this.usePoissonSampling = true;
            return;
          }
        }
        if (this._filter === value) {
          return;
        }
        this._filter = value;
        this._disposeBlurPostProcesses();
        this._applyFilterValues();
        this._light._markMeshesAsLightDirty();
      }
      /**
       * Gets if the current filter is set to Poisson Sampling.
       */
      get usePoissonSampling() {
        return this.filter === _ShadowGenerator.FILTER_POISSONSAMPLING;
      }
      /**
       * Sets the current filter to Poisson Sampling.
       */
      set usePoissonSampling(value) {
        const filter = this._validateFilter(_ShadowGenerator.FILTER_POISSONSAMPLING);
        if (!value && this.filter !== _ShadowGenerator.FILTER_POISSONSAMPLING) {
          return;
        }
        this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
      }
      /**
       * Gets if the current filter is set to ESM.
       */
      get useExponentialShadowMap() {
        return this.filter === _ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP;
      }
      /**
       * Sets the current filter is to ESM.
       */
      set useExponentialShadowMap(value) {
        const filter = this._validateFilter(_ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP);
        if (!value && this.filter !== _ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP) {
          return;
        }
        this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
      }
      /**
       * Gets if the current filter is set to filtered ESM.
       */
      get useBlurExponentialShadowMap() {
        return this.filter === _ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP;
      }
      /**
       * Gets if the current filter is set to filtered  ESM.
       */
      set useBlurExponentialShadowMap(value) {
        const filter = this._validateFilter(_ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP);
        if (!value && this.filter !== _ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {
          return;
        }
        this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
      }
      /**
       * Gets if the current filter is set to "close ESM" (using the inverse of the
       * exponential to prevent steep falloff artifacts).
       */
      get useCloseExponentialShadowMap() {
        return this.filter === _ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP;
      }
      /**
       * Sets the current filter to "close ESM" (using the inverse of the
       * exponential to prevent steep falloff artifacts).
       */
      set useCloseExponentialShadowMap(value) {
        const filter = this._validateFilter(_ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP);
        if (!value && this.filter !== _ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP) {
          return;
        }
        this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
      }
      /**
       * Gets if the current filter is set to filtered "close ESM" (using the inverse of the
       * exponential to prevent steep falloff artifacts).
       */
      get useBlurCloseExponentialShadowMap() {
        return this.filter === _ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;
      }
      /**
       * Sets the current filter to filtered "close ESM" (using the inverse of the
       * exponential to prevent steep falloff artifacts).
       */
      set useBlurCloseExponentialShadowMap(value) {
        const filter = this._validateFilter(_ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);
        if (!value && this.filter !== _ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
          return;
        }
        this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
      }
      /**
       * Gets if the current filter is set to "PCF" (percentage closer filtering).
       */
      get usePercentageCloserFiltering() {
        return this.filter === _ShadowGenerator.FILTER_PCF;
      }
      /**
       * Sets the current filter to "PCF" (percentage closer filtering).
       */
      set usePercentageCloserFiltering(value) {
        const filter = this._validateFilter(_ShadowGenerator.FILTER_PCF);
        if (!value && this.filter !== _ShadowGenerator.FILTER_PCF) {
          return;
        }
        this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
      }
      /**
       * Gets the PCF or PCSS Quality.
       * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
       */
      get filteringQuality() {
        return this._filteringQuality;
      }
      /**
       * Sets the PCF or PCSS Quality.
       * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
       */
      set filteringQuality(filteringQuality) {
        if (this._filteringQuality === filteringQuality) {
          return;
        }
        this._filteringQuality = filteringQuality;
        this._disposeBlurPostProcesses();
        this._applyFilterValues();
        this._light._markMeshesAsLightDirty();
      }
      /**
       * Gets if the current filter is set to "PCSS" (contact hardening).
       */
      get useContactHardeningShadow() {
        return this.filter === _ShadowGenerator.FILTER_PCSS;
      }
      /**
       * Sets the current filter to "PCSS" (contact hardening).
       */
      set useContactHardeningShadow(value) {
        const filter = this._validateFilter(_ShadowGenerator.FILTER_PCSS);
        if (!value && this.filter !== _ShadowGenerator.FILTER_PCSS) {
          return;
        }
        this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
      }
      /**
       * Gets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
       * Using a ratio helps keeping shape stability independently of the map size.
       *
       * It does not account for the light projection as it was having too much
       * instability during the light setup or during light position changes.
       *
       * Only valid if useContactHardeningShadow is true.
       */
      get contactHardeningLightSizeUVRatio() {
        return this._contactHardeningLightSizeUVRatio;
      }
      /**
       * Sets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
       * Using a ratio helps keeping shape stability independently of the map size.
       *
       * It does not account for the light projection as it was having too much
       * instability during the light setup or during light position changes.
       *
       * Only valid if useContactHardeningShadow is true.
       */
      set contactHardeningLightSizeUVRatio(contactHardeningLightSizeUVRatio) {
        this._contactHardeningLightSizeUVRatio = contactHardeningLightSizeUVRatio;
      }
      /** Gets or sets the actual darkness of a shadow */
      get darkness() {
        return this._darkness;
      }
      set darkness(value) {
        this.setDarkness(value);
      }
      /**
       * Returns the darkness value (float). This can only decrease the actual darkness of a shadow.
       * 0 means strongest and 1 would means no shadow.
       * @returns the darkness.
       */
      getDarkness() {
        return this._darkness;
      }
      /**
       * Sets the darkness value (float). This can only decrease the actual darkness of a shadow.
       * @param darkness The darkness value 0 means strongest and 1 would means no shadow.
       * @returns the shadow generator allowing fluent coding.
       */
      setDarkness(darkness) {
        if (darkness >= 1) {
          this._darkness = 1;
        } else if (darkness <= 0) {
          this._darkness = 0;
        } else {
          this._darkness = darkness;
        }
        return this;
      }
      /** Gets or sets the ability to have transparent shadow */
      get transparencyShadow() {
        return this._transparencyShadow;
      }
      set transparencyShadow(value) {
        this.setTransparencyShadow(value);
      }
      /**
       * Sets the ability to have transparent shadow (boolean).
       * @param transparent True if transparent else False
       * @returns the shadow generator allowing fluent coding
       */
      setTransparencyShadow(transparent) {
        this._transparencyShadow = transparent;
        return this;
      }
      /**
       * Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
       * @returns The render target texture if present otherwise, null
       */
      getShadowMap() {
        return this._shadowMap;
      }
      /**
       * Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
       * @returns The render target texture if the shadow map is present otherwise, null
       */
      getShadowMapForRendering() {
        if (this._shadowMap2) {
          return this._shadowMap2;
        }
        return this._shadowMap;
      }
      /**
       * Gets the class name of that object
       * @returns "ShadowGenerator"
       */
      getClassName() {
        return _ShadowGenerator.CLASSNAME;
      }
      /**
       * Helper function to add a mesh and its descendants to the list of shadow casters.
       * @param mesh Mesh to add
       * @param includeDescendants boolean indicating if the descendants should be added. Default to true
       * @returns the Shadow Generator itself
       */
      addShadowCaster(mesh, includeDescendants = true) {
        if (!this._shadowMap) {
          return this;
        }
        if (!this._shadowMap.renderList) {
          this._shadowMap.renderList = [];
        }
        if (this._shadowMap.renderList.indexOf(mesh) === -1) {
          this._shadowMap.renderList.push(mesh);
        }
        if (includeDescendants) {
          for (const childMesh of mesh.getChildMeshes()) {
            if (this._shadowMap.renderList.indexOf(childMesh) === -1) {
              this._shadowMap.renderList.push(childMesh);
            }
          }
        }
        return this;
      }
      /**
       * Helper function to remove a mesh and its descendants from the list of shadow casters
       * @param mesh Mesh to remove
       * @param includeDescendants boolean indicating if the descendants should be removed. Default to true
       * @returns the Shadow Generator itself
       */
      removeShadowCaster(mesh, includeDescendants = true) {
        if (!this._shadowMap || !this._shadowMap.renderList) {
          return this;
        }
        const index = this._shadowMap.renderList.indexOf(mesh);
        if (index !== -1) {
          this._shadowMap.renderList.splice(index, 1);
        }
        if (includeDescendants) {
          for (const child of mesh.getChildren()) {
            this.removeShadowCaster(child);
          }
        }
        return this;
      }
      /**
       * Returns the associated light object.
       * @returns the light generating the shadow
       */
      getLight() {
        return this._light;
      }
      /**
       * Gets the shader language used in this generator.
       */
      get shaderLanguage() {
        return this._shaderLanguage;
      }
      _getCamera() {
        return this._camera ?? this._scene.activeCamera;
      }
      /**
       * Gets or sets the size of the texture what stores the shadows
       */
      get mapSize() {
        return this._mapSize;
      }
      set mapSize(size) {
        this._mapSize = size;
        this._light._markMeshesAsLightDirty();
        this.recreateShadowMap();
      }
      /**
       * Creates a ShadowGenerator object.
       * A ShadowGenerator is the required tool to use the shadows.
       * Each light casting shadows needs to use its own ShadowGenerator.
       * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows
       * @param mapSize The size of the texture what stores the shadows. Example : 1024.
       * @param light The light object generating the shadows.
       * @param usefullFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
       * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it
       * @param useRedTextureType Forces the generator to use a Red instead of a RGBA type for the shadow map texture format (default: false)
       * @param forceGLSL defines a boolean indicating if the shader must be compiled in GLSL even if we are using WebGPU
       */
      constructor(mapSize, light, usefullFloatFirst, camera, useRedTextureType, forceGLSL = false) {
        this.onBeforeShadowMapRenderObservable = new Observable();
        this.onAfterShadowMapRenderObservable = new Observable();
        this.onBeforeShadowMapRenderMeshObservable = new Observable();
        this.onAfterShadowMapRenderMeshObservable = new Observable();
        this.doNotSerialize = false;
        this._bias = 5e-5;
        this._normalBias = 0;
        this._blurBoxOffset = 1;
        this._blurScale = 2;
        this._blurKernel = 1;
        this._useKernelBlur = false;
        this._filter = _ShadowGenerator.FILTER_NONE;
        this._filteringQuality = _ShadowGenerator.QUALITY_HIGH;
        this._contactHardeningLightSizeUVRatio = 0.1;
        this._darkness = 0;
        this._transparencyShadow = false;
        this.enableSoftTransparentShadow = false;
        this.useOpacityTextureForTransparentShadow = false;
        this.frustumEdgeFalloff = 0;
        this._shaderLanguage = 0;
        this.forceBackFacesOnly = false;
        this._lightDirection = Vector3.Zero();
        this._viewMatrix = Matrix.Zero();
        this._projectionMatrix = Matrix.Zero();
        this._transformMatrix = Matrix.Zero();
        this._cachedPosition = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cachedDirection = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._currentFaceIndex = 0;
        this._currentFaceIndexCache = 0;
        this._defaultTextureMatrix = Matrix.Identity();
        this._shadersLoaded = false;
        this._mapSize = mapSize;
        this._light = light;
        this._scene = light.getScene();
        this._camera = camera ?? null;
        this._useRedTextureType = !!useRedTextureType;
        this._initShaderSourceAsync(forceGLSL);
        let shadowGenerators = light._shadowGenerators;
        if (!shadowGenerators) {
          shadowGenerators = light._shadowGenerators = /* @__PURE__ */ new Map();
        }
        shadowGenerators.set(this._camera, this);
        this.id = light.id;
        this._useUBO = this._scene.getEngine().supportsUniformBuffers;
        if (this._useUBO) {
          this._sceneUBOs = [];
          this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light "${this._light.name}")`));
        }
        _ShadowGenerator._SceneComponentInitialization(this._scene);
        const caps = this._scene.getEngine().getCaps();
        if (!usefullFloatFirst) {
          if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
            this._textureType = 2;
          } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
            this._textureType = 1;
          } else {
            this._textureType = 0;
          }
        } else {
          if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
            this._textureType = 1;
          } else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
            this._textureType = 2;
          } else {
            this._textureType = 0;
          }
        }
        this._initializeGenerator();
        this._applyFilterValues();
      }
      _initializeGenerator() {
        this._light._markMeshesAsLightDirty();
        this._initializeShadowMap();
      }
      _createTargetRenderTexture() {
        const engine = this._scene.getEngine();
        this._shadowMap?.dispose();
        if (engine._features.supportDepthStencilTexture) {
          this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube(), void 0, false, false, void 0, this._useRedTextureType ? 6 : 5);
          this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true, void 0, void 0, void 0, `DepthStencilForShadowGenerator-${this._light.name}`);
        } else {
          this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube());
        }
        this._shadowMap.noPrePassRenderer = true;
      }
      _initializeShadowMap() {
        this._createTargetRenderTexture();
        if (this._shadowMap === null) {
          return;
        }
        this._shadowMap.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._shadowMap.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._shadowMap.anisotropicFilteringLevel = 1;
        this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        this._shadowMap.renderParticles = false;
        this._shadowMap.ignoreCameraViewport = true;
        if (this._storedUniqueId) {
          this._shadowMap.uniqueId = this._storedUniqueId;
        }
        this._shadowMap.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => this._renderForShadowMap(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes);
        this._shadowMap.customIsReadyFunction = (mesh, _refreshRate, preWarm) => {
          if (!preWarm || !mesh.subMeshes) {
            return true;
          }
          let isReady = true;
          for (const subMesh of mesh.subMeshes) {
            const renderingMesh = subMesh.getRenderingMesh();
            const scene = this._scene;
            const engine2 = scene.getEngine();
            const material = subMesh.getMaterial();
            if (!material || subMesh.verticesCount === 0 || this.customAllowRendering && !this.customAllowRendering(subMesh)) {
              continue;
            }
            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
            if (batch.mustReturn) {
              continue;
            }
            const hardwareInstancedRendering = engine2.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
            const isTransparent = material.needAlphaBlendingForMesh(renderingMesh);
            isReady = this.isReady(subMesh, hardwareInstancedRendering, isTransparent) && isReady;
          }
          return isReady;
        };
        const engine = this._scene.getEngine();
        this._shadowMap.onBeforeBindObservable.add(() => {
          this._currentSceneUBO = this._scene.getSceneUniformBuffer();
          if (engine._enableGPUDebugMarkers) {
            engine.restoreDefaultFramebuffer();
            engine._debugPushGroup?.(`Shadow map generation for pass id ${engine.currentRenderPassId}`);
          }
        });
        this._shadowMap.onBeforeRenderObservable.add((faceIndex) => {
          if (this._sceneUBOs) {
            this._scene.setSceneUniformBuffer(this._sceneUBOs[0]);
          }
          this._currentFaceIndex = faceIndex;
          if (this._filter === _ShadowGenerator.FILTER_PCF) {
            engine.setColorWrite(false);
          }
          this.getTransformMatrix();
          FloatingOriginCurrentScene.eyeAtCamera = false;
          this._scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);
          if (this._useUBO) {
            this._scene.getSceneUniformBuffer().unbindEffect();
            this._scene.finalizeSceneUbo();
          }
        });
        this._shadowMap.onAfterUnbindObservable.add(() => {
          if (this._sceneUBOs) {
            this._scene.setSceneUniformBuffer(this._currentSceneUBO);
          }
          FloatingOriginCurrentScene.eyeAtCamera = true;
          this._scene.updateTransformMatrix();
          if (this._filter === _ShadowGenerator.FILTER_PCF) {
            engine.setColorWrite(true);
          }
          if (!this.useBlurExponentialShadowMap && !this.useBlurCloseExponentialShadowMap) {
            engine._debugPopGroup?.();
            return;
          }
          const shadowMap = this.getShadowMapForRendering();
          if (shadowMap) {
            this._scene.postProcessManager.directRender(this._blurPostProcesses, shadowMap.renderTarget, true);
            engine.unBindFramebuffer(shadowMap.renderTarget, true);
          }
          if (engine._enableGPUDebugMarkers) {
            engine._debugPopGroup?.();
          }
        });
        const clearZero = new Color4(0, 0, 0, 0);
        const clearOne = new Color4(1, 1, 1, 1);
        this._shadowMap.onClearObservable.add((engine2) => {
          if (this._filter === _ShadowGenerator.FILTER_PCF) {
            engine2.clear(clearOne, false, true, false);
          } else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {
            engine2.clear(clearZero, true, true, false);
          } else {
            engine2.clear(clearOne, true, true, false);
          }
        });
        this._shadowMap.onResizeObservable.add((rtt) => {
          this._storedUniqueId = this._shadowMap.uniqueId;
          this._mapSize = rtt.getRenderSize();
          this._light._markMeshesAsLightDirty();
          this.recreateShadowMap();
        });
        for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {
          this._shadowMap.setRenderingAutoClearDepthStencil(i, false);
        }
      }
      async _initShaderSourceAsync(forceGLSL = false) {
        const engine = this._scene.getEngine();
        if (engine.isWebGPU && !forceGLSL && !_ShadowGenerator.ForceGLSL) {
          this._shaderLanguage = 1;
          await Promise.all([
            import("./shadowMap.fragment-2MCXAEYQ.js"),
            import("./shadowMap.vertex-6LNCTW2Q.js"),
            import("./depthBoxBlur.fragment-CWVLPW33.js"),
            import("./shadowMapFragmentSoftTransparentShadow-ZARYJV4H.js")
          ]);
        } else {
          await Promise.all([
            import("./shadowMap.fragment-HGWA5DWA.js"),
            import("./shadowMap.vertex-GWXVCGQL.js"),
            import("./depthBoxBlur.fragment-HBWLBIXA.js"),
            import("./shadowMapFragmentSoftTransparentShadow-4OM7LZYZ.js")
          ]);
        }
        this._shadersLoaded = true;
      }
      _initializeBlurRTTAndPostProcesses() {
        const engine = this._scene.getEngine();
        const targetSize = this._mapSize / this.blurScale;
        if (!this.useKernelBlur || this.blurScale !== 1) {
          this._shadowMap2 = new RenderTargetTexture(this._light.name + "_shadowMap2", targetSize, this._scene, false, true, this._textureType, void 0, void 0, false);
          this._shadowMap2.wrapU = Texture.CLAMP_ADDRESSMODE;
          this._shadowMap2.wrapV = Texture.CLAMP_ADDRESSMODE;
          this._shadowMap2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        }
        if (this.useKernelBlur) {
          this._kernelBlurXPostprocess = new BlurPostProcess(this._light.name + "KernelBlurX", new Vector2(1, 0), this.blurKernel, 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
          this._kernelBlurXPostprocess.width = targetSize;
          this._kernelBlurXPostprocess.height = targetSize;
          this._kernelBlurXPostprocess.externalTextureSamplerBinding = true;
          this._kernelBlurXPostprocess.onApplyObservable.add((effect) => {
            effect.setTexture("textureSampler", this._shadowMap);
          });
          this._kernelBlurYPostprocess = new BlurPostProcess(this._light.name + "KernelBlurY", new Vector2(0, 1), this.blurKernel, 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
          this._kernelBlurXPostprocess.autoClear = false;
          this._kernelBlurYPostprocess.autoClear = false;
          if (this._textureType === 0) {
            this._kernelBlurXPostprocess.packedFloat = true;
            this._kernelBlurYPostprocess.packedFloat = true;
          }
          this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess];
        } else {
          this._boxBlurPostprocess = new PostProcess(this._light.name + "DepthBoxBlur", "depthBoxBlur", ["screenSize", "boxOffset"], [], 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, "#define OFFSET " + this._blurBoxOffset, this._textureType, void 0, void 0, void 0, void 0, this._shaderLanguage);
          this._boxBlurPostprocess.externalTextureSamplerBinding = true;
          this._boxBlurPostprocess.onApplyObservable.add((effect) => {
            effect.setFloat2("screenSize", targetSize, targetSize);
            effect.setTexture("textureSampler", this._shadowMap);
          });
          this._boxBlurPostprocess.autoClear = false;
          this._blurPostProcesses = [this._boxBlurPostprocess];
        }
      }
      _renderForShadowMap(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
        let index;
        if (depthOnlySubMeshes.length) {
          for (index = 0; index < depthOnlySubMeshes.length; index++) {
            this._renderSubMeshForShadowMap(depthOnlySubMeshes.data[index]);
          }
        }
        for (index = 0; index < opaqueSubMeshes.length; index++) {
          this._renderSubMeshForShadowMap(opaqueSubMeshes.data[index]);
        }
        for (index = 0; index < alphaTestSubMeshes.length; index++) {
          this._renderSubMeshForShadowMap(alphaTestSubMeshes.data[index]);
        }
        if (this._transparencyShadow) {
          for (index = 0; index < transparentSubMeshes.length; index++) {
            this._renderSubMeshForShadowMap(transparentSubMeshes.data[index], true);
          }
        } else {
          for (index = 0; index < transparentSubMeshes.length; index++) {
            transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;
          }
        }
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect, mesh) {
        effect.setMatrix("viewProjection", this.getTransformMatrix());
      }
      _renderSubMeshForShadowMap(subMesh, isTransparent = false) {
        const renderingMesh = subMesh.getRenderingMesh();
        const effectiveMesh = subMesh.getEffectiveMesh();
        const scene = this._scene;
        const engine = scene.getEngine();
        const material = subMesh.getMaterial();
        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
        if (!material || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {
          return;
        }
        const useRHS = scene.useRightHandedSystem;
        const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;
        let sideOrientation = material._getEffectiveOrientation(renderingMesh);
        if (detNeg && !useRHS || !detNeg && useRHS) {
          sideOrientation = sideOrientation === 0 ? 1 : 0;
        }
        const reverseSideOrientation = sideOrientation === 0;
        engine.setState(material.backFaceCulling, void 0, void 0, reverseSideOrientation, material.cullBackFaces);
        const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
        if (batch.mustReturn) {
          return;
        }
        const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
        if (this.customAllowRendering && !this.customAllowRendering(subMesh)) {
          return;
        }
        if (this.isReady(subMesh, hardwareInstancedRendering, isTransparent)) {
          subMesh._renderId = scene.getRenderId();
          const shadowDepthWrapper = material.shadowDepthWrapper;
          const drawWrapper = shadowDepthWrapper?.getEffect(subMesh, this, engine.currentRenderPassId) ?? subMesh._getDrawWrapper();
          const effect = DrawWrapper.GetEffect(drawWrapper);
          engine.enableEffect(drawWrapper);
          if (!hardwareInstancedRendering) {
            renderingMesh._bind(subMesh, effect, material.fillMode);
          }
          this.getTransformMatrix();
          effect.setFloat3("biasAndScaleSM", this.bias, this.normalBias, this.depthScale);
          if (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
            effect.setVector3("lightDataSM", this._cachedDirection);
          } else {
            effect.setVector3("lightDataSM", this._cachedPosition.subtractToRef(this._scene.floatingOriginOffset, TmpVectors.Vector3[0]));
          }
          const camera = this._getCamera();
          effect.setFloat2("depthValuesSM", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera));
          if (isTransparent && this.enableSoftTransparentShadow) {
            effect.setFloat2("softTransparentShadowSM", effectiveMesh.visibility * material.alpha, this._opacityTexture?.getAlphaFromRGB ? 1 : 0);
          }
          if (shadowDepthWrapper) {
            subMesh._setMainDrawWrapperOverride(drawWrapper);
            if (shadowDepthWrapper.standalone) {
              shadowDepthWrapper.baseMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);
            } else {
              material.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);
            }
            subMesh._setMainDrawWrapperOverride(null);
          } else {
            if (this._opacityTexture) {
              effect.setTexture("diffuseSampler", this._opacityTexture);
              effect.setMatrix("diffuseMatrix", this._opacityTexture.getTextureMatrix() || this._defaultTextureMatrix);
            }
            if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
              const skeleton = renderingMesh.skeleton;
              if (skeleton.isUsingTextureForMatrices) {
                const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);
                if (!boneTexture) {
                  return;
                }
                effect.setTexture("boneSampler", boneTexture);
                effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
              } else {
                effect.setMatrices("mBones", skeleton.getTransformMatrices(renderingMesh));
              }
            }
            BindMorphTargetParameters(renderingMesh, effect);
            if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
              renderingMesh.morphTargetManager._bind(effect);
            }
            const bvaManager = subMesh.getMesh().bakedVertexAnimationManager;
            if (bvaManager && bvaManager.isEnabled) {
              bvaManager.bind(effect, hardwareInstancedRendering);
            }
            BindClipPlane(effect, material, scene);
          }
          if (!this._useUBO && !shadowDepthWrapper) {
            this._bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect, effectiveMesh);
          }
          BindSceneUniformBuffer(effect, this._scene.getSceneUniformBuffer());
          this._scene.getSceneUniformBuffer().bindUniformBuffer();
          const world = effectiveMesh.getWorldMatrix();
          if (hardwareInstancedRendering) {
            effectiveMesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
            effectiveMesh.transferToEffect(world);
          }
          if (this.forceBackFacesOnly) {
            engine.setState(true, 0, false, true, material.cullBackFaces);
          }
          this.onBeforeShadowMapRenderMeshObservable.notifyObservers(renderingMesh);
          this.onBeforeShadowMapRenderObservable.notifyObservers(effect);
          renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, worldOverride) => {
            if (effectiveMesh !== renderingMesh && !isInstance) {
              renderingMesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
              renderingMesh.transferToEffect(worldOverride);
            } else {
              effectiveMesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
              effectiveMesh.transferToEffect(isInstance ? worldOverride : world);
            }
          });
          if (this.forceBackFacesOnly) {
            engine.setState(true, 0, false, false, material.cullBackFaces);
          }
          this.onAfterShadowMapRenderObservable.notifyObservers(effect);
          this.onAfterShadowMapRenderMeshObservable.notifyObservers(renderingMesh);
        } else {
          if (this._shadowMap) {
            this._shadowMap.resetRefreshCounter();
          }
        }
      }
      _applyFilterValues() {
        if (!this._shadowMap) {
          return;
        }
        if (this.filter === _ShadowGenerator.FILTER_NONE || this.filter === _ShadowGenerator.FILTER_PCSS) {
          this._shadowMap.updateSamplingMode(Texture.NEAREST_SAMPLINGMODE);
        } else {
          this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        }
      }
      /**
       * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.
       * @param onCompiled Callback triggered at the and of the effects compilation
       * @param options Sets of optional options forcing the compilation with different modes
       */
      forceCompilation(onCompiled, options) {
        const localOptions = {
          useInstances: false,
          ...options
        };
        const shadowMap = this.getShadowMap();
        if (!shadowMap) {
          if (onCompiled) {
            onCompiled(this);
          }
          return;
        }
        const renderList = shadowMap.renderList;
        if (!renderList) {
          if (onCompiled) {
            onCompiled(this);
          }
          return;
        }
        const subMeshes = [];
        for (const mesh of renderList) {
          subMeshes.push(...mesh.subMeshes);
        }
        if (subMeshes.length === 0) {
          if (onCompiled) {
            onCompiled(this);
          }
          return;
        }
        let currentIndex = 0;
        const checkReady = () => {
          if (!this._scene || !this._scene.getEngine()) {
            return;
          }
          while (this.isReady(subMeshes[currentIndex], localOptions.useInstances, subMeshes[currentIndex].getMaterial()?.needAlphaBlendingForMesh(subMeshes[currentIndex].getMesh()) ?? false)) {
            currentIndex++;
            if (currentIndex >= subMeshes.length) {
              if (onCompiled) {
                onCompiled(this);
              }
              return;
            }
          }
          setTimeout(checkReady, 16);
        };
        checkReady();
      }
      /**
       * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.
       * @param options Sets of optional options forcing the compilation with different modes
       * @returns A promise that resolves when the compilation completes
       */
      async forceCompilationAsync(options) {
        return await new Promise((resolve) => {
          this.forceCompilation(() => {
            resolve();
          }, options);
        });
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _isReadyCustomDefines(defines, subMesh, useInstances) {
      }
      _prepareShadowDefines(subMesh, useInstances, defines, isTransparent) {
        defines.push("#define SM_LIGHTTYPE_" + this._light.getClassName().toUpperCase());
        defines.push("#define SM_FLOAT " + (this._textureType !== 0 ? "1" : "0"));
        defines.push("#define SM_ESM " + (this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? "1" : "0"));
        defines.push("#define SM_DEPTHTEXTURE " + (this.usePercentageCloserFiltering || this.useContactHardeningShadow ? "1" : "0"));
        const mesh = subMesh.getMesh();
        defines.push("#define SM_NORMALBIAS " + (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind) ? "1" : "0"));
        defines.push("#define SM_DIRECTIONINLIGHTDATA " + (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT ? "1" : "0"));
        defines.push("#define SM_USEDISTANCE " + (this._light.needCube() ? "1" : "0"));
        defines.push("#define SM_SOFTTRANSPARENTSHADOW " + (this.enableSoftTransparentShadow && isTransparent ? "1" : "0"));
        this._isReadyCustomDefines(defines, subMesh, useInstances);
        return defines;
      }
      /**
       * Determine whether the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).
       * @param subMesh The submesh we want to render in the shadow map
       * @param useInstances Defines whether will draw in the map using instances
       * @param isTransparent Indicates that isReady is called for a transparent subMesh
       * @returns true if ready otherwise, false
       */
      isReady(subMesh, useInstances, isTransparent) {
        if (!this._shadersLoaded) {
          return false;
        }
        const material = subMesh.getMaterial(), shadowDepthWrapper = material?.shadowDepthWrapper;
        this._opacityTexture = null;
        if (!material) {
          return false;
        }
        const defines = [];
        this._prepareShadowDefines(subMesh, useInstances, defines, isTransparent);
        if (shadowDepthWrapper) {
          if (!shadowDepthWrapper.isReadyForSubMesh(subMesh, defines, this, useInstances, this._scene.getEngine().currentRenderPassId)) {
            return false;
          }
        } else {
          const subMeshEffect = subMesh._getDrawWrapper(void 0, true);
          let effect = subMeshEffect.effect;
          let cachedDefines = subMeshEffect.defines;
          const attribs = [VertexBuffer.PositionKind];
          const mesh = subMesh.getMesh();
          let useNormal = false;
          let uv1 = false;
          let uv2 = false;
          const color = false;
          if (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
            attribs.push(VertexBuffer.NormalKind);
            defines.push("#define NORMAL");
            useNormal = true;
            if (mesh.nonUniformScaling) {
              defines.push("#define NONUNIFORMSCALING");
            }
          }
          const needAlphaTesting = material.needAlphaTestingForMesh(mesh);
          if (needAlphaTesting || material.needAlphaBlendingForMesh(mesh)) {
            if (this.useOpacityTextureForTransparentShadow) {
              this._opacityTexture = material.opacityTexture;
            } else {
              this._opacityTexture = material.getAlphaTestTexture();
            }
            if (this._opacityTexture) {
              if (!this._opacityTexture.isReady()) {
                return false;
              }
              const alphaCutOff = material.alphaCutOff ?? _ShadowGenerator.DEFAULT_ALPHA_CUTOFF;
              defines.push("#define ALPHATEXTURE");
              if (needAlphaTesting) {
                defines.push(`#define ALPHATESTVALUE ${alphaCutOff}${alphaCutOff % 1 === 0 ? "." : ""}`);
              }
              if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
                attribs.push(VertexBuffer.UVKind);
                defines.push("#define UV1");
                uv1 = true;
              }
              if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
                if (this._opacityTexture.coordinatesIndex === 1) {
                  attribs.push(VertexBuffer.UV2Kind);
                  defines.push("#define UV2");
                  uv2 = true;
                }
              }
            }
          }
          const fallbacks = new EffectFallbacks();
          if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
            attribs.push(VertexBuffer.MatricesIndicesKind);
            attribs.push(VertexBuffer.MatricesWeightsKind);
            if (mesh.numBoneInfluencers > 4) {
              attribs.push(VertexBuffer.MatricesIndicesExtraKind);
              attribs.push(VertexBuffer.MatricesWeightsExtraKind);
            }
            const skeleton = mesh.skeleton;
            defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
            if (mesh.numBoneInfluencers > 0) {
              fallbacks.addCPUSkinningFallback(0, mesh);
            }
            if (skeleton.isUsingTextureForMatrices) {
              defines.push("#define BONETEXTURE");
            } else {
              defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
            }
          } else {
            defines.push("#define NUM_BONE_INFLUENCERS 0");
          }
          const numMorphInfluencers = mesh.morphTargetManager ? PrepareDefinesAndAttributesForMorphTargets(
            mesh.morphTargetManager,
            defines,
            attribs,
            mesh,
            true,
            // usePositionMorph
            useNormal,
            // useNormalMorph
            false,
            // useTangentMorph
            uv1,
            // useUVMorph
            uv2,
            // useUV2Morph
            color
            // useColorMorph
          ) : 0;
          PrepareStringDefinesForClipPlanes(material, this._scene, defines);
          if (useInstances) {
            defines.push("#define INSTANCES");
            PushAttributesForInstances(attribs);
            if (subMesh.getRenderingMesh().hasThinInstances) {
              defines.push("#define THIN_INSTANCES");
            }
          }
          if (this.customShaderOptions) {
            if (this.customShaderOptions.defines) {
              for (const define of this.customShaderOptions.defines) {
                if (defines.indexOf(define) === -1) {
                  defines.push(define);
                }
              }
            }
          }
          const bvaManager = mesh.bakedVertexAnimationManager;
          if (bvaManager && bvaManager.isEnabled) {
            defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
            if (useInstances) {
              attribs.push("bakedVertexAnimationSettingsInstanced");
            }
          }
          const join = defines.join("\n");
          if (cachedDefines !== join) {
            cachedDefines = join;
            let shaderName = "shadowMap";
            const uniforms = [
              "world",
              "mBones",
              "viewProjection",
              "diffuseMatrix",
              "lightDataSM",
              "depthValuesSM",
              "biasAndScaleSM",
              "morphTargetInfluences",
              "morphTargetCount",
              "boneTextureWidth",
              "softTransparentShadowSM",
              "morphTargetTextureInfo",
              "morphTargetTextureIndices",
              "bakedVertexAnimationSettings",
              "bakedVertexAnimationTextureSizeInverted",
              "bakedVertexAnimationTime",
              "bakedVertexAnimationTexture"
            ];
            const samplers = ["diffuseSampler", "boneSampler", "morphTargets", "bakedVertexAnimationTexture"];
            const uniformBuffers = ["Scene", "Mesh"];
            AddClipPlaneUniforms(uniforms);
            if (this.customShaderOptions) {
              shaderName = this.customShaderOptions.shaderName;
              if (this.customShaderOptions.attributes) {
                for (const attrib of this.customShaderOptions.attributes) {
                  if (attribs.indexOf(attrib) === -1) {
                    attribs.push(attrib);
                  }
                }
              }
              if (this.customShaderOptions.uniforms) {
                for (const uniform of this.customShaderOptions.uniforms) {
                  if (uniforms.indexOf(uniform) === -1) {
                    uniforms.push(uniform);
                  }
                }
              }
              if (this.customShaderOptions.samplers) {
                for (const sampler of this.customShaderOptions.samplers) {
                  if (samplers.indexOf(sampler) === -1) {
                    samplers.push(sampler);
                  }
                }
              }
            }
            const engine = this._scene.getEngine();
            effect = engine.createEffect(shaderName, {
              attributes: attribs,
              uniformsNames: uniforms,
              uniformBuffersNames: uniformBuffers,
              samplers,
              defines: join,
              fallbacks,
              onCompiled: null,
              onError: null,
              indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },
              shaderLanguage: this._shaderLanguage
            }, engine);
            subMeshEffect.setEffect(effect, cachedDefines);
          }
          if (!effect.isReady()) {
            return false;
          }
        }
        if (this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
          if (!this._blurPostProcesses || !this._blurPostProcesses.length) {
            this._initializeBlurRTTAndPostProcesses();
          }
        }
        if (this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady()) {
          return false;
        }
        if (this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady()) {
          return false;
        }
        if (this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady()) {
          return false;
        }
        return true;
      }
      /**
       * Prepare all the defines in a material relying on a shadow map at the specified light index.
       * @param defines Defines of the material we want to update
       * @param lightIndex Index of the light in the enabled light list of the material
       */
      prepareDefines(defines, lightIndex) {
        const scene = this._scene;
        const light = this._light;
        if (!scene.shadowsEnabled || !light.shadowEnabled) {
          return;
        }
        defines["SHADOW" + lightIndex] = true;
        if (this.useContactHardeningShadow) {
          defines["SHADOWPCSS" + lightIndex] = true;
          if (this._filteringQuality === _ShadowGenerator.QUALITY_LOW) {
            defines["SHADOWLOWQUALITY" + lightIndex] = true;
          } else if (this._filteringQuality === _ShadowGenerator.QUALITY_MEDIUM) {
            defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
          }
        } else if (this.usePercentageCloserFiltering) {
          defines["SHADOWPCF" + lightIndex] = true;
          if (this._filteringQuality === _ShadowGenerator.QUALITY_LOW) {
            defines["SHADOWLOWQUALITY" + lightIndex] = true;
          } else if (this._filteringQuality === _ShadowGenerator.QUALITY_MEDIUM) {
            defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
          }
        } else if (this.usePoissonSampling) {
          defines["SHADOWPOISSON" + lightIndex] = true;
        } else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {
          defines["SHADOWESM" + lightIndex] = true;
        } else if (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
          defines["SHADOWCLOSEESM" + lightIndex] = true;
        }
        if (light.needCube()) {
          defines["SHADOWCUBE" + lightIndex] = true;
        }
      }
      /**
       * Binds the shadow related information inside of an effect (information like near, far, darkness...
       * defined in the generator but impacting the effect).
       * @param lightIndex Index of the light in the enabled light list of the material owning the effect
       * @param effect The effect we are binding the information for
       */
      bindShadowLight(lightIndex, effect) {
        const light = this._light;
        const scene = this._scene;
        if (!scene.shadowsEnabled || !light.shadowEnabled) {
          return;
        }
        const camera = this._getCamera();
        const shadowMap = this.getShadowMap();
        if (!shadowMap) {
          return;
        }
        if (!light.needCube()) {
          const offset = scene.floatingOriginOffset;
          const transform = this.getTransformMatrix();
          const lightMatrix = scene.floatingOriginMode ? GetFullOffsetViewProjectionToRef(offset, this._viewMatrix, this._projectionMatrix, TmpVectors.Matrix[0]) : transform;
          effect.setMatrix("lightMatrix" + lightIndex, lightMatrix);
        }
        const shadowMapForRendering = this.getShadowMapForRendering();
        if (this._filter === _ShadowGenerator.FILTER_PCF) {
          effect.setDepthStencilTexture("shadowTexture" + lightIndex, shadowMapForRendering);
          light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), shadowMap.getSize().width, 1 / shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
        } else if (this._filter === _ShadowGenerator.FILTER_PCSS) {
          effect.setDepthStencilTexture("shadowTexture" + lightIndex, shadowMapForRendering);
          effect.setTexture("depthTexture" + lightIndex, shadowMapForRendering);
          light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / shadowMap.getSize().width, this._contactHardeningLightSizeUVRatio * shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
        } else {
          effect.setTexture("shadowTexture" + lightIndex, shadowMapForRendering);
          light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), this.blurScale / shadowMap.getSize().width, this.depthScale, this.frustumEdgeFalloff, lightIndex);
        }
        light._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);
      }
      /**
       * Gets the view matrix used to render the shadow map.
       */
      get viewMatrix() {
        return this._viewMatrix;
      }
      /**
       * Gets the projection matrix used to render the shadow map.
       */
      get projectionMatrix() {
        return this._projectionMatrix;
      }
      /**
       * Gets the transformation matrix used to project the meshes into the map from the light point of view.
       * (eq to shadow projection matrix * light transform matrix)
       * @returns The transform matrix used to create the shadow map
       */
      getTransformMatrix() {
        const scene = this._scene;
        if (this._currentRenderId === scene.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex) {
          return this._transformMatrix;
        }
        this._currentRenderId = scene.getRenderId();
        this._currentFaceIndexCache = this._currentFaceIndex;
        let lightPosition = this._light.position;
        if (this._light.computeTransformedInformation()) {
          lightPosition = this._light.transformedPosition;
        }
        Vector3.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection);
        if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1) {
          this._lightDirection.z = 1e-13;
        }
        if (this._light.needProjectionMatrixCompute() || !this._cachedPosition || !this._cachedDirection || !lightPosition.equals(this._cachedPosition) || !this._lightDirection.equals(this._cachedDirection)) {
          this._cachedPosition.copyFrom(lightPosition);
          this._cachedDirection.copyFrom(this._lightDirection);
          Matrix.LookAtLHToRef(lightPosition, lightPosition.add(this._lightDirection), Vector3.Up(), this._viewMatrix);
          const shadowMap = this.getShadowMap();
          if (shadowMap) {
            const renderList = shadowMap.renderList;
            if (renderList) {
              this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, renderList);
            }
          }
          this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
        }
        return this._transformMatrix;
      }
      /**
       * Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
       * Cube and 2D textures for instance.
       */
      recreateShadowMap() {
        const shadowMap = this._shadowMap;
        if (!shadowMap) {
          return;
        }
        const renderList = shadowMap.renderList;
        this._disposeRTTandPostProcesses();
        this._initializeGenerator();
        this.filter = this._filter;
        this._applyFilterValues();
        if (renderList) {
          if (!this._shadowMap.renderList) {
            this._shadowMap.renderList = [];
          }
          for (const mesh of renderList) {
            this._shadowMap.renderList.push(mesh);
          }
        } else {
          this._shadowMap.renderList = null;
        }
      }
      _disposeBlurPostProcesses() {
        if (this._shadowMap2) {
          this._shadowMap2.dispose();
          this._shadowMap2 = null;
        }
        if (this._boxBlurPostprocess) {
          this._boxBlurPostprocess.dispose();
          this._boxBlurPostprocess = null;
        }
        if (this._kernelBlurXPostprocess) {
          this._kernelBlurXPostprocess.dispose();
          this._kernelBlurXPostprocess = null;
        }
        if (this._kernelBlurYPostprocess) {
          this._kernelBlurYPostprocess.dispose();
          this._kernelBlurYPostprocess = null;
        }
        this._blurPostProcesses = [];
      }
      _disposeRTTandPostProcesses() {
        if (this._shadowMap) {
          this._shadowMap.dispose();
          this._shadowMap = null;
        }
        this._disposeBlurPostProcesses();
      }
      _disposeSceneUBOs() {
        if (this._sceneUBOs) {
          for (const ubo of this._sceneUBOs) {
            ubo.dispose();
          }
          this._sceneUBOs = [];
        }
      }
      /**
       * Disposes the ShadowGenerator.
       * Returns nothing.
       */
      dispose() {
        this._disposeRTTandPostProcesses();
        this._disposeSceneUBOs();
        if (this._light) {
          if (this._light._shadowGenerators) {
            const iterator = this._light._shadowGenerators.entries();
            for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {
              const [camera, shadowGenerator] = entry.value;
              if (shadowGenerator === this) {
                this._light._shadowGenerators.delete(camera);
              }
            }
            if (this._light._shadowGenerators.size === 0) {
              this._light._shadowGenerators = null;
            }
          }
          this._light._markMeshesAsLightDirty();
        }
        this.onBeforeShadowMapRenderMeshObservable.clear();
        this.onBeforeShadowMapRenderObservable.clear();
        this.onAfterShadowMapRenderMeshObservable.clear();
        this.onAfterShadowMapRenderObservable.clear();
      }
      /**
       * Serializes the shadow generator setup to a json object.
       * @returns The serialized JSON object
       */
      serialize() {
        const serializationObject = {};
        const shadowMap = this.getShadowMap();
        if (!shadowMap) {
          return serializationObject;
        }
        serializationObject.className = this.getClassName();
        serializationObject.lightId = this._light.id;
        serializationObject.cameraId = this._camera?.id;
        serializationObject.id = this.id;
        serializationObject.mapSize = shadowMap.getRenderSize();
        serializationObject.forceBackFacesOnly = this.forceBackFacesOnly;
        serializationObject.darkness = this.getDarkness();
        serializationObject.transparencyShadow = this._transparencyShadow;
        serializationObject.frustumEdgeFalloff = this.frustumEdgeFalloff;
        serializationObject.bias = this.bias;
        serializationObject.normalBias = this.normalBias;
        serializationObject.usePercentageCloserFiltering = this.usePercentageCloserFiltering;
        serializationObject.useContactHardeningShadow = this.useContactHardeningShadow;
        serializationObject.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio;
        serializationObject.filteringQuality = this.filteringQuality;
        serializationObject.useExponentialShadowMap = this.useExponentialShadowMap;
        serializationObject.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap;
        serializationObject.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
        serializationObject.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
        serializationObject.usePoissonSampling = this.usePoissonSampling;
        serializationObject.depthScale = this.depthScale;
        serializationObject.blurBoxOffset = this.blurBoxOffset;
        serializationObject.blurKernel = this.blurKernel;
        serializationObject.blurScale = this.blurScale;
        serializationObject.useKernelBlur = this.useKernelBlur;
        serializationObject.renderList = [];
        if (shadowMap.renderList) {
          for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {
            const mesh = shadowMap.renderList[meshIndex];
            serializationObject.renderList.push(mesh.id);
          }
        }
        return serializationObject;
      }
      /**
       * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
       * @param parsedShadowGenerator The JSON object to parse
       * @param scene The scene to create the shadow map for
       * @param constr A function that builds a shadow generator or undefined to create an instance of the default shadow generator
       * @returns The parsed shadow generator
       */
      static Parse(parsedShadowGenerator, scene, constr) {
        const light = scene.getLightById(parsedShadowGenerator.lightId);
        const camera = parsedShadowGenerator.cameraId !== void 0 ? scene.getCameraById(parsedShadowGenerator.cameraId) : null;
        const shadowGenerator = constr ? constr(parsedShadowGenerator.mapSize, light, camera) : new _ShadowGenerator(parsedShadowGenerator.mapSize, light, void 0, camera);
        const shadowMap = shadowGenerator.getShadowMap();
        if (parsedShadowGenerator.renderList.length && shadowMap) {
          const renderSet = new Set(parsedShadowGenerator.renderList);
          let renderList = shadowMap.renderList;
          if (!renderList) {
            renderList = shadowMap.renderList = [];
          }
          const meshes = scene.meshes;
          for (const mesh of meshes) {
            if (renderSet.has(mesh.id)) {
              renderList.push(mesh);
            }
          }
        }
        if (parsedShadowGenerator.id !== void 0) {
          shadowGenerator.id = parsedShadowGenerator.id;
        }
        shadowGenerator.forceBackFacesOnly = !!parsedShadowGenerator.forceBackFacesOnly;
        if (parsedShadowGenerator.darkness !== void 0) {
          shadowGenerator.setDarkness(parsedShadowGenerator.darkness);
        }
        if (parsedShadowGenerator.transparencyShadow) {
          shadowGenerator.setTransparencyShadow(true);
        }
        if (parsedShadowGenerator.frustumEdgeFalloff !== void 0) {
          shadowGenerator.frustumEdgeFalloff = parsedShadowGenerator.frustumEdgeFalloff;
        }
        if (parsedShadowGenerator.bias !== void 0) {
          shadowGenerator.bias = parsedShadowGenerator.bias;
        }
        if (parsedShadowGenerator.normalBias !== void 0) {
          shadowGenerator.normalBias = parsedShadowGenerator.normalBias;
        }
        if (parsedShadowGenerator.usePercentageCloserFiltering) {
          shadowGenerator.usePercentageCloserFiltering = true;
        } else if (parsedShadowGenerator.useContactHardeningShadow) {
          shadowGenerator.useContactHardeningShadow = true;
        } else if (parsedShadowGenerator.usePoissonSampling) {
          shadowGenerator.usePoissonSampling = true;
        } else if (parsedShadowGenerator.useExponentialShadowMap) {
          shadowGenerator.useExponentialShadowMap = true;
        } else if (parsedShadowGenerator.useBlurExponentialShadowMap) {
          shadowGenerator.useBlurExponentialShadowMap = true;
        } else if (parsedShadowGenerator.useCloseExponentialShadowMap) {
          shadowGenerator.useCloseExponentialShadowMap = true;
        } else if (parsedShadowGenerator.useBlurCloseExponentialShadowMap) {
          shadowGenerator.useBlurCloseExponentialShadowMap = true;
        } else if (parsedShadowGenerator.useVarianceShadowMap) {
          shadowGenerator.useExponentialShadowMap = true;
        } else if (parsedShadowGenerator.useBlurVarianceShadowMap) {
          shadowGenerator.useBlurExponentialShadowMap = true;
        }
        if (parsedShadowGenerator.contactHardeningLightSizeUVRatio !== void 0) {
          shadowGenerator.contactHardeningLightSizeUVRatio = parsedShadowGenerator.contactHardeningLightSizeUVRatio;
        }
        if (parsedShadowGenerator.filteringQuality !== void 0) {
          shadowGenerator.filteringQuality = parsedShadowGenerator.filteringQuality;
        }
        if (parsedShadowGenerator.depthScale) {
          shadowGenerator.depthScale = parsedShadowGenerator.depthScale;
        }
        if (parsedShadowGenerator.blurScale) {
          shadowGenerator.blurScale = parsedShadowGenerator.blurScale;
        }
        if (parsedShadowGenerator.blurBoxOffset) {
          shadowGenerator.blurBoxOffset = parsedShadowGenerator.blurBoxOffset;
        }
        if (parsedShadowGenerator.useKernelBlur) {
          shadowGenerator.useKernelBlur = parsedShadowGenerator.useKernelBlur;
        }
        if (parsedShadowGenerator.blurKernel) {
          shadowGenerator.blurKernel = parsedShadowGenerator.blurKernel;
        }
        return shadowGenerator;
      }
    };
    ShadowGenerator.CLASSNAME = "ShadowGenerator";
    ShadowGenerator.ForceGLSL = false;
    ShadowGenerator.FILTER_NONE = 0;
    ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP = 1;
    ShadowGenerator.FILTER_POISSONSAMPLING = 2;
    ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP = 3;
    ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP = 4;
    ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5;
    ShadowGenerator.FILTER_PCF = 6;
    ShadowGenerator.FILTER_PCSS = 7;
    ShadowGenerator.QUALITY_HIGH = 0;
    ShadowGenerator.QUALITY_MEDIUM = 1;
    ShadowGenerator.QUALITY_LOW = 2;
    ShadowGenerator.DEFAULT_ALPHA_CUTOFF = 0.5;
    ShadowGenerator._SceneComponentInitialization = (_) => {
      throw _WarnImport("ShadowGeneratorSceneComponent");
    };
  }
});

// node_modules/@babylonjs/core/Rendering/depthRenderer.js
var DepthRenderer;
var init_depthRenderer = __esm({
  "node_modules/@babylonjs/core/Rendering/depthRenderer.js"() {
    init_math_color();
    init_buffer();
    init_texture();
    init_renderTargetTexture();
    init_camera();
    init_depth_fragment();
    init_depth_vertex();
    init_devTools();
    init_clipPlaneMaterialHelper();
    init_materialHelper_functions();
    init_effectFallbacks();
    DepthRenderer = class _DepthRenderer {
      /**
       * Gets the shader language used in this material.
       */
      get shaderLanguage() {
        return this._shaderLanguage;
      }
      /**
       * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer
       * @param mesh mesh or array of meshes
       * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.
       */
      setMaterialForRendering(mesh, material) {
        this._depthMap.setMaterialForRendering(mesh, material);
      }
      /**
       * Instantiates a depth renderer
       * @param scene The scene the renderer belongs to
       * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)
       * @param camera The camera to be used to render the depth map (default: scene's active camera)
       * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z
       * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...) (default: TRILINEAR_SAMPLINGMODE)
       * @param storeCameraSpaceZ Defines whether the depth stored is the Z coordinate in camera space. If true, storeNonLinearDepth has no effect. (Default: false)
       * @param name Name of the render target (default: DepthRenderer)
       * @param existingRenderTargetTexture An existing render target texture to use (default: undefined). If not provided, a new render target texture will be created.
       */
      constructor(scene, type = 1, camera = null, storeNonLinearDepth = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, storeCameraSpaceZ = false, name13, existingRenderTargetTexture) {
        this._shaderLanguage = 0;
        this.enabled = true;
        this.forceDepthWriteTransparentMeshes = false;
        this.useOnlyInActiveCamera = false;
        this.reverseCulling = false;
        this._shadersLoaded = false;
        this._scene = scene;
        this._storeNonLinearDepth = storeNonLinearDepth;
        this._storeCameraSpaceZ = storeCameraSpaceZ;
        this.isPacked = type === 0;
        if (this.isPacked) {
          this.clearColor = new Color4(1, 1, 1, 1);
        } else {
          this.clearColor = new Color4(storeCameraSpaceZ ? 0 : 1, 0, 0, 1);
        }
        this._initShaderSourceAsync();
        _DepthRenderer._SceneComponentInitialization(this._scene);
        const engine = scene.getEngine();
        this._camera = camera;
        if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {
          if (type === 1 && !engine._caps.textureFloatLinearFiltering) {
            samplingMode = Texture.NEAREST_SAMPLINGMODE;
          }
          if (type === 2 && !engine._caps.textureHalfFloatLinearFiltering) {
            samplingMode = Texture.NEAREST_SAMPLINGMODE;
          }
        }
        const format = this.isPacked || !engine._features.supportExtendedTextureFormats ? 5 : 6;
        this._depthMap = existingRenderTargetTexture ?? new RenderTargetTexture(name13 ?? "DepthRenderer", { width: engine.getRenderWidth(), height: engine.getRenderHeight() }, this._scene, false, true, type, false, samplingMode, void 0, void 0, void 0, format);
        this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._depthMap.refreshRate = 1;
        this._depthMap.renderParticles = false;
        this._depthMap.renderList = null;
        this._depthMap.noPrePassRenderer = true;
        this._depthMap.activeCamera = this._camera;
        this._depthMap.ignoreCameraViewport = true;
        this._depthMap.useCameraPostProcesses = false;
        this._depthMap.onClearObservable.add((engine2) => {
          engine2.clear(this.clearColor, true, true, true);
        });
        this._depthMap.onBeforeBindObservable.add(() => {
          if (engine._enableGPUDebugMarkers) {
            engine.restoreDefaultFramebuffer();
            engine._debugPushGroup?.(`Depth renderer`);
          }
        });
        this._depthMap.onAfterUnbindObservable.add(() => {
          if (engine._enableGPUDebugMarkers) {
            engine._debugPopGroup?.();
          }
        });
        this._depthMap.customIsReadyFunction = (mesh, refreshRate, preWarm) => {
          if ((preWarm || refreshRate === 0) && mesh.subMeshes) {
            for (let i = 0; i < mesh.subMeshes.length; ++i) {
              const subMesh = mesh.subMeshes[i];
              const renderingMesh = subMesh.getRenderingMesh();
              const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
              const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
              if (!this.isReady(subMesh, hardwareInstancedRendering)) {
                return false;
              }
            }
          }
          return true;
        };
        const renderSubMesh = (subMesh) => {
          const renderingMesh = subMesh.getRenderingMesh();
          const effectiveMesh = subMesh.getEffectiveMesh();
          const scene2 = this._scene;
          const engine2 = scene2.getEngine();
          const material = subMesh.getMaterial();
          effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
          if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene2.getRenderId()) {
            return;
          }
          const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;
          let sideOrientation = material._getEffectiveOrientation(renderingMesh);
          if (detNeg) {
            sideOrientation = sideOrientation === 0 ? 1 : 0;
          }
          const reverseSideOrientation = sideOrientation === 0;
          engine2.setState(material.backFaceCulling, 0, false, reverseSideOrientation, this.reverseCulling ? !material.cullBackFaces : material.cullBackFaces);
          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
          if (batch.mustReturn) {
            return;
          }
          const hardwareInstancedRendering = engine2.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
          const camera2 = this._camera || scene2.activeCamera;
          if (this.isReady(subMesh, hardwareInstancedRendering) && camera2) {
            subMesh._renderId = scene2.getRenderId();
            let renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine2.currentRenderPassId];
            if (renderingMaterial === void 0 && effectiveMesh.getClassName() === "GaussianSplattingMesh") {
              const gsMaterial = effectiveMesh.material;
              renderingMaterial = gsMaterial.makeDepthRenderingMaterial(this._scene, this._shaderLanguage);
              this.setMaterialForRendering(effectiveMesh, renderingMaterial);
              if (!renderingMaterial.isReady()) {
                return;
              }
            }
            let drawWrapper = subMesh._getDrawWrapper();
            if (!drawWrapper && renderingMaterial) {
              drawWrapper = renderingMaterial._getDrawWrapper();
            }
            const cameraIsOrtho = camera2.mode === Camera.ORTHOGRAPHIC_CAMERA;
            if (!drawWrapper) {
              return;
            }
            const effect = drawWrapper.effect;
            engine2.enableEffect(drawWrapper);
            if (!hardwareInstancedRendering) {
              renderingMesh._bind(subMesh, effect, material.fillMode);
            }
            if (!renderingMaterial) {
              effect.setMatrix("viewProjection", scene2.getTransformMatrix());
              effect.setMatrix("world", effectiveMesh.getWorldMatrix());
              if (this._storeCameraSpaceZ) {
                effect.setMatrix("view", scene2.getViewMatrix());
              }
            } else {
              renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);
            }
            let minZ, maxZ;
            if (cameraIsOrtho) {
              minZ = !engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : 1;
              maxZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : 1;
            } else {
              minZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? camera2.minZ : engine2.isNDCHalfZRange ? 0 : camera2.minZ;
              maxZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : camera2.maxZ;
            }
            effect.setFloat2("depthValues", minZ, minZ + maxZ);
            if (!renderingMaterial) {
              if (material.needAlphaTestingForMesh(effectiveMesh)) {
                const alphaTexture = material.getAlphaTestTexture();
                if (alphaTexture) {
                  effect.setTexture("diffuseSampler", alphaTexture);
                  effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
                }
              }
              BindBonesParameters(renderingMesh, effect);
              BindClipPlane(effect, material, scene2);
              BindMorphTargetParameters(renderingMesh, effect);
              if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
                renderingMesh.morphTargetManager._bind(effect);
              }
              const bvaManager = subMesh.getMesh().bakedVertexAnimationManager;
              if (bvaManager && bvaManager.isEnabled) {
                bvaManager.bind(effect, hardwareInstancedRendering);
              }
              if (material.pointsCloud) {
                effect.setFloat("pointSize", material.pointSize);
              }
            }
            renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => effect.setMatrix("world", world));
          }
        };
        this._depthMap.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {
          let index;
          if (depthOnlySubMeshes.length) {
            for (index = 0; index < depthOnlySubMeshes.length; index++) {
              renderSubMesh(depthOnlySubMeshes.data[index]);
            }
          }
          for (index = 0; index < opaqueSubMeshes.length; index++) {
            renderSubMesh(opaqueSubMeshes.data[index]);
          }
          for (index = 0; index < alphaTestSubMeshes.length; index++) {
            renderSubMesh(alphaTestSubMeshes.data[index]);
          }
          if (this.forceDepthWriteTransparentMeshes) {
            for (index = 0; index < transparentSubMeshes.length; index++) {
              renderSubMesh(transparentSubMeshes.data[index]);
            }
          } else {
            for (index = 0; index < transparentSubMeshes.length; index++) {
              transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;
            }
          }
        };
      }
      async _initShaderSourceAsync(forceGLSL = false) {
        const engine = this._scene.getEngine();
        if (engine.isWebGPU && !forceGLSL && !_DepthRenderer.ForceGLSL) {
          this._shaderLanguage = 1;
          await Promise.all([import("./depth.vertex-6J4UBO65.js"), import("./depth.fragment-LKYFLLD4.js")]);
        } else {
          await Promise.all([import("./depth.vertex-EGM2HWOJ.js"), import("./depth.fragment-AZIMBRUV.js")]);
        }
        this._shadersLoaded = true;
      }
      /**
       * Creates the depth rendering effect and checks if the effect is ready.
       * @param subMesh The submesh to be used to render the depth map of
       * @param useInstances If multiple world instances should be used
       * @returns if the depth renderer is ready to render the depth map
       */
      isReady(subMesh, useInstances) {
        if (!this._shadersLoaded) {
          return false;
        }
        const engine = this._scene.getEngine();
        const mesh = subMesh.getMesh();
        const scene = mesh.getScene();
        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];
        if (renderingMaterial) {
          return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);
        }
        const material = subMesh.getMaterial();
        if (!material || material.disableDepthWrite) {
          return false;
        }
        const defines = [];
        const attribs = [VertexBuffer.PositionKind];
        let uv1 = false;
        let uv2 = false;
        const color = false;
        if (material.needAlphaTestingForMesh(mesh) && material.getAlphaTestTexture()) {
          defines.push("#define ALPHATEST");
          if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
            attribs.push(VertexBuffer.UVKind);
            defines.push("#define UV1");
            uv1 = true;
          }
          if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
            attribs.push(VertexBuffer.UV2Kind);
            defines.push("#define UV2");
            uv2 = true;
          }
        }
        const fallbacks = new EffectFallbacks();
        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
          attribs.push(VertexBuffer.MatricesIndicesKind);
          attribs.push(VertexBuffer.MatricesWeightsKind);
          if (mesh.numBoneInfluencers > 4) {
            attribs.push(VertexBuffer.MatricesIndicesExtraKind);
            attribs.push(VertexBuffer.MatricesWeightsExtraKind);
          }
          defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
          if (mesh.numBoneInfluencers > 0) {
            fallbacks.addCPUSkinningFallback(0, mesh);
          }
          const skeleton = mesh.skeleton;
          if (skeleton.isUsingTextureForMatrices) {
            defines.push("#define BONETEXTURE");
          } else {
            defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
          }
        } else {
          defines.push("#define NUM_BONE_INFLUENCERS 0");
        }
        const numMorphInfluencers = mesh.morphTargetManager ? PrepareDefinesAndAttributesForMorphTargets(
          mesh.morphTargetManager,
          defines,
          attribs,
          mesh,
          true,
          // usePositionMorph
          false,
          // useNormalMorph
          false,
          // useTangentMorph
          uv1,
          // useUVMorph
          uv2,
          // useUV2Morph
          color
          // useColorMorph
        ) : 0;
        if (material.pointsCloud) {
          defines.push("#define POINTSIZE");
        }
        if (useInstances) {
          defines.push("#define INSTANCES");
          PushAttributesForInstances(attribs);
          if (subMesh.getRenderingMesh().hasThinInstances) {
            defines.push("#define THIN_INSTANCES");
          }
        }
        const bvaManager = mesh.bakedVertexAnimationManager;
        if (bvaManager && bvaManager.isEnabled) {
          defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
          if (useInstances) {
            attribs.push("bakedVertexAnimationSettingsInstanced");
          }
        }
        if (this._storeNonLinearDepth) {
          defines.push("#define NONLINEARDEPTH");
        }
        if (this._storeCameraSpaceZ) {
          defines.push("#define STORE_CAMERASPACE_Z");
        }
        if (this.isPacked) {
          defines.push("#define PACKED");
        }
        PrepareStringDefinesForClipPlanes(material, scene, defines);
        const drawWrapper = subMesh._getDrawWrapper(void 0, true);
        const cachedDefines = drawWrapper.defines;
        const join = defines.join("\n");
        if (cachedDefines !== join) {
          const uniforms = [
            "world",
            "mBones",
            "boneTextureWidth",
            "pointSize",
            "viewProjection",
            "view",
            "diffuseMatrix",
            "depthValues",
            "morphTargetInfluences",
            "morphTargetCount",
            "morphTargetTextureInfo",
            "morphTargetTextureIndices",
            "bakedVertexAnimationSettings",
            "bakedVertexAnimationTextureSizeInverted",
            "bakedVertexAnimationTime",
            "bakedVertexAnimationTexture"
          ];
          const samplers = ["diffuseSampler", "morphTargets", "boneSampler", "bakedVertexAnimationTexture"];
          AddClipPlaneUniforms(uniforms);
          drawWrapper.setEffect(engine.createEffect("depth", {
            attributes: attribs,
            uniformsNames: uniforms,
            uniformBuffersNames: [],
            samplers,
            defines: join,
            fallbacks,
            onCompiled: null,
            onError: null,
            indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },
            shaderLanguage: this._shaderLanguage
          }, engine), join);
        }
        return drawWrapper.effect.isReady();
      }
      /**
       * Gets the texture which the depth map will be written to.
       * @returns The depth map texture
       */
      getDepthMap() {
        return this._depthMap;
      }
      /**
       * Disposes of the depth renderer.
       */
      dispose() {
        const keysToDelete = [];
        for (const key in this._scene._depthRenderer) {
          const depthRenderer = this._scene._depthRenderer[key];
          if (depthRenderer === this) {
            keysToDelete.push(key);
          }
        }
        if (keysToDelete.length > 0) {
          this._depthMap.dispose();
          for (const key of keysToDelete) {
            delete this._scene._depthRenderer[key];
          }
        }
      }
    };
    DepthRenderer.ForceGLSL = false;
    DepthRenderer._SceneComponentInitialization = (_) => {
      throw _WarnImport("DepthRendererSceneComponent");
    };
  }
});

// node_modules/@babylonjs/core/Misc/thinMinMaxReducer.js
var DepthTextureType, ThinMinMaxReducerPostProcess, BufferFloat, BufferUint8, MinMax, ThinMinMaxReducer;
var init_thinMinMaxReducer = __esm({
  "node_modules/@babylonjs/core/Misc/thinMinMaxReducer.js"() {
    init_observable();
    init_effectRenderer();
    init_engine();
    (function(DepthTextureType2) {
      DepthTextureType2[DepthTextureType2["NormalizedViewDepth"] = 0] = "NormalizedViewDepth";
      DepthTextureType2[DepthTextureType2["ViewDepth"] = 1] = "ViewDepth";
      DepthTextureType2[DepthTextureType2["ScreenDepth"] = 2] = "ScreenDepth";
    })(DepthTextureType || (DepthTextureType = {}));
    ThinMinMaxReducerPostProcess = class _ThinMinMaxReducerPostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(import("./minmaxRedux.fragment-OVK5FGNX.js"));
        } else {
          list.push(import("./minmaxRedux.fragment-LOIXQVEA.js"));
        }
      }
      constructor(name13, engine = null, defines = "", options) {
        super({
          ...options,
          name: name13,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinMinMaxReducerPostProcess.FragmentUrl,
          uniforms: _ThinMinMaxReducerPostProcess.Uniforms,
          defines
        });
        this.textureWidth = 0;
        this.textureHeight = 0;
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        const effect = this.drawWrapper.effect;
        if (this.textureWidth === 1 || this.textureHeight === 1) {
          effect.setInt2("texSize", this.textureWidth, this.textureHeight);
        } else {
          effect.setFloat2("texSize", this.textureWidth, this.textureHeight);
        }
      }
    };
    ThinMinMaxReducerPostProcess.FragmentUrl = "minmaxRedux";
    ThinMinMaxReducerPostProcess.Uniforms = ["texSize"];
    BufferFloat = new Float32Array(4 * 1 * 1);
    BufferUint8 = new Uint8Array(4 * 1 * 1);
    MinMax = { min: 0, max: 0 };
    ThinMinMaxReducer = class {
      get depthRedux() {
        return this._depthRedux;
      }
      set depthRedux(value) {
        if (this._depthRedux === value) {
          return;
        }
        this._depthRedux = value;
        this._recreatePostProcesses();
      }
      get textureWidth() {
        return this._textureWidth;
      }
      get textureHeight() {
        return this._textureHeight;
      }
      constructor(scene, depthRedux = true) {
        this.onAfterReductionPerformed = new Observable();
        this._textureWidth = 0;
        this._textureHeight = 0;
        this._scene = scene;
        this._depthRedux = depthRedux;
        this.reductionSteps = [];
      }
      setTextureDimensions(width, height, depthTextureType = 0) {
        if (width === this._textureWidth && height === this._textureHeight && depthTextureType === this._depthTextureType) {
          return false;
        }
        this._textureWidth = width;
        this._textureHeight = height;
        this._depthTextureType = depthTextureType;
        this._recreatePostProcesses();
        return true;
      }
      readMinMax(texture) {
        const isFloat = texture.type === Engine.TEXTURETYPE_FLOAT || texture.type === Engine.TEXTURETYPE_HALF_FLOAT;
        const buffer = isFloat ? BufferFloat : BufferUint8;
        this._scene.getEngine()._readTexturePixels(texture, 1, 1, -1, 0, buffer, false);
        MinMax.min = buffer[0];
        MinMax.max = buffer[1];
        if (!isFloat) {
          MinMax.min = MinMax.min / 255;
          MinMax.max = MinMax.max / 255;
        }
        if (MinMax.min >= MinMax.max) {
          MinMax.min = 0;
          MinMax.max = 1;
        }
        this.onAfterReductionPerformed.notifyObservers(MinMax);
      }
      dispose(disposeAll = true) {
        if (disposeAll) {
          this.onAfterReductionPerformed.clear();
          this._textureWidth = 0;
          this._textureHeight = 0;
        }
        for (let i = 0; i < this.reductionSteps.length; ++i) {
          this.reductionSteps[i].dispose();
        }
        this.reductionSteps.length = 0;
      }
      _recreatePostProcesses() {
        this.dispose(false);
        const scene = this._scene;
        let w = this.textureWidth, h = this.textureHeight;
        const reductionInitial = new ThinMinMaxReducerPostProcess("Initial reduction phase", scene.getEngine(), "#define INITIAL" + (this._depthRedux ? "\n#define DEPTH_REDUX" : "") + (this._depthTextureType === 1 ? "\n#define VIEW_DEPTH" : ""));
        reductionInitial.textureWidth = w;
        reductionInitial.textureHeight = h;
        this.reductionSteps.push(reductionInitial);
        let index = 1;
        while (w > 1 || h > 1) {
          w = Math.max(Math.round(w / 2), 1);
          h = Math.max(Math.round(h / 2), 1);
          const reduction = new ThinMinMaxReducerPostProcess("Reduction phase " + index, scene.getEngine(), "#define " + (w == 1 && h == 1 ? "LAST" : w == 1 || h == 1 ? "ONEBEFORELAST" : "MAIN"));
          reduction.textureWidth = w;
          reduction.textureHeight = h;
          this.reductionSteps.push(reduction);
          index++;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/minMaxReducer.js
var MinMaxReducer;
var init_minMaxReducer = __esm({
  "node_modules/@babylonjs/core/Misc/minMaxReducer.js"() {
    init_postProcess();
    init_postProcessManager();
    init_thinMinMaxReducer();
    init_minmaxRedux_fragment2();
    init_minmaxRedux_fragment();
    MinMaxReducer = class {
      /**
       * Observable triggered when the computation has been performed
       */
      get onAfterReductionPerformed() {
        return this._thinMinMaxReducer.onAfterReductionPerformed;
      }
      /**
       * Creates a min/max reducer
       * @param camera The camera to use for the post processes
       */
      constructor(camera) {
        this._onAfterUnbindObserver = null;
        this._forceFullscreenViewport = true;
        this._activated = false;
        this._camera = camera;
        this._postProcessManager = new PostProcessManager(camera.getScene());
        this._thinMinMaxReducer = new ThinMinMaxReducer(camera.getScene());
        this._reductionSteps = [];
        this._onContextRestoredObserver = camera.getEngine().onContextRestoredObservable.add(() => {
          this._postProcessManager._rebuild();
        });
      }
      /**
       * Gets the texture used to read the values from.
       */
      get sourceTexture() {
        return this._sourceTexture;
      }
      /**
       * Sets the source texture to read the values from.
       * One must indicate if the texture is a depth texture or not through the depthRedux parameter
       * because in such textures '1' value must not be taken into account to compute the maximum
       * as this value is used to clear the texture.
       * Note that the computation is not activated by calling this function, you must call activate() for that!
       * @param sourceTexture The texture to read the values from. The values should be in the red channel.
       * @param depthRedux Indicates if the texture is a depth texture or not
       * @param type The type of the textures created for the reduction (defaults to TEXTURETYPE_HALF_FLOAT)
       * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)
       */
      setSourceTexture(sourceTexture, depthRedux, type = 2, forceFullscreenViewport = true) {
        if (sourceTexture === this._sourceTexture) {
          return;
        }
        this._thinMinMaxReducer.depthRedux = depthRedux;
        this.deactivate();
        this._sourceTexture = sourceTexture;
        this._forceFullscreenViewport = forceFullscreenViewport;
        if (this._thinMinMaxReducer.setTextureDimensions(sourceTexture.getRenderWidth(), sourceTexture.getRenderHeight())) {
          this._disposePostProcesses();
          const reductionSteps = this._thinMinMaxReducer.reductionSteps;
          for (let i = 0; i < reductionSteps.length; ++i) {
            const reductionStep = reductionSteps[i];
            const postProcess = new PostProcess(reductionStep.name, ThinMinMaxReducerPostProcess.FragmentUrl, {
              effectWrapper: reductionStep,
              samplingMode: 1,
              engine: this._camera.getScene().getEngine(),
              textureType: type,
              textureFormat: 7,
              size: { width: reductionStep.textureWidth, height: reductionStep.textureHeight }
            });
            this._reductionSteps.push(postProcess);
            postProcess.autoClear = false;
            postProcess.forceFullscreenViewport = forceFullscreenViewport;
            if (i === 0) {
              postProcess.externalTextureSamplerBinding = true;
              postProcess.onApplyObservable.add((effect) => {
                effect.setTexture("textureSampler", this._sourceTexture);
              });
            }
            if (i === reductionSteps.length - 1) {
              this._reductionSteps[i - 1].onAfterRenderObservable.add(() => {
                this._thinMinMaxReducer.readMinMax(postProcess.inputTexture.texture);
              });
            }
          }
        }
      }
      /**
       * Defines the refresh rate of the computation.
       * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...
       */
      get refreshRate() {
        return this._sourceTexture ? this._sourceTexture.refreshRate : -1;
      }
      set refreshRate(value) {
        if (this._sourceTexture) {
          this._sourceTexture.refreshRate = value;
        }
      }
      /**
       * Gets the activation status of the reducer
       */
      get activated() {
        return this._activated;
      }
      /**
       * Activates the reduction computation.
       * When activated, the observers registered in onAfterReductionPerformed are
       * called after the computation is performed
       */
      activate() {
        if (this._onAfterUnbindObserver || !this._sourceTexture) {
          return;
        }
        this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(() => {
          const engine = this._camera.getScene().getEngine();
          engine._debugPushGroup?.(`min max reduction`);
          this._reductionSteps[0].activate(this._camera);
          this._postProcessManager.directRender(this._reductionSteps, this._reductionSteps[0].inputTexture, this._forceFullscreenViewport, 0, 0, true, this._reductionSteps.length - 1);
          engine.unBindFramebuffer(this._reductionSteps[this._reductionSteps.length - 1].inputTexture, false);
          engine._debugPopGroup?.();
        });
        this._activated = true;
      }
      /**
       * Deactivates the reduction computation.
       */
      deactivate() {
        if (!this._onAfterUnbindObserver || !this._sourceTexture) {
          return;
        }
        this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);
        this._onAfterUnbindObserver = null;
        this._activated = false;
      }
      /**
       * Disposes the min/max reducer
       * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.
       */
      dispose(disposeAll = true) {
        if (!disposeAll) {
          return;
        }
        this.onAfterReductionPerformed.clear();
        this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
        this._onContextRestoredObserver = void 0;
        this._disposePostProcesses();
        this._postProcessManager.dispose();
        this._postProcessManager = void 0;
        this._thinMinMaxReducer.dispose();
        this._thinMinMaxReducer = void 0;
        this._sourceTexture = null;
      }
      _disposePostProcesses() {
        for (let i = 0; i < this._reductionSteps.length; ++i) {
          this._reductionSteps[i].dispose();
        }
        this._reductionSteps.length = 0;
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/depthReducer.js
var DepthReducer;
var init_depthReducer = __esm({
  "node_modules/@babylonjs/core/Misc/depthReducer.js"() {
    init_depthRenderer();
    init_minMaxReducer();
    DepthReducer = class extends MinMaxReducer {
      /**
       * Gets the depth renderer used for the computation.
       * Note that the result is null if you provide your own renderer when calling setDepthRenderer.
       */
      get depthRenderer() {
        return this._depthRenderer;
      }
      /**
       * Creates a depth reducer
       * @param camera The camera used to render the depth texture
       */
      constructor(camera) {
        super(camera);
      }
      /**
       * Sets the depth renderer to use to generate the depth map
       * @param depthRenderer The depth renderer to use. If not provided, a new one will be created automatically
       * @param type The texture type of the depth map (default: TEXTURETYPE_HALF_FLOAT)
       * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)
       */
      setDepthRenderer(depthRenderer = null, type = 2, forceFullscreenViewport = true) {
        const scene = this._camera.getScene();
        if (this._depthRenderer) {
          delete scene._depthRenderer[this._depthRendererId];
          this._depthRenderer.dispose();
          this._depthRenderer = null;
        }
        if (depthRenderer === null) {
          if (!scene._depthRenderer) {
            scene._depthRenderer = {};
          }
          this._depthRendererId = "minmax_" + this._camera.id;
          depthRenderer = this._depthRenderer = new DepthRenderer(scene, type, this._camera, false, 1, false, `DepthRenderer ${this._depthRendererId}`);
          depthRenderer.enabled = false;
          scene._depthRenderer[this._depthRendererId] = depthRenderer;
        }
        super.setSourceTexture(depthRenderer.getDepthMap(), true, type, forceFullscreenViewport);
      }
      /**
       * @internal
       */
      setSourceTexture(sourceTexture, depthRedux, type = 2, forceFullscreenViewport = true) {
        super.setSourceTexture(sourceTexture, depthRedux, type, forceFullscreenViewport);
      }
      /**
       * Activates the reduction computation.
       * When activated, the observers registered in onAfterReductionPerformed are
       * called after the computation is performed
       */
      activate() {
        if (this._depthRenderer) {
          this._depthRenderer.enabled = true;
        }
        super.activate();
      }
      /**
       * Deactivates the reduction computation.
       */
      deactivate() {
        super.deactivate();
        if (this._depthRenderer) {
          this._depthRenderer.enabled = false;
        }
      }
      /**
       * Disposes the depth reducer
       * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.
       */
      dispose(disposeAll = true) {
        super.dispose(disposeAll);
        if (this._depthRenderer && disposeAll) {
          this._depthRenderer.dispose();
          this._depthRenderer = null;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Lights/Shadows/cascadedShadowGenerator.js
var UpDir, ZeroVec, Tmpv1, Tmpv2, TmpMatrix, CascadedShadowGenerator;
var init_cascadedShadowGenerator = __esm({
  "node_modules/@babylonjs/core/Lights/Shadows/cascadedShadowGenerator.js"() {
    init_math_vector();
    init_renderTargetTexture();
    init_devTools();
    init_shadowGenerator();
    init_boundingInfo();
    init_depthReducer();
    init_logger();
    init_engineStore();
    init_floatingOriginMatrixOverrides();
    UpDir = Vector3.Up();
    ZeroVec = Vector3.Zero();
    Tmpv1 = new Vector3();
    Tmpv2 = new Vector3();
    TmpMatrix = new Matrix();
    CascadedShadowGenerator = class _CascadedShadowGenerator extends ShadowGenerator {
      _validateFilter(filter) {
        if (filter === ShadowGenerator.FILTER_NONE || filter === ShadowGenerator.FILTER_PCF || filter === ShadowGenerator.FILTER_PCSS) {
          return filter;
        }
        Logger.Error('Unsupported filter "' + filter + '"!');
        return ShadowGenerator.FILTER_NONE;
      }
      /**
       * Gets or set the number of cascades used by the CSM.
       */
      get numCascades() {
        return this._numCascades;
      }
      set numCascades(value) {
        value = Math.min(Math.max(value, _CascadedShadowGenerator.MIN_CASCADES_COUNT), _CascadedShadowGenerator.MAX_CASCADES_COUNT);
        if (value === this._numCascades) {
          return;
        }
        this._numCascades = value;
        this.recreateShadowMap();
        this._recreateSceneUBOs();
      }
      /**
       * Enables or disables the shadow casters bounding info computation.
       * If your shadow casters don't move, you can disable this feature.
       * If it is enabled, the bounding box computation is done every frame.
       */
      get freezeShadowCastersBoundingInfo() {
        return this._freezeShadowCastersBoundingInfo;
      }
      set freezeShadowCastersBoundingInfo(freeze) {
        if (this._freezeShadowCastersBoundingInfoObservable && freeze) {
          this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);
          this._freezeShadowCastersBoundingInfoObservable = null;
        }
        if (!this._freezeShadowCastersBoundingInfoObservable && !freeze) {
          this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add(() => this._computeShadowCastersBoundingInfo());
        }
        this._freezeShadowCastersBoundingInfo = freeze;
        if (freeze) {
          this._computeShadowCastersBoundingInfo();
        }
      }
      _computeShadowCastersBoundingInfo() {
        this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._scbiMax.copyFromFloats(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        if (this._shadowMap && this._shadowMap.renderList) {
          const renderList = this._shadowMap.renderList;
          for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
            const mesh = renderList[meshIndex];
            if (!mesh) {
              continue;
            }
            const boundingInfo = mesh.getBoundingInfo(), boundingBox = boundingInfo.boundingBox;
            this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);
            this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);
          }
        }
        this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax);
      }
      /**
       * Gets or sets the shadow casters bounding info.
       * If you provide your own shadow casters bounding info, first enable freezeShadowCastersBoundingInfo
       * so that the system won't overwrite the bounds you provide
       */
      get shadowCastersBoundingInfo() {
        return this._shadowCastersBoundingInfo;
      }
      set shadowCastersBoundingInfo(boundingInfo) {
        this._shadowCastersBoundingInfo = boundingInfo;
      }
      /**
       * Sets the minimal and maximal distances to use when computing the cascade breaks.
       *
       * The values of min / max are typically the depth zmin and zmax values of your scene, for a given frame.
       * If you don't know these values, simply leave them to their defaults and don't call this function.
       * @param min minimal distance for the breaks (default to 0.)
       * @param max maximal distance for the breaks (default to 1.)
       */
      setMinMaxDistance(min, max) {
        if (this._minDistance === min && this._maxDistance === max) {
          return;
        }
        if (min > max) {
          min = 0;
          max = 1;
        }
        if (min < 0) {
          min = 0;
        }
        if (max > 1) {
          max = 1;
        }
        this._minDistance = min;
        this._maxDistance = max;
        this._breaksAreDirty = true;
      }
      /** Gets the minimal distance used in the cascade break computation */
      get minDistance() {
        return this._minDistance;
      }
      /** Gets the maximal distance used in the cascade break computation */
      get maxDistance() {
        return this._maxDistance;
      }
      /**
       * Gets the class name of that object
       * @returns "CascadedShadowGenerator"
       */
      getClassName() {
        return _CascadedShadowGenerator.CLASSNAME;
      }
      /**
       * Gets a cascade minimum extents
       * @param cascadeIndex index of the cascade
       * @returns the minimum cascade extents
       */
      getCascadeMinExtents(cascadeIndex) {
        return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMinExtents[cascadeIndex] : null;
      }
      /**
       * Gets a cascade maximum extents
       * @param cascadeIndex index of the cascade
       * @returns the maximum cascade extents
       */
      getCascadeMaxExtents(cascadeIndex) {
        return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMaxExtents[cascadeIndex] : null;
      }
      /**
       * Gets the shadow max z distance. It's the limit beyond which shadows are not displayed.
       * It defaults to camera.maxZ
       */
      get shadowMaxZ() {
        if (!this._getCamera()) {
          return 0;
        }
        return this._shadowMaxZ;
      }
      /**
       * Sets the shadow max z distance.
       */
      set shadowMaxZ(value) {
        const camera = this._getCamera();
        if (!camera) {
          this._shadowMaxZ = value;
          return;
        }
        if (this._shadowMaxZ === value || value < camera.minZ || value > camera.maxZ && camera.maxZ !== 0) {
          return;
        }
        this._shadowMaxZ = value;
        this._light._markMeshesAsLightDirty();
        this._breaksAreDirty = true;
      }
      /**
       * Gets or sets the debug flag.
       * When enabled, the cascades are materialized by different colors on the screen.
       */
      get debug() {
        return this._debug;
      }
      set debug(dbg) {
        this._debug = dbg;
        this._light._markMeshesAsLightDirty();
      }
      /**
       * Gets or sets the depth clamping value.
       *
       * When enabled, it improves the shadow quality because the near z plane of the light frustum don't need to be adjusted
       * to account for the shadow casters far away.
       *
       * Note that this property is incompatible with PCSS filtering, so it won't be used in that case.
       */
      get depthClamp() {
        return this._depthClamp;
      }
      set depthClamp(value) {
        this._depthClamp = value;
      }
      /**
       * Gets or sets the percentage of blending between two cascades (value between 0. and 1.).
       * It defaults to 0.1 (10% blending).
       */
      get cascadeBlendPercentage() {
        return this._cascadeBlendPercentage;
      }
      set cascadeBlendPercentage(value) {
        this._cascadeBlendPercentage = value;
        this._light._markMeshesAsLightDirty();
      }
      /**
       * Gets or set the lambda parameter.
       * This parameter is used to split the camera frustum and create the cascades.
       * It's a value between 0. and 1.: If 0, the split is a uniform split of the frustum, if 1 it is a logarithmic split.
       * For all values in-between, it's a linear combination of the uniform and logarithm split algorithm.
       */
      get lambda() {
        return this._lambda;
      }
      set lambda(value) {
        const lambda = Math.min(Math.max(value, 0), 1);
        if (this._lambda == lambda) {
          return;
        }
        this._lambda = lambda;
        this._breaksAreDirty = true;
      }
      /**
       * Gets the view matrix corresponding to a given cascade
       * @param cascadeNum cascade to retrieve the view matrix from
       * @returns the cascade view matrix
       */
      getCascadeViewMatrix(cascadeNum) {
        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._viewMatrices[cascadeNum] : null;
      }
      /**
       * Gets the projection matrix corresponding to a given cascade
       * @param cascadeNum cascade to retrieve the projection matrix from
       * @returns the cascade projection matrix
       */
      getCascadeProjectionMatrix(cascadeNum) {
        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._projectionMatrices[cascadeNum] : null;
      }
      /**
       * Gets the transformation matrix corresponding to a given cascade
       * @param cascadeNum cascade to retrieve the transformation matrix from
       * @returns the cascade transformation matrix
       */
      getCascadeTransformMatrix(cascadeNum) {
        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._transformMatrices[cascadeNum] : null;
      }
      /**
       * Sets the depth renderer to use when autoCalcDepthBounds is enabled.
       *
       * Note that if no depth renderer is set, a new one will be automatically created internally when necessary.
       *
       * You should call this function if you already have a depth renderer enabled in your scene, to avoid
       * doing multiple depth rendering each frame. If you provide your own depth renderer, make sure it stores linear depth!
       * @param depthRenderer The depth renderer to use when autoCalcDepthBounds is enabled. If you pass null or don't call this function at all, a depth renderer will be automatically created
       */
      setDepthRenderer(depthRenderer) {
        this._depthRenderer = depthRenderer;
        if (this._depthReducer) {
          this._depthReducer.setDepthRenderer(this._depthRenderer);
        }
      }
      /**
       * Gets or sets the autoCalcDepthBounds property.
       *
       * When enabled, a depth rendering pass is first performed (with an internally created depth renderer or with the one
       * you provide by calling setDepthRenderer). Then, a min/max reducing is applied on the depth map to compute the
       * minimal and maximal depth of the map and those values are used as inputs for the setMinMaxDistance() function.
       * It can greatly enhance the shadow quality, at the expense of more GPU works.
       * When using this option, you should increase the value of the lambda parameter, and even set it to 1 for best results.
       */
      get autoCalcDepthBounds() {
        return this._autoCalcDepthBounds;
      }
      set autoCalcDepthBounds(value) {
        const camera = this._getCamera();
        if (!camera) {
          return;
        }
        this._autoCalcDepthBounds = value;
        if (!value) {
          if (this._depthReducer) {
            this._depthReducer.deactivate();
          }
          this.setMinMaxDistance(0, 1);
          return;
        }
        if (!this._depthReducer) {
          this._depthReducer = new DepthReducer(camera);
          this._depthReducer.onAfterReductionPerformed.add((minmax) => {
            let min = minmax.min, max = minmax.max;
            if (min >= max) {
              min = 0;
              max = 1;
            }
            if (min != this._minDistance || max != this._maxDistance) {
              this.setMinMaxDistance(min, max);
            }
          });
          this._depthReducer.setDepthRenderer(this._depthRenderer);
        }
        this._depthReducer.activate();
      }
      /**
       * Defines the refresh rate of the min/max computation used when autoCalcDepthBounds is set to true
       * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...
       * Note that if you provided your own depth renderer through a call to setDepthRenderer, you are responsible
       * for setting the refresh rate on the renderer yourself!
       */
      get autoCalcDepthBoundsRefreshRate() {
        return this._depthReducer?.depthRenderer?.getDepthMap().refreshRate ?? -1;
      }
      set autoCalcDepthBoundsRefreshRate(value) {
        if (this._depthReducer?.depthRenderer) {
          this._depthReducer.depthRenderer.getDepthMap().refreshRate = value;
        }
      }
      /**
       * Create the cascade breaks according to the lambda, shadowMaxZ and min/max distance properties, as well as the camera near and far planes.
       * This function is automatically called when updating lambda, shadowMaxZ and min/max distances, however you should call it yourself if
       * you change the camera near/far planes!
       */
      splitFrustum() {
        this._breaksAreDirty = true;
      }
      _splitFrustum() {
        const camera = this._getCamera();
        if (!camera) {
          return;
        }
        const near = camera.minZ, far = camera.maxZ || this._shadowMaxZ, cameraRange = far - near, minDistance = this._minDistance, maxDistance = this._shadowMaxZ < far && this._shadowMaxZ >= near ? Math.min((this._shadowMaxZ - near) / (far - near), this._maxDistance) : this._maxDistance;
        const minZ = near + minDistance * cameraRange, maxZ = near + maxDistance * cameraRange;
        const range = maxZ - minZ, ratio = maxZ / minZ;
        for (let cascadeIndex = 0; cascadeIndex < this._cascades.length; ++cascadeIndex) {
          const p = (cascadeIndex + 1) / this._numCascades, log = minZ * ratio ** p, uniform = minZ + range * p;
          const d = this._lambda * (log - uniform) + uniform;
          this._cascades[cascadeIndex].prevBreakDistance = cascadeIndex === 0 ? minDistance : this._cascades[cascadeIndex - 1].breakDistance;
          this._cascades[cascadeIndex].breakDistance = (d - near) / cameraRange;
          this._viewSpaceFrustumsZ[cascadeIndex] = d;
          this._frustumLengths[cascadeIndex] = (this._cascades[cascadeIndex].breakDistance - this._cascades[cascadeIndex].prevBreakDistance) * cameraRange;
        }
        this._breaksAreDirty = false;
      }
      _computeMatrices() {
        const scene = this._scene;
        const camera = this._getCamera();
        if (!camera) {
          return;
        }
        Vector3.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection);
        if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1) {
          this._lightDirection.z = 1e-13;
        }
        this._cachedDirection.copyFrom(this._lightDirection);
        const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;
        for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
          this._computeFrustumInWorldSpace(cascadeIndex);
          this._computeCascadeFrustum(cascadeIndex);
          this._cascadeMaxExtents[cascadeIndex].subtractToRef(this._cascadeMinExtents[cascadeIndex], Tmpv1);
          this._frustumCenter[cascadeIndex].addToRef(this._lightDirection.scale(this._cascadeMinExtents[cascadeIndex].z), this._shadowCameraPos[cascadeIndex]);
          Matrix.LookAtLHToRef(this._shadowCameraPos[cascadeIndex], this._frustumCenter[cascadeIndex], UpDir, this._viewMatrices[cascadeIndex]);
          let viewMinZ = 0, viewMaxZ = Tmpv1.z;
          const boundingInfo = this._shadowCastersBoundingInfo;
          boundingInfo.update(this._viewMatrices[cascadeIndex]);
          const castersViewMinZ = boundingInfo.boundingBox.minimumWorld.z;
          const castersViewMaxZ = boundingInfo.boundingBox.maximumWorld.z;
          if (castersViewMinZ > viewMaxZ) {
          } else {
            if (!this._depthClamp || this.filter === ShadowGenerator.FILTER_PCSS) {
              viewMinZ = Math.min(viewMinZ, castersViewMinZ);
              if (this.filter !== ShadowGenerator.FILTER_PCSS) {
                viewMaxZ = Math.min(viewMaxZ, castersViewMaxZ);
              }
            } else {
              viewMaxZ = Math.min(viewMaxZ, castersViewMaxZ);
              viewMinZ = Math.max(viewMinZ, castersViewMinZ);
              viewMaxZ = Math.max(viewMinZ + 1, viewMaxZ);
            }
          }
          Matrix.OrthoOffCenterLHToRef(this._cascadeMinExtents[cascadeIndex].x, this._cascadeMaxExtents[cascadeIndex].x, this._cascadeMinExtents[cascadeIndex].y, this._cascadeMaxExtents[cascadeIndex].y, useReverseDepthBuffer ? viewMaxZ : viewMinZ, useReverseDepthBuffer ? viewMinZ : viewMaxZ, this._projectionMatrices[cascadeIndex], scene.getEngine().isNDCHalfZRange);
          this._cascadeMinExtents[cascadeIndex].z = viewMinZ;
          this._cascadeMaxExtents[cascadeIndex].z = viewMaxZ;
          this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);
          Vector3.TransformCoordinatesToRef(ZeroVec, this._transformMatrices[cascadeIndex], Tmpv1);
          Tmpv1.scaleInPlace(this._mapSize / 2);
          Tmpv2.copyFromFloats(Math.round(Tmpv1.x), Math.round(Tmpv1.y), Math.round(Tmpv1.z));
          Tmpv2.subtractInPlace(Tmpv1).scaleInPlace(2 / this._mapSize);
          Matrix.TranslationToRef(Tmpv2.x, Tmpv2.y, 0, TmpMatrix);
          this._projectionMatrices[cascadeIndex].multiplyToRef(TmpMatrix, this._projectionMatrices[cascadeIndex]);
          this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);
          this._transformMatrices[cascadeIndex].copyToArray(this._transformMatricesAsArray, cascadeIndex * 16);
        }
      }
      // Get the 8 points of the view frustum in world space
      _computeFrustumInWorldSpace(cascadeIndex) {
        const camera = this._getCamera();
        if (!camera) {
          return;
        }
        const prevSplitDist = this._cascades[cascadeIndex].prevBreakDistance, splitDist = this._cascades[cascadeIndex].breakDistance;
        const isNDCHalfZRange = this._scene.getEngine().isNDCHalfZRange;
        camera.getViewMatrix();
        const cameraInfiniteFarPlane = camera.maxZ === 0;
        const saveCameraMaxZ = camera.maxZ;
        if (cameraInfiniteFarPlane) {
          camera.maxZ = this._shadowMaxZ;
          camera.getProjectionMatrix(true);
        }
        const invViewProj = Matrix.Invert(camera.getTransformationMatrix());
        if (cameraInfiniteFarPlane) {
          camera.maxZ = saveCameraMaxZ;
          camera.getProjectionMatrix(true);
        }
        const cornerIndexOffset = this._scene.getEngine().useReverseDepthBuffer ? 4 : 0;
        for (let cornerIndex = 0; cornerIndex < _CascadedShadowGenerator._FrustumCornersNdcSpace.length; ++cornerIndex) {
          Tmpv1.copyFrom(_CascadedShadowGenerator._FrustumCornersNdcSpace[(cornerIndex + cornerIndexOffset) % _CascadedShadowGenerator._FrustumCornersNdcSpace.length]);
          if (isNDCHalfZRange && Tmpv1.z === -1) {
            Tmpv1.z = 0;
          }
          Vector3.TransformCoordinatesToRef(Tmpv1, invViewProj, this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
        }
        for (let cornerIndex = 0; cornerIndex < _CascadedShadowGenerator._FrustumCornersNdcSpace.length / 2; ++cornerIndex) {
          Tmpv1.copyFrom(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4]).subtractInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
          Tmpv2.copyFrom(Tmpv1).scaleInPlace(prevSplitDist);
          Tmpv1.scaleInPlace(splitDist);
          Tmpv1.addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
          this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4].copyFrom(Tmpv1);
          this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].addInPlace(Tmpv2);
        }
      }
      _computeCascadeFrustum(cascadeIndex) {
        this._cascadeMinExtents[cascadeIndex].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cascadeMaxExtents[cascadeIndex].copyFromFloats(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        this._frustumCenter[cascadeIndex].copyFromFloats(0, 0, 0);
        const camera = this._getCamera();
        if (!camera) {
          return;
        }
        for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
          this._frustumCenter[cascadeIndex].addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
        }
        this._frustumCenter[cascadeIndex].scaleInPlace(1 / this._frustumCornersWorldSpace[cascadeIndex].length);
        if (this.stabilizeCascades) {
          let sphereRadius = 0;
          for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
            const dist = this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].subtractToRef(this._frustumCenter[cascadeIndex], Tmpv1).length();
            sphereRadius = Math.max(sphereRadius, dist);
          }
          sphereRadius = Math.ceil(sphereRadius * 16) / 16;
          this._cascadeMaxExtents[cascadeIndex].copyFromFloats(sphereRadius, sphereRadius, sphereRadius);
          this._cascadeMinExtents[cascadeIndex].copyFromFloats(-sphereRadius, -sphereRadius, -sphereRadius);
        } else {
          const lightCameraPos = this._frustumCenter[cascadeIndex];
          this._frustumCenter[cascadeIndex].addToRef(this._lightDirection, Tmpv1);
          Matrix.LookAtLHToRef(lightCameraPos, Tmpv1, UpDir, TmpMatrix);
          for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
            Vector3.TransformCoordinatesToRef(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex], TmpMatrix, Tmpv1);
            this._cascadeMinExtents[cascadeIndex].minimizeInPlace(Tmpv1);
            this._cascadeMaxExtents[cascadeIndex].maximizeInPlace(Tmpv1);
          }
        }
      }
      _recreateSceneUBOs() {
        this._disposeSceneUBOs();
        if (this._sceneUBOs) {
          for (let i = 0; i < this._numCascades; ++i) {
            this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${i})`));
          }
        }
      }
      /**
       *  Support test.
       */
      static get IsSupported() {
        const engine = EngineStore.LastCreatedEngine;
        if (!engine) {
          return false;
        }
        return engine._features.supportCSM;
      }
      /**
       * Creates a Cascaded Shadow Generator object.
       * A ShadowGenerator is the required tool to use the shadows.
       * Each directional light casting shadows needs to use its own ShadowGenerator.
       * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows
       * @param mapSize The size of the texture what stores the shadows. Example : 1024.
       * @param light The directional light object generating the shadows.
       * @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
       * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it
       * @param useRedTextureType Forces the generator to use a Red instead of a RGBA type for the shadow map texture format (default: true)
       */
      constructor(mapSize, light, usefulFloatFirst, camera, useRedTextureType = true) {
        if (!_CascadedShadowGenerator.IsSupported) {
          Logger.Error("CascadedShadowMap is not supported by the current engine.");
          return;
        }
        super(mapSize, light, usefulFloatFirst, camera, useRedTextureType);
        this.usePercentageCloserFiltering = true;
      }
      _initializeGenerator() {
        this.penumbraDarkness = this.penumbraDarkness ?? 1;
        this._numCascades = this._numCascades ?? _CascadedShadowGenerator.DEFAULT_CASCADES_COUNT;
        this.stabilizeCascades = this.stabilizeCascades ?? false;
        this._freezeShadowCastersBoundingInfoObservable = this._freezeShadowCastersBoundingInfoObservable ?? null;
        this.freezeShadowCastersBoundingInfo = this.freezeShadowCastersBoundingInfo ?? false;
        this._scbiMin = this._scbiMin ?? new Vector3(0, 0, 0);
        this._scbiMax = this._scbiMax ?? new Vector3(0, 0, 0);
        this._shadowCastersBoundingInfo = this._shadowCastersBoundingInfo ?? new BoundingInfo(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
        this._breaksAreDirty = this._breaksAreDirty ?? true;
        this._minDistance = this._minDistance ?? 0;
        this._maxDistance = this._maxDistance ?? 1;
        this._currentLayer = this._currentLayer ?? 0;
        this._shadowMaxZ = this._shadowMaxZ ?? this._getCamera()?.maxZ ?? 1e4;
        this._debug = this._debug ?? false;
        this._depthClamp = this._depthClamp ?? true;
        this._cascadeBlendPercentage = this._cascadeBlendPercentage ?? 0.1;
        this._lambda = this._lambda ?? 0.5;
        this._autoCalcDepthBounds = this._autoCalcDepthBounds ?? false;
        this._recreateSceneUBOs();
        super._initializeGenerator();
      }
      _createTargetRenderTexture() {
        const engine = this._scene.getEngine();
        this._shadowMap?.dispose();
        const size = { width: this._mapSize, height: this._mapSize, layers: this.numCascades };
        this._shadowMap = new RenderTargetTexture(this._light.name + "_CSMShadowMap", size, this._scene, false, true, this._textureType, false, void 0, false, false, void 0, this._useRedTextureType ? 6 : 5);
        this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true, void 0, void 0, void 0, `DepthStencilForCSMShadowGenerator-${this._light.name}`);
        this._shadowMap.noPrePassRenderer = true;
      }
      _initializeShadowMap() {
        super._initializeShadowMap();
        if (this._shadowMap === null) {
          return;
        }
        this._transformMatricesAsArray = new Float32Array(this._numCascades * 16);
        this._tempTransformMatricesAsArray = new Float32Array(this._numCascades * 16);
        this._viewSpaceFrustumsZ = new Array(this._numCascades);
        this._frustumLengths = new Array(this._numCascades);
        this._lightSizeUVCorrection = new Array(this._numCascades * 2);
        this._depthCorrection = new Array(this._numCascades);
        this._cascades = [];
        this._viewMatrices = [];
        this._projectionMatrices = [];
        this._transformMatrices = [];
        this._cascadeMinExtents = [];
        this._cascadeMaxExtents = [];
        this._frustumCenter = [];
        this._shadowCameraPos = [];
        this._frustumCornersWorldSpace = [];
        for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
          this._cascades[cascadeIndex] = {
            prevBreakDistance: 0,
            breakDistance: 0
          };
          this._viewMatrices[cascadeIndex] = Matrix.Zero();
          this._projectionMatrices[cascadeIndex] = Matrix.Zero();
          this._transformMatrices[cascadeIndex] = Matrix.Zero();
          this._cascadeMinExtents[cascadeIndex] = new Vector3();
          this._cascadeMaxExtents[cascadeIndex] = new Vector3();
          this._frustumCenter[cascadeIndex] = new Vector3();
          this._shadowCameraPos[cascadeIndex] = new Vector3();
          this._frustumCornersWorldSpace[cascadeIndex] = new Array(_CascadedShadowGenerator._FrustumCornersNdcSpace.length);
          for (let i = 0; i < _CascadedShadowGenerator._FrustumCornersNdcSpace.length; ++i) {
            this._frustumCornersWorldSpace[cascadeIndex][i] = new Vector3();
          }
        }
        const engine = this._scene.getEngine();
        this._shadowMap.onBeforeBindObservable.clear();
        this._shadowMap.onBeforeRenderObservable.clear();
        this._shadowMap.onBeforeRenderObservable.add((layer) => {
          if (this._sceneUBOs) {
            this._scene.setSceneUniformBuffer(this._sceneUBOs[layer]);
          }
          this._currentLayer = layer;
          if (this._filter === ShadowGenerator.FILTER_PCF) {
            engine.setColorWrite(false);
          }
          FloatingOriginCurrentScene.eyeAtCamera = false;
          this._scene.setTransformMatrix(this.getCascadeViewMatrix(layer), this.getCascadeProjectionMatrix(layer));
          if (this._useUBO) {
            this._scene.getSceneUniformBuffer().unbindEffect();
            this._scene.finalizeSceneUbo();
          }
        });
        this._shadowMap.onBeforeBindObservable.add(() => {
          this._currentSceneUBO = this._scene.getSceneUniformBuffer();
          if (engine._enableGPUDebugMarkers) {
            engine.restoreDefaultFramebuffer();
            engine._debugPushGroup?.(`Cascaded shadow map generation for pass id ${engine.currentRenderPassId}`);
          }
          if (this._breaksAreDirty) {
            this._splitFrustum();
          }
          this._computeMatrices();
        });
        this._splitFrustum();
      }
      _bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect) {
        effect.setMatrix("viewProjection", this.getCascadeTransformMatrix(this._currentLayer));
      }
      _isReadyCustomDefines(defines) {
        defines.push("#define SM_DEPTHCLAMP " + (this._depthClamp && this._filter !== ShadowGenerator.FILTER_PCSS ? "1" : "0"));
      }
      /**
       * Prepare all the defines in a material relying on a shadow map at the specified light index.
       * @param defines Defines of the material we want to update
       * @param lightIndex Index of the light in the enabled light list of the material
       */
      prepareDefines(defines, lightIndex) {
        super.prepareDefines(defines, lightIndex);
        const scene = this._scene;
        const light = this._light;
        if (!scene.shadowsEnabled || !light.shadowEnabled) {
          return;
        }
        defines["SHADOWCSM" + lightIndex] = true;
        defines["SHADOWCSMDEBUG" + lightIndex] = this.debug;
        defines["SHADOWCSMNUM_CASCADES" + lightIndex] = this.numCascades;
        defines["SHADOWCSM_RIGHTHANDED" + lightIndex] = scene.useRightHandedSystem;
        const camera = this._getCamera();
        if (camera && this._shadowMaxZ <= (camera.maxZ || this._shadowMaxZ)) {
          defines["SHADOWCSMUSESHADOWMAXZ" + lightIndex] = true;
        }
        if (this.cascadeBlendPercentage === 0) {
          defines["SHADOWCSMNOBLEND" + lightIndex] = true;
        }
      }
      /**
       * Binds the shadow related information inside of an effect (information like near, far, darkness...
       * defined in the generator but impacting the effect).
       * @param lightIndex Index of the light in the enabled light list of the material owning the effect
       * @param effect The effect we are binfing the information for
       */
      bindShadowLight(lightIndex, effect) {
        const light = this._light;
        const scene = this._scene;
        if (!scene.shadowsEnabled || !light.shadowEnabled) {
          return;
        }
        const camera = this._getCamera();
        if (!camera) {
          return;
        }
        const shadowMap = this.getShadowMap();
        if (!shadowMap) {
          return;
        }
        const width = shadowMap.getSize().width;
        const transform = this._transformMatricesAsArray;
        const lightMatrix = scene.floatingOriginMode ? GetOffsetTransformMatrices(this._scene.floatingOriginOffset, this._viewMatrices, this._projectionMatrices, this._numCascades, this._tempTransformMatricesAsArray) : transform;
        effect.setMatrices("lightMatrix" + lightIndex, lightMatrix);
        effect.setArray("viewFrustumZ" + lightIndex, this._viewSpaceFrustumsZ);
        effect.setFloat("cascadeBlendFactor" + lightIndex, this.cascadeBlendPercentage === 0 ? 1e4 : 1 / this.cascadeBlendPercentage);
        effect.setArray("frustumLengths" + lightIndex, this._frustumLengths);
        if (this._filter === ShadowGenerator.FILTER_PCF) {
          effect.setDepthStencilTexture("shadowTexture" + lightIndex, shadowMap);
          light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);
        } else if (this._filter === ShadowGenerator.FILTER_PCSS) {
          for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
            this._lightSizeUVCorrection[cascadeIndex * 2 + 0] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[cascadeIndex].x - this._cascadeMinExtents[cascadeIndex].x);
            this._lightSizeUVCorrection[cascadeIndex * 2 + 1] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[cascadeIndex].y - this._cascadeMinExtents[cascadeIndex].y);
            this._depthCorrection[cascadeIndex] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[cascadeIndex].z - this._cascadeMinExtents[cascadeIndex].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);
          }
          effect.setDepthStencilTexture("shadowTexture" + lightIndex, shadowMap);
          effect.setTexture("depthTexture" + lightIndex, shadowMap);
          effect.setArray2("lightSizeUVCorrection" + lightIndex, this._lightSizeUVCorrection);
          effect.setArray("depthCorrection" + lightIndex, this._depthCorrection);
          effect.setFloat("penumbraDarkness" + lightIndex, this.penumbraDarkness);
          light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / width, this._contactHardeningLightSizeUVRatio * width, this.frustumEdgeFalloff, lightIndex);
        } else {
          effect.setTexture("shadowTexture" + lightIndex, shadowMap);
          light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);
        }
        light._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);
      }
      /**
       * Gets the transformation matrix of the first cascade used to project the meshes into the map from the light point of view.
       * (eq to view projection * shadow projection matrices)
       * @returns The transform matrix used to create the shadow map
       */
      getTransformMatrix() {
        return this.getCascadeTransformMatrix(0);
      }
      /**
       * Disposes the ShadowGenerator.
       * Returns nothing.
       */
      dispose() {
        super.dispose();
        if (this._freezeShadowCastersBoundingInfoObservable) {
          this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);
          this._freezeShadowCastersBoundingInfoObservable = null;
        }
        if (this._depthReducer) {
          this._depthReducer.dispose();
          this._depthReducer = null;
        }
      }
      /**
       * Serializes the shadow generator setup to a json object.
       * @returns The serialized JSON object
       */
      serialize() {
        const serializationObject = super.serialize();
        const shadowMap = this.getShadowMap();
        if (!shadowMap) {
          return serializationObject;
        }
        serializationObject.numCascades = this._numCascades;
        serializationObject.debug = this._debug;
        serializationObject.stabilizeCascades = this.stabilizeCascades;
        serializationObject.lambda = this._lambda;
        serializationObject.cascadeBlendPercentage = this.cascadeBlendPercentage;
        serializationObject.depthClamp = this._depthClamp;
        serializationObject.autoCalcDepthBounds = this.autoCalcDepthBounds;
        serializationObject.shadowMaxZ = this._shadowMaxZ;
        serializationObject.penumbraDarkness = this.penumbraDarkness;
        serializationObject.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo;
        serializationObject.minDistance = this.minDistance;
        serializationObject.maxDistance = this.maxDistance;
        serializationObject.renderList = [];
        if (shadowMap.renderList) {
          for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {
            const mesh = shadowMap.renderList[meshIndex];
            serializationObject.renderList.push(mesh.id);
          }
        }
        return serializationObject;
      }
      /**
       * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
       * @param parsedShadowGenerator The JSON object to parse
       * @param scene The scene to create the shadow map for
       * @returns The parsed shadow generator
       */
      static Parse(parsedShadowGenerator, scene) {
        const shadowGenerator = ShadowGenerator.Parse(parsedShadowGenerator, scene, (mapSize, light, camera) => new _CascadedShadowGenerator(mapSize, light, void 0, camera));
        if (parsedShadowGenerator.numCascades !== void 0) {
          shadowGenerator.numCascades = parsedShadowGenerator.numCascades;
        }
        if (parsedShadowGenerator.debug !== void 0) {
          shadowGenerator.debug = parsedShadowGenerator.debug;
        }
        if (parsedShadowGenerator.stabilizeCascades !== void 0) {
          shadowGenerator.stabilizeCascades = parsedShadowGenerator.stabilizeCascades;
        }
        if (parsedShadowGenerator.lambda !== void 0) {
          shadowGenerator.lambda = parsedShadowGenerator.lambda;
        }
        if (parsedShadowGenerator.cascadeBlendPercentage !== void 0) {
          shadowGenerator.cascadeBlendPercentage = parsedShadowGenerator.cascadeBlendPercentage;
        }
        if (parsedShadowGenerator.depthClamp !== void 0) {
          shadowGenerator.depthClamp = parsedShadowGenerator.depthClamp;
        }
        if (parsedShadowGenerator.autoCalcDepthBounds !== void 0) {
          shadowGenerator.autoCalcDepthBounds = parsedShadowGenerator.autoCalcDepthBounds;
        }
        if (parsedShadowGenerator.shadowMaxZ !== void 0) {
          shadowGenerator.shadowMaxZ = parsedShadowGenerator.shadowMaxZ;
        }
        if (parsedShadowGenerator.penumbraDarkness !== void 0) {
          shadowGenerator.penumbraDarkness = parsedShadowGenerator.penumbraDarkness;
        }
        if (parsedShadowGenerator.freezeShadowCastersBoundingInfo !== void 0) {
          shadowGenerator.freezeShadowCastersBoundingInfo = parsedShadowGenerator.freezeShadowCastersBoundingInfo;
        }
        if (parsedShadowGenerator.minDistance !== void 0 && parsedShadowGenerator.maxDistance !== void 0) {
          shadowGenerator.setMinMaxDistance(parsedShadowGenerator.minDistance, parsedShadowGenerator.maxDistance);
        }
        return shadowGenerator;
      }
    };
    CascadedShadowGenerator._FrustumCornersNdcSpace = [
      new Vector3(-1, 1, -1),
      new Vector3(1, 1, -1),
      new Vector3(1, -1, -1),
      new Vector3(-1, -1, -1),
      new Vector3(-1, 1, 1),
      new Vector3(1, 1, 1),
      new Vector3(1, -1, 1),
      new Vector3(-1, -1, 1)
    ];
    CascadedShadowGenerator.CLASSNAME = "CascadedShadowGenerator";
    CascadedShadowGenerator.DEFAULT_CASCADES_COUNT = 4;
    CascadedShadowGenerator.MIN_CASCADES_COUNT = 2;
    CascadedShadowGenerator.MAX_CASCADES_COUNT = 4;
    CascadedShadowGenerator._SceneComponentInitialization = (_) => {
      throw _WarnImport("ShadowGeneratorSceneComponent");
    };
  }
});

// node_modules/@babylonjs/core/Gizmos/axisScaleGizmo.js
var AxisScaleGizmo;
var init_axisScaleGizmo = __esm({
  "node_modules/@babylonjs/core/Gizmos/axisScaleGizmo.js"() {
    init_observable();
    init_math_vector();
    init_mesh();
    init_boxBuilder();
    init_cylinderBuilder();
    init_standardMaterial();
    init_pointerDragBehavior();
    init_gizmo();
    init_utilityLayerRenderer();
    init_math_color();
    init_math_constants();
    AxisScaleGizmo = class _AxisScaleGizmo extends Gizmo {
      /** Default material used to render when gizmo is not disabled or hovered */
      get coloredMaterial() {
        return this._coloredMaterial;
      }
      /** Material used to render when gizmo is hovered with mouse*/
      get hoverMaterial() {
        return this._hoverMaterial;
      }
      /** Material used to render when gizmo is disabled. typically grey.*/
      get disableMaterial() {
        return this._disableMaterial;
      }
      /**
       * Creates an AxisScaleGizmo
       * @param dragAxis The axis which the gizmo will be able to scale on
       * @param color The color of the gizmo
       * @param gizmoLayer The utility layer the gizmo will be added to
       * @param parent
       * @param thickness display gizmo axis thickness
       * @param hoverColor The color of the gizmo when hovering over and dragging
       * @param disableColor The Color of the gizmo when its disabled
       */
      constructor(dragAxis, color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, parent = null, thickness = 1, hoverColor = Color3.Yellow(), disableColor = Color3.Gray()) {
        super(gizmoLayer);
        this._pointerObserver = null;
        this.snapDistance = 0;
        this.onSnapObservable = new Observable();
        this.uniformScaling = false;
        this.sensitivity = 1;
        this.dragScale = 1;
        this.incrementalSnap = false;
        this._isEnabled = true;
        this._parent = null;
        this._dragging = false;
        this._tmpVector = new Vector3(0, 0, 0);
        this._incrementalStartupValue = Vector3.Zero();
        this._parent = parent;
        this._coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        this._coloredMaterial.diffuseColor = color;
        this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));
        this._hoverMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        this._hoverMaterial.diffuseColor = hoverColor;
        this._disableMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        this._disableMaterial.diffuseColor = disableColor;
        this._disableMaterial.alpha = 0.4;
        this._gizmoMesh = new Mesh("axis", gizmoLayer.utilityLayerScene);
        const { arrowMesh, arrowTail } = this._createGizmoMesh(this._gizmoMesh, thickness);
        const collider = this._createGizmoMesh(this._gizmoMesh, thickness + 4, true);
        this._gizmoMesh.lookAt(this._rootMesh.position.add(dragAxis));
        this._rootMesh.addChild(this._gizmoMesh, Gizmo.PreserveScaling);
        this._gizmoMesh.scaling.scaleInPlace(1 / 3);
        const nodePosition = arrowMesh.position.clone();
        const linePosition = arrowTail.position.clone();
        const lineScale = arrowTail.scaling.clone();
        const increaseGizmoMesh = (dragDistance) => {
          const dragStrength = dragDistance * (3 / this._rootMesh.scaling.length()) * 6;
          arrowMesh.position.z += dragStrength / 3.5;
          arrowTail.scaling.y += dragStrength;
          this.dragScale = arrowTail.scaling.y;
          arrowTail.position.z = arrowMesh.position.z / 2;
        };
        const resetGizmoMesh = () => {
          arrowMesh.position.set(nodePosition.x, nodePosition.y, nodePosition.z);
          arrowTail.position.set(linePosition.x, linePosition.y, linePosition.z);
          arrowTail.scaling.set(lineScale.x, lineScale.y, lineScale.z);
          this.dragScale = arrowTail.scaling.y;
          this._dragging = false;
        };
        this.dragBehavior = new PointerDragBehavior({ dragAxis });
        this.dragBehavior.moveAttached = false;
        this.dragBehavior.updateDragPlane = false;
        this._rootMesh.addBehavior(this.dragBehavior);
        let currentSnapDragDistance = 0;
        let currentSnapDragDistanceIncremental = 0;
        const tmpSnapEvent = { snapDistance: 0 };
        this.dragBehavior.onDragObservable.add((event) => {
          if (this.attachedNode) {
            const dragStrength = this.sensitivity * event.dragDistance * (this.scaleRatio * 3 / this._rootMesh.scaling.length());
            const tmpVector = this._tmpVector;
            let snapped = false;
            let dragSteps = 0;
            if (this.uniformScaling) {
              tmpVector.setAll(0.57735);
            } else {
              tmpVector.copyFrom(dragAxis);
            }
            if (this.snapDistance == 0) {
              tmpVector.scaleToRef(dragStrength, tmpVector);
            } else {
              currentSnapDragDistance += dragStrength;
              currentSnapDragDistanceIncremental += dragStrength;
              const currentSnap = this.incrementalSnap ? currentSnapDragDistanceIncremental : currentSnapDragDistance;
              if (Math.abs(currentSnap) > this.snapDistance) {
                dragSteps = Math.floor(Math.abs(currentSnap) / this.snapDistance);
                if (currentSnap < 0) {
                  dragSteps *= -1;
                }
                currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;
                tmpVector.scaleToRef(this.snapDistance * dragSteps, tmpVector);
                snapped = true;
              } else {
                tmpVector.scaleInPlace(0);
              }
            }
            tmpVector.addInPlaceFromFloats(1, 1, 1);
            tmpVector.x = Math.abs(tmpVector.x) < _AxisScaleGizmo.MinimumAbsoluteScale ? _AxisScaleGizmo.MinimumAbsoluteScale * (tmpVector.x < 0 ? -1 : 1) : tmpVector.x;
            tmpVector.y = Math.abs(tmpVector.y) < _AxisScaleGizmo.MinimumAbsoluteScale ? _AxisScaleGizmo.MinimumAbsoluteScale * (tmpVector.y < 0 ? -1 : 1) : tmpVector.y;
            tmpVector.z = Math.abs(tmpVector.z) < _AxisScaleGizmo.MinimumAbsoluteScale ? _AxisScaleGizmo.MinimumAbsoluteScale * (tmpVector.z < 0 ? -1 : 1) : tmpVector.z;
            const transformNode = this.attachedNode._isMesh ? this.attachedNode : void 0;
            if (Math.abs(this.snapDistance) > 0 && this.incrementalSnap) {
              this.attachedNode.getWorldMatrix().decompose(void 0, TmpVectors.Quaternion[0], TmpVectors.Vector3[2], Gizmo.PreserveScaling ? transformNode : void 0);
              tmpVector.addInPlace(this._incrementalStartupValue);
              tmpVector.addInPlaceFromFloats(-1, -1, -1);
              tmpVector.x = Math.abs(tmpVector.x) * (this._incrementalStartupValue.x > 0 ? 1 : -1);
              tmpVector.y = Math.abs(tmpVector.y) * (this._incrementalStartupValue.y > 0 ? 1 : -1);
              tmpVector.z = Math.abs(tmpVector.z) * (this._incrementalStartupValue.z > 0 ? 1 : -1);
              Matrix.ComposeToRef(tmpVector, TmpVectors.Quaternion[0], TmpVectors.Vector3[2], TmpVectors.Matrix[1]);
            } else {
              Matrix.ScalingToRef(tmpVector.x, tmpVector.y, tmpVector.z, TmpVectors.Matrix[2]);
              TmpVectors.Matrix[2].multiplyToRef(this.attachedNode.getWorldMatrix(), TmpVectors.Matrix[1]);
            }
            TmpVectors.Matrix[1].decompose(TmpVectors.Vector3[1], void 0, void 0, Gizmo.PreserveScaling ? transformNode : void 0);
            const maxScale = 1e5;
            if (Math.abs(TmpVectors.Vector3[1].x) < maxScale && Math.abs(TmpVectors.Vector3[1].y) < maxScale && Math.abs(TmpVectors.Vector3[1].z) < maxScale) {
              this.attachedNode.getWorldMatrix().copyFrom(TmpVectors.Matrix[1]);
            }
            if (snapped) {
              tmpSnapEvent.snapDistance = this.snapDistance * dragSteps;
              this.onSnapObservable.notifyObservers(tmpSnapEvent);
            }
            this._matrixChanged();
          }
        });
        this.dragBehavior.onDragStartObservable.add(() => {
          this._dragging = true;
          const transformNode = this.attachedNode._isMesh ? this.attachedNode : void 0;
          this.attachedNode?.getWorldMatrix().decompose(this._incrementalStartupValue, void 0, void 0, Gizmo.PreserveScaling ? transformNode : void 0);
          currentSnapDragDistance = 0;
          currentSnapDragDistanceIncremental = 0;
        });
        this.dragBehavior.onDragObservable.add((e) => increaseGizmoMesh(e.dragDistance));
        this.dragBehavior.onDragEndObservable.add(resetGizmoMesh);
        parent?.uniformScaleGizmo?.dragBehavior?.onDragObservable?.add((e) => increaseGizmoMesh(e.delta.y));
        parent?.uniformScaleGizmo?.dragBehavior?.onDragEndObservable?.add(resetGizmoMesh);
        const cache = {
          gizmoMeshes: [arrowMesh, arrowTail],
          colliderMeshes: [collider.arrowMesh, collider.arrowTail],
          material: this._coloredMaterial,
          hoverMaterial: this._hoverMaterial,
          disableMaterial: this._disableMaterial,
          active: false,
          dragBehavior: this.dragBehavior
        };
        this._parent?.addToAxisCache(this._gizmoMesh, cache);
        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
          if (this._customMeshSet) {
            return;
          }
          let meshCache = this._parent?.getAxisCache(this._gizmoMesh);
          this._isHovered = !!meshCache && !!(meshCache.colliderMeshes.indexOf(pointerInfo?.pickInfo?.pickedMesh) != -1);
          meshCache = this._parent?.getAxisCache(this._rootMesh);
          this._isHovered || (this._isHovered = !!meshCache && !!(meshCache.colliderMeshes.indexOf(pointerInfo?.pickInfo?.pickedMesh) != -1));
          if (!this._parent) {
            const material = this.dragBehavior.enabled ? this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial : this._disableMaterial;
            this._setGizmoMeshMaterial(cache.gizmoMeshes, material);
          }
        });
        this.dragBehavior.onEnabledObservable.add((newState) => {
          this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? this._coloredMaterial : this._disableMaterial);
        });
        const light = gizmoLayer._getSharedGizmoLight();
        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes());
      }
      /**
       * @internal
       * Create Geometry for Gizmo
       * @param parentMesh
       * @param thickness
       * @param isCollider
       * @returns the gizmo mesh
       */
      _createGizmoMesh(parentMesh, thickness, isCollider = false) {
        const arrowMesh = CreateBox("yPosMesh", { size: 0.4 * (1 + (thickness - 1) / 4) }, this.gizmoLayer.utilityLayerScene);
        const arrowTail = CreateCylinder("cylinder", { diameterTop: 5e-3 * thickness, height: 0.275, diameterBottom: 5e-3 * thickness, tessellation: 96 }, this.gizmoLayer.utilityLayerScene);
        arrowMesh.scaling.scaleInPlace(0.1);
        arrowMesh.material = this._coloredMaterial;
        arrowMesh.rotation.x = Math.PI / 2;
        arrowMesh.position.z += 0.3;
        arrowTail.material = this._coloredMaterial;
        arrowTail.position.z += 0.275 / 2;
        arrowTail.rotation.x = Math.PI / 2;
        if (isCollider) {
          arrowMesh.visibility = 0;
          arrowTail.visibility = 0;
        }
        parentMesh.addChild(arrowMesh);
        parentMesh.addChild(arrowTail);
        return { arrowMesh, arrowTail };
      }
      _attachedNodeChanged(value) {
        if (this.dragBehavior) {
          this.dragBehavior.enabled = value ? true : false;
        }
      }
      /**
       * If the gizmo is enabled
       */
      set isEnabled(value) {
        this._isEnabled = value;
        if (!value) {
          this.attachedMesh = null;
          this.attachedNode = null;
        } else {
          if (this._parent) {
            this.attachedMesh = this._parent.attachedMesh;
            this.attachedNode = this._parent.attachedNode;
          }
        }
      }
      get isEnabled() {
        return this._isEnabled;
      }
      /**
       * Disposes of the gizmo
       */
      dispose() {
        this.onSnapObservable.clear();
        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
        this.dragBehavior.detach();
        if (this._gizmoMesh) {
          this._gizmoMesh.dispose();
        }
        const mats = [this._coloredMaterial, this._hoverMaterial, this._disableMaterial];
        for (const matl of mats) {
          if (matl) {
            matl.dispose();
          }
        }
        super.dispose();
      }
      /**
       * Disposes and replaces the current meshes in the gizmo with the specified mesh
       * @param mesh The mesh to replace the default mesh of the gizmo
       * @param useGizmoMaterial If the gizmo's default material should be used (default: false)
       */
      setCustomMesh(mesh, useGizmoMaterial = false) {
        super.setCustomMesh(mesh);
        if (useGizmoMaterial) {
          const childMeshes = this._gizmoMesh.getChildMeshes();
          for (const m of childMeshes) {
            m.material = this._coloredMaterial;
            if (m.color) {
              m.color = this._coloredMaterial.diffuseColor;
            }
          }
          this._customMeshSet = false;
        }
      }
    };
    AxisScaleGizmo.MinimumAbsoluteScale = Epsilon;
  }
});

// node_modules/@babylonjs/core/Gizmos/boundingBoxGizmo.js
var DragOperation, BoundingBoxGizmo;
var init_boundingBoxGizmo = __esm({
  "node_modules/@babylonjs/core/Gizmos/boundingBoxGizmo.js"() {
    init_observable();
    init_logger();
    init_math_vector();
    init_mesh();
    init_boxBuilder();
    init_linesBuilder();
    init_pointerDragBehavior();
    init_gizmo();
    init_utilityLayerRenderer();
    init_standardMaterial();
    init_pivotTools();
    init_math_color();
    init_math_constants();
    init_transformNode();
    (function(DragOperation2) {
      DragOperation2[DragOperation2["Rotation"] = 0] = "Rotation";
      DragOperation2[DragOperation2["Scaling"] = 1] = "Scaling";
    })(DragOperation || (DragOperation = {}));
    BoundingBoxGizmo = class extends Gizmo {
      /**
       * Sets the axis factor
       * @param factor the Vector3 value
       */
      set axisFactor(factor) {
        this._axisFactor = factor;
        const scaleBoxes = this._scaleBoxesParent.getChildMeshes();
        let index = 0;
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            for (let k = 0; k < 3; k++) {
              const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);
              if (zeroAxisCount === 1 || zeroAxisCount === 3) {
                continue;
              }
              if (scaleBoxes[index]) {
                const dragAxis = new Vector3(i - 1, j - 1, k - 1);
                dragAxis.multiplyInPlace(this._axisFactor);
                scaleBoxes[index].setEnabled(dragAxis.lengthSquared() > Epsilon);
              }
              index++;
            }
          }
        }
      }
      /**
       * Gets the axis factor
       * @returns the Vector3 factor value
       */
      get axisFactor() {
        return this._axisFactor;
      }
      /**
       * Sets scale drag speed value
       * @param value the new speed value
       */
      set scaleDragSpeed(value) {
        this._scaleDragSpeed = value;
      }
      /**
       * Gets scale drag speed
       * @returns the scale speed number
       */
      get scaleDragSpeed() {
        return this._scaleDragSpeed;
      }
      /** Default material used to render when gizmo is not disabled or hovered */
      get coloredMaterial() {
        return this._coloredMaterial;
      }
      /** Material used to render when gizmo is hovered with mouse*/
      get hoverMaterial() {
        return this._hoverColoredMaterial;
      }
      /**
       * Get the pointerDragBehavior
       */
      get pointerDragBehavior() {
        return this._pointerDragBehavior;
      }
      /** True when a rotation anchor or scale box or a attached mesh is dragged */
      get isDragging() {
        return this._dragging || this._pointerDragBehavior.dragging;
      }
      /**
       * Sets the color of the bounding box gizmo
       * @param color the color to set
       */
      setColor(color) {
        this._coloredMaterial.emissiveColor = color;
        this._hoverColoredMaterial.emissiveColor = color.clone().add(new Color3(0.3, 0.3, 0.3));
        const children = this._lineBoundingBox.getChildren();
        for (const l of children) {
          if (l.color) {
            l.color = color;
          }
        }
      }
      /**
       * Creates an BoundingBoxGizmo
       * @param color The color of the gizmo
       * @param gizmoLayer The utility layer the gizmo will be added to
       */
      constructor(color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer) {
        super(gizmoLayer);
        this._boundingDimensions = new Vector3(1, 1, 1);
        this._renderObserver = null;
        this._pointerObserver = null;
        this._scaleDragSpeed = 0.2;
        this._rotateAnchorsDragBehaviors = [];
        this._scaleBoxesDragBehaviors = [];
        this._dragging = false;
        this._tmpQuaternion = new Quaternion();
        this._tmpVector = new Vector3(0, 0, 0);
        this._tmpRotationMatrix = new Matrix();
        this._incrementalStartupValue = Vector3.Zero();
        this._incrementalAnchorStartupValue = Vector3.Zero();
        this.ignoreChildren = false;
        this.includeChildPredicate = null;
        this.rotationSphereSize = 0.1;
        this.scaleBoxSize = 0.1;
        this.fixedDragMeshScreenSize = false;
        this.fixedDragMeshBoundsSize = false;
        this.fixedDragMeshScreenSizeDistanceFactor = 10;
        this.scalingSnapDistance = 0;
        this.rotationSnapDistance = 0;
        this.onDragStartObservable = new Observable();
        this.onHoverStartObservable = new Observable();
        this.onHoverEndObservable = new Observable();
        this.onScaleBoxDragObservable = new Observable();
        this.onScaleBoxDragEndObservable = new Observable();
        this.onRotationSphereDragObservable = new Observable();
        this.onRotationSphereDragEndObservable = new Observable();
        this.scalePivot = null;
        this._axisFactor = new Vector3(1, 1, 1);
        this.incrementalSnap = false;
        this._existingMeshScale = new Vector3();
        this._dragMesh = null;
        this._pointerDragBehavior = new PointerDragBehavior();
        this._cornerMesh = null;
        this.updateScale = false;
        this._anchorMesh = new TransformNode("anchor", gizmoLayer.utilityLayerScene);
        this._coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        this._coloredMaterial.disableLighting = true;
        this._hoverColoredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        this._hoverColoredMaterial.disableLighting = true;
        this._lineBoundingBox = new TransformNode("", gizmoLayer.utilityLayerScene);
        this._lineBoundingBox.rotationQuaternion = new Quaternion();
        const lines = [
          [new Vector3(0, 0, 0), new Vector3(this._boundingDimensions.x, 0, 0)],
          [new Vector3(0, 0, 0), new Vector3(0, this._boundingDimensions.y, 0)],
          [new Vector3(0, 0, 0), new Vector3(0, 0, this._boundingDimensions.z)],
          [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)],
          [new Vector3(this._boundingDimensions.x, 0, 0), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)],
          [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)],
          [new Vector3(0, this._boundingDimensions.y, 0), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)],
          [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)],
          [new Vector3(0, 0, this._boundingDimensions.z), new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)],
          [
            new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z),
            new Vector3(0, this._boundingDimensions.y, this._boundingDimensions.z)
          ],
          [
            new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z),
            new Vector3(this._boundingDimensions.x, 0, this._boundingDimensions.z)
          ],
          [
            new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, this._boundingDimensions.z),
            new Vector3(this._boundingDimensions.x, this._boundingDimensions.y, 0)
          ]
        ];
        const line = CreateLineSystem("lines", { lines }, gizmoLayer.utilityLayerScene);
        line.color = color;
        line.position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));
        line.isPickable = false;
        this._lineBoundingBox.addChild(line);
        this._rootMesh.addChild(this._lineBoundingBox);
        this.setColor(color);
        this._rotateAnchorsParent = new TransformNode("", gizmoLayer.utilityLayerScene);
        this._rotateAnchorsParent.rotationQuaternion = new Quaternion();
        for (let i = 0; i < 12; i++) {
          const anchor = CreateBox("", { width: i < 4 || i >= 8 ? 1.6 : 0.4, height: i >= 4 && i < 8 ? 1.6 : 0.4, depth: 0.4 }, gizmoLayer.utilityLayerScene);
          anchor.rotation.x = i < 4 || i >= 8 ? Math.PI * 0.25 : 0;
          anchor.rotation.y = i >= 4 && i < 8 ? Math.PI * 0.25 : 0;
          anchor.bakeTransformIntoVertices(anchor.computeWorldMatrix(true));
          anchor.rotationQuaternion = new Quaternion();
          anchor.material = this._coloredMaterial;
          anchor.isNearGrabbable = true;
          const rotateAnchorsDragBehavior = new PointerDragBehavior({});
          rotateAnchorsDragBehavior.moveAttached = false;
          rotateAnchorsDragBehavior.updateDragPlane = false;
          anchor.addBehavior(rotateAnchorsDragBehavior);
          const startingTurnDirection = new Vector3(1, 0, 0);
          let totalTurnAmountOfDrag = 0;
          let previousProjectDist = 0;
          rotateAnchorsDragBehavior.onDragStartObservable.add(() => {
            startingTurnDirection.copyFrom(anchor.forward);
            totalTurnAmountOfDrag = 0;
            previousProjectDist = 0;
          });
          const computeAxis = function() {
            const dragAxisIndex = Math.floor(i / 4);
            TmpVectors.Vector3[0].set(dragAxisIndex == 0 ? 1 : 0, dragAxisIndex == 1 ? 1 : 0, dragAxisIndex == 2 ? 1 : 0);
            return TmpVectors.Vector3[0];
          };
          rotateAnchorsDragBehavior.onDragObservable.add((event) => {
            this.onRotationSphereDragObservable.notifyObservers({ dragOperation: 0, dragAxis: computeAxis().clone() });
            if (this.attachedMesh) {
              const originalParent = this.attachedMesh.parent;
              if (originalParent && originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(1e-3)) {
                Logger.Warn("BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling");
                return;
              }
              PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);
              const worldDragDirection = startingTurnDirection;
              const toSub = event.dragPlaneNormal.scale(Vector3.Dot(event.dragPlaneNormal, worldDragDirection));
              const dragAxis = worldDragDirection.subtract(toSub).normalizeToNew();
              let projectDist = Vector3.Dot(dragAxis, event.delta) < 0 ? Math.abs(event.delta.length()) : -Math.abs(event.delta.length());
              projectDist = projectDist / this._boundingDimensions.length() * this._anchorMesh.scaling.length();
              if (!this.attachedMesh.rotationQuaternion) {
                this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);
              }
              if (!this._anchorMesh.rotationQuaternion) {
                this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);
              }
              totalTurnAmountOfDrag += projectDist;
              if (Math.abs(totalTurnAmountOfDrag) <= 2 * Math.PI) {
                if (this.rotationSnapDistance > 0) {
                  const dragSteps = Math.floor(Math.abs(totalTurnAmountOfDrag) / this.rotationSnapDistance) * (totalTurnAmountOfDrag < 0 ? -1 : 1);
                  const angle = this.rotationSnapDistance * dragSteps;
                  projectDist = angle - previousProjectDist;
                  previousProjectDist = angle;
                }
                if (i >= 8) {
                  Quaternion.RotationYawPitchRollToRef(0, 0, projectDist, this._tmpQuaternion);
                } else if (i >= 4) {
                  Quaternion.RotationYawPitchRollToRef(projectDist, 0, 0, this._tmpQuaternion);
                } else {
                  Quaternion.RotationYawPitchRollToRef(0, projectDist, 0, this._tmpQuaternion);
                }
                if (this.attachedMesh.isUsingPivotMatrix()) {
                  this._anchorMesh.position.copyFrom(this.attachedMesh.position);
                }
                this._anchorMesh.addChild(this.attachedMesh);
                if (this._anchorMesh.getScene().useRightHandedSystem) {
                  this._tmpQuaternion.conjugateInPlace();
                }
                this._tmpQuaternion.normalize();
                this._anchorMesh.rotationQuaternion.multiplyToRef(this._tmpQuaternion, this._anchorMesh.rotationQuaternion);
                this._anchorMesh.rotationQuaternion.normalize();
                this._anchorMesh.removeChild(this.attachedMesh);
                this.attachedMesh.setParent(originalParent);
              }
              this.updateBoundingBox();
              PivotTools._RestorePivotPoint(this.attachedMesh);
            }
            this._updateDummy();
          });
          rotateAnchorsDragBehavior.onDragStartObservable.add(() => {
            this.onDragStartObservable.notifyObservers({ dragOperation: 0, dragAxis: computeAxis().clone() });
            this._dragging = true;
            this._selectNode(anchor);
          });
          rotateAnchorsDragBehavior.onDragEndObservable.add((event) => {
            this.onRotationSphereDragEndObservable.notifyObservers({ dragOperation: 0, dragAxis: computeAxis().clone() });
            this._dragging = false;
            this._selectNode(null);
            this._updateDummy();
            this._unhoverMeshOnTouchUp(event.pointerInfo, anchor);
          });
          this._rotateAnchorsDragBehaviors.push(rotateAnchorsDragBehavior);
          this._rotateAnchorsParent.addChild(anchor);
        }
        this._rootMesh.addChild(this._rotateAnchorsParent);
        this._scaleBoxesParent = new TransformNode("", gizmoLayer.utilityLayerScene);
        this._scaleBoxesParent.rotationQuaternion = new Quaternion();
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            for (let k = 0; k < 3; k++) {
              const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);
              if (zeroAxisCount === 1 || zeroAxisCount === 3) {
                continue;
              }
              const box = zeroAxisCount === 2 ? CreateBox("", { size: 1 }, gizmoLayer.utilityLayerScene) : this._getCornerMesh(gizmoLayer);
              if (zeroAxisCount === 0) {
                box.rotationQuaternion = Quaternion.FromEulerAngles(j * 0.25 * Math.PI, (k + 3 * i - i * k) * 0.25 * Math.PI, 0);
              }
              box.material = this._coloredMaterial;
              box._internalMetadata = zeroAxisCount === 2;
              box.isNearGrabbable = true;
              TmpVectors.Vector3[0].set(i - 1, j - 1, k - 1);
              TmpVectors.Vector3[0].normalize();
              box.computeWorldMatrix(true).invertToRef(TmpVectors.Matrix[0]);
              const dragAxis = Vector3.TransformCoordinates(TmpVectors.Vector3[0], TmpVectors.Matrix[0]);
              dragAxis.normalize();
              const scaleBoxesDragBehavior = new PointerDragBehavior({ dragAxis });
              scaleBoxesDragBehavior.updateDragPlane = false;
              scaleBoxesDragBehavior.moveAttached = false;
              let totalRelativeDragDistance = 0;
              let previousScale = 0;
              box.addBehavior(scaleBoxesDragBehavior);
              scaleBoxesDragBehavior.onDragObservable.add((event) => {
                this.onScaleBoxDragObservable.notifyObservers({ dragOperation: 1, dragAxis: new Vector3(i - 1, j - 1, k - 1) });
                if (this.attachedMesh) {
                  const originalParent = this.attachedMesh.parent;
                  if (originalParent && originalParent.scaling && originalParent.scaling.isNonUniformWithinEpsilon(1e-3)) {
                    Logger.Warn("BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling");
                    return;
                  }
                  PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);
                  let relativeDragDistance = event.dragDistance / this._boundingDimensions.length() * this._anchorMesh.scaling.length();
                  totalRelativeDragDistance += relativeDragDistance;
                  if (this.scalingSnapDistance > 0) {
                    const dragSteps = Math.floor(Math.abs(totalRelativeDragDistance) / this.scalingSnapDistance) * (totalRelativeDragDistance < 0 ? -1 : 1);
                    const scale = this.scalingSnapDistance * dragSteps;
                    relativeDragDistance = scale - previousScale;
                    previousScale = scale;
                  }
                  const deltaScale = new Vector3(relativeDragDistance, relativeDragDistance, relativeDragDistance);
                  const fullScale = new Vector3(previousScale, previousScale, previousScale);
                  if (zeroAxisCount === 2) {
                    deltaScale.x *= Math.abs(dragAxis.x);
                    deltaScale.y *= Math.abs(dragAxis.y);
                    deltaScale.z *= Math.abs(dragAxis.z);
                  }
                  deltaScale.scaleInPlace(this._scaleDragSpeed);
                  deltaScale.multiplyInPlace(this._axisFactor);
                  fullScale.scaleInPlace(this._scaleDragSpeed);
                  fullScale.multiplyInPlace(this._axisFactor);
                  fullScale.addInPlace(this._incrementalStartupValue);
                  this.updateBoundingBox();
                  if (this.scalePivot) {
                    this.attachedMesh.getWorldMatrix().getRotationMatrixToRef(this._tmpRotationMatrix);
                    this._boundingDimensions.scaleToRef(0.5, this._tmpVector);
                    Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);
                    this._anchorMesh.position.subtractInPlace(this._tmpVector);
                    this._boundingDimensions.multiplyToRef(this.scalePivot, this._tmpVector);
                    Vector3.TransformCoordinatesToRef(this._tmpVector, this._tmpRotationMatrix, this._tmpVector);
                    this._anchorMesh.position.addInPlace(this._tmpVector);
                  } else {
                    box.absolutePosition.subtractToRef(this._anchorMesh.position, this._tmpVector);
                    this._anchorMesh.position.subtractInPlace(this._tmpVector);
                    if (this.attachedMesh.isUsingPivotMatrix()) {
                      this._anchorMesh.position.subtractInPlace(this.attachedMesh.getPivotPoint());
                    }
                  }
                  this._anchorMesh.addChild(this.attachedMesh);
                  if (this.incrementalSnap) {
                    fullScale.x /= Math.abs(this._incrementalStartupValue.x) < Epsilon ? 1 : this._incrementalStartupValue.x;
                    fullScale.y /= Math.abs(this._incrementalStartupValue.y) < Epsilon ? 1 : this._incrementalStartupValue.y;
                    fullScale.z /= Math.abs(this._incrementalStartupValue.z) < Epsilon ? 1 : this._incrementalStartupValue.z;
                    fullScale.x = Math.max(this._incrementalAnchorStartupValue.x * fullScale.x, this.scalingSnapDistance);
                    fullScale.y = Math.max(this._incrementalAnchorStartupValue.y * fullScale.y, this.scalingSnapDistance);
                    fullScale.z = Math.max(this._incrementalAnchorStartupValue.z * fullScale.z, this.scalingSnapDistance);
                    this._anchorMesh.scaling.x += (fullScale.x - this._anchorMesh.scaling.x) * Math.abs(dragAxis.x);
                    this._anchorMesh.scaling.y += (fullScale.y - this._anchorMesh.scaling.y) * Math.abs(dragAxis.y);
                    this._anchorMesh.scaling.z += (fullScale.z - this._anchorMesh.scaling.z) * Math.abs(dragAxis.z);
                  } else {
                    this._anchorMesh.scaling.addInPlace(deltaScale);
                    if (this._anchorMesh.scaling.x < 0 || this._anchorMesh.scaling.y < 0 || this._anchorMesh.scaling.z < 0) {
                      this._anchorMesh.scaling.subtractInPlace(deltaScale);
                    }
                  }
                  this._anchorMesh.removeChild(this.attachedMesh);
                  this.attachedMesh.setParent(originalParent);
                  PivotTools._RestorePivotPoint(this.attachedMesh);
                }
                this._updateDummy();
              });
              scaleBoxesDragBehavior.onDragStartObservable.add(() => {
                this.onDragStartObservable.notifyObservers({ dragOperation: 1, dragAxis: new Vector3(i - 1, j - 1, k - 1) });
                this._dragging = true;
                this._selectNode(box);
                totalRelativeDragDistance = 0;
                previousScale = 0;
                this._incrementalStartupValue.copyFrom(this.attachedMesh.scaling);
                this._incrementalAnchorStartupValue.copyFrom(this._anchorMesh.scaling);
              });
              scaleBoxesDragBehavior.onDragEndObservable.add((event) => {
                this.onScaleBoxDragEndObservable.notifyObservers({ dragOperation: 1, dragAxis: new Vector3(i - 1, j - 1, k - 1) });
                this._dragging = false;
                this._selectNode(null);
                this._updateDummy();
                this._unhoverMeshOnTouchUp(event.pointerInfo, box);
              });
              this._scaleBoxesParent.addChild(box);
              this._scaleBoxesDragBehaviors.push(scaleBoxesDragBehavior);
            }
          }
        }
        this._rootMesh.addChild(this._scaleBoxesParent);
        const pointerIds = [];
        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
          if (!pointerIds[pointerInfo.event.pointerId]) {
            const meshes = this._rotateAnchorsParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes());
            for (const mesh of meshes) {
              if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh == mesh) {
                pointerIds[pointerInfo.event.pointerId] = mesh;
                mesh.material = this._hoverColoredMaterial;
                this.onHoverStartObservable.notifyObservers();
                this._isHovered = true;
              }
            }
          } else {
            if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh != pointerIds[pointerInfo.event.pointerId]) {
              pointerIds[pointerInfo.event.pointerId].material = this._coloredMaterial;
              pointerIds.splice(pointerInfo.event.pointerId, 1);
              this.onHoverEndObservable.notifyObservers();
              this._isHovered = false;
            }
          }
        });
        this._renderObserver = this.gizmoLayer.originalScene.onBeforeRenderObservable.add(() => {
          if (this.attachedMesh && !this._existingMeshScale.equals(this.attachedMesh.scaling)) {
            this.updateBoundingBox();
          } else if (this.fixedDragMeshScreenSize || this.fixedDragMeshBoundsSize) {
            this._updateRotationAnchors();
            this._updateScaleBoxes();
          }
          if (this._dragMesh && this.attachedMesh && this._pointerDragBehavior.dragging) {
            this._lineBoundingBox.position.rotateByQuaternionToRef(this._rootMesh.rotationQuaternion, this._tmpVector);
            this.attachedMesh.setAbsolutePosition(this._dragMesh.position.add(this._tmpVector.scale(-1)));
          }
        });
        this.updateBoundingBox();
      }
      _getCornerMesh(gizmoLayer) {
        if (!this._cornerMesh) {
          const boxZ = CreateBox("", { width: 0.4, height: 0.4, depth: 1.6 }, gizmoLayer.utilityLayerScene);
          boxZ.position.z = 0.6;
          const boxY = CreateBox("", { width: 0.4, height: 1.6, depth: 0.4 }, gizmoLayer.utilityLayerScene);
          boxY.position.y = 0.6;
          const boxX = CreateBox("", { width: 1.6, height: 0.4, depth: 0.4 }, gizmoLayer.utilityLayerScene);
          boxX.position.x = 0.6;
          this._cornerMesh = Mesh.MergeMeshes([boxX, boxY, boxZ], true);
          return this._cornerMesh;
        }
        return this._cornerMesh.clone();
      }
      /**
       * returns true if the combination of non uniform scaling and rotation of the attached mesh is not supported
       * In that case, the matrix is skewed and the bounding box gizmo will not work correctly
       * @returns True if the combination is not supported, otherwise false.
       */
      _hasInvalidNonUniformScaling() {
        return this._attachedMesh?.parent instanceof TransformNode && this._attachedMesh?.parent.absoluteScaling.isNonUniformWithinEpsilon(1e-3) && (this._attachedMesh?.rotationQuaternion && !this._attachedMesh?.rotationQuaternion.equalsWithEpsilon(Quaternion.Identity(), Epsilon) || this._attachedMesh?.rotation.equalsWithEpsilon(Vector3.Zero(), Epsilon) === false);
      }
      _attachedNodeChanged(value) {
        if (value) {
          if (this._hasInvalidNonUniformScaling()) {
            Logger.Warn("BoundingBoxGizmo controls are not supported on meshes with non-uniform scaling and rotation");
            return;
          }
          this._anchorMesh.scaling.setAll(1);
          PivotTools._RemoveAndStorePivotPoint(value);
          const originalParent = value.parent;
          this._anchorMesh.addChild(value);
          this._anchorMesh.removeChild(value);
          value.setParent(originalParent);
          PivotTools._RestorePivotPoint(value);
          this.updateBoundingBox();
          const children = value.getChildMeshes(false);
          for (const m of children) {
            m.markAsDirty("scaling");
          }
          this.gizmoLayer.utilityLayerScene.onAfterRenderObservable.addOnce(() => {
            this._updateDummy();
          });
        }
      }
      _selectNode(selectedMesh) {
        const meshes = this._rotateAnchorsParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes());
        for (const m of meshes) {
          m.isVisible = !selectedMesh || m == selectedMesh;
        }
      }
      _unhoverMeshOnTouchUp(pointerInfo, selectedMesh) {
        if (pointerInfo?.event instanceof PointerEvent && pointerInfo?.event.pointerType === "touch") {
          selectedMesh.material = this._coloredMaterial;
        }
      }
      /**
       * returns an array containing all boxes used for scaling (in increasing x, y and z orders)
       * @returns array of scaling boxes
       */
      getScaleBoxes() {
        return this._scaleBoxesParent.getChildMeshes();
      }
      /**
       * Updates the bounding box information for the Gizmo
       */
      updateBoundingBox() {
        if (this.attachedMesh && !this._hasInvalidNonUniformScaling()) {
          PivotTools._RemoveAndStorePivotPoint(this.attachedMesh);
          const originalParent = this.attachedMesh.parent;
          this.attachedMesh.setParent(null);
          this._update();
          if (!this.attachedMesh.rotationQuaternion) {
            this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);
          }
          if (!this._anchorMesh.rotationQuaternion) {
            this._anchorMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._anchorMesh.rotation.y, this._anchorMesh.rotation.x, this._anchorMesh.rotation.z);
          }
          this._anchorMesh.rotationQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);
          this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion);
          this._tmpVector.copyFrom(this.attachedMesh.position);
          this.attachedMesh.rotationQuaternion.set(0, 0, 0, 1);
          this.attachedMesh.position.set(0, 0, 0);
          const boundingMinMax = this.attachedMesh.getHierarchyBoundingVectors(!this.ignoreChildren, this.includeChildPredicate);
          boundingMinMax.max.subtractToRef(boundingMinMax.min, this._boundingDimensions);
          this._lineBoundingBox.scaling.copyFrom(this._boundingDimensions);
          this._lineBoundingBox.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);
          this._rotateAnchorsParent.position.copyFrom(this._lineBoundingBox.position);
          this._scaleBoxesParent.position.copyFrom(this._lineBoundingBox.position);
          this._lineBoundingBox.computeWorldMatrix();
          this._anchorMesh.position.copyFrom(this._lineBoundingBox.absolutePosition);
          this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion);
          this.attachedMesh.position.copyFrom(this._tmpVector);
          this.attachedMesh.setParent(originalParent);
        }
        this._updateRotationAnchors();
        this._updateScaleBoxes();
        if (this.attachedMesh) {
          this._existingMeshScale.copyFrom(this.attachedMesh.scaling);
          PivotTools._RestorePivotPoint(this.attachedMesh);
        }
      }
      _updateRotationAnchors() {
        const rotateAnchors = this._rotateAnchorsParent.getChildMeshes();
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 2; j++) {
            for (let k = 0; k < 2; k++) {
              const index = i * 4 + j * 2 + k;
              rotateAnchors[index].position.normalizeToRef(TmpVectors.Vector3[0]);
              if (i == 0) {
                rotateAnchors[index].position.set(0, this._boundingDimensions.y * (j - 0.5), this._boundingDimensions.z * (k - 0.5));
                TmpVectors.Vector3[1].set(1, 0, 0);
              }
              if (i == 1) {
                rotateAnchors[index].position.set(this._boundingDimensions.x * (j - 0.5), 0, this._boundingDimensions.z * (k - 0.5));
                TmpVectors.Vector3[1].set(0, 1, 0);
              }
              if (i == 2) {
                rotateAnchors[index].position.set(this._boundingDimensions.x * (j - 0.5), this._boundingDimensions.y * (k - 0.5), 0);
                TmpVectors.Vector3[1].set(0, 0, 1);
              }
              const target = TmpVectors.Vector3[2];
              Vector3.CrossToRef(TmpVectors.Vector3[0], TmpVectors.Vector3[1], target);
              target.normalize();
              target.addInPlace(rotateAnchors[index].position);
              rotateAnchors[index].lookAt(target);
              if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {
                rotateAnchors[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position, this._tmpVector);
                const distanceFromCamera = this.rotationSphereSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;
                rotateAnchors[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);
              } else if (this.fixedDragMeshBoundsSize) {
                rotateAnchors[index].scaling.set(this.rotationSphereSize * this._boundingDimensions.x, this.rotationSphereSize * this._boundingDimensions.y, this.rotationSphereSize * this._boundingDimensions.z);
              } else {
                rotateAnchors[index].scaling.set(this.rotationSphereSize, this.rotationSphereSize, this.rotationSphereSize);
              }
            }
          }
        }
      }
      _updateScaleBoxes() {
        const scaleBoxes = this._scaleBoxesParent.getChildMeshes();
        let index = 0;
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            for (let k = 0; k < 3; k++) {
              const zeroAxisCount = (i === 1 ? 1 : 0) + (j === 1 ? 1 : 0) + (k === 1 ? 1 : 0);
              if (zeroAxisCount === 1 || zeroAxisCount === 3) {
                continue;
              }
              if (scaleBoxes[index]) {
                scaleBoxes[index].position.set(this._boundingDimensions.x * (i / 2), this._boundingDimensions.y * (j / 2), this._boundingDimensions.z * (k / 2));
                scaleBoxes[index].position.addInPlace(new Vector3(-this._boundingDimensions.x / 2, -this._boundingDimensions.y / 2, -this._boundingDimensions.z / 2));
                if (this.fixedDragMeshScreenSize && this.gizmoLayer.utilityLayerScene.activeCamera) {
                  scaleBoxes[index].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.globalPosition, this._tmpVector);
                  const distanceFromCamera = this.scaleBoxSize * this._tmpVector.length() / this.fixedDragMeshScreenSizeDistanceFactor;
                  scaleBoxes[index].scaling.set(distanceFromCamera, distanceFromCamera, distanceFromCamera);
                } else if (this.fixedDragMeshBoundsSize) {
                  scaleBoxes[index].scaling.set(this.scaleBoxSize * this._boundingDimensions.x, this.scaleBoxSize * this._boundingDimensions.y, this.scaleBoxSize * this._boundingDimensions.z);
                } else {
                  scaleBoxes[index].scaling.set(this.scaleBoxSize, this.scaleBoxSize, this.scaleBoxSize);
                }
              }
              index++;
            }
          }
        }
      }
      /**
       * Enables rotation on the specified axis and disables rotation on the others
       * @param axis The list of axis that should be enabled (eg. "xy" or "xyz")
       */
      setEnabledRotationAxis(axis) {
        const meshes = this._rotateAnchorsParent.getChildMeshes();
        for (let i = 0; i < meshes.length; i++) {
          const m = meshes[i];
          if (i < 4) {
            m.setEnabled(axis.indexOf("x") != -1);
          } else if (i < 8) {
            m.setEnabled(axis.indexOf("y") != -1);
          } else {
            m.setEnabled(axis.indexOf("z") != -1);
          }
        }
      }
      /**
       * Enables/disables scaling
       * @param enable if scaling should be enabled
       * @param homogeneousScaling defines if scaling should only be homogeneous
       */
      setEnabledScaling(enable, homogeneousScaling = false) {
        const meshes = this._scaleBoxesParent.getChildMeshes();
        for (const m of meshes) {
          let enableMesh = enable;
          if (homogeneousScaling && m._internalMetadata === true) {
            enableMesh = false;
          }
          m.setEnabled(enableMesh);
        }
      }
      _updateDummy() {
        if (this._dragMesh) {
          this._dragMesh.position.copyFrom(this._lineBoundingBox.getAbsolutePosition());
          this._dragMesh.scaling.copyFrom(this._lineBoundingBox.scaling);
          this._dragMesh.rotationQuaternion.copyFrom(this._rootMesh.rotationQuaternion);
        }
      }
      /**
       * Enables a pointer drag behavior on the bounding box of the gizmo
       */
      enableDragBehavior() {
        this._dragMesh = CreateBox("dummy", { size: 1 }, this.gizmoLayer.utilityLayerScene);
        this._dragMesh.visibility = 0;
        this._dragMesh.rotationQuaternion = new Quaternion();
        this._pointerDragBehavior.useObjectOrientationForDragging = false;
        this._dragMesh.addBehavior(this._pointerDragBehavior);
      }
      /**
       * Force release the drag action by code
       */
      releaseDrag() {
        for (const dragBehavior of this._scaleBoxesDragBehaviors) {
          dragBehavior.releaseDrag();
        }
        for (const dragBehavior of this._rotateAnchorsDragBehaviors) {
          dragBehavior.releaseDrag();
        }
        this._pointerDragBehavior.releaseDrag();
      }
      /**
       * Disposes of the gizmo
       */
      dispose() {
        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
        this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver);
        this._lineBoundingBox.dispose();
        this._rotateAnchorsParent.dispose();
        this._scaleBoxesParent.dispose();
        if (this._dragMesh) {
          this._dragMesh.dispose();
        }
        this._scaleBoxesDragBehaviors.length = 0;
        this._rotateAnchorsDragBehaviors.length = 0;
        this.onDragStartObservable.clear();
        this.onHoverStartObservable.clear();
        this.onHoverEndObservable.clear();
        this.onScaleBoxDragObservable.clear();
        this.onScaleBoxDragEndObservable.clear();
        this.onRotationSphereDragObservable.clear();
        this.onRotationSphereDragEndObservable.clear();
        this._coloredMaterial.dispose();
        this._hoverColoredMaterial.dispose();
        super.dispose();
      }
      /**
       * Makes a mesh not pickable and wraps the mesh inside of a bounding box mesh that is pickable. (This is useful to avoid picking within complex geometry)
       * @param mesh the mesh to wrap in the bounding box mesh and make not pickable
       * @returns the bounding box mesh with the passed in mesh as a child
       */
      static MakeNotPickableAndWrapInBoundingBox(mesh) {
        const makeNotPickable = (root) => {
          root.isPickable = false;
          const children = root.getChildMeshes();
          for (const c of children) {
            makeNotPickable(c);
          }
        };
        makeNotPickable(mesh);
        if (!mesh.rotationQuaternion) {
          mesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(mesh.rotation.y, mesh.rotation.x, mesh.rotation.z);
        }
        const oldPos = mesh.position.clone();
        const oldRot = mesh.rotationQuaternion.clone();
        mesh.rotationQuaternion.set(0, 0, 0, 1);
        mesh.position.set(0, 0, 0);
        const box = CreateBox("box", { size: 1 }, mesh.getScene());
        const boundingMinMax = mesh.getHierarchyBoundingVectors();
        boundingMinMax.max.subtractToRef(boundingMinMax.min, box.scaling);
        if (box.scaling.y === 0) {
          box.scaling.y = Epsilon;
        }
        if (box.scaling.x === 0) {
          box.scaling.x = Epsilon;
        }
        if (box.scaling.z === 0) {
          box.scaling.z = Epsilon;
        }
        box.position.set((boundingMinMax.max.x + boundingMinMax.min.x) / 2, (boundingMinMax.max.y + boundingMinMax.min.y) / 2, (boundingMinMax.max.z + boundingMinMax.min.z) / 2);
        mesh.addChild(box);
        mesh.rotationQuaternion.copyFrom(oldRot);
        mesh.position.copyFrom(oldPos);
        mesh.removeChild(box);
        box.addChild(mesh);
        box.visibility = 0;
        return box;
      }
      /**
       * CustomMeshes are not supported by this gizmo
       */
      setCustomMesh() {
        Logger.Error("Custom meshes are not supported on this gizmo");
      }
    };
  }
});

// node_modules/@babylonjs/core/Gizmos/planeRotationGizmo.js
var PlaneRotationGizmo;
var init_planeRotationGizmo = __esm({
  "node_modules/@babylonjs/core/Gizmos/planeRotationGizmo.js"() {
    init_observable();
    init_math_vector();
    init_math_color();
    init_linesBuilder();
    init_mesh();
    init_pointerDragBehavior();
    init_gizmo();
    init_utilityLayerRenderer();
    init_standardMaterial();
    init_shaderMaterial();
    init_effect();
    init_planeBuilder();
    init_torusBuilder();
    init_math_constants();
    init_logger();
    PlaneRotationGizmo = class _PlaneRotationGizmo extends Gizmo {
      /** Default material used to render when gizmo is not disabled or hovered */
      get coloredMaterial() {
        return this._coloredMaterial;
      }
      /** Material used to render when gizmo is hovered with mouse */
      get hoverMaterial() {
        return this._hoverMaterial;
      }
      /** Color used to render the drag angle sector when gizmo is rotated with mouse */
      set rotationColor(color) {
        this._rotationShaderMaterial.setColor3("rotationColor", color);
      }
      /** Material used to render when gizmo is disabled. typically grey. */
      get disableMaterial() {
        return this._disableMaterial;
      }
      /**
       * Creates a PlaneRotationGizmo
       * @param planeNormal The normal of the plane which the gizmo will be able to rotate on
       * @param color The color of the gizmo
       * @param gizmoLayer The utility layer the gizmo will be added to
       * @param tessellation Amount of tessellation to be used when creating rotation circles
       * @param parent
       * @param useEulerRotation Use and update Euler angle instead of quaternion
       * @param thickness display gizmo axis thickness
       * @param hoverColor The color of the gizmo when hovering over and dragging
       * @param disableColor The Color of the gizmo when its disabled
       */
      constructor(planeNormal, color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, tessellation = 32, parent = null, useEulerRotation = false, thickness = 1, hoverColor = Color3.Yellow(), disableColor = Color3.Gray()) {
        super(gizmoLayer);
        this._pointerObserver = null;
        this.snapDistance = 0;
        this.onSnapObservable = new Observable();
        this.angle = 0;
        this.sensitivity = 1;
        this._isEnabled = true;
        this._parent = null;
        this._dragging = false;
        this._angles = new Vector3();
        this._parent = parent;
        this._coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        this._coloredMaterial.diffuseColor = color;
        this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));
        this._hoverMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        this._hoverMaterial.diffuseColor = hoverColor;
        this._hoverMaterial.specularColor = hoverColor;
        this._disableMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        this._disableMaterial.diffuseColor = disableColor;
        this._disableMaterial.alpha = 0.4;
        this._gizmoMesh = new Mesh("", gizmoLayer.utilityLayerScene);
        const { rotationMesh, collider } = this._createGizmoMesh(this._gizmoMesh, thickness, tessellation);
        this._rotationDisplayPlane = CreatePlane("rotationDisplay", {
          size: 0.6,
          updatable: false
        }, this.gizmoLayer.utilityLayerScene);
        this._rotationDisplayPlane.rotation.z = Math.PI * 0.5;
        this._rotationDisplayPlane.parent = this._gizmoMesh;
        this._rotationDisplayPlane.setEnabled(false);
        Effect.ShadersStore["rotationGizmoVertexShader"] = _PlaneRotationGizmo._RotationGizmoVertexShader;
        Effect.ShadersStore["rotationGizmoFragmentShader"] = _PlaneRotationGizmo._RotationGizmoFragmentShader;
        this._rotationShaderMaterial = new ShaderMaterial("shader", this.gizmoLayer.utilityLayerScene, {
          vertex: "rotationGizmo",
          fragment: "rotationGizmo"
        }, {
          attributes: ["position", "uv"],
          uniforms: ["worldViewProjection", "angles", "rotationColor"]
        });
        this._rotationShaderMaterial.backFaceCulling = false;
        this.rotationColor = hoverColor;
        this._rotationDisplayPlane.material = this._rotationShaderMaterial;
        this._rotationDisplayPlane.visibility = 0.999;
        this._gizmoMesh.lookAt(this._rootMesh.position.add(planeNormal));
        this._rootMesh.addChild(this._gizmoMesh, Gizmo.PreserveScaling);
        this._gizmoMesh.scaling.scaleInPlace(1 / 3);
        this.dragBehavior = new PointerDragBehavior({ dragPlaneNormal: planeNormal });
        this.dragBehavior.moveAttached = false;
        this.dragBehavior.maxDragAngle = _PlaneRotationGizmo.MaxDragAngle;
        this.dragBehavior._useAlternatePickedPointAboveMaxDragAngle = true;
        this._rootMesh.addBehavior(this.dragBehavior);
        const lastDragPosition = new Vector3();
        const rotationMatrix = new Matrix();
        const planeNormalTowardsCamera = new Vector3();
        let localPlaneNormalTowardsCamera = new Vector3();
        this.dragBehavior.onDragStartObservable.add((e) => {
          if (this.attachedNode) {
            lastDragPosition.copyFrom(e.dragPlanePoint);
            this._rotationDisplayPlane.setEnabled(true);
            this._rotationDisplayPlane.getWorldMatrix().invertToRef(rotationMatrix);
            Vector3.TransformCoordinatesToRef(e.dragPlanePoint, rotationMatrix, lastDragPosition);
            this._angles.x = Math.atan2(lastDragPosition.y, lastDragPosition.x) + Math.PI;
            this._angles.y = 0;
            this._angles.z = this.updateGizmoRotationToMatchAttachedMesh ? 1 : 0;
            this._dragging = true;
            lastDragPosition.copyFrom(e.dragPlanePoint);
            this._rotationShaderMaterial.setVector3("angles", this._angles);
            this.angle = 0;
          }
        });
        this.dragBehavior.onDragEndObservable.add(() => {
          this._dragging = false;
          this._rotationDisplayPlane.setEnabled(false);
        });
        const tmpSnapEvent = { snapDistance: 0 };
        let currentSnapDragDistance = 0;
        const tmpMatrix = new Matrix();
        const amountToRotate = new Quaternion();
        this.dragBehavior.onDragObservable.add((event) => {
          if (this.attachedNode) {
            const nodeScale = new Vector3(1, 1, 1);
            const nodeQuaternion = new Quaternion(0, 0, 0, 1);
            const nodeTranslation = new Vector3(0, 0, 0);
            const attachedNodeTransform = this._attachedNode;
            if (attachedNodeTransform && attachedNodeTransform.isUsingPivotMatrix && attachedNodeTransform.isUsingPivotMatrix() && attachedNodeTransform.position) {
              attachedNodeTransform.getWorldMatrix().setTranslation(attachedNodeTransform.position);
            }
            this.attachedNode.getWorldMatrix().decompose(nodeScale, nodeQuaternion, nodeTranslation);
            const uniformScaling = Math.abs(Math.abs(nodeScale.x) - Math.abs(nodeScale.y)) <= Epsilon && Math.abs(Math.abs(nodeScale.x) - Math.abs(nodeScale.z)) <= Epsilon;
            if (!uniformScaling && this.updateGizmoRotationToMatchAttachedMesh) {
              Logger.Warn("Unable to use a rotation gizmo matching mesh rotation with non uniform scaling. Use uniform scaling or set updateGizmoRotationToMatchAttachedMesh to false.");
              return;
            }
            nodeQuaternion.normalize();
            const nodeTranslationForOperation = this.updateGizmoPositionToMatchAttachedMesh ? nodeTranslation : this._rootMesh.absolutePosition;
            const newVector = event.dragPlanePoint.subtract(nodeTranslationForOperation).normalize();
            const originalVector = lastDragPosition.subtract(nodeTranslationForOperation).normalize();
            const cross = Vector3.Cross(newVector, originalVector);
            const dot = Vector3.Dot(newVector, originalVector);
            let angle = Math.atan2(cross.length(), dot) * this.sensitivity;
            planeNormalTowardsCamera.copyFrom(planeNormal);
            localPlaneNormalTowardsCamera.copyFrom(planeNormal);
            if (this.updateGizmoRotationToMatchAttachedMesh) {
              nodeQuaternion.toRotationMatrix(rotationMatrix);
              localPlaneNormalTowardsCamera = Vector3.TransformCoordinates(planeNormalTowardsCamera, rotationMatrix);
            }
            let cameraFlipped = false;
            if (gizmoLayer.utilityLayerScene.activeCamera) {
              const camVec = gizmoLayer.utilityLayerScene.activeCamera.position.subtract(nodeTranslationForOperation).normalize();
              if (Vector3.Dot(camVec, localPlaneNormalTowardsCamera) > 0) {
                planeNormalTowardsCamera.scaleInPlace(-1);
                localPlaneNormalTowardsCamera.scaleInPlace(-1);
                cameraFlipped = true;
              }
            }
            const halfCircleSide = Vector3.Dot(localPlaneNormalTowardsCamera, cross) > 0;
            if (halfCircleSide) {
              angle = -angle;
            }
            TmpVectors.Vector3[0].set(angle, 0, 0);
            if (!this.dragBehavior.validateDrag(TmpVectors.Vector3[0])) {
              angle = 0;
            }
            let snapped = false;
            if (this.snapDistance != 0) {
              currentSnapDragDistance += angle;
              if (Math.abs(currentSnapDragDistance) > this.snapDistance) {
                let dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);
                if (currentSnapDragDistance < 0) {
                  dragSteps *= -1;
                }
                currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;
                angle = this.snapDistance * dragSteps;
                snapped = true;
              } else {
                angle = 0;
              }
            }
            const quaternionCoefficient = Math.sin(angle / 2);
            amountToRotate.set(planeNormalTowardsCamera.x * quaternionCoefficient, planeNormalTowardsCamera.y * quaternionCoefficient, planeNormalTowardsCamera.z * quaternionCoefficient, Math.cos(angle / 2));
            if (tmpMatrix.determinant() > 0) {
              const tmpVector = new Vector3();
              amountToRotate.toEulerAnglesToRef(tmpVector);
              Quaternion.RotationYawPitchRollToRef(tmpVector.y, -tmpVector.x, -tmpVector.z, amountToRotate);
            }
            if (this.updateGizmoRotationToMatchAttachedMesh) {
              nodeQuaternion.multiplyToRef(amountToRotate, nodeQuaternion);
              nodeQuaternion.normalize();
              Matrix.ComposeToRef(nodeScale, nodeQuaternion, nodeTranslation, this.attachedNode.getWorldMatrix());
            } else {
              amountToRotate.toRotationMatrix(TmpVectors.Matrix[0]);
              const translation = this.attachedNode.getWorldMatrix().getTranslation();
              this.attachedNode.getWorldMatrix().multiplyToRef(TmpVectors.Matrix[0], this.attachedNode.getWorldMatrix());
              this.attachedNode.getWorldMatrix().setTranslation(translation);
            }
            lastDragPosition.copyFrom(event.dragPlanePoint);
            if (snapped) {
              tmpSnapEvent.snapDistance = angle;
              this.onSnapObservable.notifyObservers(tmpSnapEvent);
            }
            this._angles.y += gizmoLayer.utilityLayerScene.useRightHandedSystem ? -angle : angle;
            this.angle += cameraFlipped ? -angle : angle;
            this._rotationShaderMaterial.setVector3("angles", this._angles);
            this._matrixChanged();
          }
        });
        const light = gizmoLayer._getSharedGizmoLight();
        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));
        const cache = {
          colliderMeshes: [collider],
          gizmoMeshes: [rotationMesh],
          material: this._coloredMaterial,
          hoverMaterial: this._hoverMaterial,
          disableMaterial: this._disableMaterial,
          active: false,
          dragBehavior: this.dragBehavior
        };
        this._parent?.addToAxisCache(this._gizmoMesh, cache);
        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
          if (this._customMeshSet) {
            return;
          }
          this.dragBehavior.maxDragAngle = _PlaneRotationGizmo.MaxDragAngle;
          this._isHovered = !!(cache.colliderMeshes.indexOf(pointerInfo?.pickInfo?.pickedMesh) != -1);
          if (!this._parent) {
            const material = cache.dragBehavior.enabled ? this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial : this._disableMaterial;
            this._setGizmoMeshMaterial(cache.gizmoMeshes, material);
          }
        });
        this.dragBehavior.onEnabledObservable.add((newState) => {
          this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? this._coloredMaterial : this._disableMaterial);
        });
      }
      /**
       * @internal
       * Create Geometry for Gizmo
       * @param parentMesh
       * @param thickness
       * @param tessellation
       * @returns
       */
      _createGizmoMesh(parentMesh, thickness, tessellation) {
        const collider = CreateTorus("ignore", {
          diameter: 0.6,
          thickness: 0.03 * thickness,
          tessellation
        }, this.gizmoLayer.utilityLayerScene);
        collider.visibility = 0;
        const rotationMesh = CreateTorus("", {
          diameter: 0.6,
          thickness: 5e-3 * thickness,
          tessellation
        }, this.gizmoLayer.utilityLayerScene);
        rotationMesh.material = this._coloredMaterial;
        rotationMesh.rotation.x = Math.PI / 2;
        collider.rotation.x = Math.PI / 2;
        parentMesh.addChild(rotationMesh, Gizmo.PreserveScaling);
        parentMesh.addChild(collider, Gizmo.PreserveScaling);
        return { rotationMesh, collider };
      }
      _attachedNodeChanged(value) {
        if (this.dragBehavior) {
          this.dragBehavior.enabled = value ? true : false;
        }
      }
      /**
       * If the gizmo is enabled
       */
      set isEnabled(value) {
        this._isEnabled = value;
        if (!value) {
          this.attachedMesh = null;
        } else {
          if (this._parent) {
            this.attachedMesh = this._parent.attachedMesh;
          }
        }
      }
      get isEnabled() {
        return this._isEnabled;
      }
      /**
       * Disposes of the gizmo
       */
      dispose() {
        this.onSnapObservable.clear();
        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
        this.dragBehavior.detach();
        if (this._gizmoMesh) {
          this._gizmoMesh.dispose();
        }
        if (this._rotationDisplayPlane) {
          this._rotationDisplayPlane.dispose();
        }
        if (this._rotationShaderMaterial) {
          this._rotationShaderMaterial.dispose();
        }
        const materials = [this._coloredMaterial, this._hoverMaterial, this._disableMaterial];
        for (const matl of materials) {
          if (matl) {
            matl.dispose();
          }
        }
        super.dispose();
      }
    };
    PlaneRotationGizmo.MaxDragAngle = Math.PI * 9 / 20;
    PlaneRotationGizmo._RotationGizmoVertexShader = `
        precision highp float;
        attribute vec3 position;
        attribute vec2 uv;
        uniform mat4 worldViewProjection;
        varying vec3 vPosition;
        varying vec2 vUV;

        void main(void) {
            gl_Position = worldViewProjection * vec4(position, 1.0);
            vUV = uv;
        }`;
    PlaneRotationGizmo._RotationGizmoFragmentShader = `
        precision highp float;
        varying vec2 vUV;
        varying vec3 vPosition;
        uniform vec3 angles;
        uniform vec3 rotationColor;

        #define twopi 6.283185307

        void main(void) {
            vec2 uv = vUV - vec2(0.5);
            float angle = atan(uv.y, uv.x) + 3.141592;
            float delta = gl_FrontFacing ? angles.y : -angles.y;
            float begin = angles.x - delta * angles.z;
            float start = (begin < (begin + delta)) ? begin : (begin + delta);
            float end = (begin > (begin + delta)) ? begin : (begin + delta);
            float len = sqrt(dot(uv,uv));
            float opacity = 1. - step(0.5, len);

            float base = abs(floor(start / twopi)) * twopi;
            start += base;
            end += base;

            float intensity = 0.;
            for (int i = 0; i < 5; i++)
            {
                intensity += max(step(start, angle) - step(end, angle), 0.);
                angle += twopi;
            }
            gl_FragColor = vec4(rotationColor, min(intensity * 0.25, 0.8)) * opacity;
        }
    `;
  }
});

// node_modules/@babylonjs/core/Gizmos/rotationGizmo.js
var RotationGizmo;
var init_rotationGizmo = __esm({
  "node_modules/@babylonjs/core/Gizmos/rotationGizmo.js"() {
    init_logger();
    init_observable();
    init_math_vector();
    init_math_color();
    init_gizmo();
    init_planeRotationGizmo();
    init_utilityLayerRenderer();
    RotationGizmo = class extends Gizmo {
      get attachedMesh() {
        return this._meshAttached;
      }
      set attachedMesh(mesh) {
        this._meshAttached = mesh;
        this._nodeAttached = mesh;
        this._checkBillboardTransform();
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo];
        for (const gizmo of gizmos) {
          if (gizmo.isEnabled) {
            gizmo.attachedMesh = mesh;
          } else {
            gizmo.attachedMesh = null;
          }
        }
      }
      get attachedNode() {
        return this._nodeAttached;
      }
      set attachedNode(node) {
        this._meshAttached = null;
        this._nodeAttached = node;
        this._checkBillboardTransform();
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo];
        for (const gizmo of gizmos) {
          if (gizmo.isEnabled) {
            gizmo.attachedNode = node;
          } else {
            gizmo.attachedNode = null;
          }
        }
      }
      _checkBillboardTransform() {
        if (this._nodeAttached && this._nodeAttached.billboardMode) {
          Logger.Log("Rotation Gizmo will not work with transforms in billboard mode.");
        }
      }
      /**
       * Sensitivity factor for dragging (Default: 1)
       */
      set sensitivity(value) {
        this._sensitivity = value;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.sensitivity = value;
          }
        }
      }
      get sensitivity() {
        return this._sensitivity;
      }
      /**
       * True when the mouse pointer is hovering a gizmo mesh
       */
      get isHovered() {
        return this.xGizmo.isHovered || this.yGizmo.isHovered || this.zGizmo.isHovered;
      }
      /**
       * True when the mouse pointer is dragging a gizmo mesh
       */
      get isDragging() {
        return this.xGizmo.dragBehavior.dragging || this.yGizmo.dragBehavior.dragging || this.zGizmo.dragBehavior.dragging;
      }
      get additionalTransformNode() {
        return this._additionalTransformNode;
      }
      set additionalTransformNode(transformNode) {
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo];
        for (const gizmo of gizmos) {
          gizmo.additionalTransformNode = transformNode;
        }
      }
      /**
       * Creates a RotationGizmo
       * @param gizmoLayer The utility layer the gizmo will be added to
       * @param tessellation Amount of tessellation to be used when creating rotation circles
       * @param useEulerRotation Use and update Euler angle instead of quaternion
       * @param thickness display gizmo axis thickness
       * @param gizmoManager Gizmo manager
       * @param options More options
       */
      constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, tessellation = 32, useEulerRotation = false, thickness = 1, gizmoManager, options) {
        super(gizmoLayer);
        this.onDragStartObservable = new Observable();
        this.onDragObservable = new Observable();
        this.onDragEndObservable = new Observable();
        this._observables = [];
        this._sensitivity = 1;
        this._gizmoAxisCache = /* @__PURE__ */ new Map();
        const xColor = options && options.xOptions && options.xOptions.color ? options.xOptions.color : Color3.Red().scale(0.5);
        const yColor = options && options.yOptions && options.yOptions.color ? options.yOptions.color : Color3.Green().scale(0.5);
        const zColor = options && options.zOptions && options.zOptions.color ? options.zOptions.color : Color3.Blue().scale(0.5);
        this.xGizmo = new PlaneRotationGizmo(new Vector3(1, 0, 0), xColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);
        this.yGizmo = new PlaneRotationGizmo(new Vector3(0, 1, 0), yColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);
        this.zGizmo = new PlaneRotationGizmo(new Vector3(0, 0, 1), zColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);
        this.additionalTransformNode = options?.additionalTransformNode;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo];
        for (const gizmo of gizmos) {
          if (options && options.updateScale != void 0) {
            gizmo.updateScale = options.updateScale;
          }
          gizmo.dragBehavior.onDragStartObservable.add((eventData, eventState) => this.onDragStartObservable.notifyObservers(eventData, eventState.mask, eventState.target, eventState.currentTarget, eventState.userInfo));
          gizmo.dragBehavior.onDragObservable.add((eventData, eventState) => this.onDragObservable.notifyObservers(eventData, eventState.mask, eventState.target, eventState.currentTarget, eventState.userInfo));
          gizmo.dragBehavior.onDragEndObservable.add((eventData, eventState) => this.onDragEndObservable.notifyObservers(eventData, eventState.mask, eventState.target, eventState.currentTarget, eventState.userInfo));
        }
        this.attachedMesh = null;
        this.attachedNode = null;
        if (gizmoManager) {
          gizmoManager.addToAxisCache(this._gizmoAxisCache);
        } else {
          Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);
        }
      }
      /**
       * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)
       * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation
       */
      set updateGizmoRotationToMatchAttachedMesh(value) {
        if (this.xGizmo) {
          this.xGizmo.updateGizmoRotationToMatchAttachedMesh = value;
          this.yGizmo.updateGizmoRotationToMatchAttachedMesh = value;
          this.zGizmo.updateGizmoRotationToMatchAttachedMesh = value;
        }
      }
      get updateGizmoRotationToMatchAttachedMesh() {
        return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;
      }
      set updateGizmoPositionToMatchAttachedMesh(value) {
        if (this.xGizmo) {
          this.xGizmo.updateGizmoPositionToMatchAttachedMesh = value;
          this.yGizmo.updateGizmoPositionToMatchAttachedMesh = value;
          this.zGizmo.updateGizmoPositionToMatchAttachedMesh = value;
        }
      }
      get updateGizmoPositionToMatchAttachedMesh() {
        return this.xGizmo.updateGizmoPositionToMatchAttachedMesh;
      }
      set anchorPoint(value) {
        this._anchorPoint = value;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo];
        for (const gizmo of gizmos) {
          gizmo.anchorPoint = value;
        }
      }
      get anchorPoint() {
        return this._anchorPoint;
      }
      /**
       * Set the coordinate system to use. By default it's local.
       * But it's possible for a user to tweak so its local for translation and world for rotation.
       * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`
       */
      set coordinatesMode(coordinatesMode) {
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo];
        for (const gizmo of gizmos) {
          gizmo.coordinatesMode = coordinatesMode;
        }
      }
      set updateScale(value) {
        if (this.xGizmo) {
          this.xGizmo.updateScale = value;
          this.yGizmo.updateScale = value;
          this.zGizmo.updateScale = value;
        }
      }
      get updateScale() {
        return this.xGizmo.updateScale;
      }
      /**
       * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
       */
      set snapDistance(value) {
        if (this.xGizmo) {
          this.xGizmo.snapDistance = value;
          this.yGizmo.snapDistance = value;
          this.zGizmo.snapDistance = value;
        }
      }
      get snapDistance() {
        return this.xGizmo.snapDistance;
      }
      /**
       * Ratio for the scale of the gizmo (Default: 1)
       */
      set scaleRatio(value) {
        if (this.xGizmo) {
          this.xGizmo.scaleRatio = value;
          this.yGizmo.scaleRatio = value;
          this.zGizmo.scaleRatio = value;
        }
      }
      get scaleRatio() {
        return this.xGizmo.scaleRatio;
      }
      /**
       * posture that the gizmo will be display
       * When set null, default value will be used (Quaternion(0, 0, 0, 1))
       */
      get customRotationQuaternion() {
        return this._customRotationQuaternion;
      }
      set customRotationQuaternion(customRotationQuaternion) {
        this._customRotationQuaternion = customRotationQuaternion;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.customRotationQuaternion = customRotationQuaternion;
          }
        }
      }
      /**
       * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation
       * @param mesh Axis gizmo mesh
       * @param cache Gizmo axis definition used for reactive gizmo UI
       */
      addToAxisCache(mesh, cache) {
        this._gizmoAxisCache.set(mesh, cache);
      }
      /**
       * Force release the drag action by code
       */
      releaseDrag() {
        this.xGizmo.dragBehavior.releaseDrag();
        this.yGizmo.dragBehavior.releaseDrag();
        this.zGizmo.dragBehavior.releaseDrag();
      }
      /**
       * Disposes of the gizmo
       */
      dispose() {
        this.xGizmo.dispose();
        this.yGizmo.dispose();
        this.zGizmo.dispose();
        this.onDragStartObservable.clear();
        this.onDragObservable.clear();
        this.onDragEndObservable.clear();
        for (const obs of this._observables) {
          this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);
        }
        super.dispose();
      }
      /**
       * CustomMeshes are not supported by this gizmo
       */
      setCustomMesh() {
        Logger.Error("Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo)");
      }
    };
  }
});

// node_modules/@babylonjs/core/Gizmos/planeDragGizmo.js
var PlaneDragGizmo;
var init_planeDragGizmo = __esm({
  "node_modules/@babylonjs/core/Gizmos/planeDragGizmo.js"() {
    init_observable();
    init_math_vector();
    init_math_color();
    init_transformNode();
    init_planeBuilder();
    init_pointerDragBehavior();
    init_gizmo();
    init_utilityLayerRenderer();
    init_standardMaterial();
    PlaneDragGizmo = class _PlaneDragGizmo extends Gizmo {
      /** Default material used to render when gizmo is not disabled or hovered */
      get coloredMaterial() {
        return this._coloredMaterial;
      }
      /** Material used to render when gizmo is hovered with mouse*/
      get hoverMaterial() {
        return this._hoverMaterial;
      }
      /** Material used to render when gizmo is disabled. typically grey.*/
      get disableMaterial() {
        return this._disableMaterial;
      }
      /**
       * @internal
       */
      static _CreatePlane(scene, material) {
        const plane = new TransformNode("plane", scene);
        const dragPlane = CreatePlane("dragPlane", { width: 0.1375, height: 0.1375, sideOrientation: 2 }, scene);
        dragPlane.material = material;
        dragPlane.parent = plane;
        return plane;
      }
      /**
       * Creates a PlaneDragGizmo
       * @param dragPlaneNormal The axis normal to which the gizmo will be able to drag on
       * @param color The color of the gizmo
       * @param gizmoLayer The utility layer the gizmo will be added to
       * @param parent
       * @param hoverColor The color of the gizmo when hovering over and dragging
       * @param disableColor The Color of the gizmo when its disabled
       */
      constructor(dragPlaneNormal, color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, parent = null, hoverColor = Color3.Yellow(), disableColor = Color3.Gray()) {
        super(gizmoLayer);
        this._pointerObserver = null;
        this.snapDistance = 0;
        this.onSnapObservable = new Observable();
        this._isEnabled = false;
        this._parent = null;
        this._dragging = false;
        this._parent = parent;
        this._coloredMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        this._coloredMaterial.diffuseColor = color;
        this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));
        this._hoverMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        this._hoverMaterial.diffuseColor = hoverColor;
        this._disableMaterial = new StandardMaterial("", gizmoLayer.utilityLayerScene);
        this._disableMaterial.diffuseColor = disableColor;
        this._disableMaterial.alpha = 0.4;
        this._gizmoMesh = _PlaneDragGizmo._CreatePlane(gizmoLayer.utilityLayerScene, this._coloredMaterial);
        this._gizmoMesh.lookAt(this._rootMesh.position.add(dragPlaneNormal));
        this._gizmoMesh.scaling.scaleInPlace(1 / 3);
        this._gizmoMesh.parent = this._rootMesh;
        const currentSnapDragDistance = new Vector3();
        const tmpVector = new Vector3();
        const tmpVector2 = new Vector3();
        const tmpSnapEvent = { snapDistance: 0 };
        this.dragBehavior = new PointerDragBehavior({ dragPlaneNormal });
        this.dragBehavior.moveAttached = false;
        this._rootMesh.addBehavior(this.dragBehavior);
        this.dragBehavior.onDragObservable.add((event) => {
          if (this.attachedNode) {
            if (this.snapDistance == 0) {
              this.attachedNode.getWorldMatrix().getTranslationToRef(TmpVectors.Vector3[0]);
              TmpVectors.Vector3[0].addToRef(event.delta, TmpVectors.Vector3[0]);
              if (this.dragBehavior.validateDrag(TmpVectors.Vector3[0])) {
                this.attachedNode.getWorldMatrix().addTranslationFromFloats(event.delta.x, event.delta.y, event.delta.z);
              }
            } else {
              currentSnapDragDistance.addInPlace(event.delta);
              tmpVector2.set(0, 0, 0);
              const currentSnapDragDistanceArray = currentSnapDragDistance.asArray();
              for (let axis = 0; axis < 3; axis++) {
                const axisDistance = currentSnapDragDistanceArray[axis];
                if (Math.abs(axisDistance) > this.snapDistance) {
                  const dragSteps = (axisDistance < 0 ? Math.ceil : Math.floor)(axisDistance / this.snapDistance);
                  currentSnapDragDistanceArray[axis] = currentSnapDragDistanceArray[axis] % this.snapDistance;
                  tmpVector.set(axis == 0 ? 1 : 0, axis == 1 ? 1 : 0, axis == 2 ? 1 : 0);
                  tmpVector.scaleInPlace(this.snapDistance * dragSteps);
                  tmpVector2.addInPlace(tmpVector);
                }
              }
              currentSnapDragDistance.fromArray(currentSnapDragDistanceArray);
              this.attachedNode.getWorldMatrix().getTranslationToRef(TmpVectors.Vector3[0]);
              TmpVectors.Vector3[0].addToRef(tmpVector2, TmpVectors.Vector3[0]);
              if (this.dragBehavior.validateDrag(TmpVectors.Vector3[0])) {
                this.attachedNode.getWorldMatrix().addTranslationFromFloats(tmpVector2.x, tmpVector2.y, tmpVector2.z);
                tmpSnapEvent.snapDistance = tmpVector2.length();
                this.onSnapObservable.notifyObservers(tmpSnapEvent);
              }
            }
            this._matrixChanged();
          }
        });
        this.dragBehavior.onDragStartObservable.add(() => {
          this._dragging = true;
        });
        this.dragBehavior.onDragEndObservable.add(() => {
          this._dragging = false;
        });
        const light = gizmoLayer._getSharedGizmoLight();
        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));
        const cache = {
          gizmoMeshes: this._gizmoMesh.getChildMeshes(),
          colliderMeshes: this._gizmoMesh.getChildMeshes(),
          material: this._coloredMaterial,
          hoverMaterial: this._hoverMaterial,
          disableMaterial: this._disableMaterial,
          active: false,
          dragBehavior: this.dragBehavior
        };
        this._parent?.addToAxisCache(this._gizmoMesh, cache);
        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
          if (this._customMeshSet) {
            return;
          }
          this._isHovered = !!(cache.colliderMeshes.indexOf(pointerInfo?.pickInfo?.pickedMesh) != -1);
          if (!this._parent) {
            const material = cache.dragBehavior.enabled ? this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial : this._disableMaterial;
            this._setGizmoMeshMaterial(cache.gizmoMeshes, material);
          }
        });
        this.dragBehavior.onEnabledObservable.add((newState) => {
          this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? this._coloredMaterial : this._disableMaterial);
        });
      }
      _attachedNodeChanged(value) {
        if (this.dragBehavior) {
          this.dragBehavior.enabled = value ? true : false;
        }
      }
      /**
       * If the gizmo is enabled
       */
      set isEnabled(value) {
        this._isEnabled = value;
        if (!value) {
          this.attachedNode = null;
        } else {
          if (this._parent) {
            this.attachedNode = this._parent.attachedNode;
          }
        }
      }
      get isEnabled() {
        return this._isEnabled;
      }
      /**
       * Disposes of the gizmo
       */
      dispose() {
        this.onSnapObservable.clear();
        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
        this.dragBehavior.detach();
        super.dispose();
        if (this._gizmoMesh) {
          this._gizmoMesh.dispose();
        }
        const materials = [this._coloredMaterial, this._hoverMaterial, this._disableMaterial];
        for (const matl of materials) {
          if (matl) {
            matl.dispose();
          }
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Gizmos/positionGizmo.js
var PositionGizmo;
var init_positionGizmo = __esm({
  "node_modules/@babylonjs/core/Gizmos/positionGizmo.js"() {
    init_logger();
    init_observable();
    init_math_vector();
    init_math_color();
    init_gizmo();
    init_axisDragGizmo();
    init_planeDragGizmo();
    init_utilityLayerRenderer();
    PositionGizmo = class extends Gizmo {
      get attachedMesh() {
        return this._meshAttached;
      }
      set attachedMesh(mesh) {
        this._meshAttached = mesh;
        this._nodeAttached = mesh;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo];
        for (const gizmo of gizmos) {
          if (gizmo.isEnabled) {
            gizmo.attachedMesh = mesh;
          } else {
            gizmo.attachedMesh = null;
          }
        }
      }
      get attachedNode() {
        return this._nodeAttached;
      }
      set attachedNode(node) {
        this._meshAttached = null;
        this._nodeAttached = node;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo];
        for (const gizmo of gizmos) {
          if (gizmo.isEnabled) {
            gizmo.attachedNode = node;
          } else {
            gizmo.attachedNode = null;
          }
        }
      }
      /**
       * True when the mouse pointer is hovering a gizmo mesh
       */
      get isHovered() {
        return this.xGizmo.isHovered || this.yGizmo.isHovered || this.zGizmo.isHovered || this.xPlaneGizmo.isHovered || this.yPlaneGizmo.isHovered || this.zPlaneGizmo.isHovered;
      }
      get isDragging() {
        return this.xGizmo.dragBehavior.dragging || this.yGizmo.dragBehavior.dragging || this.zGizmo.dragBehavior.dragging || this.xPlaneGizmo.dragBehavior.dragging || this.yPlaneGizmo.dragBehavior.dragging || this.zPlaneGizmo.dragBehavior.dragging;
      }
      get additionalTransformNode() {
        return this._additionalTransformNode;
      }
      set additionalTransformNode(transformNode) {
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo];
        for (const gizmo of gizmos) {
          gizmo.additionalTransformNode = transformNode;
        }
      }
      /**
       * Creates a PositionGizmo
       * @param gizmoLayer The utility layer the gizmo will be added to
       * @param thickness display gizmo axis thickness
       * @param gizmoManager
       * @param options More options
       */
      constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, thickness = 1, gizmoManager, options) {
        super(gizmoLayer);
        this._meshAttached = null;
        this._nodeAttached = null;
        this._observables = [];
        this._gizmoAxisCache = /* @__PURE__ */ new Map();
        this.onDragStartObservable = new Observable();
        this.onDragObservable = new Observable();
        this.onDragEndObservable = new Observable();
        this._planarGizmoEnabled = false;
        this.xGizmo = new AxisDragGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer, this, thickness);
        this.yGizmo = new AxisDragGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer, this, thickness);
        this.zGizmo = new AxisDragGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer, this, thickness);
        this.xPlaneGizmo = new PlaneDragGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), this.gizmoLayer, this);
        this.yPlaneGizmo = new PlaneDragGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), this.gizmoLayer, this);
        this.zPlaneGizmo = new PlaneDragGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), this.gizmoLayer, this);
        this.additionalTransformNode = options?.additionalTransformNode;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo];
        for (const gizmo of gizmos) {
          gizmo.dragBehavior.onDragStartObservable.add((eventData, eventState) => this.onDragStartObservable.notifyObservers(eventData, eventState.mask, eventState.target, eventState.currentTarget, eventState.userInfo));
          gizmo.dragBehavior.onDragObservable.add((eventData, eventState) => this.onDragObservable.notifyObservers(eventData, eventState.mask, eventState.target, eventState.currentTarget, eventState.userInfo));
          gizmo.dragBehavior.onDragEndObservable.add((eventData, eventState) => this.onDragEndObservable.notifyObservers(eventData, eventState.mask, eventState.target, eventState.currentTarget, eventState.userInfo));
        }
        this.attachedMesh = null;
        if (gizmoManager) {
          gizmoManager.addToAxisCache(this._gizmoAxisCache);
        } else {
          Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);
        }
      }
      /**
       * If the planar drag gizmo is enabled
       * setting this will enable/disable XY, XZ and YZ planes regardless of individual gizmo settings.
       */
      set planarGizmoEnabled(value) {
        this._planarGizmoEnabled = value;
        const gizmos = [this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.isEnabled = value;
            if (value) {
              if (gizmo.attachedMesh) {
                gizmo.attachedMesh = this.attachedMesh;
              } else {
                gizmo.attachedNode = this.attachedNode;
              }
            }
          }
        }
      }
      get planarGizmoEnabled() {
        return this._planarGizmoEnabled;
      }
      /**
       * posture that the gizmo will be display
       * When set null, default value will be used (Quaternion(0, 0, 0, 1))
       */
      get customRotationQuaternion() {
        return this._customRotationQuaternion;
      }
      set customRotationQuaternion(customRotationQuaternion) {
        this._customRotationQuaternion = customRotationQuaternion;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.customRotationQuaternion = customRotationQuaternion;
          }
        }
      }
      /**
       * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)
       * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation
       */
      set updateGizmoRotationToMatchAttachedMesh(value) {
        this._updateGizmoRotationToMatchAttachedMesh = value;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.updateGizmoRotationToMatchAttachedMesh = value;
          }
        }
      }
      get updateGizmoRotationToMatchAttachedMesh() {
        return this._updateGizmoRotationToMatchAttachedMesh;
      }
      set updateGizmoPositionToMatchAttachedMesh(value) {
        this._updateGizmoPositionToMatchAttachedMesh = value;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.updateGizmoPositionToMatchAttachedMesh = value;
          }
        }
      }
      get updateGizmoPositionToMatchAttachedMesh() {
        return this._updateGizmoPositionToMatchAttachedMesh;
      }
      set anchorPoint(value) {
        this._anchorPoint = value;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo];
        for (const gizmo of gizmos) {
          gizmo.anchorPoint = value;
        }
      }
      get anchorPoint() {
        return this._anchorPoint;
      }
      /**
       * Set the coordinate system to use. By default it's local.
       * But it's possible for a user to tweak so its local for translation and world for rotation.
       * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`
       */
      set coordinatesMode(coordinatesMode) {
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo];
        for (const gizmo of gizmos) {
          gizmo.coordinatesMode = coordinatesMode;
        }
      }
      set updateScale(value) {
        if (this.xGizmo) {
          this.xGizmo.updateScale = value;
          this.yGizmo.updateScale = value;
          this.zGizmo.updateScale = value;
        }
      }
      get updateScale() {
        return this.xGizmo.updateScale;
      }
      /**
       * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
       */
      set snapDistance(value) {
        this._snapDistance = value;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.snapDistance = value;
          }
        }
      }
      get snapDistance() {
        return this._snapDistance;
      }
      /**
       * Ratio for the scale of the gizmo (Default: 1)
       */
      set scaleRatio(value) {
        this._scaleRatio = value;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.scaleRatio = value;
          }
        }
      }
      get scaleRatio() {
        return this._scaleRatio;
      }
      /**
       * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation
       * @param mesh Axis gizmo mesh
       * @param cache Gizmo axis definition used for reactive gizmo UI
       */
      addToAxisCache(mesh, cache) {
        this._gizmoAxisCache.set(mesh, cache);
      }
      /**
       * Force release the drag action by code
       */
      releaseDrag() {
        this.xGizmo.dragBehavior.releaseDrag();
        this.yGizmo.dragBehavior.releaseDrag();
        this.zGizmo.dragBehavior.releaseDrag();
        this.xPlaneGizmo.dragBehavior.releaseDrag();
        this.yPlaneGizmo.dragBehavior.releaseDrag();
        this.zPlaneGizmo.dragBehavior.releaseDrag();
      }
      /**
       * Disposes of the gizmo
       */
      dispose() {
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.dispose();
          }
        }
        for (const obs of this._observables) {
          this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);
        }
        this.onDragStartObservable.clear();
        this.onDragObservable.clear();
        this.onDragEndObservable.clear();
        super.dispose();
      }
      /**
       * CustomMeshes are not supported by this gizmo
       */
      setCustomMesh() {
        Logger.Error("Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo,gizmo.xPlaneGizmo, gizmo.yPlaneGizmo, gizmo.zPlaneGizmo)");
      }
    };
  }
});

// node_modules/@babylonjs/core/Gizmos/scaleGizmo.js
var ScaleGizmo;
var init_scaleGizmo = __esm({
  "node_modules/@babylonjs/core/Gizmos/scaleGizmo.js"() {
    init_logger();
    init_observable();
    init_math_vector();
    init_math_color();
    init_polyhedronBuilder();
    init_gizmo();
    init_axisScaleGizmo();
    init_utilityLayerRenderer();
    init_standardMaterial();
    ScaleGizmo = class extends Gizmo {
      /** Default material used to render when gizmo is not disabled or hovered */
      get coloredMaterial() {
        return this._coloredMaterial;
      }
      /** Material used to render when gizmo is hovered with mouse*/
      get hoverMaterial() {
        return this._hoverMaterial;
      }
      /** Material used to render when gizmo is disabled. typically grey.*/
      get disableMaterial() {
        return this._disableMaterial;
      }
      get attachedMesh() {
        return this._meshAttached;
      }
      set attachedMesh(mesh) {
        this._meshAttached = mesh;
        this._nodeAttached = mesh;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo];
        for (const gizmo of gizmos) {
          if (gizmo.isEnabled) {
            gizmo.attachedMesh = mesh;
          } else {
            gizmo.attachedMesh = null;
          }
        }
      }
      get attachedNode() {
        return this._nodeAttached;
      }
      set attachedNode(node) {
        this._meshAttached = null;
        this._nodeAttached = node;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo];
        for (const gizmo of gizmos) {
          if (gizmo.isEnabled) {
            gizmo.attachedNode = node;
          } else {
            gizmo.attachedNode = null;
          }
        }
      }
      set updateScale(value) {
        if (this.xGizmo) {
          this.xGizmo.updateScale = value;
          this.yGizmo.updateScale = value;
          this.zGizmo.updateScale = value;
        }
      }
      get updateScale() {
        return this.xGizmo.updateScale;
      }
      /**
       * True when the mouse pointer is hovering a gizmo mesh
       */
      get isHovered() {
        return this.xGizmo.isHovered || this.yGizmo.isHovered || this.zGizmo.isHovered || this.uniformScaleGizmo.isHovered;
      }
      /**
       * True when the mouse pointer is dragging a gizmo mesh
       */
      get isDragging() {
        return this.xGizmo.dragBehavior.dragging || this.yGizmo.dragBehavior.dragging || this.zGizmo.dragBehavior.dragging || this.uniformScaleGizmo.dragBehavior.dragging;
      }
      get additionalTransformNode() {
        return this._additionalTransformNode;
      }
      set additionalTransformNode(transformNode) {
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo];
        for (const gizmo of gizmos) {
          gizmo.additionalTransformNode = transformNode;
        }
      }
      /**
       * Creates a ScaleGizmo
       * @param gizmoLayer The utility layer the gizmo will be added to
       * @param thickness display gizmo axis thickness
       * @param gizmoManager
       * @param options More options
       */
      constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, thickness = 1, gizmoManager, options) {
        super(gizmoLayer);
        this._meshAttached = null;
        this._nodeAttached = null;
        this._incrementalSnap = false;
        this._sensitivity = 1;
        this._observables = [];
        this._gizmoAxisCache = /* @__PURE__ */ new Map();
        this.onDragStartObservable = new Observable();
        this.onDragObservable = new Observable();
        this.onDragEndObservable = new Observable();
        this.uniformScaleGizmo = this._createUniformScaleMesh();
        this.xGizmo = new AxisScaleGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer, this, thickness);
        this.yGizmo = new AxisScaleGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer, this, thickness);
        this.zGizmo = new AxisScaleGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer, this, thickness);
        this.additionalTransformNode = options?.additionalTransformNode;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo];
        for (const gizmo of gizmos) {
          gizmo.dragBehavior.onDragStartObservable.add((eventData, eventState) => this.onDragStartObservable.notifyObservers(eventData, eventState.mask, eventState.target, eventState.currentTarget, eventState.userInfo));
          gizmo.dragBehavior.onDragObservable.add((eventData, eventState) => this.onDragObservable.notifyObservers(eventData, eventState.mask, eventState.target, eventState.currentTarget, eventState.userInfo));
          gizmo.dragBehavior.onDragEndObservable.add((eventData, eventState) => this.onDragEndObservable.notifyObservers(eventData, eventState.mask, eventState.target, eventState.currentTarget, eventState.userInfo));
        }
        this.attachedMesh = null;
        this.attachedNode = null;
        if (gizmoManager) {
          gizmoManager.addToAxisCache(this._gizmoAxisCache);
        } else {
          Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);
        }
      }
      /**
       * @internal
       * Create Geometry for Gizmo
       */
      _createUniformScaleMesh() {
        this._coloredMaterial = new StandardMaterial("", this.gizmoLayer.utilityLayerScene);
        this._coloredMaterial.diffuseColor = Color3.Gray();
        this._hoverMaterial = new StandardMaterial("", this.gizmoLayer.utilityLayerScene);
        this._hoverMaterial.diffuseColor = Color3.Yellow();
        this._disableMaterial = new StandardMaterial("", this.gizmoLayer.utilityLayerScene);
        this._disableMaterial.diffuseColor = Color3.Gray();
        this._disableMaterial.alpha = 0.4;
        const uniformScaleGizmo = new AxisScaleGizmo(new Vector3(0, 1, 0), Color3.Gray().scale(0.5), this.gizmoLayer, this);
        uniformScaleGizmo.updateGizmoRotationToMatchAttachedMesh = false;
        uniformScaleGizmo.uniformScaling = true;
        this._uniformScalingMesh = CreatePolyhedron("uniform", { type: 1 }, uniformScaleGizmo.gizmoLayer.utilityLayerScene);
        this._uniformScalingMesh.scaling.scaleInPlace(0.01);
        this._uniformScalingMesh.visibility = 0;
        this._octahedron = CreatePolyhedron("", { type: 1 }, uniformScaleGizmo.gizmoLayer.utilityLayerScene);
        this._octahedron.scaling.scaleInPlace(7e-3);
        this._uniformScalingMesh.addChild(this._octahedron);
        uniformScaleGizmo.setCustomMesh(this._uniformScalingMesh, true);
        const light = this.gizmoLayer._getSharedGizmoLight();
        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._octahedron);
        const cache = {
          gizmoMeshes: [this._octahedron, this._uniformScalingMesh],
          colliderMeshes: [this._octahedron, this._uniformScalingMesh],
          material: this._coloredMaterial,
          hoverMaterial: this._hoverMaterial,
          disableMaterial: this._disableMaterial,
          active: false,
          dragBehavior: uniformScaleGizmo.dragBehavior
        };
        this.addToAxisCache(uniformScaleGizmo._rootMesh, cache);
        return uniformScaleGizmo;
      }
      set updateGizmoRotationToMatchAttachedMesh(value) {
        if (!value) {
          Logger.Warn("Setting updateGizmoRotationToMatchAttachedMesh = false on scaling gizmo is not supported.");
        } else {
          this._updateGizmoRotationToMatchAttachedMesh = value;
          const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo];
          for (const gizmo of gizmos) {
            if (gizmo) {
              gizmo.updateGizmoRotationToMatchAttachedMesh = value;
            }
          }
        }
      }
      get updateGizmoRotationToMatchAttachedMesh() {
        return this._updateGizmoRotationToMatchAttachedMesh;
      }
      set anchorPoint(value) {
        this._anchorPoint = value;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.anchorPoint = value;
          }
        }
      }
      get anchorPoint() {
        return this._anchorPoint;
      }
      /**
       * posture that the gizmo will be display
       * When set null, default value will be used (Quaternion(0, 0, 0, 1))
       */
      get customRotationQuaternion() {
        return this._customRotationQuaternion;
      }
      set customRotationQuaternion(customRotationQuaternion) {
        this._customRotationQuaternion = customRotationQuaternion;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.customRotationQuaternion = customRotationQuaternion;
          }
        }
      }
      /**
       * Set the coordinate system to use. By default it's local.
       * But it's possible for a user to tweak so its local for translation and world for rotation.
       * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`
       */
      set coordinatesMode(coordinatesMode) {
        if (coordinatesMode == 0) {
          Logger.Warn("Setting coordinates Mode to world on scaling gizmo is not supported.");
        }
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo];
        for (const gizmo of gizmos) {
          gizmo.coordinatesMode = 1;
        }
      }
      /**
       * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)
       */
      set snapDistance(value) {
        this._snapDistance = value;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.snapDistance = value;
          }
        }
      }
      get snapDistance() {
        return this._snapDistance;
      }
      /**
       * Incremental snap scaling (default is false). When true, with a snapDistance of 0.1, scaling will be 1.1,1.2,1.3 instead of, when false: 1.1,1.21,1.33,...
       */
      set incrementalSnap(value) {
        this._incrementalSnap = value;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.incrementalSnap = value;
          }
        }
      }
      get incrementalSnap() {
        return this._incrementalSnap;
      }
      /**
       * Ratio for the scale of the gizmo (Default: 1)
       */
      set scaleRatio(value) {
        this._scaleRatio = value;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.scaleRatio = value;
          }
        }
      }
      get scaleRatio() {
        return this._scaleRatio;
      }
      /**
       * Sensitivity factor for dragging (Default: 1)
       */
      set sensitivity(value) {
        this._sensitivity = value;
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.sensitivity = value;
          }
        }
      }
      get sensitivity() {
        return this._sensitivity;
      }
      /**
       * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation
       * @param mesh Axis gizmo mesh
       * @param cache Gizmo axis definition used for reactive gizmo UI
       */
      addToAxisCache(mesh, cache) {
        this._gizmoAxisCache.set(mesh, cache);
      }
      /**
       * Get the cache set with addToAxisCache for a specific mesh
       * @param mesh Axis gizmo mesh
       * @returns Gizmo axis definition used for reactive gizmo UI
       */
      getAxisCache(mesh) {
        return this._gizmoAxisCache.get(mesh);
      }
      /**
       * Force release the drag action by code
       */
      releaseDrag() {
        this.xGizmo.dragBehavior.releaseDrag();
        this.yGizmo.dragBehavior.releaseDrag();
        this.zGizmo.dragBehavior.releaseDrag();
        this.uniformScaleGizmo.dragBehavior.releaseDrag();
      }
      /**
       * Disposes of the gizmo
       */
      dispose() {
        const gizmos = [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.dispose();
          }
        }
        for (const obs of this._observables) {
          this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);
        }
        this.onDragStartObservable.clear();
        this.onDragObservable.clear();
        this.onDragEndObservable.clear();
        const meshes = [this._uniformScalingMesh, this._octahedron];
        for (const msh of meshes) {
          if (msh) {
            msh.dispose();
          }
        }
        const materials = [this._coloredMaterial, this._hoverMaterial, this._disableMaterial];
        for (const matl of materials) {
          if (matl) {
            matl.dispose();
          }
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Gizmos/gizmoManager.js
var GizmoManager;
var init_gizmoManager = __esm({
  "node_modules/@babylonjs/core/Gizmos/gizmoManager.js"() {
    init_observable();
    init_pointerEvents();
    init_abstractMesh();
    init_utilityLayerRenderer();
    init_math_color();
    init_sixDofDragBehavior();
    init_gizmo();
    init_rotationGizmo();
    init_positionGizmo();
    init_scaleGizmo();
    init_boundingBoxGizmo();
    GizmoManager = class {
      /**
       * Utility layer that the bounding box gizmo belongs to
       */
      get keepDepthUtilityLayer() {
        return this._defaultKeepDepthUtilityLayer;
      }
      /**
       * Utility layer that all gizmos besides bounding box belong to
       */
      get utilityLayer() {
        return this._defaultUtilityLayer;
      }
      /**
       * True when the mouse pointer is hovering a gizmo mesh
       */
      get isHovered() {
        let hovered = false;
        for (const key in this.gizmos) {
          const gizmo = this.gizmos[key];
          if (gizmo && gizmo.isHovered) {
            hovered = true;
            break;
          }
        }
        return hovered;
      }
      /**
       * True when the mouse pointer is dragging a gizmo mesh
       */
      get isDragging() {
        let dragging = false;
        const gizmos = [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo, this.gizmos.boundingBoxGizmo];
        for (const gizmo of gizmos) {
          if (gizmo && gizmo.isDragging) {
            dragging = true;
          }
        }
        return dragging;
      }
      /**
       * Ratio for the scale of the gizmo (Default: 1)
       */
      set scaleRatio(value) {
        this._scaleRatio = value;
        const gizmos = [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.scaleRatio = value;
          }
        }
      }
      get scaleRatio() {
        return this._scaleRatio;
      }
      /**
       * Set the coordinate system to use. By default it's local.
       * But it's possible for a user to tweak so its local for translation and world for rotation.
       * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`
       */
      set coordinatesMode(coordinatesMode) {
        this._coordinatesMode = coordinatesMode;
        const gizmos = [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo];
        for (const gizmo of gizmos) {
          if (gizmo) {
            gizmo.coordinatesMode = coordinatesMode;
          }
        }
      }
      get coordinatesMode() {
        return this._coordinatesMode;
      }
      /**
       * The mesh the gizmo's is attached to
       */
      get attachedMesh() {
        return this._attachedMesh;
      }
      /**
       * The node the gizmo's is attached to
       */
      get attachedNode() {
        return this._attachedNode;
      }
      /**
       * Additional transform node that will be used to transform all the gizmos
       */
      get additionalTransformNode() {
        return this._additionalTransformNode;
      }
      /**
       * Instantiates a gizmo manager
       * @param _scene the scene to overlay the gizmos on top of
       * @param thickness display gizmo axis thickness
       * @param utilityLayer the layer where gizmos are rendered
       * @param keepDepthUtilityLayer the layer where occluded gizmos are rendered
       */
      constructor(_scene, thickness = 1, utilityLayer = UtilityLayerRenderer.DefaultUtilityLayer, keepDepthUtilityLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer) {
        this._scene = _scene;
        this.clearGizmoOnEmptyPointerEvent = false;
        this.enableAutoPicking = true;
        this.onAttachedToMeshObservable = new Observable();
        this.onAttachedToNodeObservable = new Observable();
        this._gizmosEnabled = { positionGizmo: false, rotationGizmo: false, scaleGizmo: false, boundingBoxGizmo: false };
        this._pointerObservers = [];
        this._attachedMesh = null;
        this._attachedNode = null;
        this._boundingBoxColor = Color3.FromHexString("#0984e3");
        this._thickness = 1;
        this._scaleRatio = 1;
        this._coordinatesMode = 1;
        this._gizmoAxisCache = /* @__PURE__ */ new Map();
        this.boundingBoxDragBehavior = new SixDofDragBehavior();
        this.attachableMeshes = null;
        this.attachableNodes = null;
        this.usePointerToAttachGizmos = true;
        this._defaultUtilityLayer = utilityLayer;
        this._defaultKeepDepthUtilityLayer = keepDepthUtilityLayer;
        this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;
        this._thickness = thickness;
        this.gizmos = { positionGizmo: null, rotationGizmo: null, scaleGizmo: null, boundingBoxGizmo: null };
        const attachToMeshPointerObserver = this._attachToMeshPointerObserver(_scene);
        const gizmoAxisPointerObserver = Gizmo.GizmoAxisPointerObserver(this._defaultUtilityLayer, this._gizmoAxisCache);
        this._pointerObservers = [attachToMeshPointerObserver, gizmoAxisPointerObserver];
      }
      /**
       * @internal
       * Subscribes to pointer down events, for attaching and detaching mesh
       * @param scene The scene layer the observer will be added to
       * @returns the pointer observer
       */
      _attachToMeshPointerObserver(scene) {
        const pointerObserver = scene.onPointerObservable.add((pointerInfo) => {
          if (!this.usePointerToAttachGizmos) {
            return;
          }
          if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
            if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh) {
              if (this.enableAutoPicking) {
                let node = pointerInfo.pickInfo.pickedMesh;
                if (this.attachableMeshes == null) {
                  while (node && node.parent != null) {
                    node = node.parent;
                  }
                } else {
                  let found = false;
                  for (const mesh of this.attachableMeshes) {
                    if (node && (node == mesh || node.isDescendantOf(mesh))) {
                      node = mesh;
                      found = true;
                    }
                  }
                  if (!found) {
                    node = null;
                  }
                }
                if (node instanceof AbstractMesh) {
                  if (this._attachedMesh != node) {
                    this.attachToMesh(node);
                  }
                } else {
                  if (this.clearGizmoOnEmptyPointerEvent) {
                    this.attachToMesh(null);
                  }
                }
              }
            } else {
              if (this.clearGizmoOnEmptyPointerEvent) {
                this.attachToMesh(null);
              }
            }
          }
        });
        return pointerObserver;
      }
      /**
       * Attaches a set of gizmos to the specified mesh
       * @param mesh The mesh the gizmo's should be attached to
       */
      attachToMesh(mesh) {
        if (this._attachedMesh) {
          this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);
        }
        if (this._attachedNode) {
          this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);
        }
        this._attachedMesh = mesh;
        this._attachedNode = null;
        for (const key in this.gizmos) {
          const gizmo = this.gizmos[key];
          if (gizmo && this._gizmosEnabled[key]) {
            gizmo.attachedMesh = mesh;
          }
        }
        if (this.boundingBoxGizmoEnabled && this._attachedMesh) {
          this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);
        }
        this.onAttachedToMeshObservable.notifyObservers(mesh);
      }
      /**
       * Attaches a set of gizmos to the specified node
       * @param node The node the gizmo's should be attached to
       */
      attachToNode(node) {
        if (this._attachedMesh) {
          this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);
        }
        if (this._attachedNode) {
          this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);
        }
        this._attachedMesh = null;
        this._attachedNode = node;
        for (const key in this.gizmos) {
          const gizmo = this.gizmos[key];
          if (gizmo && this._gizmosEnabled[key]) {
            gizmo.attachedNode = node;
          }
        }
        if (this.boundingBoxGizmoEnabled && this._attachedNode) {
          this._attachedNode.addBehavior(this.boundingBoxDragBehavior);
        }
        this.onAttachedToNodeObservable.notifyObservers(node);
      }
      /**
       * If the position gizmo is enabled
       */
      set positionGizmoEnabled(value) {
        if (value) {
          if (!this.gizmos.positionGizmo) {
            this.gizmos.positionGizmo = new PositionGizmo(this._defaultUtilityLayer, this._thickness, this);
          }
          if (this._attachedNode) {
            this.gizmos.positionGizmo.attachedNode = this._attachedNode;
          } else {
            this.gizmos.positionGizmo.attachedMesh = this._attachedMesh;
          }
        } else if (this.gizmos.positionGizmo) {
          this.gizmos.positionGizmo.attachedNode = null;
        }
        this._gizmosEnabled.positionGizmo = value;
        this._setAdditionalTransformNode();
      }
      get positionGizmoEnabled() {
        return this._gizmosEnabled.positionGizmo;
      }
      /**
       * If the rotation gizmo is enabled
       */
      set rotationGizmoEnabled(value) {
        if (value) {
          if (!this.gizmos.rotationGizmo) {
            this.gizmos.rotationGizmo = new RotationGizmo(this._defaultUtilityLayer, 32, false, this._thickness, this);
          }
          if (this._attachedNode) {
            this.gizmos.rotationGizmo.attachedNode = this._attachedNode;
          } else {
            this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh;
          }
        } else if (this.gizmos.rotationGizmo) {
          this.gizmos.rotationGizmo.attachedNode = null;
        }
        this._gizmosEnabled.rotationGizmo = value;
        this._setAdditionalTransformNode();
      }
      get rotationGizmoEnabled() {
        return this._gizmosEnabled.rotationGizmo;
      }
      /**
       * If the scale gizmo is enabled
       */
      set scaleGizmoEnabled(value) {
        if (value) {
          this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new ScaleGizmo(this._defaultUtilityLayer, this._thickness, this);
          if (this._attachedNode) {
            this.gizmos.scaleGizmo.attachedNode = this._attachedNode;
          } else {
            this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh;
          }
        } else if (this.gizmos.scaleGizmo) {
          this.gizmos.scaleGizmo.attachedNode = null;
        }
        this._gizmosEnabled.scaleGizmo = value;
        this._setAdditionalTransformNode();
      }
      get scaleGizmoEnabled() {
        return this._gizmosEnabled.scaleGizmo;
      }
      /**
       * If the boundingBox gizmo is enabled
       */
      set boundingBoxGizmoEnabled(value) {
        if (value) {
          this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer);
          if (this._attachedMesh) {
            this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh;
          } else {
            this.gizmos.boundingBoxGizmo.attachedNode = this._attachedNode;
          }
          if (this._attachedMesh) {
            this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);
            this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);
          } else if (this._attachedNode) {
            this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);
            this._attachedNode.addBehavior(this.boundingBoxDragBehavior);
          }
        } else if (this.gizmos.boundingBoxGizmo) {
          if (this._attachedMesh) {
            this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);
          } else if (this._attachedNode) {
            this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);
          }
          this.gizmos.boundingBoxGizmo.attachedNode = null;
        }
        this._gizmosEnabled.boundingBoxGizmo = value;
        this._setAdditionalTransformNode();
      }
      get boundingBoxGizmoEnabled() {
        return this._gizmosEnabled.boundingBoxGizmo;
      }
      /**
       * Sets the additional transform applied to all the gizmos.
       * @See Gizmo.additionalTransformNode for more detail
       */
      set additionalTransformNode(node) {
        this._additionalTransformNode = node;
        this._setAdditionalTransformNode();
      }
      _setAdditionalTransformNode() {
        for (const key in this.gizmos) {
          const gizmo = this.gizmos[key];
          if (gizmo && this._gizmosEnabled[key]) {
            gizmo.additionalTransformNode = this._additionalTransformNode;
          }
        }
      }
      /**
       * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation
       * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI
       */
      addToAxisCache(gizmoAxisCache) {
        if (gizmoAxisCache.size > 0) {
          gizmoAxisCache.forEach((v, k) => {
            this._gizmoAxisCache.set(k, v);
          });
        }
      }
      /**
       * Force release the drag action by code
       */
      releaseDrag() {
        const gizmos = [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo, this.gizmos.boundingBoxGizmo];
        for (const gizmo of gizmos) {
          gizmo?.releaseDrag();
        }
      }
      /**
       * Disposes of the gizmo manager
       */
      dispose() {
        for (const observer of this._pointerObservers) {
          this._scene.onPointerObservable.remove(observer);
        }
        for (const key in this.gizmos) {
          const gizmo = this.gizmos[key];
          if (gizmo) {
            gizmo.dispose();
          }
        }
        if (this._defaultKeepDepthUtilityLayer !== UtilityLayerRenderer._DefaultKeepDepthUtilityLayer) {
          this._defaultKeepDepthUtilityLayer?.dispose();
        }
        if (this._defaultUtilityLayer !== UtilityLayerRenderer._DefaultUtilityLayer) {
          this._defaultUtilityLayer?.dispose();
        }
        this.boundingBoxDragBehavior.detach();
        this.onAttachedToMeshObservable.clear();
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Builders/hemisphereBuilder.js
function CreateHemisphere(name13, options = {}, scene) {
  if (!options.diameter) {
    options.diameter = 1;
  }
  if (!options.segments) {
    options.segments = 16;
  }
  const halfSphere = CreateSphere("", { slice: 0.5, diameter: options.diameter, segments: options.segments }, scene);
  const disc = CreateDisc("", { radius: options.diameter / 2, tessellation: options.segments * 3 + (4 - options.segments) }, scene);
  disc.rotation.x = -Math.PI / 2;
  disc.parent = halfSphere;
  const merged = Mesh.MergeMeshes([disc, halfSphere], true);
  merged.name = name13;
  return merged;
}
var HemisphereBuilder;
var init_hemisphereBuilder = __esm({
  "node_modules/@babylonjs/core/Meshes/Builders/hemisphereBuilder.js"() {
    init_mesh();
    init_sphereBuilder();
    init_discBuilder();
    HemisphereBuilder = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      CreateHemisphere
    };
    Mesh.CreateHemisphere = (name13, segments, diameter, scene) => {
      const options = {
        segments,
        diameter
      };
      return CreateHemisphere(name13, options, scene);
    };
  }
});

// node_modules/@babylonjs/core/Lights/spotLight.js
var SpotLight;
var init_spotLight = __esm({
  "node_modules/@babylonjs/core/Lights/spotLight.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_node();
    init_light();
    init_shadowLight();
    init_texture();
    init_typeStore();
    Node.AddNodeConstructor("Light_Type_2", (name13, scene) => {
      return () => new SpotLight(name13, Vector3.Zero(), Vector3.Zero(), 0, 0, scene);
    });
    SpotLight = class _SpotLight extends ShadowLight {
      /**
       * Gets or sets the IES profile texture used to create the spotlight
       * @see https://playground.babylonjs.com/#UIAXAU#1
       */
      get iesProfileTexture() {
        return this._iesProfileTexture;
      }
      set iesProfileTexture(value) {
        if (this._iesProfileTexture === value) {
          return;
        }
        this._iesProfileTexture = value;
        if (this._iesProfileTexture && _SpotLight._IsTexture(this._iesProfileTexture)) {
          this._iesProfileTexture.onLoadObservable.addOnce(() => {
            this._markMeshesAsLightDirty();
          });
        }
      }
      /**
       * Gets the cone angle of the spot light in Radians.
       */
      get angle() {
        return this._angle;
      }
      /**
       * Sets the cone angle of the spot light in Radians.
       */
      set angle(value) {
        this._angle = value;
        this._cosHalfAngle = Math.cos(value * 0.5);
        this._projectionTextureProjectionLightDirty = true;
        this.forceProjectionMatrixCompute();
        this._computeAngleValues();
      }
      /**
       * Only used in gltf falloff mode, this defines the angle where
       * the directional falloff will start before cutting at angle which could be seen
       * as outer angle.
       */
      get innerAngle() {
        return this._innerAngle;
      }
      /**
       * Only used in gltf falloff mode, this defines the angle where
       * the directional falloff will start before cutting at angle which could be seen
       * as outer angle.
       */
      set innerAngle(value) {
        this._innerAngle = value;
        this._computeAngleValues();
      }
      /**
       * Allows scaling the angle of the light for shadow generation only.
       */
      get shadowAngleScale() {
        return this._shadowAngleScale;
      }
      /**
       * Allows scaling the angle of the light for shadow generation only.
       */
      set shadowAngleScale(value) {
        this._shadowAngleScale = value;
        this.forceProjectionMatrixCompute();
      }
      /**
       * Allows reading the projection texture
       */
      get projectionTextureMatrix() {
        return this._projectionTextureMatrix;
      }
      /**
       * Gets the near clip of the Spotlight for texture projection.
       */
      get projectionTextureLightNear() {
        return this._projectionTextureLightNear;
      }
      /**
       * Sets the near clip of the Spotlight for texture projection.
       */
      set projectionTextureLightNear(value) {
        this._projectionTextureLightNear = value;
        this._projectionTextureProjectionLightDirty = true;
      }
      /**
       * Gets the far clip of the Spotlight for texture projection.
       */
      get projectionTextureLightFar() {
        return this._projectionTextureLightFar;
      }
      /**
       * Sets the far clip of the Spotlight for texture projection.
       */
      set projectionTextureLightFar(value) {
        this._projectionTextureLightFar = value;
        this._projectionTextureProjectionLightDirty = true;
      }
      /**
       * Gets the Up vector of the Spotlight for texture projection.
       */
      get projectionTextureUpDirection() {
        return this._projectionTextureUpDirection;
      }
      /**
       * Sets the Up vector of the Spotlight for texture projection.
       */
      set projectionTextureUpDirection(value) {
        this._projectionTextureUpDirection = value;
        this._projectionTextureProjectionLightDirty = true;
      }
      /**
       * Gets the projection texture of the light.
       */
      get projectionTexture() {
        return this._projectionTexture;
      }
      /**
       * Sets the projection texture of the light.
       */
      set projectionTexture(value) {
        if (this._projectionTexture === value) {
          return;
        }
        this._projectionTexture = value;
        this._projectionTextureDirty = true;
        if (this._projectionTexture && !this._projectionTexture.isReady()) {
          if (_SpotLight._IsProceduralTexture(this._projectionTexture)) {
            this._projectionTexture.getEffect().executeWhenCompiled(() => {
              this._markMeshesAsLightDirty();
            });
          } else if (_SpotLight._IsTexture(this._projectionTexture)) {
            this._projectionTexture.onLoadObservable.addOnce(() => {
              this._markMeshesAsLightDirty();
            });
          }
        }
      }
      static _IsProceduralTexture(texture) {
        return texture.onGeneratedObservable !== void 0;
      }
      static _IsTexture(texture) {
        return texture.onLoadObservable !== void 0;
      }
      /**
       * Gets or sets the light projection matrix as used by the projection texture
       */
      get projectionTextureProjectionLightMatrix() {
        return this._projectionTextureProjectionLightMatrix;
      }
      set projectionTextureProjectionLightMatrix(projection) {
        this._projectionTextureProjectionLightMatrix = projection;
        this._projectionTextureProjectionLightDirty = false;
        this._projectionTextureDirty = true;
      }
      /**
       * Creates a SpotLight object in the scene. A spot light is a simply light oriented cone.
       * It can cast shadows.
       * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
       * @param name The light friendly name
       * @param position The position of the spot light in the scene
       * @param direction The direction of the light in the scene
       * @param angle The cone angle of the light in Radians
       * @param exponent The light decay speed with the distance from the emission spot
       * @param scene The scene the lights belongs to
       * @param dontAddToScene True to not add the light to the scene
       */
      constructor(name13, position, direction, angle, exponent, scene, dontAddToScene) {
        super(name13, scene, dontAddToScene);
        this._innerAngle = 0;
        this._iesProfileTexture = null;
        this._projectionTextureMatrix = Matrix.Zero();
        this._projectionTextureLightNear = 1e-6;
        this._projectionTextureLightFar = 1e3;
        this._projectionTextureUpDirection = Vector3.Up();
        this._projectionTextureViewLightDirty = true;
        this._projectionTextureProjectionLightDirty = true;
        this._projectionTextureDirty = true;
        this._projectionTextureViewTargetVector = Vector3.Zero();
        this._projectionTextureViewLightMatrix = Matrix.Zero();
        this._projectionTextureProjectionLightMatrix = Matrix.Zero();
        this._projectionTextureScalingMatrix = Matrix.FromValues(0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0.5, 0.5, 0.5, 1);
        this.position = position;
        this.direction = direction;
        this.angle = angle;
        this.exponent = exponent;
      }
      /**
       * Returns the string "SpotLight".
       * @returns the class name
       */
      getClassName() {
        return "SpotLight";
      }
      /**
       * Returns the integer 2.
       * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      getTypeID() {
        return Light.LIGHTTYPEID_SPOTLIGHT;
      }
      /**
       * Overrides the direction setter to recompute the projection texture view light Matrix.
       * @param value
       */
      _setDirection(value) {
        super._setDirection(value);
        this._projectionTextureViewLightDirty = true;
      }
      /**
       * Overrides the position setter to recompute the projection texture view light Matrix.
       * @param value
       */
      _setPosition(value) {
        super._setPosition(value);
        this._projectionTextureViewLightDirty = true;
      }
      /**
       * Sets the passed matrix "matrix" as perspective projection matrix for the shadows and the passed view matrix with the fov equal to the SpotLight angle and and aspect ratio of 1.0.
       * Returns the SpotLight.
       * @param matrix
       * @param viewMatrix
       * @param renderList
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {
        const activeCamera = this.getScene().activeCamera;
        if (!activeCamera) {
          return;
        }
        this._shadowAngleScale = this._shadowAngleScale || 1;
        const angle = this._shadowAngleScale * this._angle;
        const minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
        const maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
        Matrix.PerspectiveFovLHToRef(angle, 1, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, true, this._scene.getEngine().isNDCHalfZRange, void 0, useReverseDepthBuffer);
      }
      _computeProjectionTextureViewLightMatrix() {
        this._projectionTextureViewLightDirty = false;
        this._projectionTextureDirty = true;
        this.getAbsolutePosition().addToRef(this.getShadowDirection(), this._projectionTextureViewTargetVector);
        Matrix.LookAtLHToRef(this.getAbsolutePosition(), this._projectionTextureViewTargetVector, this._projectionTextureUpDirection, this._projectionTextureViewLightMatrix);
      }
      _computeProjectionTextureProjectionLightMatrix() {
        this._projectionTextureProjectionLightDirty = false;
        this._projectionTextureDirty = true;
        const lightFar = this.projectionTextureLightFar;
        const lightNear = this.projectionTextureLightNear;
        const p = lightFar / (lightFar - lightNear);
        const q = -p * lightNear;
        const s = 1 / Math.tan(this._angle / 2);
        const a = 1;
        Matrix.FromValuesToRef(s / a, 0, 0, 0, 0, s, 0, 0, 0, 0, p, 1, 0, 0, q, 0, this._projectionTextureProjectionLightMatrix);
      }
      /**
       * Main function for light texture projection matrix computing.
       */
      _computeProjectionTextureMatrix() {
        this._projectionTextureDirty = false;
        this._projectionTextureViewLightMatrix.multiplyToRef(this._projectionTextureProjectionLightMatrix, this._projectionTextureMatrix);
        if (this._projectionTexture instanceof Texture) {
          const u = this._projectionTexture.uScale / 2;
          const v = this._projectionTexture.vScale / 2;
          Matrix.FromValuesToRef(u, 0, 0, 0, 0, v, 0, 0, 0, 0, 0.5, 0, 0.5, 0.5, 0.5, 1, this._projectionTextureScalingMatrix);
        }
        this._projectionTextureMatrix.multiplyToRef(this._projectionTextureScalingMatrix, this._projectionTextureMatrix);
      }
      _buildUniformLayout() {
        this._uniformBuffer.addUniform("vLightData", 4);
        this._uniformBuffer.addUniform("vLightDiffuse", 4);
        this._uniformBuffer.addUniform("vLightSpecular", 4);
        this._uniformBuffer.addUniform("vLightDirection", 3);
        this._uniformBuffer.addUniform("vLightFalloff", 4);
        this._uniformBuffer.addUniform("shadowsInfo", 3);
        this._uniformBuffer.addUniform("depthValues", 2);
        this._uniformBuffer.create();
      }
      _computeAngleValues() {
        this._lightAngleScale = 1 / Math.max(1e-3, Math.cos(this._innerAngle * 0.5) - this._cosHalfAngle);
        this._lightAngleOffset = -this._cosHalfAngle * this._lightAngleScale;
      }
      /**
       * Sets the passed Effect "effect" with the Light textures.
       * @param effect The effect to update
       * @param lightIndex The index of the light in the effect to update
       * @returns The light
       */
      transferTexturesToEffect(effect, lightIndex) {
        if (this.projectionTexture && this.projectionTexture.isReady()) {
          if (this._projectionTextureViewLightDirty) {
            this._computeProjectionTextureViewLightMatrix();
          }
          if (this._projectionTextureProjectionLightDirty) {
            this._computeProjectionTextureProjectionLightMatrix();
          }
          if (this._projectionTextureDirty) {
            this._computeProjectionTextureMatrix();
          }
          effect.setMatrix("textureProjectionMatrix" + lightIndex, this._projectionTextureMatrix);
          effect.setTexture("projectionLightTexture" + lightIndex, this.projectionTexture);
        }
        if (this._iesProfileTexture && this._iesProfileTexture.isReady()) {
          effect.setTexture("iesLightTexture" + lightIndex, this._iesProfileTexture);
        }
        return this;
      }
      /**
       * Sets the passed Effect object with the SpotLight transformed position (or position if not parented) and normalized direction.
       * @param effect The effect to update
       * @param lightIndex The index of the light in the effect to update
       * @returns The spot light
       */
      transferToEffect(effect, lightIndex) {
        let normalizeDirection;
        const offset = this._scene.floatingOriginOffset;
        if (this.computeTransformedInformation()) {
          this._uniformBuffer.updateFloat4("vLightData", this.transformedPosition.x - offset.x, this.transformedPosition.y - offset.y, this.transformedPosition.z - offset.z, this.exponent, lightIndex);
          normalizeDirection = Vector3.Normalize(this.transformedDirection);
        } else {
          this._uniformBuffer.updateFloat4("vLightData", this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z, this.exponent, lightIndex);
          normalizeDirection = Vector3.Normalize(this.direction);
        }
        this._uniformBuffer.updateFloat4("vLightDirection", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, this._cosHalfAngle, lightIndex);
        this._uniformBuffer.updateFloat4("vLightFalloff", this.range, this._inverseSquaredRange, this._lightAngleScale, this._lightAngleOffset, lightIndex);
        return this;
      }
      transferToNodeMaterialEffect(effect, lightDataUniformName) {
        let normalizeDirection;
        if (this.computeTransformedInformation()) {
          normalizeDirection = Vector3.Normalize(this.transformedDirection);
        } else {
          normalizeDirection = Vector3.Normalize(this.direction);
        }
        if (this.getScene().useRightHandedSystem) {
          effect.setFloat3(lightDataUniformName, -normalizeDirection.x, -normalizeDirection.y, -normalizeDirection.z);
        } else {
          effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);
        }
        return this;
      }
      /**
       * Disposes the light and the associated resources.
       */
      dispose() {
        super.dispose();
        if (this._projectionTexture) {
          this._projectionTexture.dispose();
        }
        if (this._iesProfileTexture) {
          this._iesProfileTexture.dispose();
          this._iesProfileTexture = null;
        }
      }
      /**
       * Gets the minZ used for shadow according to both the scene and the light.
       * @param activeCamera The camera we are returning the min for
       * @returns the depth min z
       */
      getDepthMinZ(activeCamera) {
        const engine = this._scene.getEngine();
        const minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera?.minZ ?? 0;
        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? minZ : this._scene.getEngine().isNDCHalfZRange ? 0 : minZ;
      }
      /**
       * Gets the maxZ used for shadow according to both the scene and the light.
       * @param activeCamera The camera we are returning the max for
       * @returns the depth max z
       */
      getDepthMaxZ(activeCamera) {
        const engine = this._scene.getEngine();
        const maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera?.maxZ ?? 1e4;
        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : maxZ;
      }
      /**
       * Prepares the list of defines specific to the light type.
       * @param defines the list of defines
       * @param lightIndex defines the index of the light for the effect
       */
      prepareLightSpecificDefines(defines, lightIndex) {
        defines["SPOTLIGHT" + lightIndex] = true;
        defines["PROJECTEDLIGHTTEXTURE" + lightIndex] = this.projectionTexture && this.projectionTexture.isReady() ? true : false;
        defines["IESLIGHTTEXTURE" + lightIndex] = this._iesProfileTexture && this._iesProfileTexture.isReady() ? true : false;
      }
    };
    __decorate([
      serialize()
    ], SpotLight.prototype, "angle", null);
    __decorate([
      serialize()
    ], SpotLight.prototype, "innerAngle", null);
    __decorate([
      serialize()
    ], SpotLight.prototype, "shadowAngleScale", null);
    __decorate([
      serialize()
    ], SpotLight.prototype, "exponent", void 0);
    __decorate([
      serialize()
    ], SpotLight.prototype, "projectionTextureLightNear", null);
    __decorate([
      serialize()
    ], SpotLight.prototype, "projectionTextureLightFar", null);
    __decorate([
      serialize()
    ], SpotLight.prototype, "projectionTextureUpDirection", null);
    __decorate([
      serializeAsTexture("projectedLightTexture")
    ], SpotLight.prototype, "_projectionTexture", void 0);
    RegisterClass("BABYLON.SpotLight", SpotLight);
  }
});

// node_modules/@babylonjs/core/Gizmos/lightGizmo.js
var LightGizmo;
var init_lightGizmo = __esm({
  "node_modules/@babylonjs/core/Gizmos/lightGizmo.js"() {
    init_math_vector();
    init_math_color();
    init_mesh();
    init_gizmo();
    init_utilityLayerRenderer();
    init_standardMaterial();
    init_hemisphericLight();
    init_directionalLight();
    init_sphereBuilder();
    init_hemisphereBuilder();
    init_spotLight();
    init_transformNode();
    init_pointerEvents();
    init_observable();
    init_cylinderBuilder();
    init_logger();
    LightGizmo = class _LightGizmo extends Gizmo {
      /**
       * Creates a LightGizmo
       * @param gizmoLayer The utility layer the gizmo will be added to
       */
      constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer) {
        super(gizmoLayer);
        this._cachedPosition = new Vector3();
        this._cachedForward = new Vector3(0, 0, 1);
        this._pointerObserver = null;
        this.onClickedObservable = new Observable();
        this._light = null;
        this.attachedMesh = new Mesh("", this.gizmoLayer.utilityLayerScene);
        this._attachedMeshParent = new TransformNode("parent", this.gizmoLayer.utilityLayerScene);
        this.attachedMesh.parent = this._attachedMeshParent;
        this._material = new StandardMaterial("light", this.gizmoLayer.utilityLayerScene);
        this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);
        this._material.specularColor = new Color3(0.1, 0.1, 0.1);
        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
          if (!this._light) {
            return;
          }
          this._isHovered = !!(pointerInfo.pickInfo && this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);
          if (this._isHovered && pointerInfo.type === PointerEventTypes.POINTERDOWN && pointerInfo.event.button === 0) {
            this.onClickedObservable.notifyObservers(this._light);
          }
        });
      }
      /**
       * Override attachedNode because lightgizmo only support attached mesh
       * It will return the attached mesh (if any) and setting an attached node will log
       * a warning
       */
      get attachedNode() {
        return this.attachedMesh;
      }
      set attachedNode(value) {
        Logger.Warn("Nodes cannot be attached to LightGizmo. Attach to a mesh instead.");
      }
      /**
       * The light that the gizmo is attached to
       */
      set light(light) {
        this._light = light;
        if (light) {
          if (this._lightMesh) {
            this._lightMesh.dispose();
          }
          if (light instanceof HemisphericLight) {
            this._lightMesh = _LightGizmo._CreateHemisphericLightMesh(this.gizmoLayer.utilityLayerScene);
          } else if (light instanceof DirectionalLight) {
            this._lightMesh = _LightGizmo._CreateDirectionalLightMesh(this.gizmoLayer.utilityLayerScene);
          } else if (light instanceof SpotLight) {
            this._lightMesh = _LightGizmo._CreateSpotLightMesh(this.gizmoLayer.utilityLayerScene);
          } else {
            this._lightMesh = _LightGizmo._CreatePointLightMesh(this.gizmoLayer.utilityLayerScene);
          }
          const children = this._lightMesh.getChildMeshes(false);
          for (const m of children) {
            m.material = this._material;
          }
          this._lightMesh.parent = this._rootMesh;
          const gizmoLight = this.gizmoLayer._getSharedGizmoLight();
          gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._lightMesh.getChildMeshes(false));
          this._lightMesh.rotationQuaternion = new Quaternion();
          if (!this.attachedMesh.reservedDataStore) {
            this.attachedMesh.reservedDataStore = {};
          }
          this.attachedMesh.reservedDataStore.lightGizmo = this;
          if (light.parent) {
            this._attachedMeshParent.freezeWorldMatrix(light.parent.getWorldMatrix());
          }
          if (light.position) {
            this.attachedMesh.position.copyFrom(light.position);
            this.attachedMesh.computeWorldMatrix(true);
            this._cachedPosition.copyFrom(this.attachedMesh.position);
          }
          if (light.direction) {
            this.attachedMesh.setDirection(light.direction);
            this.attachedMesh.computeWorldMatrix(true);
            const forward = this._getMeshForward();
            this._cachedForward.copyFrom(forward);
          }
          this._update();
        }
      }
      get light() {
        return this._light;
      }
      /**
       * Gets the material used to render the light gizmo
       */
      get material() {
        return this._material;
      }
      /**
       * @internal
       * returns mesh forward
       */
      _getMeshForward() {
        let forward = this.attachedMesh.forward;
        if (this.attachedMesh.getScene().useRightHandedSystem) {
          forward.negateToRef(TmpVectors.Vector3[0]);
          forward = TmpVectors.Vector3[0];
        }
        return forward;
      }
      /**
       * @internal
       * Updates the gizmo to match the attached mesh's position/rotation
       */
      _update() {
        super._update();
        if (!this._light) {
          return;
        }
        if (this._light.parent) {
          this._attachedMeshParent.freezeWorldMatrix(this._light.parent.getWorldMatrix());
        }
        if (this._light.position) {
          if (!this.attachedMesh.position.equals(this._cachedPosition)) {
            const position = this.attachedMesh.position;
            this._light.position = new Vector3(position.x, position.y, position.z);
            this._cachedPosition.copyFrom(this.attachedMesh.position);
          } else {
            this.attachedMesh.position.copyFrom(this._light.position);
            this.attachedMesh.computeWorldMatrix(true);
            this._cachedPosition.copyFrom(this.attachedMesh.position);
          }
        }
        if (this._light.direction) {
          const forward = this._getMeshForward();
          if (Vector3.DistanceSquared(forward, this._cachedForward) > 1e-4) {
            const direction = forward;
            this._light.direction = new Vector3(direction.x, direction.y, direction.z);
            this._cachedForward.copyFrom(forward);
          } else if (Vector3.DistanceSquared(forward, this._light.direction) > 1e-4) {
            this.attachedMesh.setDirection(this._light.direction);
            this.attachedMesh.computeWorldMatrix(true);
            this._cachedForward.copyFrom(forward);
          }
        }
      }
      /**
       * Disposes of the light gizmo
       */
      dispose() {
        this.onClickedObservable.clear();
        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
        this._material.dispose();
        super.dispose();
        this._attachedMeshParent.dispose();
      }
      static _CreateHemisphericLightMesh(scene) {
        const root = new Mesh("hemisphereLight", scene);
        const hemisphere = CreateHemisphere(root.name, { segments: 10, diameter: 1 }, scene);
        hemisphere.position.z = -0.15;
        hemisphere.rotation.x = Math.PI / 2;
        hemisphere.parent = root;
        const lines = this._CreateLightLines(3, scene);
        lines.parent = root;
        root.scaling.scaleInPlace(_LightGizmo._Scale);
        root.rotation.x = Math.PI / 2;
        return root;
      }
      static _CreatePointLightMesh(scene) {
        const root = new Mesh("pointLight", scene);
        const sphere = CreateSphere(root.name, { segments: 10, diameter: 1 }, scene);
        sphere.rotation.x = Math.PI / 2;
        sphere.parent = root;
        const lines = this._CreateLightLines(5, scene);
        lines.parent = root;
        root.scaling.scaleInPlace(_LightGizmo._Scale);
        root.rotation.x = Math.PI / 2;
        return root;
      }
      static _CreateSpotLightMesh(scene) {
        const root = new Mesh("spotLight", scene);
        const sphere = CreateSphere(root.name, { segments: 10, diameter: 1 }, scene);
        sphere.parent = root;
        const hemisphere = CreateHemisphere(root.name, { segments: 10, diameter: 2 }, scene);
        hemisphere.parent = root;
        hemisphere.rotation.x = -Math.PI / 2;
        const lines = this._CreateLightLines(2, scene);
        lines.parent = root;
        root.scaling.scaleInPlace(_LightGizmo._Scale);
        root.rotation.x = Math.PI / 2;
        return root;
      }
      static _CreateDirectionalLightMesh(scene) {
        const root = new Mesh("directionalLight", scene);
        const mesh = new Mesh(root.name, scene);
        mesh.parent = root;
        const sphere = CreateSphere(root.name, { diameter: 1.2, segments: 10 }, scene);
        sphere.parent = mesh;
        const line = CreateCylinder(root.name, {
          updatable: false,
          height: 6,
          diameterTop: 0.3,
          diameterBottom: 0.3,
          tessellation: 6,
          subdivisions: 1
        }, scene);
        line.parent = mesh;
        let left = line.clone(root.name);
        left.scaling.y = 0.5;
        left.position.x += 1.25;
        let right = line.clone(root.name);
        right.scaling.y = 0.5;
        right.position.x += -1.25;
        const arrowHead = CreateCylinder(root.name, {
          updatable: false,
          height: 1,
          diameterTop: 0,
          diameterBottom: 0.6,
          tessellation: 6,
          subdivisions: 1
        }, scene);
        arrowHead.position.y += 3;
        arrowHead.parent = mesh;
        left = arrowHead.clone(root.name);
        left.position.y = 1.5;
        left.position.x += 1.25;
        right = arrowHead.clone(root.name);
        right.position.y = 1.5;
        right.position.x += -1.25;
        mesh.scaling.scaleInPlace(_LightGizmo._Scale);
        mesh.rotation.z = Math.PI / 2;
        mesh.rotation.y = Math.PI / 2;
        return root;
      }
    };
    LightGizmo._Scale = 7e-3;
    LightGizmo._CreateLightLines = (levels, scene) => {
      const distFromSphere = 1.2;
      const root = new Mesh("root", scene);
      root.rotation.x = Math.PI / 2;
      const linePivot = new Mesh("linePivot", scene);
      linePivot.parent = root;
      const line = CreateCylinder("line", {
        updatable: false,
        height: 2,
        diameterTop: 0.2,
        diameterBottom: 0.3,
        tessellation: 6,
        subdivisions: 1
      }, scene);
      line.position.y = line.scaling.y / 2 + distFromSphere;
      line.parent = linePivot;
      if (levels < 2) {
        return linePivot;
      }
      for (let i = 0; i < 4; i++) {
        const l2 = linePivot.clone("lineParentClone");
        l2.rotation.z = Math.PI / 4;
        l2.rotation.y = Math.PI / 2 + Math.PI / 2 * i;
        l2.getChildMeshes()[0].scaling.y = 0.5;
        l2.getChildMeshes()[0].scaling.x = l2.getChildMeshes()[0].scaling.z = 0.8;
        l2.getChildMeshes()[0].position.y = l2.getChildMeshes()[0].scaling.y / 2 + distFromSphere;
      }
      if (levels < 3) {
        return root;
      }
      for (let i = 0; i < 4; i++) {
        const l2 = linePivot.clone("linePivotClone");
        l2.rotation.z = Math.PI / 2;
        l2.rotation.y = Math.PI / 2 * i;
      }
      if (levels < 4) {
        return root;
      }
      for (let i = 0; i < 4; i++) {
        const l2 = linePivot.clone("linePivotClone");
        l2.rotation.z = Math.PI + Math.PI / 4;
        l2.rotation.y = Math.PI / 2 + Math.PI / 2 * i;
        l2.getChildMeshes()[0].scaling.y = 0.5;
        l2.getChildMeshes()[0].scaling.x = l2.getChildMeshes()[0].scaling.z = 0.8;
        l2.getChildMeshes()[0].position.y = l2.getChildMeshes()[0].scaling.y / 2 + distFromSphere;
      }
      if (levels < 5) {
        return root;
      }
      const l = linePivot.clone("linePivotClone");
      l.rotation.z = Math.PI;
      return root;
    };
  }
});

// node_modules/@babylonjs/core/Gizmos/cameraGizmo.js
var CameraGizmo;
var init_cameraGizmo = __esm({
  "node_modules/@babylonjs/core/Gizmos/cameraGizmo.js"() {
    init_math_vector();
    init_math_color();
    init_mesh();
    init_gizmo();
    init_utilityLayerRenderer();
    init_standardMaterial();
    init_boxBuilder();
    init_cylinderBuilder();
    init_math();
    init_linesBuilder();
    init_pointerEvents();
    init_observable();
    CameraGizmo = class _CameraGizmo extends Gizmo {
      /**
       * Creates a CameraGizmo
       * @param gizmoLayer The utility layer the gizmo will be added to
       * @param gizmoColor Camera mesh color. Default is Gray
       * @param frustumLinesColor Frustum lines color. Default is White
       */
      constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, gizmoColor, frustumLinesColor) {
        super(gizmoLayer);
        this._pointerObserver = null;
        this.onClickedObservable = new Observable();
        this._camera = null;
        this._invProjection = new Matrix();
        this._material = new StandardMaterial("cameraGizmoMaterial", this.gizmoLayer.utilityLayerScene);
        this._frustumLinesColor = frustumLinesColor;
        this._material.diffuseColor = gizmoColor ?? new Color3(0.5, 0.5, 0.5);
        this._material.specularColor = new Color3(0.1, 0.1, 0.1);
        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {
          if (!this._camera) {
            return;
          }
          this._isHovered = !!(pointerInfo.pickInfo && this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);
          if (this._isHovered && pointerInfo.type === PointerEventTypes.POINTERDOWN && pointerInfo.event.button === 0) {
            this.onClickedObservable.notifyObservers(this._camera);
          }
        });
      }
      /** Gets or sets a boolean indicating if frustum lines must be rendered (true by default)) */
      get displayFrustum() {
        return this._cameraLinesMesh.isEnabled();
      }
      set displayFrustum(value) {
        this._cameraLinesMesh.setEnabled(value);
      }
      /**
       * The camera that the gizmo is attached to
       */
      set camera(camera) {
        this._camera = camera;
        this.attachedNode = camera;
        if (camera) {
          if (!this._customMeshSet) {
            if (this._cameraMesh) {
              this._cameraMesh.dispose();
            }
            this._cameraMesh = _CameraGizmo._CreateCameraMesh(this.gizmoLayer.utilityLayerScene);
            const childMeshes = this._cameraMesh.getChildMeshes(false);
            for (const m of childMeshes) {
              m.material = this._material;
            }
            this._cameraMesh.parent = this._rootMesh;
          }
          if (this._cameraLinesMesh) {
            this._cameraLinesMesh.dispose();
          }
          const linesColor = this._frustumLinesColor?.toColor4(1) ?? new Color4(1, 1, 1, 1);
          this._cameraLinesMesh = _CameraGizmo._CreateCameraFrustum(this.gizmoLayer.utilityLayerScene, linesColor);
          this._cameraLinesMesh.parent = this._rootMesh;
          if (this.gizmoLayer.utilityLayerScene.activeCamera && this.gizmoLayer.utilityLayerScene.activeCamera != camera && this.gizmoLayer.utilityLayerScene.activeCamera.maxZ < camera.maxZ) {
            this.gizmoLayer.utilityLayerScene.activeCamera.maxZ = camera.maxZ;
          }
          if (!this.attachedNode.reservedDataStore) {
            this.attachedNode.reservedDataStore = {};
          }
          this.attachedNode.reservedDataStore.cameraGizmo = this;
          const gizmoLight = this.gizmoLayer._getSharedGizmoLight();
          gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._cameraMesh.getChildMeshes(false));
          this._update();
        }
      }
      get camera() {
        return this._camera;
      }
      /**
       * Gets the material used to render the camera gizmo
       */
      get material() {
        return this._material;
      }
      /**
       * @internal
       * Updates the gizmo to match the attached mesh's position/rotation
       */
      _update() {
        super._update();
        if (!this._camera) {
          return;
        }
        this._camera.getProjectionMatrix().invertToRef(this._invProjection);
        this._cameraLinesMesh.setPivotMatrix(this._invProjection, false);
        this._cameraLinesMesh.scaling.x = 1 / this._rootMesh.scaling.x;
        this._cameraLinesMesh.scaling.y = 1 / this._rootMesh.scaling.y;
        this._cameraLinesMesh.scaling.z = 1 / this._rootMesh.scaling.z;
        this._cameraMesh.parent = null;
        this._cameraMesh.rotation.y = Math.PI * 0.5 * (this._camera.getScene().useRightHandedSystem ? 1 : -1);
        this._cameraMesh.parent = this._rootMesh;
      }
      /**
       * Disposes and replaces the current camera mesh in the gizmo with the specified mesh
       * @param mesh The mesh to replace the default mesh of the camera gizmo
       */
      setCustomMesh(mesh) {
        if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {
          throw "When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)";
        }
        if (this._cameraMesh) {
          this._cameraMesh.dispose();
        }
        this._cameraMesh = mesh;
        this._cameraMesh.parent = this._rootMesh;
        this._customMeshSet = true;
      }
      /**
       * Disposes of the camera gizmo
       */
      dispose() {
        this.onClickedObservable.clear();
        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
        if (this._cameraMesh) {
          this._cameraMesh.dispose();
        }
        if (this._cameraLinesMesh) {
          this._cameraLinesMesh.dispose();
        }
        this._material.dispose();
        super.dispose();
      }
      static _CreateCameraMesh(scene) {
        const root = new Mesh("rootCameraGizmo", scene);
        const mesh = new Mesh(root.name, scene);
        mesh.parent = root;
        const box = CreateBox(root.name, { width: 1, height: 0.8, depth: 0.5 }, scene);
        box.parent = mesh;
        const cyl1 = CreateCylinder(root.name, { height: 0.5, diameterTop: 0.8, diameterBottom: 0.8 }, scene);
        cyl1.parent = mesh;
        cyl1.position.y = 0.3;
        cyl1.position.x = -0.6;
        cyl1.rotation.x = Math.PI * 0.5;
        const cyl2 = CreateCylinder(root.name, { height: 0.5, diameterTop: 0.6, diameterBottom: 0.6 }, scene);
        cyl2.parent = mesh;
        cyl2.position.y = 0.5;
        cyl2.position.x = 0.4;
        cyl2.rotation.x = Math.PI * 0.5;
        const cyl3 = CreateCylinder(root.name, { height: 0.5, diameterTop: 0.5, diameterBottom: 0.5 }, scene);
        cyl3.parent = mesh;
        cyl3.position.y = 0;
        cyl3.position.x = 0.6;
        cyl3.rotation.z = Math.PI * 0.5;
        root.scaling.scaleInPlace(_CameraGizmo._Scale);
        mesh.position.x = -0.9;
        return root;
      }
      static _CreateCameraFrustum(scene, linesColor) {
        const root = new Mesh("rootCameraGizmo", scene);
        const mesh = new Mesh(root.name, scene);
        mesh.parent = root;
        const lines = [];
        const colors = [];
        for (let y = 0; y < 4; y += 2) {
          for (let x = 0; x < 4; x += 2) {
            lines.push([new Vector3(-1 + x, -1 + y, -1), new Vector3(-1 + x, -1 + y, 1)]);
            lines.push([new Vector3(-1, -1 + x, -1 + y), new Vector3(1, -1 + x, -1 + y)]);
            lines.push([new Vector3(-1 + x, -1, -1 + y), new Vector3(-1 + x, 1, -1 + y)]);
            colors.push([linesColor, linesColor], [linesColor, linesColor], [linesColor, linesColor]);
          }
        }
        const line = CreateLineSystem("lines", { lines, colors }, scene);
        line.parent = mesh;
        line.alwaysSelectAsActiveMesh = true;
        line.isPickable = false;
        return root;
      }
    };
    CameraGizmo._Scale = 0.05;
  }
});

// node_modules/@babylonjs/core/Materials/Textures/cubeTexture.js
var DefaultLodScale, CubeTexture;
var init_cubeTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/cubeTexture.js"() {
    init_tslib_es6();
    init_decorators();
    init_tools();
    init_math_vector();
    init_baseTexture();
    init_texture();
    init_typeStore();
    init_observable();
    init_decorators_serialization();
    init_abstractEngine_cubeTexture();
    DefaultLodScale = 0.8;
    CubeTexture = class _CubeTexture extends BaseTexture {
      /**
       * Gets or sets the size of the bounding box associated with the cube texture
       * When defined, the cubemap will switch to local mode
       * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
       * @example https://www.babylonjs-playground.com/#RNASML
       */
      set boundingBoxSize(value) {
        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
          return;
        }
        this._boundingBoxSize = value;
        const scene = this.getScene();
        if (scene) {
          scene.markAllMaterialsAsDirty(1);
        }
      }
      /**
       * Returns the bounding box size
       * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode
       */
      get boundingBoxSize() {
        return this._boundingBoxSize;
      }
      /**
       * Sets texture matrix rotation angle around Y axis in radians.
       */
      set rotationY(value) {
        this._rotationY = value;
        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));
      }
      /**
       * Gets texture matrix rotation angle around Y axis radians.
       */
      get rotationY() {
        return this._rotationY;
      }
      /**
       * Are mip maps generated for this texture or not.
       */
      get noMipmap() {
        return this._noMipmap;
      }
      /**
       * Gets the forced extension (if any)
       */
      get forcedExtension() {
        return this._forcedExtension;
      }
      /**
       * Creates a cube texture from an array of image urls
       * @param files defines an array of image urls
       * @param scene defines the hosting scene
       * @param noMipmap specifies if mip maps are not used
       * @returns a cube texture
       */
      static CreateFromImages(files, scene, noMipmap) {
        let rootUrlKey = "";
        for (const url of files) {
          rootUrlKey += url;
        }
        return new _CubeTexture(rootUrlKey, scene, null, noMipmap, files);
      }
      /**
       * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.
       * @param url defines the url of the prefiltered texture
       * @param scene defines the scene the texture is attached to
       * @param forcedExtension defines the extension of the file if different from the url
       * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary
       * @returns the prefiltered texture
       */
      static CreateFromPrefilteredData(url, scene, forcedExtension = null, createPolynomials = true) {
        const oldValue = scene.useDelayedTextureLoading;
        scene.useDelayedTextureLoading = false;
        const result = new _CubeTexture(url, scene, null, false, null, null, null, void 0, true, forcedExtension, createPolynomials);
        scene.useDelayedTextureLoading = oldValue;
        return result;
      }
      /**
       * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well
       * as prefiltered data.
       * @param rootUrl defines the url of the texture or the root name of the six images
       * @param sceneOrEngine defines the scene or engine the texture is attached to
       * @param extensionsOrOptions defines the suffixes add to the picture name in case six images are in use like _px.jpg or set of all options to create the cube texture
       * @param noMipmap defines if mipmaps should be created or not
       * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz
       * @param onLoad defines a callback triggered at the end of the file load if no errors occurred
       * @param onError defines a callback triggered in case of error during load
       * @param format defines the internal format to use for the texture once loaded
       * @param prefiltered defines whether or not the texture is created from prefiltered data
       * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name
       * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary
       * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
       * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
       * @param loaderOptions options to be passed to the loader
       * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)
       * @returns the cube texture
       */
      constructor(rootUrl, sceneOrEngine, extensionsOrOptions = null, noMipmap = false, files = null, onLoad = null, onError = null, format = 5, prefiltered = false, forcedExtension = null, createPolynomials = false, lodScale = DefaultLodScale, lodOffset = 0, loaderOptions, useSRGBBuffer) {
        super(sceneOrEngine);
        this.onLoadObservable = new Observable();
        this.boundingBoxPosition = Vector3.Zero();
        this._rotationY = 0;
        this._files = null;
        this._forcedExtension = null;
        this._extensions = null;
        this._textureMatrixRefraction = new Matrix();
        this._buffer = null;
        this.name = rootUrl;
        this.url = rootUrl;
        this._noMipmap = noMipmap;
        this.hasAlpha = false;
        this.isCube = true;
        this._textureMatrix = Matrix.Identity();
        this.coordinatesMode = Texture.CUBIC_MODE;
        let extensions = null;
        let buffer = null;
        if (extensionsOrOptions !== null && !Array.isArray(extensionsOrOptions)) {
          extensions = extensionsOrOptions.extensions ?? null;
          this._noMipmap = extensionsOrOptions.noMipmap ?? false;
          files = extensionsOrOptions.files ?? null;
          buffer = extensionsOrOptions.buffer ?? null;
          this._format = extensionsOrOptions.format ?? 5;
          prefiltered = extensionsOrOptions.prefiltered ?? false;
          forcedExtension = extensionsOrOptions.forcedExtension ?? null;
          this._createPolynomials = extensionsOrOptions.createPolynomials ?? false;
          this._lodScale = extensionsOrOptions.lodScale ?? DefaultLodScale;
          this._lodOffset = extensionsOrOptions.lodOffset ?? 0;
          this._loaderOptions = extensionsOrOptions.loaderOptions;
          this._useSRGBBuffer = extensionsOrOptions.useSRGBBuffer;
          onLoad = extensionsOrOptions.onLoad ?? null;
          onError = extensionsOrOptions.onError ?? null;
        } else {
          this._noMipmap = noMipmap;
          this._format = format;
          this._createPolynomials = createPolynomials;
          extensions = extensionsOrOptions;
          this._loaderOptions = loaderOptions;
          this._useSRGBBuffer = useSRGBBuffer;
          this._lodScale = lodScale;
          this._lodOffset = lodOffset;
        }
        if (!rootUrl && !files) {
          return;
        }
        this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, this.getScene()?.useDelayedTextureLoading, files, buffer);
      }
      /**
       * Get the current class name of the texture useful for serialization or dynamic coding.
       * @returns "CubeTexture"
       */
      getClassName() {
        return "CubeTexture";
      }
      /**
       * Update the url (and optional buffer) of this texture if url was null during construction.
       * @param url the url of the texture
       * @param forcedExtension defines the extension to use
       * @param onLoad callback called when the texture is loaded  (defaults to null)
       * @param prefiltered Defines whether the updated texture is prefiltered or not
       * @param onError callback called if there was an error during the loading process (defaults to null)
       * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...
       * @param delayLoad defines if the texture should be loaded now (false by default)
       * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz
       * @param buffer the buffer to use instead of loading from the url
       */
      updateURL(url, forcedExtension = null, onLoad = null, prefiltered = false, onError = null, extensions = null, delayLoad = false, files = null, buffer = null) {
        if (!this.name || this.name.startsWith("data:")) {
          this.name = url;
        }
        this.url = url;
        if (forcedExtension) {
          this._forcedExtension = forcedExtension;
        }
        const lastDot = url.lastIndexOf(".");
        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : "";
        const isDDS = extension.indexOf(".dds") === 0;
        const isEnv = extension.indexOf(".env") === 0;
        const isBasis = extension.indexOf(".basis") === 0;
        if (isEnv) {
          this.gammaSpace = false;
          this._prefiltered = false;
          this.anisotropicFilteringLevel = 1;
        } else {
          this._prefiltered = prefiltered;
          if (prefiltered) {
            this.gammaSpace = false;
            this.anisotropicFilteringLevel = 1;
          }
        }
        if (files) {
          this._files = files;
        } else {
          if (!isBasis && !isEnv && !isDDS && !extensions) {
            extensions = ["_px.jpg", "_py.jpg", "_pz.jpg", "_nx.jpg", "_ny.jpg", "_nz.jpg"];
          }
          this._files = this._files || [];
          this._files.length = 0;
          if (extensions) {
            for (let index = 0; index < extensions.length; index++) {
              this._files.push(url + extensions[index]);
            }
            this._extensions = extensions;
          }
        }
        this._buffer = buffer;
        if (delayLoad) {
          this.delayLoadState = 4;
          this._delayedOnLoad = onLoad;
          this._delayedOnError = onError;
        } else {
          this._loadTexture(onLoad, onError);
        }
      }
      /**
       * Delays loading of the cube texture
       * @param forcedExtension defines the extension to use
       */
      delayLoad(forcedExtension) {
        if (this.delayLoadState !== 4) {
          return;
        }
        if (forcedExtension) {
          this._forcedExtension = forcedExtension;
        }
        this.delayLoadState = 1;
        this._loadTexture(this._delayedOnLoad, this._delayedOnError);
      }
      /**
       * Returns the reflection texture matrix
       * @returns the reflection texture matrix
       */
      getReflectionTextureMatrix() {
        return this._textureMatrix;
      }
      /**
       * Sets the reflection texture matrix
       * @param value Reflection texture matrix
       */
      setReflectionTextureMatrix(value) {
        if (value.updateFlag === this._textureMatrix.updateFlag) {
          return;
        }
        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {
          this.getScene()?.markAllMaterialsAsDirty(1, (mat) => mat.getActiveTextures().indexOf(this) !== -1);
        }
        this._textureMatrix = value;
        if (!this.getScene()?.useRightHandedSystem) {
          return;
        }
        const scale = TmpVectors.Vector3[0];
        const quat = TmpVectors.Quaternion[0];
        const trans = TmpVectors.Vector3[1];
        this._textureMatrix.decompose(scale, quat, trans);
        quat.z *= -1;
        quat.w *= -1;
        Matrix.ComposeToRef(scale, quat, trans, this._textureMatrixRefraction);
      }
      /**
       * Gets a suitable rotate/transform matrix when the texture is used for refraction.
       * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.
       * @returns The refraction matrix
       */
      getRefractionTextureMatrix() {
        return this.getScene()?.useRightHandedSystem ? this._textureMatrixRefraction : this._textureMatrix;
      }
      _loadTexture(onLoad = null, onError = null) {
        const scene = this.getScene();
        const oldTexture = this._texture;
        this._texture = this._getFromCache(this.url, this._noMipmap, void 0, void 0, this._useSRGBBuffer, this.isCube);
        const onLoadProcessing = () => {
          this.onLoadObservable.notifyObservers(this);
          if (oldTexture) {
            oldTexture.dispose();
            this.getScene()?.markAllMaterialsAsDirty(1);
          }
          if (onLoad) {
            onLoad();
          }
        };
        const errorHandler = (message, exception) => {
          this._loadingError = true;
          this._errorObject = { message, exception };
          if (onError) {
            onError(message, exception);
          }
          Texture.OnTextureLoadErrorObservable.notifyObservers(this);
        };
        if (!this._texture) {
          if (this._prefiltered) {
            this._texture = this._getEngine().createPrefilteredCubeTexture(this.url, scene, this._lodScale, this._lodOffset, onLoad, errorHandler, this._format, this._forcedExtension, this._createPolynomials);
          } else {
            this._texture = this._getEngine().createCubeTexture(this.url, scene, this._files, this._noMipmap, onLoad, errorHandler, this._format, this._forcedExtension, false, this._lodScale, this._lodOffset, null, this._loaderOptions, !!this._useSRGBBuffer, this._buffer);
          }
          this._texture?.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));
        } else {
          if (this._texture.isReady) {
            Tools.SetImmediate(() => onLoadProcessing());
          } else {
            this._texture.onLoadedObservable.add(() => onLoadProcessing());
          }
        }
      }
      /**
       * Parses text to create a cube texture
       * @param parsedTexture define the serialized text to read from
       * @param scene defines the hosting scene
       * @param rootUrl defines the root url of the cube texture
       * @returns a cube texture
       */
      static Parse(parsedTexture, scene, rootUrl) {
        const texture = SerializationHelper.Parse(() => {
          let prefiltered = false;
          if (parsedTexture.prefiltered) {
            prefiltered = parsedTexture.prefiltered;
          }
          return new _CubeTexture(rootUrl + (parsedTexture.url ?? parsedTexture.name), scene, parsedTexture.extensions, false, parsedTexture.files || null, null, null, void 0, prefiltered, parsedTexture.forcedExtension);
        }, parsedTexture, scene);
        if (parsedTexture.boundingBoxPosition) {
          texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);
        }
        if (parsedTexture.boundingBoxSize) {
          texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);
        }
        if (parsedTexture.animations) {
          for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {
            const parsedAnimation = parsedTexture.animations[animationIndex];
            const internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              texture.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
        }
        return texture;
      }
      /**
       * Makes a clone, or deep copy, of the cube texture
       * @returns a new cube texture
       */
      clone() {
        let uniqueId = 0;
        const newCubeTexture = SerializationHelper.Clone(() => {
          const cubeTexture = new _CubeTexture(this.url, this.getScene() || this._getEngine(), this._extensions, this._noMipmap, this._files);
          uniqueId = cubeTexture.uniqueId;
          return cubeTexture;
        }, this);
        newCubeTexture.uniqueId = uniqueId;
        return newCubeTexture;
      }
    };
    __decorate([
      serialize()
    ], CubeTexture.prototype, "url", void 0);
    __decorate([
      serializeAsVector3()
    ], CubeTexture.prototype, "boundingBoxPosition", void 0);
    __decorate([
      serializeAsVector3()
    ], CubeTexture.prototype, "boundingBoxSize", null);
    __decorate([
      serialize("rotationY")
    ], CubeTexture.prototype, "rotationY", null);
    __decorate([
      serialize("files")
    ], CubeTexture.prototype, "_files", void 0);
    __decorate([
      serialize("forcedExtension")
    ], CubeTexture.prototype, "_forcedExtension", void 0);
    __decorate([
      serialize("extensions")
    ], CubeTexture.prototype, "_extensions", void 0);
    __decorate([
      serializeAsMatrix("textureMatrix")
    ], CubeTexture.prototype, "_textureMatrix", void 0);
    __decorate([
      serializeAsMatrix("textureMatrixRefraction")
    ], CubeTexture.prototype, "_textureMatrixRefraction", void 0);
    Texture._CubeTextureParser = CubeTexture.Parse;
    RegisterClass("BABYLON.CubeTexture", CubeTexture);
  }
});

// node_modules/@babylonjs/core/Misc/webRequest.fetch.js
async function _FetchAsync(url, options) {
  const method = options.method || "GET";
  return await new Promise((resolve, reject) => {
    const request = new WebRequest();
    request.addEventListener("readystatechange", () => {
      if (request.readyState == 4) {
        if (request.status == 200) {
          const headerValues = {};
          if (options.responseHeaders) {
            for (const header of options.responseHeaders) {
              headerValues[header] = request.getResponseHeader(header) || "";
            }
          }
          resolve({ response: request.response, headerValues });
        } else {
          reject(`Unable to fetch data from ${url}. Error code: ${request.status}`);
        }
      }
    });
    request.open(method, url);
    request.send();
  });
}
var init_webRequest_fetch = __esm({
  "node_modules/@babylonjs/core/Misc/webRequest.fetch.js"() {
    init_webRequest();
  }
});

// node_modules/@babylonjs/core/Loading/sceneLoader.js
function IsFactory(pluginOrFactory) {
  return !!pluginOrFactory.createPlugin;
}
function isFile(value) {
  return !!value.name;
}
function getDefaultPlugin() {
  return registeredPlugins[".babylon"];
}
function getPluginForMimeType(mimeType) {
  for (const registeredPluginKey in registeredPlugins) {
    const registeredPlugin = registeredPlugins[registeredPluginKey];
    if (registeredPlugin.mimeType === mimeType) {
      return registeredPlugin;
    }
  }
  return void 0;
}
function getPluginForExtension(extension, returnDefault) {
  const registeredPlugin = registeredPlugins[extension];
  if (registeredPlugin) {
    return registeredPlugin;
  }
  Logger.Warn("Unable to find a plugin to load " + extension + " files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes");
  return returnDefault ? getDefaultPlugin() : void 0;
}
function isPluginForExtensionAvailable(extension) {
  return !!registeredPlugins[extension];
}
function getPluginForDirectLoad(data) {
  for (const extension in registeredPlugins) {
    const plugin = registeredPlugins[extension].plugin;
    if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {
      return registeredPlugins[extension];
    }
  }
  return getDefaultPlugin();
}
function getFilenameExtension(sceneFilename) {
  const queryStringPosition = sceneFilename.indexOf("?");
  if (queryStringPosition !== -1) {
    sceneFilename = sceneFilename.substring(0, queryStringPosition);
  }
  const dotPosition = sceneFilename.lastIndexOf(".");
  return sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();
}
function getDirectLoad(sceneFilename) {
  if (sceneFilename.substring(0, 5) === "data:") {
    return sceneFilename.substring(5);
  }
  return null;
}
function formatErrorMessage(fileInfo, message, exception) {
  const fromLoad = fileInfo.rawData ? "binary data" : fileInfo.url;
  let errorMessage = "Unable to load from " + fromLoad;
  if (message) {
    errorMessage += `: ${message}`;
  } else if (exception) {
    errorMessage += `: ${exception}`;
  }
  return errorMessage;
}
async function loadDataAsync(fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension, name13, pluginOptions) {
  const directLoad = getDirectLoad(fileInfo.url);
  if (fileInfo.rawData && !pluginExtension) {
    throw "When using ArrayBufferView to load data the file extension must be provided.";
  }
  const fileExtension = !directLoad && !pluginExtension ? getFilenameExtension(fileInfo.url) : "";
  let registeredPlugin = pluginExtension ? getPluginForExtension(pluginExtension, true) : directLoad ? getPluginForDirectLoad(fileInfo.url) : getPluginForExtension(fileExtension, false);
  if (!registeredPlugin && fileExtension) {
    if (fileInfo.url && !fileInfo.url.startsWith("blob:")) {
      const response = await _FetchAsync(fileInfo.url, { method: "HEAD", responseHeaders: ["Content-Type"] });
      const mimeType = response.headerValues ? response.headerValues["Content-Type"] : "";
      if (mimeType) {
        registeredPlugin = getPluginForMimeType(mimeType);
      }
    }
    if (!registeredPlugin) {
      registeredPlugin = getDefaultPlugin();
    }
  }
  if (!registeredPlugin) {
    throw new Error(`No plugin or fallback for ${pluginExtension ?? fileInfo.url}`);
  }
  if (pluginOptions?.[registeredPlugin.plugin.name]?.enabled === false) {
    throw new Error(`The '${registeredPlugin.plugin.name}' plugin is disabled via the loader options passed to the loading operation.`);
  }
  if (fileInfo.rawData && !registeredPlugin.isBinary) {
    throw "Loading from ArrayBufferView can not be used with plugins that don't support binary loading.";
  }
  const getPluginInstance = (callback) => {
    if (IsFactory(registeredPlugin.plugin)) {
      const pluginFactory = registeredPlugin.plugin;
      const partialPlugin = pluginFactory.createPlugin(pluginOptions ?? {});
      if (partialPlugin instanceof Promise) {
        partialPlugin.then(callback).catch((error) => {
          onError("Error instantiating plugin.", error);
        });
        return null;
      } else {
        callback(partialPlugin);
        return partialPlugin;
      }
    } else {
      callback(registeredPlugin.plugin);
      return registeredPlugin.plugin;
    }
  };
  return getPluginInstance((plugin) => {
    if (!plugin) {
      throw `The loader plugin corresponding to the '${pluginExtension}' file type has not been found. If using es6, please import the plugin you wish to use before.`;
    }
    onPluginActivatedObservable.notifyObservers(plugin);
    if (directLoad && (plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url) || !IsBase64DataUrl(fileInfo.url))) {
      if (plugin.directLoad) {
        const result = plugin.directLoad(scene, directLoad);
        if (result instanceof Promise) {
          result.then((data) => {
            onSuccess(plugin, data);
          }).catch((error) => {
            onError("Error in directLoad of _loadData: " + error, error);
          });
        } else {
          onSuccess(plugin, result);
        }
      } else {
        onSuccess(plugin, directLoad);
      }
      return;
    }
    const useArrayBuffer = registeredPlugin.isBinary;
    const dataCallback = (data, responseURL) => {
      if (scene.isDisposed) {
        onError("Scene has been disposed");
        return;
      }
      onSuccess(plugin, data, responseURL);
    };
    let request = null;
    let pluginDisposed = false;
    plugin.onDisposeObservable?.add(() => {
      pluginDisposed = true;
      if (request) {
        request.abort();
        request = null;
      }
      onDispose();
    });
    const manifestChecked = () => {
      if (pluginDisposed) {
        return;
      }
      const errorCallback = (request2, exception) => {
        onError(request2?.statusText, exception);
      };
      if (!plugin.loadFile && fileInfo.rawData) {
        throw "Plugin does not support loading ArrayBufferView.";
      }
      request = plugin.loadFile ? plugin.loadFile(scene, fileInfo.rawData || fileInfo.file || fileInfo.url, fileInfo.rootUrl, dataCallback, onProgress, useArrayBuffer, errorCallback, name13) : scene._loadFile(fileInfo.file || fileInfo.url, dataCallback, onProgress, true, useArrayBuffer, errorCallback);
    };
    const engine = scene.getEngine();
    let canUseOfflineSupport = engine.enableOfflineSupport;
    if (canUseOfflineSupport) {
      let exceptionFound = false;
      for (const regex of scene.disableOfflineSupportExceptionRules) {
        if (regex.test(fileInfo.url)) {
          exceptionFound = true;
          break;
        }
      }
      canUseOfflineSupport = !exceptionFound;
    }
    if (canUseOfflineSupport && AbstractEngine.OfflineProviderFactory) {
      scene.offlineProvider = AbstractEngine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);
    } else {
      manifestChecked();
    }
  });
}
function GetFileInfo(rootUrl, sceneSource) {
  let url;
  let name13;
  let file = null;
  let rawData = null;
  if (!sceneSource) {
    url = rootUrl;
    name13 = Tools.GetFilename(rootUrl);
    rootUrl = Tools.GetFolderPath(rootUrl);
  } else if (isFile(sceneSource)) {
    url = `file:${sceneSource.name}`;
    name13 = sceneSource.name;
    file = sceneSource;
  } else if (ArrayBuffer.isView(sceneSource)) {
    url = "";
    name13 = RandomGUID();
    rawData = sceneSource;
  } else if (sceneSource.startsWith("data:")) {
    url = sceneSource;
    name13 = "";
  } else if (rootUrl) {
    const filename = sceneSource;
    if (filename.substring(0, 1) === "/") {
      Tools.Error("Wrong sceneFilename parameter");
      return null;
    }
    url = rootUrl + filename;
    name13 = filename;
  } else {
    url = sceneSource;
    name13 = Tools.GetFilename(sceneSource);
    rootUrl = Tools.GetFolderPath(sceneSource);
  }
  return {
    url,
    rootUrl,
    name: name13,
    file,
    rawData
  };
}
function RegisterSceneLoaderPlugin(plugin) {
  if (typeof plugin.extensions === "string") {
    const extension = plugin.extensions;
    registeredPlugins[extension.toLowerCase()] = {
      plugin,
      isBinary: false
    };
  } else {
    const extensions = plugin.extensions;
    const keys = Object.keys(extensions);
    for (const extension of keys) {
      registeredPlugins[extension.toLowerCase()] = {
        plugin,
        isBinary: extensions[extension].isBinary,
        mimeType: extensions[extension].mimeType
      };
    }
  }
}
function registerSceneLoaderPlugin(plugin) {
  RegisterSceneLoaderPlugin(plugin);
}
function GetRegisteredSceneLoaderPluginMetadata() {
  return Array.from(Object.entries(registeredPlugins).reduce((pluginMap, [extension, extensionRegistration]) => {
    let pluginMetadata = pluginMap.get(extensionRegistration.plugin.name);
    if (!pluginMetadata) {
      pluginMap.set(extensionRegistration.plugin.name, pluginMetadata = []);
    }
    pluginMetadata.push({ extension, isBinary: extensionRegistration.isBinary, mimeType: extensionRegistration.mimeType });
    return pluginMap;
  }, /* @__PURE__ */ new Map())).map(([name13, extensions]) => ({ name: name13, extensions }));
}
async function ImportMeshAsync(source, scene, options) {
  const { meshNames, rootUrl = "", onProgress, pluginExtension, name: name13, pluginOptions } = options ?? {};
  return await importMeshAsyncCoreAsync(meshNames, rootUrl, source, scene, onProgress, pluginExtension, name13, pluginOptions);
}
async function importMeshAsync(meshNames, rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name13 = "", pluginOptions = {}) {
  if (!scene) {
    Logger.Error("No scene available to import mesh to");
    return null;
  }
  const fileInfo = GetFileInfo(rootUrl, sceneFilename);
  if (!fileInfo) {
    return null;
  }
  const loadingToken = {};
  scene.addPendingData(loadingToken);
  const disposeHandler = () => {
    scene.removePendingData(loadingToken);
  };
  const errorHandler = (message, exception) => {
    const errorMessage = formatErrorMessage(fileInfo, message, exception);
    if (onError) {
      onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
    } else {
      Logger.Error(errorMessage);
    }
    disposeHandler();
  };
  const progressHandler = onProgress ? (event) => {
    try {
      onProgress(event);
    } catch (e) {
      errorHandler("Error in onProgress callback: " + e, e);
    }
  } : void 0;
  const successHandler = (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers) => {
    scene.importedMeshesFiles.push(fileInfo.url);
    if (onSuccess) {
      try {
        onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers);
      } catch (e) {
        errorHandler("Error in onSuccess callback: " + e, e);
      }
    }
    scene.removePendingData(loadingToken);
  };
  return await loadDataAsync(fileInfo, scene, (plugin, data, responseURL) => {
    if (plugin.rewriteRootURL) {
      fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);
    }
    if (plugin.importMesh) {
      const syncedPlugin = plugin;
      const meshes = [];
      const particleSystems = [];
      const skeletons = [];
      if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {
        return;
      }
      scene.loadingPluginName = plugin.name;
      successHandler(meshes, particleSystems, skeletons, [], [], [], [], []);
    } else {
      const asyncedPlugin = plugin;
      asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then((result) => {
        scene.loadingPluginName = plugin.name;
        successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights, result.spriteManagers);
      }).catch((error) => {
        errorHandler(error.message, error);
      });
    }
  }, progressHandler, errorHandler, disposeHandler, pluginExtension, name13, pluginOptions);
}
async function importMeshAsyncCoreAsync(meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension, name13, pluginOptions) {
  return await new Promise((resolve, reject) => {
    try {
      importMeshAsync(
        meshNames,
        rootUrl,
        sceneFilename,
        scene,
        (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers) => {
          resolve({
            meshes,
            particleSystems,
            skeletons,
            animationGroups,
            transformNodes,
            geometries,
            lights,
            spriteManagers
          });
        },
        onProgress,
        (scene2, message, exception) => {
          reject(exception || new Error(message));
        },
        pluginExtension,
        name13,
        pluginOptions
        // eslint-disable-next-line github/no-then
      ).catch(reject);
    } catch (error) {
      reject(error);
    }
  });
}
async function loadSceneImplAsync(rootUrl, sceneFilename = "", engine = EngineStore.LastCreatedEngine, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name13 = "", pluginOptions = {}) {
  if (!engine) {
    Tools.Error("No engine available");
    return;
  }
  await appendSceneImplAsync(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension, name13, pluginOptions);
}
async function LoadSceneAsync(source, engine, options) {
  const { rootUrl = "", onProgress, pluginExtension, name: name13, pluginOptions } = options ?? {};
  return await loadSceneSharedAsync(rootUrl, source, engine, onProgress, pluginExtension, name13, pluginOptions);
}
async function loadSceneAsync(source, engine, options) {
  return await LoadSceneAsync(source, engine, options);
}
async function loadSceneSharedAsync(rootUrl, sceneFilename, engine, onProgress, pluginExtension, name13, pluginOptions) {
  return await new Promise((resolve, reject) => {
    loadSceneImplAsync(rootUrl, sceneFilename, engine, (scene) => {
      resolve(scene);
    }, onProgress, (scene, message, exception) => {
      reject(exception || new Error(message));
    }, pluginExtension, name13, pluginOptions);
  });
}
async function appendSceneImplAsync(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name13 = "", pluginOptions = {}) {
  if (!scene) {
    Logger.Error("No scene available to append to");
    return null;
  }
  const fileInfo = GetFileInfo(rootUrl, sceneFilename);
  if (!fileInfo) {
    return null;
  }
  const loadingToken = {};
  scene.addPendingData(loadingToken);
  const disposeHandler = () => {
    scene.removePendingData(loadingToken);
  };
  if (SceneLoaderFlags.ShowLoadingScreen && !showingLoadingScreen) {
    showingLoadingScreen = true;
    scene.getEngine().displayLoadingUI();
    scene.executeWhenReady(() => {
      scene.getEngine().hideLoadingUI();
      showingLoadingScreen = false;
    });
  }
  const errorHandler = (message, exception) => {
    const errorMessage = formatErrorMessage(fileInfo, message, exception);
    if (onError) {
      onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
    } else {
      Logger.Error(errorMessage);
    }
    disposeHandler();
  };
  const progressHandler = onProgress ? (event) => {
    try {
      onProgress(event);
    } catch (e) {
      errorHandler("Error in onProgress callback", e);
    }
  } : void 0;
  const successHandler = () => {
    if (onSuccess) {
      try {
        onSuccess(scene);
      } catch (e) {
        errorHandler("Error in onSuccess callback", e);
      }
    }
    scene.removePendingData(loadingToken);
  };
  return await loadDataAsync(fileInfo, scene, (plugin, data) => {
    if (plugin.load) {
      const syncedPlugin = plugin;
      if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {
        return;
      }
      scene.loadingPluginName = plugin.name;
      successHandler();
    } else {
      const asyncedPlugin = plugin;
      asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(() => {
        scene.loadingPluginName = plugin.name;
        successHandler();
      }).catch((error) => {
        errorHandler(error.message, error);
      });
    }
  }, progressHandler, errorHandler, disposeHandler, pluginExtension, name13, pluginOptions);
}
async function AppendSceneAsync(source, scene, options) {
  const { rootUrl = "", onProgress, pluginExtension, name: name13, pluginOptions } = options ?? {};
  await appendSceneSharedAsync(rootUrl, source, scene, onProgress, pluginExtension, name13, pluginOptions);
}
async function appendSceneAsync(source, scene, options) {
  return await AppendSceneAsync(source, scene, options);
}
async function appendSceneSharedAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name13, pluginOptions) {
  return await new Promise((resolve, reject) => {
    try {
      appendSceneImplAsync(
        rootUrl,
        sceneFilename,
        scene,
        (scene2) => {
          resolve(scene2);
        },
        onProgress,
        (scene2, message, exception) => {
          reject(exception || new Error(message));
        },
        pluginExtension,
        name13,
        pluginOptions
        // eslint-disable-next-line github/no-then
      ).catch(reject);
    } catch (error) {
      reject(error);
    }
  });
}
async function loadAssetContainerImplAsync(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name13 = "", pluginOptions = {}) {
  if (!scene) {
    Logger.Error("No scene available to load asset container to");
    return null;
  }
  const fileInfo = GetFileInfo(rootUrl, sceneFilename);
  if (!fileInfo) {
    return null;
  }
  const loadingToken = {};
  scene.addPendingData(loadingToken);
  const disposeHandler = () => {
    scene.removePendingData(loadingToken);
  };
  const errorHandler = (message, exception) => {
    const errorMessage = formatErrorMessage(fileInfo, message, exception);
    if (onError) {
      onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
    } else {
      Logger.Error(errorMessage);
    }
    disposeHandler();
  };
  const progressHandler = onProgress ? (event) => {
    try {
      onProgress(event);
    } catch (e) {
      errorHandler("Error in onProgress callback", e);
    }
  } : void 0;
  const successHandler = (assets) => {
    if (onSuccess) {
      try {
        onSuccess(assets);
      } catch (e) {
        errorHandler("Error in onSuccess callback", e);
      }
    }
    scene.removePendingData(loadingToken);
  };
  return await loadDataAsync(fileInfo, scene, (plugin, data) => {
    if (plugin.loadAssetContainer) {
      const syncedPlugin = plugin;
      const assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);
      if (!assetContainer) {
        return;
      }
      assetContainer.populateRootNodes();
      scene.loadingPluginName = plugin.name;
      successHandler(assetContainer);
    } else if (plugin.loadAssetContainerAsync) {
      const asyncedPlugin = plugin;
      asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then((assetContainer) => {
        assetContainer.populateRootNodes();
        scene.loadingPluginName = plugin.name;
        successHandler(assetContainer);
      }).catch((error) => {
        errorHandler(error.message, error);
      });
    } else {
      errorHandler("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.");
    }
  }, progressHandler, errorHandler, disposeHandler, pluginExtension, name13, pluginOptions);
}
async function LoadAssetContainerAsync(source, scene, options) {
  const { rootUrl = "", onProgress, pluginExtension, name: name13, pluginOptions } = options ?? {};
  return await loadAssetContainerSharedAsync(rootUrl, source, scene, onProgress, pluginExtension, name13, pluginOptions);
}
async function loadAssetContainerAsync(source, scene, options) {
  return await LoadAssetContainerAsync(source, scene, options);
}
async function loadAssetContainerSharedAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name13, pluginOptions) {
  return await new Promise((resolve, reject) => {
    try {
      loadAssetContainerImplAsync(
        rootUrl,
        sceneFilename,
        scene,
        (assets) => {
          resolve(assets);
        },
        onProgress,
        (scene2, message, exception) => {
          reject(exception || new Error(message));
        },
        pluginExtension,
        name13,
        pluginOptions
        // eslint-disable-next-line github/no-then
      ).catch(reject);
    } catch (error) {
      reject(error);
    }
  });
}
async function importAnimationsImplAsync(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = 0, targetConverter = null, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name13 = "", pluginOptions = {}) {
  if (!scene) {
    Logger.Error("No scene available to load animations to");
    return;
  }
  if (overwriteAnimations) {
    for (const animatable of scene.animatables) {
      animatable.reset();
    }
    scene.stopAllAnimations();
    const animationGroups = scene.animationGroups.slice();
    for (const animationGroup of animationGroups) {
      animationGroup.dispose();
    }
    const nodes = scene.getNodes();
    for (const node of nodes) {
      if (node.animations) {
        node.animations = [];
      }
    }
  } else {
    switch (animationGroupLoadingMode) {
      case 0:
        const animationGroups = scene.animationGroups.slice();
        for (const animationGroup of animationGroups) {
          animationGroup.dispose();
        }
        break;
      case 1:
        for (const animationGroup of scene.animationGroups) {
          animationGroup.stop();
        }
        break;
      case 2:
        for (const animationGroup of scene.animationGroups) {
          animationGroup.reset();
          animationGroup.restart();
        }
        break;
      case 3:
        break;
      default:
        Logger.Error("Unknown animation group loading mode value '" + animationGroupLoadingMode + "'");
        return;
    }
  }
  const startingIndexForNewAnimatables = scene.animatables.length;
  const onAssetContainerLoaded = (container) => {
    container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);
    container.dispose();
    scene.onAnimationFileImportedObservable.notifyObservers(scene);
    if (onSuccess) {
      onSuccess(scene);
    }
  };
  await loadAssetContainerImplAsync(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension, name13, pluginOptions);
}
async function ImportAnimationsAsync(source, scene, options) {
  const { rootUrl = "", overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name: name13, pluginOptions } = options ?? {};
  await importAnimationsSharedAsync(rootUrl, source, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name13, pluginOptions);
}
async function importAnimationsAsync(source, scene, options) {
  return await ImportAnimationsAsync(source, scene, options);
}
async function importAnimationsSharedAsync(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name13, pluginOptions) {
  return await new Promise((resolve, reject) => {
    try {
      importAnimationsImplAsync(
        rootUrl,
        sceneFilename,
        scene,
        overwriteAnimations,
        animationGroupLoadingMode,
        targetConverter,
        (scene2) => {
          resolve(scene2);
        },
        onProgress,
        (scene2, message, exception) => {
          reject(exception || new Error(message));
        },
        pluginExtension,
        name13,
        pluginOptions
        // eslint-disable-next-line github/no-then
      ).catch(reject);
    } catch (error) {
      reject(error);
    }
  });
}
var SceneLoaderAnimationGroupLoadingMode, onPluginActivatedObservable, registeredPlugins, showingLoadingScreen, SceneLoader;
var init_sceneLoader = __esm({
  "node_modules/@babylonjs/core/Loading/sceneLoader.js"() {
    init_tools();
    init_observable();
    init_scene();
    init_engineStore();
    init_logger();
    init_sceneLoaderFlags();
    init_fileTools();
    init_error();
    init_guid();
    init_abstractEngine();
    init_webRequest_fetch();
    (function(SceneLoaderAnimationGroupLoadingMode2) {
      SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Clean"] = 0] = "Clean";
      SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Stop"] = 1] = "Stop";
      SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Sync"] = 2] = "Sync";
      SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["NoSync"] = 3] = "NoSync";
    })(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));
    onPluginActivatedObservable = new Observable();
    registeredPlugins = {};
    showingLoadingScreen = false;
    SceneLoader = class {
      /**
       * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data
       */
      static get ForceFullSceneLoadingForIncremental() {
        return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;
      }
      static set ForceFullSceneLoadingForIncremental(value) {
        SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;
      }
      /**
       * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene
       */
      static get ShowLoadingScreen() {
        return SceneLoaderFlags.ShowLoadingScreen;
      }
      static set ShowLoadingScreen(value) {
        SceneLoaderFlags.ShowLoadingScreen = value;
      }
      /**
       * Defines the current logging level (while loading the scene)
       * @ignorenaming
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      static get loggingLevel() {
        return SceneLoaderFlags.loggingLevel;
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      static set loggingLevel(value) {
        SceneLoaderFlags.loggingLevel = value;
      }
      /**
       * Gets or set a boolean indicating if matrix weights must be cleaned upon loading
       */
      static get CleanBoneMatrixWeights() {
        return SceneLoaderFlags.CleanBoneMatrixWeights;
      }
      static set CleanBoneMatrixWeights(value) {
        SceneLoaderFlags.CleanBoneMatrixWeights = value;
      }
      /**
       * Gets the default plugin (used to load Babylon files)
       * @returns the .babylon plugin
       */
      static GetDefaultPlugin() {
        return getDefaultPlugin();
      }
      // Public functions
      /**
       * Gets a plugin that can load the given extension
       * @param extension defines the extension to load
       * @returns a plugin or null if none works
       */
      static GetPluginForExtension(extension) {
        return getPluginForExtension(extension, true)?.plugin;
      }
      /**
       * Gets a boolean indicating that the given extension can be loaded
       * @param extension defines the extension to load
       * @returns true if the extension is supported
       */
      static IsPluginForExtensionAvailable(extension) {
        return isPluginForExtensionAvailable(extension);
      }
      /**
       * Adds a new plugin to the list of registered plugins
       * @param plugin defines the plugin to add
       */
      static RegisterPlugin(plugin) {
        RegisterSceneLoaderPlugin(plugin);
      }
      /**
       * Import meshes into a scene
       * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
       * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
       * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
       * @param scene the instance of BABYLON.Scene to append to
       * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds
       * @param onProgress a callback with a progress event for each file being loaded
       * @param onError a callback with the scene, a message, and possibly an exception when import fails
       * @param pluginExtension the extension used to determine the plugin
       * @param name defines the name of the file, if the data is binary
       * @param pluginOptions defines the options to use with the plugin
       * @deprecated Please use the module level {@link ImportMeshAsync} instead
       */
      static ImportMesh(meshNames, rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name13, pluginOptions) {
        importMeshAsync(meshNames, rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name13, pluginOptions).catch((error) => onError?.(EngineStore.LastCreatedScene, error?.message, error));
      }
      /**
       * Import meshes into a scene
       * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
       * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
       * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
       * @param scene the instance of BABYLON.Scene to append to
       * @param onProgress a callback with a progress event for each file being loaded
       * @param pluginExtension the extension used to determine the plugin
       * @param name defines the name of the file
       * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups
       * @deprecated Please use the module level {@link ImportMeshAsync} instead
       */
      static async ImportMeshAsync(meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension, name13) {
        return await importMeshAsyncCoreAsync(meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension, name13);
      }
      /**
       * Load a scene
       * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
       * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
       * @param engine is the instance of BABYLON.Engine to use to create the scene
       * @param onSuccess a callback with the scene when import succeeds
       * @param onProgress a callback with a progress event for each file being loaded
       * @param onError a callback with the scene, a message, and possibly an exception when import fails
       * @param pluginExtension the extension used to determine the plugin
       * @param name defines the filename, if the data is binary
       * @deprecated Please use the module level {@link LoadSceneAsync} instead
       */
      static Load(rootUrl, sceneFilename, engine, onSuccess, onProgress, onError, pluginExtension, name13) {
        loadSceneImplAsync(rootUrl, sceneFilename, engine, onSuccess, onProgress, onError, pluginExtension, name13).catch((error) => onError?.(EngineStore.LastCreatedScene, error?.message, error));
      }
      /**
       * Load a scene
       * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
       * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
       * @param engine is the instance of BABYLON.Engine to use to create the scene
       * @param onProgress a callback with a progress event for each file being loaded
       * @param pluginExtension the extension used to determine the plugin
       * @param name defines the filename, if the data is binary
       * @returns The loaded scene
       * @deprecated Please use the module level {@link LoadSceneAsync} instead
       */
      static async LoadAsync(rootUrl, sceneFilename, engine, onProgress, pluginExtension, name13) {
        return await loadSceneSharedAsync(rootUrl, sceneFilename, engine, onProgress, pluginExtension, name13);
      }
      /**
       * Append a scene
       * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
       * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
       * @param scene is the instance of BABYLON.Scene to append to
       * @param onSuccess a callback with the scene when import succeeds
       * @param onProgress a callback with a progress event for each file being loaded
       * @param onError a callback with the scene, a message, and possibly an exception when import fails
       * @param pluginExtension the extension used to determine the plugin
       * @param name defines the name of the file, if the data is binary
       * @deprecated Please use the module level {@link AppendSceneAsync} instead
       */
      static Append(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name13) {
        appendSceneImplAsync(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name13).catch((error) => onError?.(scene ?? EngineStore.LastCreatedScene, error?.message, error));
      }
      /**
       * Append a scene
       * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
       * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
       * @param scene is the instance of BABYLON.Scene to append to
       * @param onProgress a callback with a progress event for each file being loaded
       * @param pluginExtension the extension used to determine the plugin
       * @param name defines the name of the file, if the data is binary
       * @returns The given scene
       * @deprecated Please use the module level {@link AppendSceneAsync} instead
       */
      static async AppendAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name13) {
        return await appendSceneSharedAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name13);
      }
      /**
       * Load a scene into an asset container
       * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
       * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
       * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
       * @param onSuccess a callback with the scene when import succeeds
       * @param onProgress a callback with a progress event for each file being loaded
       * @param onError a callback with the scene, a message, and possibly an exception when import fails
       * @param pluginExtension the extension used to determine the plugin
       * @param name defines the filename, if the data is binary
       * @deprecated Please use the module level {@link LoadAssetContainerAsync} instead
       */
      static LoadAssetContainer(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name13) {
        loadAssetContainerImplAsync(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name13).catch((error) => onError?.(scene ?? EngineStore.LastCreatedScene, error?.message, error));
      }
      /**
       * Load a scene into an asset container
       * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
       * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene (default: empty string)
       * @param scene is the instance of Scene to append to
       * @param onProgress a callback with a progress event for each file being loaded
       * @param pluginExtension the extension used to determine the plugin
       * @param name defines the filename, if the data is binary
       * @returns The loaded asset container
       * @deprecated Please use the module level {@link LoadAssetContainerAsync} instead
       */
      static async LoadAssetContainerAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name13) {
        return await loadAssetContainerSharedAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name13);
      }
      /**
       * Import animations from a file into a scene
       * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
       * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
       * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
       * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise
       * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones
       * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)
       * @param onSuccess a callback with the scene when import succeeds
       * @param onProgress a callback with a progress event for each file being loaded
       * @param onError a callback with the scene, a message, and possibly an exception when import fails
       * @param pluginExtension the extension used to determine the plugin
       * @param name defines the filename, if the data is binary
       * @deprecated Please use the module level {@link ImportAnimationsAsync} instead
       */
      static ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension, name13) {
        importAnimationsImplAsync(
          rootUrl,
          sceneFilename,
          scene,
          overwriteAnimations,
          animationGroupLoadingMode,
          targetConverter,
          onSuccess,
          onProgress,
          onError,
          pluginExtension,
          name13
          // eslint-disable-next-line github/no-then
        ).catch((error) => onError?.(scene ?? EngineStore.LastCreatedScene, error?.message, error));
      }
      /**
       * Import animations from a file into a scene
       * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
       * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
       * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
       * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise
       * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones
       * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)
       * @param onSuccess a callback with the scene when import succeeds
       * @param onProgress a callback with a progress event for each file being loaded
       * @param onError a callback with the scene, a message, and possibly an exception when import fails
       * @param pluginExtension the extension used to determine the plugin
       * @param name defines the filename, if the data is binary
       * @returns the updated scene with imported animations
       * @deprecated Please use the module level {@link ImportAnimationsAsync} instead
       */
      static async ImportAnimationsAsync(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension, name13) {
        return await importAnimationsSharedAsync(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name13);
      }
    };
    SceneLoader.NO_LOGGING = 0;
    SceneLoader.MINIMAL_LOGGING = 1;
    SceneLoader.SUMMARY_LOGGING = 2;
    SceneLoader.DETAILED_LOGGING = 3;
    SceneLoader.OnPluginActivatedObservable = onPluginActivatedObservable;
  }
});

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockConnectionPointTypes.js
var NodeMaterialBlockConnectionPointTypes;
var init_nodeMaterialBlockConnectionPointTypes = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockConnectionPointTypes.js"() {
    (function(NodeMaterialBlockConnectionPointTypes2) {
      NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Float"] = 1] = "Float";
      NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Int"] = 2] = "Int";
      NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector2"] = 4] = "Vector2";
      NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector3"] = 8] = "Vector3";
      NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Vector4"] = 16] = "Vector4";
      NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Color3"] = 32] = "Color3";
      NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Color4"] = 64] = "Color4";
      NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Matrix"] = 128] = "Matrix";
      NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["Object"] = 256] = "Object";
      NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["AutoDetect"] = 1024] = "AutoDetect";
      NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["BasedOnInput"] = 2048] = "BasedOnInput";
      NodeMaterialBlockConnectionPointTypes2[NodeMaterialBlockConnectionPointTypes2["All"] = 4095] = "All";
    })(NodeMaterialBlockConnectionPointTypes || (NodeMaterialBlockConnectionPointTypes = {}));
  }
});

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockTargets.js
var NodeMaterialBlockTargets;
var init_nodeMaterialBlockTargets = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockTargets.js"() {
    (function(NodeMaterialBlockTargets2) {
      NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Vertex"] = 1] = "Vertex";
      NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Fragment"] = 2] = "Fragment";
      NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["Neutral"] = 4] = "Neutral";
      NodeMaterialBlockTargets2[NodeMaterialBlockTargets2["VertexAndFragment"] = 3] = "VertexAndFragment";
    })(NodeMaterialBlockTargets || (NodeMaterialBlockTargets = {}));
  }
});

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBlockConnectionPoint.js
var NodeMaterialConnectionPointCompatibilityStates, NodeMaterialConnectionPointDirection, NodeMaterialConnectionPoint;
var init_nodeMaterialBlockConnectionPoint = __esm({
  "node_modules/@babylonjs/core/Materials/Node/nodeMaterialBlockConnectionPoint.js"() {
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialBlockTargets();
    init_observable();
    (function(NodeMaterialConnectionPointCompatibilityStates2) {
      NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["Compatible"] = 0] = "Compatible";
      NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["TypeIncompatible"] = 1] = "TypeIncompatible";
      NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["TargetIncompatible"] = 2] = "TargetIncompatible";
      NodeMaterialConnectionPointCompatibilityStates2[NodeMaterialConnectionPointCompatibilityStates2["HierarchyIssue"] = 3] = "HierarchyIssue";
    })(NodeMaterialConnectionPointCompatibilityStates || (NodeMaterialConnectionPointCompatibilityStates = {}));
    (function(NodeMaterialConnectionPointDirection2) {
      NodeMaterialConnectionPointDirection2[NodeMaterialConnectionPointDirection2["Input"] = 0] = "Input";
      NodeMaterialConnectionPointDirection2[NodeMaterialConnectionPointDirection2["Output"] = 1] = "Output";
    })(NodeMaterialConnectionPointDirection || (NodeMaterialConnectionPointDirection = {}));
    NodeMaterialConnectionPoint = class _NodeMaterialConnectionPoint {
      /**
       * Checks if two types are equivalent
       * @param type1 type 1 to check
       * @param type2 type 2 to check
       * @returns true if both types are equivalent, else false
       */
      static AreEquivalentTypes(type1, type2) {
        switch (type1) {
          case NodeMaterialBlockConnectionPointTypes.Vector3: {
            if (type2 === NodeMaterialBlockConnectionPointTypes.Color3) {
              return true;
            }
            break;
          }
          case NodeMaterialBlockConnectionPointTypes.Vector4: {
            if (type2 === NodeMaterialBlockConnectionPointTypes.Color4) {
              return true;
            }
            break;
          }
          case NodeMaterialBlockConnectionPointTypes.Color3: {
            if (type2 === NodeMaterialBlockConnectionPointTypes.Vector3) {
              return true;
            }
            break;
          }
          case NodeMaterialBlockConnectionPointTypes.Color4: {
            if (type2 === NodeMaterialBlockConnectionPointTypes.Vector4) {
              return true;
            }
            break;
          }
        }
        return false;
      }
      /**
       * Boolean used to provide visual clue to users when some ports are not active in the current block configuration
       */
      get isInactive() {
        return this._isInactive;
      }
      get _connectedPoint() {
        return this._connectedPointBackingField;
      }
      set _connectedPoint(value) {
        if (this._connectedPointBackingField === value) {
          return;
        }
        this._connectedPointTypeChangedObserver?.remove();
        this._updateTypeDependentState(() => this._connectedPointBackingField = value);
        if (this._connectedPointBackingField) {
          this._connectedPointTypeChangedObserver = this._connectedPointBackingField.onTypeChangedObservable.add(() => {
            this._notifyTypeChanged();
          });
        }
      }
      /** @internal */
      get _typeConnectionSource() {
        return this._typeConnectionSourceBackingField;
      }
      /** @internal */
      set _typeConnectionSource(value) {
        if (this._typeConnectionSourceBackingField === value) {
          return;
        }
        this._typeConnectionSourceTypeChangedObserver?.remove();
        this._updateTypeDependentState(() => this._typeConnectionSourceBackingField = value);
        if (this._typeConnectionSourceBackingField) {
          this._typeConnectionSourceTypeChangedObserver = this._typeConnectionSourceBackingField.onTypeChangedObservable.add(() => {
            this._notifyTypeChanged();
          });
        }
      }
      /** @internal */
      get _defaultConnectionPointType() {
        return this._defaultConnectionPointTypeBackingField;
      }
      /** @internal */
      set _defaultConnectionPointType(value) {
        this._updateTypeDependentState(() => this._defaultConnectionPointTypeBackingField = value);
      }
      /** @internal */
      get _linkedConnectionSource() {
        return this._linkedConnectionSourceBackingField;
      }
      /** @internal */
      set _linkedConnectionSource(value) {
        if (this._linkedConnectionSourceBackingField === value) {
          return;
        }
        this._linkedConnectionSourceTypeChangedObserver?.remove();
        this._updateTypeDependentState(() => this._linkedConnectionSourceBackingField = value);
        this._isMainLinkSource = false;
        if (this._linkedConnectionSourceBackingField) {
          this._linkedConnectionSourceTypeChangedObserver = this._linkedConnectionSourceBackingField.onTypeChangedObservable.add(() => {
            this._notifyTypeChanged();
          });
        }
      }
      /** Gets the direction of the point */
      get direction() {
        return this._direction;
      }
      /**
       * Gets the declaration variable name in the shader
       */
      get declarationVariableName() {
        if (this._ownerBlock.isInput) {
          return this._ownerBlock.declarationVariableName;
        }
        if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {
          return this._connectedPoint.declarationVariableName;
        }
        return this._associatedVariableName;
      }
      /**
       * Gets or sets the associated variable name in the shader
       */
      get associatedVariableName() {
        if (this._ownerBlock.isInput) {
          return this._ownerBlock.associatedVariableName;
        }
        if ((!this._enforceAssociatedVariableName || !this._associatedVariableName) && this._connectedPoint) {
          return this._connectedPoint.associatedVariableName;
        }
        return this._associatedVariableName;
      }
      set associatedVariableName(value) {
        this._associatedVariableName = value;
      }
      /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */
      get innerType() {
        if (this._linkedConnectionSource && !this._isMainLinkSource && this._linkedConnectionSource.isConnected) {
          return this.type;
        }
        return this._type;
      }
      /**
       * Gets or sets the connection point type (default is float)
       */
      get type() {
        if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {
          if (this._ownerBlock.isInput) {
            return this._ownerBlock.type;
          }
          if (this._connectedPoint) {
            return this._connectedPoint.type;
          }
          if (this._linkedConnectionSource) {
            if (this._linkedConnectionSource.isConnected) {
              if (this._linkedConnectionSource.connectedPoint._redirectedSource && this._linkedConnectionSource.connectedPoint._redirectedSource.isConnected) {
                return this._linkedConnectionSource.connectedPoint._redirectedSource.type;
              }
              return this._linkedConnectionSource.type;
            }
            if (this._linkedConnectionSource._defaultConnectionPointType) {
              return this._linkedConnectionSource._defaultConnectionPointType;
            }
          }
          if (this._defaultConnectionPointType) {
            return this._defaultConnectionPointType;
          }
        }
        if (this._type === NodeMaterialBlockConnectionPointTypes.BasedOnInput) {
          if (this._typeConnectionSource) {
            if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {
              return this._defaultConnectionPointType;
            }
            return this._typeConnectionSource.type;
          } else if (this._defaultConnectionPointType) {
            return this._defaultConnectionPointType;
          }
        }
        return this._type;
      }
      set type(value) {
        this._updateTypeDependentState(() => this._type = value);
      }
      /** Gets or sets the target of that connection point */
      get target() {
        if (!this._prioritizeVertex || !this._ownerBlock) {
          return this._target;
        }
        if (this._target !== NodeMaterialBlockTargets.VertexAndFragment) {
          return this._target;
        }
        if (this._ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
          return NodeMaterialBlockTargets.Fragment;
        }
        return NodeMaterialBlockTargets.Vertex;
      }
      set target(value) {
        this._target = value;
      }
      /**
       * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock
       */
      get isConnected() {
        return this.connectedPoint !== null || this.hasEndpoints;
      }
      /**
       * Gets a boolean indicating that the current point is connected to an input block
       */
      get isConnectedToInputBlock() {
        return this.connectedPoint !== null && this.connectedPoint.ownerBlock.isInput;
      }
      /**
       * Gets a the connected input block (if any)
       */
      get connectInputBlock() {
        if (!this.isConnectedToInputBlock) {
          return null;
        }
        return this.connectedPoint.ownerBlock;
      }
      /** Get the other side of the connection (if any) */
      get connectedPoint() {
        return this._connectedPoint;
      }
      /** Get the block that owns this connection point */
      get ownerBlock() {
        return this._ownerBlock;
      }
      /** Get the block connected on the other side of this connection (if any) */
      get sourceBlock() {
        if (!this._connectedPoint) {
          return null;
        }
        return this._connectedPoint.ownerBlock;
      }
      /** Get the block connected on the endpoints of this connection (if any) */
      get connectedBlocks() {
        if (this._endpoints.length === 0) {
          return [];
        }
        return this._endpoints.map((e) => e.ownerBlock);
      }
      /** Gets the list of connected endpoints */
      get endpoints() {
        return this._endpoints;
      }
      /** Gets a boolean indicating if that output point is connected to at least one input */
      get hasEndpoints() {
        return this._endpoints && this._endpoints.length > 0;
      }
      /** Gets a boolean indicating that this connection has a path to the vertex output*/
      get isDirectlyConnectedToVertexOutput() {
        if (!this.hasEndpoints) {
          return false;
        }
        for (const endpoint of this._endpoints) {
          if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {
            return true;
          }
          if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
            if (endpoint.ownerBlock.outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {
              return true;
            }
          }
        }
        return false;
      }
      /** Gets a boolean indicating that this connection will be used in the vertex shader */
      get isConnectedInVertexShader() {
        if (this.target === NodeMaterialBlockTargets.Vertex) {
          return true;
        }
        if (!this.hasEndpoints) {
          return false;
        }
        for (const endpoint of this._endpoints) {
          if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Vertex) {
            return true;
          }
          if (endpoint.target === NodeMaterialBlockTargets.Vertex) {
            return true;
          }
          if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
            if (endpoint.ownerBlock.outputs.some((o) => o.isConnectedInVertexShader)) {
              return true;
            }
          }
        }
        return false;
      }
      /** Gets a boolean indicating that this connection will be used in the fragment shader */
      get isConnectedInFragmentShader() {
        if (this.target === NodeMaterialBlockTargets.Fragment) {
          return true;
        }
        if (!this.hasEndpoints) {
          return false;
        }
        for (const endpoint of this._endpoints) {
          if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
            return true;
          }
          if (endpoint.ownerBlock.target === NodeMaterialBlockTargets.Neutral || endpoint.ownerBlock.target === NodeMaterialBlockTargets.VertexAndFragment) {
            if (endpoint.ownerBlock.isConnectedInFragmentShader()) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Creates a block suitable to be used as an input for this input point.
       * If null is returned, a block based on the point type will be created.
       * @returns The returned string parameter is the name of the output point of NodeMaterialBlock (first parameter of the returned array) that can be connected to the input
       */
      createCustomInputBlock() {
        return null;
      }
      /**
       * Creates a new connection point
       * @param name defines the connection point name
       * @param ownerBlock defines the block hosting this connection point
       * @param direction defines the direction of the connection point
       */
      constructor(name13, ownerBlock, direction) {
        this._isInactive = false;
        this._preventBubbleUp = false;
        this._connectedPointBackingField = null;
        this._endpoints = new Array();
        this._redirectedSource = null;
        this._typeConnectionSourceBackingField = null;
        this._defaultConnectionPointTypeBackingField = null;
        this._isMainLinkSource = false;
        this._linkedConnectionSourceBackingField = null;
        this._acceptedConnectionPointType = null;
        this._type = NodeMaterialBlockConnectionPointTypes.Float;
        this._enforceAssociatedVariableName = false;
        this._forPostBuild = false;
        this.needDualDirectionValidation = false;
        this.acceptedConnectionPointTypes = [];
        this.excludedConnectionPointTypes = [];
        this.onConnectionObservable = new Observable();
        this.onDisconnectionObservable = new Observable();
        this.onTypeChangedObservable = new Observable();
        this._isTypeChangeObservableNotifying = false;
        this.isExposedOnFrame = false;
        this.exposedPortPosition = -1;
        this._prioritizeVertex = false;
        this._target = NodeMaterialBlockTargets.VertexAndFragment;
        this._ownerBlock = ownerBlock;
        this.name = name13;
        this._direction = direction;
      }
      /**
       * Gets the current class name e.g. "NodeMaterialConnectionPoint"
       * @returns the class name
       */
      getClassName() {
        return "NodeMaterialConnectionPoint";
      }
      /**
       * Gets a boolean indicating if the current point can be connected to another point
       * @param connectionPoint defines the other connection point
       * @returns a boolean
       */
      canConnectTo(connectionPoint) {
        return this.checkCompatibilityState(connectionPoint) === 0;
      }
      /**
       * Gets a number indicating if the current point can be connected to another point
       * @param connectionPoint defines the other connection point
       * @returns a number defining the compatibility state
       */
      checkCompatibilityState(connectionPoint) {
        const ownerBlock = this._ownerBlock;
        const otherBlock = connectionPoint.ownerBlock;
        if (ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
          if (otherBlock.target === NodeMaterialBlockTargets.Vertex) {
            return 2;
          }
          for (const output of otherBlock.outputs) {
            if (output.ownerBlock.target != NodeMaterialBlockTargets.Neutral && output.isConnectedInVertexShader) {
              return 2;
            }
          }
        }
        if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeMaterialBlockConnectionPointTypes.AutoDetect) {
          if (_NodeMaterialConnectionPoint.AreEquivalentTypes(this.type, connectionPoint.type)) {
            return 0;
          }
          if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1 || connectionPoint._acceptedConnectionPointType && _NodeMaterialConnectionPoint.AreEquivalentTypes(connectionPoint._acceptedConnectionPointType.type, this.type)) {
            return 0;
          } else {
            return 1;
          }
        }
        if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {
          return 1;
        }
        let targetBlock = otherBlock;
        let sourceBlock = ownerBlock;
        if (this.direction === 0) {
          targetBlock = ownerBlock;
          sourceBlock = otherBlock;
        }
        if (targetBlock.isAnAncestorOf(sourceBlock)) {
          return 3;
        }
        return 0;
      }
      /**
       * Connect this point to another connection point
       * @param connectionPoint defines the other connection point
       * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)
       * @returns the current connection point
       */
      connectTo(connectionPoint, ignoreConstraints = false) {
        if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {
          throw `Cannot connect these two connectors. source: "${this.ownerBlock.name}".${this.name}, target: "${connectionPoint.ownerBlock.name}".${connectionPoint.name}`;
        }
        this._endpoints.push(connectionPoint);
        connectionPoint._connectedPoint = this;
        this._enforceAssociatedVariableName = false;
        this.onConnectionObservable.notifyObservers(connectionPoint);
        connectionPoint.onConnectionObservable.notifyObservers(this);
        return this;
      }
      /**
       * Disconnect this point from one of his endpoint
       * @param endpoint defines the other connection point
       * @returns the current connection point
       */
      disconnectFrom(endpoint) {
        const index = this._endpoints.indexOf(endpoint);
        if (index === -1) {
          return this;
        }
        this._endpoints.splice(index, 1);
        endpoint._connectedPoint = null;
        this._enforceAssociatedVariableName = false;
        endpoint._enforceAssociatedVariableName = false;
        this.onDisconnectionObservable.notifyObservers(endpoint);
        endpoint.onDisconnectionObservable.notifyObservers(this);
        return this;
      }
      /**
       * Fill the list of excluded connection point types with all types other than those passed in the parameter
       * @param mask Types (ORed values of NodeMaterialBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list
       */
      addExcludedConnectionPointFromAllowedTypes(mask) {
        let bitmask = 1;
        while (bitmask < NodeMaterialBlockConnectionPointTypes.All) {
          if (!(mask & bitmask)) {
            this.excludedConnectionPointTypes.push(bitmask);
          }
          bitmask = bitmask << 1;
        }
      }
      /**
       * Serializes this point in a JSON representation
       * @param isInput defines if the connection point is an input (default is true)
       * @returns the serialized point object
       */
      serialize(isInput = true) {
        const serializationObject = {};
        serializationObject.name = this.name;
        if (this.displayName) {
          serializationObject.displayName = this.displayName;
        }
        if (isInput && this.connectedPoint) {
          serializationObject.inputName = this.name;
          serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;
          serializationObject.targetConnectionName = this.connectedPoint.name;
          serializationObject.isExposedOnFrame = true;
          serializationObject.exposedPortPosition = this.exposedPortPosition;
        }
        if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {
          serializationObject.isExposedOnFrame = true;
          serializationObject.exposedPortPosition = this.exposedPortPosition;
        }
        return serializationObject;
      }
      /**
       * Release resources
       */
      dispose() {
        this.onConnectionObservable.clear();
        this.onDisconnectionObservable.clear();
        this.onTypeChangedObservable.clear();
        this._connectedPoint = null;
        this._typeConnectionSource = null;
        this._linkedConnectionSource = null;
      }
      _updateTypeDependentState(update) {
        const previousType = this.type;
        update();
        if (this.type !== previousType) {
          this._notifyTypeChanged();
        }
      }
      _notifyTypeChanged() {
        if (this._isTypeChangeObservableNotifying) {
          return;
        }
        this._isTypeChangeObservableNotifying = true;
        this.onTypeChangedObservable.notifyObservers(this.type);
        this._isTypeChangeObservableNotifying = false;
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBlock.js
var NodeMaterialBlock;
var init_nodeMaterialBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/nodeMaterialBlock.js"() {
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialBlockConnectionPoint();
    init_nodeMaterialBlockTargets();
    init_uniqueIdGenerator();
    init_typeStore();
    init_logger();
    init_observable();
    NodeMaterialBlock = class {
      /** @internal */
      get _isFinalOutputAndActive() {
        return this._isFinalOutput;
      }
      /** @internal */
      get _hasPrecedence() {
        return false;
      }
      /**
       * Gets the name of the block
       */
      get name() {
        return this._name;
      }
      /**
       * Gets a boolean indicating that this block has is code ready to be used
       */
      get codeIsReady() {
        return this._codeIsReady;
      }
      /**
       * Sets the name of the block. Will check if the name is valid.
       */
      set name(newName) {
        if (!this.validateBlockName(newName)) {
          return;
        }
        this._name = newName;
      }
      /**
       * Gets a boolean indicating that this block can only be used once per NodeMaterial
       */
      get isUnique() {
        return this._isUnique;
      }
      /**
       * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)
       */
      get isFinalMerger() {
        return this._isFinalMerger;
      }
      /**
       * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)
       */
      get isInput() {
        return this._isInput;
      }
      /**
       * Gets a boolean indicating if this block is a teleport out
       */
      get isTeleportOut() {
        return this._isTeleportOut;
      }
      /**
       * Gets a boolean indicating if this block is a teleport in
       */
      get isTeleportIn() {
        return this._isTeleportIn;
      }
      /**
       * Gets a boolean indicating if this block is a loop
       */
      get isLoop() {
        return this._isLoop;
      }
      /**
       * Gets or sets the build Id
       */
      get buildId() {
        return this._buildId;
      }
      set buildId(value) {
        this._buildId = value;
      }
      /**
       * Gets or sets the target of the block
       */
      get target() {
        return this._target;
      }
      set target(value) {
        if ((this._target & value) !== 0) {
          return;
        }
        this._target = value;
      }
      /**
       * Gets the list of input points
       */
      get inputs() {
        return this._inputs;
      }
      /** Gets the list of output points */
      get outputs() {
        return this._outputs;
      }
      /**
       * Find an input by its name
       * @param name defines the name of the input to look for
       * @returns the input or null if not found
       */
      getInputByName(name13) {
        const filter = this._inputs.filter((e) => e.name === name13);
        if (filter.length) {
          return filter[0];
        }
        return null;
      }
      /**
       * Find an output by its name
       * @param name defines the name of the output to look for
       * @returns the output or null if not found
       */
      getOutputByName(name13) {
        const filter = this._outputs.filter((e) => e.name === name13);
        if (filter.length) {
          return filter[0];
        }
        return null;
      }
      /**
       * Creates a new NodeMaterialBlock
       * @param name defines the block name
       * @param target defines the target of that block (Vertex by default)
       * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false
       * @param isFinalOutput defines a boolean indicating that this block is generating a final output and no other block should be generated after
       */
      constructor(name13, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false, isFinalOutput = false) {
        this._isFinalMerger = false;
        this._isInput = false;
        this._isLoop = false;
        this._isTeleportOut = false;
        this._isTeleportIn = false;
        this._name = "";
        this._isUnique = false;
        this._codeIsReady = true;
        this._isFinalOutput = false;
        this.onCodeIsReadyObservable = new Observable();
        this.inputsAreExclusive = false;
        this._codeVariableName = "";
        this._inputs = new Array();
        this._outputs = new Array();
        this.comments = "";
        this.visibleInInspector = false;
        this.visibleOnFrame = false;
        this._target = target;
        this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;
        this._isFinalMerger = isFinalMerger;
        this._isFinalOutput = isFinalOutput;
        switch (this.getClassName()) {
          case "InputBlock":
            this._isInput = true;
            break;
          case "NodeMaterialTeleportOutBlock":
            this._isTeleportOut = true;
            break;
          case "NodeMaterialTeleportInBlock":
            this._isTeleportIn = true;
            break;
          case "LoopBlock":
            this._isLoop = true;
            break;
        }
        this._name = name13;
        this.uniqueId = UniqueIdGenerator.UniqueId;
      }
      /** @internal */
      _setInitialTarget(target) {
        this._target = target;
        this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;
      }
      /**
       * Initialize the block and prepare the context for build
       * @param state defines the state that will be used for the build
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      initialize(state) {
      }
      /**
       * Bind data to effect. Will only be called for blocks with isBindable === true
       * @param effect defines the effect to bind data to
       * @param nodeMaterial defines the hosting NodeMaterial
       * @param mesh defines the mesh that will be rendered
       * @param subMesh defines the submesh that will be rendered
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      bind(effect, nodeMaterial, mesh, subMesh) {
      }
      _writeVariable(currentPoint) {
        const connectionPoint = currentPoint.connectedPoint;
        if (connectionPoint) {
          return `${currentPoint.associatedVariableName}`;
        }
        return `0.`;
      }
      _writeFloat(value) {
        let stringVersion = value.toString();
        if (stringVersion.indexOf(".") === -1) {
          stringVersion += ".0";
        }
        return `${stringVersion}`;
      }
      /**
       * Gets the current class name e.g. "NodeMaterialBlock"
       * @returns the class name
       */
      getClassName() {
        return "NodeMaterialBlock";
      }
      /** Gets a boolean indicating that this connection will be used in the fragment shader
       * @returns true if connected in fragment shader
       */
      isConnectedInFragmentShader() {
        return this.outputs.some((o) => o.isConnectedInFragmentShader);
      }
      /**
       * Register a new input. Must be called inside a block constructor
       * @param name defines the connection point name
       * @param type defines the connection point type
       * @param isOptional defines a boolean indicating that this input can be omitted
       * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)
       * @param point an already created connection point. If not provided, create a new one
       * @returns the current block
       */
      registerInput(name13, type, isOptional = false, target, point) {
        point = point ?? new NodeMaterialConnectionPoint(
          name13,
          this,
          0
          /* NodeMaterialConnectionPointDirection.Input */
        );
        point.type = type;
        point.isOptional = isOptional;
        if (target) {
          point.target = target;
        }
        this._inputs.push(point);
        return this;
      }
      /**
       * Register a new output. Must be called inside a block constructor
       * @param name defines the connection point name
       * @param type defines the connection point type
       * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)
       * @param point an already created connection point. If not provided, create a new one
       * @returns the current block
       */
      registerOutput(name13, type, target, point) {
        point = point ?? new NodeMaterialConnectionPoint(
          name13,
          this,
          1
          /* NodeMaterialConnectionPointDirection.Output */
        );
        point.type = type;
        if (target) {
          point.target = target;
        }
        this._outputs.push(point);
        return this;
      }
      /**
       * Will return the first available input e.g. the first one which is not an uniform or an attribute
       * @param forOutput defines an optional connection point to check compatibility with
       * @returns the first available input or null
       */
      getFirstAvailableInput(forOutput = null) {
        for (const input of this._inputs) {
          if (!input.connectedPoint) {
            if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect || input.acceptedConnectionPointTypes.indexOf(forOutput.type) !== -1) {
              return input;
            }
          }
        }
        return null;
      }
      /**
       * Will return the first available output e.g. the first one which is not yet connected and not a varying
       * @param forBlock defines an optional block to check compatibility with
       * @returns the first available input or null
       */
      getFirstAvailableOutput(forBlock = null) {
        for (const output of this._outputs) {
          if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {
            return output;
          }
        }
        return null;
      }
      /**
       * Gets the sibling of the given output
       * @param current defines the current output
       * @returns the next output in the list or null
       */
      getSiblingOutput(current) {
        const index = this._outputs.indexOf(current);
        if (index === -1 || index >= this._outputs.length) {
          return null;
        }
        return this._outputs[index + 1];
      }
      /**
       * Checks if the current block is an ancestor of a given block
       * @param block defines the potential descendant block to check
       * @returns true if block is a descendant
       */
      isAnAncestorOf(block) {
        for (const output of this._outputs) {
          if (!output.hasEndpoints) {
            continue;
          }
          for (const endpoint of output.endpoints) {
            if (endpoint.ownerBlock === block) {
              return true;
            }
            if (endpoint.ownerBlock.isAnAncestorOf(block)) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Connect current block with another block
       * @param other defines the block to connect with
       * @param options define the various options to help pick the right connections
       * @param options.input
       * @param options.output
       * @param options.outputSwizzle
       * @returns the current block
       */
      connectTo(other, options) {
        if (this._outputs.length === 0) {
          return;
        }
        let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);
        let notFound = true;
        while (notFound) {
          const input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);
          if (output && input && output.canConnectTo(input)) {
            output.connectTo(input);
            notFound = false;
          } else if (!output) {
            throw "Unable to find a compatible match";
          } else {
            output = this.getSiblingOutput(output);
          }
        }
        return this;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _buildBlock(state) {
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _postBuildBlock(state) {
      }
      /**
       * Add uniforms, samplers and uniform buffers at compilation time
       * @param state defines the state to update
       * @param nodeMaterial defines the node material requesting the update
       * @param defines defines the material defines to update
       * @param uniformBuffers defines the list of uniform buffer names
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {
      }
      /**
       * Add potential fallbacks if shader compilation fails
       * @param fallbacks defines the current prioritized list of fallbacks
       * @param mesh defines the mesh to be rendered
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      provideFallbacks(fallbacks, mesh) {
      }
      /**
       * Initialize defines for shader compilation
       * @param defines defines the material defines to update
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      initializeDefines(defines) {
      }
      /**
       * Update defines for shader compilation
       * @param defines defines the material defines to update
       * @param nodeMaterial defines the node material requesting the update
       * @param mesh defines the mesh to be rendered
       * @param useInstances specifies that instances should be used
       * @param subMesh defines which submesh to render
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      prepareDefines(defines, nodeMaterial, mesh, useInstances = false, subMesh) {
      }
      /**
       * Lets the block try to connect some inputs automatically
       * @param material defines the hosting NodeMaterial
       * @param additionalFilteringInfo optional additional filtering condition when looking for compatible blocks
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      autoConfigure(material, additionalFilteringInfo = () => true) {
      }
      /**
       * Function called when a block is declared as repeatable content generator
       * @param vertexShaderState defines the current compilation state for the vertex shader
       * @param defines defines the material defines to update
       * @param mesh defines the mesh to be rendered
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      replaceRepeatableContent(vertexShaderState, defines, mesh) {
      }
      /** Gets a boolean indicating that the code of this block will be promoted to vertex shader even if connected to fragment output */
      get willBeGeneratedIntoVertexShaderFromFragmentShader() {
        if (this.isInput || this.isFinalMerger) {
          return false;
        }
        if (this._outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {
          return false;
        }
        if (this.target === NodeMaterialBlockTargets.Vertex) {
          return false;
        }
        if (this.target === NodeMaterialBlockTargets.VertexAndFragment || this.target === NodeMaterialBlockTargets.Neutral) {
          if (this._outputs.some((o) => o.isConnectedInVertexShader)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Checks if the block is ready
       * @param mesh defines the mesh to be rendered
       * @param nodeMaterial defines the node material requesting the update
       * @param defines defines the material defines to update
       * @param useInstances specifies that instances should be used
       * @returns true if the block is ready
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      isReady(mesh, nodeMaterial, defines, useInstances = false) {
        return true;
      }
      _linkConnectionTypes(inputIndex0, inputIndex1, looseCoupling = false) {
        if (looseCoupling) {
          this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];
        } else {
          this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];
          this._inputs[inputIndex0]._isMainLinkSource = true;
        }
        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];
      }
      _processBuild(block, state, input, activeBlocks) {
        block.build(state, activeBlocks);
        const localBlockIsFragment = state._vertexState != null;
        const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;
        if (block.isTeleportOut && block.entryPoint?.isConnectedToUniform) {
          return;
        }
        if (localBlockIsFragment && ((block.target & block._buildTarget) === 0 || (block.target & input.target) === 0 || this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader)) {
          if (!block.isInput && state.target !== block._buildTarget || // block was already emitted by vertex shader
          block.isInput && block.isAttribute && !block._noContextSwitch) {
            const connectedPoint = input.connectedPoint;
            if (state._vertexState._emitVaryingFromString("v_" + connectedPoint.declarationVariableName, connectedPoint.type)) {
              const prefix2 = state.shaderLanguage === 1 ? "vertexOutputs." : "";
              if (state.shaderLanguage === 1 && connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Matrix) {
                state._vertexState.compilationString += `${prefix2}${"v_" + connectedPoint.declarationVariableName}_r0 = ${connectedPoint.associatedVariableName}[0];
`;
                state._vertexState.compilationString += `${prefix2}${"v_" + connectedPoint.declarationVariableName}_r1 = ${connectedPoint.associatedVariableName}[1];
`;
                state._vertexState.compilationString += `${prefix2}${"v_" + connectedPoint.declarationVariableName}_r2 = ${connectedPoint.associatedVariableName}[2];
`;
                state._vertexState.compilationString += `${prefix2}${"v_" + connectedPoint.declarationVariableName}_r3 = ${connectedPoint.associatedVariableName}[3];
`;
              } else {
                state._vertexState.compilationString += `${prefix2}${"v_" + connectedPoint.declarationVariableName} = ${connectedPoint.associatedVariableName};
`;
              }
            }
            const prefix = state.shaderLanguage === 1 && connectedPoint.type !== NodeMaterialBlockConnectionPointTypes.Matrix ? "fragmentInputs." : "";
            input.associatedVariableName = prefix + "v_" + connectedPoint.declarationVariableName;
            input._enforceAssociatedVariableName = true;
          }
        }
      }
      /**
       * Validates the new name for the block node.
       * @param newName the new name to be given to the node.
       * @returns false if the name is a reserve word, else true.
       */
      validateBlockName(newName) {
        const reservedNames = [
          "position",
          "normal",
          "tangent",
          "particle_positionw",
          "uv",
          "uv2",
          "uv3",
          "uv4",
          "uv5",
          "uv6",
          "position2d",
          "particle_uv",
          "postprocess_uv",
          "matricesIndices",
          "matricesWeights",
          "world0",
          "world1",
          "world2",
          "world3",
          "particle_color",
          "particle_texturemask"
        ];
        for (const reservedName of reservedNames) {
          if (newName === reservedName) {
            return false;
          }
        }
        return true;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _customBuildStep(state, activeBlocks) {
      }
      /**
       * Compile the current node and generate the shader code
       * @param state defines the current compilation state (uniforms, samplers, current string)
       * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)
       * @returns true if already built
       */
      build(state, activeBlocks) {
        if (this._buildId === state.sharedData.buildId) {
          return true;
        }
        if (!this.isInput) {
          for (const output of this._outputs) {
            if (!output.associatedVariableName) {
              output.associatedVariableName = state._getFreeVariableName(output.name);
            }
          }
        }
        for (const input of this._inputs) {
          if (!input.connectedPoint) {
            if (!input.isOptional) {
              state.sharedData.checks.notConnectedNonOptionalInputs.push(input);
            }
            continue;
          }
          if (this.target !== NodeMaterialBlockTargets.Neutral) {
            if ((input.target & this.target) === 0) {
              continue;
            }
            if ((input.target & state.target) === 0) {
              continue;
            }
          }
          const block = input.connectedPoint.ownerBlock;
          if (block && block !== this) {
            this._processBuild(block, state, input, activeBlocks);
          }
        }
        this._customBuildStep(state, activeBlocks);
        if (this._buildId === state.sharedData.buildId) {
          return true;
        }
        if (state.sharedData.verbose) {
          Logger.Log(`${state.target === NodeMaterialBlockTargets.Vertex ? "Vertex shader" : "Fragment shader"}: Building ${this.name} [${this.getClassName()}]`);
        }
        if (this.isFinalMerger) {
          switch (state.target) {
            case NodeMaterialBlockTargets.Vertex:
              state.sharedData.checks.emitVertex = true;
              break;
            case NodeMaterialBlockTargets.Fragment:
              state.sharedData.checks.emitFragment = true;
              break;
          }
        }
        if (!this.isInput && state.sharedData.emitComments) {
          state.compilationString += `
//${this.name}
`;
        }
        this._buildBlock(state);
        this._buildId = state.sharedData.buildId;
        this._buildTarget = state.target;
        for (const output of this._outputs) {
          if (output._forPostBuild) {
            continue;
          }
          if ((output.target & state.target) === 0) {
            continue;
          }
          for (const endpoint of output.endpoints) {
            const block = endpoint.ownerBlock;
            if (block) {
              if ((block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1 || state._terminalBlocks.has(block)) {
                this._processBuild(block, state, endpoint, activeBlocks);
              }
            }
          }
        }
        this._postBuildBlock(state);
        for (const output of this._outputs) {
          if (!output._forPostBuild) {
            continue;
          }
          if ((output.target & state.target) === 0) {
            continue;
          }
          for (const endpoint of output.endpoints) {
            const block = endpoint.ownerBlock;
            if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {
              this._processBuild(block, state, endpoint, activeBlocks);
            }
          }
        }
        return false;
      }
      _inputRename(name13) {
        return name13;
      }
      _outputRename(name13) {
        return name13;
      }
      _dumpPropertiesCode() {
        const variableName = this._codeVariableName;
        return `${variableName}.visibleInInspector = ${this.visibleInInspector};
${variableName}.visibleOnFrame = ${this.visibleOnFrame};
${variableName}.target = ${this.target};
`;
      }
      /**
       * @internal
       */
      _dumpCode(uniqueNames, alreadyDumped) {
        alreadyDumped.push(this);
        const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, "");
        this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;
        if (uniqueNames.indexOf(this._codeVariableName) !== -1) {
          let index = 0;
          do {
            index++;
            this._codeVariableName = nameAsVariableName + index;
          } while (uniqueNames.indexOf(this._codeVariableName) !== -1);
        }
        uniqueNames.push(this._codeVariableName);
        let codeString = `
// ${this.getClassName()}
`;
        if (this.comments) {
          codeString += `// ${this.comments}
`;
        }
        codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}("${this.name}");
`;
        codeString += this._dumpPropertiesCode();
        for (const input of this.inputs) {
          if (!input.isConnected) {
            continue;
          }
          const connectedOutput = input.connectedPoint;
          const connectedBlock = connectedOutput.ownerBlock;
          if (alreadyDumped.indexOf(connectedBlock) === -1) {
            codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
          }
        }
        for (const output of this.outputs) {
          if (!output.hasEndpoints) {
            continue;
          }
          for (const endpoint of output.endpoints) {
            const connectedBlock = endpoint.ownerBlock;
            if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {
              codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
            }
          }
        }
        return codeString;
      }
      /**
       * @internal
       */
      _dumpCodeForOutputConnections(alreadyDumped) {
        let codeString = "";
        if (alreadyDumped.indexOf(this) !== -1) {
          return codeString;
        }
        alreadyDumped.push(this);
        for (const input of this.inputs) {
          if (!input.isConnected) {
            continue;
          }
          const connectedOutput = input.connectedPoint;
          const connectedBlock = connectedOutput.ownerBlock;
          codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);
          codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(input.name)});
`;
        }
        return codeString;
      }
      /**
       * Clone the current block to a new identical block
       * @param scene defines the hosting scene
       * @param rootUrl defines the root URL to use to load textures and relative dependencies
       * @returns a copy of the current block
       */
      clone(scene, rootUrl = "") {
        const serializationObject = this.serialize();
        const blockType = GetClass(serializationObject.customType);
        if (blockType) {
          const block = new blockType();
          block._deserialize(serializationObject, scene, rootUrl);
          return block;
        }
        return null;
      }
      /**
       * Serializes this block in a JSON representation
       * @returns the serialized block object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.customType = "BABYLON." + this.getClassName();
        serializationObject.id = this.uniqueId;
        serializationObject.name = this.name;
        serializationObject.comments = this.comments;
        serializationObject.visibleInInspector = this.visibleInInspector;
        serializationObject.visibleOnFrame = this.visibleOnFrame;
        serializationObject.target = this.target;
        serializationObject.inputs = [];
        serializationObject.outputs = [];
        for (const input of this.inputs) {
          serializationObject.inputs.push(input.serialize());
        }
        for (const output of this.outputs) {
          serializationObject.outputs.push(output.serialize(false));
        }
        return serializationObject;
      }
      /**
       * @internal
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _deserialize(serializationObject, scene, rootUrl, urlRewriter) {
        this.name = serializationObject.name;
        this.comments = serializationObject.comments;
        this.visibleInInspector = !!serializationObject.visibleInInspector;
        this.visibleOnFrame = !!serializationObject.visibleOnFrame;
        this._target = serializationObject.target ?? this.target;
        this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);
      }
      _deserializePortDisplayNamesAndExposedOnFrame(serializationObject) {
        const serializedInputs = serializationObject.inputs;
        const serializedOutputs = serializationObject.outputs;
        if (serializedInputs) {
          for (let i = 0; i < Math.min(serializedInputs.length, this.inputs.length); i++) {
            const port = serializedInputs[i];
            if (port.displayName) {
              this.inputs[i].displayName = port.displayName;
            }
            if (port.isExposedOnFrame) {
              this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;
              this.inputs[i].exposedPortPosition = port.exposedPortPosition;
            }
          }
        }
        if (serializedOutputs) {
          for (let i = 0; i < Math.min(serializedOutputs.length, this.outputs.length); i++) {
            const port = serializedOutputs[i];
            if (port.displayName) {
              this.outputs[i].displayName = port.displayName;
            }
            if (port.isExposedOnFrame) {
              this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;
              this.outputs[i].exposedPortPosition = port.exposedPortPosition;
            }
          }
        }
      }
      /**
       * Release resources
       */
      dispose() {
        this.onCodeIsReadyObservable.clear();
        for (const input of this.inputs) {
          input.dispose();
        }
        for (const output of this.outputs) {
          output.dispose();
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/fragmentOutputBlock.js
var FragmentOutputBlockColorSpace, FragmentOutputBlock;
var init_fragmentOutputBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/fragmentOutputBlock.js"() {
    init_tslib_es6();
    init_nodeMaterialBlock();
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialBlockTargets();
    init_typeStore();
    init_nodeDecorator();
    init_materialHelper_functions();
    (function(FragmentOutputBlockColorSpace2) {
      FragmentOutputBlockColorSpace2[FragmentOutputBlockColorSpace2["NoColorSpace"] = 0] = "NoColorSpace";
      FragmentOutputBlockColorSpace2[FragmentOutputBlockColorSpace2["Gamma"] = 1] = "Gamma";
      FragmentOutputBlockColorSpace2[FragmentOutputBlockColorSpace2["Linear"] = 2] = "Linear";
    })(FragmentOutputBlockColorSpace || (FragmentOutputBlockColorSpace = {}));
    FragmentOutputBlock = class extends NodeMaterialBlock {
      /**
       * Create a new FragmentOutputBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13, NodeMaterialBlockTargets.Fragment, true, true);
        this.convertToGammaSpace = false;
        this.convertToLinearSpace = false;
        this.useLogarithmicDepth = false;
        this.registerInput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, true);
        this.registerInput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, true);
        this.registerInput("a", NodeMaterialBlockConnectionPointTypes.Float, true);
        this.registerInput("glow", NodeMaterialBlockConnectionPointTypes.Color3, true);
        this.rgb.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);
        this.rgb.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
        this.additionalColor.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);
        this.additionalColor.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
      }
      /**
       * Gets or sets the color space used for the block
       */
      get colorSpace() {
        if (this.convertToGammaSpace) {
          return FragmentOutputBlockColorSpace.Gamma;
        }
        if (this.convertToLinearSpace) {
          return FragmentOutputBlockColorSpace.Linear;
        }
        return FragmentOutputBlockColorSpace.NoColorSpace;
      }
      set colorSpace(value) {
        this.convertToGammaSpace = value === FragmentOutputBlockColorSpace.Gamma;
        this.convertToLinearSpace = value === FragmentOutputBlockColorSpace.Linear;
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "FragmentOutputBlock";
      }
      /**
       * Initialize the block and prepare the context for build
       * @param state defines the state that will be used for the build
       */
      initialize(state) {
        state._excludeVariableName("logarithmicDepthConstant");
        state._excludeVariableName("vFragmentDepth");
      }
      /**
       * Gets the rgba input component
       */
      get rgba() {
        return this._inputs[0];
      }
      /**
       * Gets the rgb input component
       */
      get rgb() {
        return this._inputs[1];
      }
      /**
       * Gets the a input component
       */
      get a() {
        return this._inputs[2];
      }
      /**
       * Gets the additionalColor input component (named glow in the UI for now)
       */
      get additionalColor() {
        return this._inputs[3];
      }
      /**
       * Gets the glow input component
       */
      get glow() {
        return this._inputs[3];
      }
      _getOutputString(state) {
        return state.shaderLanguage === 1 ? "fragmentOutputsColor" : "gl_FragColor";
      }
      prepareDefines(defines, nodeMaterial) {
        defines.setValue(this._linearDefineName, this.convertToLinearSpace, true);
        defines.setValue(this._gammaDefineName, this.convertToGammaSpace, true);
        defines.setValue(this._additionalColorDefineName, this.additionalColor.connectedPoint && nodeMaterial._useAdditionalColor, true);
      }
      bind(effect, nodeMaterial, mesh) {
        if ((this.useLogarithmicDepth || nodeMaterial.useLogarithmicDepth) && mesh) {
          BindLogDepth(void 0, effect, mesh.getScene());
        }
      }
      _buildBlock(state) {
        super._buildBlock(state);
        const rgba = this.rgba;
        const rgb = this.rgb;
        const a = this.a;
        const additionalColor = this.additionalColor;
        const isWebGPU = state.shaderLanguage === 1;
        state.sharedData.hints.needAlphaBlending = rgba.isConnected || a.isConnected;
        state.sharedData.blocksWithDefines.push(this);
        if (this.useLogarithmicDepth || state.sharedData.nodeMaterial.useLogarithmicDepth) {
          state._emitUniformFromString("logarithmicDepthConstant", NodeMaterialBlockConnectionPointTypes.Float);
          state._emitVaryingFromString("vFragmentDepth", NodeMaterialBlockConnectionPointTypes.Float);
          state.sharedData.bindableBlocks.push(this);
        }
        if (additionalColor.connectedPoint) {
          state._excludeVariableName("useAdditionalColor");
          state._emitUniformFromString("useAdditionalColor", NodeMaterialBlockConnectionPointTypes.Float);
          this._additionalColorDefineName = state._getFreeDefineName("USEADDITIONALCOLOR");
        }
        this._linearDefineName = state._getFreeDefineName("CONVERTTOLINEAR");
        this._gammaDefineName = state._getFreeDefineName("CONVERTTOGAMMA");
        const comments = `//${this.name}`;
        state._emitFunctionFromInclude("helperFunctions", comments);
        const outputString = this._getOutputString(state);
        if (state.shaderLanguage === 1) {
          state.compilationString += `var ${outputString} : vec4<f32>;\r
`;
        }
        const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);
        if (additionalColor.connectedPoint) {
          let aValue = "1.0";
          if (a.connectedPoint) {
            aValue = a.associatedVariableName;
          }
          state.compilationString += `#ifdef ${this._additionalColorDefineName}
`;
          if (additionalColor.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {
            state.compilationString += `${outputString}  = ${vec4}(${additionalColor.associatedVariableName}, ${additionalColor.associatedVariableName}, ${additionalColor.associatedVariableName}, ${aValue});
`;
          } else {
            state.compilationString += `${outputString}  = ${vec4}(${additionalColor.associatedVariableName}, ${aValue});
`;
          }
          state.compilationString += `#else
`;
        }
        if (rgba.connectedPoint) {
          if (a.isConnected) {
            state.compilationString += `${outputString} = ${vec4}(${rgba.associatedVariableName}.rgb, ${a.associatedVariableName});
`;
          } else {
            state.compilationString += `${outputString}  = ${rgba.associatedVariableName};
`;
          }
        } else if (rgb.connectedPoint) {
          let aValue = "1.0";
          if (a.connectedPoint) {
            aValue = a.associatedVariableName;
          }
          if (rgb.connectedPoint.type === NodeMaterialBlockConnectionPointTypes.Float) {
            state.compilationString += `${outputString}  = ${vec4}(${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${rgb.associatedVariableName}, ${aValue});
`;
          } else {
            state.compilationString += `${outputString}  = ${vec4}(${rgb.associatedVariableName}, ${aValue});
`;
          }
        } else {
          state.sharedData.checks.notConnectedNonOptionalInputs.push(rgba);
        }
        if (additionalColor.connectedPoint) {
          state.compilationString += `#endif
`;
        }
        state.compilationString += `#ifdef ${this._linearDefineName}
`;
        state.compilationString += `${outputString}  = toLinearSpace${state.shaderLanguage === 1 ? "Vec4" : ""}(${outputString});
`;
        state.compilationString += `#endif
`;
        state.compilationString += `#ifdef ${this._gammaDefineName}
`;
        state.compilationString += `${outputString}  = toGammaSpace(${outputString});
`;
        state.compilationString += `#endif
`;
        if (state.shaderLanguage === 1) {
          state.compilationString += `#if !defined(PREPASS)\r
`;
          state.compilationString += `fragmentOutputs.color = ${outputString};\r
`;
          state.compilationString += `#endif\r
`;
        }
        if (this.useLogarithmicDepth || state.sharedData.nodeMaterial.useLogarithmicDepth) {
          const fragDepth = isWebGPU ? "input.vFragmentDepth" : "vFragmentDepth";
          const uniformP = isWebGPU ? "uniforms." : "";
          const output = isWebGPU ? "fragmentOutputs.fragDepth" : "gl_FragDepthEXT";
          state.compilationString += `${output} = log2(${fragDepth}) * ${uniformP}logarithmicDepthConstant * 0.5;
`;
        }
        state.compilationString += `#if defined(PREPASS)\r
`;
        state.compilationString += `${isWebGPU ? "fragmentOutputs.fragData0" : "gl_FragData[0]"} = ${outputString};\r
`;
        state.compilationString += `#endif\r
`;
        return this;
      }
      _dumpPropertiesCode() {
        let codeString = super._dumpPropertiesCode();
        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};
`;
        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};
`;
        codeString += `${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};
`;
        return codeString;
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.convertToGammaSpace = this.convertToGammaSpace;
        serializationObject.convertToLinearSpace = this.convertToLinearSpace;
        serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;
        return serializationObject;
      }
      _deserialize(serializationObject, scene, rootUrl) {
        super._deserialize(serializationObject, scene, rootUrl);
        this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;
        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
        this.useLogarithmicDepth = serializationObject.useLogarithmicDepth ?? false;
      }
    };
    __decorate([
      editableInPropertyPage("Use logarithmic depth", 0, "PROPERTIES", { embedded: true })
    ], FragmentOutputBlock.prototype, "useLogarithmicDepth", void 0);
    __decorate([
      editableInPropertyPage("Color space", 5, "ADVANCED", {
        notifiers: { rebuild: true },
        embedded: true,
        options: [
          { label: "No color space", value: FragmentOutputBlockColorSpace.NoColorSpace },
          { label: "Gamma", value: FragmentOutputBlockColorSpace.Gamma },
          { label: "Linear", value: FragmentOutputBlockColorSpace.Linear }
        ]
      })
    ], FragmentOutputBlock.prototype, "colorSpace", null);
    RegisterClass("BABYLON.FragmentOutputBlock", FragmentOutputBlock);
  }
});

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialModes.js
var NodeMaterialModes;
var init_nodeMaterialModes = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialModes.js"() {
    (function(NodeMaterialModes2) {
      NodeMaterialModes2[NodeMaterialModes2["Material"] = 0] = "Material";
      NodeMaterialModes2[NodeMaterialModes2["PostProcess"] = 1] = "PostProcess";
      NodeMaterialModes2[NodeMaterialModes2["Particle"] = 2] = "Particle";
      NodeMaterialModes2[NodeMaterialModes2["ProceduralTexture"] = 3] = "ProceduralTexture";
      NodeMaterialModes2[NodeMaterialModes2["GaussianSplatting"] = 4] = "GaussianSplatting";
      NodeMaterialModes2[NodeMaterialModes2["SFE"] = 5] = "SFE";
    })(NodeMaterialModes || (NodeMaterialModes = {}));
  }
});

// node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialSystemValues.js
var NodeMaterialSystemValues;
var init_nodeMaterialSystemValues = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Enums/nodeMaterialSystemValues.js"() {
    (function(NodeMaterialSystemValues2) {
      NodeMaterialSystemValues2[NodeMaterialSystemValues2["World"] = 1] = "World";
      NodeMaterialSystemValues2[NodeMaterialSystemValues2["View"] = 2] = "View";
      NodeMaterialSystemValues2[NodeMaterialSystemValues2["Projection"] = 3] = "Projection";
      NodeMaterialSystemValues2[NodeMaterialSystemValues2["ViewProjection"] = 4] = "ViewProjection";
      NodeMaterialSystemValues2[NodeMaterialSystemValues2["WorldView"] = 5] = "WorldView";
      NodeMaterialSystemValues2[NodeMaterialSystemValues2["WorldViewProjection"] = 6] = "WorldViewProjection";
      NodeMaterialSystemValues2[NodeMaterialSystemValues2["CameraPosition"] = 7] = "CameraPosition";
      NodeMaterialSystemValues2[NodeMaterialSystemValues2["FogColor"] = 8] = "FogColor";
      NodeMaterialSystemValues2[NodeMaterialSystemValues2["DeltaTime"] = 9] = "DeltaTime";
      NodeMaterialSystemValues2[NodeMaterialSystemValues2["CameraParameters"] = 10] = "CameraParameters";
      NodeMaterialSystemValues2[NodeMaterialSystemValues2["MaterialAlpha"] = 11] = "MaterialAlpha";
      NodeMaterialSystemValues2[NodeMaterialSystemValues2["ProjectionInverse"] = 12] = "ProjectionInverse";
      NodeMaterialSystemValues2[NodeMaterialSystemValues2["CameraForward"] = 13] = "CameraForward";
    })(NodeMaterialSystemValues || (NodeMaterialSystemValues = {}));
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/Input/animatedInputBlockTypes.js
var AnimatedInputBlockTypes;
var init_animatedInputBlockTypes = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/Input/animatedInputBlockTypes.js"() {
    (function(AnimatedInputBlockTypes2) {
      AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["None"] = 0] = "None";
      AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["Time"] = 1] = "Time";
      AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["RealTime"] = 2] = "RealTime";
      AnimatedInputBlockTypes2[AnimatedInputBlockTypes2["MouseInfo"] = 3] = "MouseInfo";
    })(AnimatedInputBlockTypes || (AnimatedInputBlockTypes = {}));
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/Input/inputBlock.js
var remapAttributeName, attributeInFragmentOnly, attributeAsUniform, attributeDefine, InputBlock;
var init_inputBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/Input/inputBlock.js"() {
    init_nodeMaterialBlock();
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialSystemValues();
    init_math_vector();
    init_nodeMaterialBlockTargets();
    init_typeStore();
    init_math();
    init_animatedInputBlockTypes();
    init_observable();
    init_precisionDate();
    remapAttributeName = {
      position2d: "position",
      // From particle.vertex:
      particle_uv: "vUV",
      particle_color: "vColor",
      particle_texturemask: "textureMask",
      particle_positionw: "vPositionW",
      // From postprocess.vertex:
      postprocess_uv: "vUV"
    };
    attributeInFragmentOnly = {
      particle_uv: true,
      particle_color: true,
      particle_texturemask: true,
      particle_positionw: true,
      postprocess_uv: true
    };
    attributeAsUniform = {
      particle_texturemask: true
    };
    attributeDefine = {
      normal: "NORMAL",
      tangent: "TANGENT",
      uv: "UV1",
      uv2: "UV2",
      uv3: "UV3",
      uv4: "UV4",
      uv5: "UV5",
      uv6: "UV6",
      uv7: "UV7",
      uv8: "UV8"
    };
    InputBlock = class extends NodeMaterialBlock {
      /**
       * Gets or sets the connection point type (default is float)
       */
      get type() {
        if (this._type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {
          if (this.isUniform && this.value != null) {
            if (!isNaN(this.value)) {
              this._type = NodeMaterialBlockConnectionPointTypes.Float;
              return this._type;
            }
            switch (this.value.getClassName()) {
              case "Vector2":
                this._type = NodeMaterialBlockConnectionPointTypes.Vector2;
                return this._type;
              case "Vector3":
                this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
                return this._type;
              case "Vector4":
                this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
                return this._type;
              case "Color3":
                this._type = NodeMaterialBlockConnectionPointTypes.Color3;
                return this._type;
              case "Color4":
                this._type = NodeMaterialBlockConnectionPointTypes.Color4;
                return this._type;
              case "Matrix":
                this._type = NodeMaterialBlockConnectionPointTypes.Matrix;
                return this._type;
            }
          }
          if (this.isAttribute) {
            switch (this.name) {
              case "splatIndex":
                this._type = NodeMaterialBlockConnectionPointTypes.Float;
                return this._type;
              case "position":
              case "normal":
              case "particle_positionw":
              case "splatPosition":
                this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
                return this._type;
              case "uv":
              case "uv2":
              case "uv3":
              case "uv4":
              case "uv5":
              case "uv6":
              case "position2d":
              case "particle_uv":
              case "splatScale":
              case "postprocess_uv":
                this._type = NodeMaterialBlockConnectionPointTypes.Vector2;
                return this._type;
              case "matricesIndices":
              case "matricesWeights":
              case "matricesIndicesExtra":
              case "matricesWeightsExtra":
              case "world0":
              case "world1":
              case "world2":
              case "world3":
              case "tangent":
                this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
                return this._type;
              case "color":
              case "instanceColor":
              case "particle_color":
              case "particle_texturemask":
              case "splatColor":
                this._type = NodeMaterialBlockConnectionPointTypes.Color4;
                return this._type;
            }
          }
          if (this.isSystemValue) {
            switch (this._systemValue) {
              case NodeMaterialSystemValues.World:
              case NodeMaterialSystemValues.WorldView:
              case NodeMaterialSystemValues.WorldViewProjection:
              case NodeMaterialSystemValues.View:
              case NodeMaterialSystemValues.ViewProjection:
              case NodeMaterialSystemValues.Projection:
              case NodeMaterialSystemValues.ProjectionInverse:
                this._type = NodeMaterialBlockConnectionPointTypes.Matrix;
                return this._type;
              case NodeMaterialSystemValues.CameraPosition:
                this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
                return this._type;
              case NodeMaterialSystemValues.CameraForward:
                this._type = NodeMaterialBlockConnectionPointTypes.Vector3;
                return this._type;
              case NodeMaterialSystemValues.FogColor:
                this._type = NodeMaterialBlockConnectionPointTypes.Color3;
                return this._type;
              case NodeMaterialSystemValues.DeltaTime:
              case NodeMaterialSystemValues.MaterialAlpha:
                this._type = NodeMaterialBlockConnectionPointTypes.Float;
                return this._type;
              case NodeMaterialSystemValues.CameraParameters:
                this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
                return this._type;
            }
          }
        }
        return this._type;
      }
      /**
       * Creates a new InputBlock
       * @param name defines the block name
       * @param target defines the target of that block (Vertex by default)
       * @param type defines the type of the input (can be set to NodeMaterialBlockConnectionPointTypes.AutoDetect)
       */
      constructor(name13, target = NodeMaterialBlockTargets.Vertex, type = NodeMaterialBlockConnectionPointTypes.AutoDetect) {
        super(name13, target, false);
        this._mode = 3;
        this._animationType = AnimatedInputBlockTypes.None;
        this._prefix = "";
        this.min = 0;
        this.max = 0;
        this.isBoolean = false;
        this.matrixMode = 0;
        this._systemValue = null;
        this.isConstant = false;
        this.groupInInspector = "";
        this.onValueChangedObservable = new Observable();
        this.convertToGammaSpace = false;
        this.convertToLinearSpace = false;
        this._type = type;
        this.setDefaultValue();
        this.registerOutput("output", type);
      }
      /**
       * Validates if a name is a reserve word.
       * @param newName the new name to be given to the node.
       * @returns false if the name is a reserve word, else true.
       */
      validateBlockName(newName) {
        if (!this.isAttribute) {
          return super.validateBlockName(newName);
        }
        return true;
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Set the source of this connection point to a vertex attribute
       * @param attributeName defines the attribute name (position, uv, normal, etc...). If not specified it will take the connection point name
       * @returns the current connection point
       */
      setAsAttribute(attributeName) {
        this._mode = 1;
        if (attributeName) {
          this.name = attributeName;
        }
        return this;
      }
      /**
       * Set the source of this connection point to a system value
       * @param value define the system value to use (world, view, etc...) or null to switch to manual value
       * @returns the current connection point
       */
      setAsSystemValue(value) {
        this.systemValue = value;
        return this;
      }
      /**
       * Gets or sets the value of that point.
       * Please note that this value will be ignored if valueCallback is defined
       */
      get value() {
        return this._storedValue;
      }
      set value(value) {
        if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
          if (this.isBoolean) {
            value = value ? 1 : 0;
          } else if (this.min !== this.max) {
            value = Math.max(this.min, value);
            value = Math.min(this.max, value);
          }
        }
        this._storedValue = value;
        this._mode = 0;
        this.onValueChangedObservable.notifyObservers(this);
      }
      /**
       * Gets or sets a callback used to get the value of that point.
       * Please note that setting this value will force the connection point to ignore the value property
       */
      get valueCallback() {
        return this._valueCallback;
      }
      set valueCallback(value) {
        this._valueCallback = value;
        this._mode = 0;
      }
      /**
       * Gets the declaration variable name in the shader
       */
      get declarationVariableName() {
        return this._associatedVariableName;
      }
      /**
       * Gets or sets the associated variable name in the shader
       */
      get associatedVariableName() {
        return this._prefix + this._associatedVariableName;
      }
      set associatedVariableName(value) {
        this._associatedVariableName = value;
      }
      /** Gets or sets the type of animation applied to the input */
      get animationType() {
        return this._animationType;
      }
      set animationType(value) {
        this._animationType = value;
      }
      /**
       * Gets a boolean indicating that this connection point not defined yet
       */
      get isUndefined() {
        return this._mode === 3;
      }
      /**
       * Gets or sets a boolean indicating that this connection point is coming from an uniform.
       * In this case the connection point name must be the name of the uniform to use.
       * Can only be set on inputs
       */
      get isUniform() {
        return this._mode === 0;
      }
      set isUniform(value) {
        this._mode = value ? 0 : 3;
        this.associatedVariableName = "";
      }
      /**
       * Gets or sets a boolean indicating that this connection point is coming from an attribute.
       * In this case the connection point name must be the name of the attribute to use
       * Can only be set on inputs
       */
      get isAttribute() {
        return this._mode === 1;
      }
      set isAttribute(value) {
        this._mode = value ? 1 : 3;
        this.associatedVariableName = "";
      }
      /**
       * Gets or sets a boolean indicating that this connection point is generating a varying variable.
       * Can only be set on exit points
       */
      get isVarying() {
        return this._mode === 2;
      }
      set isVarying(value) {
        this._mode = value ? 2 : 3;
        this.associatedVariableName = "";
      }
      /**
       * Gets a boolean indicating that the current connection point is a system value
       */
      get isSystemValue() {
        return this._systemValue != null;
      }
      /**
       * Gets or sets the current well known value or null if not defined as a system value
       */
      get systemValue() {
        return this._systemValue;
      }
      set systemValue(value) {
        this._mode = 0;
        this.associatedVariableName = "";
        this._systemValue = value;
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "InputBlock";
      }
      /**
       * Animate the input if animationType !== None
       * @param scene defines the rendering scene
       */
      animate(scene) {
        switch (this._animationType) {
          case AnimatedInputBlockTypes.Time: {
            if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
              this.value += scene.getAnimationRatio() * 0.01;
            }
            break;
          }
          case AnimatedInputBlockTypes.RealTime: {
            if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
              this.value = (PrecisionDate.Now - scene.getEngine().startTime) / 1e3;
            }
            break;
          }
          case AnimatedInputBlockTypes.MouseInfo: {
            if (this.type === NodeMaterialBlockConnectionPointTypes.Vector4) {
              const event = scene._inputManager._originMouseEvent;
              if (event) {
                const x = event.offsetX;
                const y = event.offsetY;
                const z = (event.buttons & 1) != 0 ? 1 : 0;
                const w = (event.buttons & 2) != 0 ? 1 : 0;
                this.value = new Vector4(x, y, z, w);
              } else {
                this.value = new Vector4(0, 0, 0, 0);
              }
            }
            break;
          }
        }
      }
      _emitDefine(define, notDefine = false) {
        return `${notDefine ? "#ifndef" : "#ifdef"} ${define}
`;
      }
      initialize() {
        this.associatedVariableName = "";
      }
      /**
       * Set the input block to its default value (based on its type)
       */
      setDefaultValue() {
        switch (this.type) {
          case NodeMaterialBlockConnectionPointTypes.Float:
            this.value = 0;
            break;
          case NodeMaterialBlockConnectionPointTypes.Vector2:
            this.value = Vector2.Zero();
            break;
          case NodeMaterialBlockConnectionPointTypes.Vector3:
            this.value = Vector3.Zero();
            break;
          case NodeMaterialBlockConnectionPointTypes.Vector4:
            this.value = Vector4.Zero();
            break;
          case NodeMaterialBlockConnectionPointTypes.Color3:
            this.value = Color3.White();
            break;
          case NodeMaterialBlockConnectionPointTypes.Color4:
            this.value = new Color4(1, 1, 1, 1);
            break;
          case NodeMaterialBlockConnectionPointTypes.Matrix:
            this.value = Matrix.Identity();
            break;
        }
      }
      _emitConstant(state) {
        switch (this.type) {
          case NodeMaterialBlockConnectionPointTypes.Float:
            return `${state._emitFloat(this.value)}`;
          case NodeMaterialBlockConnectionPointTypes.Vector2:
            return `vec2(${this.value.x}, ${this.value.y})`;
          case NodeMaterialBlockConnectionPointTypes.Vector3:
            return `vec3(${this.value.x}, ${this.value.y}, ${this.value.z})`;
          case NodeMaterialBlockConnectionPointTypes.Vector4:
            return `vec4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;
          case NodeMaterialBlockConnectionPointTypes.Color3:
            TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);
            if (this.convertToGammaSpace) {
              TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0], state.sharedData.scene.getEngine().useExactSrgbConversions);
            }
            if (this.convertToLinearSpace) {
              TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0], state.sharedData.scene.getEngine().useExactSrgbConversions);
            }
            return `vec3(${TmpColors.Color3[0].r}, ${TmpColors.Color3[0].g}, ${TmpColors.Color3[0].b})`;
          case NodeMaterialBlockConnectionPointTypes.Color4:
            TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);
            if (this.convertToGammaSpace) {
              TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0], state.sharedData.scene.getEngine().useExactSrgbConversions);
            }
            if (this.convertToLinearSpace) {
              TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0], state.sharedData.scene.getEngine().useExactSrgbConversions);
            }
            return `vec4(${TmpColors.Color4[0].r}, ${TmpColors.Color4[0].g}, ${TmpColors.Color4[0].b}, ${TmpColors.Color4[0].a})`;
        }
        return "";
      }
      /** @internal */
      get _noContextSwitch() {
        return attributeInFragmentOnly[this.name];
      }
      _emit(state) {
        if (this.isUniform) {
          if (!this._associatedVariableName) {
            this._associatedVariableName = state._getFreeVariableName("u_" + this.name);
          }
          if (this.isConstant) {
            if (state.constants.indexOf(this.associatedVariableName) !== -1) {
              return;
            }
            state.constants.push(this.associatedVariableName);
            state._constantDeclaration += state._declareOutput(this.output, true) + ` = ${this._emitConstant(state)};
`;
            return;
          }
          if (state.uniforms.indexOf(this.associatedVariableName) !== -1) {
            return;
          }
          state._emitUniformFromString(this._associatedVariableName, this.type);
          if (state.shaderLanguage === 1) {
            this._prefix = "uniforms.";
          }
          const hints = state.sharedData.hints;
          if (this._systemValue !== null && this._systemValue !== void 0) {
            switch (this._systemValue) {
              case NodeMaterialSystemValues.WorldView:
                hints.needWorldViewMatrix = true;
                break;
              case NodeMaterialSystemValues.WorldViewProjection:
                hints.needWorldViewProjectionMatrix = true;
                break;
            }
          } else {
            if (this._animationType !== AnimatedInputBlockTypes.None) {
              state.sharedData.animatedInputs.push(this);
            }
          }
          return;
        }
        if (this.isAttribute) {
          this.associatedVariableName = remapAttributeName[this.name] ?? this.name;
          if (this.name === "particle_positionw") {
            state.sharedData.defines["POSITIONW_AS_VARYING"] = "true";
          }
          if (this.target === NodeMaterialBlockTargets.Vertex && state._vertexState) {
            if (attributeInFragmentOnly[this.name]) {
              if (attributeAsUniform[this.name]) {
                state._emitUniformFromString(this.declarationVariableName, this.type);
                if (state.shaderLanguage === 1) {
                  this._prefix = `vertexInputs.`;
                }
              } else {
                state._emitVaryingFromString(this.declarationVariableName, this.type);
              }
            } else {
              this._emit(state._vertexState);
            }
            return;
          }
          const alreadyDeclared = state.attributes.indexOf(this.declarationVariableName) !== -1;
          if (!alreadyDeclared) {
            state.attributes.push(this.declarationVariableName);
          }
          if (attributeInFragmentOnly[this.name]) {
            if (attributeAsUniform[this.name]) {
              if (!alreadyDeclared) {
                state._emitUniformFromString(this.declarationVariableName, this.type);
              }
              if (state.shaderLanguage === 1) {
                this._prefix = `uniforms.`;
              }
            } else {
              if (!alreadyDeclared) {
                state._emitVaryingFromString(this.declarationVariableName, this.type);
              }
              if (state.shaderLanguage === 1) {
                this._prefix = `fragmentInputs.`;
              }
            }
          } else {
            if (state.shaderLanguage === 1) {
              if (!alreadyDeclared) {
                const defineName = attributeDefine[this.name];
                if (defineName) {
                  state._attributeDeclaration += this._emitDefine(defineName);
                  state._attributeDeclaration += `attribute ${this.declarationVariableName}: ${state._getShaderType(this.type)};
`;
                  state._attributeDeclaration += `#else
`;
                  state._attributeDeclaration += `var<private> ${this.declarationVariableName}: ${state._getShaderType(this.type)} = ${state._getShaderType(this.type)}(0.);
`;
                  state._attributeDeclaration += `#endif
`;
                } else {
                  state._attributeDeclaration += `attribute ${this.declarationVariableName}: ${state._getShaderType(this.type)};
`;
                }
              }
              this._prefix = `vertexInputs.`;
            } else {
              if (!alreadyDeclared) {
                const defineName = attributeDefine[this.name];
                if (defineName) {
                  state._attributeDeclaration += this._emitDefine(defineName);
                  state._attributeDeclaration += `attribute ${state._getShaderType(this.type)} ${this.declarationVariableName};
`;
                  state._attributeDeclaration += `#else
`;
                  state._attributeDeclaration += `${state._getShaderType(this.type)} ${this.declarationVariableName} = ${state._getShaderType(this.type)}(0.);
`;
                  state._attributeDeclaration += `#endif
`;
                } else {
                  state._attributeDeclaration += `attribute ${state._getShaderType(this.type)} ${this.declarationVariableName};
`;
                }
              }
            }
          }
        }
      }
      /**
       * @internal
       */
      _transmitWorld(effect, world, worldView, worldViewProjection) {
        if (!this._systemValue) {
          return;
        }
        const variableName = this._associatedVariableName;
        switch (this._systemValue) {
          case NodeMaterialSystemValues.World:
            effect.setMatrix(variableName, world);
            break;
          case NodeMaterialSystemValues.WorldView:
            effect.setMatrix(variableName, worldView);
            break;
          case NodeMaterialSystemValues.WorldViewProjection:
            effect.setMatrix(variableName, worldViewProjection);
            break;
        }
      }
      /**
       * @internal
       */
      _transmit(effect, scene, material) {
        if (this.isAttribute) {
          return;
        }
        const variableName = this._associatedVariableName;
        if (this._systemValue) {
          switch (this._systemValue) {
            case NodeMaterialSystemValues.World:
            case NodeMaterialSystemValues.WorldView:
            case NodeMaterialSystemValues.WorldViewProjection:
              return;
            case NodeMaterialSystemValues.View:
              effect.setMatrix(variableName, scene.getViewMatrix());
              break;
            case NodeMaterialSystemValues.Projection:
              effect.setMatrix(variableName, scene.getProjectionMatrix());
              break;
            case NodeMaterialSystemValues.ProjectionInverse: {
              const projectionMatrix = scene.getProjectionMatrix();
              projectionMatrix.invertToRef(TmpVectors.Matrix[0]);
              effect.setMatrix(variableName, TmpVectors.Matrix[0]);
              break;
            }
            case NodeMaterialSystemValues.ViewProjection:
              effect.setMatrix(variableName, scene.getTransformMatrix());
              break;
            case NodeMaterialSystemValues.CameraPosition:
              scene.bindEyePosition(effect, variableName, true);
              break;
            case NodeMaterialSystemValues.CameraForward:
              if (scene.activeCamera) {
                const transform = scene.activeCamera.getWorldMatrix();
                const forward = TmpVectors.Vector3[2];
                forward.set(0, 0, scene.useRightHandedSystem ? -1 : 1);
                const worldForward = new Vector3();
                Vector3.TransformNormalToRef(forward, transform, worldForward);
                worldForward.normalize();
                effect.setVector3(variableName, worldForward);
              }
              break;
            case NodeMaterialSystemValues.FogColor:
              effect.setColor3(variableName, scene.fogColor);
              break;
            case NodeMaterialSystemValues.DeltaTime:
              effect.setFloat(variableName, scene.deltaTime / 1e3);
              break;
            case NodeMaterialSystemValues.CameraParameters:
              if (scene.activeCamera) {
                effect.setFloat4(variableName, scene.getEngine().hasOriginBottomLeft ? -1 : 1, scene.activeCamera.minZ, scene.activeCamera.maxZ, 1 / scene.activeCamera.maxZ);
              }
              break;
            case NodeMaterialSystemValues.MaterialAlpha:
              effect.setFloat(variableName, material.alpha);
              break;
          }
          return;
        }
        const value = this._valueCallback ? this._valueCallback() : this._storedValue;
        if (value === null) {
          return;
        }
        switch (this.type) {
          case NodeMaterialBlockConnectionPointTypes.Float:
            effect.setFloat(variableName, value);
            break;
          case NodeMaterialBlockConnectionPointTypes.Int:
            effect.setInt(variableName, value);
            break;
          case NodeMaterialBlockConnectionPointTypes.Color3:
            TmpColors.Color3[0].set(this.value.r, this.value.g, this.value.b);
            if (this.convertToGammaSpace) {
              TmpColors.Color3[0].toGammaSpaceToRef(TmpColors.Color3[0], scene.getEngine().useExactSrgbConversions);
            }
            if (this.convertToLinearSpace) {
              TmpColors.Color3[0].toLinearSpaceToRef(TmpColors.Color3[0], scene.getEngine().useExactSrgbConversions);
            }
            effect.setColor3(variableName, TmpColors.Color3[0]);
            break;
          case NodeMaterialBlockConnectionPointTypes.Color4:
            TmpColors.Color4[0].set(this.value.r, this.value.g, this.value.b, this.value.a);
            if (this.convertToGammaSpace) {
              TmpColors.Color4[0].toGammaSpaceToRef(TmpColors.Color4[0], scene.getEngine().useExactSrgbConversions);
            }
            if (this.convertToLinearSpace) {
              TmpColors.Color4[0].toLinearSpaceToRef(TmpColors.Color4[0], scene.getEngine().useExactSrgbConversions);
            }
            effect.setDirectColor4(variableName, TmpColors.Color4[0]);
            break;
          case NodeMaterialBlockConnectionPointTypes.Vector2:
            effect.setVector2(variableName, value);
            break;
          case NodeMaterialBlockConnectionPointTypes.Vector3:
            effect.setVector3(variableName, value);
            break;
          case NodeMaterialBlockConnectionPointTypes.Vector4:
            effect.setVector4(variableName, value);
            break;
          case NodeMaterialBlockConnectionPointTypes.Matrix:
            effect.setMatrix(variableName, value);
            break;
        }
      }
      _buildBlock(state) {
        super._buildBlock(state);
        if (this.isUniform || this.isSystemValue) {
          state.sharedData.inputBlocks.push(this);
        }
        this._emit(state);
      }
      _dumpPropertiesCode() {
        const variableName = this._codeVariableName;
        if (this.isAttribute) {
          return super._dumpPropertiesCode() + `${variableName}.setAsAttribute("${this.name}");
`;
        }
        if (this.isSystemValue) {
          return super._dumpPropertiesCode() + `${variableName}.setAsSystemValue(BABYLON.NodeMaterialSystemValues.${NodeMaterialSystemValues[this._systemValue]});
`;
        }
        if (this.isUniform) {
          const codes = [];
          let valueString = "";
          switch (this.type) {
            case NodeMaterialBlockConnectionPointTypes.Float:
              valueString = `${this.value}`;
              break;
            case NodeMaterialBlockConnectionPointTypes.Vector2:
              valueString = `new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;
              break;
            case NodeMaterialBlockConnectionPointTypes.Vector3:
              valueString = `new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;
              break;
            case NodeMaterialBlockConnectionPointTypes.Vector4:
              valueString = `new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;
              break;
            case NodeMaterialBlockConnectionPointTypes.Color3:
              valueString = `new BABYLON.Color3(${this.value.r}, ${this.value.g}, ${this.value.b})`;
              if (this.convertToGammaSpace) {
                valueString += ".toGammaSpace()";
              }
              if (this.convertToLinearSpace) {
                valueString += ".toLinearSpace()";
              }
              break;
            case NodeMaterialBlockConnectionPointTypes.Color4:
              valueString = `new BABYLON.Color4(${this.value.r}, ${this.value.g}, ${this.value.b}, ${this.value.a})`;
              if (this.convertToGammaSpace) {
                valueString += ".toGammaSpace()";
              }
              if (this.convertToLinearSpace) {
                valueString += ".toLinearSpace()";
              }
              break;
            case NodeMaterialBlockConnectionPointTypes.Matrix:
              valueString = `BABYLON.Matrix.FromArray([${this.value.m.join(", ")}])`;
              break;
          }
          codes.push(`${variableName}.value = ${valueString}`);
          if (this.type === NodeMaterialBlockConnectionPointTypes.Float) {
            codes.push(`${variableName}.min = ${this.min}`, `${variableName}.max = ${this.max}`, `${variableName}.isBoolean = ${this.isBoolean}`, `${variableName}.matrixMode = ${this.matrixMode}`, `${variableName}.animationType = BABYLON.AnimatedInputBlockTypes.${AnimatedInputBlockTypes[this.animationType]}`);
          }
          codes.push(`${variableName}.isConstant = ${this.isConstant}`);
          codes.push("");
          return super._dumpPropertiesCode() + codes.join(";\n");
        }
        return super._dumpPropertiesCode();
      }
      dispose() {
        this.onValueChangedObservable.clear();
        super.dispose();
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.type = this.type;
        serializationObject.mode = this._mode;
        serializationObject.systemValue = this._systemValue;
        serializationObject.animationType = this._animationType;
        serializationObject.min = this.min;
        serializationObject.max = this.max;
        serializationObject.isBoolean = this.isBoolean;
        serializationObject.matrixMode = this.matrixMode;
        serializationObject.isConstant = this.isConstant;
        serializationObject.groupInInspector = this.groupInInspector;
        serializationObject.convertToGammaSpace = this.convertToGammaSpace;
        serializationObject.convertToLinearSpace = this.convertToLinearSpace;
        if (this._storedValue != null && this._mode === 0) {
          if (this._storedValue.asArray) {
            serializationObject.valueType = "BABYLON." + this._storedValue.getClassName();
            serializationObject.value = this._storedValue.asArray();
          } else {
            serializationObject.valueType = "number";
            serializationObject.value = this._storedValue;
          }
        }
        return serializationObject;
      }
      _deserialize(serializationObject, scene, rootUrl) {
        this._mode = serializationObject.mode;
        super._deserialize(serializationObject, scene, rootUrl);
        this._type = serializationObject.type;
        this._systemValue = serializationObject.systemValue || serializationObject.wellKnownValue;
        this._animationType = serializationObject.animationType;
        this.min = serializationObject.min || 0;
        this.max = serializationObject.max || 0;
        this.isBoolean = !!serializationObject.isBoolean;
        this.matrixMode = serializationObject.matrixMode || 0;
        this.isConstant = !!serializationObject.isConstant;
        this.groupInInspector = serializationObject.groupInInspector || "";
        this.convertToGammaSpace = !!serializationObject.convertToGammaSpace;
        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
        if (serializationObject.name === "tangent" && serializationObject.mode === 1 && serializationObject.type === NodeMaterialBlockConnectionPointTypes.Vector3) {
          this._type = NodeMaterialBlockConnectionPointTypes.Vector4;
        }
        if (!serializationObject.valueType) {
          return;
        }
        if (serializationObject.valueType === "number") {
          this._storedValue = serializationObject.value;
        } else {
          const valueType = GetClass(serializationObject.valueType);
          if (valueType) {
            this._storedValue = valueType.FromArray(serializationObject.value);
          }
        }
      }
    };
    RegisterClass("BABYLON.InputBlock", InputBlock);
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/screenSizeBlock.js
var ScreenSizeBlock;
var init_screenSizeBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/screenSizeBlock.js"() {
    init_nodeMaterialBlock();
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialBlockTargets();
    init_typeStore();
    ScreenSizeBlock = class extends NodeMaterialBlock {
      /**
       * Name of the variable in the shader that holds the screen size
       */
      get associatedVariableName() {
        return this._varName;
      }
      /**
       * Creates a new ScreenSizeBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13, NodeMaterialBlockTargets.Fragment);
        this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2, NodeMaterialBlockTargets.Fragment);
        this.registerOutput("x", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
        this.registerOutput("y", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "ScreenSizeBlock";
      }
      /**
       * Gets the xy component
       */
      get xy() {
        return this._outputs[0];
      }
      /**
       * Gets the x component
       */
      get x() {
        return this._outputs[1];
      }
      /**
       * Gets the y component
       */
      get y() {
        return this._outputs[2];
      }
      bind(effect) {
        const engine = this._scene.getEngine();
        effect.setFloat2(this._varName, engine.getRenderWidth(), engine.getRenderHeight());
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      writeOutputs(state, varName) {
        let code = "";
        for (const output of this._outputs) {
          if (output.hasEndpoints) {
            code += `${state._declareOutput(output)} = ${varName}.${output.name};
`;
          }
        }
        return code;
      }
      _buildBlock(state) {
        super._buildBlock(state);
        this._scene = state.sharedData.scene;
        if (state.target === NodeMaterialBlockTargets.Vertex) {
          state.sharedData.raiseBuildError("ScreenSizeBlock must only be used in a fragment shader");
          return this;
        }
        state.sharedData.bindableBlocks.push(this);
        this._varName = state._getFreeVariableName("screenSize");
        state._emitUniformFromString(this._varName, NodeMaterialBlockConnectionPointTypes.Vector2);
        const prefix = state.shaderLanguage === 1 ? "uniforms." : "";
        state.compilationString += this.writeOutputs(state, prefix + this._varName);
        return this;
      }
    };
    RegisterClass("BABYLON.ScreenSizeBlock", ScreenSizeBlock);
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/smartFilterFragmentOutputBlock.js
var SfeModeDefine, SmartFilterFragmentOutputBlock;
var init_smartFilterFragmentOutputBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/Fragment/smartFilterFragmentOutputBlock.js"() {
    init_fragmentOutputBlock();
    init_nodeMaterialModes();
    init_typeStore();
    init_inputBlock();
    init_screenSizeBlock();
    SfeModeDefine = "USE_SFE_FRAMEWORK";
    SmartFilterFragmentOutputBlock = class extends FragmentOutputBlock {
      /**
       * Create a new SmartFilterFragmentOutputBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "SmartFilterFragmentOutputBlock";
      }
      /**
       * Initialize the block and prepare the context for build
       * @param state defines the state that will be used for the build
       */
      initialize(state) {
        super.initialize(state);
        if (state.sharedData.nodeMaterial.mode !== NodeMaterialModes.SFE) {
          state.sharedData.raiseBuildError("SmartFilterFragmentOutputBlock should not be used outside of SFE mode.");
        }
        if (state.sharedData.nodeMaterial.shaderLanguage !== 0) {
          state.sharedData.raiseBuildError("WebGPU is not supported in SmartFilters mode.");
        }
        if (!state.sharedData.formatConfig.getUniformAnnotation) {
          state.sharedData.formatConfig.getUniformAnnotation = (name13) => {
            for (const block of state.sharedData.nodeMaterial.attachedBlocks) {
              if (block instanceof InputBlock && block.isUniform && block.associatedVariableName === name13) {
                return this._generateInputBlockAnnotation(block);
              }
              if (block instanceof ScreenSizeBlock && block.associatedVariableName === name13) {
                return this._generateScreenSizeBlockAnnotation();
              }
            }
            return "";
          };
        }
        state.sharedData.formatConfig.formatVariablename = (n) => {
          let name13 = n;
          const hasUnderscoredPrefix = name13.length > 1 && name13[1] === "_";
          if (hasUnderscoredPrefix) {
            name13 = name13.substring(2);
          }
          return name13.replace(/[^a-zA-Z]+/g, "");
        };
      }
      _generateInputBlockAnnotation(inputBlock) {
        const value = inputBlock.valueCallback ? inputBlock.valueCallback() : inputBlock.value;
        return `// { "default": ${JSON.stringify(value)} }
`;
      }
      _generateScreenSizeBlockAnnotation() {
        return `// { "autoBind": "outputResolution" }
`;
      }
      _getMainUvName(state) {
        const screenUv = state.sharedData.nodeMaterial.getInputBlockByPredicate((b) => b.isAttribute && b.name === "postprocess_uv");
        if (!screenUv || !screenUv.isAnAncestorOf(this)) {
          return "";
        }
        return screenUv.associatedVariableName;
      }
      _getOutputString() {
        return "outColor";
      }
      _buildBlock(state) {
        super._buildBlock(state);
        const outputString = this._getOutputString();
        state._customEntryHeader += `#ifdef ${SfeModeDefine}
`;
        state._customEntryHeader += `vec4 nmeMain(vec2 ${this._getMainUvName(state)}) { // main
`;
        state._customEntryHeader += `#else
`;
        state._customEntryHeader += `void main(void) {
`;
        state._customEntryHeader += `#endif
`;
        state._customEntryHeader += `vec4 ${outputString} = vec4(0.0);
`;
        state.compilationString += `
#ifndef ${SfeModeDefine}
`;
        state.compilationString += `gl_FragColor = ${outputString};
`;
        state.compilationString += `#else
`;
        state.compilationString += `return ${outputString};
`;
        state.compilationString += `#endif
`;
        return this;
      }
    };
    RegisterClass("BABYLON.SmartFilterFragmentOutputBlock", SmartFilterFragmentOutputBlock);
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/transformBlock.js
var TransformBlock;
var init_transformBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/transformBlock.js"() {
    init_tslib_es6();
    init_nodeMaterialBlock();
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialBlockTargets();
    init_typeStore();
    init_nodeDecorator();
    TransformBlock = class extends NodeMaterialBlock {
      /**
       * Boolean indicating if the transformation is made for a direction vector and not a position vector
       * If set to true the complementW value will be set to 0 else it will be set to 1
       */
      get transformAsDirection() {
        return this.complementW === 0;
      }
      set transformAsDirection(value) {
        this.complementW = value ? 0 : 1;
      }
      /**
       * Creates a new TransformBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13, NodeMaterialBlockTargets.Neutral);
        this.complementW = 1;
        this.complementZ = 0;
        this.target = NodeMaterialBlockTargets.Vertex;
        this.registerInput("vector", NodeMaterialBlockConnectionPointTypes.AutoDetect);
        this.registerInput("transform", NodeMaterialBlockConnectionPointTypes.Matrix);
        this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Vector4);
        this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
        this._inputs[0].onConnectionObservable.add((other) => {
          if (other.ownerBlock.isInput) {
            const otherAsInput = other.ownerBlock;
            if (otherAsInput.name === "normal" || otherAsInput.name === "tangent") {
              this.complementW = 0;
            }
          }
        });
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "TransformBlock";
      }
      /**
       * Gets the vector input
       */
      get vector() {
        return this._inputs[0];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Gets the xyz output component
       */
      get xyz() {
        return this._outputs[1];
      }
      /**
       * Gets the matrix transform input
       */
      get transform() {
        return this._inputs[1];
      }
      _buildBlock(state) {
        super._buildBlock(state);
        const vector = this.vector;
        const transform = this.transform;
        const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);
        const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);
        if (vector.connectedPoint) {
          if (this.complementW === 0 || this.transformAsDirection) {
            const comments = `//${this.name}`;
            state._emitFunctionFromInclude("helperFunctions", comments);
            state.sharedData.blocksWithDefines.push(this);
            const transformName = state._getFreeVariableName(`${transform.associatedVariableName}_NUS`);
            if (state.shaderLanguage === 1) {
              state.compilationString += `var ${transformName}: mat3x3f = mat3x3f(${transform.associatedVariableName}[0].xyz, ${transform.associatedVariableName}[1].xyz, ${transform.associatedVariableName}[2].xyz);
`;
            } else {
              state.compilationString += `mat3 ${transformName} = mat3(${transform.associatedVariableName});
`;
            }
            state.compilationString += `#ifdef NONUNIFORMSCALING
`;
            state.compilationString += `${transformName} = transposeMat3(inverseMat3(${transformName}));
`;
            state.compilationString += `#endif
`;
            switch (vector.connectedPoint.type) {
              case NodeMaterialBlockConnectionPointTypes.Vector2:
                state.compilationString += state._declareOutput(this.output) + ` = ${vec4}(${transformName} * ${vec3}(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}), ${this._writeFloat(this.complementW)});
`;
                break;
              case NodeMaterialBlockConnectionPointTypes.Vector3:
              case NodeMaterialBlockConnectionPointTypes.Color3:
                state.compilationString += state._declareOutput(this.output) + ` = ${vec4}(${transformName} * ${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});
`;
                break;
              default:
                state.compilationString += state._declareOutput(this.output) + ` = ${vec4}(${transformName} * ${vector.associatedVariableName}.xyz, ${this._writeFloat(this.complementW)});
`;
                break;
            }
          } else {
            const transformName = transform.associatedVariableName;
            switch (vector.connectedPoint.type) {
              case NodeMaterialBlockConnectionPointTypes.Vector2:
                state.compilationString += state._declareOutput(this.output) + ` = ${transformName} * ${vec4}(${vector.associatedVariableName}, ${this._writeFloat(this.complementZ)}, ${this._writeFloat(this.complementW)});
`;
                break;
              case NodeMaterialBlockConnectionPointTypes.Vector3:
              case NodeMaterialBlockConnectionPointTypes.Color3:
                state.compilationString += state._declareOutput(this.output) + ` = ${transformName} * ${vec4}(${vector.associatedVariableName}, ${this._writeFloat(this.complementW)});
`;
                break;
              default:
                state.compilationString += state._declareOutput(this.output) + ` = ${transformName} * ${vector.associatedVariableName};
`;
                break;
            }
          }
          if (this.xyz.hasEndpoints) {
            state.compilationString += state._declareOutput(this.xyz) + ` = ${this.output.associatedVariableName}.xyz;
`;
          }
        }
        return this;
      }
      /**
       * Update defines for shader compilation
       * @param defines defines the material defines to update
       * @param nodeMaterial defines the node material requesting the update
       * @param mesh defines the mesh to be rendered
       */
      prepareDefines(defines, nodeMaterial, mesh) {
        if (mesh && mesh.nonUniformScaling) {
          defines.setValue("NONUNIFORMSCALING", true);
        }
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.complementZ = this.complementZ;
        serializationObject.complementW = this.complementW;
        return serializationObject;
      }
      _deserialize(serializationObject, scene, rootUrl) {
        super._deserialize(serializationObject, scene, rootUrl);
        this.complementZ = serializationObject.complementZ !== void 0 ? serializationObject.complementZ : 0;
        this.complementW = serializationObject.complementW !== void 0 ? serializationObject.complementW : 1;
      }
      _dumpPropertiesCode() {
        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.complementZ = ${this.complementZ};
`;
        codeString += `${this._codeVariableName}.complementW = ${this.complementW};
`;
        return codeString;
      }
    };
    __decorate([
      editableInPropertyPage("Transform as direction", 0, void 0, { embedded: true })
    ], TransformBlock.prototype, "transformAsDirection", null);
    RegisterClass("BABYLON.TransformBlock", TransformBlock);
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/vertexOutputBlock.js
var VertexOutputBlock;
var init_vertexOutputBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/Vertex/vertexOutputBlock.js"() {
    init_nodeMaterialBlock();
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialBlockTargets();
    init_typeStore();
    VertexOutputBlock = class extends NodeMaterialBlock {
      /**
       * Creates a new VertexOutputBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13, NodeMaterialBlockTargets.Vertex, true);
        this.registerInput("vector", NodeMaterialBlockConnectionPointTypes.Vector4);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "VertexOutputBlock";
      }
      /**
       * Gets the vector input component
       */
      get vector() {
        return this._inputs[0];
      }
      _isLogarithmicDepthEnabled(nodeList, useLogarithmicDepth) {
        if (useLogarithmicDepth) {
          return true;
        }
        for (const node of nodeList) {
          if (node.useLogarithmicDepth) {
            return true;
          }
        }
        return false;
      }
      _buildBlock(state) {
        super._buildBlock(state);
        const input = this.vector;
        const isWebGPU = state.shaderLanguage === 1;
        if (state.shaderLanguage === 1) {
          state.compilationString += `vertexOutputs.position = ${input.associatedVariableName};
`;
        } else {
          state.compilationString += `gl_Position = ${input.associatedVariableName};
`;
        }
        if (this._isLogarithmicDepthEnabled(state.sharedData.fragmentOutputNodes, state.sharedData.nodeMaterial.useLogarithmicDepth)) {
          state._emitUniformFromString("logarithmicDepthConstant", NodeMaterialBlockConnectionPointTypes.Float);
          state._emitVaryingFromString("vFragmentDepth", NodeMaterialBlockConnectionPointTypes.Float);
          const fragDepth = isWebGPU ? "vertexOutputs.vFragmentDepth" : "vFragmentDepth";
          const uniformP = isWebGPU ? "uniforms." : "";
          const position = isWebGPU ? "vertexOutputs.position" : "gl_Position";
          state.compilationString += `${fragDepth} = 1.0 + ${position}.w;
`;
          state.compilationString += `${position}.z = log2(max(0.000001, ${fragDepth})) * ${uniformP}logarithmicDepthConstant;
`;
        }
        return this;
      }
    };
    RegisterClass("BABYLON.VertexOutputBlock", VertexOutputBlock);
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/currentScreenBlock.js
var CurrentScreenBlock;
var init_currentScreenBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/Dual/currentScreenBlock.js"() {
    init_nodeMaterialBlock();
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialBlockTargets();
    init_typeStore();
    init_texture();
    CurrentScreenBlock = class extends NodeMaterialBlock {
      /**
       * The name of the sampler to read the screen texture from.
       */
      get samplerName() {
        return this._samplerName;
      }
      /**
       * Gets or sets the texture associated with the node
       */
      get texture() {
        return this._texture;
      }
      set texture(value) {
        this._texture = value;
      }
      /**
       * Create a new CurrentScreenBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13, NodeMaterialBlockTargets.VertexAndFragment);
        this._samplerName = "textureSampler";
        this.convertToGammaSpace = false;
        this.convertToLinearSpace = false;
        this._isUnique = false;
        this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);
        this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
        this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
        this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
        this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
        this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
        this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
        this._inputs[0]._prioritizeVertex = false;
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "CurrentScreenBlock";
      }
      /**
       * Gets the uv input component
       */
      get uv() {
        return this._inputs[0];
      }
      /**
       * Gets the rgba output component
       */
      get rgba() {
        return this._outputs[0];
      }
      /**
       * Gets the rgb output component
       */
      get rgb() {
        return this._outputs[1];
      }
      /**
       * Gets the r output component
       */
      get r() {
        return this._outputs[2];
      }
      /**
       * Gets the g output component
       */
      get g() {
        return this._outputs[3];
      }
      /**
       * Gets the b output component
       */
      get b() {
        return this._outputs[4];
      }
      /**
       * Gets the a output component
       */
      get a() {
        return this._outputs[5];
      }
      /**
       * Initialize the block and prepare the context for build
       * @param state defines the state that will be used for the build
       */
      initialize(state) {
        state._excludeVariableName(this.samplerName);
      }
      get target() {
        if (!this.uv.isConnected) {
          return NodeMaterialBlockTargets.VertexAndFragment;
        }
        if (this.uv.sourceBlock.isInput) {
          return NodeMaterialBlockTargets.VertexAndFragment;
        }
        return NodeMaterialBlockTargets.Fragment;
      }
      prepareDefines(defines) {
        defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);
        defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);
      }
      isReady() {
        if (this.texture && !this.texture.isReadyOrNotBlocking()) {
          return false;
        }
        return true;
      }
      _getMainUvName(state) {
        return "vMain" + this.uv.associatedVariableName;
      }
      _injectVertexCode(state) {
        const uvInput = this.uv;
        if (uvInput.connectedPoint.ownerBlock.isInput) {
          const uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;
          if (!uvInputOwnerBlock.isAttribute) {
            state._emitUniformFromString(uvInput.associatedVariableName, NodeMaterialBlockConnectionPointTypes.Vector2);
          }
        }
        state.compilationString += `${this._mainUVName} = ${uvInput.associatedVariableName}.xy;
`;
        if (!this._outputs.some((o) => o.isConnectedInVertexShader)) {
          return;
        }
        this._writeTextureRead(state, true);
        for (const output of this._outputs) {
          if (output.hasEndpoints) {
            this._writeOutput(state, output, output.name, true);
          }
        }
      }
      _writeTextureRead(state, vertexMode = false) {
        const uvInput = this.uv;
        if (vertexMode) {
          if (state.target === NodeMaterialBlockTargets.Fragment) {
            return;
          }
          const textureReadFunc2 = state.shaderLanguage === 0 ? `texture2D(${this.samplerName},` : `textureSampleLevel(${this.samplerName}, ${this.samplerName + `Sampler`},`;
          const complement = state.shaderLanguage === 0 ? "" : ", 0";
          state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc2} ${uvInput.associatedVariableName}${complement});
`;
          return;
        }
        const textureReadFunc = state.shaderLanguage === 0 ? `texture2D(${this.samplerName},` : `textureSample(${this.samplerName}, ${this.samplerName + `Sampler`},`;
        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
          state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc} ${uvInput.associatedVariableName});
`;
          return;
        }
        state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${textureReadFunc} ${this._mainUVName});
`;
      }
      _writeOutput(state, output, swizzle, vertexMode = false) {
        if (vertexMode) {
          if (state.target === NodeMaterialBlockTargets.Fragment) {
            return;
          }
          state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
          return;
        }
        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
          state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
          return;
        }
        state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
        state.compilationString += `#ifdef ${this._linearDefineName}
`;
        state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});
`;
        state.compilationString += `#endif
`;
        state.compilationString += `#ifdef ${this._gammaDefineName}
`;
        state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});
`;
        state.compilationString += `#endif
`;
      }
      _emitUvAndSampler(state) {
        state._emitVaryingFromString(this._mainUVName, NodeMaterialBlockConnectionPointTypes.Vector2);
        state._emit2DSampler(this.samplerName);
      }
      _buildBlock(state) {
        super._buildBlock(state);
        this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
        if (state.sharedData.blockingBlocks.indexOf(this) < 0) {
          state.sharedData.blockingBlocks.push(this);
        }
        if (state.sharedData.textureBlocks.indexOf(this) < 0) {
          state.sharedData.textureBlocks.push(this);
        }
        if (state.sharedData.blocksWithDefines.indexOf(this) < 0) {
          state.sharedData.blocksWithDefines.push(this);
        }
        this._mainUVName = this._getMainUvName(state);
        this._emitUvAndSampler(state);
        if (state.target !== NodeMaterialBlockTargets.Fragment) {
          this._injectVertexCode(state);
          return;
        }
        if (!this._outputs.some((o) => o.isConnectedInFragmentShader)) {
          return;
        }
        this._linearDefineName = state._getFreeDefineName("ISLINEAR");
        this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
        const comments = `//${this.name}`;
        state._emitFunctionFromInclude("helperFunctions", comments);
        this._writeTextureRead(state);
        for (const output of this._outputs) {
          if (output.hasEndpoints) {
            this._writeOutput(state, output, output.name);
          }
        }
        return this;
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.convertToGammaSpace = this.convertToGammaSpace;
        serializationObject.convertToLinearSpace = this.convertToLinearSpace;
        if (this.texture && !this.texture.isRenderTarget) {
          serializationObject.texture = this.texture.serialize();
        }
        return serializationObject;
      }
      _deserialize(serializationObject, scene, rootUrl) {
        super._deserialize(serializationObject, scene, rootUrl);
        this.convertToGammaSpace = serializationObject.convertToGammaSpace;
        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
        if (serializationObject.texture) {
          rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
          this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
        }
      }
    };
    RegisterClass("BABYLON.CurrentScreenBlock", CurrentScreenBlock);
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleTextureBlock.js
var ParticleTextureBlock;
var init_particleTextureBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleTextureBlock.js"() {
    init_nodeMaterialBlock();
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialBlockTargets();
    init_inputBlock();
    init_typeStore();
    init_texture();
    ParticleTextureBlock = class extends NodeMaterialBlock {
      /**
       * Create a new ParticleTextureBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13, NodeMaterialBlockTargets.Fragment);
        this._samplerName = "diffuseSampler";
        this.convertToGammaSpace = false;
        this.convertToLinearSpace = false;
        this._isUnique = false;
        this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.VertexAndFragment);
        this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
        this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
        this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
        this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
        this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
        this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "ParticleTextureBlock";
      }
      /**
       * Gets the uv input component
       */
      get uv() {
        return this._inputs[0];
      }
      /**
       * Gets the rgba output component
       */
      get rgba() {
        return this._outputs[0];
      }
      /**
       * Gets the rgb output component
       */
      get rgb() {
        return this._outputs[1];
      }
      /**
       * Gets the r output component
       */
      get r() {
        return this._outputs[2];
      }
      /**
       * Gets the g output component
       */
      get g() {
        return this._outputs[3];
      }
      /**
       * Gets the b output component
       */
      get b() {
        return this._outputs[4];
      }
      /**
       * Gets the a output component
       */
      get a() {
        return this._outputs[5];
      }
      /**
       * Initialize the block and prepare the context for build
       * @param state defines the state that will be used for the build
       */
      initialize(state) {
        state._excludeVariableName("diffuseSampler");
      }
      autoConfigure(material, additionalFilteringInfo = () => true) {
        if (!this.uv.isConnected) {
          let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === "particle_uv" && additionalFilteringInfo(b));
          if (!uvInput) {
            uvInput = new InputBlock("uv");
            uvInput.setAsAttribute("particle_uv");
          }
          uvInput.output.connectTo(this.uv);
        }
      }
      prepareDefines(defines) {
        defines.setValue(this._linearDefineName, this.convertToGammaSpace, true);
        defines.setValue(this._gammaDefineName, this.convertToLinearSpace, true);
      }
      isReady() {
        if (this.texture && !this.texture.isReadyOrNotBlocking()) {
          return false;
        }
        return true;
      }
      _writeOutput(state, output, swizzle) {
        state.compilationString += `${state._declareOutput(output)} = ${this._tempTextureRead}.${swizzle};
`;
        state.compilationString += `#ifdef ${this._linearDefineName}
`;
        state.compilationString += `${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});
`;
        state.compilationString += `#endif
`;
        state.compilationString += `#ifdef ${this._gammaDefineName}
`;
        state.compilationString += `${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});
`;
        state.compilationString += `#endif
`;
      }
      _buildBlock(state) {
        super._buildBlock(state);
        if (state.target === NodeMaterialBlockTargets.Vertex) {
          return;
        }
        this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
        state._emit2DSampler(this._samplerName);
        state.sharedData.blockingBlocks.push(this);
        state.sharedData.textureBlocks.push(this);
        state.sharedData.blocksWithDefines.push(this);
        this._linearDefineName = state._getFreeDefineName("ISLINEAR");
        this._gammaDefineName = state._getFreeDefineName("ISGAMMA");
        const comments = `//${this.name}`;
        state._emitFunctionFromInclude("helperFunctions", comments);
        state.compilationString += `${state._declareLocalVar(this._tempTextureRead, NodeMaterialBlockConnectionPointTypes.Vector4)} = ${state._generateTextureSample(this.uv.associatedVariableName, this._samplerName)};
`;
        for (const output of this._outputs) {
          if (output.hasEndpoints) {
            this._writeOutput(state, output, output.name);
          }
        }
        return this;
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.convertToGammaSpace = this.convertToGammaSpace;
        serializationObject.convertToLinearSpace = this.convertToLinearSpace;
        if (this.texture && !this.texture.isRenderTarget) {
          serializationObject.texture = this.texture.serialize();
        }
        return serializationObject;
      }
      _deserialize(serializationObject, scene, rootUrl) {
        super._deserialize(serializationObject, scene, rootUrl);
        this.convertToGammaSpace = serializationObject.convertToGammaSpace;
        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;
        if (serializationObject.texture) {
          rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
          this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
        }
      }
    };
    RegisterClass("BABYLON.ParticleTextureBlock", ParticleTextureBlock);
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleRampGradientBlock.js
var ParticleRampGradientBlock;
var init_particleRampGradientBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleRampGradientBlock.js"() {
    init_nodeMaterialBlock();
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialBlockTargets();
    init_typeStore();
    ParticleRampGradientBlock = class extends NodeMaterialBlock {
      /**
       * Create a new ParticleRampGradientBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13, NodeMaterialBlockTargets.Fragment);
        this._isUnique = true;
        this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);
        this.registerOutput("rampColor", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "ParticleRampGradientBlock";
      }
      /**
       * Gets the color input component
       */
      get color() {
        return this._inputs[0];
      }
      /**
       * Gets the rampColor output component
       */
      get rampColor() {
        return this._outputs[0];
      }
      /**
       * Initialize the block and prepare the context for build
       * @param state defines the state that will be used for the build
       */
      initialize(state) {
        state._excludeVariableName("remapRanges");
        state._excludeVariableName("rampSampler");
        state._excludeVariableName("baseColor");
        state._excludeVariableName("alpha");
        state._excludeVariableName("remappedColorIndex");
        state._excludeVariableName("rampColor");
      }
      _buildBlock(state) {
        super._buildBlock(state);
        if (state.target === NodeMaterialBlockTargets.Vertex) {
          return;
        }
        state._emit2DSampler("rampSampler", "RAMPGRADIENT");
        state._emitVaryingFromString("remapRanges", NodeMaterialBlockConnectionPointTypes.Vector4, "RAMPGRADIENT");
        const varyingString = state.shaderLanguage === 0 ? "" : "fragmentInputs.";
        state.compilationString += `
            #ifdef RAMPGRADIENT
                ${state._declareLocalVar("baseColor", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${this.color.associatedVariableName};
                ${state._declareLocalVar("alpha", NodeMaterialBlockConnectionPointTypes.Float)} = ${this.color.associatedVariableName}.a;

                ${state._declareLocalVar("remappedColorIndex", NodeMaterialBlockConnectionPointTypes.Float)} = clamp((alpha - ${varyingString}remapRanges.x) / ${varyingString}remapRanges.y, 0.0, 1.0);

                ${state._declareLocalVar("rampColor", NodeMaterialBlockConnectionPointTypes.Vector4)} = ${state._generateTextureSample("vec2(1.0 - remappedColorIndex, 0.)", "rampSampler")};

                // Remapped alpha
                ${state._declareOutput(this.rampColor)} = vec4${state.fSuffix}(baseColor.rgb * rampColor.rgb, clamp((alpha * rampColor.a - ${varyingString}remapRanges.z) / ${varyingString}remapRanges.w, 0.0, 1.0));
            #else
                ${state._declareOutput(this.rampColor)} = ${this.color.associatedVariableName};
            #endif
        `;
        return this;
      }
    };
    RegisterClass("BABYLON.ParticleRampGradientBlock", ParticleRampGradientBlock);
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleBlendMultiplyBlock.js
var ParticleBlendMultiplyBlock;
var init_particleBlendMultiplyBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/Particle/particleBlendMultiplyBlock.js"() {
    init_nodeMaterialBlock();
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialBlockTargets();
    init_typeStore();
    ParticleBlendMultiplyBlock = class extends NodeMaterialBlock {
      /**
       * Create a new ParticleBlendMultiplyBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13, NodeMaterialBlockTargets.Fragment);
        this._isUnique = true;
        this.registerInput("color", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);
        this.registerInput("alphaTexture", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
        this.registerInput("alphaColor", NodeMaterialBlockConnectionPointTypes.Float, false, NodeMaterialBlockTargets.Fragment);
        this.registerOutput("blendColor", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "ParticleBlendMultiplyBlock";
      }
      /**
       * Gets the color input component
       */
      get color() {
        return this._inputs[0];
      }
      /**
       * Gets the alphaTexture input component
       */
      get alphaTexture() {
        return this._inputs[1];
      }
      /**
       * Gets the alphaColor input component
       */
      get alphaColor() {
        return this._inputs[2];
      }
      /**
       * Gets the blendColor output component
       */
      get blendColor() {
        return this._outputs[0];
      }
      /**
       * Initialize the block and prepare the context for build
       * @param state defines the state that will be used for the build
       */
      initialize(state) {
        state._excludeVariableName("sourceAlpha");
      }
      _buildBlock(state) {
        super._buildBlock(state);
        if (state.target === NodeMaterialBlockTargets.Vertex) {
          return;
        }
        state.compilationString += `
            #ifdef BLENDMULTIPLYMODE
                ${state._declareOutput(this.blendColor)};
                ${state._declareLocalVar("sourceAlpha", NodeMaterialBlockConnectionPointTypes.Float)}  = ${this.alphaColor.associatedVariableName} * ${this.alphaTexture.associatedVariableName};
                ${this.blendColor.associatedVariableName} = vec4${state.fSuffix}(${this.color.associatedVariableName}.rgb * sourceAlpha + vec3(1.0) * (1.0 - sourceAlpha), ${this.color.associatedVariableName}.a);
            #else
                ${state._declareOutput(this.blendColor)} = ${this.color.associatedVariableName};
            #endif
        `;
        return this;
      }
    };
    RegisterClass("BABYLON.ParticleBlendMultiplyBlock", ParticleBlendMultiplyBlock);
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/vectorMergerBlock.js
var VectorMergerBlock;
var init_vectorMergerBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/vectorMergerBlock.js"() {
    init_nodeMaterialBlock();
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialBlockTargets();
    init_typeStore();
    VectorMergerBlock = class extends NodeMaterialBlock {
      /**
       * Create a new VectorMergerBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13, NodeMaterialBlockTargets.Neutral);
        this.xSwizzle = "x";
        this.ySwizzle = "y";
        this.zSwizzle = "z";
        this.wSwizzle = "w";
        this.registerInput("xyzw ", NodeMaterialBlockConnectionPointTypes.Vector4, true);
        this.registerInput("xyz ", NodeMaterialBlockConnectionPointTypes.Vector3, true);
        this.registerInput("xy ", NodeMaterialBlockConnectionPointTypes.Vector2, true);
        this.registerInput("zw ", NodeMaterialBlockConnectionPointTypes.Vector2, true);
        this.registerInput("x", NodeMaterialBlockConnectionPointTypes.Float, true);
        this.registerInput("y", NodeMaterialBlockConnectionPointTypes.Float, true);
        this.registerInput("z", NodeMaterialBlockConnectionPointTypes.Float, true);
        this.registerInput("w", NodeMaterialBlockConnectionPointTypes.Float, true);
        this.registerOutput("xyzw", NodeMaterialBlockConnectionPointTypes.Vector4);
        this.registerOutput("xyz", NodeMaterialBlockConnectionPointTypes.Vector3);
        this.registerOutput("xy", NodeMaterialBlockConnectionPointTypes.Vector2);
        this.registerOutput("zw", NodeMaterialBlockConnectionPointTypes.Vector2);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "VectorMergerBlock";
      }
      /**
       * Gets the xyzw component (input)
       */
      get xyzwIn() {
        return this._inputs[0];
      }
      /**
       * Gets the xyz component (input)
       */
      get xyzIn() {
        return this._inputs[1];
      }
      /**
       * Gets the xy component (input)
       */
      get xyIn() {
        return this._inputs[2];
      }
      /**
       * Gets the zw component (input)
       */
      get zwIn() {
        return this._inputs[3];
      }
      /**
       * Gets the x component (input)
       */
      get x() {
        return this._inputs[4];
      }
      /**
       * Gets the y component (input)
       */
      get y() {
        return this._inputs[5];
      }
      /**
       * Gets the z component (input)
       */
      get z() {
        return this._inputs[6];
      }
      /**
       * Gets the w component (input)
       */
      get w() {
        return this._inputs[7];
      }
      /**
       * Gets the xyzw component (output)
       */
      get xyzw() {
        return this._outputs[0];
      }
      /**
       * Gets the xyz component (output)
       */
      get xyzOut() {
        return this._outputs[1];
      }
      /**
       * Gets the xy component (output)
       */
      get xyOut() {
        return this._outputs[2];
      }
      /**
       * Gets the zw component (output)
       */
      get zwOut() {
        return this._outputs[3];
      }
      /**
       * Gets the xy component (output)
       * @deprecated Please use xyOut instead.
       */
      get xy() {
        return this.xyOut;
      }
      /**
       * Gets the xyz component (output)
       * @deprecated Please use xyzOut instead.
       */
      get xyz() {
        return this.xyzOut;
      }
      _inputRename(name13) {
        if (name13 === "xyzw ") {
          return "xyzwIn";
        }
        if (name13 === "xyz ") {
          return "xyzIn";
        }
        if (name13 === "xy ") {
          return "xyIn";
        }
        if (name13 === "zw ") {
          return "zwIn";
        }
        return name13;
      }
      _buildSwizzle(len) {
        const swizzle = this.xSwizzle + this.ySwizzle + this.zSwizzle + this.wSwizzle;
        return "." + swizzle.substring(0, len);
      }
      _buildBlock(state) {
        super._buildBlock(state);
        const xInput = this.x;
        const yInput = this.y;
        const zInput = this.z;
        const wInput = this.w;
        const xyInput = this.xyIn;
        const zwInput = this.zwIn;
        const xyzInput = this.xyzIn;
        const xyzwInput = this.xyzwIn;
        const v4Output = this._outputs[0];
        const v3Output = this._outputs[1];
        const v2Output = this._outputs[2];
        const v2CompOutput = this._outputs[3];
        const vec4 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector4);
        const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);
        const vec2 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector2);
        if (xyzwInput.isConnected) {
          if (v4Output.hasEndpoints) {
            state.compilationString += state._declareOutput(v4Output) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(4)};
`;
          }
          if (v3Output.hasEndpoints) {
            state.compilationString += state._declareOutput(v3Output) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(3)};
`;
          }
          if (v2Output.hasEndpoints) {
            state.compilationString += state._declareOutput(v2Output) + ` = ${xyzwInput.associatedVariableName}${this._buildSwizzle(2)};
`;
          }
        } else if (xyzInput.isConnected) {
          if (v4Output.hasEndpoints) {
            state.compilationString += state._declareOutput(v4Output) + ` = ${vec4}(${xyzInput.associatedVariableName}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(4)};
`;
          }
          if (v3Output.hasEndpoints) {
            state.compilationString += state._declareOutput(v3Output) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(3)};
`;
          }
          if (v2Output.hasEndpoints) {
            state.compilationString += state._declareOutput(v2Output) + ` = ${xyzInput.associatedVariableName}${this._buildSwizzle(2)};
`;
          }
        } else if (xyInput.isConnected) {
          if (v4Output.hasEndpoints) {
            if (zwInput.isConnected) {
              state.compilationString += state._declareOutput(v4Output) + ` = ${vec4}(${xyInput.associatedVariableName}, ${zwInput.associatedVariableName})${this._buildSwizzle(4)};
`;
            } else {
              state.compilationString += state._declareOutput(v4Output) + ` = ${vec4}(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(4)};
`;
            }
          }
          if (v3Output.hasEndpoints) {
            state.compilationString += state._declareOutput(v3Output) + ` = ${vec3}(${xyInput.associatedVariableName}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"})${this._buildSwizzle(3)};
`;
          }
          if (v2Output.hasEndpoints) {
            state.compilationString += state._declareOutput(v2Output) + ` = ${xyInput.associatedVariableName}${this._buildSwizzle(2)};
`;
          }
          if (v2CompOutput.hasEndpoints) {
            if (zwInput.isConnected) {
              state.compilationString += state._declareOutput(v2CompOutput) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};
`;
            } else {
              state.compilationString += state._declareOutput(v2CompOutput) + ` = ${vec2}(${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(2)};
`;
            }
          }
        } else {
          if (v4Output.hasEndpoints) {
            if (zwInput.isConnected) {
              state.compilationString += state._declareOutput(v4Output) + ` = ${vec4}(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"}, ${zwInput.associatedVariableName})${this._buildSwizzle(4)};
`;
            } else {
              state.compilationString += state._declareOutput(v4Output) + ` = ${vec4}(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(4)};
`;
            }
          }
          if (v3Output.hasEndpoints) {
            state.compilationString += state._declareOutput(v3Output) + ` = ${vec3}(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"}, ${zInput.isConnected ? this._writeVariable(zInput) : "0.0"})${this._buildSwizzle(3)};
`;
          }
          if (v2Output.hasEndpoints) {
            state.compilationString += state._declareOutput(v2Output) + ` = ${vec2}(${xInput.isConnected ? this._writeVariable(xInput) : "0.0"}, ${yInput.isConnected ? this._writeVariable(yInput) : "0.0"})${this._buildSwizzle(2)};
`;
          }
          if (v2CompOutput.hasEndpoints) {
            if (zwInput.isConnected) {
              state.compilationString += state._declareOutput(v2CompOutput) + ` = ${zwInput.associatedVariableName}${this._buildSwizzle(2)};
`;
            } else {
              state.compilationString += state._declareOutput(v2CompOutput) + ` = ${vec2}(${zInput.isConnected ? this._writeVariable(zInput) : "0.0"}, ${wInput.isConnected ? this._writeVariable(wInput) : "0.0"})${this._buildSwizzle(2)};
`;
            }
          }
        }
        return this;
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.xSwizzle = this.xSwizzle;
        serializationObject.ySwizzle = this.ySwizzle;
        serializationObject.zSwizzle = this.zSwizzle;
        serializationObject.wSwizzle = this.wSwizzle;
        return serializationObject;
      }
      _deserialize(serializationObject, scene, rootUrl) {
        super._deserialize(serializationObject, scene, rootUrl);
        this.xSwizzle = serializationObject.xSwizzle ?? "x";
        this.ySwizzle = serializationObject.ySwizzle ?? "y";
        this.zSwizzle = serializationObject.zSwizzle ?? "z";
        this.wSwizzle = serializationObject.wSwizzle ?? "w";
      }
      _dumpPropertiesCode() {
        let codeString = super._dumpPropertiesCode();
        codeString += `${this._codeVariableName}.xSwizzle = "${this.xSwizzle}";
`;
        codeString += `${this._codeVariableName}.ySwizzle = "${this.ySwizzle}";
`;
        codeString += `${this._codeVariableName}.zSwizzle = "${this.zSwizzle}";
`;
        codeString += `${this._codeVariableName}.wSwizzle = "${this.wSwizzle}";
`;
        return codeString;
      }
    };
    RegisterClass("BABYLON.VectorMergerBlock", VectorMergerBlock);
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/remapBlock.js
var RemapBlock;
var init_remapBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/remapBlock.js"() {
    init_tslib_es6();
    init_nodeMaterialBlock();
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialBlockTargets();
    init_typeStore();
    init_math_vector();
    init_nodeDecorator();
    RemapBlock = class extends NodeMaterialBlock {
      /**
       * Creates a new RemapBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13, NodeMaterialBlockTargets.Neutral);
        this.sourceRange = new Vector2(-1, 1);
        this.targetRange = new Vector2(0, 1);
        this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
        this.registerInput("sourceMin", NodeMaterialBlockConnectionPointTypes.Float, true);
        this.registerInput("sourceMax", NodeMaterialBlockConnectionPointTypes.Float, true);
        this.registerInput("targetMin", NodeMaterialBlockConnectionPointTypes.Float, true);
        this.registerInput("targetMax", NodeMaterialBlockConnectionPointTypes.Float, true);
        this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
        this._outputs[0]._typeConnectionSource = this._inputs[0];
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "RemapBlock";
      }
      /**
       * Gets the input component
       */
      get input() {
        return this._inputs[0];
      }
      /**
       * Gets the source min input component
       */
      get sourceMin() {
        return this._inputs[1];
      }
      /**
       * Gets the source max input component
       */
      get sourceMax() {
        return this._inputs[2];
      }
      /**
       * Gets the target min input component
       */
      get targetMin() {
        return this._inputs[3];
      }
      /**
       * Gets the target max input component
       */
      get targetMax() {
        return this._inputs[4];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      _buildBlock(state) {
        super._buildBlock(state);
        const output = this._outputs[0];
        const sourceMin = this.sourceMin.isConnected ? this.sourceMin.associatedVariableName : this._writeFloat(this.sourceRange.x);
        const sourceMax = this.sourceMax.isConnected ? this.sourceMax.associatedVariableName : this._writeFloat(this.sourceRange.y);
        const targetMin = this.targetMin.isConnected ? this.targetMin.associatedVariableName : this._writeFloat(this.targetRange.x);
        const targetMax = this.targetMax.isConnected ? this.targetMax.associatedVariableName : this._writeFloat(this.targetRange.y);
        state.compilationString += state._declareOutput(output) + ` = ${targetMin} + (${this._inputs[0].associatedVariableName} - ${sourceMin}) * (${targetMax} - ${targetMin}) / (${sourceMax} - ${sourceMin});
`;
        return this;
      }
      _dumpPropertiesCode() {
        let codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.sourceRange = new BABYLON.Vector2(${this.sourceRange.x}, ${this.sourceRange.y});
`;
        codeString += `${this._codeVariableName}.targetRange = new BABYLON.Vector2(${this.targetRange.x}, ${this.targetRange.y});
`;
        return codeString;
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.sourceRange = this.sourceRange.asArray();
        serializationObject.targetRange = this.targetRange.asArray();
        return serializationObject;
      }
      _deserialize(serializationObject, scene, rootUrl) {
        super._deserialize(serializationObject, scene, rootUrl);
        this.sourceRange = Vector2.FromArray(serializationObject.sourceRange);
        this.targetRange = Vector2.FromArray(serializationObject.targetRange);
      }
    };
    __decorate([
      editableInPropertyPage(
        "From",
        3
        /* PropertyTypeForEdition.Vector2 */
      )
    ], RemapBlock.prototype, "sourceRange", void 0);
    __decorate([
      editableInPropertyPage(
        "To",
        3
        /* PropertyTypeForEdition.Vector2 */
      )
    ], RemapBlock.prototype, "targetRange", void 0);
    RegisterClass("BABYLON.RemapBlock", RemapBlock);
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/baseMathBlock.js
var BaseMathBlock;
var init_baseMathBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/baseMathBlock.js"() {
    init_nodeMaterialBlockTargets();
    init_nodeMaterialBlock();
    init_nodeMaterialBlockConnectionPointTypes();
    BaseMathBlock = class extends NodeMaterialBlock {
      constructor(name13) {
        super(name13, NodeMaterialBlockTargets.Neutral);
        this.registerInput("left", NodeMaterialBlockConnectionPointTypes.AutoDetect);
        this.registerInput("right", NodeMaterialBlockConnectionPointTypes.AutoDetect);
        this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
        this.output._typeConnectionSource = this.left;
        this._linkConnectionTypes(0, 1, true);
        this.left.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
        this.right.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Float);
        this._connectionObservers = [
          this.left.onTypeChangedObservable.add(() => this._updateInputOutputTypes()),
          this.right.onTypeChangedObservable.add(() => this._updateInputOutputTypes())
        ];
      }
      /**
       * Gets the left operand input component
       */
      get left() {
        return this._inputs[0];
      }
      /**
       * Gets the right operand input component
       */
      get right() {
        return this._inputs[1];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      _updateInputOutputTypes() {
        this.output._typeConnectionSource = this.left;
        if (this.left.isConnected && this.right.isConnected) {
          if (this.left.type === NodeMaterialBlockConnectionPointTypes.Int || this.left.type === NodeMaterialBlockConnectionPointTypes.Float && this.right.type !== NodeMaterialBlockConnectionPointTypes.Int) {
            this.output._typeConnectionSource = this.right;
          }
        } else if (this.left.isConnected !== this.right.isConnected) {
          this.output._typeConnectionSource = this.left.isConnected ? this.left : this.right;
        }
        if (this.left.isConnected || this.right.isConnected) {
          for (const [first, second] of [
            [this.left, this.right],
            [this.right, this.left]
          ]) {
            first.acceptedConnectionPointTypes = [NodeMaterialBlockConnectionPointTypes.Int, NodeMaterialBlockConnectionPointTypes.Float];
            if (second.isConnected) {
              first.acceptedConnectionPointTypes.push(second.type);
              if (second.type === NodeMaterialBlockConnectionPointTypes.Int || second.type === NodeMaterialBlockConnectionPointTypes.Float) {
                first.acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector2, NodeMaterialBlockConnectionPointTypes.Vector3, NodeMaterialBlockConnectionPointTypes.Vector4, NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockConnectionPointTypes.Matrix);
              }
            }
          }
        }
      }
      /**
       * Release resources
       */
      dispose() {
        super.dispose();
        for (const observer of this._connectionObservers) {
          observer.remove();
        }
        this._connectionObservers.length = 0;
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/multiplyBlock.js
var MultiplyBlock;
var init_multiplyBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/multiplyBlock.js"() {
    init_typeStore();
    init_baseMathBlock();
    MultiplyBlock = class extends BaseMathBlock {
      /**
       * Creates a new MultiplyBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "MultiplyBlock";
      }
      _buildBlock(state) {
        super._buildBlock(state);
        const output = this._outputs[0];
        state.compilationString += state._declareOutput(output) + ` = ${this.left.associatedVariableName} * ${this.right.associatedVariableName};
`;
        return this;
      }
    };
    RegisterClass("BABYLON.MultiplyBlock", MultiplyBlock);
  }
});

// node_modules/@babylonjs/core/Particles/baseParticleSystem.js
var BaseParticleSystem;
var init_baseParticleSystem = __esm({
  "node_modules/@babylonjs/core/Particles/baseParticleSystem.js"() {
    init_math_vector();
    init_imageProcessingConfiguration_defines();
    init_math_color();
    init_engine_dynamicBuffer();
    init_typeStore();
    BaseParticleSystem = class _BaseParticleSystem {
      /**
       * The amount of time the particle system is running (depends of the overall update speed).
       */
      get targetStopDuration() {
        return this._targetStopDuration;
      }
      set targetStopDuration(value) {
        if (this._targetStopDuration === value) {
          return;
        }
        this._targetStopDuration = value;
      }
      /**
       * Returns true if the particle system was generated by a node particle system set
       */
      get isNodeGenerated() {
        return false;
      }
      /**
       * Gets or sets a texture used to add random noise to particle positions
       */
      get noiseTexture() {
        return this._noiseTexture;
      }
      set noiseTexture(value) {
        if (this._noiseTexture === value) {
          return;
        }
        this._noiseTexture = value;
        this._reset();
      }
      /** @internal */
      get _isAnimationSheetEnabled() {
        return this._animationSheetEnabled;
      }
      set _isAnimationSheetEnabled(value) {
        if (this._animationSheetEnabled === value) {
          return;
        }
        this._animationSheetEnabled = value;
      }
      /**
       * Gets or sets whether an animation sprite sheet is enabled or not on the particle system
       */
      get isAnimationSheetEnabled() {
        return this._isAnimationSheetEnabled;
      }
      set isAnimationSheetEnabled(value) {
        if (this._isAnimationSheetEnabled == value) {
          return;
        }
        this._isAnimationSheetEnabled = value;
        this._reset();
      }
      /**
       * Gets or sets a boolean enabling the use of logarithmic depth buffers, which is good for wide depth buffers.
       */
      get useLogarithmicDepth() {
        return this._useLogarithmicDepth;
      }
      set useLogarithmicDepth(value) {
        this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;
      }
      /**
       * Get hosting scene
       * @returns the scene
       */
      getScene() {
        return this._scene;
      }
      _hasTargetStopDurationDependantGradient() {
        return this._startSizeGradients && this._startSizeGradients.length > 0 || this._emitRateGradients && this._emitRateGradients.length > 0 || this._lifeTimeGradients && this._lifeTimeGradients.length > 0;
      }
      _setEngineBasedOnBlendMode(blendMode) {
        switch (blendMode) {
          case _BaseParticleSystem.BLENDMODE_MULTIPLYADD:
            return;
          case _BaseParticleSystem.BLENDMODE_ADD:
            blendMode = 1;
            break;
          case _BaseParticleSystem.BLENDMODE_ONEONE:
            blendMode = 6;
            break;
          case _BaseParticleSystem.BLENDMODE_STANDARD:
            blendMode = 2;
            break;
          case _BaseParticleSystem.BLENDMODE_MULTIPLY:
            blendMode = 4;
            break;
          case _BaseParticleSystem.BLENDMODE_SUBTRACT:
            blendMode = 3;
            break;
          default:
            break;
        }
        this._engine.setAlphaMode(blendMode);
      }
      /**
       * Gets the current list of drag gradients.
       * You must use addDragGradient and removeDragGradient to update this list
       * @returns the list of drag gradients
       */
      getDragGradients() {
        return this._dragGradients;
      }
      /**
       * Gets the current list of limit velocity gradients.
       * You must use addLimitVelocityGradient and removeLimitVelocityGradient to update this list
       * @returns the list of limit velocity gradients
       */
      getLimitVelocityGradients() {
        return this._limitVelocityGradients;
      }
      /**
       * Gets the current list of color gradients.
       * You must use addColorGradient and removeColorGradient to update this list
       * @returns the list of color gradients
       */
      getColorGradients() {
        return this._colorGradients;
      }
      /**
       * Gets the current list of size gradients.
       * You must use addSizeGradient and removeSizeGradient to update this list
       * @returns the list of size gradients
       */
      getSizeGradients() {
        return this._sizeGradients;
      }
      /**
       * Gets the current list of color remap gradients.
       * You must use addColorRemapGradient and removeColorRemapGradient to update this list
       * @returns the list of color remap gradients
       */
      getColorRemapGradients() {
        return this._colorRemapGradients;
      }
      /**
       * Gets the current list of alpha remap gradients.
       * You must use addAlphaRemapGradient and removeAlphaRemapGradient to update this list
       * @returns the list of alpha remap gradients
       */
      getAlphaRemapGradients() {
        return this._alphaRemapGradients;
      }
      /**
       * Gets the current list of life time gradients.
       * You must use addLifeTimeGradient and removeLifeTimeGradient to update this list
       * @returns the list of life time gradients
       */
      getLifeTimeGradients() {
        return this._lifeTimeGradients;
      }
      /**
       * Gets the current list of angular speed gradients.
       * You must use addAngularSpeedGradient and removeAngularSpeedGradient to update this list
       * @returns the list of angular speed gradients
       */
      getAngularSpeedGradients() {
        return this._angularSpeedGradients;
      }
      /**
       * Gets the current list of velocity gradients.
       * You must use addVelocityGradient and removeVelocityGradient to update this list
       * @returns the list of velocity gradients
       */
      getVelocityGradients() {
        return this._velocityGradients;
      }
      /**
       * Gets the current list of start size gradients.
       * You must use addStartSizeGradient and removeStartSizeGradient to update this list
       * @returns the list of start size gradients
       */
      getStartSizeGradients() {
        return this._startSizeGradients;
      }
      /**
       * Gets the current list of emit rate gradients.
       * You must use addEmitRateGradient and removeEmitRateGradient to update this list
       * @returns the list of emit rate gradients
       */
      getEmitRateGradients() {
        return this._emitRateGradients;
      }
      /**
       * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
       * This only works when particleEmitterTyps is a BoxParticleEmitter
       */
      get direction1() {
        if (this.particleEmitterType.direction1) {
          return this.particleEmitterType.direction1;
        }
        return Vector3.Zero();
      }
      set direction1(value) {
        if (this.particleEmitterType.direction1) {
          this.particleEmitterType.direction1 = value;
        }
      }
      /**
       * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
       * This only works when particleEmitterTyps is a BoxParticleEmitter
       */
      get direction2() {
        if (this.particleEmitterType.direction2) {
          return this.particleEmitterType.direction2;
        }
        return Vector3.Zero();
      }
      set direction2(value) {
        if (this.particleEmitterType.direction2) {
          this.particleEmitterType.direction2 = value;
        }
      }
      /**
       * Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
       * This only works when particleEmitterTyps is a BoxParticleEmitter
       */
      get minEmitBox() {
        if (this.particleEmitterType.minEmitBox) {
          return this.particleEmitterType.minEmitBox;
        }
        return Vector3.Zero();
      }
      set minEmitBox(value) {
        if (this.particleEmitterType.minEmitBox) {
          this.particleEmitterType.minEmitBox = value;
        }
      }
      /**
       * Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
       * This only works when particleEmitterTyps is a BoxParticleEmitter
       */
      get maxEmitBox() {
        if (this.particleEmitterType.maxEmitBox) {
          return this.particleEmitterType.maxEmitBox;
        }
        return Vector3.Zero();
      }
      set maxEmitBox(value) {
        if (this.particleEmitterType.maxEmitBox) {
          this.particleEmitterType.maxEmitBox = value;
        }
      }
      /**
       * Gets or sets the billboard mode to use when isBillboardBased = true.
       * Value can be: ParticleSystem.BILLBOARDMODE_ALL, ParticleSystem.BILLBOARDMODE_Y, ParticleSystem.BILLBOARDMODE_STRETCHED, ParticleSystem.PARTICLES_BILLBOARDMODE_STRETCHED_LOCAL
       */
      get billboardMode() {
        return this._billboardMode;
      }
      set billboardMode(value) {
        if (this._billboardMode === value) {
          return;
        }
        this._billboardMode = value;
        this._reset();
      }
      /**
       * Gets or sets a boolean indicating if the particles must be rendered as billboard or aligned with the direction
       */
      get isBillboardBased() {
        return this._isBillboardBased;
      }
      set isBillboardBased(value) {
        if (this._isBillboardBased === value) {
          return;
        }
        this._isBillboardBased = value;
        this._reset();
      }
      /**
       * Gets the image processing configuration used either in this material.
       */
      get imageProcessingConfiguration() {
        return this._imageProcessingConfiguration;
      }
      /**
       * Sets the Default image processing configuration used either in the this material.
       *
       * If sets to null, the scene one is in use.
       */
      set imageProcessingConfiguration(value) {
        this._attachImageProcessingConfiguration(value);
      }
      /**
       * Attaches a new image processing configuration to the Standard Material.
       * @param configuration
       */
      _attachImageProcessingConfiguration(configuration) {
        if (configuration === this._imageProcessingConfiguration) {
          return;
        }
        if (!configuration && this._scene) {
          this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration;
        } else {
          this._imageProcessingConfiguration = configuration;
        }
      }
      /** @internal */
      _reset() {
      }
      /**
       * @internal
       */
      _removeGradientAndTexture(gradient, gradients, texture) {
        if (!gradients) {
          return this;
        }
        let index = 0;
        for (const valueGradient of gradients) {
          if (valueGradient.gradient === gradient) {
            gradients.splice(index, 1);
            break;
          }
          index++;
        }
        if (texture) {
          texture.dispose();
        }
        return this;
      }
      /**
       * Instantiates a particle system.
       * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
       * @param name The name of the particle system
       */
      constructor(name13) {
        this.animations = [];
        this.renderingGroupId = 0;
        this.emitter = Vector3.Zero();
        this.emitRate = 10;
        this.manualEmitCount = -1;
        this.updateSpeed = 0.01;
        this._targetStopDuration = 0;
        this.disposeOnStop = false;
        this.minEmitPower = 1;
        this.maxEmitPower = 1;
        this.minLifeTime = 1;
        this.maxLifeTime = 1;
        this.minSize = 1;
        this.maxSize = 1;
        this.minScaleX = 1;
        this.maxScaleX = 1;
        this.minScaleY = 1;
        this.maxScaleY = 1;
        this.minInitialRotation = 0;
        this.maxInitialRotation = 0;
        this.minAngularSpeed = 0;
        this.maxAngularSpeed = 0;
        this.layerMask = 268435455;
        this.customShader = null;
        this.preventAutoStart = false;
        this.applyFog = false;
        this._wasDispatched = false;
        this._rootUrl = "";
        this.noiseStrength = new Vector3(10, 10, 10);
        this.onAnimationEnd = null;
        this.blendMode = _BaseParticleSystem.BLENDMODE_ONEONE;
        this.forceDepthWrite = false;
        this.preWarmCycles = 0;
        this.preWarmStepOffset = 1;
        this.spriteCellChangeSpeed = 1;
        this.startSpriteCellID = 0;
        this.endSpriteCellID = 0;
        this.spriteCellWidth = 0;
        this.spriteCellHeight = 0;
        this.spriteCellLoop = true;
        this.spriteRandomStartCell = false;
        this.translationPivot = new Vector2(0, 0);
        this._animationSheetEnabled = false;
        this.beginAnimationOnStart = false;
        this.beginAnimationFrom = 0;
        this.beginAnimationTo = 60;
        this.beginAnimationLoop = false;
        this.worldOffset = new Vector3(0, 0, 0);
        this._useLogarithmicDepth = false;
        this.gravity = Vector3.Zero();
        this._colorGradients = null;
        this._sizeGradients = null;
        this._lifeTimeGradients = null;
        this._angularSpeedGradients = null;
        this._velocityGradients = null;
        this._limitVelocityGradients = null;
        this._dragGradients = null;
        this._emitRateGradients = null;
        this._startSizeGradients = null;
        this._rampGradients = null;
        this._colorRemapGradients = null;
        this._alphaRemapGradients = null;
        this.startDelay = 0;
        this.limitVelocityDamping = 0.4;
        this.color1 = new Color4(1, 1, 1, 1);
        this.color2 = new Color4(1, 1, 1, 1);
        this.colorDead = new Color4(0, 0, 0, 1);
        this.textureMask = new Color4(1, 1, 1, 1);
        this._isSubEmitter = false;
        this._billboardMode = 7;
        this._isBillboardBased = true;
        this._imageProcessingConfigurationDefines = new ImageProcessingConfigurationDefines();
        this.id = name13;
        this.name = name13;
      }
      /**
       * Creates a Point Emitter for the particle system (emits directly from the emitter position)
       * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
       * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
       */
      createPointEmitter(direction1, direction2) {
        throw new Error("Method not implemented.");
      }
      /**
       * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)
       * @param radius The radius of the hemisphere to emit from
       * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
       */
      createHemisphericEmitter(radius = 1, radiusRange = 1) {
        throw new Error("Method not implemented.");
      }
      /**
       * Creates a Sphere Emitter for the particle system (emits along the sphere radius)
       * @param radius The radius of the sphere to emit from
       * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
       */
      createSphereEmitter(radius = 1, radiusRange = 1) {
        throw new Error("Method not implemented.");
      }
      /**
       * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)
       * @param radius The radius of the sphere to emit from
       * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere
       * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere
       */
      createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
        throw new Error("Method not implemented.");
      }
      /**
       * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)
       * @param radius The radius of the emission cylinder
       * @param height The height of the emission cylinder
       * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius
       * @param directionRandomizer How much to randomize the particle direction [0-1]
       */
      createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {
        throw new Error("Method not implemented.");
      }
      /**
       * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)
       * @param radius The radius of the cylinder to emit from
       * @param height The height of the emission cylinder
       * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
       * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder
       * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder
       */
      createDirectedCylinderEmitter(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
        throw new Error("Method not implemented.");
      }
      /**
       * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)
       * @param radius The radius of the cone to emit from
       * @param angle The base angle of the cone
       */
      createConeEmitter(radius = 1, angle = Math.PI / 4) {
        throw new Error("Method not implemented.");
      }
      /**
       * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)
       * @param radius The radius of the cone to emit from
       * @param angle The base angle of the cone
       * @param direction1 Particles are emitted between the direction1 and direction2 from within the cone
       * @param direction2 Particles are emitted between the direction1 and direction2 from within the cone
       */
      createDirectedConeEmitter(radius = 1, angle = Math.PI / 4, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
        throw new Error("Method not implemented.");
      }
      /**
       * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)
       * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
       * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
       * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox
       * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox
       */
      createBoxEmitter(direction1, direction2, minEmitBox, maxEmitBox) {
        throw new Error("Method not implemented.");
      }
    };
    BaseParticleSystem.BLENDMODE_ONEONE = 0;
    BaseParticleSystem.BLENDMODE_STANDARD = 1;
    BaseParticleSystem.BLENDMODE_ADD = 2;
    BaseParticleSystem.BLENDMODE_MULTIPLY = 3;
    BaseParticleSystem.BLENDMODE_MULTIPLYADD = 4;
    BaseParticleSystem.BLENDMODE_SUBTRACT = -1;
    RegisterClass("BABYLON.BaseParticleSystem", BaseParticleSystem);
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/colorSplitterBlock.js
var ColorSplitterBlock;
var init_colorSplitterBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/colorSplitterBlock.js"() {
    init_nodeMaterialBlock();
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialBlockTargets();
    init_typeStore();
    ColorSplitterBlock = class extends NodeMaterialBlock {
      /**
       * Create a new ColorSplitterBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13, NodeMaterialBlockTargets.Neutral);
        this.registerInput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, true);
        this.registerInput("rgb ", NodeMaterialBlockConnectionPointTypes.Color3, true);
        this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3);
        this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float);
        this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float);
        this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float);
        this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float);
        this.inputsAreExclusive = true;
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "ColorSplitterBlock";
      }
      /**
       * Gets the rgba component (input)
       */
      get rgba() {
        return this._inputs[0];
      }
      /**
       * Gets the rgb component (input)
       */
      get rgbIn() {
        return this._inputs[1];
      }
      /**
       * Gets the rgb component (output)
       */
      get rgbOut() {
        return this._outputs[0];
      }
      /**
       * Gets the r component (output)
       */
      get r() {
        return this._outputs[1];
      }
      /**
       * Gets the g component (output)
       */
      get g() {
        return this._outputs[2];
      }
      /**
       * Gets the b component (output)
       */
      get b() {
        return this._outputs[3];
      }
      /**
       * Gets the a component (output)
       */
      get a() {
        return this._outputs[4];
      }
      _inputRename(name13) {
        if (name13 === "rgb ") {
          return "rgbIn";
        }
        return name13;
      }
      _outputRename(name13) {
        if (name13 === "rgb") {
          return "rgbOut";
        }
        return name13;
      }
      _buildBlock(state) {
        super._buildBlock(state);
        const input = this.rgba.isConnected ? this.rgba : this.rgbIn;
        if (!input.isConnected) {
          return;
        }
        const rgbOutput = this._outputs[0];
        const rOutput = this._outputs[1];
        const gOutput = this._outputs[2];
        const bOutput = this._outputs[3];
        const aOutput = this._outputs[4];
        if (rgbOutput.hasEndpoints) {
          state.compilationString += state._declareOutput(rgbOutput) + ` = ${input.associatedVariableName}.rgb;
`;
        }
        if (rOutput.hasEndpoints) {
          state.compilationString += state._declareOutput(rOutput) + ` = ${input.associatedVariableName}.r;
`;
        }
        if (gOutput.hasEndpoints) {
          state.compilationString += state._declareOutput(gOutput) + ` = ${input.associatedVariableName}.g;
`;
        }
        if (bOutput.hasEndpoints) {
          state.compilationString += state._declareOutput(bOutput) + ` = ${input.associatedVariableName}.b;
`;
        }
        if (aOutput.hasEndpoints) {
          state.compilationString += state._declareOutput(aOutput) + ` = ${input.associatedVariableName}.a;
`;
        }
        return this;
      }
    };
    RegisterClass("BABYLON.ColorSplitterBlock", ColorSplitterBlock);
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/trigonometryBlock.js
var TrigonometryBlockOperations, TrigonometryBlock;
var init_trigonometryBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/trigonometryBlock.js"() {
    init_tslib_es6();
    init_nodeMaterialBlock();
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialBlockTargets();
    init_typeStore();
    init_nodeDecorator();
    (function(TrigonometryBlockOperations2) {
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["Cos"] = 0] = "Cos";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sin"] = 1] = "Sin";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["Abs"] = 2] = "Abs";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["Exp"] = 3] = "Exp";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["Exp2"] = 4] = "Exp2";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["Round"] = 5] = "Round";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["Floor"] = 6] = "Floor";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["Ceiling"] = 7] = "Ceiling";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sqrt"] = 8] = "Sqrt";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["Log"] = 9] = "Log";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["Tan"] = 10] = "Tan";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcTan"] = 11] = "ArcTan";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcCos"] = 12] = "ArcCos";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["ArcSin"] = 13] = "ArcSin";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["Fract"] = 14] = "Fract";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["Sign"] = 15] = "Sign";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["Radians"] = 16] = "Radians";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["Degrees"] = 17] = "Degrees";
      TrigonometryBlockOperations2[TrigonometryBlockOperations2["Set"] = 18] = "Set";
    })(TrigonometryBlockOperations || (TrigonometryBlockOperations = {}));
    TrigonometryBlock = class extends NodeMaterialBlock {
      /**
       * Creates a new TrigonometryBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13, NodeMaterialBlockTargets.Neutral);
        this.operation = TrigonometryBlockOperations.Cos;
        this.registerInput("input", NodeMaterialBlockConnectionPointTypes.AutoDetect);
        this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.BasedOnInput);
        this._outputs[0]._typeConnectionSource = this._inputs[0];
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "TrigonometryBlock";
      }
      /**
       * Gets the input component
       */
      get input() {
        return this._inputs[0];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      _buildBlock(state) {
        super._buildBlock(state);
        const output = this._outputs[0];
        let operation = "";
        switch (this.operation) {
          case TrigonometryBlockOperations.Cos: {
            operation = "cos";
            break;
          }
          case TrigonometryBlockOperations.Sin: {
            operation = "sin";
            break;
          }
          case TrigonometryBlockOperations.Abs: {
            operation = "abs";
            break;
          }
          case TrigonometryBlockOperations.Exp: {
            operation = "exp";
            break;
          }
          case TrigonometryBlockOperations.Exp2: {
            operation = "exp2";
            break;
          }
          case TrigonometryBlockOperations.Round: {
            operation = "round";
            break;
          }
          case TrigonometryBlockOperations.Floor: {
            operation = "floor";
            break;
          }
          case TrigonometryBlockOperations.Ceiling: {
            operation = "ceil";
            break;
          }
          case TrigonometryBlockOperations.Sqrt: {
            operation = "sqrt";
            break;
          }
          case TrigonometryBlockOperations.Log: {
            operation = "log";
            break;
          }
          case TrigonometryBlockOperations.Tan: {
            operation = "tan";
            break;
          }
          case TrigonometryBlockOperations.ArcTan: {
            operation = "atan";
            break;
          }
          case TrigonometryBlockOperations.ArcCos: {
            operation = "acos";
            break;
          }
          case TrigonometryBlockOperations.ArcSin: {
            operation = "asin";
            break;
          }
          case TrigonometryBlockOperations.Fract: {
            operation = "fract";
            break;
          }
          case TrigonometryBlockOperations.Sign: {
            operation = "sign";
            break;
          }
          case TrigonometryBlockOperations.Radians: {
            operation = "radians";
            break;
          }
          case TrigonometryBlockOperations.Degrees: {
            operation = "degrees";
            break;
          }
          case TrigonometryBlockOperations.Set: {
            operation = "";
            break;
          }
        }
        state.compilationString += state._declareOutput(output) + ` = ${operation}(${this.input.associatedVariableName});
`;
        return this;
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.operation = this.operation;
        return serializationObject;
      }
      _deserialize(serializationObject, scene, rootUrl) {
        super._deserialize(serializationObject, scene, rootUrl);
        this.operation = serializationObject.operation;
      }
      _dumpPropertiesCode() {
        const codeString = super._dumpPropertiesCode() + `${this._codeVariableName}.operation = BABYLON.TrigonometryBlockOperations.${TrigonometryBlockOperations[this.operation]};
`;
        return codeString;
      }
    };
    __decorate([
      editableInPropertyPage("Operation", 5, "ADVANCED", {
        notifiers: { rebuild: true },
        embedded: true,
        options: [
          { label: "Cos", value: TrigonometryBlockOperations.Cos },
          { label: "Sin", value: TrigonometryBlockOperations.Sin },
          { label: "Abs", value: TrigonometryBlockOperations.Abs },
          { label: "Exp", value: TrigonometryBlockOperations.Exp },
          { label: "Exp2", value: TrigonometryBlockOperations.Exp2 },
          { label: "Round", value: TrigonometryBlockOperations.Round },
          { label: "Floor", value: TrigonometryBlockOperations.Floor },
          { label: "Ceiling", value: TrigonometryBlockOperations.Ceiling },
          { label: "Sqrt", value: TrigonometryBlockOperations.Sqrt },
          { label: "Log", value: TrigonometryBlockOperations.Log },
          { label: "Tan", value: TrigonometryBlockOperations.Tan },
          { label: "ArcTan", value: TrigonometryBlockOperations.ArcTan },
          { label: "ArcCos", value: TrigonometryBlockOperations.ArcCos },
          { label: "ArcSin", value: TrigonometryBlockOperations.ArcSin },
          { label: "Fract", value: TrigonometryBlockOperations.Fract },
          { label: "Sign", value: TrigonometryBlockOperations.Sign },
          { label: "Radians", value: TrigonometryBlockOperations.Radians },
          { label: "Degrees", value: TrigonometryBlockOperations.Degrees },
          { label: "Set", value: TrigonometryBlockOperations.Set }
        ]
      })
    ], TrigonometryBlock.prototype, "operation", void 0);
    RegisterClass("BABYLON.TrigonometryBlock", TrigonometryBlock);
  }
});

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBuildState.js
var NodeMaterialBuildState;
var init_nodeMaterialBuildState = __esm({
  "node_modules/@babylonjs/core/Materials/Node/nodeMaterialBuildState.js"() {
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialBlockTargets();
    init_shaderStore();
    init_shaderProcessor();
    init_webGLShaderProcessors();
    init_logger();
    NodeMaterialBuildState = class {
      constructor() {
        this.supportUniformBuffers = false;
        this.attributes = [];
        this.uniforms = [];
        this.constants = [];
        this.samplers = [];
        this.functions = {};
        this.extensions = {};
        this.prePassOutput = {};
        this.counters = {};
        this._terminalBlocks = /* @__PURE__ */ new Set();
        this._attributeDeclaration = "";
        this._uniformDeclaration = "";
        this._constantDeclaration = "";
        this._samplerDeclaration = "";
        this._varyingTransfer = "";
        this._injectAtEnd = "";
        this._injectAtTop = "";
        this._customEntryHeader = "";
        this._repeatableContentAnchorIndex = 0;
        this._builtCompilationString = "";
        this.compilationString = "";
      }
      /**
       * Gets the current shader language to use
       */
      get shaderLanguage() {
        return this.sharedData.nodeMaterial.shaderLanguage;
      }
      /** Gets suffix to add behind type casting */
      get fSuffix() {
        return this.shaderLanguage === 1 ? "f" : "";
      }
      /**
       * Returns the processed, compiled shader code
       * @param defines defines to use for the shader processing
       * @returns the raw shader code used by the engine
       */
      async getProcessedShaderAsync(defines) {
        if (!this._builtCompilationString) {
          Logger.Error("getProcessedShaderAsync: Shader not built yet.");
          return "";
        }
        const engine = this.sharedData.nodeMaterial.getScene().getEngine();
        const options = {
          defines: defines.split("\n"),
          indexParameters: void 0,
          isFragment: this.target === NodeMaterialBlockTargets.Fragment,
          shouldUseHighPrecisionShader: engine._shouldUseHighPrecisionShader,
          processor: engine._getShaderProcessor(this.shaderLanguage),
          supportsUniformBuffers: engine.supportsUniformBuffers,
          shadersRepository: ShaderStore.GetShadersRepository(this.shaderLanguage),
          includesShadersStore: ShaderStore.GetIncludesShadersStore(this.shaderLanguage),
          version: (engine.version * 100).toString(),
          platformName: engine.shaderPlatformName,
          processingContext: null,
          isNDCHalfZRange: engine.isNDCHalfZRange,
          useReverseDepthBuffer: engine.useReverseDepthBuffer
        };
        if (!engine.isWebGPU && engine.version > 1) {
          options.processor = new WebGLShaderProcessor();
        }
        return await new Promise((resolve) => {
          Process(this._builtCompilationString, options, (migratedCode, _) => {
            resolve(migratedCode);
          }, engine);
        });
      }
      /**
       * Finalize the compilation strings
       * @param state defines the current compilation state
       */
      finalize(state) {
        const emitComments = state.sharedData.emitComments;
        const isFragmentMode = this.target === NodeMaterialBlockTargets.Fragment;
        let entryPointString = `
${emitComments ? "//Entry point\n" : ""}`;
        if (this._customEntryHeader) {
          entryPointString += this._customEntryHeader;
        } else if (this.shaderLanguage === 1) {
          if (isFragmentMode) {
            entryPointString += `@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
${this.sharedData.varyingInitializationsFragment}`;
          } else {
            entryPointString += `@vertex
fn main(input: VertexInputs) -> FragmentInputs{
`;
          }
        } else {
          entryPointString += `void main(void) {
`;
        }
        this.compilationString = entryPointString + this.compilationString;
        if (this._constantDeclaration) {
          this.compilationString = `
${emitComments ? "//Constants\n" : ""}${this._constantDeclaration}
${this.compilationString}`;
        }
        let functionCode = "";
        for (const functionName in this.functions) {
          functionCode += this.functions[functionName] + `
`;
        }
        this.compilationString = `
${functionCode}
${this.compilationString}`;
        if (!isFragmentMode && this._varyingTransfer) {
          this.compilationString = `${this.compilationString}
${this._varyingTransfer}`;
        }
        if (this._injectAtEnd) {
          this.compilationString = `${this.compilationString}
${this._injectAtEnd}`;
        }
        this.compilationString = `${this.compilationString}
}`;
        if (this.sharedData.varyingDeclaration) {
          this.compilationString = `
${emitComments ? "//Varyings\n" : ""}${isFragmentMode ? this.sharedData.varyingDeclarationFragment : this.sharedData.varyingDeclaration}
${this.compilationString}`;
        }
        if (this._samplerDeclaration) {
          this.compilationString = `
${emitComments ? "//Samplers\n" : ""}${this._samplerDeclaration}
${this.compilationString}`;
        }
        if (this._uniformDeclaration) {
          this.compilationString = `
${emitComments ? "//Uniforms\n" : ""}${this._uniformDeclaration}
${this.compilationString}`;
        }
        if (this._attributeDeclaration && !isFragmentMode) {
          this.compilationString = `
${emitComments ? "//Attributes\n" : ""}${this._attributeDeclaration}
${this.compilationString}`;
        }
        if (this.shaderLanguage !== 1) {
          this.compilationString = "precision highp float;\n" + this.compilationString;
          this.compilationString = "#if defined(WEBGL2) || defined(WEBGPU)\nprecision highp sampler2DArray;\n#endif\n" + this.compilationString;
          if (isFragmentMode) {
            this.compilationString = "#if defined(PREPASS)\r\n#extension GL_EXT_draw_buffers : require\r\nlayout(location = 0) out highp vec4 glFragData[SCENE_MRT_COUNT];\r\nhighp vec4 gl_FragColor;\r\n#endif\r\n" + this.compilationString;
          }
          for (const extensionName in this.extensions) {
            const extension = this.extensions[extensionName];
            this.compilationString = `
${extension}
${this.compilationString}`;
          }
        }
        if (this._injectAtTop) {
          this.compilationString = `${this._injectAtTop}
${this.compilationString}`;
        }
        this._builtCompilationString = this.compilationString;
      }
      /** @internal */
      get _repeatableContentAnchor() {
        return `###___ANCHOR${this._repeatableContentAnchorIndex++}___###`;
      }
      /**
       * @internal
       */
      _getFreeVariableName(prefix) {
        prefix = this.sharedData.formatConfig.formatVariablename(prefix);
        if (this.sharedData.variableNames[prefix] === void 0) {
          this.sharedData.variableNames[prefix] = 0;
          if (prefix === "output" || prefix === "texture") {
            return prefix + this.sharedData.variableNames[prefix];
          }
          return prefix;
        } else {
          this.sharedData.variableNames[prefix]++;
        }
        return prefix + this.sharedData.variableNames[prefix];
      }
      /**
       * @internal
       */
      _getFreeDefineName(prefix) {
        if (this.sharedData.defineNames[prefix] === void 0) {
          this.sharedData.defineNames[prefix] = 0;
        } else {
          this.sharedData.defineNames[prefix]++;
        }
        return prefix + this.sharedData.defineNames[prefix];
      }
      /**
       * @internal
       */
      _excludeVariableName(name13) {
        this.sharedData.variableNames[name13] = 0;
      }
      /**
       * @internal
       */
      _emit2DSampler(name13, define = "", force = false, annotation, unsignedSampler, precision) {
        if (this.samplers.indexOf(name13) < 0 || force) {
          if (define) {
            this._samplerDeclaration += `#if ${define}
`;
          }
          if (this.shaderLanguage === 1) {
            const unsignedSamplerPrefix = unsignedSampler ? "u" : "f";
            this._samplerDeclaration += `var ${name13 + `Sampler`}: sampler;
`;
            this._samplerDeclaration += `var ${name13}: texture_2d<${unsignedSamplerPrefix}32>;
`;
          } else {
            const unsignedSamplerPrefix = unsignedSampler ? "u" : "";
            const precisionDecl = precision ?? "";
            this._samplerDeclaration += `uniform ${precisionDecl} ${unsignedSamplerPrefix}sampler2D ${name13}; ${annotation ? annotation : ""}
`;
          }
          if (define) {
            this._samplerDeclaration += `#endif
`;
          }
          if (!force) {
            this.samplers.push(name13);
          }
        }
      }
      /**
       * @internal
       */
      _emitCubeSampler(name13, define = "", force = false) {
        if (this.samplers.indexOf(name13) < 0 || force) {
          if (define) {
            this._samplerDeclaration += `#if ${define}
`;
          }
          if (this.shaderLanguage === 1) {
            this._samplerDeclaration += `var ${name13 + `Sampler`}: sampler;
`;
            this._samplerDeclaration += `var ${name13}: texture_cube<f32>;
`;
          } else {
            this._samplerDeclaration += `uniform samplerCube ${name13};
`;
          }
          if (define) {
            this._samplerDeclaration += `#endif
`;
          }
          if (!force) {
            this.samplers.push(name13);
          }
        }
      }
      /**
       * @internal
       */
      _emit2DArraySampler(name13) {
        if (this.samplers.indexOf(name13) < 0) {
          if (this.shaderLanguage === 1) {
            this._samplerDeclaration += `var ${name13 + `Sampler`}: sampler;
`;
            this._samplerDeclaration += `var ${name13}: texture_2d_array<f32>;
`;
          } else {
            this._samplerDeclaration += `uniform sampler2DArray ${name13};
`;
          }
          this.samplers.push(name13);
        }
      }
      /**
       * @internal
       */
      _getGLType(type) {
        switch (type) {
          case NodeMaterialBlockConnectionPointTypes.Float:
            return "float";
          case NodeMaterialBlockConnectionPointTypes.Int:
            return "int";
          case NodeMaterialBlockConnectionPointTypes.Vector2:
            return "vec2";
          case NodeMaterialBlockConnectionPointTypes.Color3:
          case NodeMaterialBlockConnectionPointTypes.Vector3:
            return "vec3";
          case NodeMaterialBlockConnectionPointTypes.Color4:
          case NodeMaterialBlockConnectionPointTypes.Vector4:
            return "vec4";
          case NodeMaterialBlockConnectionPointTypes.Matrix:
            return "mat4";
        }
        return "";
      }
      /**
       * @internal
       */
      _getShaderType(type) {
        const isWGSL = this.shaderLanguage === 1;
        switch (type) {
          case NodeMaterialBlockConnectionPointTypes.Float:
            return isWGSL ? "f32" : "float";
          case NodeMaterialBlockConnectionPointTypes.Int:
            return isWGSL ? "i32" : "int";
          case NodeMaterialBlockConnectionPointTypes.Vector2:
            return isWGSL ? "vec2f" : "vec2";
          case NodeMaterialBlockConnectionPointTypes.Color3:
          case NodeMaterialBlockConnectionPointTypes.Vector3:
            return isWGSL ? "vec3f" : "vec3";
          case NodeMaterialBlockConnectionPointTypes.Color4:
          case NodeMaterialBlockConnectionPointTypes.Vector4:
            return isWGSL ? "vec4f" : "vec4";
          case NodeMaterialBlockConnectionPointTypes.Matrix:
            return isWGSL ? "mat4x4f" : "mat4";
        }
        return "";
      }
      /**
       * @internal
       */
      _emitExtension(name13, extension, define = "") {
        if (this.extensions[name13]) {
          return;
        }
        if (define) {
          extension = `#if ${define}
${extension}
#endif`;
        }
        this.extensions[name13] = extension;
      }
      /**
       * @internal
       */
      _emitFunction(name13, code, comments) {
        if (this.functions[name13]) {
          return;
        }
        if (this.sharedData.emitComments) {
          code = comments + `
` + code;
        }
        this.functions[name13] = code;
      }
      /**
       * @internal
       */
      _emitCodeFromInclude(includeName, comments, options) {
        const store = ShaderStore.GetIncludesShadersStore(this.shaderLanguage);
        if (options && options.repeatKey) {
          return `#include<${includeName}>${options.substitutionVars ? "(" + options.substitutionVars + ")" : ""}[0..${options.repeatKey}]
`;
        }
        let code = store[includeName] + "\n";
        if (this.sharedData.emitComments) {
          code = comments + `
` + code;
        }
        if (!options) {
          return code;
        }
        if (options.replaceStrings) {
          for (let index = 0; index < options.replaceStrings.length; index++) {
            const replaceString = options.replaceStrings[index];
            code = code.replace(replaceString.search, replaceString.replace);
          }
        }
        return code;
      }
      /**
       * @internal
       */
      _emitFunctionFromInclude(includeName, comments, options, storeKey = "") {
        const key = includeName + storeKey;
        if (this.functions[key]) {
          return;
        }
        const store = ShaderStore.GetIncludesShadersStore(this.shaderLanguage);
        if (!options || !options.removeAttributes && !options.removeUniforms && !options.removeVaryings && !options.removeIfDef && !options.replaceStrings) {
          if (options && options.repeatKey) {
            this.functions[key] = `#include<${includeName}>${options.substitutionVars ? "(" + options.substitutionVars + ")" : ""}[0..${options.repeatKey}]
`;
          } else {
            this.functions[key] = `#include<${includeName}>${options?.substitutionVars ? "(" + options?.substitutionVars + ")" : ""}
`;
          }
          if (this.sharedData.emitComments) {
            this.functions[key] = comments + `
` + this.functions[key];
          }
          return;
        }
        this.functions[key] = store[includeName];
        if (this.sharedData.emitComments) {
          this.functions[key] = comments + `
` + this.functions[key];
        }
        if (options.removeIfDef) {
          this.functions[key] = this.functions[key].replace(/^\s*?#ifdef.+$/gm, "");
          this.functions[key] = this.functions[key].replace(/^\s*?#endif.*$/gm, "");
          this.functions[key] = this.functions[key].replace(/^\s*?#else.*$/gm, "");
          this.functions[key] = this.functions[key].replace(/^\s*?#elif.*$/gm, "");
        }
        if (options.removeAttributes) {
          this.functions[key] = this.functions[key].replace(/\s*?attribute .+?;/g, "\n");
        }
        if (options.removeUniforms) {
          this.functions[key] = this.functions[key].replace(/\s*?uniform .*?;/g, "\n");
        }
        if (options.removeVaryings) {
          this.functions[key] = this.functions[key].replace(/\s*?(varying|in) .+?;/g, "\n");
        }
        if (options.replaceStrings) {
          for (let index = 0; index < options.replaceStrings.length; index++) {
            const replaceString = options.replaceStrings[index];
            this.functions[key] = this.functions[key].replace(replaceString.search, replaceString.replace);
          }
        }
      }
      /**
       * @internal
       */
      _registerTempVariable(name13) {
        if (this.sharedData.temps.indexOf(name13) !== -1) {
          return false;
        }
        this.sharedData.temps.push(name13);
        return true;
      }
      _emitDefineStart(define, notDefine = false) {
        let code = "";
        if (define) {
          if (define.startsWith("defined(")) {
            code = `#if ${define}
`;
          } else {
            code = `${notDefine ? "#ifndef" : "#ifdef"} ${define}
`;
          }
        }
        return code;
      }
      _emitDefineEnd(define) {
        return define ? `#endif
` : "";
      }
      /**
       * @internal
       */
      _emitVaryingFromString(name13, type, define = "", notDefine = false) {
        if (this.sharedData.varyings.indexOf(name13) !== -1) {
          return false;
        }
        this.sharedData.varyings.push(name13);
        const shaderType = this._getShaderType(type);
        const emitCode = (forFragment = false) => {
          let code = this._emitDefineStart(define, notDefine);
          if (this.shaderLanguage === 1) {
            switch (shaderType) {
              case "i32":
              case "f32":
              case "vec2f":
              case "vec3f":
              case "vec4f":
                code += `varying ${name13}: ${shaderType};
`;
                if (forFragment) {
                  code += `var<private> ${name13}: ${shaderType};
`;
                  this.sharedData.varyingInitializationsFragment += this._emitDefineStart(define, notDefine) + `${name13} = fragmentInputs.${name13};
` + this._emitDefineEnd(define);
                }
                break;
              case "mat4x4f":
                code += `varying ${name13}_r0: vec4f;
`;
                code += `varying ${name13}_r1: vec4f;
`;
                code += `varying ${name13}_r2: vec4f;
`;
                code += `varying ${name13}_r3: vec4f;
`;
                if (forFragment) {
                  code += `var<private> ${name13}: mat4x4f;
`;
                  this.sharedData.varyingInitializationsFragment += this._emitDefineStart(define, notDefine) + `${name13} = mat4x4f(fragmentInputs.${name13}_r0, fragmentInputs.${name13}_r1, fragmentInputs.${name13}_r2, fragmentInputs.${name13}_r3);
` + this._emitDefineEnd(define);
                }
                break;
              default:
                code += `varying ${name13}: ${shaderType};
`;
                break;
            }
          } else {
            code += `varying ${shaderType} ${name13};
`;
          }
          code += this._emitDefineEnd(define);
          return code;
        };
        if (this.shaderLanguage === 1) {
          this.sharedData.varyingDeclaration += emitCode(false);
          this.sharedData.varyingDeclarationFragment += emitCode(true);
        } else {
          const code = emitCode();
          this.sharedData.varyingDeclaration += code;
          this.sharedData.varyingDeclarationFragment += code;
        }
        return true;
      }
      /**
       * @internal
       */
      _getVaryingName(name13) {
        if (this.shaderLanguage === 1) {
          return (this.target !== NodeMaterialBlockTargets.Fragment ? "vertexOutputs." : "fragmentInputs.") + name13;
        }
        return name13;
      }
      /**
       * @internal
       */
      _emitUniformFromString(name13, type, define = "", notDefine = false) {
        if (this.uniforms.indexOf(name13) !== -1) {
          return;
        }
        this.uniforms.push(name13);
        if (define) {
          if (define.startsWith("defined(")) {
            this._uniformDeclaration += `#if ${define}
`;
          } else {
            this._uniformDeclaration += `${notDefine ? "#ifndef" : "#ifdef"} ${define}
`;
          }
        }
        if (this.sharedData.formatConfig.getUniformAnnotation) {
          this._uniformDeclaration += this.sharedData.formatConfig.getUniformAnnotation(name13);
        }
        const shaderType = this._getShaderType(type);
        if (this.shaderLanguage === 1) {
          this._uniformDeclaration += `uniform ${name13}: ${shaderType};
`;
        } else {
          this._uniformDeclaration += `uniform ${shaderType} ${name13};
`;
        }
        if (define) {
          this._uniformDeclaration += `#endif
`;
        }
      }
      /**
       * @internal
       */
      _generateTernary(trueStatement, falseStatement, condition) {
        if (this.shaderLanguage === 1) {
          return `select(${falseStatement}, ${trueStatement}, ${condition})`;
        }
        return `(${condition}) ? ${trueStatement} : ${falseStatement}`;
      }
      /**
       * @internal
       */
      _emitFloat(value) {
        if (value.toString() === value.toFixed(0)) {
          return `${value}.0`;
        }
        return value.toString();
      }
      /**
       * @internal
       */
      _declareOutput(output, isConst) {
        return this._declareLocalVar(output.associatedVariableName, output.type, isConst);
      }
      /**
       * @internal
       */
      _declareLocalVar(name13, type, isConst, isVarPrivate) {
        if (this.shaderLanguage === 1) {
          return `${isConst ? "const" : "var" + (isVarPrivate ? "<private>" : "")} ${name13}: ${this._getShaderType(type)}`;
        } else {
          return `${isConst ? "const " : ""}${this._getShaderType(type)} ${name13}`;
        }
      }
      /**
       * @internal
       */
      _samplerCubeFunc() {
        if (this.shaderLanguage === 1) {
          return "textureSample";
        }
        return "textureCube";
      }
      /**
       * @internal
       */
      _samplerFunc() {
        if (this.shaderLanguage === 1) {
          return "textureSample";
        }
        return "texture2D";
      }
      /**
       * @internal
       */
      _samplerLODFunc() {
        if (this.shaderLanguage === 1) {
          return "textureSampleLevel";
        }
        return "texture2DLodEXT";
      }
      _toLinearSpace(output) {
        if (this.shaderLanguage === 1) {
          if (output.type === NodeMaterialBlockConnectionPointTypes.Color3 || output.type === NodeMaterialBlockConnectionPointTypes.Vector3) {
            return `toLinearSpaceVec3(${output.associatedVariableName})`;
          }
          return `toLinearSpace(${output.associatedVariableName})`;
        }
        return `toLinearSpace(${output.associatedVariableName})`;
      }
      /**
       * @internal
       */
      _generateTextureSample(uv, samplerName) {
        if (this.shaderLanguage === 1) {
          return `${this._samplerFunc()}(${samplerName},${samplerName + `Sampler`}, ${uv})`;
        }
        return `${this._samplerFunc()}(${samplerName}, ${uv})`;
      }
      /**
       * @internal
       */
      _generateTextureSampleLOD(uv, samplerName, lod) {
        if (this.shaderLanguage === 1) {
          return `${this._samplerLODFunc()}(${samplerName},${samplerName + `Sampler`}, ${uv}, ${lod})`;
        }
        return `${this._samplerLODFunc()}(${samplerName}, ${uv}, ${lod})`;
      }
      /**
       * @internal
       */
      _generateTextureSampleCube(uv, samplerName) {
        if (this.shaderLanguage === 1) {
          return `${this._samplerCubeFunc()}(${samplerName},${samplerName + `Sampler`}, ${uv})`;
        }
        return `${this._samplerCubeFunc()}(${samplerName}, ${uv})`;
      }
      /**
       * @internal
       */
      _generateTextureSampleCubeLOD(uv, samplerName, lod) {
        if (this.shaderLanguage === 1) {
          return `${this._samplerCubeFunc()}(${samplerName},${samplerName + `Sampler`}, ${uv}, ${lod})`;
        }
        return `${this._samplerCubeFunc()}(${samplerName}, ${uv}, ${lod})`;
      }
      _convertVariableDeclarationToWGSL(type, dest, source) {
        return source.replace(new RegExp(`(${type})\\s+(\\w+)`, "g"), `var $2: ${dest}`);
      }
      _convertVariableConstructorsToWGSL(type, dest, source) {
        return source.replace(new RegExp(`(${type})\\(`, "g"), ` ${dest}(`);
      }
      _convertOutParametersToWGSL(source) {
        return source.replace(new RegExp(`out\\s+var\\s+(\\w+)\\s*:\\s*(\\w+)`, "g"), `$1: ptr<function, $2>`);
      }
      _convertTernaryOperandsToWGSL(source) {
        return source.replace(new RegExp(`\\[(.*?)\\?(.*?):(.*)\\]`, "g"), (match, condition, trueCase, falseCase) => `select(${falseCase}, ${trueCase}, ${condition})`);
      }
      _convertModOperatorsToWGSL(source) {
        return source.replace(new RegExp(`mod\\((.+?),\\s*(.+?)\\)`, "g"), (match, left, right) => `((${left})%(${right}))`);
      }
      _convertConstToWGSL(source) {
        return source.replace(new RegExp(`const var`, "g"), `const`);
      }
      _convertInnerFunctionsToWGSL(source) {
        return source.replace(new RegExp(`inversesqrt`, "g"), `inverseSqrt`);
      }
      _convertFunctionsToWGSL(source) {
        const regex = /var\s+(\w+)\s*:\s*(\w+)\((.*)\)/g;
        let match;
        while ((match = regex.exec(source)) !== null) {
          const funcName = match[1];
          const funcType = match[2];
          const params = match[3];
          const formattedParams = params.replace(/var\s/g, "");
          source = source.replace(match[0], `fn ${funcName}(${formattedParams}) -> ${funcType}`);
        }
        return source;
      }
      _babylonSLtoWGSL(code) {
        code = this._convertVariableDeclarationToWGSL("void", "voidnull", code);
        code = this._convertVariableDeclarationToWGSL("bool", "bool", code);
        code = this._convertVariableDeclarationToWGSL("int", "i32", code);
        code = this._convertVariableDeclarationToWGSL("uint", "u32", code);
        code = this._convertVariableDeclarationToWGSL("float", "f32", code);
        code = this._convertVariableDeclarationToWGSL("vec2", "vec2f", code);
        code = this._convertVariableDeclarationToWGSL("vec3", "vec3f", code);
        code = this._convertVariableDeclarationToWGSL("vec4", "vec4f", code);
        code = this._convertVariableDeclarationToWGSL("mat2", "mat2x2f", code);
        code = this._convertVariableDeclarationToWGSL("mat3", "mat3x3f", code);
        code = this._convertVariableDeclarationToWGSL("mat4", "mat4x4f", code);
        code = this._convertVariableConstructorsToWGSL("float", "f32", code);
        code = this._convertVariableConstructorsToWGSL("vec2", "vec2f", code);
        code = this._convertVariableConstructorsToWGSL("vec3", "vec3f", code);
        code = this._convertVariableConstructorsToWGSL("vec4", "vec4f", code);
        code = this._convertVariableConstructorsToWGSL("mat2", "mat2x2f", code);
        code = this._convertVariableConstructorsToWGSL("mat3", "mat3x3f", code);
        code = this._convertVariableConstructorsToWGSL("mat4", "mat4x4f", code);
        code = this._convertTernaryOperandsToWGSL(code);
        code = this._convertModOperatorsToWGSL(code);
        code = this._convertConstToWGSL(code);
        code = this._convertInnerFunctionsToWGSL(code);
        code = this._convertOutParametersToWGSL(code);
        code = code.replace(/\[\*\]/g, "*");
        code = this._convertFunctionsToWGSL(code);
        code = code.replace(/\s->\svoidnull/g, "");
        code = code.replace(/dFdx/g, "dpdx");
        code = code.replace(/dFdy/g, "dpdy");
        return code;
      }
      _convertTernaryOperandsToGLSL(source) {
        return source.replace(new RegExp(`\\[(.+?)\\?(.+?):(.+)\\]`, "g"), (match, condition, trueCase, falseCase) => `${condition} ? ${trueCase} : ${falseCase}`);
      }
      _babylonSLtoGLSL(code) {
        code = code.replace(/\[\*\]/g, "");
        code = this._convertTernaryOperandsToGLSL(code);
        return code;
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/Node/nodeMaterialBuildStateSharedData.js
var NodeMaterialBuildStateSharedData;
var init_nodeMaterialBuildStateSharedData = __esm({
  "node_modules/@babylonjs/core/Materials/Node/nodeMaterialBuildStateSharedData.js"() {
    init_logger();
    NodeMaterialBuildStateSharedData = class {
      /** Creates a new shared data */
      constructor() {
        this.temps = [];
        this.varyings = [];
        this.varyingDeclaration = "";
        this.varyingDeclarationFragment = "";
        this.varyingInitializationsFragment = "";
        this.inputBlocks = [];
        this.textureBlocks = [];
        this.bindableBlocks = [];
        this.forcedBindableBlocks = [];
        this.blocksWithFallbacks = [];
        this.blocksWithDefines = [];
        this.repeatableContentBlocks = [];
        this.dynamicUniformBlocks = [];
        this.blockingBlocks = [];
        this.animatedInputs = [];
        this.defines = {};
        this.formatConfig = {
          getUniformAnnotation: null,
          formatVariablename: (name13) => name13.replace(/[^a-zA-Z_]+/g, "")
        };
        this.variableNames = {};
        this.defineNames = {};
        this.hints = {
          needWorldViewMatrix: false,
          needWorldViewProjectionMatrix: false,
          needAlphaBlending: false,
          needAlphaTesting: false
        };
        this.checks = {
          emitVertex: false,
          emitFragment: false,
          notConnectedNonOptionalInputs: new Array(),
          customErrors: new Array()
        };
        this.allowEmptyVertexProgram = false;
        this.variableNames["position"] = 0;
        this.variableNames["normal"] = 0;
        this.variableNames["tangent"] = 0;
        this.variableNames["uv"] = 0;
        this.variableNames["uv2"] = 0;
        this.variableNames["uv3"] = 0;
        this.variableNames["uv4"] = 0;
        this.variableNames["uv5"] = 0;
        this.variableNames["uv6"] = 0;
        this.variableNames["color"] = 0;
        this.variableNames["matricesIndices"] = 0;
        this.variableNames["matricesWeights"] = 0;
        this.variableNames["matricesIndicesExtra"] = 0;
        this.variableNames["matricesWeightsExtra"] = 0;
        this.variableNames["diffuseBase"] = 0;
        this.variableNames["specularBase"] = 0;
        this.variableNames["worldPos"] = 0;
        this.variableNames["shadow"] = 0;
        this.variableNames["view"] = 0;
        this.variableNames["vTBN"] = 0;
        this.defineNames["MAINUV0"] = 0;
        this.defineNames["MAINUV1"] = 0;
        this.defineNames["MAINUV2"] = 0;
        this.defineNames["MAINUV3"] = 0;
        this.defineNames["MAINUV4"] = 0;
        this.defineNames["MAINUV5"] = 0;
        this.defineNames["MAINUV6"] = 0;
        this.defineNames["MAINUV7"] = 0;
      }
      /**
       * Push a new error to the build state, avoiding exceptions that can break the build process
       * @param message defines the error message to push
       */
      raiseBuildError(message) {
        if (this.checks.customErrors.indexOf(message) !== -1) {
          this.checks.customErrors.push(message);
        }
      }
      /**
       * Emits console errors and exceptions if there is a failing check
       * @returns true if all checks pass
       */
      emitErrors() {
        let errorMessage = "";
        if (!this.checks.emitVertex && !this.allowEmptyVertexProgram) {
          errorMessage += "NodeMaterial does not have a vertex output. You need to at least add a block that generates a position value.\n";
        }
        if (!this.checks.emitFragment) {
          errorMessage += "NodeMaterial does not have a fragment output. You need to at least add a block that generates a color value.\n";
        }
        for (const notConnectedInput of this.checks.notConnectedNonOptionalInputs) {
          errorMessage += `input ${notConnectedInput.name} from block ${notConnectedInput.ownerBlock.name}[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.
`;
        }
        for (const customError of this.checks.customErrors) {
          errorMessage += customError + "\n";
        }
        if (errorMessage) {
          errorMessage = "Node material build failed: \n" + errorMessage;
          Logger.Error(errorMessage);
          this.nodeMaterial.onBuildErrorObservable.notifyObservers(errorMessage);
          return false;
        }
        return true;
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/Node/nodeMaterial.js
var onCreatedEffectParameters, NodeMaterialDefinesBase, NodeMaterialDefines, NodeMaterialBase, NodeMaterial;
var init_nodeMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/Node/nodeMaterial.js"() {
    init_tslib_es6();
    init_pushMaterial();
    init_math_vector();
    init_math_color();
    init_nodeMaterialBuildState();
    init_effect();
    init_observable();
    init_nodeMaterialBlockTargets();
    init_nodeMaterialBuildStateSharedData();
    init_materialDefines();
    init_buffer();
    init_tools();
    init_smartFilterFragmentOutputBlock();
    init_transformBlock();
    init_vertexOutputBlock();
    init_fragmentOutputBlock();
    init_inputBlock();
    init_typeStore();
    init_decorators();
    init_decorators_serialization();
    init_currentScreenBlock();
    init_particleTextureBlock();
    init_particleRampGradientBlock();
    init_particleBlendMultiplyBlock();
    init_effectFallbacks();
    init_webRequest();
    init_postProcess();
    init_vectorMergerBlock();
    init_remapBlock();
    init_multiplyBlock();
    init_nodeMaterialModes();
    init_texture();
    init_baseParticleSystem();
    init_colorSplitterBlock();
    init_timingTools();
    init_proceduralTexture();
    init_animatedInputBlockTypes();
    init_trigonometryBlock();
    init_nodeMaterialSystemValues();
    init_engineStore();
    init_material();
    init_logger();
    init_materialHelper_functions();
    init_imageProcessingConfiguration_defines();
    init_abstractEngine();
    init_materialHelper_geometryrendering();
    init_uv_defines();
    init_imageProcessing();
    onCreatedEffectParameters = { effect: null, subMesh: null };
    NodeMaterialDefinesBase = class extends UVDefinesMixin(MaterialDefines) {
    };
    NodeMaterialDefines = class extends ImageProcessingDefinesMixin(NodeMaterialDefinesBase) {
      /**
       * Creates a new NodeMaterialDefines
       */
      constructor() {
        super();
        this.NORMAL = false;
        this.TANGENT = false;
        this.VERTEXCOLOR_NME = false;
        this.PREPASS = false;
        this.PREPASS_NORMAL = false;
        this.PREPASS_NORMAL_INDEX = -1;
        this.PREPASS_WORLD_NORMAL = false;
        this.PREPASS_WORLD_NORMAL_INDEX = -1;
        this.PREPASS_POSITION = false;
        this.PREPASS_POSITION_INDEX = -1;
        this.PREPASS_LOCAL_POSITION = false;
        this.PREPASS_LOCAL_POSITION_INDEX = -1;
        this.PREPASS_DEPTH = false;
        this.PREPASS_DEPTH_INDEX = -1;
        this.PREPASS_SCREENSPACE_DEPTH = false;
        this.PREPASS_SCREENSPACE_DEPTH_INDEX = -1;
        this.SCENE_MRT_COUNT = 0;
        this.NUM_BONE_INFLUENCERS = 0;
        this.BonesPerMesh = 0;
        this.BONETEXTURE = false;
        this.MORPHTARGETS = false;
        this.MORPHTARGETS_POSITION = false;
        this.MORPHTARGETS_NORMAL = false;
        this.MORPHTARGETS_TANGENT = false;
        this.MORPHTARGETS_UV = false;
        this.MORPHTARGETS_UV2 = false;
        this.MORPHTARGETS_COLOR = false;
        this.MORPHTARGETTEXTURE_HASPOSITIONS = false;
        this.MORPHTARGETTEXTURE_HASNORMALS = false;
        this.MORPHTARGETTEXTURE_HASTANGENTS = false;
        this.MORPHTARGETTEXTURE_HASUVS = false;
        this.MORPHTARGETTEXTURE_HASUV2S = false;
        this.MORPHTARGETTEXTURE_HASCOLORS = false;
        this.NUM_MORPH_INFLUENCERS = 0;
        this.MORPHTARGETS_TEXTURE = false;
        this.BUMPDIRECTUV = 0;
        this.CAMERA_ORTHOGRAPHIC = false;
        this.CAMERA_PERSPECTIVE = false;
        this.AREALIGHTSUPPORTED = true;
        this.AREALIGHTNOROUGHTNESS = true;
        this.POSITIONW_AS_VARYING = false;
        this.rebuild();
      }
      /**
       * Set the value of a specific key
       * @param name defines the name of the key to set
       * @param value defines the value to set
       * @param markAsUnprocessedIfDirty Flag to indicate to the cache that this value needs processing
       */
      setValue(name13, value, markAsUnprocessedIfDirty = false) {
        if (this[name13] === void 0) {
          this._keys.push(name13);
        }
        if (markAsUnprocessedIfDirty && this[name13] !== value) {
          this.markAsUnprocessed();
        }
        this[name13] = value;
      }
    };
    NodeMaterialBase = class extends ImageProcessingMixin(PushMaterial) {
    };
    NodeMaterial = class _NodeMaterial extends NodeMaterialBase {
      /**
       * Checks if a block is a texture block
       * @param block The block to check
       * @returns True if the block is a texture block
       */
      static _BlockIsTextureBlock(block) {
        return block.getClassName() === "TextureBlock" || block.getClassName() === "ReflectionTextureBaseBlock" || block.getClassName() === "ReflectionTextureBlock" || block.getClassName() === "ReflectionBlock" || block.getClassName() === "RefractionBlock" || block.getClassName() === "CurrentScreenBlock" || block.getClassName() === "SmartFilterTextureBlock" || block.getClassName() === "ParticleTextureBlock" || block.getClassName() === "ImageSourceBlock" || block.getClassName() === "TriPlanarBlock" || block.getClassName() === "BiPlanarBlock" || block.getClassName() === "PrePassTextureBlock";
      }
      /** Gets whether the node material is currently building */
      get buildIsInProgress() {
        return this._buildIsInProgress;
      }
      set _glowModeEnabled(value) {
        this._useAdditionalColor = value;
      }
      /** Get the inspector from bundle or global
       * @returns the global NME
       */
      _getGlobalNodeMaterialEditor() {
        if (typeof NODEEDITOR !== "undefined") {
          return NODEEDITOR;
        }
        if (typeof BABYLON !== "undefined" && typeof BABYLON.NodeEditor !== "undefined") {
          return BABYLON;
        }
        return void 0;
      }
      /** Gets or sets the active shader language */
      get shaderLanguage() {
        return this._options?.shaderLanguage || _NodeMaterial.DefaultShaderLanguage;
      }
      set shaderLanguage(value) {
        this._options.shaderLanguage = value;
      }
      /** Gets or sets options to control the node material overall behavior */
      get options() {
        return this._options;
      }
      set options(options) {
        this._options = options;
      }
      /**
       * Gets or sets the mode property
       */
      get mode() {
        return this._mode;
      }
      set mode(value) {
        this._mode = value;
      }
      /** Gets or sets the unique identifier used to identified the effect associated with the material */
      get buildId() {
        return this._buildId;
      }
      set buildId(value) {
        this._buildId = value;
      }
      /**
       * Create a new node based material
       * @param name defines the material name
       * @param scene defines the hosting scene
       * @param options defines creation option
       */
      constructor(name13, scene, options = {}) {
        super(name13, scene || EngineStore.LastCreatedScene);
        this._buildId = _NodeMaterial._BuildIdGenerator++;
        this._buildWasSuccessful = false;
        this._cachedWorldViewMatrix = new Matrix();
        this._cachedWorldViewProjectionMatrix = new Matrix();
        this._optimizers = new Array();
        this._animationFrame = -1;
        this._buildIsInProgress = false;
        this.BJSNODEMATERIALEDITOR = this._getGlobalNodeMaterialEditor();
        this._useAdditionalColor = false;
        this.editorData = null;
        this.ignoreAlpha = false;
        this.maxSimultaneousLights = 4;
        this.onBuildObservable = new Observable();
        this.onBuildErrorObservable = new Observable();
        this._vertexOutputNodes = new Array();
        this._fragmentOutputNodes = new Array();
        this.attachedBlocks = [];
        this._mode = NodeMaterialModes.Material;
        this.forceAlphaBlending = false;
        if (!_NodeMaterial.UseNativeShaderLanguageOfEngine && options && options.shaderLanguage === 1 && !this.getScene().getEngine().isWebGPU) {
          throw new Error("WebGPU shader language is only supported with WebGPU engine");
        }
        this._options = {
          emitComments: false,
          shaderLanguage: _NodeMaterial.DefaultShaderLanguage,
          ...options
        };
        if (_NodeMaterial.UseNativeShaderLanguageOfEngine) {
          this._options.shaderLanguage = this.getScene().getEngine().isWebGPU ? 1 : 0;
        }
        this._attachImageProcessingConfiguration(null);
      }
      /**
       * Gets the current class name of the material e.g. "NodeMaterial"
       * @returns the class name
       */
      getClassName() {
        return "NodeMaterial";
      }
      /**
       * Get a block by its name
       * @param name defines the name of the block to retrieve
       * @returns the required block or null if not found
       */
      getBlockByName(name13) {
        let result = null;
        for (const block of this.attachedBlocks) {
          if (block.name === name13) {
            if (!result) {
              result = block;
            } else {
              Tools.Warn("More than one block was found with the name `" + name13 + "`");
              return result;
            }
          }
        }
        return result;
      }
      /**
       * Get a block using a predicate
       * @param predicate defines the predicate used to find the good candidate
       * @returns the required block or null if not found
       */
      getBlockByPredicate(predicate) {
        for (const block of this.attachedBlocks) {
          if (predicate(block)) {
            return block;
          }
        }
        return null;
      }
      /**
       * Get an input block using a predicate
       * @param predicate defines the predicate used to find the good candidate
       * @returns the required input block or null if not found
       */
      getInputBlockByPredicate(predicate) {
        for (const block of this.attachedBlocks) {
          if (block.isInput && predicate(block)) {
            return block;
          }
        }
        return null;
      }
      /**
       * Gets the list of input blocks attached to this material
       * @returns an array of InputBlocks
       */
      getInputBlocks() {
        const blocks = [];
        for (const block of this.attachedBlocks) {
          if (block.isInput) {
            blocks.push(block);
          }
        }
        return blocks;
      }
      /**
       * Adds a new optimizer to the list of optimizers
       * @param optimizer defines the optimizers to add
       * @returns the current material
       */
      registerOptimizer(optimizer) {
        const index = this._optimizers.indexOf(optimizer);
        if (index > -1) {
          return;
        }
        this._optimizers.push(optimizer);
        return this;
      }
      /**
       * Remove an optimizer from the list of optimizers
       * @param optimizer defines the optimizers to remove
       * @returns the current material
       */
      unregisterOptimizer(optimizer) {
        const index = this._optimizers.indexOf(optimizer);
        if (index === -1) {
          return;
        }
        this._optimizers.splice(index, 1);
        return this;
      }
      /**
       * Add a new block to the list of output nodes
       * @param node defines the node to add
       * @returns the current material
       */
      addOutputNode(node) {
        if (node.target === null) {
          throw "This node is not meant to be an output node. You may want to explicitly set its target value.";
        }
        if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {
          this._addVertexOutputNode(node);
        }
        if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {
          this._addFragmentOutputNode(node);
        }
        return this;
      }
      /**
       * Remove a block from the list of root nodes
       * @param node defines the node to remove
       * @returns the current material
       */
      removeOutputNode(node) {
        if (node.target === null) {
          return this;
        }
        if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {
          this._removeVertexOutputNode(node);
        }
        if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {
          this._removeFragmentOutputNode(node);
        }
        return this;
      }
      _addVertexOutputNode(node) {
        if (this._vertexOutputNodes.indexOf(node) !== -1) {
          return;
        }
        node.target = NodeMaterialBlockTargets.Vertex;
        this._vertexOutputNodes.push(node);
        return this;
      }
      _removeVertexOutputNode(node) {
        const index = this._vertexOutputNodes.indexOf(node);
        if (index === -1) {
          return;
        }
        this._vertexOutputNodes.splice(index, 1);
        return this;
      }
      _addFragmentOutputNode(node) {
        if (this._fragmentOutputNodes.indexOf(node) !== -1) {
          return;
        }
        node.target = NodeMaterialBlockTargets.Fragment;
        this._fragmentOutputNodes.push(node);
        return this;
      }
      _removeFragmentOutputNode(node) {
        const index = this._fragmentOutputNodes.indexOf(node);
        if (index === -1) {
          return;
        }
        this._fragmentOutputNodes.splice(index, 1);
        return this;
      }
      get _supportGlowLayer() {
        if (this._fragmentOutputNodes.length === 0) {
          return false;
        }
        if (this._fragmentOutputNodes.some((f) => f.additionalColor && f.additionalColor.isConnected)) {
          return true;
        }
        return false;
      }
      /**
       * Specifies if the material will require alpha blending
       * @returns a boolean specifying if alpha blending is needed
       */
      needAlphaBlending() {
        if (this.ignoreAlpha) {
          return false;
        }
        return this.forceAlphaBlending || this.alpha < 1 || this._sharedData && this._sharedData.hints.needAlphaBlending;
      }
      /**
       * Specifies if this material should be rendered in alpha test mode
       * @returns a boolean specifying if an alpha test is needed.
       */
      needAlphaTesting() {
        return this._sharedData && this._sharedData.hints.needAlphaTesting;
      }
      _processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure = true) {
        if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {
          nodesToProcessForOtherBuildState.push(block);
        } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {
          nodesToProcessForOtherBuildState.push(block);
        }
        this._initializeBlock(block, state, nodesToProcessForOtherBuildState, autoConfigure);
      }
      _attachBlock(node) {
        if (this.attachedBlocks.indexOf(node) === -1) {
          if (node.isUnique) {
            const className = node.getClassName();
            for (const other of this.attachedBlocks) {
              if (other.getClassName() === className) {
                this._sharedData.raiseBuildError(`Cannot have multiple blocks of type ${className} in the same NodeMaterial`);
                return;
              }
            }
          }
          this.attachedBlocks.push(node);
        }
      }
      _initializeBlock(node, state, nodesToProcessForOtherBuildState, autoConfigure = true) {
        node.initialize(state);
        if (autoConfigure) {
          node.autoConfigure(this);
        }
        node._preparationId = this._buildId;
        this._attachBlock(node);
        for (const input of node.inputs) {
          input.associatedVariableName = "";
          const connectedPoint = input.connectedPoint;
          if (connectedPoint && !connectedPoint._preventBubbleUp) {
            const block = connectedPoint.ownerBlock;
            if (block !== node) {
              this._processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure);
            }
          }
        }
        if (node.isLoop) {
          const loopBlock = node;
          if (loopBlock.loopID.hasEndpoints) {
            for (const endpoint of loopBlock.loopID.endpoints) {
              const block = endpoint.ownerBlock;
              if (block.outputs.length !== 0) {
                continue;
              }
              state._terminalBlocks.add(block);
              this._processInitializeOnLink(block, state, nodesToProcessForOtherBuildState, autoConfigure);
            }
          }
        } else if (node.isTeleportOut) {
          const teleport = node;
          if (teleport.entryPoint) {
            this._processInitializeOnLink(teleport.entryPoint, state, nodesToProcessForOtherBuildState, autoConfigure);
          }
        }
        for (const output of node.outputs) {
          output.associatedVariableName = "";
        }
      }
      _resetDualBlocks(node, id) {
        if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {
          node.buildId = id;
        }
        for (const input of node.inputs) {
          const connectedPoint = input.connectedPoint;
          if (connectedPoint && !connectedPoint._preventBubbleUp) {
            const block = connectedPoint.ownerBlock;
            if (block !== node) {
              this._resetDualBlocks(block, id);
            }
          }
        }
        if (node.isTeleportOut) {
          const teleportOut = node;
          if (teleportOut.entryPoint) {
            this._resetDualBlocks(teleportOut.entryPoint, id);
          }
        } else if (node.isLoop) {
          const loopBlock = node;
          if (loopBlock.loopID.hasEndpoints) {
            for (const endpoint of loopBlock.loopID.endpoints) {
              const block = endpoint.ownerBlock;
              if (block.outputs.length !== 0) {
                continue;
              }
              this._resetDualBlocks(block, id);
            }
          }
        }
      }
      /**
       * Remove a block from the current node material
       * @param block defines the block to remove
       */
      removeBlock(block) {
        const attachedBlockIndex = this.attachedBlocks.indexOf(block);
        if (attachedBlockIndex > -1) {
          this.attachedBlocks.splice(attachedBlockIndex, 1);
        }
        if (block.isFinalMerger) {
          this.removeOutputNode(block);
        }
      }
      /**
       * Build the material and generates the inner effect
       * @param verbose defines if the build should log activity
       * @param updateBuildId defines if the internal build Id should be updated (default is true)
       * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is false)
       */
      build(verbose = false, updateBuildId = true, autoConfigure = false) {
        if (this._buildIsInProgress) {
          Logger.Warn("Build is already in progress, You can use NodeMaterial.onBuildObservable to determine when the build is completed.");
          return;
        }
        this._buildIsInProgress = true;
        if (!this._vertexCompilationState && !autoConfigure) {
          autoConfigure = true;
        }
        this._buildWasSuccessful = false;
        const engine = this.getScene().getEngine();
        const allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle || this._mode === NodeMaterialModes.SFE;
        if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {
          this.onBuildErrorObservable.notifyObservers("You must define at least one vertexOutputNode");
          this._buildIsInProgress = false;
          return;
        }
        if (this._fragmentOutputNodes.length === 0) {
          this.onBuildErrorObservable.notifyObservers("You must define at least one fragmentOutputNode");
          this._buildIsInProgress = false;
          return;
        }
        this._vertexCompilationState = new NodeMaterialBuildState();
        this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;
        this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;
        this._fragmentCompilationState = new NodeMaterialBuildState();
        this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;
        this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment;
        const needToPurgeList = this._fragmentOutputNodes.filter((n) => n._isFinalOutputAndActive).length > 1;
        let fragmentOutputNodes = this._fragmentOutputNodes;
        if (needToPurgeList) {
          fragmentOutputNodes = this._fragmentOutputNodes.filter((n) => !n._isFinalOutputAndActive);
          fragmentOutputNodes.push(this._fragmentOutputNodes.filter((n) => n._isFinalOutputAndActive && n._hasPrecedence)[0]);
        }
        this._sharedData = new NodeMaterialBuildStateSharedData();
        this._sharedData.nodeMaterial = this;
        this._sharedData.fragmentOutputNodes = fragmentOutputNodes;
        this._vertexCompilationState.sharedData = this._sharedData;
        this._fragmentCompilationState.sharedData = this._sharedData;
        this._sharedData.buildId = this._buildId;
        this._sharedData.emitComments = this._options.emitComments;
        this._sharedData.verbose = verbose;
        this._sharedData.scene = this.getScene();
        this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram;
        const vertexNodes = [];
        const fragmentNodes = [];
        for (const vertexOutputNode of this._vertexOutputNodes) {
          vertexNodes.push(vertexOutputNode);
          this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes, autoConfigure);
        }
        for (const fragmentOutputNode of fragmentOutputNodes) {
          fragmentNodes.push(fragmentOutputNode);
          this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes, autoConfigure);
        }
        let waitingNodeCount = 0;
        for (const node of this.attachedBlocks) {
          if (!node.codeIsReady) {
            waitingNodeCount++;
            node.onCodeIsReadyObservable.addOnce(() => {
              waitingNodeCount--;
              if (waitingNodeCount === 0) {
                this._finishBuildProcess(verbose, updateBuildId, vertexNodes, fragmentNodes);
              }
            });
          }
        }
        if (waitingNodeCount !== 0) {
          return;
        }
        this._finishBuildProcess(verbose, updateBuildId, vertexNodes, fragmentNodes);
      }
      _finishBuildProcess(verbose = false, updateBuildId = true, vertexNodes, fragmentNodes) {
        this.optimize();
        for (const vertexOutputNode of vertexNodes) {
          vertexOutputNode.build(this._vertexCompilationState, vertexNodes);
        }
        this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);
        this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;
        this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;
        this._fragmentCompilationState._vertexState = this._vertexCompilationState;
        for (const fragmentOutputNode of fragmentNodes) {
          this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);
        }
        for (const fragmentOutputNode of fragmentNodes) {
          fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);
        }
        this._vertexCompilationState.finalize(this._vertexCompilationState);
        this._fragmentCompilationState.finalize(this._fragmentCompilationState);
        if (updateBuildId) {
          this._buildId = _NodeMaterial._BuildIdGenerator++;
        }
        if (verbose) {
          Logger.Log("Vertex shader:");
          Logger.Log(this._vertexCompilationState.compilationString);
          Logger.Log("Fragment shader:");
          Logger.Log(this._fragmentCompilationState.compilationString);
        }
        const noError = this._sharedData.emitErrors();
        this._buildIsInProgress = false;
        if (noError) {
          this._buildWasSuccessful = true;
          this.onBuildObservable.notifyObservers(this);
        }
        const meshes = this.getScene().meshes;
        for (const mesh of meshes) {
          if (!mesh.subMeshes) {
            continue;
          }
          for (const subMesh of mesh.subMeshes) {
            if (subMesh.getMaterial() !== this) {
              continue;
            }
            if (!subMesh.materialDefines) {
              continue;
            }
            const defines = subMesh.materialDefines;
            defines.markAllAsDirty();
            defines.reset();
          }
        }
        if (this.prePassTextureInputs.length) {
          this.getScene().enablePrePassRenderer();
        }
        const prePassRenderer = this.getScene().prePassRenderer;
        if (prePassRenderer) {
          prePassRenderer.markAsDirty();
        }
      }
      /**
       * Runs an optimization phase to try to improve the shader code
       */
      optimize() {
        for (const optimizer of this._optimizers) {
          optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);
        }
      }
      _prepareDefinesForAttributes(mesh, defines) {
        const oldNormal = defines["NORMAL"];
        const oldTangent = defines["TANGENT"];
        const oldColor = defines["VERTEXCOLOR_NME"];
        defines["NORMAL"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
        defines["TANGENT"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);
        const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);
        defines["VERTEXCOLOR_NME"] = hasVertexColors;
        let uvChanged = false;
        for (let i = 1; i <= 6; ++i) {
          const oldUV = defines["UV" + i];
          defines["UV" + i] = mesh.isVerticesDataPresent(`uv${i === 1 ? "" : i}`);
          uvChanged = uvChanged || defines["UV" + i] !== oldUV;
        }
        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
        PrepareDefinesForPrePass(this.getScene(), defines, !oit);
        MaterialHelperGeometryRendering.PrepareDefines(this.getScene().getEngine().currentRenderPassId, mesh, defines);
        if (oldNormal !== defines["NORMAL"] || oldTangent !== defines["TANGENT"] || oldColor !== defines["VERTEXCOLOR_NME"] || uvChanged) {
          defines.markAsAttributesDirty();
        }
      }
      /**
       * Can this material render to prepass
       */
      get isPrePassCapable() {
        return true;
      }
      /**
       * Outputs written to the prepass
       */
      get prePassTextureOutputs() {
        const prePassOutputBlock = this.getBlockByPredicate((block) => block.getClassName() === "PrePassOutputBlock");
        const result = [4];
        if (!prePassOutputBlock) {
          return result;
        }
        if (this.prePassTextureInputs.length) {
          return result;
        }
        if (prePassOutputBlock.viewDepth.isConnected) {
          result.push(5);
        }
        if (prePassOutputBlock.screenDepth.isConnected) {
          result.push(10);
        }
        if (prePassOutputBlock.viewNormal.isConnected) {
          result.push(6);
        }
        if (prePassOutputBlock.worldNormal.isConnected) {
          result.push(8);
        }
        if (prePassOutputBlock.worldPosition.isConnected) {
          result.push(1);
        }
        if (prePassOutputBlock.localPosition.isConnected) {
          result.push(9);
        }
        if (prePassOutputBlock.reflectivity.isConnected) {
          result.push(3);
        }
        if (prePassOutputBlock.velocity.isConnected) {
          result.push(2);
        }
        if (prePassOutputBlock.velocityLinear.isConnected) {
          result.push(11);
        }
        return result;
      }
      /**
       * Gets the list of prepass texture required
       */
      get prePassTextureInputs() {
        const prePassTextureBlocks = this.getAllTextureBlocks().filter((block) => block.getClassName() === "PrePassTextureBlock");
        const result = [];
        for (const block of prePassTextureBlocks) {
          if (block.position.isConnected && !result.includes(1)) {
            result.push(1);
          }
          if (block.localPosition.isConnected && !result.includes(9)) {
            result.push(9);
          }
          if (block.depth.isConnected && !result.includes(5)) {
            result.push(5);
          }
          if (block.screenDepth.isConnected && !result.includes(10)) {
            result.push(10);
          }
          if (block.normal.isConnected && !result.includes(6)) {
            result.push(6);
          }
          if (block.worldNormal.isConnected && !result.includes(8)) {
            result.push(8);
          }
        }
        return result;
      }
      /**
       * Sets the required values to the prepass renderer.
       * @param prePassRenderer defines the prepass renderer to set
       * @returns true if the pre pass is needed
       */
      setPrePassRenderer(prePassRenderer) {
        const prePassTexturesRequired = this.prePassTextureInputs.concat(this.prePassTextureOutputs);
        if (prePassRenderer && prePassTexturesRequired.length > 1) {
          let cfg = prePassRenderer.getEffectConfiguration("nodeMaterial");
          if (!cfg) {
            cfg = prePassRenderer.addEffectConfiguration({
              enabled: true,
              needsImageProcessing: false,
              name: "nodeMaterial",
              texturesRequired: []
            });
          }
          for (const prePassTexture of prePassTexturesRequired) {
            if (!cfg.texturesRequired.includes(prePassTexture)) {
              cfg.texturesRequired.push(prePassTexture);
            }
          }
          cfg.enabled = true;
        }
        return prePassTexturesRequired.length > 1;
      }
      /**
       * Create a post process from the material
       * @param camera The camera to apply the render pass to.
       * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
       * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
       * @param engine The engine which the post process will be applied. (default: current engine)
       * @param reusable If the post process can be reused on the same frame. (default: false)
       * @param textureType Type of textures used when performing the post process. (default: 0)
       * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)
       * @returns the post process created
       */
      createPostProcess(camera, options = 1, samplingMode = 1, engine, reusable, textureType = 0, textureFormat = 5) {
        if (this.mode !== NodeMaterialModes.PostProcess && this.mode !== NodeMaterialModes.SFE) {
          Logger.Log("Incompatible material mode");
          return null;
        }
        return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);
      }
      /**
       * Create the post process effect from the material
       * @param postProcess The post process to create the effect for
       */
      createEffectForPostProcess(postProcess) {
        this._createEffectForPostProcess(postProcess);
      }
      _createEffectForPostProcess(postProcess, camera, options = 1, samplingMode = 1, engine, reusable, textureType = 0, textureFormat = 5) {
        let tempName = this.name + this._buildId;
        const defines = new NodeMaterialDefines();
        let buildId = this._buildId;
        this._processDefines(defines);
        const vertexCode = this._sharedData.checks.emitVertex ? this._vertexCompilationState._builtCompilationString : void 0;
        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, vertexCode, this.shaderLanguage);
        if (!postProcess) {
          postProcess = new PostProcess(this.name + "PostProcess", tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, options, camera, samplingMode, engine, reusable, defines.toString(), textureType, vertexCode ? tempName : "postprocess", { maxSimultaneousLights: this.maxSimultaneousLights }, false, textureFormat, this.shaderLanguage);
        } else {
          postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, { maxSimultaneousLights: this.maxSimultaneousLights }, void 0, void 0, tempName, tempName);
        }
        postProcess.nodeMaterialSource = this;
        postProcess.onApplyObservable.add((effect) => {
          if (buildId !== this._buildId) {
            delete Effect.ShadersStore[tempName + "VertexShader"];
            delete Effect.ShadersStore[tempName + "PixelShader"];
            tempName = this.name + this._buildId;
            defines.markAllAsDirty();
            buildId = this._buildId;
          }
          const result = this._processDefines(defines);
          if (result) {
            Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);
            TimingTools.SetImmediate(() => postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, { maxSimultaneousLights: this.maxSimultaneousLights }, void 0, void 0, tempName, tempName));
          }
          this._checkInternals(effect);
        });
        return postProcess;
      }
      /**
       * Create a new procedural texture based on this node material
       * @param size defines the size of the texture
       * @param scene defines the hosting scene
       * @returns the new procedural texture attached to this node material
       */
      createProceduralTexture(size, scene) {
        if (this.mode !== NodeMaterialModes.ProceduralTexture) {
          Logger.Log("Incompatible material mode");
          return null;
        }
        let tempName = this.name + this._buildId;
        const proceduralTexture = new ProceduralTexture(tempName, size, null, scene);
        const defines = new NodeMaterialDefines();
        const result = this._processDefines(defines);
        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString, this.shaderLanguage);
        let effect = this.getScene().getEngine().createEffect({
          vertexElement: tempName,
          fragmentElement: tempName
        }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result?.fallbacks, void 0, void 0, void 0, this.shaderLanguage);
        proceduralTexture.nodeMaterialSource = this;
        proceduralTexture._setEffect(effect);
        let buildId = this._buildId;
        const refreshEffect = () => {
          if (buildId !== this._buildId) {
            delete Effect.ShadersStore[tempName + "VertexShader"];
            delete Effect.ShadersStore[tempName + "PixelShader"];
            tempName = this.name + this._buildId;
            defines.markAllAsDirty();
            buildId = this._buildId;
          }
          const result2 = this._processDefines(defines);
          if (result2) {
            Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString, this.shaderLanguage);
            TimingTools.SetImmediate(() => {
              effect = this.getScene().getEngine().createEffect({
                vertexElement: tempName,
                fragmentElement: tempName
              }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result2?.fallbacks, void 0);
              proceduralTexture._setEffect(effect);
            });
          }
          this._checkInternals(effect);
        };
        proceduralTexture.onBeforeGenerationObservable.add(() => {
          refreshEffect();
        });
        this.onBuildObservable.add(() => {
          refreshEffect();
        });
        return proceduralTexture;
      }
      _createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, particleSystemDefinesJoined = "") {
        let tempName = this.name + this._buildId + "_" + blendMode;
        if (!defines) {
          defines = new NodeMaterialDefines();
        }
        let buildId = this._buildId;
        const particleSystemDefines = [];
        let join = particleSystemDefinesJoined;
        if (!effect) {
          const result = this._processDefines(defines);
          Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, void 0, this.shaderLanguage);
          particleSystem.fillDefines(particleSystemDefines, blendMode, false);
          join = particleSystemDefines.join("\n");
          effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + "\n" + join, result?.fallbacks, onCompiled, onError, particleSystem, this.shaderLanguage);
          particleSystem.setCustomEffect(effect, blendMode);
        }
        effect.onBindObservable.add((effect2) => {
          if (buildId !== this._buildId) {
            delete Effect.ShadersStore[tempName + "PixelShader"];
            tempName = this.name + this._buildId + "_" + blendMode;
            defines.markAllAsDirty();
            buildId = this._buildId;
          }
          particleSystemDefines.length = 0;
          particleSystem.fillDefines(particleSystemDefines, blendMode, false);
          const particleSystemDefinesJoinedCurrent = particleSystemDefines.join("\n");
          if (particleSystemDefinesJoinedCurrent !== join) {
            defines.markAllAsDirty();
            join = particleSystemDefinesJoinedCurrent;
          }
          const result = this._processDefines(defines);
          if (result) {
            Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, void 0, this.shaderLanguage);
            effect2 = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + "\n" + join, result?.fallbacks, onCompiled, onError, particleSystem);
            particleSystem.setCustomEffect(effect2, blendMode);
            this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect2, defines, particleSystemDefinesJoined);
            return;
          }
          this._checkInternals(effect2);
        });
      }
      _checkInternals(effect) {
        if (this._sharedData.animatedInputs) {
          const scene = this.getScene();
          const frameId = scene.getFrameId();
          if (this._animationFrame !== frameId) {
            for (const input of this._sharedData.animatedInputs) {
              input.animate(scene);
            }
            this._animationFrame = frameId;
          }
        }
        for (const block of this._sharedData.bindableBlocks) {
          block.bind(effect, this);
        }
        for (const inputBlock of this._sharedData.inputBlocks) {
          inputBlock._transmit(effect, this.getScene(), this);
        }
      }
      /**
       * Create the effect to be used as the custom effect for a particle system
       * @param particleSystem Particle system to create the effect for
       * @param onCompiled defines a function to call when the effect creation is successful
       * @param onError defines a function to call when the effect creation has failed
       */
      createEffectForParticles(particleSystem, onCompiled, onError) {
        if (this.mode !== NodeMaterialModes.Particle) {
          Logger.Log("Incompatible material mode");
          return;
        }
        this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);
        this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);
      }
      /**
       * Use this material as the shadow depth wrapper of a target material
       * @param targetMaterial defines the target material
       */
      createAsShadowDepthWrapper(targetMaterial) {
        if (this.mode !== NodeMaterialModes.Material) {
          Logger.Log("Incompatible material mode");
          return;
        }
        targetMaterial.shadowDepthWrapper = new BABYLON.ShadowDepthWrapper(this, this.getScene());
      }
      _processDefines(defines, mesh, useInstances = false, subMesh) {
        let result = null;
        const scene = this.getScene();
        if (PrepareDefinesForCamera(scene, defines)) {
          defines.markAsMiscDirty();
        }
        for (const b of this._sharedData.blocksWithDefines) {
          b.initializeDefines(defines);
        }
        for (const b of this._sharedData.blocksWithDefines) {
          b.prepareDefines(defines, this, mesh, useInstances, subMesh);
        }
        for (const d in this._sharedData.defines) {
          defines[d] = this._sharedData.defines[d];
        }
        if (defines.isDirty) {
          const lightDisposed = defines._areLightsDisposed;
          defines.markAsProcessed();
          this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;
          this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;
          for (const b of this._sharedData.repeatableContentBlocks) {
            b.replaceRepeatableContent(this._vertexCompilationState, defines, mesh);
          }
          const uniformBuffers = [];
          for (const b of this._sharedData.dynamicUniformBlocks) {
            b.updateUniformsAndSamples(this._vertexCompilationState, this, defines, uniformBuffers);
          }
          const mergedUniforms = this._vertexCompilationState.uniforms;
          for (const u of this._fragmentCompilationState.uniforms) {
            const index = mergedUniforms.indexOf(u);
            if (index === -1) {
              mergedUniforms.push(u);
            }
          }
          const mergedSamplers = this._vertexCompilationState.samplers;
          for (const s of this._fragmentCompilationState.samplers) {
            const index = mergedSamplers.indexOf(s);
            if (index === -1) {
              mergedSamplers.push(s);
            }
          }
          const fallbacks = new EffectFallbacks();
          for (const b of this._sharedData.blocksWithFallbacks) {
            b.provideFallbacks(fallbacks, mesh);
          }
          result = {
            lightDisposed,
            uniformBuffers,
            mergedUniforms,
            mergedSamplers,
            fallbacks
          };
        }
        return result;
      }
      /**
       * Get if the submesh is ready to be used and all its information available.
       * Child classes can use it to update shaders
       * @param mesh defines the mesh to check
       * @param subMesh defines which submesh to check
       * @param useInstances specifies that instances should be used
       * @returns a boolean indicating that the submesh is ready or not
       */
      isReadyForSubMesh(mesh, subMesh, useInstances = false) {
        if (!this._buildWasSuccessful) {
          return false;
        }
        const scene = this.getScene();
        if (this._sharedData.animatedInputs) {
          const frameId = scene.getFrameId();
          if (this._animationFrame !== frameId) {
            for (const input of this._sharedData.animatedInputs) {
              input.animate(scene);
            }
            this._animationFrame = frameId;
          }
        }
        const drawWrapper = subMesh._drawWrapper;
        if (drawWrapper.effect && this.isFrozen) {
          if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
            return true;
          }
        }
        if (!subMesh.materialDefines || typeof subMesh.materialDefines === "string") {
          subMesh.materialDefines = new NodeMaterialDefines();
        }
        const defines = subMesh.materialDefines;
        if (this._isReadyForSubMesh(subMesh)) {
          return true;
        }
        const engine = scene.getEngine();
        this._prepareDefinesForAttributes(mesh, defines);
        if (this._sharedData.blockingBlocks.some((b) => !b.isReady(mesh, this, defines, useInstances))) {
          return false;
        }
        const result = this._processDefines(defines, mesh, useInstances, subMesh);
        if (result) {
          const previousEffect = subMesh.effect;
          const join = defines.toString();
          let effect = engine.createEffect({
            vertex: "nodeMaterial" + this._buildId,
            fragment: "nodeMaterial" + this._buildId,
            vertexSource: this._vertexCompilationState.compilationString,
            fragmentSource: this._fragmentCompilationState.compilationString
          }, {
            attributes: this._vertexCompilationState.attributes,
            uniformsNames: result.mergedUniforms,
            uniformBuffersNames: result.uniformBuffers,
            samplers: result.mergedSamplers,
            defines: join,
            fallbacks: result.fallbacks,
            onCompiled: this.onCompiled,
            onError: this.onError,
            multiTarget: defines.PREPASS,
            indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },
            shaderLanguage: this.shaderLanguage
          }, engine);
          if (effect) {
            if (this._onEffectCreatedObservable) {
              onCreatedEffectParameters.effect = effect;
              onCreatedEffectParameters.subMesh = subMesh;
              this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
            }
            if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
              effect = previousEffect;
              defines.markAsUnprocessed();
              if (result.lightDisposed) {
                defines._areLightsDisposed = true;
                return false;
              }
            } else {
              scene.resetCachedMaterial();
              subMesh.setEffect(effect, defines, this._materialContext);
            }
          }
        }
        if (defines["AREALIGHTUSED"] || defines["CLUSTLIGHT_BATCH"]) {
          for (let index = 0; index < mesh.lightSources.length; index++) {
            if (!mesh.lightSources[index]._isReady()) {
              return false;
            }
          }
        }
        if (!subMesh.effect || !subMesh.effect.isReady()) {
          return false;
        }
        defines._renderId = scene.getRenderId();
        drawWrapper._wasPreviouslyReady = true;
        drawWrapper._wasPreviouslyUsingInstances = useInstances;
        this._checkScenePerformancePriority();
        return true;
      }
      /**
       * Get a string representing the shaders built by the current node graph
       */
      get compiledShaders() {
        if (!this._buildWasSuccessful) {
          this.build();
        }
        return `// Vertex shader
${this._vertexCompilationState.compilationString}

// Fragment shader
${this._fragmentCompilationState.compilationString}`;
      }
      /**
       * Get a string representing the fragment shader used by the engine for the current node graph
       * @internal
       */
      async _getProcessedFragmentAsync() {
        if (!this._buildWasSuccessful) {
          this.build();
        }
        const defines = new NodeMaterialDefines();
        this._processDefines(defines);
        let processingDefines = defines.toString();
        if (this.mode === NodeMaterialModes.SFE) {
          processingDefines += `#define ${SfeModeDefine}
`;
        }
        return await this._fragmentCompilationState.getProcessedShaderAsync(processingDefines);
      }
      /**
       * Binds the world matrix to the material
       * @param world defines the world transformation matrix
       */
      bindOnlyWorldMatrix(world) {
        const scene = this.getScene();
        if (!this._activeEffect) {
          return;
        }
        const hints = this._sharedData.hints;
        if (hints.needWorldViewMatrix) {
          world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);
        }
        if (hints.needWorldViewProjectionMatrix) {
          world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);
        }
        for (const inputBlock of this._sharedData.inputBlocks) {
          inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);
        }
      }
      /**
       * Binds the submesh to this material by preparing the effect and shader to draw
       * @param world defines the world transformation matrix
       * @param mesh defines the mesh containing the submesh
       * @param subMesh defines the submesh to bind the material to
       */
      bindForSubMesh(world, mesh, subMesh) {
        const scene = this.getScene();
        const effect = subMesh.effect;
        if (!effect) {
          return;
        }
        this._activeEffect = effect;
        this.bindOnlyWorldMatrix(world);
        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
        const sharedData = this._sharedData;
        if (mustRebind) {
          for (const block of sharedData.bindableBlocks) {
            block.bind(effect, this, mesh, subMesh);
          }
          for (const block of sharedData.forcedBindableBlocks) {
            block.bind(effect, this, mesh, subMesh);
          }
          for (const inputBlock of sharedData.inputBlocks) {
            inputBlock._transmit(effect, scene, this);
          }
        } else if (!this.isFrozen) {
          for (const block of sharedData.forcedBindableBlocks) {
            block.bind(effect, this, mesh, subMesh);
          }
        }
        this._afterBind(mesh, this._activeEffect, subMesh);
      }
      /**
       * Gets the active textures from the material
       * @returns an array of textures
       */
      getActiveTextures() {
        const activeTextures = super.getActiveTextures();
        if (this._sharedData) {
          activeTextures.push(...this._sharedData.textureBlocks.filter((tb) => tb.texture).map((tb) => tb.texture));
        }
        return activeTextures;
      }
      /**
       * Gets the list of texture blocks
       * Note that this method will only return blocks that are reachable from the final block(s) and only after the material has been built!
       * @returns an array of texture blocks
       */
      getTextureBlocks() {
        if (!this._sharedData) {
          return [];
        }
        return this._sharedData.textureBlocks;
      }
      /**
       * Gets the list of all texture blocks
       * Note that this method will scan all attachedBlocks and return blocks that are texture blocks
       * @returns
       */
      getAllTextureBlocks() {
        const textureBlocks = [];
        for (const block of this.attachedBlocks) {
          if (_NodeMaterial._BlockIsTextureBlock(block)) {
            textureBlocks.push(block);
          }
        }
        return textureBlocks;
      }
      /**
       * Specifies if the material uses a texture
       * @param texture defines the texture to check against the material
       * @returns a boolean specifying if the material uses the texture
       */
      hasTexture(texture) {
        if (super.hasTexture(texture)) {
          return true;
        }
        if (!this._sharedData) {
          return false;
        }
        for (const t of this._sharedData.textureBlocks) {
          if (t.texture === texture) {
            return true;
          }
        }
        return false;
      }
      /**
       * Disposes the material
       * @param forceDisposeEffect specifies if effects should be forcefully disposed
       * @param forceDisposeTextures specifies if textures should be forcefully disposed
       * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
       */
      dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
        if (forceDisposeTextures) {
          for (const texture of this.getTextureBlocks().filter((tb) => tb.texture).map((tb) => tb.texture)) {
            texture.dispose();
          }
        }
        for (const block of this.attachedBlocks) {
          block.dispose();
        }
        this.attachedBlocks.length = 0;
        this._sharedData = null;
        this._vertexCompilationState = null;
        this._fragmentCompilationState = null;
        this.onBuildObservable.clear();
        this.onBuildErrorObservable.clear();
        if (this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
          this._imageProcessingObserver = null;
        }
        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);
      }
      /** Creates the node editor window.
       * @param additionalConfig Define the configuration of the editor
       */
      _createNodeEditor(additionalConfig) {
        const nodeEditorConfig = {
          nodeMaterial: this,
          ...additionalConfig
        };
        this.BJSNODEMATERIALEDITOR.NodeEditor.Show(nodeEditorConfig);
      }
      /**
       * Launch the node material editor
       * @param config Define the configuration of the editor
       * @returns a promise fulfilled when the node editor is visible
       */
      async edit(config) {
        return await new Promise((resolve) => {
          this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();
          if (typeof this.BJSNODEMATERIALEDITOR == "undefined") {
            const editorUrl = config && config.editorURL ? config.editorURL : _NodeMaterial.EditorURL;
            Tools.LoadBabylonScript(editorUrl, () => {
              this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();
              this._createNodeEditor(config?.nodeEditorConfig);
              resolve();
            });
          } else {
            this._createNodeEditor(config?.nodeEditorConfig);
            resolve();
          }
        });
      }
      /**
       * Clear the current material
       */
      clear() {
        this._vertexOutputNodes.length = 0;
        this._fragmentOutputNodes.length = 0;
        this.attachedBlocks.length = 0;
        this._buildIsInProgress = false;
      }
      /**
       * Clear the current material and set it to a default state
       */
      setToDefault() {
        this.clear();
        this.editorData = null;
        const positionInput = new InputBlock("Position");
        positionInput.setAsAttribute("position");
        const worldInput = new InputBlock("World");
        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);
        const worldPos = new TransformBlock("WorldPos");
        positionInput.connectTo(worldPos);
        worldInput.connectTo(worldPos);
        const viewProjectionInput = new InputBlock("ViewProjection");
        viewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.ViewProjection);
        const worldPosdMultipliedByViewProjection = new TransformBlock("WorldPos * ViewProjectionTransform");
        worldPos.connectTo(worldPosdMultipliedByViewProjection);
        viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);
        const vertexOutput = new VertexOutputBlock("VertexOutput");
        worldPosdMultipliedByViewProjection.connectTo(vertexOutput);
        const pixelColor = new InputBlock("color");
        pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);
        const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
        pixelColor.connectTo(fragmentOutput);
        this.addOutputNode(vertexOutput);
        this.addOutputNode(fragmentOutput);
        this._mode = NodeMaterialModes.Material;
      }
      /**
       * Clear the current material and set it to a default state for post process
       */
      setToDefaultPostProcess() {
        this.clear();
        this.editorData = null;
        const position = new InputBlock("Position");
        position.setAsAttribute("position2d");
        const const1 = new InputBlock("Constant1");
        const1.isConstant = true;
        const1.value = 1;
        const vmerger = new VectorMergerBlock("Position3D");
        position.connectTo(vmerger);
        const1.connectTo(vmerger, { input: "w" });
        const vertexOutput = new VertexOutputBlock("VertexOutput");
        vmerger.connectTo(vertexOutput);
        const scale = new InputBlock("Scale");
        scale.visibleInInspector = true;
        scale.value = new Vector2(1, 1);
        const uv0 = new RemapBlock("uv0");
        position.connectTo(uv0);
        const uv = new MultiplyBlock("UV scale");
        uv0.connectTo(uv);
        scale.connectTo(uv);
        const currentScreen = new CurrentScreenBlock("CurrentScreen");
        uv.connectTo(currentScreen);
        const textureUrl = Tools.GetAssetUrl("https://assets.babylonjs.com/core/nme/currentScreenPostProcess.png");
        currentScreen.texture = new Texture(textureUrl, this.getScene());
        const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
        currentScreen.connectTo(fragmentOutput, { output: "rgba" });
        this.addOutputNode(vertexOutput);
        this.addOutputNode(fragmentOutput);
        this._mode = NodeMaterialModes.PostProcess;
      }
      /**
       * Clear the current material and set it to a default state for procedural texture
       */
      setToDefaultProceduralTexture() {
        this.clear();
        this.editorData = null;
        const position = new InputBlock("Position");
        position.setAsAttribute("position2d");
        const const1 = new InputBlock("Constant1");
        const1.isConstant = true;
        const1.value = 1;
        const vmerger = new VectorMergerBlock("Position3D");
        position.connectTo(vmerger);
        const1.connectTo(vmerger, { input: "w" });
        const vertexOutput = new VertexOutputBlock("VertexOutput");
        vmerger.connectTo(vertexOutput);
        const time = new InputBlock("Time");
        time.value = 0;
        time.min = 0;
        time.max = 0;
        time.isBoolean = false;
        time.matrixMode = 0;
        time.animationType = AnimatedInputBlockTypes.Time;
        time.isConstant = false;
        const color = new InputBlock("Color3");
        color.value = new Color3(1, 1, 1);
        color.isConstant = false;
        const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
        const vectorMerger = new VectorMergerBlock("VectorMerger");
        vectorMerger.visibleInInspector = false;
        const cos = new TrigonometryBlock("Cos");
        cos.operation = TrigonometryBlockOperations.Cos;
        position.connectTo(vectorMerger);
        time.output.connectTo(cos.input);
        cos.output.connectTo(vectorMerger.z);
        vectorMerger.xyzOut.connectTo(fragmentOutput.rgb);
        this.addOutputNode(vertexOutput);
        this.addOutputNode(fragmentOutput);
        this._mode = NodeMaterialModes.ProceduralTexture;
      }
      /**
       * Clear the current material and set it to a default state for particle
       */
      setToDefaultParticle() {
        this.clear();
        this.editorData = null;
        const uv = new InputBlock("uv");
        uv.setAsAttribute("particle_uv");
        const texture = new ParticleTextureBlock("ParticleTexture");
        uv.connectTo(texture);
        const color = new InputBlock("Color");
        color.setAsAttribute("particle_color");
        const multiply = new MultiplyBlock("Texture * Color");
        texture.connectTo(multiply);
        color.connectTo(multiply);
        const rampGradient = new ParticleRampGradientBlock("ParticleRampGradient");
        multiply.connectTo(rampGradient);
        const cSplitter = new ColorSplitterBlock("ColorSplitter");
        color.connectTo(cSplitter);
        const blendMultiply = new ParticleBlendMultiplyBlock("ParticleBlendMultiply");
        rampGradient.connectTo(blendMultiply);
        texture.connectTo(blendMultiply, { output: "a" });
        cSplitter.connectTo(blendMultiply, { output: "a" });
        const fragmentOutput = new FragmentOutputBlock("FragmentOutput");
        blendMultiply.connectTo(fragmentOutput);
        this.addOutputNode(fragmentOutput);
        this._mode = NodeMaterialModes.Particle;
      }
      /**
       * Loads the current Node Material from a url pointing to a file save by the Node Material Editor
       * @deprecated Please use NodeMaterial.ParseFromFileAsync instead
       * @param url defines the url to load from
       * @param rootUrl defines the root URL for nested url in the node material
       * @returns a promise that will fulfil when the material is fully loaded
       */
      async loadAsync(url, rootUrl = "") {
        return await _NodeMaterial.ParseFromFileAsync("", url, this.getScene(), rootUrl, true, this);
      }
      _gatherBlocks(rootNode, list) {
        if (list.indexOf(rootNode) !== -1) {
          return;
        }
        list.push(rootNode);
        for (const input of rootNode.inputs) {
          const connectedPoint = input.connectedPoint;
          if (connectedPoint) {
            const block = connectedPoint.ownerBlock;
            if (block !== rootNode) {
              this._gatherBlocks(block, list);
            }
          }
        }
        if (rootNode.isTeleportOut) {
          const block = rootNode;
          if (block.entryPoint) {
            this._gatherBlocks(block.entryPoint, list);
          }
        }
      }
      /**
       * Generate a string containing the code declaration required to create an equivalent of this material
       * @returns a string
       */
      generateCode() {
        let alreadyDumped = [];
        const vertexBlocks = [];
        const uniqueNames = ["const", "var", "let"];
        for (const outputNode of this._vertexOutputNodes) {
          this._gatherBlocks(outputNode, vertexBlocks);
        }
        const fragmentBlocks = [];
        for (const outputNode of this._fragmentOutputNodes) {
          this._gatherBlocks(outputNode, fragmentBlocks);
        }
        let codeString = `var nodeMaterial = new BABYLON.NodeMaterial("${this.name || "node material"}");
`;
        codeString += `nodeMaterial.mode = BABYLON.NodeMaterialModes.${NodeMaterialModes[this.mode]};
`;
        for (const node of vertexBlocks) {
          if (node.isInput && alreadyDumped.indexOf(node) === -1) {
            codeString += node._dumpCode(uniqueNames, alreadyDumped);
          }
        }
        for (const node of fragmentBlocks) {
          if (node.isInput && alreadyDumped.indexOf(node) === -1) {
            codeString += node._dumpCode(uniqueNames, alreadyDumped);
          }
        }
        alreadyDumped = [];
        codeString += "\n// Connections\n";
        for (const node of this._vertexOutputNodes) {
          codeString += node._dumpCodeForOutputConnections(alreadyDumped);
        }
        for (const node of this._fragmentOutputNodes) {
          codeString += node._dumpCodeForOutputConnections(alreadyDumped);
        }
        codeString += "\n// Output nodes\n";
        for (const node of this._vertexOutputNodes) {
          codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});
`;
        }
        for (const node of this._fragmentOutputNodes) {
          codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});
`;
        }
        codeString += `nodeMaterial.build();
`;
        return codeString;
      }
      /**
       * Serializes this material in a JSON representation
       * @param selectedBlocks defines an optional list of blocks to serialize
       * @returns the serialized material object
       */
      serialize(selectedBlocks) {
        const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);
        serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData));
        let blocks = [];
        if (selectedBlocks) {
          blocks = selectedBlocks;
        } else {
          serializationObject.customType = "BABYLON.NodeMaterial";
          serializationObject.outputNodes = [];
          for (const outputNode of this._vertexOutputNodes) {
            this._gatherBlocks(outputNode, blocks);
            serializationObject.outputNodes.push(outputNode.uniqueId);
          }
          for (const outputNode of this._fragmentOutputNodes) {
            this._gatherBlocks(outputNode, blocks);
            if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {
              serializationObject.outputNodes.push(outputNode.uniqueId);
            }
          }
        }
        serializationObject.blocks = [];
        for (const block of blocks) {
          serializationObject.blocks.push(block.serialize());
        }
        if (!selectedBlocks) {
          for (const block of this.attachedBlocks) {
            if (blocks.indexOf(block) !== -1) {
              continue;
            }
            serializationObject.blocks.push(block.serialize());
          }
        }
        serializationObject.uniqueId = this.uniqueId;
        return serializationObject;
      }
      _restoreConnections(block, source, map) {
        for (const outputPoint of block.outputs) {
          for (const candidate of source.blocks) {
            const target = map[candidate.id];
            if (!target) {
              continue;
            }
            for (const input of candidate.inputs) {
              if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {
                const inputPoint = target.getInputByName(input.inputName);
                if (!inputPoint || inputPoint.isConnected) {
                  continue;
                }
                outputPoint.connectTo(inputPoint, true);
                this._restoreConnections(target, source, map);
                continue;
              }
            }
          }
        }
      }
      /**
       * Clear the current graph and load a new one from a serialization object
       * @param source defines the JSON representation of the material
       * @param rootUrl defines the root URL to use to load textures and relative dependencies
       * @param merge defines whether or not the source must be merged or replace the current content
       * @param urlRewriter defines a function used to rewrite urls
       */
      parseSerializedObject(source, rootUrl = "", merge = false, urlRewriter) {
        if (!merge) {
          this.clear();
        }
        const id = this.id;
        const uniqueId = this.uniqueId;
        SerializationHelper.ParseProperties(source, this, this.getScene(), rootUrl);
        this.id = id;
        this.uniqueId = uniqueId;
        const map = {};
        for (const parsedBlock of source.blocks) {
          const blockType = GetClass(parsedBlock.customType);
          if (blockType) {
            const block = new blockType();
            block._deserialize(parsedBlock, this.getScene(), rootUrl, urlRewriter);
            map[parsedBlock.id] = block;
            this.attachedBlocks.push(block);
          }
        }
        for (const block of this.attachedBlocks) {
          if (block.isTeleportOut) {
            const teleportOut = block;
            const id2 = teleportOut._tempEntryPointUniqueId;
            if (id2) {
              const source2 = map[id2];
              source2.attachToEndpoint(teleportOut);
            }
          }
        }
        for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {
          const parsedBlock = source.blocks[blockIndex];
          const block = map[parsedBlock.id];
          if (!block) {
            continue;
          }
          if (block.inputs.length && !merge) {
            continue;
          }
          this._restoreConnections(block, source, map);
        }
        if (source.outputNodes) {
          for (const outputNodeId of source.outputNodes) {
            this.addOutputNode(map[outputNodeId]);
          }
        }
        if (source.locations || source.editorData && source.editorData.locations) {
          const locations = source.locations || source.editorData.locations;
          for (const location of locations) {
            if (map[location.blockId]) {
              location.blockId = map[location.blockId].uniqueId;
            }
          }
          if (merge && this.editorData && this.editorData.locations) {
            locations.concat(this.editorData.locations);
          }
          if (source.locations) {
            this.editorData = {
              locations
            };
          } else {
            this.editorData = source.editorData;
            this.editorData.locations = locations;
          }
          const blockMap = {};
          for (const key in map) {
            blockMap[key] = map[key].uniqueId;
          }
          this.editorData.map = blockMap;
        }
        Material.ParseAlphaMode(source, this);
        if (!merge) {
          this._mode = source.mode ?? NodeMaterialModes.Material;
        }
      }
      /**
       * Clear the current graph and load a new one from a serialization object
       * @param source defines the JSON representation of the material
       * @param rootUrl defines the root URL to use to load textures and relative dependencies
       * @param merge defines whether or not the source must be merged or replace the current content
       * @deprecated Please use the parseSerializedObject method instead
       */
      loadFromSerialization(source, rootUrl = "", merge = false) {
        this.parseSerializedObject(source, rootUrl, merge);
      }
      /**
       * Makes a duplicate of the current material.
       * @param name defines the name to use for the new material
       * @param shareEffect defines if the clone material should share the same effect (default is false)
       * @returns the cloned material
       */
      clone(name13, shareEffect = false) {
        const serializationObject = this.serialize();
        const clone = SerializationHelper.Clone(() => new _NodeMaterial(name13, this.getScene(), this.options), this);
        clone.parseSerializedObject(serializationObject);
        clone.id = name13;
        clone.name = name13;
        clone._buildId = this._buildId;
        clone.build(false, !shareEffect);
        return clone;
      }
      /**
       * Awaits for all the material textures to be ready before resolving the returned promise.
       * @returns A promise that resolves when the textures are ready.
       */
      // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
      whenTexturesReadyAsync() {
        const textureReadyPromises = [];
        const activeTextures = this.getActiveTextures();
        for (const texture of activeTextures) {
          const internalTexture = texture.getInternalTexture();
          if (internalTexture && !internalTexture.isReady) {
            textureReadyPromises.push(new Promise((textureResolve, textureReject) => {
              internalTexture.onLoadedObservable.addOnce(() => {
                textureResolve();
              });
              internalTexture.onErrorObservable.addOnce((e) => {
                textureReject(e);
              });
            }));
          }
        }
        return Promise.all(textureReadyPromises);
      }
      /**
       * Creates a node material from parsed material data
       * @param source defines the JSON representation of the material
       * @param scene defines the hosting scene
       * @param rootUrl defines the root URL to use to load textures and relative dependencies
       * @param shaderLanguage defines the language to use (GLSL by default)
       * @returns a new node material
       */
      static Parse(source, scene, rootUrl = "", shaderLanguage = 0) {
        const nodeMaterial = SerializationHelper.Parse(() => new _NodeMaterial(source.name, scene, { shaderLanguage }), source, scene, rootUrl);
        nodeMaterial.parseSerializedObject(source, rootUrl);
        nodeMaterial.build();
        return nodeMaterial;
      }
      /**
       * Creates a node material from a snippet saved in a remote file
       * @param name defines the name of the material to create
       * @param url defines the url to load from
       * @param scene defines the hosting scene
       * @param rootUrl defines the root URL for nested url in the node material
       * @param skipBuild defines whether to build the node material
       * @param targetMaterial defines a material to use instead of creating a new one
       * @param urlRewriter defines a function used to rewrite urls
       * @param options defines options to be used with the node material
       * @returns a promise that will resolve to the new node material
       */
      static async ParseFromFileAsync(name13, url, scene, rootUrl = "", skipBuild = false, targetMaterial, urlRewriter, options) {
        const material = targetMaterial ?? new _NodeMaterial(name13, scene, options);
        const finalName = material.name;
        const data = await scene._loadFileAsync(url);
        const serializationObject = JSON.parse(data);
        material.parseSerializedObject(serializationObject, rootUrl, void 0, urlRewriter);
        material.name = finalName;
        if (!skipBuild) {
          material.build();
        }
        return material;
      }
      /**
       * Creates a node material from a snippet saved by the node material editor
       * @param snippetId defines the snippet to load
       * @param scene defines the hosting scene
       * @param rootUrl defines the root URL to use to load textures and relative dependencies
       * @param nodeMaterial defines a node material to update (instead of creating a new one)
       * @param skipBuild defines whether to build the node material
       * @param waitForTextureReadyness defines whether to wait for texture readiness resolving the promise (default: false)
       * @param urlRewriter defines a function used to rewrite urls
       * @param options defines options to be used with the node material
       * @returns a promise that will resolve to the new node material
       */
      // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
      static ParseFromSnippetAsync(snippetId, scene = EngineStore.LastCreatedScene, rootUrl = "", nodeMaterial, skipBuild = false, waitForTextureReadyness = false, urlRewriter, options) {
        if (snippetId === "_BLANK") {
          return Promise.resolve(_NodeMaterial.CreateDefault("blank", scene));
        }
        return new Promise((resolve, reject) => {
          const request = new WebRequest();
          request.addEventListener("readystatechange", () => {
            if (request.readyState == 4) {
              if (request.status == 200) {
                const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
                const serializationObject = JSON.parse(snippet.nodeMaterial);
                if (!nodeMaterial) {
                  nodeMaterial = SerializationHelper.Parse(() => new _NodeMaterial(snippetId, scene, options), serializationObject, scene, rootUrl);
                  nodeMaterial.uniqueId = scene.getUniqueId();
                }
                nodeMaterial.parseSerializedObject(serializationObject, void 0, void 0, urlRewriter);
                nodeMaterial.snippetId = snippetId;
                nodeMaterial.sideOrientation = null;
                try {
                  if (!skipBuild) {
                    nodeMaterial.build();
                  }
                } catch (err) {
                  reject(err);
                }
                if (waitForTextureReadyness) {
                  nodeMaterial.whenTexturesReadyAsync().then(() => {
                    resolve(nodeMaterial);
                  }).catch((err) => {
                    reject(err);
                  });
                } else {
                  resolve(nodeMaterial);
                }
              } else {
                reject("Unable to load the snippet " + snippetId);
              }
            }
          });
          request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
          request.send();
        });
      }
      /**
       * Creates a new node material set to default basic configuration
       * @param name defines the name of the material
       * @param scene defines the hosting scene
       * @returns a new NodeMaterial
       */
      static CreateDefault(name13, scene) {
        const newMaterial = new _NodeMaterial(name13, scene);
        newMaterial.setToDefault();
        newMaterial.build();
        return newMaterial;
      }
    };
    NodeMaterial._BuildIdGenerator = 0;
    NodeMaterial.EditorURL = `${Tools._DefaultCdnUrl}/v${AbstractEngine.Version}/nodeEditor/babylon.nodeEditor.js`;
    NodeMaterial.SnippetUrl = `https://snippet.babylonjs.com`;
    NodeMaterial.IgnoreTexturesAtLoadTime = false;
    NodeMaterial.AllowSerializationOfRenderTargetTextures = false;
    NodeMaterial.DefaultShaderLanguage = 0;
    NodeMaterial.UseNativeShaderLanguageOfEngine = false;
    __decorate([
      serialize()
    ], NodeMaterial.prototype, "ignoreAlpha", void 0);
    __decorate([
      serialize()
    ], NodeMaterial.prototype, "maxSimultaneousLights", void 0);
    __decorate([
      serialize("mode")
    ], NodeMaterial.prototype, "_mode", void 0);
    __decorate([
      serialize("comment")
    ], NodeMaterial.prototype, "comment", void 0);
    __decorate([
      serialize()
    ], NodeMaterial.prototype, "forceAlphaBlending", void 0);
    RegisterClass("BABYLON.NodeMaterial", NodeMaterial);
  }
});

// node_modules/@babylonjs/core/Physics/v2/IPhysicsEnginePlugin.js
var PhysicsConstraintAxisLimitMode, PhysicsConstraintAxis, PhysicsConstraintType, PhysicsShapeType, PhysicsConstraintMotorType, PhysicsEventType, PhysicsMotionType, PhysicsPrestepType, PhysicsActivationControl;
var init_IPhysicsEnginePlugin = __esm({
  "node_modules/@babylonjs/core/Physics/v2/IPhysicsEnginePlugin.js"() {
    (function(PhysicsConstraintAxisLimitMode2) {
      PhysicsConstraintAxisLimitMode2[PhysicsConstraintAxisLimitMode2["FREE"] = 0] = "FREE";
      PhysicsConstraintAxisLimitMode2[PhysicsConstraintAxisLimitMode2["LIMITED"] = 1] = "LIMITED";
      PhysicsConstraintAxisLimitMode2[PhysicsConstraintAxisLimitMode2["LOCKED"] = 2] = "LOCKED";
    })(PhysicsConstraintAxisLimitMode || (PhysicsConstraintAxisLimitMode = {}));
    (function(PhysicsConstraintAxis2) {
      PhysicsConstraintAxis2[PhysicsConstraintAxis2["LINEAR_X"] = 0] = "LINEAR_X";
      PhysicsConstraintAxis2[PhysicsConstraintAxis2["LINEAR_Y"] = 1] = "LINEAR_Y";
      PhysicsConstraintAxis2[PhysicsConstraintAxis2["LINEAR_Z"] = 2] = "LINEAR_Z";
      PhysicsConstraintAxis2[PhysicsConstraintAxis2["ANGULAR_X"] = 3] = "ANGULAR_X";
      PhysicsConstraintAxis2[PhysicsConstraintAxis2["ANGULAR_Y"] = 4] = "ANGULAR_Y";
      PhysicsConstraintAxis2[PhysicsConstraintAxis2["ANGULAR_Z"] = 5] = "ANGULAR_Z";
      PhysicsConstraintAxis2[PhysicsConstraintAxis2["LINEAR_DISTANCE"] = 6] = "LINEAR_DISTANCE";
    })(PhysicsConstraintAxis || (PhysicsConstraintAxis = {}));
    (function(PhysicsConstraintType2) {
      PhysicsConstraintType2[PhysicsConstraintType2["BALL_AND_SOCKET"] = 1] = "BALL_AND_SOCKET";
      PhysicsConstraintType2[PhysicsConstraintType2["DISTANCE"] = 2] = "DISTANCE";
      PhysicsConstraintType2[PhysicsConstraintType2["HINGE"] = 3] = "HINGE";
      PhysicsConstraintType2[PhysicsConstraintType2["SLIDER"] = 4] = "SLIDER";
      PhysicsConstraintType2[PhysicsConstraintType2["LOCK"] = 5] = "LOCK";
      PhysicsConstraintType2[PhysicsConstraintType2["PRISMATIC"] = 6] = "PRISMATIC";
      PhysicsConstraintType2[PhysicsConstraintType2["SIX_DOF"] = 7] = "SIX_DOF";
    })(PhysicsConstraintType || (PhysicsConstraintType = {}));
    (function(PhysicsShapeType2) {
      PhysicsShapeType2[PhysicsShapeType2["SPHERE"] = 0] = "SPHERE";
      PhysicsShapeType2[PhysicsShapeType2["CAPSULE"] = 1] = "CAPSULE";
      PhysicsShapeType2[PhysicsShapeType2["CYLINDER"] = 2] = "CYLINDER";
      PhysicsShapeType2[PhysicsShapeType2["BOX"] = 3] = "BOX";
      PhysicsShapeType2[PhysicsShapeType2["CONVEX_HULL"] = 4] = "CONVEX_HULL";
      PhysicsShapeType2[PhysicsShapeType2["CONTAINER"] = 5] = "CONTAINER";
      PhysicsShapeType2[PhysicsShapeType2["MESH"] = 6] = "MESH";
      PhysicsShapeType2[PhysicsShapeType2["HEIGHTFIELD"] = 7] = "HEIGHTFIELD";
    })(PhysicsShapeType || (PhysicsShapeType = {}));
    (function(PhysicsConstraintMotorType2) {
      PhysicsConstraintMotorType2[PhysicsConstraintMotorType2["NONE"] = 0] = "NONE";
      PhysicsConstraintMotorType2[PhysicsConstraintMotorType2["VELOCITY"] = 1] = "VELOCITY";
      PhysicsConstraintMotorType2[PhysicsConstraintMotorType2["POSITION"] = 2] = "POSITION";
    })(PhysicsConstraintMotorType || (PhysicsConstraintMotorType = {}));
    (function(PhysicsEventType2) {
      PhysicsEventType2["COLLISION_STARTED"] = "COLLISION_STARTED";
      PhysicsEventType2["COLLISION_CONTINUED"] = "COLLISION_CONTINUED";
      PhysicsEventType2["COLLISION_FINISHED"] = "COLLISION_FINISHED";
      PhysicsEventType2["TRIGGER_ENTERED"] = "TRIGGER_ENTERED";
      PhysicsEventType2["TRIGGER_EXITED"] = "TRIGGER_EXITED";
    })(PhysicsEventType || (PhysicsEventType = {}));
    (function(PhysicsMotionType2) {
      PhysicsMotionType2[PhysicsMotionType2["STATIC"] = 0] = "STATIC";
      PhysicsMotionType2[PhysicsMotionType2["ANIMATED"] = 1] = "ANIMATED";
      PhysicsMotionType2[PhysicsMotionType2["DYNAMIC"] = 2] = "DYNAMIC";
    })(PhysicsMotionType || (PhysicsMotionType = {}));
    (function(PhysicsPrestepType2) {
      PhysicsPrestepType2[PhysicsPrestepType2["DISABLED"] = 0] = "DISABLED";
      PhysicsPrestepType2[PhysicsPrestepType2["TELEPORT"] = 1] = "TELEPORT";
      PhysicsPrestepType2[PhysicsPrestepType2["ACTION"] = 2] = "ACTION";
    })(PhysicsPrestepType || (PhysicsPrestepType = {}));
    (function(PhysicsActivationControl2) {
      PhysicsActivationControl2[PhysicsActivationControl2["SIMULATION_CONTROLLED"] = 0] = "SIMULATION_CONTROLLED";
      PhysicsActivationControl2[PhysicsActivationControl2["ALWAYS_ACTIVE"] = 1] = "ALWAYS_ACTIVE";
      PhysicsActivationControl2[PhysicsActivationControl2["ALWAYS_INACTIVE"] = 2] = "ALWAYS_INACTIVE";
    })(PhysicsActivationControl || (PhysicsActivationControl = {}));
  }
});

// node_modules/@babylonjs/core/Instrumentation/engineInstrumentation.js
var EngineInstrumentation;
var init_engineInstrumentation = __esm({
  "node_modules/@babylonjs/core/Instrumentation/engineInstrumentation.js"() {
    init_perfCounter();
    EngineInstrumentation = class {
      // Properties
      /**
       * Gets the perf counter used for GPU frame time
       */
      get gpuFrameTimeCounter() {
        return this.engine.getGPUFrameTimeCounter();
      }
      /**
       * Gets the GPU frame time capture status
       */
      get captureGPUFrameTime() {
        return this._captureGPUFrameTime;
      }
      /**
       * Enable or disable the GPU frame time capture
       */
      set captureGPUFrameTime(value) {
        if (value === this._captureGPUFrameTime) {
          return;
        }
        this._captureGPUFrameTime = value;
        this.engine.captureGPUFrameTime(value);
      }
      /**
       * Gets the perf counter used for shader compilation time
       */
      get shaderCompilationTimeCounter() {
        return this._shaderCompilationTime;
      }
      /**
       * Gets the shader compilation time capture status
       */
      get captureShaderCompilationTime() {
        return this._captureShaderCompilationTime;
      }
      /**
       * Enable or disable the shader compilation time capture
       */
      set captureShaderCompilationTime(value) {
        if (value === this._captureShaderCompilationTime) {
          return;
        }
        this._captureShaderCompilationTime = value;
        if (value) {
          this._onBeforeShaderCompilationObserver = this.engine.onBeforeShaderCompilationObservable.add(() => {
            this._shaderCompilationTime.fetchNewFrame();
            this._shaderCompilationTime.beginMonitoring();
          });
          this._onAfterShaderCompilationObserver = this.engine.onAfterShaderCompilationObservable.add(() => {
            this._shaderCompilationTime.endMonitoring();
          });
        } else {
          this.engine.onBeforeShaderCompilationObservable.remove(this._onBeforeShaderCompilationObserver);
          this._onBeforeShaderCompilationObserver = null;
          this.engine.onAfterShaderCompilationObservable.remove(this._onAfterShaderCompilationObserver);
          this._onAfterShaderCompilationObserver = null;
        }
      }
      /**
       * Instantiates a new engine instrumentation.
       * This class can be used to get instrumentation data from a Babylon engine
       * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#engineinstrumentation
       * @param engine Defines the engine to instrument
       */
      constructor(engine) {
        this.engine = engine;
        this._captureGPUFrameTime = false;
        this._captureShaderCompilationTime = false;
        this._shaderCompilationTime = new PerfCounter();
        this._onBeginFrameObserver = null;
        this._onEndFrameObserver = null;
        this._onBeforeShaderCompilationObserver = null;
        this._onAfterShaderCompilationObserver = null;
        this._disposed = false;
      }
      /**
       * Dispose and release associated resources.
       */
      dispose() {
        if (this._disposed) {
          return;
        }
        this.engine.onBeginFrameObservable.remove(this._onBeginFrameObserver);
        this._onBeginFrameObserver = null;
        this.engine.onEndFrameObservable.remove(this._onEndFrameObserver);
        this._onEndFrameObserver = null;
        this.engine.onBeforeShaderCompilationObservable.remove(this._onBeforeShaderCompilationObserver);
        this._onBeforeShaderCompilationObserver = null;
        this.engine.onAfterShaderCompilationObservable.remove(this._onAfterShaderCompilationObserver);
        this._onAfterShaderCompilationObserver = null;
        this.engine = null;
        this._disposed = true;
      }
    };
  }
});

// node_modules/@babylonjs/core/Instrumentation/sceneInstrumentation.js
var SceneInstrumentation;
var init_sceneInstrumentation = __esm({
  "node_modules/@babylonjs/core/Instrumentation/sceneInstrumentation.js"() {
    init_tools();
    init_perfCounter();
    SceneInstrumentation = class {
      // Properties
      /**
       * Gets the perf counter used for active meshes evaluation time
       */
      get activeMeshesEvaluationTimeCounter() {
        return this._activeMeshesEvaluationTime;
      }
      /**
       * Gets the active meshes evaluation time capture status
       */
      get captureActiveMeshesEvaluationTime() {
        return this._captureActiveMeshesEvaluationTime;
      }
      /**
       * Enable or disable the active meshes evaluation time capture
       */
      set captureActiveMeshesEvaluationTime(value) {
        if (value === this._captureActiveMeshesEvaluationTime) {
          return;
        }
        this._captureActiveMeshesEvaluationTime = value;
        if (value) {
          this._onBeforeActiveMeshesEvaluationObserver = this.scene.onBeforeActiveMeshesEvaluationObservable.add(() => {
            Tools.StartPerformanceCounter("Active meshes evaluation");
            this._activeMeshesEvaluationTime.beginMonitoring();
          });
          this._onAfterActiveMeshesEvaluationObserver = this.scene.onAfterActiveMeshesEvaluationObservable.add(() => {
            Tools.EndPerformanceCounter("Active meshes evaluation");
            this._activeMeshesEvaluationTime.endMonitoring(false);
          });
        } else {
          this.scene.onBeforeActiveMeshesEvaluationObservable.remove(this._onBeforeActiveMeshesEvaluationObserver);
          this._onBeforeActiveMeshesEvaluationObserver = null;
          this.scene.onAfterActiveMeshesEvaluationObservable.remove(this._onAfterActiveMeshesEvaluationObserver);
          this._onAfterActiveMeshesEvaluationObserver = null;
        }
      }
      /**
       * Gets the perf counter used for render targets render time
       */
      get renderTargetsRenderTimeCounter() {
        return this._renderTargetsRenderTime;
      }
      /**
       * Gets the render targets render time capture status
       */
      get captureRenderTargetsRenderTime() {
        return this._captureRenderTargetsRenderTime;
      }
      /**
       * Enable or disable the render targets render time capture
       */
      set captureRenderTargetsRenderTime(value) {
        if (value === this._captureRenderTargetsRenderTime) {
          return;
        }
        this._captureRenderTargetsRenderTime = value;
        if (value) {
          for (const objectRenderer of this.scene.objectRenderers) {
            this._onBeforeRenderTargetsRenderObserver.push(objectRenderer.onInitRenderingObservable.add(() => {
              Tools.StartPerformanceCounter("Render targets rendering");
              this._renderTargetsRenderTime.beginMonitoring();
            }));
            this._onAfterRenderTargetsRenderObserver.push(objectRenderer.onFinishRenderingObservable.add(() => {
              Tools.EndPerformanceCounter("Render targets rendering");
              this._renderTargetsRenderTime.endMonitoring(false);
            }));
          }
        } else {
          for (let i = 0; i < this.scene.objectRenderers.length; ++i) {
            const objectRenderer = this.scene.objectRenderers[i];
            objectRenderer.onInitRenderingObservable.remove(this._onBeforeRenderTargetsRenderObserver[i]);
            objectRenderer.onFinishRenderingObservable.remove(this._onAfterRenderTargetsRenderObserver[i]);
          }
          this._onBeforeRenderTargetsRenderObserver.length = 0;
          this._onAfterRenderTargetsRenderObserver.length = 0;
        }
      }
      /**
       * Gets the perf counter used for particles render time
       */
      get particlesRenderTimeCounter() {
        return this._particlesRenderTime;
      }
      /**
       * Gets the particles render time capture status
       */
      get captureParticlesRenderTime() {
        return this._captureParticlesRenderTime;
      }
      /**
       * Enable or disable the particles render time capture
       */
      set captureParticlesRenderTime(value) {
        if (value === this._captureParticlesRenderTime) {
          return;
        }
        this._captureParticlesRenderTime = value;
        if (value) {
          this._onBeforeParticlesRenderingObserver = this.scene.onBeforeParticlesRenderingObservable.add(() => {
            Tools.StartPerformanceCounter("Particles");
            this._particlesRenderTime.beginMonitoring();
          });
          this._onAfterParticlesRenderingObserver = this.scene.onAfterParticlesRenderingObservable.add(() => {
            Tools.EndPerformanceCounter("Particles");
            this._particlesRenderTime.endMonitoring(false);
          });
        } else {
          this.scene.onBeforeParticlesRenderingObservable.remove(this._onBeforeParticlesRenderingObserver);
          this._onBeforeParticlesRenderingObserver = null;
          this.scene.onAfterParticlesRenderingObservable.remove(this._onAfterParticlesRenderingObserver);
          this._onAfterParticlesRenderingObserver = null;
        }
      }
      /**
       * Gets the perf counter used for sprites render time
       */
      get spritesRenderTimeCounter() {
        return this._spritesRenderTime;
      }
      /**
       * Gets the sprites render time capture status
       */
      get captureSpritesRenderTime() {
        return this._captureSpritesRenderTime;
      }
      /**
       * Enable or disable the sprites render time capture
       */
      set captureSpritesRenderTime(value) {
        if (value === this._captureSpritesRenderTime) {
          return;
        }
        this._captureSpritesRenderTime = value;
        if (!this.scene.spriteManagers) {
          return;
        }
        if (value) {
          this._onBeforeSpritesRenderingObserver = this.scene.onBeforeSpritesRenderingObservable.add(() => {
            Tools.StartPerformanceCounter("Sprites");
            this._spritesRenderTime.beginMonitoring();
          });
          this._onAfterSpritesRenderingObserver = this.scene.onAfterSpritesRenderingObservable.add(() => {
            Tools.EndPerformanceCounter("Sprites");
            this._spritesRenderTime.endMonitoring(false);
          });
        } else {
          this.scene.onBeforeSpritesRenderingObservable.remove(this._onBeforeSpritesRenderingObserver);
          this._onBeforeSpritesRenderingObserver = null;
          this.scene.onAfterSpritesRenderingObservable.remove(this._onAfterSpritesRenderingObserver);
          this._onAfterSpritesRenderingObserver = null;
        }
      }
      /**
       * Gets the perf counter used for physics time
       */
      get physicsTimeCounter() {
        return this._physicsTime;
      }
      /**
       * Gets the physics time capture status
       */
      get capturePhysicsTime() {
        return this._capturePhysicsTime;
      }
      /**
       * Enable or disable the physics time capture
       */
      set capturePhysicsTime(value) {
        if (value === this._capturePhysicsTime) {
          return;
        }
        if (!this.scene.onBeforePhysicsObservable) {
          return;
        }
        this._capturePhysicsTime = value;
        if (value) {
          this._onBeforePhysicsObserver = this.scene.onBeforePhysicsObservable.add(() => {
            Tools.StartPerformanceCounter("Physics");
            this._physicsTime.beginMonitoring();
          });
          this._onAfterPhysicsObserver = this.scene.onAfterPhysicsObservable.add(() => {
            Tools.EndPerformanceCounter("Physics");
            this._physicsTime.endMonitoring();
          });
        } else {
          this.scene.onBeforePhysicsObservable.remove(this._onBeforePhysicsObserver);
          this._onBeforePhysicsObserver = null;
          this.scene.onAfterPhysicsObservable.remove(this._onAfterPhysicsObserver);
          this._onAfterPhysicsObserver = null;
        }
      }
      /**
       * Gets the perf counter used for animations time
       */
      get animationsTimeCounter() {
        return this._animationsTime;
      }
      /**
       * Gets the animations time capture status
       */
      get captureAnimationsTime() {
        return this._captureAnimationsTime;
      }
      /**
       * Enable or disable the animations time capture
       */
      set captureAnimationsTime(value) {
        if (value === this._captureAnimationsTime) {
          return;
        }
        this._captureAnimationsTime = value;
        if (value) {
          this._onAfterAnimationsObserver = this.scene.onAfterAnimationsObservable.add(() => {
            this._animationsTime.endMonitoring();
          });
        } else {
          this.scene.onAfterAnimationsObservable.remove(this._onAfterAnimationsObserver);
          this._onAfterAnimationsObserver = null;
        }
      }
      /**
       * Gets the perf counter used for frame time capture
       */
      get frameTimeCounter() {
        return this._frameTime;
      }
      /**
       * Gets the frame time capture status
       */
      get captureFrameTime() {
        return this._captureFrameTime;
      }
      /**
       * Enable or disable the frame time capture
       */
      set captureFrameTime(value) {
        this._captureFrameTime = value;
      }
      /**
       * Gets the perf counter used for inter-frames time capture
       */
      get interFrameTimeCounter() {
        return this._interFrameTime;
      }
      /**
       * Gets the inter-frames time capture status
       */
      get captureInterFrameTime() {
        return this._captureInterFrameTime;
      }
      /**
       * Enable or disable the inter-frames time capture
       */
      set captureInterFrameTime(value) {
        this._captureInterFrameTime = value;
      }
      /**
       * Gets the perf counter used for render time capture
       */
      get renderTimeCounter() {
        return this._renderTime;
      }
      /**
       * Gets the render time capture status
       */
      get captureRenderTime() {
        return this._captureRenderTime;
      }
      /**
       * Enable or disable the render time capture
       */
      set captureRenderTime(value) {
        if (value === this._captureRenderTime) {
          return;
        }
        this._captureRenderTime = value;
        if (value) {
          this._onBeforeDrawPhaseObserver.push(this.scene.onBeforeDrawPhaseObservable.add(() => {
            this._renderTime.beginMonitoring();
            Tools.StartPerformanceCounter("Main render");
          }));
          this._onAfterDrawPhaseObserver.push(this.scene.onAfterDrawPhaseObservable.add(() => {
            this._renderTime.endMonitoring(false);
            Tools.EndPerformanceCounter("Main render");
          }));
          for (const objectRenderer of this.scene.objectRenderers) {
            this._onBeforeDrawPhaseObserver.push(objectRenderer.onBeforeRenderingManagerRenderObservable.add(() => {
              this._renderTime.beginMonitoring();
              Tools.StartPerformanceCounter("Main render");
            }));
            this._onAfterDrawPhaseObserver.push(objectRenderer.onAfterRenderingManagerRenderObservable.add(() => {
              this._renderTime.endMonitoring(false);
              Tools.EndPerformanceCounter("Main render");
            }));
          }
        } else {
          this._removeRenderTimeObservers();
        }
      }
      /**
       * Gets the perf counter used for camera render time capture
       */
      get cameraRenderTimeCounter() {
        return this._cameraRenderTime;
      }
      /**
       * Gets the camera render time capture status
       */
      get captureCameraRenderTime() {
        return this._captureCameraRenderTime;
      }
      /**
       * Enable or disable the camera render time capture
       */
      set captureCameraRenderTime(value) {
        if (value === this._captureCameraRenderTime) {
          return;
        }
        this._captureCameraRenderTime = value;
        if (value) {
          this._onBeforeCameraRenderObserver = this.scene.onBeforeCameraRenderObservable.add((camera) => {
            this._cameraRenderTime.beginMonitoring();
            Tools.StartPerformanceCounter(`Rendering camera ${camera.name}`);
          });
          this._onAfterCameraRenderObserver = this.scene.onAfterCameraRenderObservable.add((camera) => {
            this._cameraRenderTime.endMonitoring(false);
            Tools.EndPerformanceCounter(`Rendering camera ${camera.name}`);
          });
        } else {
          this.scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
          this._onBeforeCameraRenderObserver = null;
          this.scene.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);
          this._onAfterCameraRenderObserver = null;
        }
      }
      /**
       * Gets the perf counter used for draw calls
       */
      get drawCallsCounter() {
        return this.scene.getEngine()._drawCalls;
      }
      /**
       * Instantiates a new scene instrumentation.
       * This class can be used to get instrumentation data from a Babylon engine
       * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#sceneinstrumentation
       * @param scene Defines the scene to instrument
       */
      constructor(scene) {
        this.scene = scene;
        this._captureActiveMeshesEvaluationTime = false;
        this._activeMeshesEvaluationTime = new PerfCounter();
        this._captureRenderTargetsRenderTime = false;
        this._renderTargetsRenderTime = new PerfCounter();
        this._captureFrameTime = false;
        this._frameTime = new PerfCounter();
        this._captureRenderTime = false;
        this._renderTime = new PerfCounter();
        this._captureInterFrameTime = false;
        this._interFrameTime = new PerfCounter();
        this._captureParticlesRenderTime = false;
        this._particlesRenderTime = new PerfCounter();
        this._captureSpritesRenderTime = false;
        this._spritesRenderTime = new PerfCounter();
        this._capturePhysicsTime = false;
        this._physicsTime = new PerfCounter();
        this._captureAnimationsTime = false;
        this._animationsTime = new PerfCounter();
        this._captureCameraRenderTime = false;
        this._cameraRenderTime = new PerfCounter();
        this._onBeforeActiveMeshesEvaluationObserver = null;
        this._onAfterActiveMeshesEvaluationObserver = null;
        this._onBeforeRenderTargetsRenderObserver = [];
        this._onAfterRenderTargetsRenderObserver = [];
        this._onAfterRenderObserver = null;
        this._onBeforeDrawPhaseObserver = [];
        this._onAfterDrawPhaseObserver = [];
        this._onBeforeAnimationsObserver = null;
        this._onBeforeParticlesRenderingObserver = null;
        this._onAfterParticlesRenderingObserver = null;
        this._onBeforeSpritesRenderingObserver = null;
        this._onAfterSpritesRenderingObserver = null;
        this._onBeforePhysicsObserver = null;
        this._onAfterPhysicsObserver = null;
        this._onAfterAnimationsObserver = null;
        this._onBeforeCameraRenderObserver = null;
        this._onAfterCameraRenderObserver = null;
        this._disposed = false;
        this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {
          if (this._captureActiveMeshesEvaluationTime) {
            this._activeMeshesEvaluationTime.fetchNewFrame();
          }
          if (this._captureRenderTargetsRenderTime) {
            this._renderTargetsRenderTime.fetchNewFrame();
          }
          if (this._captureFrameTime) {
            Tools.StartPerformanceCounter("Scene rendering");
            this._frameTime.beginMonitoring();
          }
          if (this._captureInterFrameTime) {
            this._interFrameTime.endMonitoring();
          }
          if (this._captureParticlesRenderTime) {
            this._particlesRenderTime.fetchNewFrame();
          }
          if (this._captureSpritesRenderTime) {
            this._spritesRenderTime.fetchNewFrame();
          }
          if (this._captureAnimationsTime) {
            this._animationsTime.beginMonitoring();
          }
          if (this._captureRenderTime) {
            this._renderTime.fetchNewFrame();
          }
          if (this._captureCameraRenderTime) {
            this._cameraRenderTime.fetchNewFrame();
          }
          this.scene.getEngine()._drawCalls.fetchNewFrame();
        });
        this._onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {
          if (this._captureFrameTime) {
            Tools.EndPerformanceCounter("Scene rendering");
            this._frameTime.endMonitoring();
          }
          if (this._captureRenderTime) {
            this._renderTime.endMonitoring(false);
          }
          if (this._captureInterFrameTime) {
            this._interFrameTime.beginMonitoring();
          }
          if (this._captureActiveMeshesEvaluationTime) {
            this._activeMeshesEvaluationTime.endFrame();
          }
          if (this._captureRenderTargetsRenderTime) {
            this._renderTargetsRenderTime.endFrame();
          }
          if (this._captureParticlesRenderTime) {
            this._particlesRenderTime.endFrame();
          }
          if (this._captureSpritesRenderTime) {
            this._spritesRenderTime.endFrame();
          }
          if (this._captureRenderTime) {
            this._renderTime.endFrame();
          }
          if (this._captureCameraRenderTime) {
            this._cameraRenderTime.endFrame();
          }
        });
      }
      _removeRenderTargetsObservers() {
        for (let i = 0; i < this.scene.objectRenderers.length; ++i) {
          const objectRenderer = this.scene.objectRenderers[i];
          objectRenderer.onInitRenderingObservable.remove(this._onBeforeRenderTargetsRenderObserver[i]);
          objectRenderer.onFinishRenderingObservable.remove(this._onAfterRenderTargetsRenderObserver[i]);
        }
        this._onBeforeRenderTargetsRenderObserver.length = 0;
        this._onAfterRenderTargetsRenderObserver.length = 0;
      }
      _removeRenderTimeObservers() {
        this.scene.onBeforeDrawPhaseObservable.remove(this._onBeforeDrawPhaseObserver[0]);
        this._onBeforeDrawPhaseObserver.length = 0;
        this.scene.onAfterDrawPhaseObservable.remove(this._onAfterDrawPhaseObserver[0]);
        this._onAfterDrawPhaseObserver.length = 0;
        for (let i = 1; i < this._onBeforeDrawPhaseObserver.length; i++) {
          const objectRenderer = this.scene.objectRenderers[i - 1];
          objectRenderer.onBeforeRenderingManagerRenderObservable.remove(this._onBeforeDrawPhaseObserver[i]);
          objectRenderer.onAfterRenderingManagerRenderObservable.remove(this._onAfterDrawPhaseObserver[i]);
        }
      }
      /**
       * Dispose and release associated resources.
       */
      dispose() {
        if (this._disposed) {
          return;
        }
        this.scene.onAfterRenderObservable.remove(this._onAfterRenderObserver);
        this._onAfterRenderObserver = null;
        this.scene.onBeforeActiveMeshesEvaluationObservable.remove(this._onBeforeActiveMeshesEvaluationObserver);
        this._onBeforeActiveMeshesEvaluationObserver = null;
        this.scene.onAfterActiveMeshesEvaluationObservable.remove(this._onAfterActiveMeshesEvaluationObserver);
        this._onAfterActiveMeshesEvaluationObserver = null;
        this._removeRenderTargetsObservers();
        this.scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);
        this._onBeforeAnimationsObserver = null;
        this.scene.onBeforeParticlesRenderingObservable.remove(this._onBeforeParticlesRenderingObserver);
        this._onBeforeParticlesRenderingObserver = null;
        this.scene.onAfterParticlesRenderingObservable.remove(this._onAfterParticlesRenderingObserver);
        this._onAfterParticlesRenderingObserver = null;
        if (this._onBeforeSpritesRenderingObserver) {
          this.scene.onBeforeSpritesRenderingObservable.remove(this._onBeforeSpritesRenderingObserver);
          this._onBeforeSpritesRenderingObserver = null;
        }
        if (this._onAfterSpritesRenderingObserver) {
          this.scene.onAfterSpritesRenderingObservable.remove(this._onAfterSpritesRenderingObserver);
          this._onAfterSpritesRenderingObserver = null;
        }
        this._removeRenderTimeObservers();
        if (this._onBeforePhysicsObserver) {
          this.scene.onBeforePhysicsObservable.remove(this._onBeforePhysicsObserver);
          this._onBeforePhysicsObserver = null;
        }
        if (this._onAfterPhysicsObserver) {
          this.scene.onAfterPhysicsObservable.remove(this._onAfterPhysicsObserver);
          this._onAfterPhysicsObserver = null;
        }
        this.scene.onAfterAnimationsObservable.remove(this._onAfterAnimationsObserver);
        this._onAfterAnimationsObserver = null;
        this.scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
        this._onBeforeCameraRenderObserver = null;
        this.scene.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);
        this._onAfterCameraRenderObserver = null;
        this.scene = null;
        this._disposed = true;
      }
    };
  }
});

// node_modules/@babylonjs/core/Layers/effectLayer.js
var EffectLayer;
var init_effectLayer = __esm({
  "node_modules/@babylonjs/core/Layers/effectLayer.js"() {
    init_tslib_es6();
    init_decorators();
    init_tools();
    init_observable();
    init_engineStore();
    init_texture();
    init_renderTargetTexture();
    init_devTools();
    init_tools_functions();
    init_thinEffectLayer();
    init_uniqueIdGenerator();
    EffectLayer = class _EffectLayer {
      get _shouldRender() {
        return this._thinEffectLayer._shouldRender;
      }
      set _shouldRender(value) {
        this._thinEffectLayer._shouldRender = value;
      }
      get _emissiveTextureAndColor() {
        return this._thinEffectLayer._emissiveTextureAndColor;
      }
      set _emissiveTextureAndColor(value) {
        this._thinEffectLayer._emissiveTextureAndColor = value;
      }
      get _effectIntensity() {
        return this._thinEffectLayer._effectIntensity;
      }
      set _effectIntensity(value) {
        this._thinEffectLayer._effectIntensity = value;
      }
      /**
       * Force all the effect layers to compile to glsl even on WebGPU engines.
       * False by default. This is mostly meant for backward compatibility.
       */
      static get ForceGLSL() {
        return ThinEffectLayer.ForceGLSL;
      }
      static set ForceGLSL(value) {
        ThinEffectLayer.ForceGLSL = value;
      }
      /**
       * The name of the layer
       */
      get name() {
        return this._thinEffectLayer.name;
      }
      set name(value) {
        this._thinEffectLayer.name = value;
      }
      /**
       * The clear color of the texture used to generate the glow map.
       */
      get neutralColor() {
        return this._thinEffectLayer.neutralColor;
      }
      set neutralColor(value) {
        this._thinEffectLayer.neutralColor = value;
      }
      /**
       * Specifies whether the highlight layer is enabled or not.
       */
      get isEnabled() {
        return this._thinEffectLayer.isEnabled;
      }
      set isEnabled(value) {
        this._thinEffectLayer.isEnabled = value;
      }
      /**
       * Gets the camera attached to the layer.
       */
      get camera() {
        return this._thinEffectLayer.camera;
      }
      /**
       * Gets the rendering group id the layer should render in.
       */
      get renderingGroupId() {
        return this._thinEffectLayer.renderingGroupId;
      }
      set renderingGroupId(renderingGroupId) {
        this._thinEffectLayer.renderingGroupId = renderingGroupId;
      }
      /**
       * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer
       */
      get disableBoundingBoxesFromEffectLayer() {
        return this._thinEffectLayer.disableBoundingBoxesFromEffectLayer;
      }
      set disableBoundingBoxesFromEffectLayer(value) {
        this._thinEffectLayer.disableBoundingBoxesFromEffectLayer = value;
      }
      /**
       * Gets the main texture where the effect is rendered
       */
      get mainTexture() {
        return this._mainTexture;
      }
      get _shaderLanguage() {
        return this._thinEffectLayer.shaderLanguage;
      }
      /**
       * Gets the shader language used in this material.
       */
      get shaderLanguage() {
        return this._thinEffectLayer.shaderLanguage;
      }
      /**
       * Sets a specific material to be used to render a mesh/a list of meshes in the layer
       * @param mesh mesh or array of meshes
       * @param material material to use by the layer when rendering the mesh(es). If undefined is passed, the specific material created by the layer will be used.
       */
      setMaterialForRendering(mesh, material) {
        this._thinEffectLayer.setMaterialForRendering(mesh, material);
      }
      /**
       * Gets the intensity of the effect for a specific mesh.
       * @param mesh The mesh to get the effect intensity for
       * @returns The intensity of the effect for the mesh
       */
      getEffectIntensity(mesh) {
        return this._thinEffectLayer.getEffectIntensity(mesh);
      }
      /**
       * Sets the intensity of the effect for a specific mesh.
       * @param mesh The mesh to set the effect intensity for
       * @param intensity The intensity of the effect for the mesh
       */
      setEffectIntensity(mesh, intensity) {
        this._thinEffectLayer.setEffectIntensity(mesh, intensity);
      }
      /**
       * Instantiates a new effect Layer and references it in the scene.
       * @param name The name of the layer
       * @param scene The scene to use the layer in
       * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
       * @param thinEffectLayer The thin instance of the effect layer (optional)
       */
      constructor(name13, scene, forceGLSL = false, thinEffectLayer) {
        this._mainTextureCreatedSize = { width: 0, height: 0 };
        this._maxSize = 0;
        this._mainTextureDesiredSize = { width: 0, height: 0 };
        this._postProcesses = [];
        this._textures = [];
        this.uniqueId = UniqueIdGenerator.UniqueId;
        this.onDisposeObservable = new Observable();
        this.onBeforeRenderMainTextureObservable = new Observable();
        this.onBeforeComposeObservable = new Observable();
        this.onBeforeRenderMeshToEffect = new Observable();
        this.onAfterRenderMeshToEffect = new Observable();
        this.onAfterComposeObservable = new Observable();
        this.onSizeChangedObservable = new Observable();
        this._internalThinEffectLayer = !thinEffectLayer;
        if (!thinEffectLayer) {
          thinEffectLayer = new ThinEffectLayer(name13, scene, forceGLSL, false, this._importShadersAsync.bind(this));
          thinEffectLayer.getEffectName = this.getEffectName.bind(this);
          thinEffectLayer.isReady = this.isReady.bind(this);
          thinEffectLayer._createMergeEffect = this._createMergeEffect.bind(this);
          thinEffectLayer._createTextureAndPostProcesses = this._createTextureAndPostProcesses.bind(this);
          thinEffectLayer._internalCompose = this._internalRender.bind(this);
          thinEffectLayer._setEmissiveTextureAndColor = this._setEmissiveTextureAndColor.bind(this);
          thinEffectLayer._numInternalDraws = this._numInternalDraws.bind(this);
          thinEffectLayer._addCustomEffectDefines = this._addCustomEffectDefines.bind(this);
          thinEffectLayer.hasMesh = this.hasMesh.bind(this);
          thinEffectLayer.shouldRender = this.shouldRender.bind(this);
          thinEffectLayer._shouldRenderMesh = this._shouldRenderMesh.bind(this);
          thinEffectLayer._canRenderMesh = this._canRenderMesh.bind(this);
          thinEffectLayer._useMeshMaterial = this._useMeshMaterial.bind(this);
        }
        this._thinEffectLayer = thinEffectLayer;
        this.name = name13;
        this._scene = scene || EngineStore.LastCreatedScene;
        _EffectLayer._SceneComponentInitialization(this._scene);
        this._engine = this._scene.getEngine();
        this._maxSize = this._engine.getCaps().maxTextureSize;
        this._scene.addEffectLayer(this);
        this._thinEffectLayer.onDisposeObservable.add(() => {
          this.onDisposeObservable.notifyObservers(this);
        });
        this._thinEffectLayer.onBeforeRenderLayerObservable.add(() => {
          this.onBeforeRenderMainTextureObservable.notifyObservers(this);
        });
        this._thinEffectLayer.onBeforeComposeObservable.add(() => {
          this.onBeforeComposeObservable.notifyObservers(this);
        });
        this._thinEffectLayer.onBeforeRenderMeshToEffect.add((mesh) => {
          this.onBeforeRenderMeshToEffect.notifyObservers(mesh);
        });
        this._thinEffectLayer.onAfterRenderMeshToEffect.add((mesh) => {
          this.onAfterRenderMeshToEffect.notifyObservers(mesh);
        });
        this._thinEffectLayer.onAfterComposeObservable.add(() => {
          this.onAfterComposeObservable.notifyObservers(this);
        });
      }
      get _shadersLoaded() {
        return this._thinEffectLayer._shadersLoaded;
      }
      set _shadersLoaded(value) {
        this._thinEffectLayer._shadersLoaded = value;
      }
      /**
       * Number of times _internalRender will be called. Some effect layers need to render the mesh several times, so they should override this method with the number of times the mesh should be rendered
       * @returns Number of times a mesh must be rendered in the layer
       */
      _numInternalDraws() {
        return this._internalThinEffectLayer ? 1 : this._thinEffectLayer._numInternalDraws();
      }
      /**
       * Initializes the effect layer with the required options.
       * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)
       */
      _init(options) {
        this._effectLayerOptions = {
          mainTextureRatio: 0.5,
          alphaBlendingMode: 2,
          camera: null,
          renderingGroupId: -1,
          mainTextureType: 0,
          generateStencilBuffer: false,
          ...options
        };
        this._setMainTextureSize();
        this._thinEffectLayer._init(options);
        this._createMainTexture();
        this._createTextureAndPostProcesses();
      }
      /**
       * Sets the main texture desired size which is the closest power of two
       * of the engine canvas size.
       */
      _setMainTextureSize() {
        if (this._effectLayerOptions.mainTextureFixedSize) {
          this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;
          this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;
        } else {
          this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;
          this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;
          this._mainTextureDesiredSize.width = this._engine.needPOTTextures ? GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize) : this._mainTextureDesiredSize.width;
          this._mainTextureDesiredSize.height = this._engine.needPOTTextures ? GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize) : this._mainTextureDesiredSize.height;
        }
        this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);
        this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);
      }
      /**
       * Creates the main texture for the effect layer.
       */
      _createMainTexture() {
        this._mainTexture = new RenderTargetTexture("EffectLayerMainRTT", {
          width: this._mainTextureDesiredSize.width,
          height: this._mainTextureDesiredSize.height
        }, this._scene, {
          type: this._effectLayerOptions.mainTextureType,
          samplingMode: Texture.TRILINEAR_SAMPLINGMODE,
          generateStencilBuffer: this._effectLayerOptions.generateStencilBuffer,
          existingObjectRenderer: this._thinEffectLayer.objectRenderer
        });
        this._mainTexture.activeCamera = this._effectLayerOptions.camera;
        this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._mainTexture.anisotropicFilteringLevel = 1;
        this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        this._mainTexture.renderParticles = false;
        this._mainTexture.renderList = null;
        this._mainTexture.ignoreCameraViewport = true;
        this._mainTexture.onClearObservable.add((engine) => {
          engine.clear(this.neutralColor, true, true, true);
        });
      }
      /**
       * Adds specific effects defines.
       * @param defines The defines to add specifics to.
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _addCustomEffectDefines(defines) {
      }
      /**
       * Checks for the readiness of the element composing the layer.
       * @param subMesh the mesh to check for
       * @param useInstances specify whether or not to use instances to render the mesh
       * @param emissiveTexture the associated emissive texture used to generate the glow
       * @returns true if ready otherwise, false
       */
      _isReady(subMesh, useInstances, emissiveTexture) {
        return this._internalThinEffectLayer ? this._thinEffectLayer._internalIsSubMeshReady(subMesh, useInstances, emissiveTexture) : this._thinEffectLayer._isSubMeshReady(subMesh, useInstances, emissiveTexture);
      }
      async _importShadersAsync() {
      }
      _arePostProcessAndMergeReady() {
        return this._internalThinEffectLayer ? this._thinEffectLayer._internalIsLayerReady() : this._thinEffectLayer.isLayerReady();
      }
      /**
       * Checks if the layer is ready to be used.
       * @returns true if the layer is ready to be used
       */
      isLayerReady() {
        return this._arePostProcessAndMergeReady() && this._mainTexture.isReady();
      }
      /**
       * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.
       */
      render() {
        if (!this._thinEffectLayer.compose()) {
          return;
        }
        this._setMainTextureSize();
        if ((this._mainTextureCreatedSize.width !== this._mainTextureDesiredSize.width || this._mainTextureCreatedSize.height !== this._mainTextureDesiredSize.height) && this._mainTextureDesiredSize.width !== 0 && this._mainTextureDesiredSize.height !== 0) {
          this.onSizeChangedObservable.notifyObservers(this);
          this._disposeTextureAndPostProcesses();
          this._createMainTexture();
          this._createTextureAndPostProcesses();
          this._mainTextureCreatedSize.width = this._mainTextureDesiredSize.width;
          this._mainTextureCreatedSize.height = this._mainTextureDesiredSize.height;
        }
      }
      /**
       * Determine if a given mesh will be used in the current effect.
       * @param mesh mesh to test
       * @returns true if the mesh will be used
       */
      hasMesh(mesh) {
        return this._internalThinEffectLayer ? this._thinEffectLayer._internalHasMesh(mesh) : this._thinEffectLayer.hasMesh(mesh);
      }
      /**
       * Returns true if the layer contains information to display, otherwise false.
       * @returns true if the glow layer should be rendered
       */
      shouldRender() {
        return this._internalThinEffectLayer ? this._thinEffectLayer._internalShouldRender() : this._thinEffectLayer.shouldRender();
      }
      /**
       * Returns true if the mesh should render, otherwise false.
       * @param mesh The mesh to render
       * @returns true if it should render otherwise false
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _shouldRenderMesh(mesh) {
        return this._internalThinEffectLayer ? true : this._thinEffectLayer._shouldRenderMesh(mesh);
      }
      /**
       * Returns true if the mesh can be rendered, otherwise false.
       * @param mesh The mesh to render
       * @param material The material used on the mesh
       * @returns true if it can be rendered otherwise false
       */
      _canRenderMesh(mesh, material) {
        return this._internalThinEffectLayer ? this._thinEffectLayer._internalCanRenderMesh(mesh, material) : this._thinEffectLayer._canRenderMesh(mesh, material);
      }
      /**
       * Returns true if the mesh should render, otherwise false.
       * @returns true if it should render otherwise false
       */
      _shouldRenderEmissiveTextureForMesh() {
        return true;
      }
      /**
       * Defines whether the current material of the mesh should be use to render the effect.
       * @param mesh defines the current mesh to render
       * @returns true if the mesh material should be use
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _useMeshMaterial(mesh) {
        return this._internalThinEffectLayer ? false : this._thinEffectLayer._useMeshMaterial(mesh);
      }
      /**
       * Rebuild the required buffers.
       * @internal Internal use only.
       */
      _rebuild() {
        this._thinEffectLayer._rebuild();
      }
      /**
       * Dispose only the render target textures and post process.
       */
      _disposeTextureAndPostProcesses() {
        this._mainTexture.dispose();
        for (let i = 0; i < this._postProcesses.length; i++) {
          if (this._postProcesses[i]) {
            this._postProcesses[i].dispose();
          }
        }
        this._postProcesses = [];
        for (let i = 0; i < this._textures.length; i++) {
          if (this._textures[i]) {
            this._textures[i].dispose();
          }
        }
        this._textures = [];
      }
      /**
       * Dispose the highlight layer and free resources.
       */
      dispose() {
        this._thinEffectLayer.dispose();
        this._disposeTextureAndPostProcesses();
        this._scene.removeEffectLayer(this);
        this.onDisposeObservable.clear();
        this.onBeforeRenderMainTextureObservable.clear();
        this.onBeforeComposeObservable.clear();
        this.onBeforeRenderMeshToEffect.clear();
        this.onAfterRenderMeshToEffect.clear();
        this.onAfterComposeObservable.clear();
        this.onSizeChangedObservable.clear();
      }
      /**
       * Gets the class name of the effect layer
       * @returns the string with the class name of the effect layer
       */
      getClassName() {
        return "EffectLayer";
      }
      /**
       * Creates an effect layer from parsed effect layer data
       * @param parsedEffectLayer defines effect layer data
       * @param scene defines the current scene
       * @param rootUrl defines the root URL containing the effect layer information
       * @returns a parsed effect Layer
       */
      static Parse(parsedEffectLayer, scene, rootUrl) {
        const effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);
        return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);
      }
    };
    EffectLayer._SceneComponentInitialization = (_) => {
      throw _WarnImport("EffectLayerSceneComponent");
    };
    __decorate([
      serialize()
    ], EffectLayer.prototype, "name", null);
    __decorate([
      serializeAsColor4()
    ], EffectLayer.prototype, "neutralColor", null);
    __decorate([
      serialize()
    ], EffectLayer.prototype, "isEnabled", null);
    __decorate([
      serializeAsCameraReference()
    ], EffectLayer.prototype, "camera", null);
    __decorate([
      serialize()
    ], EffectLayer.prototype, "renderingGroupId", null);
    __decorate([
      serialize()
    ], EffectLayer.prototype, "disableBoundingBoxesFromEffectLayer", null);
  }
});

// node_modules/@babylonjs/core/Layers/effectLayerSceneComponent.js
var EffectLayerSceneComponent;
var init_effectLayerSceneComponent = __esm({
  "node_modules/@babylonjs/core/Layers/effectLayerSceneComponent.js"() {
    init_camera();
    init_sceneComponent();
    init_effectLayer();
    init_engineStore();
    init_babylonFileParser_function();
    AddParser(SceneComponentConstants.NAME_EFFECTLAYER, (parsedData, scene, container, rootUrl) => {
      if (parsedData.effectLayers) {
        if (!container.effectLayers) {
          container.effectLayers = [];
        }
        for (let index = 0; index < parsedData.effectLayers.length; index++) {
          const effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);
          container.effectLayers.push(effectLayer);
        }
      }
    });
    EffectLayerSceneComponent = class {
      /**
       * Creates a new instance of the component for the given scene
       * @param scene Defines the scene to register the component in
       */
      constructor(scene) {
        this.name = SceneComponentConstants.NAME_EFFECTLAYER;
        this._renderEffects = false;
        this._needStencil = false;
        this._previousStencilState = false;
        this.scene = scene || EngineStore.LastCreatedScene;
        if (!this.scene) {
          return;
        }
        this._engine = this.scene.getEngine();
      }
      /**
       * Registers the component in a given scene
       */
      register() {
        this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);
        this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);
        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);
        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);
        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);
        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);
      }
      /**
       * Rebuilds the elements related to this component in case of
       * context lost for instance.
       */
      rebuild() {
        const layers = this.scene.effectLayers;
        for (const effectLayer of layers) {
          effectLayer._rebuild();
        }
      }
      /**
       * Serializes the component data to the specified json object
       * @param serializationObject The object to serialize to
       */
      serialize(serializationObject) {
        serializationObject.effectLayers = [];
        const layers = this.scene.effectLayers;
        for (const effectLayer of layers) {
          if (effectLayer.serialize) {
            serializationObject.effectLayers.push(effectLayer.serialize());
          }
        }
      }
      /**
       * Adds all the elements from the container to the scene
       * @param container the container holding the elements
       */
      addFromContainer(container) {
        if (!container.effectLayers) {
          return;
        }
        for (const o of container.effectLayers) {
          this.scene.addEffectLayer(o);
        }
      }
      /**
       * Removes all the elements in the container from the scene
       * @param container contains the elements to remove
       * @param dispose if the removed element should be disposed (default: false)
       */
      removeFromContainer(container, dispose) {
        if (!container.effectLayers) {
          return;
        }
        for (const o of container.effectLayers) {
          this.scene.removeEffectLayer(o);
          if (dispose) {
            o.dispose();
          }
        }
      }
      /**
       * Disposes the component and the associated resources.
       */
      dispose() {
        const layers = this.scene.effectLayers;
        while (layers.length) {
          layers[0].dispose();
        }
      }
      _isReadyForMesh(mesh, hardwareInstancedRendering) {
        const currentRenderPassId = this._engine.currentRenderPassId;
        const layers = this.scene.effectLayers;
        for (const layer of layers) {
          if (!layer.hasMesh(mesh)) {
            continue;
          }
          const renderTarget = layer._mainTexture;
          this._engine.currentRenderPassId = renderTarget.renderPassId;
          for (const subMesh of mesh.subMeshes) {
            if (!layer.isReady(subMesh, hardwareInstancedRendering)) {
              this._engine.currentRenderPassId = currentRenderPassId;
              return false;
            }
          }
        }
        this._engine.currentRenderPassId = currentRenderPassId;
        return true;
      }
      _renderMainTexture(camera) {
        this._renderEffects = false;
        this._needStencil = false;
        let needRebind = false;
        const layers = this.scene.effectLayers;
        if (layers && layers.length > 0) {
          this._previousStencilState = this._engine.getStencilBuffer();
          for (const effectLayer of layers) {
            if (effectLayer.shouldRender() && (!effectLayer.camera || effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera || effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1)) {
              this._renderEffects = true;
              this._needStencil = this._needStencil || effectLayer.needStencil();
              const renderTarget = effectLayer._mainTexture;
              if (renderTarget._shouldRender()) {
                this.scene.incrementRenderId();
                renderTarget.render(false, false);
                needRebind = true;
              }
            }
          }
          this.scene.incrementRenderId();
        }
        return needRebind;
      }
      _setStencil() {
        if (this._needStencil) {
          this._engine.setStencilBuffer(true);
        }
      }
      _setStencilBack() {
        if (this._needStencil) {
          this._engine.setStencilBuffer(this._previousStencilState);
        }
      }
      _draw(renderingGroupId) {
        if (this._renderEffects) {
          this._engine.setDepthBuffer(false);
          const layers = this.scene.effectLayers;
          for (let i = 0; i < layers.length; i++) {
            const effectLayer = layers[i];
            if (effectLayer.renderingGroupId === renderingGroupId) {
              if (effectLayer.shouldRender()) {
                effectLayer.render();
              }
            }
          }
          this._engine.setDepthBuffer(true);
        }
      }
      _drawCamera() {
        if (this._renderEffects) {
          this._draw(-1);
        }
      }
      _drawRenderingGroup(index) {
        if (!this.scene._isInIntermediateRendering() && this._renderEffects) {
          this._draw(index);
        }
      }
    };
    EffectLayer._SceneComponentInitialization = (scene) => {
      let component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER);
      if (!component) {
        component = new EffectLayerSceneComponent(scene);
        scene._addComponent(component);
      }
    };
  }
});

// node_modules/@babylonjs/core/Layers/glowLayer.js
var GlowLayer;
var init_glowLayer = __esm({
  "node_modules/@babylonjs/core/Layers/glowLayer.js"() {
    init_tslib_es6();
    init_decorators();
    init_scene();
    init_texture();
    init_renderTargetTexture();
    init_blurPostProcess();
    init_effectLayer();
    init_typeStore();
    init_effectLayerSceneComponent();
    init_decorators_serialization();
    init_tools_functions();
    init_thinGlowLayer();
    Scene.prototype.getGlowLayerByName = function(name13) {
      for (let index = 0; index < this.effectLayers?.length; index++) {
        if (this.effectLayers[index].name === name13 && this.effectLayers[index].getEffectName() === GlowLayer.EffectName) {
          return this.effectLayers[index];
        }
      }
      return null;
    };
    GlowLayer = class _GlowLayer extends EffectLayer {
      /**
       * Effect Name of the layer.
       */
      static get EffectName() {
        return ThinGlowLayer.EffectName;
      }
      /**
       * Sets the kernel size of the blur.
       */
      set blurKernelSize(value) {
        this._thinEffectLayer.blurKernelSize = value;
      }
      /**
       * Gets the kernel size of the blur.
       */
      get blurKernelSize() {
        return this._thinEffectLayer.blurKernelSize;
      }
      /**
       * Sets the glow intensity.
       */
      set intensity(value) {
        this._thinEffectLayer.intensity = value;
      }
      /**
       * Gets the glow intensity.
       */
      get intensity() {
        return this._thinEffectLayer.intensity;
      }
      /**
       * Callback used to let the user override the color selection on a per mesh basis
       */
      get customEmissiveColorSelector() {
        return this._thinEffectLayer.customEmissiveColorSelector;
      }
      set customEmissiveColorSelector(value) {
        this._thinEffectLayer.customEmissiveColorSelector = value;
      }
      /**
       * Callback used to let the user override the texture selection on a per mesh basis
       */
      get customEmissiveTextureSelector() {
        return this._thinEffectLayer.customEmissiveTextureSelector;
      }
      set customEmissiveTextureSelector(value) {
        this._thinEffectLayer.customEmissiveTextureSelector = value;
      }
      /**
       * Instantiates a new glow Layer and references it to the scene.
       * @param name The name of the layer
       * @param scene The scene to use the layer in
       * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)
       */
      constructor(name13, scene, options) {
        super(name13, scene, false, new ThinGlowLayer(name13, scene, options));
        this._options = {
          mainTextureRatio: _GlowLayer.DefaultTextureRatio,
          blurKernelSize: 32,
          mainTextureFixedSize: void 0,
          camera: null,
          mainTextureSamples: 1,
          renderingGroupId: -1,
          ldrMerge: false,
          alphaBlendingMode: 1,
          mainTextureType: 0,
          generateStencilBuffer: false,
          excludeByDefault: false,
          ...options
        };
        this._init(this._options);
      }
      /**
       * Get the effect name of the layer.
       * @returns The effect name
       */
      getEffectName() {
        return _GlowLayer.EffectName;
      }
      /**
       * @internal
       * Create the merge effect. This is the shader use to blit the information back
       * to the main canvas at the end of the scene rendering.
       */
      _createMergeEffect() {
        return this._thinEffectLayer._createMergeEffect();
      }
      /**
       * Creates the render target textures and post processes used in the glow layer.
       */
      _createTextureAndPostProcesses() {
        this._thinEffectLayer._renderPassId = this._mainTexture.renderPassId;
        let blurTextureWidth = this._mainTextureDesiredSize.width;
        let blurTextureHeight = this._mainTextureDesiredSize.height;
        blurTextureWidth = this._engine.needPOTTextures ? GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;
        blurTextureHeight = this._engine.needPOTTextures ? GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;
        let textureType = 0;
        if (this._engine.getCaps().textureHalfFloatRender) {
          textureType = 2;
        } else {
          textureType = 0;
        }
        this._blurTexture1 = new RenderTargetTexture("GlowLayerBlurRTT", {
          width: blurTextureWidth,
          height: blurTextureHeight
        }, this._scene, false, true, textureType);
        this._blurTexture1.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._blurTexture1.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._blurTexture1.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        this._blurTexture1.renderParticles = false;
        this._blurTexture1.ignoreCameraViewport = true;
        const blurTextureWidth2 = Math.floor(blurTextureWidth / 2);
        const blurTextureHeight2 = Math.floor(blurTextureHeight / 2);
        this._blurTexture2 = new RenderTargetTexture("GlowLayerBlurRTT2", {
          width: blurTextureWidth2,
          height: blurTextureHeight2
        }, this._scene, false, true, textureType);
        this._blurTexture2.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._blurTexture2.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._blurTexture2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
        this._blurTexture2.renderParticles = false;
        this._blurTexture2.ignoreCameraViewport = true;
        this._textures = [this._blurTexture1, this._blurTexture2];
        this._thinEffectLayer.bindTexturesForCompose = (effect) => {
          effect.setTexture("textureSampler", this._blurTexture1);
          effect.setTexture("textureSampler2", this._blurTexture2);
          effect.setFloat("offset", this.intensity);
        };
        this._thinEffectLayer._createTextureAndPostProcesses();
        const thinBlurPostProcesses1 = this._thinEffectLayer._postProcesses[0];
        this._horizontalBlurPostprocess1 = new BlurPostProcess("GlowLayerHBP1", thinBlurPostProcesses1.direction, thinBlurPostProcesses1.kernel, {
          samplingMode: Texture.BILINEAR_SAMPLINGMODE,
          engine: this._scene.getEngine(),
          width: blurTextureWidth,
          height: blurTextureHeight,
          textureType,
          effectWrapper: thinBlurPostProcesses1
        });
        this._horizontalBlurPostprocess1.width = blurTextureWidth;
        this._horizontalBlurPostprocess1.height = blurTextureHeight;
        this._horizontalBlurPostprocess1.externalTextureSamplerBinding = true;
        this._horizontalBlurPostprocess1.onApplyObservable.add((effect) => {
          effect.setTexture("textureSampler", this._mainTexture);
        });
        const thinBlurPostProcesses2 = this._thinEffectLayer._postProcesses[1];
        this._verticalBlurPostprocess1 = new BlurPostProcess("GlowLayerVBP1", thinBlurPostProcesses2.direction, thinBlurPostProcesses2.kernel, {
          samplingMode: Texture.BILINEAR_SAMPLINGMODE,
          engine: this._scene.getEngine(),
          width: blurTextureWidth,
          height: blurTextureHeight,
          textureType,
          effectWrapper: thinBlurPostProcesses2
        });
        const thinBlurPostProcesses3 = this._thinEffectLayer._postProcesses[2];
        this._horizontalBlurPostprocess2 = new BlurPostProcess("GlowLayerHBP2", thinBlurPostProcesses3.direction, thinBlurPostProcesses3.kernel, {
          samplingMode: Texture.BILINEAR_SAMPLINGMODE,
          engine: this._scene.getEngine(),
          width: blurTextureWidth2,
          height: blurTextureHeight2,
          textureType,
          effectWrapper: thinBlurPostProcesses3
        });
        this._horizontalBlurPostprocess2.width = blurTextureWidth2;
        this._horizontalBlurPostprocess2.height = blurTextureHeight2;
        this._horizontalBlurPostprocess2.externalTextureSamplerBinding = true;
        this._horizontalBlurPostprocess2.onApplyObservable.add((effect) => {
          effect.setTexture("textureSampler", this._blurTexture1);
        });
        const thinBlurPostProcesses4 = this._thinEffectLayer._postProcesses[3];
        this._verticalBlurPostprocess2 = new BlurPostProcess("GlowLayerVBP2", thinBlurPostProcesses4.direction, thinBlurPostProcesses4.kernel, {
          samplingMode: Texture.BILINEAR_SAMPLINGMODE,
          engine: this._scene.getEngine(),
          width: blurTextureWidth2,
          height: blurTextureHeight2,
          textureType,
          effectWrapper: thinBlurPostProcesses4
        });
        this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];
        this._postProcesses1 = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1];
        this._postProcesses2 = [this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];
        this._mainTexture.samples = this._options.mainTextureSamples;
        this._mainTexture.onAfterUnbindObservable.add(() => {
          const internalTexture = this._blurTexture1.renderTarget;
          if (internalTexture) {
            this._scene.postProcessManager.directRender(this._postProcesses1, internalTexture, true);
            const internalTexture2 = this._blurTexture2.renderTarget;
            if (internalTexture2) {
              this._scene.postProcessManager.directRender(this._postProcesses2, internalTexture2, true);
            }
            this._engine.unBindFramebuffer(internalTexture2 ?? internalTexture, true);
          }
        });
        this._postProcesses.map((pp) => {
          pp.autoClear = false;
        });
        this._mainTextureCreatedSize.width = this._mainTextureDesiredSize.width;
        this._mainTextureCreatedSize.height = this._mainTextureDesiredSize.height;
      }
      /**
       * Checks for the readiness of the element composing the layer.
       * @param subMesh the mesh to check for
       * @param useInstances specify whether or not to use instances to render the mesh
       * @returns true if ready otherwise, false
       */
      isReady(subMesh, useInstances) {
        return this._thinEffectLayer.isReady(subMesh, useInstances);
      }
      /**
       * @returns whether or not the layer needs stencil enabled during the mesh rendering.
       */
      needStencil() {
        return false;
      }
      /**
       * Returns true if the mesh can be rendered, otherwise false.
       * @param mesh The mesh to render
       * @param material The material used on the mesh
       * @returns true if it can be rendered otherwise false
       */
      _canRenderMesh(mesh, material) {
        return this._thinEffectLayer._canRenderMesh(mesh, material);
      }
      /**
       * Implementation specific of rendering the generating effect on the main canvas.
       * @param effect The effect used to render through
       */
      _internalRender(effect) {
        this._thinEffectLayer._internalCompose(effect);
      }
      /**
       * Sets the required values for both the emissive texture and and the main color.
       * @param mesh
       * @param subMesh
       * @param material
       */
      _setEmissiveTextureAndColor(mesh, subMesh, material) {
        this._thinEffectLayer._setEmissiveTextureAndColor(mesh, subMesh, material);
      }
      /**
       * Returns true if the mesh should render, otherwise false.
       * @param mesh The mesh to render
       * @returns true if it should render otherwise false
       */
      _shouldRenderMesh(mesh) {
        return this._thinEffectLayer._shouldRenderMesh(mesh);
      }
      /**
       * Adds specific effects defines.
       * @param defines The defines to add specifics to.
       */
      _addCustomEffectDefines(defines) {
        this._thinEffectLayer._addCustomEffectDefines(defines);
      }
      /**
       * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.
       * This will not have an effect if meshes are excluded by default (see setExcludedByDefault).
       * @param mesh The mesh to exclude from the glow layer
       */
      addExcludedMesh(mesh) {
        this._thinEffectLayer.addExcludedMesh(mesh);
      }
      /**
       * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.
       * This will not have an effect if meshes are excluded by default (see setExcludedByDefault).
       * @param mesh The mesh to remove
       */
      removeExcludedMesh(mesh) {
        this._thinEffectLayer.removeExcludedMesh(mesh);
      }
      /**
       * Add a mesh in the inclusion list to impact or being impacted by the glow layer.
       * @param mesh The mesh to include in the glow layer
       */
      addIncludedOnlyMesh(mesh) {
        this._thinEffectLayer.addIncludedOnlyMesh(mesh);
      }
      /**
       * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.
       * @param mesh The mesh to remove
       */
      removeIncludedOnlyMesh(mesh) {
        this._thinEffectLayer.removeIncludedOnlyMesh(mesh);
      }
      /**
       * Set the excluded by default option.
       * If true, all meshes will be excluded by default unless they are added to the inclusion list.
       * @param value The boolean value to set the excluded by default option to
       */
      setExcludedByDefault(value) {
        this._thinEffectLayer.setExcludedByDefault(value);
      }
      /**
       * Determine if a given mesh will be used in the glow layer
       * @param mesh The mesh to test
       * @returns true if the mesh will be highlighted by the current glow layer
       */
      hasMesh(mesh) {
        return this._thinEffectLayer.hasMesh(mesh);
      }
      /**
       * Defines whether the current material of the mesh should be use to render the effect.
       * @param mesh defines the current mesh to render
       * @returns true if the material of the mesh should be use to render the effect
       */
      _useMeshMaterial(mesh) {
        return this._thinEffectLayer._useMeshMaterial(mesh);
      }
      /**
       * Add a mesh to be rendered through its own material and not with emissive only.
       * @param mesh The mesh for which we need to use its material
       */
      referenceMeshToUseItsOwnMaterial(mesh) {
        this._thinEffectLayer.referenceMeshToUseItsOwnMaterial(mesh);
      }
      /**
       * Remove a mesh from being rendered through its own material and not with emissive only.
       * @param mesh The mesh for which we need to not use its material
       */
      unReferenceMeshFromUsingItsOwnMaterial(mesh) {
        this._thinEffectLayer.unReferenceMeshFromUsingItsOwnMaterial(mesh, this._mainTexture.renderPassId);
      }
      /**
       * Free any resources and references associated to a mesh.
       * Internal use
       * @param mesh The mesh to free.
       * @internal
       */
      _disposeMesh(mesh) {
        this._thinEffectLayer._disposeMesh(mesh);
      }
      /**
       * Gets the class name of the effect layer
       * @returns the string with the class name of the effect layer
       */
      getClassName() {
        return "GlowLayer";
      }
      /**
       * Serializes this glow layer
       * @returns a serialized glow layer object
       */
      serialize() {
        const serializationObject = SerializationHelper.Serialize(this);
        serializationObject.customType = "BABYLON.GlowLayer";
        let index;
        serializationObject.includedMeshes = [];
        const includedOnlyMeshes = this._thinEffectLayer._includedOnlyMeshes;
        if (includedOnlyMeshes.length) {
          for (index = 0; index < includedOnlyMeshes.length; index++) {
            const mesh = this._scene.getMeshByUniqueId(includedOnlyMeshes[index]);
            if (mesh) {
              serializationObject.includedMeshes.push(mesh.id);
            }
          }
        }
        serializationObject.excludedMeshes = [];
        const excludedMeshes = this._thinEffectLayer._excludedMeshes;
        if (excludedMeshes.length) {
          for (index = 0; index < excludedMeshes.length; index++) {
            const mesh = this._scene.getMeshByUniqueId(excludedMeshes[index]);
            if (mesh) {
              serializationObject.excludedMeshes.push(mesh.id);
            }
          }
        }
        return serializationObject;
      }
      /**
       * Creates a Glow Layer from parsed glow layer data
       * @param parsedGlowLayer defines glow layer data
       * @param scene defines the current scene
       * @param rootUrl defines the root URL containing the glow layer information
       * @returns a parsed Glow Layer
       */
      static Parse(parsedGlowLayer, scene, rootUrl) {
        const gl = SerializationHelper.Parse(() => new _GlowLayer(parsedGlowLayer.name, scene, parsedGlowLayer.options), parsedGlowLayer, scene, rootUrl);
        let index;
        for (index = 0; index < parsedGlowLayer.excludedMeshes.length; index++) {
          const mesh = scene.getMeshById(parsedGlowLayer.excludedMeshes[index]);
          if (mesh) {
            gl.addExcludedMesh(mesh);
          }
        }
        for (index = 0; index < parsedGlowLayer.includedMeshes.length; index++) {
          const mesh = scene.getMeshById(parsedGlowLayer.includedMeshes[index]);
          if (mesh) {
            gl.addIncludedOnlyMesh(mesh);
          }
        }
        return gl;
      }
    };
    GlowLayer.DefaultBlurKernelSize = 32;
    GlowLayer.DefaultTextureRatio = 0.5;
    __decorate([
      serialize()
    ], GlowLayer.prototype, "blurKernelSize", null);
    __decorate([
      serialize()
    ], GlowLayer.prototype, "intensity", null);
    __decorate([
      serialize("options")
    ], GlowLayer.prototype, "_options", void 0);
    RegisterClass("BABYLON.GlowLayer", GlowLayer);
  }
});

// node_modules/@babylonjs/core/Lights/Shadows/shadowGeneratorSceneComponent.js
var ShadowGeneratorSceneComponent;
var init_shadowGeneratorSceneComponent = __esm({
  "node_modules/@babylonjs/core/Lights/Shadows/shadowGeneratorSceneComponent.js"() {
    init_shadowGenerator();
    init_cascadedShadowGenerator();
    init_sceneComponent();
    init_babylonFileParser_function();
    AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, (parsedData, scene) => {
      if (parsedData.shadowGenerators !== void 0 && parsedData.shadowGenerators !== null) {
        for (let index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {
          const parsedShadowGenerator = parsedData.shadowGenerators[index];
          if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {
            CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);
          } else {
            ShadowGenerator.Parse(parsedShadowGenerator, scene);
          }
        }
      }
    });
    ShadowGeneratorSceneComponent = class {
      /**
       * Creates a new instance of the component for the given scene
       * @param scene Defines the scene to register the component in
       */
      constructor(scene) {
        this.name = SceneComponentConstants.NAME_SHADOWGENERATOR;
        this.scene = scene;
      }
      /**
       * Registers the component in a given scene
       */
      register() {
        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);
      }
      /**
       * Rebuilds the elements related to this component in case of
       * context lost for instance.
       */
      rebuild() {
      }
      /**
       * Serializes the component data to the specified json object
       * @param serializationObject The object to serialize to
       */
      serialize(serializationObject) {
        serializationObject.shadowGenerators = [];
        const lights = this.scene.lights;
        for (const light of lights) {
          if (light.doNotSerialize) {
            continue;
          }
          const shadowGenerators = light.getShadowGenerators();
          if (shadowGenerators) {
            const iterator = shadowGenerators.values();
            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
              const shadowGenerator = key.value;
              if (shadowGenerator.doNotSerialize) {
                continue;
              }
              serializationObject.shadowGenerators.push(shadowGenerator.serialize());
            }
          }
        }
      }
      /**
       * Adds all the elements from the container to the scene
       * @param container the container holding the elements
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      addFromContainer(container) {
      }
      /**
       * Removes all the elements in the container from the scene
       * @param container contains the elements to remove
       * @param dispose if the removed element should be disposed (default: false)
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      removeFromContainer(container, dispose) {
      }
      /**
       * Rebuilds the elements related to this component in case of
       * context lost for instance.
       */
      dispose() {
      }
      _gatherRenderTargets(renderTargets) {
        const scene = this.scene;
        if (this.scene.shadowsEnabled) {
          for (let lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {
            const light = scene.lights[lightIndex];
            const shadowGenerators = light.getShadowGenerators();
            if (light.isEnabled() && light.shadowEnabled && shadowGenerators) {
              const iterator = shadowGenerators.values();
              for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
                const shadowGenerator = key.value;
                const shadowMap = shadowGenerator.getShadowMap();
                if (scene.textures.indexOf(shadowMap) !== -1) {
                  renderTargets.push(shadowMap);
                }
              }
            }
          }
        }
      }
    };
    ShadowGenerator._SceneComponentInitialization = (scene) => {
      let component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);
      if (!component) {
        component = new ShadowGeneratorSceneComponent(scene);
        scene._addComponent(component);
      }
    };
  }
});

// node_modules/@babylonjs/core/Lights/pointLight.js
var PointLight;
var init_pointLight = __esm({
  "node_modules/@babylonjs/core/Lights/pointLight.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_node();
    init_light();
    init_shadowLight();
    init_typeStore();
    Node.AddNodeConstructor("Light_Type_0", (name13, scene) => {
      return () => new PointLight(name13, Vector3.Zero(), scene);
    });
    PointLight = class extends ShadowLight {
      /**
       * Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
       * This specifies what angle the shadow will use to be created.
       *
       * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
       */
      get shadowAngle() {
        return this._shadowAngle;
      }
      /**
       * Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
       * This specifies what angle the shadow will use to be created.
       *
       * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
       */
      set shadowAngle(value) {
        this._shadowAngle = value;
        this.forceProjectionMatrixCompute();
      }
      /**
       * Gets the direction if it has been set.
       * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
       */
      get direction() {
        return this._direction;
      }
      /**
       * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
       */
      set direction(value) {
        const previousNeedCube = this.needCube();
        this._direction = value;
        if (this.needCube() !== previousNeedCube && this._shadowGenerators) {
          const iterator = this._shadowGenerators.values();
          for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
            const shadowGenerator = key.value;
            shadowGenerator.recreateShadowMap();
          }
        }
      }
      /**
       * Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.
       * A PointLight emits the light in every direction.
       * It can cast shadows.
       * If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :
       * ```javascript
       * var pointLight = new PointLight("pl", camera.position, scene);
       * ```
       * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
       * @param name The light friendly name
       * @param position The position of the point light in the scene
       * @param scene The scene the lights belongs to
       * @param dontAddToScene True to not add the light to the scene
       */
      constructor(name13, position, scene, dontAddToScene) {
        super(name13, scene, dontAddToScene);
        this._shadowAngle = Math.PI / 2;
        this.position = position;
      }
      /**
       * Returns the string "PointLight"
       * @returns the class name
       */
      getClassName() {
        return "PointLight";
      }
      /**
       * Returns the integer 0.
       * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      getTypeID() {
        return Light.LIGHTTYPEID_POINTLIGHT;
      }
      /**
       * Specifies whether or not the shadowmap should be a cube texture.
       * @returns true if the shadowmap needs to be a cube texture.
       */
      needCube() {
        return !this.direction;
      }
      /**
       * Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).
       * @param faceIndex The index of the face we are computed the direction to generate shadow
       * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
       */
      getShadowDirection(faceIndex) {
        if (this.direction) {
          return super.getShadowDirection(faceIndex);
        } else {
          switch (faceIndex) {
            case 0:
              return new Vector3(1, 0, 0);
            case 1:
              return new Vector3(-1, 0, 0);
            case 2:
              return new Vector3(0, -1, 0);
            case 3:
              return new Vector3(0, 1, 0);
            case 4:
              return new Vector3(0, 0, 1);
            case 5:
              return new Vector3(0, 0, -1);
          }
        }
        return Vector3.Zero();
      }
      /**
       * Sets the passed matrix "matrix" as a left-handed perspective projection matrix with the following settings :
       * - fov = PI / 2
       * - aspect ratio : 1.0
       * - z-near and far equal to the active camera minZ and maxZ.
       * Returns the PointLight.
       * @param matrix
       * @param viewMatrix
       * @param renderList
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {
        const activeCamera = this.getScene().activeCamera;
        const minZ = this.getDepthMinZ(activeCamera);
        const maxZ = this.getDepthMaxZ(activeCamera);
        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
        Matrix.PerspectiveFovLHToRef(this.shadowAngle, 1, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, true, this._scene.getEngine().isNDCHalfZRange, void 0, useReverseDepthBuffer);
      }
      _buildUniformLayout() {
        this._uniformBuffer.addUniform("vLightData", 4);
        this._uniformBuffer.addUniform("vLightDiffuse", 4);
        this._uniformBuffer.addUniform("vLightSpecular", 4);
        this._uniformBuffer.addUniform("vLightFalloff", 4);
        this._uniformBuffer.addUniform("shadowsInfo", 3);
        this._uniformBuffer.addUniform("depthValues", 2);
        this._uniformBuffer.create();
      }
      /**
       * Sets the passed Effect "effect" with the PointLight transformed position (or position, if none) and passed name (string).
       * @param effect The effect to update
       * @param lightIndex The index of the light in the effect to update
       * @returns The point light
       */
      transferToEffect(effect, lightIndex) {
        const offset = this._scene.floatingOriginOffset;
        if (this.computeTransformedInformation()) {
          this._uniformBuffer.updateFloat4("vLightData", this.transformedPosition.x - offset.x, this.transformedPosition.y - offset.y, this.transformedPosition.z - offset.z, 0, lightIndex);
        } else {
          this._uniformBuffer.updateFloat4("vLightData", this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z, 0, lightIndex);
        }
        this._uniformBuffer.updateFloat4("vLightFalloff", this.range, this._inverseSquaredRange, 0, 0, lightIndex);
        return this;
      }
      transferToNodeMaterialEffect(effect, lightDataUniformName) {
        const offset = this._scene.floatingOriginOffset;
        if (this.computeTransformedInformation()) {
          effect.setFloat3(lightDataUniformName, this.transformedPosition.x - offset.x, this.transformedPosition.y - offset.y, this.transformedPosition.z - offset.z);
        } else {
          effect.setFloat3(lightDataUniformName, this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z);
        }
        return this;
      }
      /**
       * Prepares the list of defines specific to the light type.
       * @param defines the list of defines
       * @param lightIndex defines the index of the light for the effect
       */
      prepareLightSpecificDefines(defines, lightIndex) {
        defines["POINTLIGHT" + lightIndex] = true;
      }
    };
    __decorate([
      serialize()
    ], PointLight.prototype, "shadowAngle", null);
    RegisterClass("BABYLON.PointLight", PointLight);
  }
});

// node_modules/@babylonjs/core/Lights/LTC/ltcTextureTool.js
async function DecodeLTCTextureDataAsync() {
  const ltc1 = new Uint16Array(64 * 64 * 4);
  const ltc2 = new Uint16Array(64 * 64 * 4);
  const file = await Tools.LoadFileAsync(Tools.GetAssetUrl("https://assets.babylonjs.com/core/areaLights/areaLightsLTC.bin"));
  const ltcEncoded = new Uint16Array(file);
  const pixelCount = ltcEncoded.length / 8;
  for (let pixelIndex = 0; pixelIndex < pixelCount; pixelIndex++) {
    ltc1[pixelIndex * 4] = ltcEncoded[pixelIndex * 8];
    ltc1[pixelIndex * 4 + 1] = ltcEncoded[pixelIndex * 8 + 1];
    ltc1[pixelIndex * 4 + 2] = ltcEncoded[pixelIndex * 8 + 2];
    ltc1[pixelIndex * 4 + 3] = ltcEncoded[pixelIndex * 8 + 3];
    ltc2[pixelIndex * 4] = ltcEncoded[pixelIndex * 8 + 4];
    ltc2[pixelIndex * 4 + 1] = ltcEncoded[pixelIndex * 8 + 5];
    ltc2[pixelIndex * 4 + 2] = ltcEncoded[pixelIndex * 8 + 6];
    ltc2[pixelIndex * 4 + 3] = ltcEncoded[pixelIndex * 8 + 7];
  }
  return [ltc1, ltc2];
}
var init_ltcTextureTool = __esm({
  "node_modules/@babylonjs/core/Lights/LTC/ltcTextureTool.js"() {
    init_tools();
  }
});

// node_modules/@babylonjs/core/Lights/areaLight.js
function CreateSceneLTCTextures(scene) {
  const useDelayedTextureLoading = scene.useDelayedTextureLoading;
  scene.useDelayedTextureLoading = false;
  const previousState = scene._blockEntityCollection;
  scene._blockEntityCollection = false;
  scene._ltcTextures = {
    LTC1: RawTexture.CreateRGBATexture(null, 64, 64, scene.getEngine(), false, false, 2, 2, 0, false, true),
    LTC2: RawTexture.CreateRGBATexture(null, 64, 64, scene.getEngine(), false, false, 2, 2, 0, false, true)
  };
  scene._blockEntityCollection = previousState;
  scene._ltcTextures.LTC1.wrapU = Texture.CLAMP_ADDRESSMODE;
  scene._ltcTextures.LTC1.wrapV = Texture.CLAMP_ADDRESSMODE;
  scene._ltcTextures.LTC2.wrapU = Texture.CLAMP_ADDRESSMODE;
  scene._ltcTextures.LTC2.wrapV = Texture.CLAMP_ADDRESSMODE;
  scene.useDelayedTextureLoading = useDelayedTextureLoading;
  DecodeLTCTextureDataAsync().then((textureData) => {
    if (scene._ltcTextures) {
      const ltc1 = scene._ltcTextures?.LTC1;
      ltc1.update(textureData[0]);
      const ltc2 = scene._ltcTextures?.LTC2;
      ltc2.update(textureData[1]);
      scene.onDisposeObservable.addOnce(() => {
        scene._ltcTextures?.LTC1.dispose();
        scene._ltcTextures?.LTC2.dispose();
      });
    }
  }).catch((error) => {
    Logger.Error(`Area Light fail to get LTC textures data. Error: ${error}`);
  });
}
var AreaLight;
var init_areaLight = __esm({
  "node_modules/@babylonjs/core/Lights/areaLight.js"() {
    init_rawTexture();
    init_texture();
    init_light();
    init_ltcTextureTool();
    init_logger();
    AreaLight = class extends Light {
      /**
       * Creates a area light object.
       * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
       * @param name The friendly name of the light
       * @param position The position of the area light.
       * @param scene The scene the light belongs to
       * @param dontAddToScene True to not add the light to the scene
       */
      constructor(name13, position, scene, dontAddToScene) {
        super(name13, scene, dontAddToScene);
        this.position = position;
        if (!this._scene._ltcTextures) {
          CreateSceneLTCTextures(this._scene);
        }
      }
      transferTexturesToEffect(effect, lightIndex) {
        if (this._scene._ltcTextures) {
          effect.setTexture("areaLightsLTC1Sampler", this._scene._ltcTextures.LTC1);
          effect.setTexture("areaLightsLTC2Sampler", this._scene._ltcTextures.LTC2);
        }
        return this;
      }
      /**
       * Prepares the list of defines specific to the light type.
       * @param defines the list of defines
       * @param lightIndex defines the index of the light for the effect
       */
      prepareLightSpecificDefines(defines, lightIndex) {
        defines["AREALIGHT" + lightIndex] = true;
        defines["AREALIGHTUSED"] = true;
      }
      _isReady() {
        if (this._scene._ltcTextures) {
          return this._scene._ltcTextures.LTC1.isReady() && this._scene._ltcTextures.LTC2.isReady();
        }
        return false;
      }
    };
  }
});

// node_modules/@babylonjs/core/Lights/rectAreaLight.js
var RectAreaLight;
var init_rectAreaLight = __esm({
  "node_modules/@babylonjs/core/Lights/rectAreaLight.js"() {
    init_tslib_es6();
    init_math_vector();
    init_node();
    init_light();
    init_typeStore();
    init_decorators();
    init_areaLight();
    Node.AddNodeConstructor("Light_Type_4", (name13, scene) => {
      return () => new RectAreaLight(name13, Vector3.Zero(), 1, 1, scene);
    });
    RectAreaLight = class _RectAreaLight extends AreaLight {
      /**
       * Gets Rect Area Light emission texture. (Note: This texture needs pre-processing! Use AreaLightTextureTools to pre-process the texture).
       */
      get emissionTexture() {
        return this._emissionTextureTexture;
      }
      /**
       * Sets Rect Area Light emission texture. (Note: This texture needs pre-processing! Use AreaLightTextureTools to pre-process the texture).
       */
      set emissionTexture(value) {
        if (this._emissionTextureTexture === value) {
          return;
        }
        this._emissionTextureTexture = value;
        if (this._emissionTextureTexture) {
          this._emissionTextureTexture.wrapU = 0;
          this._emissionTextureTexture.wrapV = 0;
        }
        if (this._emissionTextureTexture && _RectAreaLight._IsTexture(this._emissionTextureTexture)) {
          this._emissionTextureTexture.onLoadObservable.addOnce(() => {
            this._markMeshesAsLightDirty();
          });
        }
      }
      /**
       * Rect Area Light width.
       */
      get width() {
        return this._width.x;
      }
      /**
       * Rect Area Light width.
       */
      set width(value) {
        this._width.x = value;
      }
      /**
       * Rect Area Light height.
       */
      get height() {
        return this._height.y;
      }
      /**
       * Rect Area Light height.
       */
      set height(value) {
        this._height.y = value;
      }
      /**
       * Creates a rectangular area light object.
       * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
       * @param name The friendly name of the light
       * @param position The position of the area light.
       * @param width The width of the area light.
       * @param height The height of the area light.
       * @param scene The scene the light belongs to
       * @param dontAddToScene True to not add the light to the scene
       */
      constructor(name13, position, width, height, scene, dontAddToScene) {
        super(name13, position, scene, dontAddToScene);
        this._emissionTextureTexture = null;
        this._width = new Vector3(width, 0, 0);
        this._height = new Vector3(0, height, 0);
        this._pointTransformedPosition = Vector3.Zero();
        this._pointTransformedWidth = Vector3.Zero();
        this._pointTransformedHeight = Vector3.Zero();
      }
      /**
       * Returns the string "RectAreaLight"
       * @returns the class name
       */
      getClassName() {
        return "RectAreaLight";
      }
      /**
       * Returns the integer 4.
       * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      getTypeID() {
        return Light.LIGHTTYPEID_RECT_AREALIGHT;
      }
      _buildUniformLayout() {
        this._uniformBuffer.addUniform("vLightData", 4);
        this._uniformBuffer.addUniform("vLightDiffuse", 4);
        this._uniformBuffer.addUniform("vLightSpecular", 4);
        this._uniformBuffer.addUniform("vLightWidth", 4);
        this._uniformBuffer.addUniform("vLightHeight", 4);
        this._uniformBuffer.addUniform("shadowsInfo", 3);
        this._uniformBuffer.addUniform("depthValues", 2);
        this._uniformBuffer.create();
      }
      _computeTransformedInformation() {
        if (this.parent && this.parent.getWorldMatrix) {
          Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this._pointTransformedPosition);
          Vector3.TransformNormalToRef(this._width, this.parent.getWorldMatrix(), this._pointTransformedWidth);
          Vector3.TransformNormalToRef(this._height, this.parent.getWorldMatrix(), this._pointTransformedHeight);
          return true;
        }
        return false;
      }
      static _IsTexture(texture) {
        return texture.onLoadObservable !== void 0;
      }
      /**
       * Sets the passed Effect "effect" with the PointLight transformed position (or position, if none) and passed name (string).
       * @param effect The effect to update
       * @param lightIndex The index of the light in the effect to update
       * @returns The point light
       */
      transferToEffect(effect, lightIndex) {
        const offset = this._scene.floatingOriginOffset;
        if (this._computeTransformedInformation()) {
          this._uniformBuffer.updateFloat4("vLightData", this._pointTransformedPosition.x - offset.x, this._pointTransformedPosition.y - offset.y, this._pointTransformedPosition.z - offset.z, 0, lightIndex);
          this._uniformBuffer.updateFloat4("vLightWidth", this._pointTransformedWidth.x / 2, this._pointTransformedWidth.y / 2, this._pointTransformedWidth.z / 2, 0, lightIndex);
          this._uniformBuffer.updateFloat4("vLightHeight", this._pointTransformedHeight.x / 2, this._pointTransformedHeight.y / 2, this._pointTransformedHeight.z / 2, 0, lightIndex);
        } else {
          this._uniformBuffer.updateFloat4("vLightData", this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z, 0, lightIndex);
          this._uniformBuffer.updateFloat4("vLightWidth", this._width.x / 2, this._width.y / 2, this._width.z / 2, 0, lightIndex);
          this._uniformBuffer.updateFloat4("vLightHeight", this._height.x / 2, this._height.y / 2, this._height.z / 2, 0, lightIndex);
        }
        return this;
      }
      transferTexturesToEffect(effect, lightIndex) {
        super.transferTexturesToEffect(effect, lightIndex);
        if (this._emissionTextureTexture && this._emissionTextureTexture.isReady()) {
          effect.setTexture("rectAreaLightEmissionTexture" + lightIndex, this._emissionTextureTexture);
        }
        return this;
      }
      transferToNodeMaterialEffect(effect, lightDataUniformName) {
        const offset = this._scene.floatingOriginOffset;
        if (this._computeTransformedInformation()) {
          effect.setFloat3(lightDataUniformName, this._pointTransformedPosition.x - offset.x, this._pointTransformedPosition.y - offset.y, this._pointTransformedPosition.z - offset.z);
        } else {
          effect.setFloat3(lightDataUniformName, this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z);
        }
        return this;
      }
      /**
       * Prepares the list of defines specific to the light type.
       * @param defines the list of defines
       * @param lightIndex defines the index of the light for the effect
       */
      prepareLightSpecificDefines(defines, lightIndex) {
        super.prepareLightSpecificDefines(defines, lightIndex);
        defines["RECTAREALIGHTEMISSIONTEXTURE" + lightIndex] = this._emissionTextureTexture && this._emissionTextureTexture.isReady() ? true : false;
      }
    };
    __decorate([
      serialize()
    ], RectAreaLight.prototype, "width", null);
    __decorate([
      serialize()
    ], RectAreaLight.prototype, "height", null);
    RegisterClass("BABYLON.RectAreaLight", RectAreaLight);
  }
});

// node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js
var init_thinInstanceMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js"() {
    init_mesh();
    init_buffer();
    init_math_vector();
    init_logger();
    init_boundingInfo();
    Mesh.prototype.thinInstanceAdd = function(matrix, refresh = true) {
      if (!this.getScene().getEngine().getCaps().instancedArrays) {
        Logger.Error("Thin Instances are not supported on this device as Instanced Array extension not supported");
        return -1;
      }
      this._thinInstanceUpdateBufferSize("matrix", Array.isArray(matrix) ? matrix.length : 1);
      const index = this._thinInstanceDataStorage.instancesCount;
      if (Array.isArray(matrix)) {
        for (let i = 0; i < matrix.length; ++i) {
          this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);
        }
      } else {
        this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);
      }
      return index;
    };
    Mesh.prototype.thinInstanceAddSelf = function(refresh = true) {
      return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);
    };
    Mesh.prototype.thinInstanceRegisterAttribute = function(kind, stride) {
      if (kind === VertexBuffer.ColorKind) {
        kind = VertexBuffer.ColorInstanceKind;
      }
      this.removeVerticesData(kind);
      this._thinInstanceInitializeUserStorage();
      this._userThinInstanceBuffersStorage.strides[kind] = stride;
      this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount);
      this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);
      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);
      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
    };
    Mesh.prototype.thinInstanceSetMatrixAt = function(index, matrix, refresh = true) {
      if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {
        return false;
      }
      const matrixData = this._thinInstanceDataStorage.matrixData;
      matrix.copyToArray(matrixData, index * 16);
      if (this._thinInstanceDataStorage.worldMatrices) {
        this._thinInstanceDataStorage.worldMatrices[index] = matrix;
      }
      if (refresh) {
        this.thinInstanceBufferUpdated("matrix");
        if (!this.doNotSyncBoundingInfo) {
          this.thinInstanceRefreshBoundingInfo(false);
        }
      }
      return true;
    };
    Mesh.prototype.thinInstanceSetAttributeAt = function(kind, index, value, refresh = true) {
      if (kind === VertexBuffer.ColorKind) {
        kind = VertexBuffer.ColorInstanceKind;
      }
      if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {
        return false;
      }
      this._thinInstanceUpdateBufferSize(kind, 0);
      this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);
      if (refresh) {
        this.thinInstanceBufferUpdated(kind);
      }
      return true;
    };
    Object.defineProperty(Mesh.prototype, "thinInstanceCount", {
      get: function() {
        return this._thinInstanceDataStorage.instancesCount;
      },
      set: function(value) {
        const matrixData = this._thinInstanceDataStorage.matrixData ?? this.source?._thinInstanceDataStorage.matrixData;
        const numMaxInstances = matrixData ? matrixData.length / 16 : 0;
        if (value <= numMaxInstances) {
          this._thinInstanceDataStorage.instancesCount = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Mesh.prototype._thinInstanceCreateMatrixBuffer = function(kind, buffer, staticBuffer = true) {
      const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);
      for (let i = 0; i < 4; i++) {
        this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));
      }
      return matrixBuffer;
    };
    Mesh.prototype.thinInstanceSetBuffer = function(kind, buffer, stride = 0, staticBuffer = true) {
      stride = stride || 16;
      if (kind === "matrix") {
        this._thinInstanceDataStorage.matrixBuffer?.dispose();
        this._thinInstanceDataStorage.matrixBuffer = null;
        this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;
        this._thinInstanceDataStorage.matrixData = buffer;
        this._thinInstanceDataStorage.worldMatrices = null;
        if (buffer !== null) {
          this._thinInstanceDataStorage.instancesCount = buffer.length / stride;
          this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", buffer, staticBuffer);
          if (!this.doNotSyncBoundingInfo) {
            this.thinInstanceRefreshBoundingInfo(false);
          }
        } else {
          this._thinInstanceDataStorage.instancesCount = 0;
          if (!this.doNotSyncBoundingInfo) {
            this.refreshBoundingInfo();
          }
        }
      } else if (kind === "previousMatrix") {
        this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();
        this._thinInstanceDataStorage.previousMatrixBuffer = null;
        this._thinInstanceDataStorage.previousMatrixData = buffer;
        if (buffer !== null) {
          this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", buffer, staticBuffer);
        }
      } else if (kind === "splatIndex" && buffer) {
        this._thinInstanceInitializeUserStorage();
        this._thinInstanceDataStorage.instancesCount = buffer.length / stride;
        this._userThinInstanceBuffersStorage.data[kind] = buffer;
        this._userThinInstanceBuffersStorage.strides[kind] = stride;
        this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;
        const splatInstancesBuffer = new Buffer(this.getEngine(), buffer, true, 16, false, true);
        this._thinInstanceDataStorage.matrixBuffer = splatInstancesBuffer;
        for (let i = 0; i < 4; i++) {
          this.setVerticesBuffer(splatInstancesBuffer.createVertexBuffer(kind + i, i * 4, 4));
        }
      } else {
        if (kind === VertexBuffer.ColorKind) {
          kind = VertexBuffer.ColorInstanceKind;
        }
        if (buffer === null) {
          if (this._userThinInstanceBuffersStorage?.data[kind]) {
            this.removeVerticesData(kind);
            delete this._userThinInstanceBuffersStorage.data[kind];
            delete this._userThinInstanceBuffersStorage.strides[kind];
            delete this._userThinInstanceBuffersStorage.sizes[kind];
            delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];
          }
        } else {
          this._thinInstanceInitializeUserStorage();
          this._userThinInstanceBuffersStorage.data[kind] = buffer;
          this._userThinInstanceBuffersStorage.strides[kind] = stride;
          this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;
          this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);
          this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
        }
      }
    };
    Mesh.prototype.thinInstanceBufferUpdated = function(kind) {
      if (kind === "matrix") {
        if (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.matrixBuffer && !this._thinInstanceDataStorage.matrixBuffer.isUpdatable()) {
          this._thinInstanceRecreateBuffer(kind);
        }
        this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount);
      } else if (kind === "previousMatrix") {
        if (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.previousMatrixBuffer && !this._thinInstanceDataStorage.previousMatrixBuffer.isUpdatable()) {
          this._thinInstanceRecreateBuffer(kind);
        }
        this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData, 0, this._thinInstanceDataStorage.instancesCount);
      } else if (kind === "splatIndex") {
        this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0, this._thinInstanceDataStorage.instancesCount);
      } else {
        if (kind === VertexBuffer.ColorKind) {
          kind = VertexBuffer.ColorInstanceKind;
        }
        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {
          if (this.thinInstanceAllowAutomaticStaticBufferRecreation && !this._userThinInstanceBuffersStorage.vertexBuffers[kind].isUpdatable()) {
            this._thinInstanceRecreateBuffer(kind);
          }
          this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);
        }
      }
    };
    Mesh.prototype.thinInstancePartialBufferUpdate = function(kind, data, offset) {
      if (kind === "matrix") {
        if (this._thinInstanceDataStorage.matrixBuffer) {
          this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);
        }
      } else {
        if (kind === VertexBuffer.ColorKind) {
          kind = VertexBuffer.ColorInstanceKind;
        }
        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {
          this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(data, offset);
        }
      }
    };
    Mesh.prototype.thinInstanceGetWorldMatrices = function() {
      if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
        return [];
      }
      const matrixData = this._thinInstanceDataStorage.matrixData;
      if (!this._thinInstanceDataStorage.worldMatrices) {
        this._thinInstanceDataStorage.worldMatrices = [];
        for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {
          this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);
        }
      }
      return this._thinInstanceDataStorage.worldMatrices;
    };
    Mesh.prototype.thinInstanceRefreshBoundingInfo = function(forceRefreshParentInfo = false, applySkeleton = false, applyMorph = false) {
      if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
        return;
      }
      const vectors = this._thinInstanceDataStorage.boundingVectors;
      if (forceRefreshParentInfo || !this.rawBoundingInfo) {
        vectors.length = 0;
        this.refreshBoundingInfo(applySkeleton, applyMorph);
        const boundingInfo2 = this.getBoundingInfo();
        this.rawBoundingInfo = new BoundingInfo(boundingInfo2.minimum, boundingInfo2.maximum);
      }
      const boundingInfo = this.getBoundingInfo();
      const matrixData = this._thinInstanceDataStorage.matrixData;
      if (vectors.length === 0) {
        for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {
          vectors.push(boundingInfo.boundingBox.vectors[v].clone());
        }
      }
      TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY);
      TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY);
      for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {
        Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);
        for (let v = 0; v < vectors.length; ++v) {
          Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);
          TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);
          TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);
        }
      }
      boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);
      this._updateBoundingInfo();
    };
    Mesh.prototype._thinInstanceRecreateBuffer = function(kind, staticBuffer = true) {
      if (kind === "matrix") {
        this._thinInstanceDataStorage.matrixBuffer?.dispose();
        this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", this._thinInstanceDataStorage.matrixData, staticBuffer);
      } else if (kind === "previousMatrix") {
        if (this._scene.needsPreviousWorldMatrices) {
          this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();
          this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.previousMatrixData ?? this._thinInstanceDataStorage.matrixData, staticBuffer);
        }
      } else {
        if (kind === VertexBuffer.ColorKind) {
          kind = VertexBuffer.ColorInstanceKind;
        }
        this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();
        this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, !staticBuffer, false, this._userThinInstanceBuffersStorage.strides[kind], true);
        this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
      }
    };
    Mesh.prototype._thinInstanceUpdateBufferSize = function(kind, numInstances = 1) {
      if (kind === VertexBuffer.ColorKind) {
        kind = VertexBuffer.ColorInstanceKind;
      }
      const kindIsMatrix = kind === "matrix";
      if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {
        return;
      }
      const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];
      const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];
      let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];
      const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;
      let newSize = currentSize;
      while (newSize < bufferSize) {
        newSize *= 2;
      }
      if (!data || currentSize != newSize) {
        if (!data) {
          data = new Float32Array(newSize);
        } else {
          const newData = new Float32Array(newSize);
          newData.set(data, 0);
          data = newData;
        }
        if (kindIsMatrix) {
          this._thinInstanceDataStorage.matrixBuffer?.dispose();
          this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", data, false);
          this._thinInstanceDataStorage.matrixData = data;
          this._thinInstanceDataStorage.matrixBufferSize = newSize;
          if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {
            this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();
            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", data, false);
          }
        } else {
          this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();
          this._userThinInstanceBuffersStorage.data[kind] = data;
          this._userThinInstanceBuffersStorage.sizes[kind] = newSize;
          this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);
          this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
        }
      }
    };
    Mesh.prototype._thinInstanceInitializeUserStorage = function() {
      if (!this._userThinInstanceBuffersStorage) {
        this._userThinInstanceBuffersStorage = {
          data: {},
          sizes: {},
          vertexBuffers: {},
          strides: {}
        };
      }
    };
    Mesh.prototype._disposeThinInstanceSpecificData = function() {
      if (this._thinInstanceDataStorage?.matrixBuffer) {
        this._thinInstanceDataStorage.matrixBuffer.dispose();
        this._thinInstanceDataStorage.matrixBuffer = null;
      }
      if (this._thinInstanceDataStorage?.previousMatrixBuffer) {
        this._thinInstanceDataStorage.previousMatrixBuffer.dispose();
        this._thinInstanceDataStorage.previousMatrixBuffer = null;
      }
    };
  }
});

// node_modules/@babylonjs/core/Lights/Clustered/clusteredLightContainer.js
var DefaultDepthSlices, ClusteredLightContainer;
var init_clusteredLightContainer = __esm({
  "node_modules/@babylonjs/core/Lights/Clustered/clusteredLightContainer.js"() {
    init_tslib_es6();
    init_storageBuffer();
    init_shaderMaterial();
    init_rawTexture();
    init_renderTargetTexture();
    init_uniformBuffer();
    init_math_color();
    init_math_vector();
    init_planeBuilder();
    init_decorators();
    init_devTools();
    init_logger();
    init_typeStore();
    init_node();
    init_light();
    init_lightConstants();
    init_thinInstanceMesh();
    Node.AddNodeConstructor("Light_Type_5", (name13, scene) => {
      return () => new ClusteredLightContainer(name13, [], scene);
    });
    DefaultDepthSlices = 16;
    ClusteredLightContainer = class _ClusteredLightContainer extends Light {
      static _GetEngineBatchSize(engine) {
        const caps = engine._caps;
        if (!caps.texelFetch) {
          return 0;
        } else if (engine.isWebGPU) {
          return 32;
        } else if (engine.version > 1) {
          if (!caps.colorBufferFloat || !caps.blendFloat) {
            return 0;
          }
          return caps.shaderFloatPrecision;
        } else {
          return 0;
        }
      }
      /**
       * Checks if the clustered lighting system supports the given light with its current parameters.
       * This will also check if the light's associated engine supports clustered lighting.
       *
       * @param light The light to test
       * @returns true if the light and its engine is supported
       */
      static IsLightSupported(light) {
        if (_ClusteredLightContainer._GetEngineBatchSize(light.getEngine()) === 0) {
          return false;
        } else if (light.shadowEnabled && light._scene.shadowsEnabled && light.getShadowGenerators()) {
          return false;
        } else if (light.falloffType !== Light.FALLOFF_DEFAULT) {
          return false;
        } else if (light.getTypeID() === LightConstants.LIGHTTYPEID_POINTLIGHT) {
          return true;
        } else if (light.getTypeID() === LightConstants.LIGHTTYPEID_SPOTLIGHT) {
          return !light.projectionTexture && !light.iesProfileTexture;
        } else {
          return false;
        }
      }
      /**
       * True if clustered lighting is supported.
       */
      get isSupported() {
        return this._batchSize > 0;
      }
      /**
       * Gets the current list of lights added to this clustering system.
       */
      get lights() {
        return this._lights;
      }
      /**
       * The number of tiles in the horizontal direction to cluster lights into.
       * A lower value will reduce memory and make the clustering step faster, while a higher value increases memory and makes the rendering step faster.
       */
      get horizontalTiles() {
        return this._horizontalTiles;
      }
      set horizontalTiles(horizontal) {
        if (this._horizontalTiles === horizontal) {
          return;
        }
        this._horizontalTiles = horizontal;
        this._tileMaskBatches = -1;
      }
      /**
       * The number of tiles in the vertical direction to cluster lights into.
       * A lower value will reduce memory and make the clustering step faster, while a higher value increases memory and makes the rendering step faster.
       */
      get verticalTiles() {
        return this._verticalTiles;
      }
      set verticalTiles(vertical) {
        if (this._verticalTiles === vertical) {
          return;
        }
        this._verticalTiles = vertical;
        this._tileMaskBatches = -1;
      }
      /**
       * The number of slices to split the depth range by and cluster lights into.
       */
      get depthSlices() {
        return this._depthSlices;
      }
      set depthSlices(slices) {
        if (this._depthSlices === slices) {
          return;
        }
        this._depthSlices = slices;
        this._sliceRanges = new Float32Array(slices * 2);
        this._uniformBuffer.dispose();
        this._uniformBuffer = new UniformBuffer(this.getEngine(), void 0, void 0, this.name);
        this._buildUniformLayout();
      }
      /**
       * This limits the range of all the added lights, so even lights with extreme ranges will still have bounds for clustering.
       */
      get maxRange() {
        return this._maxRange;
      }
      set maxRange(range) {
        if (this._maxRange === range) {
          return;
        }
        this._maxRange = range;
        this._minInverseSquaredRange = 1 / (range * range);
      }
      /**
       * Creates a new clustered light system with an initial set of lights.
       *
       * @param name The name of the clustered light container
       * @param lights The initial set of lights to add
       * @param scene The scene the clustered light container belongs to
       */
      constructor(name13, lights = [], scene) {
        super(name13, scene);
        this._lights = [];
        this._camera = null;
        this._sortedLights = [];
        this._lightDataRenderId = -1;
        this._tileMaskBatches = -1;
        this._horizontalTiles = 64;
        this._verticalTiles = 64;
        this._sliceScale = 0;
        this._sliceBias = 0;
        this._depthSlices = DefaultDepthSlices;
        this._maxRange = 16383;
        this._minInverseSquaredRange = 1 / (this._maxRange * this._maxRange);
        const engine = this.getEngine();
        this._batchSize = _ClusteredLightContainer._GetEngineBatchSize(engine);
        const proxyShader = { vertex: "lightProxy", fragment: "lightProxy" };
        const defines = [`CLUSTLIGHT_BATCH ${this._batchSize}`];
        if (this._scene.useRightHandedSystem) {
          defines.push("#define RIGHT_HANDED");
        }
        this._proxyMaterial = new ShaderMaterial("ProxyMaterial", this._scene, proxyShader, {
          attributes: ["position"],
          uniforms: ["view", "projection", "tileMaskResolution"],
          samplers: ["lightDataTexture"],
          uniformBuffers: ["Scene"],
          storageBuffers: ["tileMaskBuffer"],
          defines,
          shaderLanguage: engine.isWebGPU ? 1 : 0,
          extraInitializationsAsync: async () => {
            if (engine.isWebGPU) {
              await Promise.all([import("./lightProxy.vertex-5224LFZE.js"), import("./lightProxy.fragment-EEHNFTS7.js")]);
            } else {
              await Promise.all([import("./lightProxy.vertex-TVXVURYE.js"), import("./lightProxy.fragment-OUIZ7FRR.js")]);
            }
          }
        });
        this._proxyMaterial.transparencyMode = ShaderMaterial.MATERIAL_ALPHABLEND;
        this._proxyMaterial.alphaMode = 1;
        this._proxyMaterial.sideOrientation = 1;
        this._proxyMesh = CreatePlane("ProxyMesh", { size: 2 }, this._scene);
        this._scene.removeMesh(this._proxyMesh);
        this._proxyMesh.material = this._proxyMaterial;
        this._updateBatches();
        this._sliceRanges = new Float32Array(this._depthSlices * 2);
        if (this._batchSize > 0) {
          _ClusteredLightContainer._SceneComponentInitialization(this._scene);
          for (const light of lights) {
            this.addLight(light);
          }
        }
      }
      getClassName() {
        return "ClusteredLightContainer";
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      getTypeID() {
        return LightConstants.LIGHTTYPEID_CLUSTERED_CONTAINER;
      }
      /** @internal */
      _updateBatches(camera = null) {
        this._camera = camera;
        this._proxyMesh.isVisible = this._sortedLights.length > 0;
        const batches = Math.max(Math.ceil(this._sortedLights.length / this._batchSize), 1);
        if (this._tileMaskBatches >= batches) {
          this._proxyMesh.thinInstanceCount = this._sortedLights.length;
          return this._tileMaskTexture;
        }
        const engine = this.getEngine();
        const maxLights = batches * this._batchSize;
        this._lightDataBuffer = new Float32Array(20 * maxLights);
        this._lightDataTexture?.dispose();
        this._lightDataTexture = new RawTexture(this._lightDataBuffer, 5, maxLights, 5, this._scene, false, false, 1, 1);
        this._lightDataTexture.name = "LightDataTexture_clustered_" + this.name;
        this._proxyMaterial.setTexture("lightDataTexture", this._lightDataTexture);
        this._tileMaskTexture?.dispose();
        const textureSize = { width: this._horizontalTiles, height: this._verticalTiles };
        if (!engine.isWebGPU) {
          textureSize.height *= batches;
        }
        this._tileMaskTexture = new RenderTargetTexture("TileMaskTexture", textureSize, this._scene, {
          // We don't write anything on WebGPU so make it as small as possible
          type: engine.isWebGPU ? 0 : 1,
          format: 6,
          generateDepthBuffer: false
        });
        this._tileMaskTexture.renderParticles = false;
        this._tileMaskTexture.renderSprites = false;
        this._tileMaskTexture.noPrePassRenderer = true;
        this._tileMaskTexture.renderList = [this._proxyMesh];
        let currentRenderTarget = null;
        this._tileMaskTexture.onBeforeBindObservable.add(() => {
          currentRenderTarget = engine._currentRenderTarget;
          this._updateLightData();
        });
        this._tileMaskTexture.onAfterUnbindObservable.add(() => {
          if (engine._currentRenderTarget !== currentRenderTarget) {
            if (!currentRenderTarget) {
              engine.restoreDefaultFramebuffer();
            } else {
              engine.bindFramebuffer(currentRenderTarget);
            }
          }
        });
        this._tileMaskTexture.onClearObservable.add(() => {
          if (engine.isWebGPU) {
            this._tileMaskBuffer?.clear();
          } else {
            engine.clear({ r: 0, g: 0, b: 0, a: 1 }, true, false);
          }
        });
        if (engine.isWebGPU) {
          this._tileMaskBuffer?.dispose();
          const bufferSize = this._horizontalTiles * this._verticalTiles * batches * 4;
          this._tileMaskBuffer = new StorageBuffer(engine, bufferSize);
          this._proxyMaterial.setStorageBuffer("tileMaskBuffer", this._tileMaskBuffer);
        }
        this._proxyMaterial.setVector3("tileMaskResolution", new Vector3(this._horizontalTiles, this.verticalTiles, batches));
        this._proxyMesh.thinInstanceSetBuffer("matrix", new Float32Array(maxLights * 16));
        this._proxyMesh.thinInstanceCount = this._sortedLights.length;
        this._tileMaskBatches = batches;
        return this._tileMaskTexture;
      }
      _getSliceIndex(camera, depth) {
        if (depth < camera.minZ) {
          return -1;
        }
        return Math.floor(Math.log(depth) * this._sliceScale + this._sliceBias);
      }
      _updateLightData() {
        const camera = this._camera || this._scene.activeCamera;
        const renderId = this._scene.getRenderId();
        if (!camera || this._lightDataRenderId === renderId) {
          return;
        }
        this._lightDataRenderId = renderId;
        const view = camera.getViewMatrix();
        for (const light of this._sortedLights) {
          const position = light.computeTransformedInformation() ? light.transformedPosition : light.position;
          const viewPosition = Vector3.TransformCoordinatesToRef(position, view, TmpVectors.Vector3[0]);
          light._currentViewDepth = this._scene.useRightHandedSystem ? -viewPosition.z : viewPosition.z;
        }
        this._sortedLights.sort((a, b) => a._currentViewDepth - b._currentViewDepth);
        const logFarNear = Math.log(camera.maxZ / camera.minZ);
        this._sliceScale = this._depthSlices / logFarNear;
        this._sliceBias = -(this._depthSlices * Math.log(camera.minZ)) / logFarNear;
        this._sliceRanges.fill(0);
        let minSlice = -1;
        const buf = this._lightDataBuffer;
        const offset = this._scene.floatingOriginOffset;
        for (let i = 0; i < this._sortedLights.length; i += 1) {
          const light = this._sortedLights[i];
          const off = i * 20;
          const computed = light.computeTransformedInformation();
          const scaledIntensity = light.getScaledIntensity();
          const position = computed ? light.transformedPosition : light.position;
          const diffuse = light.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);
          const specular = light.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);
          const range = Math.min(light.range, this.maxRange);
          const inverseSquaredRange = Math.max(light._inverseSquaredRange, this._minInverseSquaredRange);
          buf[off + 0] = position.x - offset.x;
          buf[off + 1] = position.y - offset.y;
          buf[off + 2] = position.z - offset.z;
          buf[off + 3] = 0;
          buf[off + 4] = diffuse.r;
          buf[off + 5] = diffuse.g;
          buf[off + 6] = diffuse.b;
          buf[off + 7] = range;
          buf[off + 8] = specular.r;
          buf[off + 9] = specular.g;
          buf[off + 10] = specular.b;
          buf[off + 11] = light.radius;
          buf[off + 12] = 0;
          buf[off + 13] = 0;
          buf[off + 14] = 0;
          buf[off + 15] = -1;
          buf[off + 16] = range;
          buf[off + 17] = inverseSquaredRange;
          buf[off + 18] = 0;
          buf[off + 19] = 0;
          if (light.getTypeID() === LightConstants.LIGHTTYPEID_SPOTLIGHT) {
            const spotLight = light;
            const direction = Vector3.NormalizeToRef(computed ? spotLight.transformedDirection : spotLight.direction, TmpVectors.Vector3[0]);
            buf[off + 3] = spotLight.exponent;
            buf[off + 12] = direction.x;
            buf[off + 13] = direction.y;
            buf[off + 14] = direction.z;
            buf[off + 15] = spotLight._cosHalfAngle;
            buf[off + 18] = spotLight._lightAngleScale;
            buf[off + 19] = spotLight._lightAngleOffset;
          }
          const firstSlice = this._getSliceIndex(camera, light._currentViewDepth - range);
          const lastSlice = this._getSliceIndex(camera, light._currentViewDepth + range);
          for (let j = firstSlice; j <= lastSlice; j += 1) {
            if (j < 0 || j >= this._depthSlices) {
              continue;
            } else if (j > minSlice) {
              this._sliceRanges[j * 2] = i;
              minSlice = j;
            }
            this._sliceRanges[j * 2 + 1] = i;
          }
        }
        const engine = this.getEngine();
        if (engine.isWebGPU) {
          engine.flushFramebuffer();
        }
        this._lightDataTexture.update(this._lightDataBuffer);
      }
      dispose(doNotRecurse, disposeMaterialAndTextures) {
        for (const light of this._lights) {
          light.dispose(doNotRecurse, disposeMaterialAndTextures);
        }
        this._lightDataTexture.dispose();
        this._tileMaskTexture.dispose();
        this._tileMaskBuffer?.dispose();
        this._proxyMesh.dispose(doNotRecurse, disposeMaterialAndTextures);
        super.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
      /**
       * Adds a light to the clustering system.
       * @param light The light to add
       */
      addLight(light) {
        if (!_ClusteredLightContainer.IsLightSupported(light)) {
          Logger.Warn("Attempting to add a light to cluster that does not support clustering");
          return;
        }
        this._scene.removeLight(light);
        this._lights.push(light);
        this._sortedLights.push(light);
        this._proxyMesh.isVisible = true;
        this._proxyMesh.thinInstanceCount = this._sortedLights.length;
      }
      /**
       * Removes a light from the clustering system.
       * @param light The light to remove
       * @returns the index where the light was in the light list
       */
      removeLight(light) {
        const sortedLights = this._sortedLights;
        const sortedIndex = sortedLights.indexOf(light);
        if (sortedIndex !== -1) {
          sortedLights.splice(sortedIndex, 1);
          this._proxyMesh.thinInstanceCount = sortedLights.length;
          if (sortedLights.length === 0) {
            this._proxyMesh.isVisible = false;
          }
        }
        const index = this._lights.indexOf(light);
        if (index !== -1) {
          this._lights.splice(index, 1);
          this._scene.addLight(light);
        }
        return index;
      }
      _buildUniformLayout() {
        this._uniformBuffer.addUniform("vLightData", 4);
        this._uniformBuffer.addUniform("vLightDiffuse", 4);
        this._uniformBuffer.addUniform("vLightSpecular", 4);
        this._uniformBuffer.addUniform("vSliceData", 2);
        this._uniformBuffer.addUniform("vSliceRanges", 2, this._depthSlices ?? DefaultDepthSlices);
        this._uniformBuffer.addUniform("shadowsInfo", 3);
        this._uniformBuffer.addUniform("depthValues", 2);
        this._uniformBuffer.create();
      }
      transferToEffect(effect, lightIndex) {
        const engine = this.getEngine();
        const hscale = this._horizontalTiles / engine.getRenderWidth();
        const vscale = this._verticalTiles / engine.getRenderHeight();
        this._uniformBuffer.updateFloat4("vLightData", hscale, vscale, this._verticalTiles, this._tileMaskBatches, lightIndex);
        this._uniformBuffer.updateFloat2("vSliceData", this._sliceScale, this._sliceBias, lightIndex);
        this._uniformBuffer.updateFloatArray("vSliceRanges", this._sliceRanges, lightIndex);
        return this;
      }
      transferTexturesToEffect(effect, lightIndex) {
        const engine = this.getEngine();
        effect.setTexture("lightDataTexture" + lightIndex, this._lightDataTexture);
        if (engine.isWebGPU) {
          engine.setStorageBuffer("tileMaskBuffer" + lightIndex, this._tileMaskBuffer);
        } else {
          effect.setTexture("tileMaskTexture" + lightIndex, this._tileMaskTexture);
        }
        return this;
      }
      transferToNodeMaterialEffect(_effect) {
        return this;
      }
      prepareLightSpecificDefines(defines, lightIndex) {
        defines["CLUSTLIGHT" + lightIndex] = true;
        defines["CLUSTLIGHT_BATCH"] = this._batchSize;
        defines["CLUSTLIGHT_SLICES"] = this._depthSlices;
      }
      _isReady() {
        this._updateBatches();
        return this._proxyMesh.isReady(true, true);
      }
    };
    ClusteredLightContainer._SceneComponentInitialization = () => {
      throw _WarnImport("ClusteredLightingSceneComponent");
    };
    __decorate([
      serialize()
    ], ClusteredLightContainer.prototype, "horizontalTiles", null);
    __decorate([
      serialize()
    ], ClusteredLightContainer.prototype, "verticalTiles", null);
    __decorate([
      serialize()
    ], ClusteredLightContainer.prototype, "maxRange", null);
    RegisterClass("BABYLON.ClusteredLightContainer", ClusteredLightContainer);
  }
});

// node_modules/@babylonjs/core/Rendering/iblCdfGenerator.js
var IblCdfGenerator;
var init_iblCdfGenerator = __esm({
  "node_modules/@babylonjs/core/Rendering/iblCdfGenerator.js"() {
    init_texture();
    init_proceduralTexture();
    init_postProcess();
    init_math_vector();
    init_rawTexture();
    init_observable();
    init_engine();
    init_devTools();
    init_engineStore();
    init_logger();
    init_timingTools();
    IblCdfGenerator = class _IblCdfGenerator {
      /**
       * Returns whether the CDF renderer is supported by the current engine
       */
      get isSupported() {
        const engine = EngineStore.LastCreatedEngine;
        if (!engine) {
          return false;
        }
        return engine.getCaps().texelFetch;
      }
      /**
       * Gets the IBL source texture being used by the CDF renderer
       */
      get iblSource() {
        return this._iblSource;
      }
      /**
       * Sets the IBL source texture to be used by the CDF renderer.
       * This will trigger recreation of the CDF assets.
       */
      set iblSource(source) {
        if (this._iblSource === source) {
          return;
        }
        this._disposeTextures();
        this._iblSource = source;
        if (!source) {
          return;
        }
        if (source.isCube) {
          if (source.isReadyOrNotBlocking()) {
            this._recreateAssetsFromNewIbl();
          } else {
            source.onLoadObservable.addOnce(this._recreateAssetsFromNewIbl.bind(this, source));
          }
        } else {
          if (source.isReadyOrNotBlocking()) {
            this._recreateAssetsFromNewIbl();
          } else {
            source.onLoadObservable.addOnce(this._recreateAssetsFromNewIbl.bind(this, source));
          }
        }
      }
      _recreateAssetsFromNewIbl() {
        if (this._debugPass) {
          this._debugPass.dispose();
        }
        this._createTextures();
        if (this._debugPass) {
          this._createDebugPass();
        }
      }
      /**
       * Return the cumulative distribution function (CDF) texture
       * @returns Return the cumulative distribution function (CDF) texture
       */
      getIcdfTexture() {
        return this._icdfPT ? this._icdfPT : this._dummyTexture;
      }
      /**
       * Sets params that control the position and scaling of the debug display on the screen.
       * @param x Screen X offset of the debug display (0-1)
       * @param y Screen Y offset of the debug display (0-1)
       * @param widthScale X scale of the debug display (0-1)
       * @param heightScale Y scale of the debug display (0-1)
       */
      setDebugDisplayParams(x, y, widthScale, heightScale) {
        this._debugSizeParams.set(x, y, widthScale, heightScale);
      }
      /**
       * The name of the debug pass post process
       */
      get debugPassName() {
        return this._debugPassName;
      }
      /**
       * Gets the debug pass post process
       * @returns The post process
       */
      getDebugPassPP() {
        if (!this._debugPass) {
          this._createDebugPass();
        }
        return this._debugPass;
      }
      /**
       * Instanciates the CDF renderer
       * @param sceneOrEngine Scene to attach to
       * @returns The CDF renderer
       */
      constructor(sceneOrEngine) {
        this._cachedDominantDirection = null;
        this.debugEnabled = false;
        this._debugSizeParams = new Vector4(0, 0, 1, 1);
        this._debugPassName = "CDF Debug";
        this.onGeneratedObservable = new Observable();
        if (sceneOrEngine) {
          if (_IblCdfGenerator._IsScene(sceneOrEngine)) {
            this._scene = sceneOrEngine;
          } else {
            this._engine = sceneOrEngine;
          }
        } else {
          this._scene = EngineStore.LastCreatedScene;
        }
        if (this._scene) {
          this._engine = this._scene.getEngine();
        }
        if (!this.isSupported) {
          Logger.Warn("CDF renderer is not supported by the current engine.");
          return;
        }
        const blackPixels = new Uint16Array([0, 0, 0, 255]);
        this._dummyTexture = new RawTexture(blackPixels, 1, 1, Engine.TEXTUREFORMAT_RGBA, sceneOrEngine, false, false, void 0, 2);
        if (this._scene) {
          _IblCdfGenerator._SceneComponentInitialization(this._scene);
        }
      }
      _createTextures() {
        const size = this._iblSource ? { width: this._iblSource.getSize().width, height: this._iblSource.getSize().height } : { width: 1, height: 1 };
        if (!this._iblSource) {
          this._iblSource = RawTexture.CreateRTexture(new Uint8Array([255]), 1, 1, this._engine, false, false, 1, 0);
          this._iblSource.name = "Placeholder IBL Source";
        }
        if (this._iblSource.isCube) {
          size.width *= 4;
          size.height *= 2;
          size.width = 1 << Math.floor(Math.log2(size.width));
          size.height = 1 << Math.floor(Math.log2(size.height));
        }
        const isWebGPU = this._engine.isWebGPU;
        const cdfOptions = {
          generateDepthBuffer: false,
          generateMipMaps: false,
          format: 6,
          type: 1,
          samplingMode: 1,
          shaderLanguage: isWebGPU ? 1 : 0,
          gammaSpace: false,
          extraInitializationsAsync: async () => {
            if (isWebGPU) {
              await Promise.all([import("./iblCdfx.fragment-ALHDY5EQ.js"), import("./iblCdfy.fragment-LOYU5TII.js"), import("./iblScaledLuminance.fragment-AU5KEFFW.js")]);
            } else {
              await Promise.all([import("./iblCdfx.fragment-JRGY6SJD.js"), import("./iblCdfy.fragment-XZMR6KBZ.js"), import("./iblScaledLuminance.fragment-BRMAUDSS.js")]);
            }
          }
        };
        const icdfOptions = {
          generateDepthBuffer: false,
          generateMipMaps: false,
          format: 5,
          type: 2,
          samplingMode: 1,
          shaderLanguage: isWebGPU ? 1 : 0,
          gammaSpace: false,
          extraInitializationsAsync: async () => {
            if (isWebGPU) {
              await Promise.all([import("./iblIcdf.fragment-HCHBLJCF.js"), import("./iblDominantDirection.fragment-ZUWNKZKT.js")]);
            } else {
              await Promise.all([import("./iblIcdf.fragment-FUSBW7MJ.js"), import("./iblDominantDirection.fragment-73LBQF5B.js")]);
            }
          }
        };
        this._cdfyPT = new ProceduralTexture("cdfyTexture", { width: size.width, height: size.height + 1 }, "iblCdfy", this._scene, cdfOptions, false, false);
        this._cdfyPT.autoClear = false;
        this._cdfyPT.setTexture("iblSource", this._iblSource);
        this._cdfyPT.setInt("iblHeight", size.height);
        this._cdfyPT.wrapV = 0;
        this._cdfyPT.refreshRate = 0;
        if (this._iblSource.isCube) {
          this._cdfyPT.defines = "#define IBL_USE_CUBE_MAP\n";
        }
        this._cdfxPT = new ProceduralTexture("cdfxTexture", { width: size.width + 1, height: 1 }, "iblCdfx", this._scene, cdfOptions, false, false);
        this._cdfxPT.autoClear = false;
        this._cdfxPT.setTexture("cdfy", this._cdfyPT);
        this._cdfxPT.refreshRate = 0;
        this._cdfxPT.wrapU = 0;
        this._scaledLuminancePT = new ProceduralTexture("iblScaledLuminance", { width: size.width, height: size.height }, "iblScaledLuminance", this._scene, { ...cdfOptions, samplingMode: 3, generateMipMaps: true }, true, false);
        this._scaledLuminancePT.autoClear = false;
        this._scaledLuminancePT.setTexture("iblSource", this._iblSource);
        this._scaledLuminancePT.setInt("iblHeight", size.height);
        this._scaledLuminancePT.setInt("iblWidth", size.width);
        this._scaledLuminancePT.refreshRate = 0;
        if (this._iblSource.isCube) {
          this._scaledLuminancePT.defines = "#define IBL_USE_CUBE_MAP\n";
        }
        this._icdfPT = new ProceduralTexture("icdfTexture", { width: size.width, height: size.height }, "iblIcdf", this._scene, icdfOptions, false, false);
        this._icdfPT.autoClear = false;
        this._icdfPT.setTexture("cdfy", this._cdfyPT);
        this._icdfPT.setTexture("cdfx", this._cdfxPT);
        this._icdfPT.setTexture("iblSource", this._iblSource);
        this._icdfPT.setTexture("scaledLuminanceSampler", this._scaledLuminancePT);
        this._icdfPT.refreshRate = 0;
        this._icdfPT.wrapV = 0;
        this._icdfPT.wrapU = 0;
        if (this._iblSource.isCube) {
          this._icdfPT.defines = "#define IBL_USE_CUBE_MAP\n";
        }
        this._icdfPT.onGeneratedObservable.addOnce(() => {
          this.onGeneratedObservable.notifyObservers();
        });
        this._dominantDirectionPT = new ProceduralTexture("iblDominantDirection", { width: 1, height: 1 }, "iblDominantDirection", this._scene, icdfOptions, false, false);
        this._dominantDirectionPT.autoClear = false;
        this._dominantDirectionPT.setTexture("icdfSampler", this._icdfPT);
        this._dominantDirectionPT.refreshRate = 0;
        this._dominantDirectionPT.defines = "#define NUM_SAMPLES 32u\n";
      }
      _disposeTextures() {
        this._cdfyPT?.dispose();
        this._cdfxPT?.dispose();
        this._icdfPT?.dispose();
        this._scaledLuminancePT?.dispose();
        this._dominantDirectionPT?.dispose();
      }
      _createDebugPass() {
        if (this._debugPass) {
          this._debugPass.dispose();
        }
        const isWebGPU = this._engine.isWebGPU;
        const debugOptions = {
          width: this._engine.getRenderWidth(),
          height: this._engine.getRenderHeight(),
          samplingMode: Texture.BILINEAR_SAMPLINGMODE,
          engine: this._engine,
          textureType: 0,
          uniforms: ["sizeParams"],
          samplers: ["cdfy", "icdf", "cdfx", "iblSource"],
          defines: this._iblSource?.isCube ? "#define IBL_USE_CUBE_MAP\n" : "",
          shaderLanguage: isWebGPU ? 1 : 0,
          extraInitializations: (useWebGPU, list) => {
            if (useWebGPU) {
              list.push(import("./iblCdfDebug.fragment-Y5CPUUNT.js"));
            } else {
              list.push(import("./iblCdfDebug.fragment-TVE6HLAA.js"));
            }
          }
        };
        this._debugPass = new PostProcess(this._debugPassName, "iblCdfDebug", debugOptions);
        const debugEffect = this._debugPass.getEffect();
        if (debugEffect) {
          debugEffect.defines = this._iblSource?.isCube ? "#define IBL_USE_CUBE_MAP\n" : "";
        }
        if (this._iblSource?.isCube) {
          this._debugPass.updateEffect("#define IBL_USE_CUBE_MAP\n");
        }
        this._debugPass.onApplyObservable.add((effect) => {
          effect.setTexture("cdfy", this._cdfyPT);
          effect.setTexture("icdf", this._icdfPT);
          effect.setTexture("cdfx", this._cdfxPT);
          effect.setTexture("iblSource", this._iblSource);
          effect.setFloat4("sizeParams", this._debugSizeParams.x, this._debugSizeParams.y, this._debugSizeParams.z, this._debugSizeParams.w);
        });
      }
      /**
       * Checks if the CDF renderer is ready
       * @returns true if the CDF renderer is ready
       */
      isReady() {
        return this._iblSource && this._iblSource.name !== "Placeholder IBL Source" && this._iblSource.isReady() && this._cdfyPT && this._cdfyPT.isReady() && this._icdfPT && this._icdfPT.isReady() && this._cdfxPT && this._cdfxPT.isReady() && this._scaledLuminancePT && this._scaledLuminancePT.isReady();
      }
      /**
       * Explicitly trigger generation of CDF maps when they are ready to render.
       * @returns Promise that resolves when the CDF maps are rendered.
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async
      renderWhenReady() {
        this._cachedDominantDirection = null;
        const icdfPTPromise = new Promise((resolve, reject) => {
          _RetryWithInterval(() => !!this._icdfPT, () => resolve(void 0), () => reject(new Error("Waiting for _icdfPT creation failed")));
        });
        return icdfPTPromise.then(() => {
          this._icdfPT.onGeneratedObservable.addOnce(() => {
            this.onGeneratedObservable.notifyObservers();
          });
          const promises = [];
          const renderTargets = [this._cdfyPT, this._cdfxPT, this._scaledLuminancePT, this._icdfPT];
          for (const target of renderTargets) {
            promises.push(new Promise((resolve) => {
              if (target.isReady()) {
                resolve();
              } else {
                target.getEffect().executeWhenCompiled(() => {
                  resolve();
                });
              }
            }));
          }
          return Promise.all(promises).then(() => {
            for (const target of renderTargets) {
              target.render();
            }
          });
        });
      }
      /**
       * Finds the average direction of the highest intensity areas of the IBL source
       * @returns Async promise that resolves to the dominant direction of the IBL source
       */
      // eslint-disable-next-line @typescript-eslint/promise-function-async
      findDominantDirection() {
        if (this._cachedDominantDirection) {
          return Promise.resolve(this._cachedDominantDirection);
        }
        return new Promise((resolve) => {
          this._dominantDirectionPT.onGeneratedObservable.addOnce(() => {
            const data = new Float32Array(4);
            this._dominantDirectionPT.readPixels(0, 0, data, true).then(() => {
              const dominantDirection = new Vector3(data[0], data[1], data[2]);
              this._cachedDominantDirection = dominantDirection;
              resolve(dominantDirection);
            });
          });
          if (this.isReady()) {
            if (this._dominantDirectionPT.isReady()) {
              this._dominantDirectionPT.render();
            } else {
              this._dominantDirectionPT.getEffect().executeWhenCompiled(() => {
                this._dominantDirectionPT.render();
              });
            }
          } else {
            this.onGeneratedObservable.addOnce(() => {
              if (this._dominantDirectionPT.isReady()) {
                this._dominantDirectionPT.render();
              } else {
                this._dominantDirectionPT.getEffect().executeWhenCompiled(() => {
                  this._dominantDirectionPT.render();
                });
              }
            });
          }
        });
      }
      /**
       * Disposes the CDF renderer and associated resources
       */
      dispose() {
        this._disposeTextures();
        this._dummyTexture.dispose();
        if (this._debugPass) {
          this._debugPass.dispose();
        }
        this.onGeneratedObservable.clear();
      }
      static _IsScene(sceneOrEngine) {
        return sceneOrEngine.getClassName() === "Scene";
      }
    };
    IblCdfGenerator._SceneComponentInitialization = (_) => {
      throw _WarnImport("IblCdfGeneratorSceneComponentSceneComponent");
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/rawTexture2DArray.js
var RawTexture2DArray;
var init_rawTexture2DArray = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/rawTexture2DArray.js"() {
    init_texture();
    RawTexture2DArray = class _RawTexture2DArray extends Texture {
      /**
       * Gets the number of layers of the texture
       */
      get depth() {
        return this._depth;
      }
      /**
       * Create a new RawTexture2DArray
       * @param data defines the data of the texture
       * @param width defines the width of the texture
       * @param height defines the height of the texture
       * @param depth defines the number of layers of the texture
       * @param format defines the texture format to use
       * @param scene defines the hosting scene
       * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)
       * @param invertY defines if texture must be stored with Y axis inverted
       * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)
       * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_BYTE, Engine.TEXTURETYPE_FLOAT...)
       * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
       * @param mipLevelCount defines the number of mip levels to allocate for the texture
       */
      constructor(data, width, height, depth, format, scene, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, textureType = 0, creationFlags, mipLevelCount) {
        super(null, scene, !generateMipMaps, invertY);
        this.format = format;
        this._texture = scene.getEngine().createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType, creationFlags ?? 0, mipLevelCount);
        this._depth = depth;
        this.is2DArray = true;
      }
      /**
       * Update the texture with new data
       * @param data defines the data to store in the texture
       */
      update(data) {
        this.updateMipLevel(data, 0);
      }
      /**
       * Updates a specific mip level of the texture.
       * @param data The new data for the mip level
       * @param mipLevel The mip level to update (0 is the base level)
       */
      updateMipLevel(data, mipLevel) {
        if (!this._texture) {
          return;
        }
        this._getEngine().updateRawTexture2DArray(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type, mipLevel);
      }
      /**
       * Creates a RGBA texture from some data.
       * @param data Define the texture data
       * @param width Define the width of the texture
       * @param height Define the height of the texture
       * @param depth defines the number of layers of the texture
       * @param scene defines the scene the texture will belong to
       * @param generateMipMaps Define whether or not to create mip maps for the texture
       * @param invertY define if the data should be flipped on Y when uploaded to the GPU
       * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
       * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
       * @returns the RGBA texture
       */
      static CreateRGBATexture(data, width, height, depth, scene, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0) {
        return new _RawTexture2DArray(data, width, height, depth, 5, scene, generateMipMaps, invertY, samplingMode, type);
      }
    };
  }
});

// node_modules/@babylonjs/core/Morph/morphTargetManager.js
var MorphTargetManager;
var init_morphTargetManager = __esm({
  "node_modules/@babylonjs/core/Morph/morphTargetManager.js"() {
    init_smartArray();
    init_logger();
    init_engineStore();
    init_morphTarget();
    init_rawTexture2DArray();
    MorphTargetManager = class _MorphTargetManager {
      /**
       * Sets a boolean indicating that adding new target or updating an existing target will not update the underlying data buffers
       */
      set areUpdatesFrozen(block) {
        if (block) {
          this._blockCounter++;
        } else {
          this._blockCounter--;
          if (this._blockCounter <= 0) {
            this._blockCounter = 0;
            this._syncActiveTargets(this._forceUpdateWhenUnfrozen);
            this._forceUpdateWhenUnfrozen = false;
          }
        }
      }
      get areUpdatesFrozen() {
        return this._blockCounter > 0;
      }
      /**
       * Creates a new MorphTargetManager
       * @param scene defines the current scene
       */
      constructor(scene = null) {
        this._targets = new Array();
        this._targetInfluenceChangedObservers = new Array();
        this._targetDataLayoutChangedObservers = new Array();
        this._activeTargets = new SmartArray(16);
        this._supportsPositions = false;
        this._supportsNormals = false;
        this._supportsTangents = false;
        this._supportsUVs = false;
        this._supportsUV2s = false;
        this._supportsColors = false;
        this._vertexCount = 0;
        this._uniqueId = 0;
        this._tempInfluences = new Array();
        this._canUseTextureForTargets = false;
        this._blockCounter = 0;
        this._mustSynchronize = true;
        this._forceUpdateWhenUnfrozen = false;
        this._textureVertexStride = 0;
        this._textureWidth = 0;
        this._textureHeight = 1;
        this._parentContainer = null;
        this.optimizeInfluencers = true;
        this.enablePositionMorphing = true;
        this.enableNormalMorphing = true;
        this.enableTangentMorphing = true;
        this.enableUVMorphing = true;
        this.enableUV2Morphing = true;
        this.enableColorMorphing = true;
        this._numMaxInfluencers = 0;
        this._useTextureToStoreTargets = true;
        this.metadata = null;
        this._influencesAreDirty = false;
        this._needUpdateInfluences = false;
        if (!scene) {
          scene = EngineStore.LastCreatedScene;
        }
        this._scene = scene;
        if (this._scene) {
          this._scene.addMorphTargetManager(this);
          this._uniqueId = this._scene.getUniqueId();
          const engineCaps = this._scene.getEngine().getCaps();
          this._canUseTextureForTargets = engineCaps.canUseGLVertexID && engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0 && engineCaps.texture2DArrayMaxLayerCount > 1;
        }
      }
      /**
       * Gets or sets the maximum number of influencers (targets) (default value: 0).
       * Setting a value for this property can lead to a smoother experience, as only one shader will be compiled, which will use this value as the maximum number of influencers.
       * If you leave the value at 0 (default), a new shader will be compiled every time the number of active influencers changes. This can cause problems, as compiling a shader takes time.
       * If you assign a non-zero value to this property, you need to ensure that this value is greater than the maximum number of (active) influencers you'll need for this morph manager.
       * Otherwise, the number of active influencers will be truncated at the value you set for this property, which can lead to unexpected results.
       * Note that this property has no effect if "useTextureToStoreTargets" is false.
       * Note as well that if MorphTargetManager.ConstantTargetCountForTextureMode is greater than 0, this property will be ignored and the constant value will be used instead.
       */
      get numMaxInfluencers() {
        if (_MorphTargetManager.ConstantTargetCountForTextureMode > 0 && this.isUsingTextureForTargets) {
          return _MorphTargetManager.ConstantTargetCountForTextureMode;
        }
        return this._numMaxInfluencers;
      }
      set numMaxInfluencers(value) {
        if (this._numMaxInfluencers === value) {
          return;
        }
        this._numMaxInfluencers = value;
        this._mustSynchronize = true;
        this._syncActiveTargets();
      }
      /**
       * Gets the unique ID of this manager
       */
      get uniqueId() {
        return this._uniqueId;
      }
      /**
       * Gets the number of vertices handled by this manager
       */
      get vertexCount() {
        return this._vertexCount;
      }
      /**
       * Gets a boolean indicating if this manager supports morphing of positions
       */
      get supportsPositions() {
        return this._supportsPositions && this.enablePositionMorphing;
      }
      /**
       * Gets a boolean indicating if this manager supports morphing of normals
       */
      get supportsNormals() {
        return this._supportsNormals && this.enableNormalMorphing;
      }
      /**
       * Gets a boolean indicating if this manager supports morphing of tangents
       */
      get supportsTangents() {
        return this._supportsTangents && this.enableTangentMorphing;
      }
      /**
       * Gets a boolean indicating if this manager supports morphing of texture coordinates
       */
      get supportsUVs() {
        return this._supportsUVs && this.enableUVMorphing;
      }
      /**
       * Gets a boolean indicating if this manager supports morphing of texture coordinates 2
       */
      get supportsUV2s() {
        return this._supportsUV2s && this.enableUV2Morphing;
      }
      /**
       * Gets a boolean indicating if this manager supports morphing of colors
       */
      get supportsColors() {
        return this._supportsColors && this.enableColorMorphing;
      }
      /**
       * Gets a boolean indicating if this manager has data for morphing positions
       */
      get hasPositions() {
        return this._supportsPositions;
      }
      /**
       * Gets a boolean indicating if this manager has data for morphing normals
       */
      get hasNormals() {
        return this._supportsNormals;
      }
      /**
       * Gets a boolean indicating if this manager has data for morphing tangents
       */
      get hasTangents() {
        return this._supportsTangents;
      }
      /**
       * Gets a boolean indicating if this manager has data for morphing texture coordinates
       */
      get hasUVs() {
        return this._supportsUVs;
      }
      /**
       * Gets a boolean indicating if this manager has data for morphing texture coordinates 2
       */
      get hasUV2s() {
        return this._supportsUV2s;
      }
      /**
       * Gets a boolean indicating if this manager has data for morphing colors
       */
      get hasColors() {
        return this._supportsColors;
      }
      /**
       * Gets the number of targets stored in this manager
       */
      get numTargets() {
        return this._targets.length;
      }
      /**
       * Gets the number of influencers (ie. the number of targets with influences > 0)
       */
      get numInfluencers() {
        if (this._influencesAreDirty) {
          this._syncActiveTargets();
        }
        return this._activeTargets.length;
      }
      /**
       * Gets the list of influences (one per target)
       */
      get influences() {
        if (this._influencesAreDirty) {
          this._syncActiveTargets();
        }
        return this._influences;
      }
      /**
       * Gets or sets a boolean indicating that targets should be stored as a texture instead of using vertex attributes (default is true).
       * Please note that this option is not available if the hardware does not support it
       */
      get useTextureToStoreTargets() {
        return this._useTextureToStoreTargets;
      }
      set useTextureToStoreTargets(value) {
        if (this._useTextureToStoreTargets === value) {
          return;
        }
        this._useTextureToStoreTargets = value;
        this._mustSynchronize = true;
        this._syncActiveTargets();
      }
      /**
       * Gets a boolean indicating that the targets are stored into a texture (instead of as attributes)
       */
      get isUsingTextureForTargets() {
        return _MorphTargetManager.EnableTextureStorage && this.useTextureToStoreTargets && this._canUseTextureForTargets && !this._scene?.getEngine().getCaps().disableMorphTargetTexture;
      }
      /**
       * Gets the active target at specified index. An active target is a target with an influence > 0
       * @param index defines the index to check
       * @returns the requested target
       */
      getActiveTarget(index) {
        if (this._influencesAreDirty) {
          this._syncActiveTargets();
        }
        return this._activeTargets.data[index];
      }
      /**
       * Gets the target at specified index
       * @param index defines the index to check
       * @returns the requested target
       */
      getTarget(index) {
        return this._targets[index];
      }
      /**
       * Gets the first target with the specified name
       * @param name defines the name to check
       * @returns the requested target
       */
      getTargetByName(name13) {
        for (const target of this._targets) {
          if (target.name === name13) {
            return target;
          }
        }
        return null;
      }
      /**
       * Add a new target to this manager
       * @param target defines the target to add
       */
      addTarget(target) {
        this._targets.push(target);
        this._targetInfluenceChangedObservers.push(target.onInfluenceChanged.add((needUpdate) => {
          if (this.areUpdatesFrozen && needUpdate) {
            this._forceUpdateWhenUnfrozen = true;
          }
          this._influencesAreDirty = true;
          this._needUpdateInfluences = this._needUpdateInfluences || needUpdate;
        }));
        this._targetDataLayoutChangedObservers.push(target._onDataLayoutChanged.add(() => {
          this._mustSynchronize = true;
          this._syncActiveTargets();
        }));
        this._mustSynchronize = true;
        this._syncActiveTargets();
      }
      /**
       * Removes a target from the manager
       * @param target defines the target to remove
       */
      removeTarget(target) {
        const index = this._targets.indexOf(target);
        if (index >= 0) {
          this._targets.splice(index, 1);
          target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);
          target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);
          this._mustSynchronize = true;
          this._syncActiveTargets();
        }
        if (this._scene) {
          this._scene.stopAnimation(target);
        }
      }
      /**
       * @internal
       */
      _bind(effect) {
        if (this._influencesAreDirty) {
          this._syncActiveTargets();
        }
        effect.setFloat3("morphTargetTextureInfo", this._textureVertexStride, this._textureWidth, this._textureHeight);
        effect.setFloatArray("morphTargetTextureIndices", this._morphTargetTextureIndices);
        effect.setTexture("morphTargets", this._targetStoreTexture);
        effect.setFloat("morphTargetCount", this.numInfluencers);
      }
      /**
       * Clone the current manager
       * @returns a new MorphTargetManager
       */
      clone() {
        const copy = new _MorphTargetManager(this._scene);
        copy.areUpdatesFrozen = true;
        for (const target of this._targets) {
          copy.addTarget(target.clone());
        }
        copy.areUpdatesFrozen = false;
        copy.enablePositionMorphing = this.enablePositionMorphing;
        copy.enableNormalMorphing = this.enableNormalMorphing;
        copy.enableTangentMorphing = this.enableTangentMorphing;
        copy.enableUVMorphing = this.enableUVMorphing;
        copy.enableUV2Morphing = this.enableUV2Morphing;
        copy.enableColorMorphing = this.enableColorMorphing;
        copy.metadata = this.metadata;
        return copy;
      }
      /**
       * Serializes the current manager into a Serialization object
       * @returns the serialized object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.id = this.uniqueId;
        serializationObject.targets = [];
        for (const target of this._targets) {
          serializationObject.targets.push(target.serialize());
        }
        if (this.metadata) {
          serializationObject.metadata = this.metadata;
        }
        return serializationObject;
      }
      _syncActiveTargets(needUpdate = false) {
        if (this.areUpdatesFrozen) {
          return;
        }
        needUpdate = needUpdate || this._needUpdateInfluences;
        this._needUpdateInfluences = false;
        this._influencesAreDirty = false;
        const wasUsingTextureForTargets = !!this._targetStoreTexture;
        const isUsingTextureForTargets = this.isUsingTextureForTargets;
        if (this._mustSynchronize || wasUsingTextureForTargets !== isUsingTextureForTargets) {
          this._mustSynchronize = false;
          this.synchronize();
        }
        let influenceCount = 0;
        this._activeTargets.reset();
        if (!this._morphTargetTextureIndices || this._morphTargetTextureIndices.length !== this._targets.length) {
          this._morphTargetTextureIndices = new Float32Array(this._targets.length);
        }
        let targetIndex = -1;
        for (const target of this._targets) {
          targetIndex++;
          if (target.influence === 0 && this.optimizeInfluencers) {
            continue;
          }
          if (this._activeTargets.length >= _MorphTargetManager.MaxActiveMorphTargetsInVertexAttributeMode && !this.isUsingTextureForTargets) {
            break;
          }
          this._activeTargets.push(target);
          this._morphTargetTextureIndices[influenceCount] = targetIndex;
          this._tempInfluences[influenceCount++] = target.influence;
        }
        if (this._morphTargetTextureIndices.length !== influenceCount) {
          this._morphTargetTextureIndices = this._morphTargetTextureIndices.slice(0, influenceCount);
        }
        if (!this._influences || this._influences.length !== influenceCount) {
          this._influences = new Float32Array(influenceCount);
        }
        for (let index = 0; index < influenceCount; index++) {
          this._influences[index] = this._tempInfluences[index];
        }
        if (needUpdate && this._scene) {
          for (const mesh of this._scene.meshes) {
            if (mesh.morphTargetManager === this) {
              if (isUsingTextureForTargets) {
                mesh._markSubMeshesAsAttributesDirty();
              } else {
                mesh._syncGeometryWithMorphTargetManager();
              }
            }
          }
        }
      }
      /**
       * Synchronize the targets with all the meshes using this morph target manager
       */
      synchronize() {
        if (!this._scene || this.areUpdatesFrozen) {
          return;
        }
        const engine = this._scene.getEngine();
        this._supportsPositions = true;
        this._supportsNormals = true;
        this._supportsTangents = true;
        this._supportsUVs = true;
        this._supportsUV2s = true;
        this._supportsColors = true;
        this._vertexCount = 0;
        this._targetStoreTexture?.dispose();
        this._targetStoreTexture = null;
        if (this.isUsingTextureForTargets && this._targets.length > engine.getCaps().texture2DArrayMaxLayerCount) {
          this.useTextureToStoreTargets = false;
        }
        for (const target of this._targets) {
          this._supportsPositions = this._supportsPositions && target.hasPositions;
          this._supportsNormals = this._supportsNormals && target.hasNormals;
          this._supportsTangents = this._supportsTangents && target.hasTangents;
          this._supportsUVs = this._supportsUVs && target.hasUVs;
          this._supportsUV2s = this._supportsUV2s && target.hasUV2s;
          this._supportsColors = this._supportsColors && target.hasColors;
          const vertexCount = target.vertexCount;
          if (this._vertexCount === 0) {
            this._vertexCount = vertexCount;
          } else if (this._vertexCount !== vertexCount) {
            Logger.Error(`Incompatible target. Targets must all have the same vertices count. Current vertex count: ${this._vertexCount}, vertex count for target "${target.name}": ${vertexCount}`);
            return;
          }
        }
        if (this.isUsingTextureForTargets) {
          this._textureVertexStride = 0;
          this._supportsPositions && this._textureVertexStride++;
          this._supportsNormals && this._textureVertexStride++;
          this._supportsTangents && this._textureVertexStride++;
          this._supportsUVs && this._textureVertexStride++;
          this._supportsUV2s && this._textureVertexStride++;
          this._supportsColors && this._textureVertexStride++;
          this._textureWidth = this._vertexCount * this._textureVertexStride || 1;
          this._textureHeight = 1;
          const maxTextureSize = engine.getCaps().maxTextureSize;
          if (this._textureWidth > maxTextureSize) {
            this._textureHeight = Math.ceil(this._textureWidth / maxTextureSize);
            this._textureWidth = maxTextureSize;
          }
          const targetCount = this._targets.length;
          const data = new Float32Array(targetCount * this._textureWidth * this._textureHeight * 4);
          let offset = 0;
          for (let index = 0; index < targetCount; index++) {
            const target = this._targets[index];
            const positions = target.getPositions();
            const normals = target.getNormals();
            const uvs = target.getUVs();
            const tangents = target.getTangents();
            const uv2s = target.getUV2s();
            const colors = target.getColors();
            offset = index * this._textureWidth * this._textureHeight * 4;
            for (let vertex = 0; vertex < this._vertexCount; vertex++) {
              if (this._supportsPositions && positions) {
                data[offset] = positions[vertex * 3];
                data[offset + 1] = positions[vertex * 3 + 1];
                data[offset + 2] = positions[vertex * 3 + 2];
                offset += 4;
              }
              if (this._supportsNormals && normals) {
                data[offset] = normals[vertex * 3];
                data[offset + 1] = normals[vertex * 3 + 1];
                data[offset + 2] = normals[vertex * 3 + 2];
                offset += 4;
              }
              if (this._supportsUVs && uvs) {
                data[offset] = uvs[vertex * 2];
                data[offset + 1] = uvs[vertex * 2 + 1];
                offset += 4;
              }
              if (this._supportsTangents && tangents) {
                data[offset] = tangents[vertex * 3];
                data[offset + 1] = tangents[vertex * 3 + 1];
                data[offset + 2] = tangents[vertex * 3 + 2];
                offset += 4;
              }
              if (this._supportsUV2s && uv2s) {
                data[offset] = uv2s[vertex * 2];
                data[offset + 1] = uv2s[vertex * 2 + 1];
                offset += 4;
              }
              if (this._supportsColors && colors) {
                data[offset] = colors[vertex * 4];
                data[offset + 1] = colors[vertex * 4 + 1];
                data[offset + 2] = colors[vertex * 4 + 2];
                data[offset + 3] = colors[vertex * 4 + 3];
                offset += 4;
              }
            }
          }
          this._targetStoreTexture = RawTexture2DArray.CreateRGBATexture(data, this._textureWidth, this._textureHeight, targetCount, this._scene, false, false, 1, 1);
          this._targetStoreTexture.name = `Morph texture_${this.uniqueId}`;
        }
        for (const mesh of this._scene.meshes) {
          if (mesh.morphTargetManager === this) {
            mesh._syncGeometryWithMorphTargetManager();
          }
        }
      }
      /**
       * Release all resources
       */
      dispose() {
        if (this._targetStoreTexture) {
          this._targetStoreTexture.dispose();
        }
        this._targetStoreTexture = null;
        this.metadata = null;
        if (this._scene) {
          this._scene.removeMorphTargetManager(this);
          if (this._parentContainer) {
            const index = this._parentContainer.morphTargetManagers.indexOf(this);
            if (index > -1) {
              this._parentContainer.morphTargetManagers.splice(index, 1);
            }
            this._parentContainer = null;
          }
          for (const morph of this._targets) {
            this._scene.stopAnimation(morph);
          }
        }
      }
      // Statics
      /**
       * Creates a new MorphTargetManager from serialized data
       * @param serializationObject defines the serialized data
       * @param scene defines the hosting scene
       * @returns the new MorphTargetManager
       */
      static Parse(serializationObject, scene) {
        const result = new _MorphTargetManager(scene);
        for (const targetData of serializationObject.targets) {
          result.addTarget(MorphTarget.Parse(targetData, scene));
        }
        if (serializationObject.metadata) {
          result.metadata = serializationObject.metadata;
        }
        return result;
      }
    };
    MorphTargetManager.EnableTextureStorage = true;
    MorphTargetManager.MaxActiveMorphTargetsInVertexAttributeMode = 8;
    MorphTargetManager.ConstantTargetCountForTextureMode = 0;
  }
});

// node_modules/@babylonjs/core/Physics/castingResult.js
var CastingResult;
var init_castingResult = __esm({
  "node_modules/@babylonjs/core/Physics/castingResult.js"() {
    init_math_vector();
    CastingResult = class {
      constructor() {
        this._hasHit = false;
        this._hitNormal = Vector3.Zero();
        this._hitPoint = Vector3.Zero();
        this._triangleIndex = -1;
      }
      /**
       * Gets the hit point.
       */
      get hitPoint() {
        return this._hitPoint;
      }
      /**
       * Gets the hit normal.
       */
      get hitNormal() {
        return this._hitNormal;
      }
      /**
       * Gets if there was a hit
       */
      get hasHit() {
        return this._hasHit;
      }
      /*
       * The index of the original triangle which was hit. Will be -1 if contact point is not on a mesh shape
       */
      get triangleIndex() {
        return this._triangleIndex;
      }
      /**
       * Sets the hit data
       * @param hitNormal defines the normal in world space
       * @param hitPoint defines the point in world space
       * @param triangleIndex defines the index of the triangle in case of mesh shape
       */
      setHitData(hitNormal, hitPoint, triangleIndex) {
        this._hasHit = true;
        this._hitNormal.set(hitNormal.x, hitNormal.y, hitNormal.z);
        this._hitPoint.set(hitPoint.x, hitPoint.y, hitPoint.z);
        this._triangleIndex = triangleIndex ?? -1;
      }
      /**
       * Resets all the values to default
       */
      reset() {
        this._hasHit = false;
        this._hitNormal.setAll(0);
        this._hitPoint.setAll(0);
        this._triangleIndex = -1;
        this.body = void 0;
        this.bodyIndex = void 0;
        this.shape = void 0;
      }
    };
  }
});

// node_modules/@babylonjs/core/Physics/physicsRaycastResult.js
var PhysicsRaycastResult;
var init_physicsRaycastResult = __esm({
  "node_modules/@babylonjs/core/Physics/physicsRaycastResult.js"() {
    init_math_vector();
    init_castingResult();
    PhysicsRaycastResult = class extends CastingResult {
      constructor() {
        super(...arguments);
        this._hitDistance = 0;
        this._rayFromWorld = Vector3.Zero();
        this._rayToWorld = Vector3.Zero();
      }
      /**
       * Gets the distance from the hit
       */
      get hitDistance() {
        return this._hitDistance;
      }
      /**
       * Gets the hit normal/direction in the world
       */
      get hitNormalWorld() {
        return this._hitNormal;
      }
      /**
       * Gets the hit point in the world
       */
      get hitPointWorld() {
        return this._hitPoint;
      }
      /**
       * Gets the ray "start point" of the ray in the world
       */
      get rayFromWorld() {
        return this._rayFromWorld;
      }
      /**
       * Gets the ray "end point" of the ray in the world
       */
      get rayToWorld() {
        return this._rayToWorld;
      }
      /**
       * Sets the distance from the start point to the hit point
       * @param distance defines the distance to set
       */
      setHitDistance(distance) {
        this._hitDistance = distance;
      }
      /**
       * Calculates the distance manually
       */
      calculateHitDistance() {
        this._hitDistance = Vector3.Distance(this._rayFromWorld, this._hitPoint);
      }
      /**
       * Resets all the values to default
       * @param from The from point on world space
       * @param to The to point on world space
       */
      reset(from = Vector3.Zero(), to = Vector3.Zero()) {
        super.reset();
        this._rayFromWorld.copyFrom(from);
        this._rayToWorld.copyFrom(to);
        this._hitDistance = 0;
      }
    };
  }
});

// node_modules/@babylonjs/core/Physics/v1/physicsEngine.js
var PhysicsEngine;
var init_physicsEngine = __esm({
  "node_modules/@babylonjs/core/Physics/v1/physicsEngine.js"() {
    init_math_vector();
    init_devTools();
    PhysicsEngine = class _PhysicsEngine {
      /**
       *
       * @returns version
       */
      getPluginVersion() {
        return this._physicsPlugin.getPluginVersion();
      }
      /**
       * @virtual
       * Factory used to create the default physics plugin.
       * @returns The default physics plugin
       */
      static DefaultPluginFactory() {
        throw _WarnImport("CannonJSPlugin");
      }
      /**
       * Creates a new Physics Engine
       * @param gravity defines the gravity vector used by the simulation
       * @param _physicsPlugin defines the plugin to use (CannonJS by default)
       */
      constructor(gravity, _physicsPlugin = _PhysicsEngine.DefaultPluginFactory()) {
        this._physicsPlugin = _physicsPlugin;
        this._impostors = [];
        this._joints = [];
        this._subTimeStep = 0;
        this._uniqueIdCounter = 0;
        if (!this._physicsPlugin.isSupported()) {
          throw new Error("Physics Engine " + this._physicsPlugin.name + " cannot be found. Please make sure it is included.");
        }
        gravity = gravity || new Vector3(0, -9.807, 0);
        this.setGravity(gravity);
        this.setTimeStep();
      }
      /**
       * Sets the gravity vector used by the simulation
       * @param gravity defines the gravity vector to use
       */
      setGravity(gravity) {
        this.gravity = gravity;
        this._physicsPlugin.setGravity(this.gravity);
      }
      /**
       * Set the time step of the physics engine.
       * Default is 1/60.
       * To slow it down, enter 1/600 for example.
       * To speed it up, 1/30
       * @param newTimeStep defines the new timestep to apply to this world.
       */
      setTimeStep(newTimeStep = 1 / 60) {
        this._physicsPlugin.setTimeStep(newTimeStep);
      }
      /**
       * Get the time step of the physics engine.
       * @returns the current time step
       */
      getTimeStep() {
        return this._physicsPlugin.getTimeStep();
      }
      /**
       * Set the sub time step of the physics engine.
       * Default is 0 meaning there is no sub steps
       * To increase physics resolution precision, set a small value (like 1 ms)
       * @param subTimeStep defines the new sub timestep used for physics resolution.
       */
      setSubTimeStep(subTimeStep = 0) {
        this._subTimeStep = subTimeStep;
      }
      /**
       * Get the sub time step of the physics engine.
       * @returns the current sub time step
       */
      getSubTimeStep() {
        return this._subTimeStep;
      }
      /**
       * Release all resources
       */
      dispose() {
        for (const impostor of this._impostors) {
          impostor.dispose();
        }
        this._physicsPlugin.dispose();
      }
      /**
       * Gets the name of the current physics plugin
       * @returns the name of the plugin
       */
      getPhysicsPluginName() {
        return this._physicsPlugin.name;
      }
      /**
       * Adding a new impostor for the impostor tracking.
       * This will be done by the impostor itself.
       * @param impostor the impostor to add
       */
      addImpostor(impostor) {
        this._impostors.push(impostor);
        impostor.uniqueId = this._uniqueIdCounter++;
        if (!impostor.parent) {
          this._physicsPlugin.generatePhysicsBody(impostor);
        }
      }
      /**
       * Remove an impostor from the engine.
       * This impostor and its mesh will not longer be updated by the physics engine.
       * @param impostor the impostor to remove
       */
      removeImpostor(impostor) {
        const index = this._impostors.indexOf(impostor);
        if (index > -1) {
          const removed = this._impostors.splice(index, 1);
          if (removed.length) {
            this.getPhysicsPlugin().removePhysicsBody(impostor);
          }
        }
      }
      /**
       * Add a joint to the physics engine
       * @param mainImpostor defines the main impostor to which the joint is added.
       * @param connectedImpostor defines the impostor that is connected to the main impostor using this joint
       * @param joint defines the joint that will connect both impostors.
       */
      addJoint(mainImpostor, connectedImpostor, joint) {
        const impostorJoint = {
          mainImpostor,
          connectedImpostor,
          joint
        };
        joint.physicsPlugin = this._physicsPlugin;
        this._joints.push(impostorJoint);
        this._physicsPlugin.generateJoint(impostorJoint);
      }
      /**
       * Removes a joint from the simulation
       * @param mainImpostor defines the impostor used with the joint
       * @param connectedImpostor defines the other impostor connected to the main one by the joint
       * @param joint defines the joint to remove
       */
      removeJoint(mainImpostor, connectedImpostor, joint) {
        const matchingJoints = this._joints.filter(function(impostorJoint) {
          return impostorJoint.connectedImpostor === connectedImpostor && impostorJoint.joint === joint && impostorJoint.mainImpostor === mainImpostor;
        });
        if (matchingJoints.length) {
          this._physicsPlugin.removeJoint(matchingJoints[0]);
        }
      }
      /**
       * Called by the scene. No need to call it.
       * @param delta defines the timespan between frames
       */
      _step(delta) {
        for (const impostor of this._impostors) {
          if (impostor.isBodyInitRequired()) {
            this._physicsPlugin.generatePhysicsBody(impostor);
          }
        }
        if (delta > 0.1) {
          delta = 0.1;
        } else if (delta <= 0) {
          delta = 1 / 60;
        }
        this._physicsPlugin.executeStep(delta, this._impostors);
      }
      /**
       * Gets the current plugin used to run the simulation
       * @returns current plugin
       */
      getPhysicsPlugin() {
        return this._physicsPlugin;
      }
      /**
       * Gets the list of physic impostors
       * @returns an array of PhysicsImpostor
       */
      getImpostors() {
        return this._impostors;
      }
      /**
       * Gets the impostor for a physics enabled object
       * @param object defines the object impersonated by the impostor
       * @returns the PhysicsImpostor or null if not found
       */
      getImpostorForPhysicsObject(object) {
        for (let i = 0; i < this._impostors.length; ++i) {
          if (this._impostors[i].object === object) {
            return this._impostors[i];
          }
        }
        return null;
      }
      /**
       * Gets the impostor for a physics body object
       * @param body defines physics body used by the impostor
       * @returns the PhysicsImpostor or null if not found
       */
      getImpostorWithPhysicsBody(body) {
        for (let i = 0; i < this._impostors.length; ++i) {
          if (this._impostors[i].physicsBody === body) {
            return this._impostors[i];
          }
        }
        return null;
      }
      /**
       * Does a raycast in the physics world
       * @param from when should the ray start?
       * @param to when should the ray end?
       * @returns PhysicsRaycastResult
       */
      raycast(from, to) {
        return this._physicsPlugin.raycast(from, to);
      }
      /**
       * Does a raycast in the physics world
       * @param from when should the ray start?
       * @param to when should the ray end?
       * @param result resulting PhysicsRaycastResult
       * @returns true if the ray hits an impostor, else false
       */
      raycastToRef(from, to, result) {
        return this._physicsPlugin.raycastToRef(from, to, result);
      }
    };
  }
});

// node_modules/@babylonjs/core/Probes/reflectionProbe.js
var ReflectionProbe;
var init_reflectionProbe = __esm({
  "node_modules/@babylonjs/core/Probes/reflectionProbe.js"() {
    init_tslib_es6();
    init_decorators();
    init_decorators_serialization();
    init_renderTargetTexture();
    init_math_vector();
    init_scene();
    Scene.prototype.removeReflectionProbe = function(toRemove) {
      if (!this.reflectionProbes) {
        return -1;
      }
      const index = this.reflectionProbes.indexOf(toRemove);
      if (index !== -1) {
        this.reflectionProbes.splice(index, 1);
      }
      return index;
    };
    Scene.prototype.addReflectionProbe = function(newReflectionProbe) {
      if (!this.reflectionProbes) {
        this.reflectionProbes = [];
      }
      this.reflectionProbes.push(newReflectionProbe);
    };
    ReflectionProbe = class _ReflectionProbe {
      /**
       * Creates a new reflection probe
       * @param name defines the name of the probe
       * @param size defines the texture resolution (for each face)
       * @param scene defines the hosting scene
       * @param generateMipMaps defines if mip maps should be generated automatically (true by default)
       * @param useFloat defines if HDR data (float data) should be used to store colors (false by default)
       * @param linearSpace defines if the probe should be generated in linear space or not (false by default)
       */
      constructor(name13, size, scene, generateMipMaps = true, useFloat = false, linearSpace = false) {
        this.name = name13;
        this._viewMatrix = Matrix.Identity();
        this._target = Vector3.Zero();
        this._add = Vector3.Zero();
        this._invertYAxis = false;
        this.position = Vector3.Zero();
        this.metadata = null;
        this._parentContainer = null;
        this._scene = scene;
        if (scene.getEngine().supportsUniformBuffers) {
          this._sceneUBOs = [];
          for (let i = 0; i < 6; ++i) {
            this._sceneUBOs.push(scene.createSceneUniformBuffer(`Scene for Reflection Probe (name "${name13}") face #${i}`));
          }
        }
        if (!this._scene.reflectionProbes) {
          this._scene.reflectionProbes = [];
        }
        this._scene.reflectionProbes.push(this);
        let textureType = 0;
        if (useFloat) {
          const caps = this._scene.getEngine().getCaps();
          if (caps.textureHalfFloatRender) {
            textureType = 2;
          } else if (caps.textureFloatRender) {
            textureType = 1;
          }
        }
        this._renderTargetTexture = new RenderTargetTexture(name13, size, scene, generateMipMaps, true, textureType, true);
        this._renderTargetTexture.gammaSpace = !linearSpace;
        this._renderTargetTexture.invertZ = scene.useRightHandedSystem;
        const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;
        this._renderTargetTexture.onBeforeRenderObservable.add((faceIndex) => {
          if (this._sceneUBOs) {
            scene.setSceneUniformBuffer(this._sceneUBOs[faceIndex]);
            scene.getSceneUniformBuffer().unbindEffect();
          }
          switch (faceIndex) {
            case 0:
              this._add.copyFromFloats(1, 0, 0);
              break;
            case 1:
              this._add.copyFromFloats(-1, 0, 0);
              break;
            case 2:
              this._add.copyFromFloats(0, this._invertYAxis ? 1 : -1, 0);
              break;
            case 3:
              this._add.copyFromFloats(0, this._invertYAxis ? -1 : 1, 0);
              break;
            case 4:
              this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? -1 : 1);
              break;
            case 5:
              this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? 1 : -1);
              break;
          }
          if (this._attachedMesh) {
            this.position.copyFrom(this._attachedMesh.getAbsolutePosition());
          }
          this.position.addToRef(this._add, this._target);
          const lookAtFunction = scene.useRightHandedSystem ? Matrix.LookAtRHToRef : Matrix.LookAtLHToRef;
          const perspectiveFunction = scene.useRightHandedSystem ? Matrix.PerspectiveFovRH : Matrix.PerspectiveFovLH;
          lookAtFunction(this.position, this._target, Vector3.Up(), this._viewMatrix);
          if (scene.activeCamera) {
            this._projectionMatrix = perspectiveFunction(Math.PI / 2, 1, useReverseDepthBuffer ? scene.activeCamera.maxZ : scene.activeCamera.minZ, useReverseDepthBuffer ? scene.activeCamera.minZ : scene.activeCamera.maxZ, this._scene.getEngine().isNDCHalfZRange);
            scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);
            if (scene.activeCamera.isRigCamera && !this._renderTargetTexture.activeCamera) {
              this._renderTargetTexture.activeCamera = scene.activeCamera.rigParent || null;
            }
          }
          scene._forcedViewPosition = this.position;
        });
        let currentApplyByPostProcess;
        this._renderTargetTexture.onBeforeBindObservable.add(() => {
          const engine = scene.getEngine();
          this._currentSceneUBO = scene.getSceneUniformBuffer();
          if (engine._enableGPUDebugMarkers) {
            engine.restoreDefaultFramebuffer();
            engine._debugPushGroup?.(`reflection probe generation for ${name13}`);
          }
          currentApplyByPostProcess = this._scene.imageProcessingConfiguration.applyByPostProcess;
          if (linearSpace) {
            scene.imageProcessingConfiguration.applyByPostProcess = true;
          }
        });
        this._renderTargetTexture.onAfterUnbindObservable.add(() => {
          const engine = scene.getEngine();
          scene.imageProcessingConfiguration.applyByPostProcess = currentApplyByPostProcess;
          scene._forcedViewPosition = null;
          if (this._sceneUBOs) {
            scene.setSceneUniformBuffer(this._currentSceneUBO);
          }
          scene.updateTransformMatrix(true);
          if (engine._enableGPUDebugMarkers) {
            engine._debugPopGroup?.();
          }
        });
      }
      /** Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2 */
      get samples() {
        return this._renderTargetTexture.samples;
      }
      set samples(value) {
        this._renderTargetTexture.samples = value;
      }
      /** Gets or sets the refresh rate to use (on every frame by default) */
      get refreshRate() {
        return this._renderTargetTexture.refreshRate;
      }
      set refreshRate(value) {
        this._renderTargetTexture.refreshRate = value;
      }
      /**
       * Gets the hosting scene
       * @returns a Scene
       */
      getScene() {
        return this._scene;
      }
      /** Gets the internal CubeTexture used to render to */
      get cubeTexture() {
        return this._renderTargetTexture;
      }
      /** Gets or sets the list of meshes to render */
      get renderList() {
        return this._renderTargetTexture.renderList;
      }
      set renderList(value) {
        this._renderTargetTexture.renderList = value;
      }
      /**
       * Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)
       * @param mesh defines the mesh to attach to
       */
      attachToMesh(mesh) {
        this._attachedMesh = mesh;
      }
      /**
       * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups
       * @param renderingGroupId The rendering group id corresponding to its index
       * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
       */
      setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil) {
        this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);
      }
      /**
       * Clean all associated resources
       */
      dispose() {
        const index = this._scene.reflectionProbes.indexOf(this);
        if (index !== -1) {
          this._scene.reflectionProbes.splice(index, 1);
        }
        if (this._parentContainer) {
          const index2 = this._parentContainer.reflectionProbes.indexOf(this);
          if (index2 > -1) {
            this._parentContainer.reflectionProbes.splice(index2, 1);
          }
          this._parentContainer = null;
        }
        if (this._renderTargetTexture) {
          this._renderTargetTexture.dispose();
          this._renderTargetTexture = null;
        }
        if (this._sceneUBOs) {
          for (const ubo of this._sceneUBOs) {
            ubo.dispose();
          }
          this._sceneUBOs = [];
        }
      }
      /**
       * Converts the reflection probe information to a readable string for debug purpose.
       * @param fullDetails Supports for multiple levels of logging within scene loading
       * @returns the human readable reflection probe info
       */
      toString(fullDetails) {
        let ret = "Name: " + this.name;
        if (fullDetails) {
          ret += ", position: " + this.position.toString();
          if (this._attachedMesh) {
            ret += ", attached mesh: " + this._attachedMesh.name;
          }
        }
        return ret;
      }
      /**
       * Get the class name of the refection probe.
       * @returns "ReflectionProbe"
       */
      getClassName() {
        return "ReflectionProbe";
      }
      /**
       * Serialize the reflection probe to a JSON representation we can easily use in the respective Parse function.
       * @returns The JSON representation of the texture
       */
      serialize() {
        const serializationObject = SerializationHelper.Serialize(this, this._renderTargetTexture.serialize());
        serializationObject.isReflectionProbe = true;
        serializationObject.metadata = this.metadata;
        return serializationObject;
      }
      /**
       * Parse the JSON representation of a reflection probe in order to recreate the reflection probe in the given scene.
       * @param parsedReflectionProbe Define the JSON representation of the reflection probe
       * @param scene Define the scene the parsed reflection probe should be instantiated in
       * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies
       * @returns The parsed reflection probe if successful
       */
      static Parse(parsedReflectionProbe, scene, rootUrl) {
        let reflectionProbe = null;
        if (scene.reflectionProbes) {
          for (let index = 0; index < scene.reflectionProbes.length; index++) {
            const rp = scene.reflectionProbes[index];
            if (rp.name === parsedReflectionProbe.name) {
              reflectionProbe = rp;
              break;
            }
          }
        }
        reflectionProbe = SerializationHelper.Parse(() => reflectionProbe || new _ReflectionProbe(parsedReflectionProbe.name, parsedReflectionProbe.renderTargetSize, scene, parsedReflectionProbe._generateMipMaps), parsedReflectionProbe, scene, rootUrl);
        reflectionProbe.cubeTexture._waitingRenderList = parsedReflectionProbe.renderList;
        if (parsedReflectionProbe._attachedMesh) {
          reflectionProbe.attachToMesh(scene.getMeshById(parsedReflectionProbe._attachedMesh));
        }
        if (parsedReflectionProbe.metadata) {
          reflectionProbe.metadata = parsedReflectionProbe.metadata;
        }
        return reflectionProbe;
      }
    };
    __decorate([
      serializeAsMeshReference()
    ], ReflectionProbe.prototype, "_attachedMesh", void 0);
    __decorate([
      serializeAsVector3()
    ], ReflectionProbe.prototype, "position", void 0);
  }
});

// node_modules/@babylonjs/core/Sprites/thinSprite.js
var ThinSprite;
var init_thinSprite = __esm({
  "node_modules/@babylonjs/core/Sprites/thinSprite.js"() {
    ThinSprite = class {
      /**
       * Returns a boolean indicating if the animation is started
       */
      get animationStarted() {
        return this._animationStarted;
      }
      /** Gets the initial key for the animation (setting it will restart the animation)  */
      get fromIndex() {
        return this._fromIndex;
      }
      /** Gets or sets the end key for the animation (setting it will restart the animation)  */
      get toIndex() {
        return this._toIndex;
      }
      /** Gets or sets a boolean indicating if the animation is looping (setting it will restart the animation)  */
      get loopAnimation() {
        return this._loopAnimation;
      }
      /** Gets or sets the delay between cell changes (setting it will restart the animation)  */
      get delay() {
        return Math.max(this._delay, 1);
      }
      /**
       * Creates a new Thin Sprite
       */
      constructor() {
        this.width = 1;
        this.height = 1;
        this.angle = 0;
        this.invertU = false;
        this.invertV = false;
        this.isVisible = true;
        this._animationStarted = false;
        this._loopAnimation = false;
        this._fromIndex = 0;
        this._toIndex = 0;
        this._delay = 0;
        this._direction = 1;
        this._time = 0;
        this._onBaseAnimationEnd = null;
        this.position = { x: 1, y: 1, z: 1 };
        this.color = { r: 1, g: 1, b: 1, a: 1 };
      }
      /**
       * Starts an animation
       * @param from defines the initial key
       * @param to defines the end key
       * @param loop defines if the animation must loop
       * @param delay defines the start delay (in ms)
       * @param onAnimationEnd defines a callback for when the animation ends
       */
      playAnimation(from, to, loop, delay, onAnimationEnd) {
        this._fromIndex = from;
        this._toIndex = to;
        this._loopAnimation = loop;
        this._delay = delay || 1;
        this._animationStarted = true;
        this._onBaseAnimationEnd = onAnimationEnd;
        if (from < to) {
          this._direction = 1;
        } else {
          this._direction = -1;
          this._toIndex = from;
          this._fromIndex = to;
        }
        this.cellIndex = from;
        this._time = 0;
      }
      /** Stops current animation (if any) */
      stopAnimation() {
        this._animationStarted = false;
      }
      /**
       * @internal
       */
      _animate(deltaTime) {
        if (!this._animationStarted) {
          return;
        }
        this._time += deltaTime;
        if (this._time > this._delay) {
          this._time = this._time % this._delay;
          this.cellIndex += this._direction;
          if (this._direction > 0 && this.cellIndex > this._toIndex || this._direction < 0 && this.cellIndex < this._fromIndex) {
            if (this._loopAnimation) {
              this.cellIndex = this._direction > 0 ? this._fromIndex : this._toIndex;
            } else {
              this.cellIndex = this._toIndex;
              this._animationStarted = false;
              if (this._onBaseAnimationEnd) {
                this._onBaseAnimationEnd();
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Sprites/sprite.js
var Sprite;
var init_sprite = __esm({
  "node_modules/@babylonjs/core/Sprites/sprite.js"() {
    init_math_vector();
    init_math_color();
    init_observable();
    init_thinSprite();
    Sprite = class _Sprite extends ThinSprite {
      /**
       * Gets or sets the sprite size
       */
      get size() {
        return this.width;
      }
      set size(value) {
        this.width = value;
        this.height = value;
      }
      /**
       * Gets the manager of this sprite
       */
      get manager() {
        return this._manager;
      }
      /**
       * Creates a new Sprite
       * @param name defines the name
       * @param manager defines the manager
       */
      constructor(name13, manager) {
        super();
        this.name = name13;
        this.animations = new Array();
        this.isPickable = false;
        this.useAlphaForPicking = false;
        this.onDisposeObservable = new Observable();
        this._onAnimationEnd = null;
        this._endAnimation = () => {
          if (this._onAnimationEnd) {
            this._onAnimationEnd();
          }
          if (this.disposeWhenFinishedAnimating) {
            this.dispose();
          }
        };
        this.color = new Color4(1, 1, 1, 1);
        this.position = Vector3.Zero();
        this._manager = manager;
        this._manager.sprites.push(this);
        this.uniqueId = this._manager.scene.getUniqueId();
      }
      /**
       * Returns the string "Sprite"
       * @returns "Sprite"
       */
      getClassName() {
        return "Sprite";
      }
      /** Gets or sets the initial key for the animation (setting it will restart the animation)  */
      get fromIndex() {
        return this._fromIndex;
      }
      set fromIndex(value) {
        this.playAnimation(value, this._toIndex, this._loopAnimation, this._delay, this._onAnimationEnd);
      }
      /** Gets or sets the end key for the animation (setting it will restart the animation)  */
      get toIndex() {
        return this._toIndex;
      }
      set toIndex(value) {
        this.playAnimation(this._fromIndex, value, this._loopAnimation, this._delay, this._onAnimationEnd);
      }
      /** Gets or sets a boolean indicating if the animation is looping (setting it will restart the animation)  */
      get loopAnimation() {
        return this._loopAnimation;
      }
      set loopAnimation(value) {
        this.playAnimation(this._fromIndex, this._toIndex, value, this._delay, this._onAnimationEnd);
      }
      /** Gets or sets the delay between cell changes (setting it will restart the animation)  */
      get delay() {
        return Math.max(this._delay, 1);
      }
      set delay(value) {
        this.playAnimation(this._fromIndex, this._toIndex, this._loopAnimation, value, this._onAnimationEnd);
      }
      /**
       * Starts an animation
       * @param from defines the initial key
       * @param to defines the end key
       * @param loop defines if the animation must loop
       * @param delay defines the start delay (in ms)
       * @param onAnimationEnd defines a callback to call when animation ends
       */
      playAnimation(from, to, loop, delay, onAnimationEnd = null) {
        this._onAnimationEnd = onAnimationEnd;
        super.playAnimation(from, to, loop, delay, this._endAnimation);
      }
      /** Release associated resources */
      dispose() {
        for (let i = 0; i < this._manager.sprites.length; i++) {
          if (this._manager.sprites[i] == this) {
            this._manager.sprites.splice(i, 1);
          }
        }
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
      }
      /**
       * Serializes the sprite to a JSON object
       * @returns the JSON object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.position = this.position.asArray();
        serializationObject.color = this.color.asArray();
        serializationObject.width = this.width;
        serializationObject.height = this.height;
        serializationObject.angle = this.angle;
        serializationObject.cellIndex = this.cellIndex;
        serializationObject.cellRef = this.cellRef;
        serializationObject.invertU = this.invertU;
        serializationObject.invertV = this.invertV;
        serializationObject.disposeWhenFinishedAnimating = this.disposeWhenFinishedAnimating;
        serializationObject.isPickable = this.isPickable;
        serializationObject.isVisible = this.isVisible;
        serializationObject.useAlphaForPicking = this.useAlphaForPicking;
        serializationObject.animationStarted = this.animationStarted;
        serializationObject.fromIndex = this.fromIndex;
        serializationObject.toIndex = this.toIndex;
        serializationObject.loopAnimation = this.loopAnimation;
        serializationObject.delay = this.delay;
        return serializationObject;
      }
      /**
       * Parses a JSON object to create a new sprite
       * @param parsedSprite The JSON object to parse
       * @param manager defines the hosting manager
       * @returns the new sprite
       */
      static Parse(parsedSprite, manager) {
        const sprite = new _Sprite(parsedSprite.name, manager);
        sprite.position = Vector3.FromArray(parsedSprite.position);
        sprite.color = Color4.FromArray(parsedSprite.color);
        sprite.width = parsedSprite.width;
        sprite.height = parsedSprite.height;
        sprite.angle = parsedSprite.angle;
        sprite.cellIndex = parsedSprite.cellIndex;
        sprite.cellRef = parsedSprite.cellRef;
        sprite.invertU = parsedSprite.invertU;
        sprite.invertV = parsedSprite.invertV;
        sprite.disposeWhenFinishedAnimating = parsedSprite.disposeWhenFinishedAnimating;
        sprite.isPickable = parsedSprite.isPickable;
        sprite.isVisible = parsedSprite.isVisible;
        sprite.useAlphaForPicking = parsedSprite.useAlphaForPicking;
        sprite._fromIndex = parsedSprite.fromIndex;
        sprite._toIndex = parsedSprite.toIndex;
        sprite._loopAnimation = parsedSprite.loopAnimation;
        sprite._delay = parsedSprite.delay;
        if (parsedSprite.animationStarted) {
          sprite.playAnimation(sprite.fromIndex, sprite.toIndex, sprite.loopAnimation, sprite.delay);
        }
        return sprite;
      }
    };
  }
});

// node_modules/@babylonjs/core/Sprites/spriteSceneComponent.js
var SpriteSceneComponent;
var init_spriteSceneComponent = __esm({
  "node_modules/@babylonjs/core/Sprites/spriteSceneComponent.js"() {
    init_observable();
    init_scene();
    init_ray_core();
    init_pickingInfo();
    init_sceneComponent();
    init_actionEvent();
    Object.defineProperty(Scene.prototype, "onNewSpriteManagerAddedObservable", {
      get: function() {
        if (!this.isDisposed && !this._onNewSpriteManagerAddedObservable) {
          const onNewSpriteManagerAddedObservable = this._onNewSpriteManagerAddedObservable = new Observable();
          this.onDisposeObservable.addOnce(() => onNewSpriteManagerAddedObservable.clear());
        }
        return this._onNewSpriteManagerAddedObservable;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Scene.prototype, "onSpriteManagerRemovedObservable", {
      get: function() {
        if (!this.isDisposed && !this._onSpriteManagerRemovedObservable) {
          const onSpriteManagerRemovedObservable = this._onSpriteManagerRemovedObservable = new Observable();
          this.onDisposeObservable.addOnce(() => onSpriteManagerRemovedObservable.clear());
        }
        return this._onSpriteManagerRemovedObservable;
      },
      enumerable: true,
      configurable: true
    });
    Scene.prototype._internalPickSprites = function(ray, predicate, fastCheck, camera) {
      if (!PickingInfo) {
        return null;
      }
      let pickingInfo = null;
      if (!camera) {
        if (!this.activeCamera) {
          return null;
        }
        camera = this.activeCamera;
      }
      if (this.spriteManagers && this.spriteManagers.length > 0) {
        for (let spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {
          const spriteManager = this.spriteManagers[spriteIndex];
          if (!spriteManager.isPickable) {
            continue;
          }
          const result = spriteManager.intersects(ray, camera, predicate, fastCheck);
          if (!result || !result.hit) {
            continue;
          }
          if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {
            continue;
          }
          pickingInfo = result;
          if (fastCheck) {
            break;
          }
        }
      }
      return pickingInfo || new PickingInfo();
    };
    Scene.prototype._internalMultiPickSprites = function(ray, predicate, camera) {
      if (!PickingInfo) {
        return null;
      }
      let pickingInfos = [];
      if (!camera) {
        if (!this.activeCamera) {
          return null;
        }
        camera = this.activeCamera;
      }
      if (this.spriteManagers && this.spriteManagers.length > 0) {
        for (let spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {
          const spriteManager = this.spriteManagers[spriteIndex];
          if (!spriteManager.isPickable) {
            continue;
          }
          const results = spriteManager.multiIntersects(ray, camera, predicate);
          if (results !== null) {
            pickingInfos = pickingInfos.concat(results);
          }
        }
      }
      return pickingInfos;
    };
    Scene.prototype.pickSprite = function(x, y, predicate, fastCheck, camera) {
      if (!this._tempSpritePickingRay) {
        return null;
      }
      CreatePickingRayInCameraSpaceToRef(this, x, y, this._tempSpritePickingRay, camera);
      const result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);
      if (result) {
        result.ray = CreatePickingRayInCameraSpace(this, x, y, camera);
      }
      return result;
    };
    Scene.prototype.pickSpriteWithRay = function(ray, predicate, fastCheck, camera) {
      if (!this._tempSpritePickingRay) {
        return null;
      }
      if (!camera) {
        if (!this.activeCamera) {
          return null;
        }
        camera = this.activeCamera;
      }
      Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);
      const result = this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);
      if (result) {
        result.ray = ray;
      }
      return result;
    };
    Scene.prototype.multiPickSprite = function(x, y, predicate, camera) {
      CreatePickingRayInCameraSpaceToRef(this, x, y, this._tempSpritePickingRay, camera);
      return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);
    };
    Scene.prototype.multiPickSpriteWithRay = function(ray, predicate, camera) {
      if (!this._tempSpritePickingRay) {
        return null;
      }
      if (!camera) {
        if (!this.activeCamera) {
          return null;
        }
        camera = this.activeCamera;
      }
      Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);
      return this._internalMultiPickSprites(this._tempSpritePickingRay, predicate, camera);
    };
    Scene.prototype.setPointerOverSprite = function(sprite) {
      if (this._pointerOverSprite === sprite) {
        return;
      }
      if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {
        this._pointerOverSprite.actionManager.processTrigger(10, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));
      }
      this._pointerOverSprite = sprite;
      if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {
        this._pointerOverSprite.actionManager.processTrigger(9, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));
      }
    };
    Scene.prototype.getPointerOverSprite = function() {
      return this._pointerOverSprite;
    };
    SpriteSceneComponent = class {
      /**
       * Creates a new instance of the component for the given scene
       * @param scene Defines the scene to register the component in
       */
      constructor(scene) {
        this.name = SceneComponentConstants.NAME_SPRITE;
        this.scene = scene;
        this.scene.spriteManagers = [];
        this.scene._tempSpritePickingRay = Ray ? Ray.Zero() : null;
        this.scene.onBeforeSpritesRenderingObservable = new Observable();
        this.scene.onAfterSpritesRenderingObservable = new Observable();
        this._spritePredicate = (sprite) => {
          if (!sprite.actionManager) {
            return false;
          }
          return sprite.isPickable && sprite.actionManager.hasPointerTriggers;
        };
      }
      /**
       * Registers the component in a given scene
       */
      register() {
        this.scene._pointerMoveStage.registerStep(SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove);
        this.scene._pointerDownStage.registerStep(SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown);
        this.scene._pointerUpStage.registerStep(SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);
      }
      /**
       * Rebuilds the elements related to this component in case of
       * context lost for instance.
       */
      rebuild() {
      }
      /**
       * Disposes the component and the associated resources.
       */
      dispose() {
        this.scene.onBeforeSpritesRenderingObservable.clear();
        this.scene.onAfterSpritesRenderingObservable.clear();
        const spriteManagers = this.scene.spriteManagers;
        if (!spriteManagers) {
          return;
        }
        while (spriteManagers.length) {
          spriteManagers[0].dispose();
        }
      }
      _pickSpriteButKeepRay(originalPointerInfo, x, y, fastCheck, camera) {
        const result = this.scene.pickSprite(x, y, this._spritePredicate, fastCheck, camera);
        if (result) {
          result.ray = originalPointerInfo ? originalPointerInfo.ray : null;
        }
        return result;
      }
      _pointerMove(unTranslatedPointerX, unTranslatedPointerY, pickResult, isMeshPicked, element) {
        const scene = this.scene;
        if (isMeshPicked) {
          scene.setPointerOverSprite(null);
        } else {
          pickResult = this._pickSpriteButKeepRay(pickResult, unTranslatedPointerX, unTranslatedPointerY, false, scene.cameraToUseForPointers || void 0);
          if (pickResult && pickResult.hit && pickResult.pickedSprite) {
            scene.setPointerOverSprite(pickResult.pickedSprite);
            if (!scene.doNotHandleCursors && element) {
              if (scene._pointerOverSprite && scene._pointerOverSprite.actionManager && scene._pointerOverSprite.actionManager.hoverCursor) {
                element.style.cursor = scene._pointerOverSprite.actionManager.hoverCursor;
              } else {
                element.style.cursor = scene.hoverCursor;
              }
            }
          } else {
            scene.setPointerOverSprite(null);
          }
        }
        return pickResult;
      }
      _pointerDown(unTranslatedPointerX, unTranslatedPointerY, pickResult, evt) {
        const scene = this.scene;
        scene._pickedDownSprite = null;
        if (scene.spriteManagers && scene.spriteManagers.length > 0) {
          pickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || void 0);
          if (pickResult && pickResult.hit && pickResult.pickedSprite) {
            if (pickResult.pickedSprite.actionManager) {
              scene._pickedDownSprite = pickResult.pickedSprite;
              switch (evt.button) {
                case 0:
                  pickResult.pickedSprite.actionManager.processTrigger(2, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));
                  break;
                case 1:
                  pickResult.pickedSprite.actionManager.processTrigger(4, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));
                  break;
                case 2:
                  pickResult.pickedSprite.actionManager.processTrigger(3, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));
                  break;
              }
              if (pickResult.pickedSprite.actionManager) {
                pickResult.pickedSprite.actionManager.processTrigger(5, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));
              }
            }
          }
        }
        return pickResult;
      }
      _pointerUp(unTranslatedPointerX, unTranslatedPointerY, pickResult, evt, doubleClick) {
        const scene = this.scene;
        if (scene.spriteManagers && scene.spriteManagers.length > 0) {
          const spritePickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || void 0);
          if (spritePickResult) {
            if (spritePickResult.hit && spritePickResult.pickedSprite) {
              if (spritePickResult.pickedSprite.actionManager) {
                spritePickResult.pickedSprite.actionManager.processTrigger(7, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));
                if (spritePickResult.pickedSprite.actionManager) {
                  if (!this.scene._inputManager._isPointerSwiping()) {
                    spritePickResult.pickedSprite.actionManager.processTrigger(1, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));
                  }
                  if (doubleClick) {
                    spritePickResult.pickedSprite.actionManager.processTrigger(6, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));
                  }
                }
              }
            }
            if (scene._pickedDownSprite && scene._pickedDownSprite.actionManager && scene._pickedDownSprite !== spritePickResult.pickedSprite) {
              scene._pickedDownSprite.actionManager.processTrigger(16, ActionEvent.CreateNewFromSprite(scene._pickedDownSprite, scene, evt));
            }
          }
        }
        return pickResult;
      }
    };
  }
});

// node_modules/@babylonjs/core/Sprites/spriteRenderer.js
var SpriteRenderer;
var init_spriteRenderer = __esm({
  "node_modules/@babylonjs/core/Sprites/spriteRenderer.js"() {
    init_buffer();
    init_drawWrapper();
    init_logger();
    init_materialHelper_functions_pure();
    init_math_vector();
    SpriteRenderer = class _SpriteRenderer {
      /**
       * Gets or sets a boolean indicating if the manager must consider scene fog when rendering
       */
      get fogEnabled() {
        return this._fogEnabled;
      }
      set fogEnabled(value) {
        if (this._fogEnabled === value) {
          return;
        }
        this._fogEnabled = value;
        this._createEffects();
      }
      /**
       * In case the depth buffer does not allow enough depth precision for your scene (might be the case in large scenes)
       * You can try switching to logarithmic depth.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/logarithmicDepthBuffer
       */
      get useLogarithmicDepth() {
        return this._useLogarithmicDepth;
      }
      set useLogarithmicDepth(value) {
        const fragmentDepthSupported = !!this._scene?.getEngine().getCaps().fragmentDepthSupported;
        if (value && !fragmentDepthSupported) {
          Logger.Warn("Logarithmic depth has been requested for a sprite renderer on a device that doesn't support it.");
        }
        this._useLogarithmicDepth = value && fragmentDepthSupported;
        this._createEffects();
      }
      /**
       * Gets the capacity of the manager
       */
      get capacity() {
        return this._capacity;
      }
      /**
       * Gets or sets a boolean indicating if the renderer must render sprites with pixel perfect rendering
       * Note that pixel perfect mode is not supported in WebGL 1
       */
      get pixelPerfect() {
        return this._pixelPerfect;
      }
      set pixelPerfect(value) {
        if (this._pixelPerfect === value) {
          return;
        }
        this._pixelPerfect = value;
        this._createEffects();
      }
      /**
       * Gets the shader language used in this renderer.
       */
      get shaderLanguage() {
        return this._shaderLanguage;
      }
      /**
       * Creates a new sprite renderer
       * @param engine defines the engine the renderer works with
       * @param capacity defines the maximum allowed number of sprites
       * @param epsilon defines the epsilon value to align texture (0.01 by default)
       * @param scene defines the hosting scene
       * @param rendererOptions options for the sprite renderer
       */
      constructor(engine, capacity, epsilon = 0.01, scene = null, rendererOptions) {
        this.blendMode = 2;
        this.autoResetAlpha = true;
        this.disableDepthWrite = false;
        this._fogEnabled = true;
        this._pixelPerfect = false;
        this._shaderLanguage = 0;
        this._useVAO = false;
        this._useInstancing = false;
        this._vertexBuffers = {};
        this._isDisposed = false;
        this._shadersLoaded = false;
        this._pixelPerfect = rendererOptions?.pixelPerfect ?? false;
        this._capacity = capacity;
        this._epsilon = epsilon;
        this._engine = engine;
        this._useInstancing = engine.getCaps().instancedArrays && engine._features.supportSpriteInstancing;
        this._useVAO = engine.getCaps().vertexArrayObject && !engine.disableVertexArrayObjects;
        this._scene = scene;
        if (!this._useInstancing) {
          this._buildIndexBuffer();
        }
        this._vertexBufferSize = this._useInstancing ? 16 : 18;
        this._vertexData = new Float32Array(capacity * this._vertexBufferSize * (this._useInstancing ? 1 : 4));
        this._buffer = new Buffer(engine, this._vertexData, true, this._vertexBufferSize);
        const positions = this._buffer.createVertexBuffer(VertexBuffer.PositionKind, 0, 4, this._vertexBufferSize, this._useInstancing);
        const options = this._buffer.createVertexBuffer("options", 4, 2, this._vertexBufferSize, this._useInstancing);
        let offset = 6;
        let offsets;
        if (this._useInstancing) {
          const spriteData = new Float32Array([
            this._epsilon,
            this._epsilon,
            1 - this._epsilon,
            this._epsilon,
            this._epsilon,
            1 - this._epsilon,
            1 - this._epsilon,
            1 - this._epsilon
          ]);
          this._spriteBuffer = new Buffer(engine, spriteData, false, 2);
          offsets = this._spriteBuffer.createVertexBuffer("offsets", 0, 2);
        } else {
          offsets = this._buffer.createVertexBuffer("offsets", offset, 2, this._vertexBufferSize, this._useInstancing);
          offset += 2;
        }
        const inverts = this._buffer.createVertexBuffer("inverts", offset, 2, this._vertexBufferSize, this._useInstancing);
        const cellInfo = this._buffer.createVertexBuffer("cellInfo", offset + 2, 4, this._vertexBufferSize, this._useInstancing);
        const colors = this._buffer.createVertexBuffer(VertexBuffer.ColorKind, offset + 6, 4, this._vertexBufferSize, this._useInstancing);
        this._vertexBuffers[VertexBuffer.PositionKind] = positions;
        this._vertexBuffers["options"] = options;
        this._vertexBuffers["offsets"] = offsets;
        this._vertexBuffers["inverts"] = inverts;
        this._vertexBuffers["cellInfo"] = cellInfo;
        this._vertexBuffers[VertexBuffer.ColorKind] = colors;
        this._initShaderSourceAsync();
      }
      async _initShaderSourceAsync() {
        const engine = this._engine;
        if (engine.isWebGPU && !_SpriteRenderer.ForceGLSL) {
          this._shaderLanguage = 1;
          await Promise.all([import("./sprites.vertex-U74QF3JR.js"), import("./sprites.fragment-KSORSCYA.js")]);
        } else {
          await Promise.all([import("./sprites.vertex-CGT4YS3D.js"), import("./sprites.fragment-ABXUP3T3.js")]);
        }
        this._shadersLoaded = true;
        this._createEffects();
      }
      _createEffects() {
        if (this._isDisposed || !this._shadersLoaded) {
          return;
        }
        this._drawWrapperBase?.dispose();
        this._drawWrapperDepth?.dispose();
        this._drawWrapperBase = new DrawWrapper(this._engine);
        this._drawWrapperDepth = new DrawWrapper(this._engine, false);
        if (this._drawWrapperBase.drawContext) {
          this._drawWrapperBase.drawContext.useInstancing = this._useInstancing;
        }
        if (this._drawWrapperDepth.drawContext) {
          this._drawWrapperDepth.drawContext.useInstancing = this._useInstancing;
        }
        let defines = "";
        if (this._pixelPerfect) {
          defines += "#define PIXEL_PERFECT\n";
        }
        if (this._scene && this._scene.fogEnabled && this._scene.fogMode !== 0 && this._fogEnabled) {
          defines += "#define FOG\n";
        }
        if (this._useLogarithmicDepth) {
          defines += "#define LOGARITHMICDEPTH\n";
        }
        this._drawWrapperBase.effect = this._engine.createEffect("sprites", [VertexBuffer.PositionKind, "options", "offsets", "inverts", "cellInfo", VertexBuffer.ColorKind], ["view", "projection", "textureInfos", "alphaTest", "vFogInfos", "vFogColor", "logarithmicDepthConstant"], ["diffuseSampler"], defines, void 0, void 0, void 0, void 0, this._shaderLanguage);
        this._drawWrapperDepth.effect = this._drawWrapperBase.effect;
        this._drawWrapperBase.effect._refCount++;
        this._drawWrapperDepth.materialContext = this._drawWrapperBase.materialContext;
      }
      /**
       * Render all child sprites
       * @param sprites defines the list of sprites to render
       * @param deltaTime defines the time since last frame
       * @param viewMatrix defines the viewMatrix to use to render the sprites
       * @param projectionMatrix defines the projectionMatrix to use to render the sprites
       * @param customSpriteUpdate defines a custom function to update the sprites data before they render
       */
      render(sprites, deltaTime, viewMatrix, projectionMatrix, customSpriteUpdate = null) {
        if (!this._shadersLoaded || !this.texture || !this.texture.isReady() || !sprites.length) {
          return;
        }
        const drawWrapper = this._drawWrapperBase;
        const drawWrapperDepth = this._drawWrapperDepth;
        const shouldRenderFog = this.fogEnabled && this._scene && this._scene.fogEnabled && this._scene.fogMode !== 0;
        const effect = drawWrapper.effect;
        if (!effect.isReady()) {
          return;
        }
        const engine = this._engine;
        const useRightHandedSystem = !!(this._scene && this._scene.useRightHandedSystem);
        const max = Math.min(this._capacity, sprites.length);
        let offset = 0;
        let noSprite = true;
        const floatingOriginOffset = this._scene?.floatingOriginOffset || Vector3.ZeroReadOnly;
        for (let index = 0; index < max; index++) {
          const sprite = sprites[index];
          if (!sprite || !sprite.isVisible) {
            continue;
          }
          noSprite = false;
          sprite._animate(deltaTime);
          const baseSize = this.texture.getBaseSize();
          this._appendSpriteVertex(offset++, sprite, 0, 0, baseSize, useRightHandedSystem, customSpriteUpdate, floatingOriginOffset);
          if (!this._useInstancing) {
            this._appendSpriteVertex(offset++, sprite, 1, 0, baseSize, useRightHandedSystem, customSpriteUpdate, floatingOriginOffset);
            this._appendSpriteVertex(offset++, sprite, 1, 1, baseSize, useRightHandedSystem, customSpriteUpdate, floatingOriginOffset);
            this._appendSpriteVertex(offset++, sprite, 0, 1, baseSize, useRightHandedSystem, customSpriteUpdate, floatingOriginOffset);
          }
        }
        if (noSprite) {
          return;
        }
        this._buffer.update(this._vertexData);
        const culling = !!engine.depthCullingState.cull;
        const zOffset = engine.depthCullingState.zOffset;
        const zOffsetUnits = engine.depthCullingState.zOffsetUnits;
        engine.setState(culling, zOffset, false, false, void 0, void 0, zOffsetUnits);
        engine.enableEffect(drawWrapper);
        effect.setTexture("diffuseSampler", this.texture);
        effect.setMatrix("view", viewMatrix);
        effect.setMatrix("projection", projectionMatrix);
        if (shouldRenderFog) {
          const scene = this._scene;
          effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
          effect.setColor3("vFogColor", scene.fogColor);
        }
        if (this.useLogarithmicDepth && this._scene) {
          BindLogDepth(drawWrapper.defines, effect, this._scene);
        }
        if (this._useVAO) {
          if (!this._vertexArrayObject) {
            this._vertexArrayObject = engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);
          }
          engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);
        } else {
          engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
        }
        engine.depthCullingState.depthFunc = engine.useReverseDepthBuffer ? 518 : 515;
        if (!this.disableDepthWrite) {
          effect.setBool("alphaTest", true);
          engine.setColorWrite(false);
          engine.enableEffect(drawWrapperDepth);
          if (this._useInstancing) {
            engine.drawArraysType(7, 0, 4, offset);
          } else {
            engine.drawElementsType(0, 0, offset / 4 * 6);
          }
          engine.enableEffect(drawWrapper);
          engine.setColorWrite(true);
          effect.setBool("alphaTest", false);
        }
        engine.setAlphaMode(this.blendMode);
        if (this._useInstancing) {
          engine.drawArraysType(7, 0, 4, offset);
        } else {
          engine.drawElementsType(0, 0, offset / 4 * 6);
        }
        if (this.autoResetAlpha) {
          engine.setAlphaMode(0);
        }
        if (useRightHandedSystem) {
          this._scene.getEngine().setState(culling, zOffset, false, true, void 0, void 0, zOffsetUnits);
        }
        engine.unbindInstanceAttributes();
      }
      _appendSpriteVertex(index, sprite, offsetX, offsetY, baseSize, useRightHandedSystem, customSpriteUpdate, floatingOriginOffset) {
        let arrayOffset = index * this._vertexBufferSize;
        if (offsetX === 0) {
          offsetX = this._epsilon;
        } else if (offsetX === 1) {
          offsetX = 1 - this._epsilon;
        }
        if (offsetY === 0) {
          offsetY = this._epsilon;
        } else if (offsetY === 1) {
          offsetY = 1 - this._epsilon;
        }
        if (customSpriteUpdate) {
          customSpriteUpdate(sprite, baseSize);
        } else {
          if (!sprite.cellIndex) {
            sprite.cellIndex = 0;
          }
          const rowSize = baseSize.width / this.cellWidth;
          const offset = sprite.cellIndex / rowSize >> 0;
          sprite._xOffset = (sprite.cellIndex - offset * rowSize) * this.cellWidth / baseSize.width;
          sprite._yOffset = offset * this.cellHeight / baseSize.height;
          sprite._xSize = this.cellWidth;
          sprite._ySize = this.cellHeight;
        }
        this._vertexData[arrayOffset] = sprite.position.x - floatingOriginOffset.x;
        this._vertexData[arrayOffset + 1] = sprite.position.y - floatingOriginOffset.y;
        this._vertexData[arrayOffset + 2] = sprite.position.z - floatingOriginOffset.z;
        this._vertexData[arrayOffset + 3] = sprite.angle;
        this._vertexData[arrayOffset + 4] = sprite.width;
        this._vertexData[arrayOffset + 5] = sprite.height;
        if (!this._useInstancing) {
          this._vertexData[arrayOffset + 6] = offsetX;
          this._vertexData[arrayOffset + 7] = offsetY;
        } else {
          arrayOffset -= 2;
        }
        if (useRightHandedSystem) {
          this._vertexData[arrayOffset + 8] = sprite.invertU ? 0 : 1;
        } else {
          this._vertexData[arrayOffset + 8] = sprite.invertU ? 1 : 0;
        }
        this._vertexData[arrayOffset + 9] = sprite.invertV ? 1 : 0;
        this._vertexData[arrayOffset + 10] = sprite._xOffset;
        this._vertexData[arrayOffset + 11] = sprite._yOffset;
        this._vertexData[arrayOffset + 12] = sprite._xSize / baseSize.width;
        this._vertexData[arrayOffset + 13] = sprite._ySize / baseSize.height;
        this._vertexData[arrayOffset + 14] = sprite.color.r;
        this._vertexData[arrayOffset + 15] = sprite.color.g;
        this._vertexData[arrayOffset + 16] = sprite.color.b;
        this._vertexData[arrayOffset + 17] = sprite.color.a;
      }
      _buildIndexBuffer() {
        const indices = [];
        let index = 0;
        for (let count = 0; count < this._capacity; count++) {
          indices.push(index);
          indices.push(index + 1);
          indices.push(index + 2);
          indices.push(index);
          indices.push(index + 2);
          indices.push(index + 3);
          index += 4;
        }
        this._indexBuffer = this._engine.createIndexBuffer(indices);
      }
      /**
       * Rebuilds the renderer (after a context lost, for eg)
       */
      rebuild() {
        if (this._indexBuffer) {
          this._buildIndexBuffer();
        }
        if (this._useVAO) {
          this._vertexArrayObject = void 0;
        }
        this._buffer._rebuild();
        for (const key in this._vertexBuffers) {
          const vertexBuffer = this._vertexBuffers[key];
          vertexBuffer._rebuild();
        }
        this._spriteBuffer?._rebuild();
      }
      /**
       * Release associated resources
       */
      dispose() {
        if (this._buffer) {
          this._buffer.dispose();
          this._buffer = null;
        }
        if (this._spriteBuffer) {
          this._spriteBuffer.dispose();
          this._spriteBuffer = null;
        }
        if (this._indexBuffer) {
          this._engine._releaseBuffer(this._indexBuffer);
          this._indexBuffer = null;
        }
        if (this._vertexArrayObject) {
          this._engine.releaseVertexArrayObject(this._vertexArrayObject);
          this._vertexArrayObject = null;
        }
        if (this.texture) {
          this.texture.dispose();
          this.texture = null;
        }
        this._drawWrapperBase?.dispose();
        this._drawWrapperDepth?.dispose();
        this._isDisposed = true;
      }
    };
    SpriteRenderer.ForceGLSL = false;
  }
});

// node_modules/@babylonjs/core/Sprites/spriteManager.js
var SpriteManager;
var init_spriteManager = __esm({
  "node_modules/@babylonjs/core/Sprites/spriteManager.js"() {
    init_observable();
    init_math_vector();
    init_sprite();
    init_spriteSceneComponent();
    init_pickingInfo();
    init_texture();
    init_sceneComponent();
    init_logger();
    init_tools();
    init_webRequest();
    init_spriteRenderer();
    init_engineStore();
    SpriteManager = class _SpriteManager {
      /**
       * Callback called when the manager is disposed
       */
      set onDispose(callback) {
        if (this._onDisposeObserver) {
          this.onDisposeObservable.remove(this._onDisposeObserver);
        }
        this._onDisposeObserver = this.onDisposeObservable.add(callback);
      }
      /**
       * Gets the array of sprites
       */
      get children() {
        return this.sprites;
      }
      /**
       * Gets the hosting scene
       */
      get scene() {
        return this._scene;
      }
      /**
       * Gets the capacity of the manager
       */
      get capacity() {
        return this._spriteRenderer.capacity;
      }
      /**
       * Gets or sets the spritesheet texture
       */
      get texture() {
        return this._spriteRenderer.texture;
      }
      set texture(value) {
        value.wrapU = Texture.CLAMP_ADDRESSMODE;
        value.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._spriteRenderer.texture = value;
        this._textureContent = null;
      }
      /** Defines the default width of a cell in the spritesheet */
      get cellWidth() {
        return this._spriteRenderer.cellWidth;
      }
      set cellWidth(value) {
        this._spriteRenderer.cellWidth = value;
      }
      /** Defines the default height of a cell in the spritesheet */
      get cellHeight() {
        return this._spriteRenderer.cellHeight;
      }
      set cellHeight(value) {
        this._spriteRenderer.cellHeight = value;
      }
      /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */
      get fogEnabled() {
        return this._spriteRenderer.fogEnabled;
      }
      set fogEnabled(value) {
        this._spriteRenderer.fogEnabled = value;
      }
      /** Gets or sets a boolean indicating if the manager must use logarithmic depth when rendering */
      get useLogarithmicDepth() {
        return this._spriteRenderer.useLogarithmicDepth;
      }
      set useLogarithmicDepth(value) {
        this._spriteRenderer.useLogarithmicDepth = value;
      }
      /**
       * Blend mode use to render the particle, it can be any of
       * the static undefined properties provided in this class.
       * Default value is 2
       */
      get blendMode() {
        return this._spriteRenderer.blendMode;
      }
      set blendMode(blendMode) {
        this._spriteRenderer.blendMode = blendMode;
      }
      /** Disables writing to the depth buffer when rendering the sprites.
       *  It can be handy to disable depth writing when using textures without alpha channel
       *  and setting some specific blend modes.
       */
      get disableDepthWrite() {
        return this._disableDepthWrite;
      }
      set disableDepthWrite(value) {
        this._disableDepthWrite = value;
        this._spriteRenderer.disableDepthWrite = value;
      }
      /**
       * Gets or sets a boolean indicating if the renderer must render sprites with pixel perfect rendering
       * In this mode, sprites are rendered as "pixel art", which means that they appear as pixelated but remain stable when moving or when rotated or scaled.
       * Note that for this mode to work as expected, the sprite texture must use the BILINEAR sampling mode, not NEAREST!
       */
      get pixelPerfect() {
        return this._spriteRenderer.pixelPerfect;
      }
      set pixelPerfect(value) {
        this._spriteRenderer.pixelPerfect = value;
        if (value && this.texture.samplingMode !== 3) {
          this.texture.updateSamplingMode(3);
        }
      }
      /**
       * Gets the sprite renderer associated with this manager
       */
      get spriteRenderer() {
        return this._spriteRenderer;
      }
      /**
       * Creates a new sprite manager
       * @param name defines the manager's name
       * @param imgUrl defines the sprite sheet url
       * @param capacity defines the maximum allowed number of sprites
       * @param cellSize defines the size of a sprite cell
       * @param scene defines the hosting scene
       * @param epsilon defines the epsilon value to align texture (0.01 by default)
       * @param samplingMode defines the sampling mode to use with spritesheet
       * @param fromPacked set to false; do not alter
       * @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter
       * @param options options used to create the SpriteManager instance
       */
      constructor(name13, imgUrl, capacity, cellSize, scene, epsilon = 0.01, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, fromPacked = false, spriteJSON = null, options) {
        this.name = name13;
        this._parentContainer = null;
        this.sprites = [];
        this.renderingGroupId = 0;
        this.layerMask = 268435455;
        this.isPickable = false;
        this.metadata = null;
        this._wasDispatched = false;
        this.onDisposeObservable = new Observable();
        this.doNotSerialize = false;
        this._disableDepthWrite = false;
        this._packedAndReady = false;
        this._customUpdate = (sprite, baseSize) => {
          if (!sprite.cellRef) {
            sprite.cellIndex = 0;
          }
          const num = sprite.cellIndex;
          if (typeof num === "number" && isFinite(num) && Math.floor(num) === num) {
            sprite.cellRef = this._spriteMap[sprite.cellIndex];
          }
          sprite._xOffset = this._cellData[sprite.cellRef].frame.x / baseSize.width;
          sprite._yOffset = this._cellData[sprite.cellRef].frame.y / baseSize.height;
          sprite._xSize = this._cellData[sprite.cellRef].frame.w;
          sprite._ySize = this._cellData[sprite.cellRef].frame.h;
        };
        if (!scene) {
          scene = EngineStore.LastCreatedScene;
        }
        if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {
          scene._addComponent(new SpriteSceneComponent(scene));
        }
        this._fromPacked = fromPacked;
        this._scene = scene;
        const engine = this._scene.getEngine();
        this._spriteRenderer = new SpriteRenderer(engine, capacity, epsilon, scene, options?.spriteRendererOptions);
        if (cellSize.width && cellSize.height) {
          this.cellWidth = cellSize.width;
          this.cellHeight = cellSize.height;
        } else if (cellSize !== void 0) {
          this.cellWidth = cellSize;
          this.cellHeight = cellSize;
        } else {
          this._spriteRenderer = null;
          return;
        }
        this._scene.spriteManagers && this._scene.spriteManagers.push(this);
        this.uniqueId = this.scene.getUniqueId();
        if (imgUrl) {
          this.texture = new Texture(imgUrl, scene, true, false, samplingMode);
        }
        if (this._fromPacked) {
          this._makePacked(imgUrl, spriteJSON);
        }
        this._scene._onNewSpriteManagerAddedObservable?.notifyObservers(this);
      }
      /**
       * Returns the string "SpriteManager"
       * @returns "SpriteManager"
       */
      getClassName() {
        return "SpriteManager";
      }
      _makePacked(imgUrl, spriteJSON) {
        if (spriteJSON !== null) {
          try {
            let celldata;
            if (typeof spriteJSON === "string") {
              celldata = JSON.parse(spriteJSON);
            } else {
              celldata = spriteJSON;
            }
            if (celldata.frames.length) {
              const frametemp = {};
              for (let i = 0; i < celldata.frames.length; i++) {
                const _f = celldata.frames[i];
                if (typeof Object.keys(_f)[0] !== "string") {
                  throw new Error("Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.");
                }
                const name13 = _f[Object.keys(_f)[0]];
                frametemp[name13] = _f;
              }
              celldata.frames = frametemp;
            }
            const spritemap = Reflect.ownKeys(celldata.frames);
            this._spriteMap = spritemap;
            this._packedAndReady = true;
            this._cellData = celldata.frames;
          } catch (e) {
            this._fromPacked = false;
            this._packedAndReady = false;
            throw new Error("Invalid JSON from string. Spritesheet managed with constant cell size.");
          }
        } else {
          const re = /\./g;
          let li;
          do {
            li = re.lastIndex;
            re.test(imgUrl);
          } while (re.lastIndex > 0);
          const jsonUrl = imgUrl.substring(0, li - 1) + ".json";
          const onerror = () => {
            Logger.Error("JSON ERROR: Unable to load JSON file.");
            this._fromPacked = false;
            this._packedAndReady = false;
          };
          const onload = (data) => {
            try {
              const celldata = JSON.parse(data);
              const spritemap = Reflect.ownKeys(celldata.frames);
              this._spriteMap = spritemap;
              this._packedAndReady = true;
              this._cellData = celldata.frames;
            } catch (e) {
              this._fromPacked = false;
              this._packedAndReady = false;
              throw new Error("Invalid JSON format. Please check documentation for format specifications.");
            }
          };
          Tools.LoadFile(jsonUrl, onload, void 0, void 0, false, onerror);
        }
      }
      _checkTextureAlpha(sprite, ray, distance, min, max) {
        if (!sprite.useAlphaForPicking || !this.texture?.isReady()) {
          return true;
        }
        const textureSize = this.texture.getSize();
        if (!this._textureContent) {
          this._textureContent = new Uint8Array(textureSize.width * textureSize.height * 4);
          this.texture.readPixels(0, 0, this._textureContent);
        }
        const contactPoint = TmpVectors.Vector3[0];
        contactPoint.copyFrom(ray.direction);
        contactPoint.normalize();
        contactPoint.scaleInPlace(distance);
        contactPoint.addInPlace(ray.origin);
        const contactPointU = (contactPoint.x - min.x) / (max.x - min.x);
        const contactPointV = 1 - (contactPoint.y - min.y) / (max.y - min.y);
        const u = sprite._xOffset * textureSize.width + contactPointU * sprite._xSize | 0;
        const v = sprite._yOffset * textureSize.height + contactPointV * sprite._ySize | 0;
        const alpha = this._textureContent[(u + v * textureSize.width) * 4 + 3];
        return alpha > 0.5;
      }
      /**
       * Intersects the sprites with a ray
       * @param ray defines the ray to intersect with
       * @param camera defines the current active camera
       * @param predicate defines a predicate used to select candidate sprites
       * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)
       * @returns null if no hit or a PickingInfo
       */
      intersects(ray, camera, predicate, fastCheck) {
        const count = Math.min(this.capacity, this.sprites.length);
        const min = Vector3.Zero();
        const max = Vector3.Zero();
        let distance = Number.MAX_VALUE;
        let currentSprite = null;
        const pickedPoint = TmpVectors.Vector3[0];
        const cameraSpacePosition = TmpVectors.Vector3[1];
        const cameraView = camera.getViewMatrix();
        let activeRay = ray;
        let pickedRay = ray;
        for (let index = 0; index < count; index++) {
          const sprite = this.sprites[index];
          if (!sprite) {
            continue;
          }
          if (predicate) {
            if (!predicate(sprite)) {
              continue;
            }
          } else if (!sprite.isPickable) {
            continue;
          }
          Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);
          if (sprite.angle) {
            Matrix.TranslationToRef(-cameraSpacePosition.x, -cameraSpacePosition.y, 0, TmpVectors.Matrix[1]);
            Matrix.TranslationToRef(cameraSpacePosition.x, cameraSpacePosition.y, 0, TmpVectors.Matrix[2]);
            Matrix.RotationZToRef(-sprite.angle, TmpVectors.Matrix[3]);
            TmpVectors.Matrix[1].multiplyToRef(TmpVectors.Matrix[3], TmpVectors.Matrix[4]);
            TmpVectors.Matrix[4].multiplyToRef(TmpVectors.Matrix[2], TmpVectors.Matrix[0]);
            activeRay = ray.clone();
            Vector3.TransformCoordinatesToRef(ray.origin, TmpVectors.Matrix[0], activeRay.origin);
            Vector3.TransformNormalToRef(ray.direction, TmpVectors.Matrix[0], activeRay.direction);
          } else {
            activeRay = ray;
          }
          min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);
          max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);
          if (activeRay.intersectsBoxMinMax(min, max)) {
            const currentDistance = Vector3.Distance(cameraSpacePosition, activeRay.origin);
            if (distance > currentDistance) {
              if (!this._checkTextureAlpha(sprite, activeRay, currentDistance, min, max)) {
                continue;
              }
              pickedRay = activeRay;
              distance = currentDistance;
              currentSprite = sprite;
              if (fastCheck) {
                break;
              }
            }
          }
        }
        if (currentSprite) {
          const result = new PickingInfo();
          cameraView.invertToRef(TmpVectors.Matrix[0]);
          result.hit = true;
          result.pickedSprite = currentSprite;
          result.distance = distance;
          const direction = TmpVectors.Vector3[2];
          direction.copyFrom(pickedRay.direction);
          direction.normalize();
          direction.scaleInPlace(distance);
          pickedRay.origin.addToRef(direction, pickedPoint);
          result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);
          return result;
        }
        return null;
      }
      /**
       * Intersects the sprites with a ray
       * @param ray defines the ray to intersect with
       * @param camera defines the current active camera
       * @param predicate defines a predicate used to select candidate sprites
       * @returns null if no hit or a PickingInfo array
       */
      multiIntersects(ray, camera, predicate) {
        const count = Math.min(this.capacity, this.sprites.length);
        const min = Vector3.Zero();
        const max = Vector3.Zero();
        let distance;
        const results = [];
        const pickedPoint = TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);
        const cameraSpacePosition = TmpVectors.Vector3[1].copyFromFloats(0, 0, 0);
        const cameraView = camera.getViewMatrix();
        for (let index = 0; index < count; index++) {
          const sprite = this.sprites[index];
          if (!sprite) {
            continue;
          }
          if (predicate) {
            if (!predicate(sprite)) {
              continue;
            }
          } else if (!sprite.isPickable) {
            continue;
          }
          Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);
          min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);
          max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);
          if (ray.intersectsBoxMinMax(min, max)) {
            distance = Vector3.Distance(cameraSpacePosition, ray.origin);
            if (!this._checkTextureAlpha(sprite, ray, distance, min, max)) {
              continue;
            }
            const result = new PickingInfo();
            results.push(result);
            cameraView.invertToRef(TmpVectors.Matrix[0]);
            result.hit = true;
            result.pickedSprite = sprite;
            result.distance = distance;
            const direction = TmpVectors.Vector3[2];
            direction.copyFrom(ray.direction);
            direction.normalize();
            direction.scaleInPlace(distance);
            ray.origin.addToRef(direction, pickedPoint);
            result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);
          }
        }
        return results;
      }
      /**
       * Render all child sprites
       */
      render() {
        if (this._fromPacked && (!this._packedAndReady || !this._spriteMap || !this._cellData)) {
          return;
        }
        const engine = this._scene.getEngine();
        const deltaTime = engine.getDeltaTime();
        if (this._packedAndReady) {
          this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix(), this._customUpdate);
        } else {
          this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix());
        }
      }
      /**
       * Rebuilds the manager (after a context lost, for eg)
       */
      rebuild() {
        this._spriteRenderer?.rebuild();
      }
      /**
       * Release associated resources
       */
      dispose() {
        if (this._spriteRenderer) {
          this._spriteRenderer.dispose();
          this._spriteRenderer = null;
        }
        this._textureContent = null;
        if (this._scene.spriteManagers) {
          const index = this._scene.spriteManagers.indexOf(this);
          this._scene.spriteManagers.splice(index, 1);
          this._scene._onSpriteManagerRemovedObservable?.notifyObservers(this);
        }
        if (this._parentContainer && this._parentContainer.spriteManagers) {
          const index = this._parentContainer.spriteManagers.indexOf(this);
          if (index > -1) {
            this._parentContainer.spriteManagers.splice(index, 1);
          }
          this._parentContainer = null;
        }
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
        this.metadata = null;
      }
      /**
       * Serializes the sprite manager to a JSON object
       * @param serializeTexture defines if the texture must be serialized as well
       * @returns the JSON object
       */
      serialize(serializeTexture = false) {
        const serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.capacity = this.capacity;
        serializationObject.cellWidth = this.cellWidth;
        serializationObject.cellHeight = this.cellHeight;
        serializationObject.fogEnabled = this.fogEnabled;
        serializationObject.blendMode = this.blendMode;
        serializationObject.disableDepthWrite = this.disableDepthWrite;
        serializationObject.pixelPerfect = this.pixelPerfect;
        serializationObject.useLogarithmicDepth = this.useLogarithmicDepth;
        if (this.texture) {
          if (serializeTexture) {
            serializationObject.texture = this.texture.serialize();
          } else {
            serializationObject.textureUrl = this.texture.name;
            serializationObject.invertY = this.texture._invertY;
          }
        }
        serializationObject.sprites = [];
        for (const sprite of this.sprites) {
          serializationObject.sprites.push(sprite.serialize());
        }
        serializationObject.metadata = this.metadata;
        return serializationObject;
      }
      /**
       * Parses a JSON object to create a new sprite manager.
       * @param parsedManager The JSON object to parse
       * @param scene The scene to create the sprite manager
       * @param rootUrl The root url to use to load external dependencies like texture
       * @returns the new sprite manager
       */
      static Parse(parsedManager, scene, rootUrl) {
        const manager = new _SpriteManager(parsedManager.name, "", parsedManager.capacity, {
          width: parsedManager.cellWidth,
          height: parsedManager.cellHeight
        }, scene);
        if (parsedManager.fogEnabled !== void 0) {
          manager.fogEnabled = parsedManager.fogEnabled;
        }
        if (parsedManager.blendMode !== void 0) {
          manager.blendMode = parsedManager.blendMode;
        }
        if (parsedManager.disableDepthWrite !== void 0) {
          manager.disableDepthWrite = parsedManager.disableDepthWrite;
        }
        if (parsedManager.pixelPerfect !== void 0) {
          manager.pixelPerfect = parsedManager.pixelPerfect;
        }
        if (parsedManager.useLogarithmicDepth !== void 0) {
          manager.useLogarithmicDepth = parsedManager.useLogarithmicDepth;
        }
        if (parsedManager.metadata !== void 0) {
          manager.metadata = parsedManager.metadata;
        }
        if (parsedManager.texture) {
          manager.texture = Texture.Parse(parsedManager.texture, scene, rootUrl);
        } else if (parsedManager.textureName) {
          manager.texture = new Texture(rootUrl + parsedManager.textureUrl, scene, false, parsedManager.invertY !== void 0 ? parsedManager.invertY : true);
        }
        for (const parsedSprite of parsedManager.sprites) {
          Sprite.Parse(parsedSprite, manager);
        }
        return manager;
      }
      /**
       * Creates a sprite manager from a snippet saved in a remote file
       * @param name defines the name of the sprite manager to create (can be null or empty to use the one from the json data)
       * @param url defines the url to load from
       * @param scene defines the hosting scene
       * @param rootUrl defines the root URL to use to load textures and relative dependencies
       * @returns a promise that will resolve to the new sprite manager
       */
      static async ParseFromFileAsync(name13, url, scene, rootUrl = "") {
        return await new Promise((resolve, reject) => {
          const request = new WebRequest();
          request.addEventListener("readystatechange", () => {
            if (request.readyState == 4) {
              if (request.status == 200) {
                const serializationObject = JSON.parse(request.responseText);
                const output = _SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
                if (name13) {
                  output.name = name13;
                }
                resolve(output);
              } else {
                reject("Unable to load the sprite manager");
              }
            }
          });
          request.open("GET", url);
          request.send();
        });
      }
      /**
       * Creates a sprite manager from a snippet saved by the sprite editor
       * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)
       * @param scene defines the hosting scene
       * @param rootUrl defines the root URL to use to load textures and relative dependencies
       * @returns a promise that will resolve to the new sprite manager
       */
      // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
      static ParseFromSnippetAsync(snippetId, scene, rootUrl = "") {
        if (snippetId === "_BLANK") {
          return Promise.resolve(new _SpriteManager("Default sprite manager", "//playground.babylonjs.com/textures/player.png", 500, 64, scene));
        }
        return new Promise((resolve, reject) => {
          const request = new WebRequest();
          request.addEventListener("readystatechange", () => {
            if (request.readyState == 4) {
              if (request.status == 200) {
                const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
                const serializationObject = JSON.parse(snippet.spriteManager);
                const output = _SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
                output.snippetId = snippetId;
                resolve(output);
              } else {
                reject("Unable to load the snippet " + snippetId);
              }
            }
          });
          request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
          request.send();
        });
      }
    };
    SpriteManager.SnippetUrl = `https://snippet.babylonjs.com`;
    SpriteManager.CreateFromSnippetAsync = SpriteManager.ParseFromSnippetAsync;
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.videoTexture.js
var init_engine_videoTexture = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.videoTexture.js"() {
    init_thinEngine();
    ThinEngine.prototype.updateVideoTexture = function(texture, video, invertY) {
      if (!texture || texture._isDisabled) {
        return;
      }
      const glformat = this._getInternalFormat(texture.format);
      const internalFormat = this._getRGBABufferInternalSizedFormat(0, texture.format);
      const wasPreviouslyBound = this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
      this._unpackFlipY(!invertY);
      try {
        if (this._videoTextureSupported === void 0) {
          this._gl.getError();
          this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, glformat, this._gl.UNSIGNED_BYTE, video);
          if (this._gl.getError() !== 0) {
            this._videoTextureSupported = false;
          } else {
            this._videoTextureSupported = true;
          }
        }
        if (!this._videoTextureSupported) {
          if (!texture._workingCanvas) {
            texture._workingCanvas = this.createCanvas(texture.width, texture.height);
            const context = texture._workingCanvas.getContext("2d");
            if (!context) {
              throw new Error("Unable to get 2d context");
            }
            texture._workingContext = context;
            texture._workingCanvas.width = texture.width;
            texture._workingCanvas.height = texture.height;
          }
          texture._workingContext.clearRect(0, 0, texture.width, texture.height);
          texture._workingContext.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, texture.width, texture.height);
          this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, glformat, this._gl.UNSIGNED_BYTE, texture._workingCanvas);
        } else {
          this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, glformat, this._gl.UNSIGNED_BYTE, video);
        }
        if (texture.generateMipMaps) {
          this._gl.generateMipmap(this._gl.TEXTURE_2D);
        }
        if (!wasPreviouslyBound) {
          this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
        }
        texture.isReady = true;
      } catch (ex) {
        texture._isDisabled = true;
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/htmlElementTexture.js
var HtmlElementTexture;
var init_htmlElementTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/htmlElementTexture.js"() {
    init_baseTexture();
    init_math_vector();
    init_observable();
    init_engine_dynamicTexture();
    init_engine_videoTexture();
    HtmlElementTexture = class _HtmlElementTexture extends BaseTexture {
      /**
       * Instantiates a HtmlElementTexture from the following parameters.
       *
       * @param name Defines the name of the texture
       * @param element Defines the video or canvas the texture is filled with
       * @param options Defines the other none mandatory texture creation options
       */
      constructor(name13, element, options) {
        super(options.scene || options.engine);
        this.onLoadObservable = new Observable();
        if (!element || !options.engine && !options.scene) {
          return;
        }
        options = {
          ..._HtmlElementTexture._DefaultOptions,
          ...options
        };
        this._generateMipMaps = options.generateMipMaps;
        this._samplingMode = options.samplingMode;
        this._textureMatrix = Matrix.Identity();
        this._format = options.format;
        this.name = name13;
        this.element = element;
        this._isVideo = !!element.getVideoPlaybackQuality;
        if (this._isVideo) {
          const engineWebGPU = this._engine;
          const createExternalTexture = engineWebGPU?.createExternalTexture;
          if (createExternalTexture) {
            this._externalTexture = createExternalTexture.call(engineWebGPU, element);
          }
        }
        this.anisotropicFilteringLevel = 1;
        this._createInternalTexture();
      }
      _createInternalTexture() {
        let width = 0;
        let height = 0;
        if (this._isVideo) {
          width = this.element.videoWidth;
          height = this.element.videoHeight;
        } else {
          width = this.element.width;
          height = this.element.height;
        }
        const engine = this._getEngine();
        if (engine) {
          this._texture = engine.createDynamicTexture(width, height, this._generateMipMaps, this._samplingMode);
          this._texture.format = this._format;
        }
        this.update();
      }
      /**
       * @returns the texture matrix used in most of the material.
       */
      getTextureMatrix() {
        return this._textureMatrix;
      }
      /**
       * Updates the content of the texture.
       * @param invertY Defines whether the texture should be inverted on Y (false by default on video and true on canvas)
       */
      update(invertY = null) {
        const engine = this._getEngine();
        if (this._texture == null || engine == null) {
          return;
        }
        const wasReady = this.isReady();
        if (this._isVideo) {
          const videoElement = this.element;
          if (videoElement.readyState < videoElement.HAVE_CURRENT_DATA) {
            return;
          }
          engine.updateVideoTexture(this._texture, this._externalTexture ? this._externalTexture : videoElement, invertY === null ? true : invertY);
        } else {
          const canvasElement = this.element;
          engine.updateDynamicTexture(this._texture, canvasElement, invertY === null ? true : invertY, false, this._format);
        }
        if (!wasReady && this.isReady()) {
          this.onLoadObservable.notifyObservers(this);
        }
      }
      /**
       * Dispose the texture and release its associated resources.
       */
      dispose() {
        this.onLoadObservable.clear();
        super.dispose();
      }
    };
    HtmlElementTexture._DefaultOptions = {
      generateMipMaps: false,
      samplingMode: 2,
      format: 5,
      engine: null,
      scene: null
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/customProceduralTexture.js
var CustomProceduralTexture;
var init_customProceduralTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/Procedurals/customProceduralTexture.js"() {
    init_logger();
    init_math_vector();
    init_math_color();
    init_texture();
    init_proceduralTexture();
    init_webRequest();
    CustomProceduralTexture = class extends ProceduralTexture {
      /**
       * Instantiates a new Custom Procedural Texture.
       * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
       * Custom Procedural textures are the easiest way to create your own procedural in your application.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures#creating-custom-procedural-textures
       * @param name Define the name of the texture
       * @param texturePath Define the folder path containing all the custom texture related files (config, shaders...)
       * @param size Define the size of the texture to create
       * @param scene Define the scene the texture belongs to
       * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture
       * @param generateMipMaps Define if the texture should creates mip maps or not
       * @param skipJson Define a boolena indicating that there is no json config file to load
       */
      constructor(name13, texturePath, size, scene, fallbackTexture, generateMipMaps, skipJson) {
        super(name13, size, null, scene, fallbackTexture, generateMipMaps);
        this._animate = true;
        this._time = 0;
        this._texturePath = texturePath;
        if (fallbackTexture && !(fallbackTexture instanceof Texture)) {
          skipJson = !!fallbackTexture.skipJson;
        }
        if (!skipJson) {
          this._loadJson(texturePath);
        } else {
          this.setFragment(this._texturePath);
        }
        this.refreshRate = 1;
      }
      _loadJson(jsonUrl) {
        const noConfigFile = () => {
          try {
            this.setFragment(this._texturePath);
          } catch (ex) {
            Logger.Log("No json or ShaderStore or DOM element found for CustomProceduralTexture");
          }
        };
        const configFileUrl = jsonUrl + "/config.json";
        const xhr = new WebRequest();
        xhr.open("GET", configFileUrl);
        xhr.addEventListener("load", () => {
          if (xhr.status === 200 || xhr.responseText && xhr.responseText.length > 0) {
            try {
              this._config = JSON.parse(xhr.response);
              this.updateShaderUniforms();
              this.updateTextures();
              this.setFragment(this._texturePath + "/custom");
              this._animate = this._config.animate;
              this.refreshRate = this._config.refreshrate;
            } catch (ex) {
              noConfigFile();
            }
          } else {
            noConfigFile();
          }
        }, false);
        xhr.addEventListener("error", () => {
          noConfigFile();
        }, false);
        try {
          xhr.send();
        } catch (ex) {
          Logger.Error("CustomProceduralTexture: Error on XHR send request.");
        }
      }
      /**
       * Is the texture ready to be used ? (rendered at least once)
       * @returns true if ready, otherwise, false.
       */
      isReady() {
        if (!super.isReady()) {
          return false;
        }
        for (const name13 in this._textures) {
          const texture = this._textures[name13];
          if (!texture.isReady()) {
            return false;
          }
        }
        return true;
      }
      /**
       * Render the texture to its associated render target.
       * @param useCameraPostProcess Define if camera post process should be applied to the texture
       */
      render(useCameraPostProcess) {
        const scene = this.getScene();
        if (this._animate && scene) {
          this._time += scene.getAnimationRatio() * 0.03;
          this.updateShaderUniforms();
        }
        super.render(useCameraPostProcess);
      }
      /**
       * Update the list of dependant textures samplers in the shader.
       */
      updateTextures() {
        for (let i = 0; i < this._config.sampler2Ds.length; i++) {
          this.setTexture(this._config.sampler2Ds[i].sample2Dname, new Texture(this._texturePath + "/" + this._config.sampler2Ds[i].textureRelativeUrl, this.getScene()));
        }
      }
      /**
       * Update the uniform values of the procedural texture in the shader.
       */
      updateShaderUniforms() {
        if (this._config) {
          for (let j = 0; j < this._config.uniforms.length; j++) {
            const uniform = this._config.uniforms[j];
            switch (uniform.type) {
              case "float":
                this.setFloat(uniform.name, uniform.value);
                break;
              case "color3":
                this.setColor3(uniform.name, new Color3(uniform.r, uniform.g, uniform.b));
                break;
              case "color4":
                this.setColor4(uniform.name, new Color4(uniform.r, uniform.g, uniform.b, uniform.a));
                break;
              case "vector2":
                this.setVector2(uniform.name, new Vector2(uniform.x, uniform.y));
                break;
              case "vector3":
                this.setVector3(uniform.name, new Vector3(uniform.x, uniform.y, uniform.z));
                break;
            }
          }
        }
        this.setFloat("time", this._time);
      }
      /**
       * Define if the texture animates or not.
       */
      get animate() {
        return this._animate;
      }
      set animate(value) {
        this._animate = value;
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/rawTexture3D.js
var RawTexture3D;
var init_rawTexture3D = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/rawTexture3D.js"() {
    init_texture();
    RawTexture3D = class extends Texture {
      /**
       * Gets the width of the texture
       */
      get width() {
        return this._texture ? this._texture.width : 0;
      }
      /**
       * Gets the height of the texture
       */
      get height() {
        return this._texture ? this._texture.height : 0;
      }
      /**
       * Gets the depth of the texture
       */
      get depth() {
        return this._texture ? this._texture.depth : 0;
      }
      /**
       * Create a new RawTexture3D
       * @param data defines the data of the texture
       * @param width defines the width of the texture
       * @param height defines the height of the texture
       * @param depth defines the depth of the texture
       * @param format defines the texture format to use
       * @param scene defines the hosting scene
       * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)
       * @param invertY defines if texture must be stored with Y axis inverted
       * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)
       * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_BYTE, Engine.TEXTURETYPE_FLOAT...)
       * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
       */
      constructor(data, width, height, depth, format, scene, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, textureType = 0, creationFlags) {
        super(null, scene, !generateMipMaps, invertY);
        this.format = format;
        this._texture = scene.getEngine().createRawTexture3D(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType, creationFlags);
        this.is3D = true;
      }
      /**
       * Update the texture with new data
       * @param data defines the data to store in the texture
       */
      update(data) {
        if (!this._texture) {
          return;
        }
        this._getEngine().updateRawTexture3D(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/shadowDepthWrapper.js
var MapMap, ShadowDepthWrapper;
var init_shadowDepthWrapper = __esm({
  "node_modules/@babylonjs/core/Materials/shadowDepthWrapper.js"() {
    init_effect();
    init_guid();
    init_drawWrapper();
    init_engineStore();
    MapMap = class {
      constructor() {
        this.mm = /* @__PURE__ */ new Map();
      }
      get(a, b) {
        const m = this.mm.get(a);
        if (m !== void 0) {
          return m.get(b);
        }
        return void 0;
      }
      set(a, b, v) {
        let m = this.mm.get(a);
        if (m === void 0) {
          this.mm.set(a, m = /* @__PURE__ */ new Map());
        }
        m.set(b, v);
      }
    };
    ShadowDepthWrapper = class {
      /** Gets the standalone status of the wrapper */
      get standalone() {
        return this._options?.standalone ?? false;
      }
      /** Gets the base material the wrapper is built upon */
      get baseMaterial() {
        return this._baseMaterial;
      }
      /** Gets the doNotInjectCode status of the wrapper */
      get doNotInjectCode() {
        return this._options?.doNotInjectCode ?? false;
      }
      /**
       * Instantiate a new shadow depth wrapper.
       * It works by injecting some specific code in the vertex/fragment shaders of the base material and is used by a shadow generator to
       * generate the shadow depth map. For more information, please refer to the documentation:
       * https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows
       * @param baseMaterial Material to wrap
       * @param scene Define the scene the material belongs to
       * @param options Options used to create the wrapper
       */
      constructor(baseMaterial, scene, options) {
        this._baseMaterial = baseMaterial;
        this._scene = scene ?? EngineStore.LastCreatedScene;
        this._options = options;
        this._subMeshToEffect = /* @__PURE__ */ new Map();
        this._subMeshToDepthWrapper = new MapMap();
        this._meshes = /* @__PURE__ */ new Map();
        this._onEffectCreatedObserver = this._baseMaterial.onEffectCreatedObservable.add((params) => {
          const mesh = params.subMesh?.getMesh();
          if (mesh && !this._meshes.has(mesh)) {
            this._meshes.set(mesh, mesh.onDisposeObservable.add((mesh2) => {
              const iterator = this._subMeshToEffect.keys();
              for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
                const subMesh = key.value;
                if (subMesh?.getMesh() === mesh2) {
                  this._subMeshToEffect.delete(subMesh);
                  this._deleteDepthWrapperEffect(subMesh);
                }
              }
            }));
          }
          if (this._subMeshToEffect.get(params.subMesh)?.[0] !== params.effect) {
            this._subMeshToEffect.set(params.subMesh, [params.effect, this._scene.getEngine().currentRenderPassId]);
            this._deleteDepthWrapperEffect(params.subMesh);
          }
        });
      }
      _deleteDepthWrapperEffect(subMesh) {
        const depthWrapperEntries = this._subMeshToDepthWrapper.mm.get(subMesh);
        if (depthWrapperEntries) {
          depthWrapperEntries.forEach((depthWrapper) => {
            depthWrapper.mainDrawWrapper.effect?.dispose();
          });
          this._subMeshToDepthWrapper.mm.delete(subMesh);
        }
      }
      /**
       * Gets the effect to use to generate the depth map
       * @param subMesh subMesh to get the effect for
       * @param shadowGenerator shadow generator to get the effect for
       * @param passIdForDrawWrapper Id of the pass for which the effect from the draw wrapper must be retrieved from
       * @returns the effect to use to generate the depth map for the subMesh + shadow generator specified
       */
      getEffect(subMesh, shadowGenerator, passIdForDrawWrapper) {
        const entry = this._subMeshToDepthWrapper.mm.get(subMesh)?.get(shadowGenerator);
        if (!entry) {
          return null;
        }
        let drawWrapper = entry.drawWrapper[passIdForDrawWrapper];
        if (!drawWrapper) {
          drawWrapper = entry.drawWrapper[passIdForDrawWrapper] = new DrawWrapper(this._scene.getEngine());
          drawWrapper.setEffect(entry.mainDrawWrapper.effect, entry.mainDrawWrapper.defines);
        }
        return drawWrapper;
      }
      /**
       * Specifies that the submesh is ready to be used for depth rendering
       * @param subMesh submesh to check
       * @param defines the list of defines to take into account when checking the effect
       * @param shadowGenerator combined with subMesh, it defines the effect to check
       * @param useInstances specifies that instances should be used
       * @param passIdForDrawWrapper Id of the pass for which the draw wrapper should be created
       * @returns a boolean indicating that the submesh is ready or not
       */
      isReadyForSubMesh(subMesh, defines, shadowGenerator, useInstances, passIdForDrawWrapper) {
        if (this.standalone) {
          if (!this._baseMaterial.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances)) {
            return false;
          }
        }
        return this._makeEffect(subMesh, defines, shadowGenerator, passIdForDrawWrapper)?.isReady() ?? false;
      }
      /**
       * Disposes the resources
       */
      dispose() {
        this._baseMaterial.onEffectCreatedObservable.remove(this._onEffectCreatedObserver);
        this._onEffectCreatedObserver = null;
        const iterator = this._meshes.entries();
        for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {
          const [mesh, observer] = entry.value;
          mesh.onDisposeObservable.remove(observer);
        }
      }
      _makeEffect(subMesh, defines, shadowGenerator, passIdForDrawWrapper) {
        const engine = this._scene.getEngine();
        const origEffectAndRenderPassId = this._subMeshToEffect.get(subMesh);
        if (!origEffectAndRenderPassId) {
          return null;
        }
        const [origEffect, origRenderPassId] = origEffectAndRenderPassId;
        if (!origEffect.isReady()) {
          return null;
        }
        let params = this._subMeshToDepthWrapper.get(subMesh, shadowGenerator);
        if (!params) {
          const mainDrawWrapper = new DrawWrapper(engine);
          mainDrawWrapper.defines = subMesh._getDrawWrapper(origRenderPassId)?.defines ?? null;
          params = {
            drawWrapper: [],
            mainDrawWrapper,
            depthDefines: "",
            token: RandomGUID()
          };
          params.drawWrapper[passIdForDrawWrapper] = mainDrawWrapper;
          this._subMeshToDepthWrapper.set(subMesh, shadowGenerator, params);
        }
        const join = defines.join("\n");
        if (params.mainDrawWrapper.effect) {
          if (join === params.depthDefines) {
            return params.mainDrawWrapper.effect;
          }
        }
        params.depthDefines = join;
        const uniforms = origEffect.getUniformNames().slice();
        let vertexCode = origEffect.vertexSourceCodeBeforeMigration, fragmentCode = origEffect.fragmentSourceCodeBeforeMigration;
        if (!vertexCode && !fragmentCode) {
          return null;
        }
        if (!this.doNotInjectCode) {
          const vertexNormalBiasCode = this._options && this._options.remappedVariables ? `#include<shadowMapVertexNormalBias>(${this._options.remappedVariables.join(",")})` : `#include<shadowMapVertexNormalBias>`, vertexMetricCode = this._options && this._options.remappedVariables ? `#include<shadowMapVertexMetric>(${this._options.remappedVariables.join(",")})` : `#include<shadowMapVertexMetric>`, fragmentSoftTransparentShadow = this._options && this._options.remappedVariables ? `#include<shadowMapFragmentSoftTransparentShadow>(${this._options.remappedVariables.join(",")})` : `#include<shadowMapFragmentSoftTransparentShadow>`, fragmentBlockCode = `#include<shadowMapFragment>`, vertexExtraDeclartion = `#include<shadowMapVertexExtraDeclaration>`;
          if (origEffect.shaderLanguage === 0) {
            vertexCode = vertexCode.replace(/void\s+?main/g, `
${vertexExtraDeclartion}
void main`);
          } else {
            vertexCode = vertexCode.replace(/@vertex/g, `
${vertexExtraDeclartion}
@vertex`);
          }
          vertexCode = vertexCode.replace(/#define SHADOWDEPTH_NORMALBIAS|#define CUSTOM_VERTEX_UPDATE_WORLDPOS/g, vertexNormalBiasCode);
          if (vertexCode.indexOf("#define SHADOWDEPTH_METRIC") !== -1) {
            vertexCode = vertexCode.replace(/#define SHADOWDEPTH_METRIC/g, vertexMetricCode);
          } else {
            vertexCode = vertexCode.replace(/}\s*$/g, vertexMetricCode + "\n}");
          }
          vertexCode = vertexCode.replace(/#define SHADER_NAME.*?\n|out vec4 glFragColor;\n/g, "");
          const hasLocationForSoftTransparentShadow = fragmentCode.indexOf("#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW") >= 0 || fragmentCode.indexOf("#define CUSTOM_FRAGMENT_BEFORE_FOG") >= 0;
          const hasLocationForFragment = fragmentCode.indexOf("#define SHADOWDEPTH_FRAGMENT") !== -1;
          let fragmentCodeToInjectAtEnd = "";
          if (!hasLocationForSoftTransparentShadow) {
            fragmentCodeToInjectAtEnd = fragmentSoftTransparentShadow + "\n";
          } else {
            fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW|#define CUSTOM_FRAGMENT_BEFORE_FOG/g, fragmentSoftTransparentShadow);
          }
          fragmentCode = fragmentCode.replace(/void\s+?main/g, Effect.IncludesShadersStore["shadowMapFragmentExtraDeclaration"] + "\nvoid main");
          if (hasLocationForFragment) {
            fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_FRAGMENT/g, fragmentBlockCode);
          } else {
            fragmentCodeToInjectAtEnd += fragmentBlockCode + "\n";
          }
          if (fragmentCodeToInjectAtEnd) {
            fragmentCode = fragmentCode.replace(/}\s*$/g, fragmentCodeToInjectAtEnd + "}");
          }
          uniforms.push("biasAndScaleSM", "depthValuesSM", "lightDataSM", "softTransparentShadowSM");
        }
        params.mainDrawWrapper.effect = engine.createEffect({
          vertexSource: vertexCode,
          fragmentSource: fragmentCode,
          vertexToken: params.token,
          fragmentToken: params.token
        }, {
          attributes: origEffect.getAttributesNames(),
          uniformsNames: uniforms,
          uniformBuffersNames: origEffect.getUniformBuffersNames(),
          samplers: origEffect.getSamplers(),
          defines: join + "\n" + origEffect.defines.replace("#define SHADOWS", "").replace(/#define SHADOW\d/g, ""),
          indexParameters: origEffect.getIndexParameters(),
          shaderLanguage: origEffect.shaderLanguage
        }, engine);
        for (let id = 0; id < params.drawWrapper.length; ++id) {
          if (id !== passIdForDrawWrapper) {
            params.drawWrapper[id]?.setEffect(params.mainDrawWrapper.effect, params.mainDrawWrapper.defines);
          }
        }
        return params.mainDrawWrapper.effect;
      }
    };
  }
});

// node_modules/@babylonjs/core/Shaders/gaussianSplattingDepth.fragment.js
var name, shader;
var init_gaussianSplattingDepth_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/gaussianSplattingDepth.fragment.js"() {
    init_shaderStore();
    name = "gaussianSplattingDepthPixelShader";
    shader = `precision highp float;varying vec2 vPosition;varying vec4 vColor;
#ifdef DEPTH_RENDER
varying float vDepthMetric;
#endif
void main(void) {float A=-dot(vPosition,vPosition);
#if defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1
float alpha=exp(A)*vColor.a;if (A<-4.) discard;
#else
if (A<-vColor.a) discard;
#endif
#ifdef DEPTH_RENDER
gl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);
#endif
}`;
    if (!ShaderStore.ShadersStore[name]) {
      ShaderStore.ShadersStore[name] = shader;
    }
  }
});

// node_modules/@babylonjs/core/Shaders/gaussianSplattingDepth.vertex.js
var name2, shader2;
var init_gaussianSplattingDepth_vertex = __esm({
  "node_modules/@babylonjs/core/Shaders/gaussianSplattingDepth.vertex.js"() {
    init_shaderStore();
    init_gaussianSplattingVertexDeclaration();
    init_gaussianSplattingUboDeclaration();
    init_gaussianSplatting();
    name2 = "gaussianSplattingDepthVertexShader";
    shader2 = `#include<__decl__gaussianSplattingVertex>
uniform vec2 invViewport;uniform vec2 dataTextureSize;uniform vec2 focal;uniform float kernelSize;uniform float alpha;uniform sampler2D covariancesATexture;uniform sampler2D covariancesBTexture;uniform sampler2D centersTexture;uniform sampler2D colorsTexture;varying vec2 vPosition;varying vec4 vColor;
#include<gaussianSplatting>
#ifdef DEPTH_RENDER
uniform vec2 depthValues;varying float vDepthMetric;
#endif
void main(void) {float splatIndex=getSplatIndex(int(position.z+0.5));Splat splat=readSplat(splatIndex);vec3 covA=splat.covA.xyz;vec3 covB=vec3(splat.covA.w,splat.covB.xy);vec4 worldPosGS=world*vec4(splat.center.xyz,1.0);vPosition=position.xy;vColor=splat.color;vColor.w*=alpha;gl_Position=gaussianSplatting(position.xy,worldPosGS.xyz,vec2(1.,1.),covA,covB,world,view,projection);
#ifdef DEPTH_RENDER
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));
#else
vDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));
#endif
#endif
}`;
    if (!ShaderStore.ShadersStore[name2]) {
      ShaderStore.ShadersStore[name2] = shader2;
    }
  }
});

// node_modules/@babylonjs/core/ShadersWGSL/gaussianSplattingDepth.fragment.js
var name3, shader3;
var init_gaussianSplattingDepth_fragment2 = __esm({
  "node_modules/@babylonjs/core/ShadersWGSL/gaussianSplattingDepth.fragment.js"() {
    init_shaderStore();
    init_gaussianSplattingFragmentDeclaration();
    name3 = "gaussianSplattingDepthPixelShader";
    shader3 = `#include<gaussianSplattingFragmentDeclaration>
varying vPosition: vec2f;varying vColor: vec4f;
#ifdef DEPTH_RENDER
varying vDepthMetric: f32;
#endif
fn checkDiscard(inPosition: vec2f,inColor: vec4f)->vec4f {var A : f32=-dot(inPosition,inPosition);var alpha : f32=exp(A)*inColor.a;
#if defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1
if (A<-4.) {discard;}
#else
if (A<-inColor.a) {discard;}
#endif
#ifdef DEPTH_RENDER
return vec4f(fragmentInputs.vDepthMetric,0.0,0.0,1.0);
#else
return vec4f(inColor.rgb,alpha);
#endif
}
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=checkDiscard(fragmentInputs.vPosition,fragmentInputs.vColor);
#if defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1
var alpha : f32=fragmentOutputs.color.a;
#endif
}
`;
    if (!ShaderStore.ShadersStoreWGSL[name3]) {
      ShaderStore.ShadersStoreWGSL[name3] = shader3;
    }
  }
});

// node_modules/@babylonjs/core/ShadersWGSL/gaussianSplattingDepth.vertex.js
var name4, shader4;
var init_gaussianSplattingDepth_vertex2 = __esm({
  "node_modules/@babylonjs/core/ShadersWGSL/gaussianSplattingDepth.vertex.js"() {
    init_shaderStore();
    init_sceneUboDeclaration();
    init_meshUboDeclaration();
    init_gaussianSplatting2();
    name4 = "gaussianSplattingDepthVertexShader";
    shader4 = `#include<sceneUboDeclaration>
#include<meshUboDeclaration>
attribute splatIndex0: vec4f;attribute splatIndex1: vec4f;attribute splatIndex2: vec4f;attribute splatIndex3: vec4f;attribute position: vec3f;uniform invViewport: vec2f;uniform dataTextureSize: vec2f;uniform focal: vec2f;uniform kernelSize: f32;uniform alpha: f32;var covariancesATexture: texture_2d<f32>;var covariancesBTexture: texture_2d<f32>;var centersTexture: texture_2d<f32>;var colorsTexture: texture_2d<f32>;varying vPosition: vec2f;varying vColor: vec4f;
#ifdef DEPTH_RENDER
uniform depthValues: vec2f;varying vDepthMetric: f32;
#endif
#include<gaussianSplatting>
@vertex
fn main(input : VertexInputs)->FragmentInputs {let splatIndex: f32=getSplatIndex(i32(input.position.z+0.5),input.splatIndex0,input.splatIndex1,input.splatIndex2,input.splatIndex3);var splat: Splat=readSplat(splatIndex,uniforms.dataTextureSize);var covA: vec3f=splat.covA.xyz;var covB: vec3f=vec3f(splat.covA.w,splat.covB.xy);let worldPos: vec4f=mesh.world*vec4f(splat.center.xyz,1.0);vertexOutputs.vPosition=input.position.xy;vertexOutputs.vColor=splat.color;vertexOutputs.vColor.w*=uniforms.alpha;vertexOutputs.position=gaussianSplatting(input.position.xy,worldPos.xyz,vec2f(1.0,1.0),covA,covB,mesh.world,scene.view,scene.projection,uniforms.focal,uniforms.invViewport,uniforms.kernelSize);
#ifdef DEPTH_RENDER
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.vDepthMetric=((-vertexOutputs.position.z+uniforms.depthValues.x)/(uniforms.depthValues.y));
#else
vertexOutputs.vDepthMetric=((vertexOutputs.position.z+uniforms.depthValues.x)/(uniforms.depthValues.y));
#endif
#endif
}`;
    if (!ShaderStore.ShadersStoreWGSL[name4]) {
      ShaderStore.ShadersStoreWGSL[name4] = shader4;
    }
  }
});

// node_modules/@babylonjs/core/Materials/GaussianSplatting/gaussianSplattingMaterial.js
var GaussianSplattingMaterialDefines, GaussianSplattingMaterial;
var init_gaussianSplattingMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/GaussianSplatting/gaussianSplattingMaterial.js"() {
    init_decorators_serialization();
    init_buffer();
    init_materialDefines();
    init_pushMaterial();
    init_typeStore();
    init_clipPlaneMaterialHelper();
    init_camera();
    init_shadowDepthWrapper();
    init_shaderMaterial();
    init_gaussianSplatting_fragment();
    init_gaussianSplatting_vertex();
    init_gaussianSplatting_fragment2();
    init_gaussianSplatting_vertex2();
    init_gaussianSplattingDepth_fragment();
    init_gaussianSplattingDepth_vertex();
    init_gaussianSplattingDepth_fragment2();
    init_gaussianSplattingDepth_vertex2();
    init_materialHelper_functions();
    GaussianSplattingMaterialDefines = class extends MaterialDefines {
      /**
       * Constructor of the defines.
       */
      constructor() {
        super();
        this.FOG = false;
        this.THIN_INSTANCES = true;
        this.LOGARITHMICDEPTH = false;
        this.CLIPPLANE = false;
        this.CLIPPLANE2 = false;
        this.CLIPPLANE3 = false;
        this.CLIPPLANE4 = false;
        this.CLIPPLANE5 = false;
        this.CLIPPLANE6 = false;
        this.SH_DEGREE = 0;
        this.COMPENSATION = false;
        this.IS_COMPOUND = false;
        this.MAX_PART_COUNT = 16;
        this.rebuild();
      }
    };
    GaussianSplattingMaterial = class _GaussianSplattingMaterial extends PushMaterial {
      /**
       * Instantiates a Gaussian Splatting Material in the given scene
       * @param name The friendly name of the material
       * @param scene The scene to add the material to
       */
      constructor(name13, scene) {
        super(name13, scene);
        this.kernelSize = _GaussianSplattingMaterial.KernelSize;
        this._compensation = _GaussianSplattingMaterial.Compensation;
        this._isDirty = false;
        this._sourceMesh = null;
        this.backFaceCulling = false;
        this.shadowDepthWrapper = _GaussianSplattingMaterial._MakeGaussianSplattingShadowDepthWrapper(scene, this.shaderLanguage);
      }
      /**
       * Set compensation default value is `GaussianSplattingMaterial.Compensation`
       */
      set compensation(value) {
        this._isDirty = this._isDirty != value;
        this._compensation = value;
      }
      /**
       * Get compensation
       */
      get compensation() {
        return this._compensation;
      }
      /**
       * Gets a boolean indicating that current material needs to register RTT
       */
      get hasRenderTargetTextures() {
        return false;
      }
      /**
       * Specifies whether or not this material should be rendered in alpha test mode.
       * @returns false
       */
      needAlphaTesting() {
        return false;
      }
      /**
       * Specifies whether or not this material should be rendered in alpha blend mode.
       * @returns true
       */
      needAlphaBlending() {
        return true;
      }
      /**
       * Checks whether the material is ready to be rendered for a given mesh.
       * @param mesh The mesh to render
       * @param subMesh The submesh to check against
       * @returns true if all the dependencies are ready (Textures, Effects...)
       */
      isReadyForSubMesh(mesh, subMesh) {
        const useInstances = true;
        const drawWrapper = subMesh._drawWrapper;
        let defines = subMesh.materialDefines;
        if (defines && this._isDirty) {
          defines.markAsUnprocessed();
        }
        if (drawWrapper.effect && this.isFrozen) {
          if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
            return true;
          }
        }
        if (!subMesh.materialDefines) {
          defines = subMesh.materialDefines = new GaussianSplattingMaterialDefines();
        }
        const scene = this.getScene();
        if (this._isReadyForSubMesh(subMesh)) {
          return true;
        }
        if (!this._sourceMesh) {
          return false;
        }
        const engine = scene.getEngine();
        const gsMesh = this._sourceMesh;
        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, false, defines, void 0, void 0, void 0, this._isVertexOutputInvariant);
        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, true);
        PrepareDefinesForAttributes(mesh, defines, false, false);
        if (engine.version > 1 || engine.isWebGPU) {
          defines["SH_DEGREE"] = gsMesh.shDegree;
        }
        defines["IS_COMPOUND"] = gsMesh.isCompound;
        const splatMaterial = gsMesh.material;
        defines["COMPENSATION"] = splatMaterial && splatMaterial.compensation ? splatMaterial.compensation : _GaussianSplattingMaterial.Compensation;
        if (defines.isDirty) {
          defines.markAsProcessed();
          scene.resetCachedMaterial();
          PrepareAttributesForInstances(_GaussianSplattingMaterial._Attribs, defines);
          PrepareUniformsAndSamplersList({
            uniformsNames: _GaussianSplattingMaterial._Uniforms,
            uniformBuffersNames: _GaussianSplattingMaterial._UniformBuffers,
            samplers: _GaussianSplattingMaterial._Samplers,
            defines
          });
          AddClipPlaneUniforms(_GaussianSplattingMaterial._Uniforms);
          const join = defines.toString();
          const effect = scene.getEngine().createEffect("gaussianSplatting", {
            attributes: _GaussianSplattingMaterial._Attribs,
            uniformsNames: _GaussianSplattingMaterial._Uniforms,
            uniformBuffersNames: _GaussianSplattingMaterial._UniformBuffers,
            samplers: _GaussianSplattingMaterial._Samplers,
            defines: join,
            onCompiled: this.onCompiled,
            onError: this.onError,
            indexParameters: {},
            shaderLanguage: this._shaderLanguage,
            extraInitializationsAsync: async () => {
              if (this._shaderLanguage === 1) {
                await Promise.all([import("./gaussianSplatting.fragment-WHHGC3FA.js"), import("./gaussianSplatting.vertex-SMBOEFR2.js")]);
              } else {
                await Promise.all([import("./gaussianSplatting.fragment-6FYXC5JH.js"), import("./gaussianSplatting.vertex-Y36LWIJC.js")]);
              }
            }
          }, engine);
          subMesh.setEffect(effect, defines, this._materialContext);
        }
        if (!subMesh.effect || !subMesh.effect.isReady()) {
          return false;
        }
        defines._renderId = scene.getRenderId();
        drawWrapper._wasPreviouslyReady = true;
        drawWrapper._wasPreviouslyUsingInstances = useInstances;
        this._isDirty = false;
        return true;
      }
      /**
       * GaussianSplattingMaterial belongs to a single mesh
       * @param mesh mesh this material belongs to
       */
      setSourceMesh(mesh) {
        this._sourceMesh = mesh;
      }
      /**
       * Bind material effect for a specific Gaussian Splatting mesh
       * @param mesh Gaussian splatting mesh
       * @param effect Splatting material or node material
       * @param scene scene that contains mesh and camera used for rendering
       */
      static BindEffect(mesh, effect, scene) {
        const engine = scene.getEngine();
        const camera = scene.activeCamera;
        const renderWidth = engine.getRenderWidth() * camera.viewport.width;
        const renderHeight = engine.getRenderHeight() * camera.viewport.height;
        const gsMaterial = mesh.material;
        if (!gsMaterial._sourceMesh) {
          return;
        }
        const gsMesh = gsMaterial._sourceMesh;
        const numberOfRigs = camera?.rigParent?.rigCameras.length || 1;
        effect.setFloat2("invViewport", 1 / (renderWidth / numberOfRigs), 1 / renderHeight);
        let focal = 1e3;
        if (camera) {
          const t = camera.getProjectionMatrix().m[5];
          if (camera.fovMode == Camera.FOVMODE_VERTICAL_FIXED) {
            focal = renderHeight * t / 2;
          } else {
            focal = renderWidth * t / 2;
          }
        }
        effect.setFloat2("focal", focal, focal);
        effect.setFloat("kernelSize", gsMaterial && gsMaterial.kernelSize ? gsMaterial.kernelSize : _GaussianSplattingMaterial.KernelSize);
        effect.setFloat("alpha", gsMaterial.alpha);
        scene.bindEyePosition(effect, "eyePosition", true);
        if (gsMesh.covariancesATexture) {
          const textureSize = gsMesh.covariancesATexture.getSize();
          effect.setFloat2("dataTextureSize", textureSize.width, textureSize.height);
          effect.setTexture("covariancesATexture", gsMesh.covariancesATexture);
          effect.setTexture("covariancesBTexture", gsMesh.covariancesBTexture);
          effect.setTexture("centersTexture", gsMesh.centersTexture);
          effect.setTexture("colorsTexture", gsMesh.colorsTexture);
          if (gsMesh.shTextures) {
            for (let i = 0; i < gsMesh.shTextures?.length; i++) {
              effect.setTexture(`shTexture${i}`, gsMesh.shTextures[i]);
            }
          }
          if (gsMesh.partIndicesTexture) {
            effect.setTexture("partIndicesTexture", gsMesh.partIndicesTexture);
            const partWorldData = new Float32Array(gsMesh.partCount * 16);
            for (let i = 0; i < gsMesh.partCount; i++) {
              gsMesh.getWorldMatrixForPart(i).toArray(partWorldData, i * 16);
            }
            effect.setMatrices("partWorld", partWorldData);
            const partVisibilityData = [];
            for (let i = 0; i < gsMesh.partCount; i++) {
              partVisibilityData.push(gsMesh.partVisibility[i] ?? 1);
            }
            effect.setArray("partVisibility", partVisibilityData);
          }
        }
      }
      /**
       * Binds the submesh to this material by preparing the effect and shader to draw
       * @param world defines the world transformation matrix
       * @param mesh defines the mesh containing the submesh
       * @param subMesh defines the submesh to bind the material to
       */
      bindForSubMesh(world, mesh, subMesh) {
        const scene = this.getScene();
        const defines = subMesh.materialDefines;
        if (!defines) {
          return;
        }
        const effect = subMesh.effect;
        if (!effect) {
          return;
        }
        this._activeEffect = effect;
        mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
        mesh.transferToEffect(world);
        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
        if (mustRebind) {
          this.bindView(effect);
          this.bindViewProjection(effect);
          _GaussianSplattingMaterial.BindEffect(mesh, this._activeEffect, scene);
          BindClipPlane(effect, this, scene);
        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
          this._needToBindSceneUbo = true;
        }
        BindFogParameters(scene, mesh, effect);
        if (this.useLogarithmicDepth) {
          BindLogDepth(defines, effect, scene);
        }
        this._afterBind(mesh, this._activeEffect, subMesh);
      }
      static _BindEffectUniforms(gsMesh, gsMaterial, shaderMaterial, scene) {
        const engine = scene.getEngine();
        const effect = shaderMaterial.getEffect();
        gsMesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
        shaderMaterial.bindView(effect);
        shaderMaterial.bindViewProjection(effect);
        const renderWidth = engine.getRenderWidth();
        const renderHeight = engine.getRenderHeight();
        effect.setFloat2("invViewport", 1 / renderWidth, 1 / renderHeight);
        const projection = scene.getProjectionMatrix();
        const t = projection.m[5];
        const focal = renderWidth * t / 2;
        effect.setFloat2("focal", focal, focal);
        effect.setFloat("kernelSize", gsMaterial && gsMaterial.kernelSize ? gsMaterial.kernelSize : _GaussianSplattingMaterial.KernelSize);
        effect.setFloat("alpha", gsMaterial.alpha);
        let minZ, maxZ;
        const camera = scene.activeCamera;
        if (!camera) {
          return;
        }
        const cameraIsOrtho = camera.mode === Camera.ORTHOGRAPHIC_CAMERA;
        if (cameraIsOrtho) {
          minZ = !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
          maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
        } else {
          minZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? camera.minZ : engine.isNDCHalfZRange ? 0 : camera.minZ;
          maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : camera.maxZ;
        }
        effect.setFloat2("depthValues", minZ, minZ + maxZ);
        if (gsMesh.covariancesATexture) {
          const textureSize = gsMesh.covariancesATexture.getSize();
          effect.setFloat2("dataTextureSize", textureSize.width, textureSize.height);
          effect.setTexture("covariancesATexture", gsMesh.covariancesATexture);
          effect.setTexture("covariancesBTexture", gsMesh.covariancesBTexture);
          effect.setTexture("centersTexture", gsMesh.centersTexture);
          effect.setTexture("colorsTexture", gsMesh.colorsTexture);
        }
      }
      /**
       * Create a depth rendering material for a Gaussian Splatting mesh
       * @param scene scene it belongs to
       * @param shaderLanguage GLSL or WGSL
       * @returns depth rendering shader material
       */
      makeDepthRenderingMaterial(scene, shaderLanguage) {
        const shaderMaterial = new ShaderMaterial("gaussianSplattingDepthRender", scene, {
          vertex: "gaussianSplattingDepth",
          fragment: "gaussianSplattingDepth"
        }, {
          attributes: _GaussianSplattingMaterial._Attribs,
          uniforms: _GaussianSplattingMaterial._Uniforms,
          samplers: _GaussianSplattingMaterial._Samplers,
          uniformBuffers: _GaussianSplattingMaterial._UniformBuffers,
          shaderLanguage,
          defines: ["#define DEPTH_RENDER"]
        });
        shaderMaterial.onBindObservable.add((mesh) => {
          const gsMaterial = mesh.material;
          const gsMesh = mesh;
          _GaussianSplattingMaterial._BindEffectUniforms(gsMesh, gsMaterial, shaderMaterial, scene);
        });
        return shaderMaterial;
      }
      static _MakeGaussianSplattingShadowDepthWrapper(scene, shaderLanguage) {
        const shaderMaterial = new ShaderMaterial("gaussianSplattingDepth", scene, {
          vertex: "gaussianSplattingDepth",
          fragment: "gaussianSplattingDepth"
        }, {
          attributes: _GaussianSplattingMaterial._Attribs,
          uniforms: _GaussianSplattingMaterial._Uniforms,
          samplers: _GaussianSplattingMaterial._Samplers,
          uniformBuffers: _GaussianSplattingMaterial._UniformBuffers,
          shaderLanguage
        });
        const shadowDepthWrapper = new ShadowDepthWrapper(shaderMaterial, scene, {
          standalone: true
        });
        shaderMaterial.onBindObservable.add((mesh) => {
          const gsMaterial = mesh.material;
          const gsMesh = mesh;
          _GaussianSplattingMaterial._BindEffectUniforms(gsMesh, gsMaterial, shaderMaterial, scene);
        });
        return shadowDepthWrapper;
      }
      /**
       * Clones the material.
       * @param name The cloned name.
       * @returns The cloned material.
       */
      clone(name13) {
        return SerializationHelper.Clone(() => new _GaussianSplattingMaterial(name13, this.getScene()), this);
      }
      /**
       * Serializes the current material to its JSON representation.
       * @returns The JSON representation.
       */
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.customType = "BABYLON.GaussianSplattingMaterial";
        return serializationObject;
      }
      /**
       * Gets the class name of the material
       * @returns "GaussianSplattingMaterial"
       */
      getClassName() {
        return "GaussianSplattingMaterial";
      }
      /**
       * Parse a JSON input to create back a Gaussian Splatting material.
       * @param source The JSON data to parse
       * @param scene The scene to create the parsed material in
       * @param rootUrl The root url of the assets the material depends upon
       * @returns the instantiated GaussianSplattingMaterial.
       */
      static Parse(source, scene, rootUrl) {
        return SerializationHelper.Parse(() => new _GaussianSplattingMaterial(source.name, scene), source, scene, rootUrl);
      }
    };
    GaussianSplattingMaterial.KernelSize = 0.3;
    GaussianSplattingMaterial.Compensation = false;
    GaussianSplattingMaterial._Attribs = [VertexBuffer.PositionKind, "splatIndex0", "splatIndex1", "splatIndex2", "splatIndex3"];
    GaussianSplattingMaterial._Samplers = ["covariancesATexture", "covariancesBTexture", "centersTexture", "colorsTexture", "shTexture0", "shTexture1", "shTexture2", "partIndicesTexture"];
    GaussianSplattingMaterial._UniformBuffers = ["Scene", "Mesh"];
    GaussianSplattingMaterial._Uniforms = [
      "world",
      "view",
      "projection",
      "vFogInfos",
      "vFogColor",
      "logarithmicDepthConstant",
      "invViewport",
      "dataTextureSize",
      "focal",
      "eyePosition",
      "kernelSize",
      "alpha",
      "depthValues",
      "partWorld",
      "partVisibility"
    ];
    RegisterClass("BABYLON.GaussianSplattingMaterial", GaussianSplattingMaterial);
  }
});

// node_modules/@babylonjs/core/Materials/Node/Blocks/gradientBlock.js
var GradientBlockColorStep, GradientBlock;
var init_gradientBlock = __esm({
  "node_modules/@babylonjs/core/Materials/Node/Blocks/gradientBlock.js"() {
    init_nodeMaterialBlock();
    init_nodeMaterialBlockConnectionPointTypes();
    init_nodeMaterialBlockTargets();
    init_typeStore();
    init_math_color();
    init_observable();
    GradientBlockColorStep = class {
      /**
       * Gets value indicating which step this color is associated with (between 0 and 1)
       */
      get step() {
        return this._step;
      }
      /**
       * Sets a value indicating which step this color is associated with (between 0 and 1)
       */
      set step(val) {
        this._step = val;
      }
      /**
       * Gets the color associated with this step
       */
      get color() {
        return this._color;
      }
      /**
       * Sets the color associated with this step
       */
      set color(val) {
        this._color = val;
      }
      /**
       * Creates a new GradientBlockColorStep
       * @param step defines a value indicating which step this color is associated with (between 0 and 1)
       * @param color defines the color associated with this step
       */
      constructor(step, color) {
        this.step = step;
        this.color = color;
      }
    };
    GradientBlock = class extends NodeMaterialBlock {
      /** calls observable when the value is changed*/
      colorStepsUpdated() {
        this.onValueChangedObservable.notifyObservers(this);
      }
      /**
       * Creates a new GradientBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13, NodeMaterialBlockTargets.Neutral);
        this.colorSteps = [new GradientBlockColorStep(0, Color3.Black()), new GradientBlockColorStep(1, Color3.White())];
        this.onValueChangedObservable = new Observable();
        this.registerInput("gradient", NodeMaterialBlockConnectionPointTypes.AutoDetect);
        this.registerOutput("output", NodeMaterialBlockConnectionPointTypes.Color3);
        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Float | NodeMaterialBlockConnectionPointTypes.Vector2 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Color4);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "GradientBlock";
      }
      /**
       * Gets the gradient input component
       */
      get gradient() {
        return this._inputs[0];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      _writeColorConstant(index, vec3) {
        const step = this.colorSteps[index];
        return `${vec3}(${step.color.r}, ${step.color.g}, ${step.color.b})`;
      }
      _buildBlock(state) {
        super._buildBlock(state);
        const output = this._outputs[0];
        const vec3 = state._getShaderType(NodeMaterialBlockConnectionPointTypes.Vector3);
        if (!this.colorSteps.length || !this.gradient.connectedPoint) {
          state.compilationString += state._declareOutput(output) + ` = ${vec3}(0., 0., 0.);
`;
          return;
        }
        const tempColor = state._getFreeVariableName("gradientTempColor");
        const tempPosition = state._getFreeVariableName("gradientTempPosition");
        state.compilationString += `${state._declareLocalVar(tempColor, NodeMaterialBlockConnectionPointTypes.Vector3)} = ${this._writeColorConstant(0, vec3)};
`;
        state.compilationString += `${state._declareLocalVar(tempPosition, NodeMaterialBlockConnectionPointTypes.Float)};
`;
        let gradientSource = this.gradient.associatedVariableName;
        if (this.gradient.connectedPoint.type !== NodeMaterialBlockConnectionPointTypes.Float) {
          gradientSource += ".x";
        }
        for (let index = 1; index < this.colorSteps.length; index++) {
          const step = this.colorSteps[index];
          const previousStep = this.colorSteps[index - 1];
          state.compilationString += `${tempPosition} = clamp((${gradientSource} - ${state._emitFloat(previousStep.step)}) / (${state._emitFloat(step.step)} -  ${state._emitFloat(previousStep.step)}), 0.0, 1.0) * step(${state._emitFloat(index)}, ${state._emitFloat(this.colorSteps.length - 1)});
`;
          state.compilationString += `${tempColor} = mix(${tempColor}, ${this._writeColorConstant(index, vec3)}, ${tempPosition});
`;
        }
        state.compilationString += state._declareOutput(output) + ` = ${tempColor};
`;
        return this;
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.colorSteps = [];
        for (const step of this.colorSteps) {
          serializationObject.colorSteps.push({
            step: step.step,
            color: {
              r: step.color.r,
              g: step.color.g,
              b: step.color.b
            }
          });
        }
        return serializationObject;
      }
      _deserialize(serializationObject, scene, rootUrl) {
        super._deserialize(serializationObject, scene, rootUrl);
        this.colorSteps.length = 0;
        for (const step of serializationObject.colorSteps) {
          this.colorSteps.push(new GradientBlockColorStep(step.step, new Color3(step.color.r, step.color.g, step.color.b)));
        }
      }
      _dumpPropertiesCode() {
        let codeString = super._dumpPropertiesCode();
        codeString += `${this._codeVariableName}.colorSteps = [];
`;
        for (const colorStep of this.colorSteps) {
          codeString += `${this._codeVariableName}.colorSteps.push(new BABYLON.GradientBlockColorStep(${colorStep.step}, new BABYLON.Color3(${colorStep.color.r}, ${colorStep.color.g}, ${colorStep.color.b})));
`;
        }
        return codeString;
      }
    };
    RegisterClass("BABYLON.GradientBlock", GradientBlock);
  }
});

// node_modules/@babylonjs/core/Maths/ThinMaths/thinMath.matrix.js
var ThinMatrix;
var init_thinMath_matrix = __esm({
  "node_modules/@babylonjs/core/Maths/ThinMaths/thinMath.matrix.js"() {
    ThinMatrix = class {
      constructor() {
        this._m = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        this.updateFlag = 0;
      }
      /**
       * Returns the matrix as a Array<number>
       * @returns the matrix underlying array.
       */
      asArray() {
        return this._m;
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/GaussianSplatting/gaussianSplattingMesh.js
var IsNative, Native, UnpackUnorm, Unpack111011, Unpack8888, UnpackRot, PLYType, PLYValue, GaussianSplattingMesh;
var init_gaussianSplattingMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/GaussianSplatting/gaussianSplattingMesh.js"() {
    init_subMesh();
    init_mesh();
    init_mesh_vertexData();
    init_math_vector();
    init_math_vector();
    init_logger();
    init_gaussianSplattingMaterial();
    init_rawTexture();
    init_thinInstanceMesh();
    init_textureTools();
    init_math_scalar();
    init_coroutine();
    init_engineStore();
    init_sceneLoader();
    IsNative = typeof _native !== "undefined";
    Native = IsNative ? _native : null;
    UnpackUnorm = (value, bits) => {
      const t = (1 << bits) - 1;
      return (value & t) / t;
    };
    Unpack111011 = (value, result) => {
      result.x = UnpackUnorm(value >>> 21, 11);
      result.y = UnpackUnorm(value >>> 11, 10);
      result.z = UnpackUnorm(value, 11);
    };
    Unpack8888 = (value, result) => {
      result[0] = UnpackUnorm(value >>> 24, 8) * 255;
      result[1] = UnpackUnorm(value >>> 16, 8) * 255;
      result[2] = UnpackUnorm(value >>> 8, 8) * 255;
      result[3] = UnpackUnorm(value, 8) * 255;
    };
    UnpackRot = (value, result) => {
      const norm = 1 / (Math.sqrt(2) * 0.5);
      const a = (UnpackUnorm(value >>> 20, 10) - 0.5) * norm;
      const b = (UnpackUnorm(value >>> 10, 10) - 0.5) * norm;
      const c = (UnpackUnorm(value, 10) - 0.5) * norm;
      const m = Math.sqrt(1 - (a * a + b * b + c * c));
      switch (value >>> 30) {
        case 0:
          result.set(m, a, b, c);
          break;
        case 1:
          result.set(a, m, b, c);
          break;
        case 2:
          result.set(a, b, m, c);
          break;
        case 3:
          result.set(a, b, c, m);
          break;
      }
    };
    (function(PLYType2) {
      PLYType2[PLYType2["FLOAT"] = 0] = "FLOAT";
      PLYType2[PLYType2["INT"] = 1] = "INT";
      PLYType2[PLYType2["UINT"] = 2] = "UINT";
      PLYType2[PLYType2["DOUBLE"] = 3] = "DOUBLE";
      PLYType2[PLYType2["UCHAR"] = 4] = "UCHAR";
      PLYType2[PLYType2["UNDEFINED"] = 5] = "UNDEFINED";
    })(PLYType || (PLYType = {}));
    (function(PLYValue2) {
      PLYValue2[PLYValue2["MIN_X"] = 0] = "MIN_X";
      PLYValue2[PLYValue2["MIN_Y"] = 1] = "MIN_Y";
      PLYValue2[PLYValue2["MIN_Z"] = 2] = "MIN_Z";
      PLYValue2[PLYValue2["MAX_X"] = 3] = "MAX_X";
      PLYValue2[PLYValue2["MAX_Y"] = 4] = "MAX_Y";
      PLYValue2[PLYValue2["MAX_Z"] = 5] = "MAX_Z";
      PLYValue2[PLYValue2["MIN_SCALE_X"] = 6] = "MIN_SCALE_X";
      PLYValue2[PLYValue2["MIN_SCALE_Y"] = 7] = "MIN_SCALE_Y";
      PLYValue2[PLYValue2["MIN_SCALE_Z"] = 8] = "MIN_SCALE_Z";
      PLYValue2[PLYValue2["MAX_SCALE_X"] = 9] = "MAX_SCALE_X";
      PLYValue2[PLYValue2["MAX_SCALE_Y"] = 10] = "MAX_SCALE_Y";
      PLYValue2[PLYValue2["MAX_SCALE_Z"] = 11] = "MAX_SCALE_Z";
      PLYValue2[PLYValue2["PACKED_POSITION"] = 12] = "PACKED_POSITION";
      PLYValue2[PLYValue2["PACKED_ROTATION"] = 13] = "PACKED_ROTATION";
      PLYValue2[PLYValue2["PACKED_SCALE"] = 14] = "PACKED_SCALE";
      PLYValue2[PLYValue2["PACKED_COLOR"] = 15] = "PACKED_COLOR";
      PLYValue2[PLYValue2["X"] = 16] = "X";
      PLYValue2[PLYValue2["Y"] = 17] = "Y";
      PLYValue2[PLYValue2["Z"] = 18] = "Z";
      PLYValue2[PLYValue2["SCALE_0"] = 19] = "SCALE_0";
      PLYValue2[PLYValue2["SCALE_1"] = 20] = "SCALE_1";
      PLYValue2[PLYValue2["SCALE_2"] = 21] = "SCALE_2";
      PLYValue2[PLYValue2["DIFFUSE_RED"] = 22] = "DIFFUSE_RED";
      PLYValue2[PLYValue2["DIFFUSE_GREEN"] = 23] = "DIFFUSE_GREEN";
      PLYValue2[PLYValue2["DIFFUSE_BLUE"] = 24] = "DIFFUSE_BLUE";
      PLYValue2[PLYValue2["OPACITY"] = 25] = "OPACITY";
      PLYValue2[PLYValue2["F_DC_0"] = 26] = "F_DC_0";
      PLYValue2[PLYValue2["F_DC_1"] = 27] = "F_DC_1";
      PLYValue2[PLYValue2["F_DC_2"] = 28] = "F_DC_2";
      PLYValue2[PLYValue2["F_DC_3"] = 29] = "F_DC_3";
      PLYValue2[PLYValue2["ROT_0"] = 30] = "ROT_0";
      PLYValue2[PLYValue2["ROT_1"] = 31] = "ROT_1";
      PLYValue2[PLYValue2["ROT_2"] = 32] = "ROT_2";
      PLYValue2[PLYValue2["ROT_3"] = 33] = "ROT_3";
      PLYValue2[PLYValue2["MIN_COLOR_R"] = 34] = "MIN_COLOR_R";
      PLYValue2[PLYValue2["MIN_COLOR_G"] = 35] = "MIN_COLOR_G";
      PLYValue2[PLYValue2["MIN_COLOR_B"] = 36] = "MIN_COLOR_B";
      PLYValue2[PLYValue2["MAX_COLOR_R"] = 37] = "MAX_COLOR_R";
      PLYValue2[PLYValue2["MAX_COLOR_G"] = 38] = "MAX_COLOR_G";
      PLYValue2[PLYValue2["MAX_COLOR_B"] = 39] = "MAX_COLOR_B";
      PLYValue2[PLYValue2["SH_0"] = 40] = "SH_0";
      PLYValue2[PLYValue2["SH_1"] = 41] = "SH_1";
      PLYValue2[PLYValue2["SH_2"] = 42] = "SH_2";
      PLYValue2[PLYValue2["SH_3"] = 43] = "SH_3";
      PLYValue2[PLYValue2["SH_4"] = 44] = "SH_4";
      PLYValue2[PLYValue2["SH_5"] = 45] = "SH_5";
      PLYValue2[PLYValue2["SH_6"] = 46] = "SH_6";
      PLYValue2[PLYValue2["SH_7"] = 47] = "SH_7";
      PLYValue2[PLYValue2["SH_8"] = 48] = "SH_8";
      PLYValue2[PLYValue2["SH_9"] = 49] = "SH_9";
      PLYValue2[PLYValue2["SH_10"] = 50] = "SH_10";
      PLYValue2[PLYValue2["SH_11"] = 51] = "SH_11";
      PLYValue2[PLYValue2["SH_12"] = 52] = "SH_12";
      PLYValue2[PLYValue2["SH_13"] = 53] = "SH_13";
      PLYValue2[PLYValue2["SH_14"] = 54] = "SH_14";
      PLYValue2[PLYValue2["SH_15"] = 55] = "SH_15";
      PLYValue2[PLYValue2["SH_16"] = 56] = "SH_16";
      PLYValue2[PLYValue2["SH_17"] = 57] = "SH_17";
      PLYValue2[PLYValue2["SH_18"] = 58] = "SH_18";
      PLYValue2[PLYValue2["SH_19"] = 59] = "SH_19";
      PLYValue2[PLYValue2["SH_20"] = 60] = "SH_20";
      PLYValue2[PLYValue2["SH_21"] = 61] = "SH_21";
      PLYValue2[PLYValue2["SH_22"] = 62] = "SH_22";
      PLYValue2[PLYValue2["SH_23"] = 63] = "SH_23";
      PLYValue2[PLYValue2["SH_24"] = 64] = "SH_24";
      PLYValue2[PLYValue2["SH_25"] = 65] = "SH_25";
      PLYValue2[PLYValue2["SH_26"] = 66] = "SH_26";
      PLYValue2[PLYValue2["SH_27"] = 67] = "SH_27";
      PLYValue2[PLYValue2["SH_28"] = 68] = "SH_28";
      PLYValue2[PLYValue2["SH_29"] = 69] = "SH_29";
      PLYValue2[PLYValue2["SH_30"] = 70] = "SH_30";
      PLYValue2[PLYValue2["SH_31"] = 71] = "SH_31";
      PLYValue2[PLYValue2["SH_32"] = 72] = "SH_32";
      PLYValue2[PLYValue2["SH_33"] = 73] = "SH_33";
      PLYValue2[PLYValue2["SH_34"] = 74] = "SH_34";
      PLYValue2[PLYValue2["SH_35"] = 75] = "SH_35";
      PLYValue2[PLYValue2["SH_36"] = 76] = "SH_36";
      PLYValue2[PLYValue2["SH_37"] = 77] = "SH_37";
      PLYValue2[PLYValue2["SH_38"] = 78] = "SH_38";
      PLYValue2[PLYValue2["SH_39"] = 79] = "SH_39";
      PLYValue2[PLYValue2["SH_40"] = 80] = "SH_40";
      PLYValue2[PLYValue2["SH_41"] = 81] = "SH_41";
      PLYValue2[PLYValue2["SH_42"] = 82] = "SH_42";
      PLYValue2[PLYValue2["SH_43"] = 83] = "SH_43";
      PLYValue2[PLYValue2["SH_44"] = 84] = "SH_44";
      PLYValue2[PLYValue2["UNDEFINED"] = 85] = "UNDEFINED";
    })(PLYValue || (PLYValue = {}));
    GaussianSplattingMesh = class _GaussianSplattingMesh extends Mesh {
      /**
       * If true, disables depth sorting of the splats (default: false)
       */
      get disableDepthSort() {
        return this._disableDepthSort;
      }
      set disableDepthSort(value) {
        if (!this._disableDepthSort && value) {
          this._worker?.terminate();
          this._worker = null;
          this._disableDepthSort = true;
        } else if (this._disableDepthSort && !value) {
          this._disableDepthSort = false;
          this._sortIsDirty = true;
          this._instanciateWorker();
        }
      }
      /**
       * View direction factor used to compute the SH view direction in the shader.
       * @deprecated Not used anymore for SH rendering
       */
      get viewDirectionFactor() {
        return Vector3.OneReadOnly;
      }
      /**
       * SH degree. 0 = no sh (default). 1 = 3 parameters. 2 = 8 parameters. 3 = 15 parameters.
       */
      get shDegree() {
        return this._shDegree;
      }
      /**
       * Number of splats in the mesh
       */
      get splatCount() {
        return this._splatIndex?.length;
      }
      /**
       * returns the splats data array buffer that contains in order : postions (3 floats), size (3 floats), color (4 bytes), orientation quaternion (4 bytes)
       */
      get splatsData() {
        return this._splatsData;
      }
      /**
       * returns the SH data arrays
       */
      get shData() {
        return this._shData;
      }
      /**
       * True when this mesh is a compound that regroups multiple Gaussian splatting parts.
       */
      get isCompound() {
        return this._partMatrices.length > 0;
      }
      /**
       * returns the part indices array
       */
      get partIndices() {
        return this._partIndices;
      }
      /**
       * Gets the part indices texture, if the mesh is a compound
       */
      get partIndicesTexture() {
        return this._partIndicesTexture;
      }
      /**
       * Gets the part visibility array, if the mesh is a compound
       */
      get partVisibility() {
        return this._partVisibility;
      }
      /**
       * Gets the covariancesA texture
       */
      get covariancesATexture() {
        return this._covariancesATexture;
      }
      /**
       * Gets the covariancesB texture
       */
      get covariancesBTexture() {
        return this._covariancesBTexture;
      }
      /**
       * Gets the centers texture
       */
      get centersTexture() {
        return this._centersTexture;
      }
      /**
       * Gets the colors texture
       */
      get colorsTexture() {
        return this._colorsTexture;
      }
      /**
       * Gets the SH textures
       */
      get shTextures() {
        return this._shTextures;
      }
      /**
       * Gets the kernel size
       * Documentation and mathematical explanations here:
       * https://github.com/graphdeco-inria/gaussian-splatting/issues/294#issuecomment-1772688093
       * https://github.com/autonomousvision/mip-splatting/issues/18#issuecomment-1929388931
       */
      get kernelSize() {
        return this._material instanceof GaussianSplattingMaterial ? this._material.kernelSize : 0;
      }
      /**
       * Get the compensation state
       */
      get compensation() {
        return this._material instanceof GaussianSplattingMaterial ? this._material.compensation : false;
      }
      /**
       * set rendering material
       */
      set material(value) {
        this._material = value;
        this._material.backFaceCulling = false;
        this._material.cullBackFaces = false;
        value.resetDrawCache();
      }
      /**
       * get rendering material
       */
      get material() {
        return this._material;
      }
      static _MakeSplatGeometryForMesh(mesh) {
        const vertexData = new VertexData();
        const originPositions = [-2, -2, 0, 2, -2, 0, 2, 2, 0, -2, 2, 0];
        const originIndices = [0, 1, 2, 0, 2, 3];
        const positions = [];
        const indices = [];
        for (let i = 0; i < _GaussianSplattingMesh._BatchSize; i++) {
          for (let j = 0; j < 12; j++) {
            if (j == 2 || j == 5 || j == 8 || j == 11) {
              positions.push(i);
            } else {
              positions.push(originPositions[j]);
            }
          }
          indices.push(originIndices.map((v) => v + i * 4));
        }
        vertexData.positions = positions;
        vertexData.indices = indices.flat();
        vertexData.applyToMesh(mesh);
      }
      /**
       * Creates a new gaussian splatting mesh
       * @param name defines the name of the mesh
       * @param url defines the url to load from (optional)
       * @param scene defines the hosting scene (optional)
       * @param keepInRam keep datas in ram for editing purpose
       */
      constructor(name13, url = null, scene = null, keepInRam = false) {
        super(name13, scene);
        this._vertexCount = 0;
        this._worker = null;
        this._modelViewProjectionMatrix = Matrix.Identity();
        this._viewProjectionMatrix = Matrix.Identity();
        this._canPostToWorker = true;
        this._readyToDisplay = false;
        this._covariancesATexture = null;
        this._covariancesBTexture = null;
        this._centersTexture = null;
        this._colorsTexture = null;
        this._splatPositions = null;
        this._splatIndex = null;
        this._shTextures = null;
        this._splatsData = null;
        this._shData = null;
        this._partIndicesTexture = null;
        this._partIndices = null;
        this._partMatrices = [];
        this._partVisibility = [];
        this._textureSize = new Vector2(0, 0);
        this._keepInRam = false;
        this._delayedTextureUpdate = null;
        this._useRGBACovariants = false;
        this._material = null;
        this._tmpCovariances = [0, 0, 0, 0, 0, 0];
        this._sortIsDirty = false;
        this._shDegree = 0;
        this._cameraViewInfos = /* @__PURE__ */ new Map();
        this.viewUpdateThreshold = _GaussianSplattingMesh._DefaultViewUpdateThreshold;
        this._disableDepthSort = false;
        this._loadingPromise = null;
        this.subMeshes = [];
        new SubMesh(0, 0, 4 * _GaussianSplattingMesh._BatchSize, 0, 6 * _GaussianSplattingMesh._BatchSize, this);
        this.setEnabled(false);
        this._useRGBACovariants = !this.getEngine().isWebGPU && this.getEngine().version === 1;
        this._keepInRam = keepInRam;
        if (url) {
          this._loadingPromise = this.loadFileAsync(url);
        }
        const gaussianSplattingMaterial = new GaussianSplattingMaterial(this.name + "_material", this._scene);
        gaussianSplattingMaterial.setSourceMesh(this);
        this._material = gaussianSplattingMaterial;
        this._scene.onCameraRemovedObservable.add((camera) => {
          const cameraId = camera.uniqueId;
          if (this._cameraViewInfos.has(cameraId)) {
            const cameraViewInfos = this._cameraViewInfos.get(cameraId);
            cameraViewInfos?.mesh.dispose();
            this._cameraViewInfos.delete(cameraId);
          }
        });
      }
      /**
       * Get the loading promise when loading the mesh from a URL in the constructor
       * @returns constructor loading promise or null if no URL was provided
       */
      getLoadingPromise() {
        return this._loadingPromise;
      }
      /**
       * Returns the class name
       * @returns "GaussianSplattingMesh"
       */
      getClassName() {
        return "GaussianSplattingMesh";
      }
      /**
       * Returns the total number of vertices (splats) within the mesh
       * @returns the total number of vertices
       */
      getTotalVertices() {
        return this._vertexCount;
      }
      /**
       * Is this node ready to be used/rendered
       * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
       * @returns true when ready
       */
      isReady(completeCheck = false) {
        if (!super.isReady(completeCheck, true)) {
          return false;
        }
        if (!this._readyToDisplay) {
          this._postToWorker(true);
          return false;
        }
        return true;
      }
      _getCameraDirection(camera) {
        const cameraViewMatrix = camera.getViewMatrix();
        const cameraProjectionMatrix = camera.getProjectionMatrix();
        const cameraViewProjectionMatrix = TmpVectors.Matrix[0];
        cameraViewMatrix.multiplyToRef(cameraProjectionMatrix, cameraViewProjectionMatrix);
        this._viewProjectionMatrix.copyFrom(cameraViewProjectionMatrix);
        const modelViewMatrix = TmpVectors.Matrix[1];
        this.getWorldMatrix().multiplyToRef(cameraViewMatrix, modelViewMatrix);
        modelViewMatrix.multiplyToRef(cameraProjectionMatrix, this._modelViewProjectionMatrix);
        const localDirection = TmpVectors.Vector3[1];
        localDirection.set(modelViewMatrix.m[2], modelViewMatrix.m[6], modelViewMatrix.m[10]);
        localDirection.normalize();
        return localDirection;
      }
      /** @internal */
      _postToWorker(forced = false) {
        const scene = this._scene;
        const frameId = scene.getFrameId();
        let outdated = false;
        this._cameraViewInfos.forEach((cameraViewInfos) => {
          if (cameraViewInfos.frameIdLastUpdate !== frameId) {
            outdated = true;
          }
        });
        const cameras = this._scene.activeCameras?.length ? this._scene.activeCameras : [this._scene.activeCamera];
        const activeViewInfos = [];
        cameras.forEach((camera) => {
          if (!camera) {
            return;
          }
          const cameraId = camera.uniqueId;
          const cameraViewInfos = this._cameraViewInfos.get(cameraId);
          if (cameraViewInfos) {
            activeViewInfos.push(cameraViewInfos);
          } else {
            const cameraMesh = new Mesh(this.name + "_cameraMesh_" + cameraId, this._scene);
            cameraMesh.reservedDataStore = { hidden: true };
            cameraMesh.setEnabled(false);
            cameraMesh.material = this.material;
            _GaussianSplattingMesh._MakeSplatGeometryForMesh(cameraMesh);
            const newViewInfos = {
              camera,
              cameraDirection: new Vector3(0, 0, 0),
              mesh: cameraMesh,
              frameIdLastUpdate: frameId,
              splatIndexBufferSet: false
            };
            activeViewInfos.push(newViewInfos);
            this._cameraViewInfos.set(cameraId, newViewInfos);
          }
        });
        activeViewInfos.sort((a, b) => a.frameIdLastUpdate - b.frameIdLastUpdate);
        const hasSortFunction = this._worker || Native?.sortSplats || this._disableDepthSort;
        if ((forced || outdated) && hasSortFunction && (this._scene.activeCameras?.length || this._scene.activeCamera) && this._canPostToWorker) {
          activeViewInfos.forEach((cameraViewInfos) => {
            const camera = cameraViewInfos.camera;
            const cameraDirection = this._getCameraDirection(camera);
            const previousCameraDirection = cameraViewInfos.cameraDirection;
            const dot = Vector3.Dot(cameraDirection, previousCameraDirection);
            if ((forced || Math.abs(dot - 1) >= this.viewUpdateThreshold) && this._canPostToWorker) {
              cameraViewInfos.cameraDirection.copyFrom(cameraDirection);
              cameraViewInfos.frameIdLastUpdate = frameId;
              this._canPostToWorker = false;
              if (this._worker) {
                this._worker.postMessage({
                  modelViewProjection: this._modelViewProjectionMatrix.m,
                  viewProjection: this._viewProjectionMatrix.m,
                  depthMix: this._depthMix,
                  cameraId: camera.uniqueId
                }, [this._depthMix.buffer]);
              } else if (Native?.sortSplats) {
                Native.sortSplats(this._modelViewProjectionMatrix, this._splatPositions, this._splatIndex, this._scene.useRightHandedSystem);
                if (cameraViewInfos.splatIndexBufferSet) {
                  cameraViewInfos.mesh.thinInstanceBufferUpdated("splatIndex");
                } else {
                  cameraViewInfos.mesh.thinInstanceSetBuffer("splatIndex", this._splatIndex, 16, false);
                  cameraViewInfos.splatIndexBufferSet = true;
                }
                this._canPostToWorker = true;
                this._readyToDisplay = true;
              }
            }
          });
        } else if (this._disableDepthSort) {
          activeViewInfos.forEach((cameraViewInfos) => {
            if (!cameraViewInfos.splatIndexBufferSet) {
              cameraViewInfos.mesh.thinInstanceSetBuffer("splatIndex", this._splatIndex, 16, false);
              cameraViewInfos.splatIndexBufferSet = true;
            }
          });
          this._canPostToWorker = true;
          this._readyToDisplay = true;
        }
      }
      /**
       * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager
       * @param subMesh defines the subMesh to render
       * @param enableAlphaMode defines if alpha mode can be changed
       * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering
       * @returns the current mesh
       */
      render(subMesh, enableAlphaMode, effectiveMeshReplacement) {
        this._postToWorker();
        if (!this._geometry && this._cameraViewInfos.size) {
          this._geometry = this._cameraViewInfos.values().next().value.mesh.geometry;
        }
        const cameraId = this._scene.activeCamera.uniqueId;
        const cameraViewInfos = this._cameraViewInfos.get(cameraId);
        if (!cameraViewInfos || !cameraViewInfos.splatIndexBufferSet) {
          return this;
        }
        const mesh = cameraViewInfos.mesh;
        mesh.getWorldMatrix().copyFrom(this.getWorldMatrix());
        return mesh.render(subMesh, enableAlphaMode, effectiveMeshReplacement);
      }
      static _TypeNameToEnum(name13) {
        switch (name13) {
          case "float":
            return 0;
          case "int":
            return 1;
          case "uint":
            return 2;
          case "double":
            return 3;
          case "uchar":
            return 4;
        }
        return 5;
      }
      static _ValueNameToEnum(name13) {
        switch (name13) {
          case "min_x":
            return 0;
          case "min_y":
            return 1;
          case "min_z":
            return 2;
          case "max_x":
            return 3;
          case "max_y":
            return 4;
          case "max_z":
            return 5;
          case "min_scale_x":
            return 6;
          case "min_scale_y":
            return 7;
          case "min_scale_z":
            return 8;
          case "max_scale_x":
            return 9;
          case "max_scale_y":
            return 10;
          case "max_scale_z":
            return 11;
          case "packed_position":
            return 12;
          case "packed_rotation":
            return 13;
          case "packed_scale":
            return 14;
          case "packed_color":
            return 15;
          case "x":
            return 16;
          case "y":
            return 17;
          case "z":
            return 18;
          case "scale_0":
            return 19;
          case "scale_1":
            return 20;
          case "scale_2":
            return 21;
          case "diffuse_red":
          case "red":
            return 22;
          case "diffuse_green":
          case "green":
            return 23;
          case "diffuse_blue":
          case "blue":
            return 24;
          case "f_dc_0":
            return 26;
          case "f_dc_1":
            return 27;
          case "f_dc_2":
            return 28;
          case "f_dc_3":
            return 29;
          case "opacity":
            return 25;
          case "rot_0":
            return 30;
          case "rot_1":
            return 31;
          case "rot_2":
            return 32;
          case "rot_3":
            return 33;
          case "min_r":
            return 34;
          case "min_g":
            return 35;
          case "min_b":
            return 36;
          case "max_r":
            return 37;
          case "max_g":
            return 38;
          case "max_b":
            return 39;
          case "f_rest_0":
            return 40;
          case "f_rest_1":
            return 41;
          case "f_rest_2":
            return 42;
          case "f_rest_3":
            return 43;
          case "f_rest_4":
            return 44;
          case "f_rest_5":
            return 45;
          case "f_rest_6":
            return 46;
          case "f_rest_7":
            return 47;
          case "f_rest_8":
            return 48;
          case "f_rest_9":
            return 49;
          case "f_rest_10":
            return 50;
          case "f_rest_11":
            return 51;
          case "f_rest_12":
            return 52;
          case "f_rest_13":
            return 53;
          case "f_rest_14":
            return 54;
          case "f_rest_15":
            return 55;
          case "f_rest_16":
            return 56;
          case "f_rest_17":
            return 57;
          case "f_rest_18":
            return 58;
          case "f_rest_19":
            return 59;
          case "f_rest_20":
            return 60;
          case "f_rest_21":
            return 61;
          case "f_rest_22":
            return 62;
          case "f_rest_23":
            return 63;
          case "f_rest_24":
            return 64;
          case "f_rest_25":
            return 65;
          case "f_rest_26":
            return 66;
          case "f_rest_27":
            return 67;
          case "f_rest_28":
            return 68;
          case "f_rest_29":
            return 69;
          case "f_rest_30":
            return 70;
          case "f_rest_31":
            return 71;
          case "f_rest_32":
            return 72;
          case "f_rest_33":
            return 73;
          case "f_rest_34":
            return 74;
          case "f_rest_35":
            return 75;
          case "f_rest_36":
            return 76;
          case "f_rest_37":
            return 77;
          case "f_rest_38":
            return 78;
          case "f_rest_39":
            return 79;
          case "f_rest_40":
            return 80;
          case "f_rest_41":
            return 81;
          case "f_rest_42":
            return 82;
          case "f_rest_43":
            return 83;
          case "f_rest_44":
            return 84;
        }
        return 85;
      }
      /**
       * Parse a PLY file header and returns metas infos on splats and chunks
       * @param data the loaded buffer
       * @returns a PLYHeader
       */
      static ParseHeader(data) {
        const ubuf = new Uint8Array(data);
        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));
        const headerEnd = "end_header\n";
        const headerEndIndex = header.indexOf(headerEnd);
        if (headerEndIndex < 0 || !header) {
          return null;
        }
        const vertexCount = parseInt(/element vertex (\d+)\n/.exec(header)[1]);
        const chunkElement = /element chunk (\d+)\n/.exec(header);
        let chunkCount = 0;
        if (chunkElement) {
          chunkCount = parseInt(chunkElement[1]);
        }
        let rowVertexOffset = 0;
        let rowChunkOffset = 0;
        const offsets = {
          double: 8,
          int: 4,
          uint: 4,
          float: 4,
          short: 2,
          ushort: 2,
          uchar: 1,
          list: 0
        };
        let ElementMode;
        (function(ElementMode2) {
          ElementMode2[ElementMode2["Vertex"] = 0] = "Vertex";
          ElementMode2[ElementMode2["Chunk"] = 1] = "Chunk";
          ElementMode2[ElementMode2["SH"] = 2] = "SH";
          ElementMode2[ElementMode2["Unused"] = 3] = "Unused";
        })(ElementMode || (ElementMode = {}));
        let chunkMode = 1;
        const vertexProperties = [];
        const chunkProperties = [];
        const filtered = header.slice(0, headerEndIndex).split("\n");
        let shDegree = 0;
        for (const prop of filtered) {
          if (prop.startsWith("property ")) {
            const [, typeName, name13] = prop.split(" ");
            const value = _GaussianSplattingMesh._ValueNameToEnum(name13);
            if (value != 85) {
              if (value >= 84) {
                shDegree = 3;
              } else if (value >= 64) {
                shDegree = Math.max(shDegree, 2);
              } else if (value >= 48) {
                shDegree = Math.max(shDegree, 1);
              }
            }
            const type = _GaussianSplattingMesh._TypeNameToEnum(typeName);
            if (chunkMode == 1) {
              chunkProperties.push({ value, type, offset: rowChunkOffset });
              rowChunkOffset += offsets[typeName];
            } else if (chunkMode == 0) {
              vertexProperties.push({ value, type, offset: rowVertexOffset });
              rowVertexOffset += offsets[typeName];
            } else if (chunkMode == 2) {
              vertexProperties.push({ value, type, offset: rowVertexOffset });
            }
            if (!offsets[typeName]) {
              Logger.Warn(`Unsupported property type: ${typeName}.`);
            }
          } else if (prop.startsWith("element ")) {
            const [, type] = prop.split(" ");
            if (type == "chunk") {
              chunkMode = 1;
            } else if (type == "vertex") {
              chunkMode = 0;
            } else if (type == "sh") {
              chunkMode = 2;
            } else {
              chunkMode = 3;
            }
          }
        }
        const dataView = new DataView(data, headerEndIndex + headerEnd.length);
        const buffer = new ArrayBuffer(_GaussianSplattingMesh._RowOutputLength * vertexCount);
        let shBuffer = null;
        let shCoefficientCount = 0;
        if (shDegree) {
          const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1;
          shCoefficientCount = shVectorCount * 3;
          shBuffer = new ArrayBuffer(shCoefficientCount * vertexCount);
        }
        return {
          vertexCount,
          chunkCount,
          rowVertexLength: rowVertexOffset,
          rowChunkLength: rowChunkOffset,
          vertexProperties,
          chunkProperties,
          dataView,
          buffer,
          shDegree,
          shCoefficientCount,
          shBuffer
        };
      }
      static _GetCompressedChunks(header, offset) {
        if (!header.chunkCount) {
          return null;
        }
        const dataView = header.dataView;
        const compressedChunks = new Array(header.chunkCount);
        for (let i = 0; i < header.chunkCount; i++) {
          const currentChunk = {
            min: new Vector3(),
            max: new Vector3(),
            minScale: new Vector3(),
            maxScale: new Vector3(),
            minColor: new Vector3(0, 0, 0),
            maxColor: new Vector3(1, 1, 1)
          };
          compressedChunks[i] = currentChunk;
          for (let propertyIndex = 0; propertyIndex < header.chunkProperties.length; propertyIndex++) {
            const property = header.chunkProperties[propertyIndex];
            let value;
            switch (property.type) {
              case 0:
                value = dataView.getFloat32(property.offset + offset.value, true);
                break;
              default:
                continue;
            }
            switch (property.value) {
              case 0:
                currentChunk.min.x = value;
                break;
              case 1:
                currentChunk.min.y = value;
                break;
              case 2:
                currentChunk.min.z = value;
                break;
              case 3:
                currentChunk.max.x = value;
                break;
              case 4:
                currentChunk.max.y = value;
                break;
              case 5:
                currentChunk.max.z = value;
                break;
              case 6:
                currentChunk.minScale.x = value;
                break;
              case 7:
                currentChunk.minScale.y = value;
                break;
              case 8:
                currentChunk.minScale.z = value;
                break;
              case 9:
                currentChunk.maxScale.x = value;
                break;
              case 10:
                currentChunk.maxScale.y = value;
                break;
              case 11:
                currentChunk.maxScale.z = value;
                break;
              case 34:
                currentChunk.minColor.x = value;
                break;
              case 35:
                currentChunk.minColor.y = value;
                break;
              case 36:
                currentChunk.minColor.z = value;
                break;
              case 37:
                currentChunk.maxColor.x = value;
                break;
              case 38:
                currentChunk.maxColor.y = value;
                break;
              case 39:
                currentChunk.maxColor.z = value;
                break;
            }
          }
          offset.value += header.rowChunkLength;
        }
        return compressedChunks;
      }
      static _GetSplat(header, index, compressedChunks, offset) {
        const q = TmpVectors.Quaternion[0];
        const temp3 = TmpVectors.Vector3[0];
        const rowOutputLength = _GaussianSplattingMesh._RowOutputLength;
        const buffer = header.buffer;
        const dataView = header.dataView;
        const position = new Float32Array(buffer, index * rowOutputLength, 3);
        const scale = new Float32Array(buffer, index * rowOutputLength + 12, 3);
        const rgba = new Uint8ClampedArray(buffer, index * rowOutputLength + 24, 4);
        const rot = new Uint8ClampedArray(buffer, index * rowOutputLength + 28, 4);
        let sh = null;
        if (header.shBuffer) {
          sh = new Uint8ClampedArray(header.shBuffer, index * header.shCoefficientCount, header.shCoefficientCount);
        }
        const chunkIndex = index >> 8;
        let r0 = 255;
        let r1 = 0;
        let r2 = 0;
        let r3 = 0;
        const plySH = [];
        for (let propertyIndex = 0; propertyIndex < header.vertexProperties.length; propertyIndex++) {
          const property = header.vertexProperties[propertyIndex];
          let value;
          switch (property.type) {
            case 0:
              value = dataView.getFloat32(offset.value + property.offset, true);
              break;
            case 1:
              value = dataView.getInt32(offset.value + property.offset, true);
              break;
            case 2:
              value = dataView.getUint32(offset.value + property.offset, true);
              break;
            case 3:
              value = dataView.getFloat64(offset.value + property.offset, true);
              break;
            case 4:
              value = dataView.getUint8(offset.value + property.offset);
              break;
            default:
              continue;
          }
          switch (property.value) {
            case 12:
              {
                const compressedChunk = compressedChunks[chunkIndex];
                Unpack111011(value, temp3);
                position[0] = Scalar.Lerp(compressedChunk.min.x, compressedChunk.max.x, temp3.x);
                position[1] = Scalar.Lerp(compressedChunk.min.y, compressedChunk.max.y, temp3.y);
                position[2] = Scalar.Lerp(compressedChunk.min.z, compressedChunk.max.z, temp3.z);
              }
              break;
            case 13:
              {
                UnpackRot(value, q);
                r0 = q.x;
                r1 = q.y;
                r2 = q.z;
                r3 = q.w;
              }
              break;
            case 14:
              {
                const compressedChunk = compressedChunks[chunkIndex];
                Unpack111011(value, temp3);
                scale[0] = Math.exp(Scalar.Lerp(compressedChunk.minScale.x, compressedChunk.maxScale.x, temp3.x));
                scale[1] = Math.exp(Scalar.Lerp(compressedChunk.minScale.y, compressedChunk.maxScale.y, temp3.y));
                scale[2] = Math.exp(Scalar.Lerp(compressedChunk.minScale.z, compressedChunk.maxScale.z, temp3.z));
              }
              break;
            case 15:
              {
                const compressedChunk = compressedChunks[chunkIndex];
                Unpack8888(value, rgba);
                rgba[0] = Scalar.Lerp(compressedChunk.minColor.x, compressedChunk.maxColor.x, rgba[0] / 255) * 255;
                rgba[1] = Scalar.Lerp(compressedChunk.minColor.y, compressedChunk.maxColor.y, rgba[1] / 255) * 255;
                rgba[2] = Scalar.Lerp(compressedChunk.minColor.z, compressedChunk.maxColor.z, rgba[2] / 255) * 255;
              }
              break;
            case 16:
              position[0] = value;
              break;
            case 17:
              position[1] = value;
              break;
            case 18:
              position[2] = value;
              break;
            case 19:
              scale[0] = Math.exp(value);
              break;
            case 20:
              scale[1] = Math.exp(value);
              break;
            case 21:
              scale[2] = Math.exp(value);
              break;
            case 22:
              rgba[0] = value;
              break;
            case 23:
              rgba[1] = value;
              break;
            case 24:
              rgba[2] = value;
              break;
            case 26:
              rgba[0] = (0.5 + _GaussianSplattingMesh._SH_C0 * value) * 255;
              break;
            case 27:
              rgba[1] = (0.5 + _GaussianSplattingMesh._SH_C0 * value) * 255;
              break;
            case 28:
              rgba[2] = (0.5 + _GaussianSplattingMesh._SH_C0 * value) * 255;
              break;
            case 29:
              rgba[3] = (0.5 + _GaussianSplattingMesh._SH_C0 * value) * 255;
              break;
            case 25:
              rgba[3] = 1 / (1 + Math.exp(-value)) * 255;
              break;
            case 30:
              r0 = value;
              break;
            case 31:
              r1 = value;
              break;
            case 32:
              r2 = value;
              break;
            case 33:
              r3 = value;
              break;
          }
          if (sh && property.value >= 40 && property.value <= 84) {
            const shIndex = property.value - 40;
            if (property.type == 4 && header.chunkCount) {
              const compressedValue = dataView.getUint8(header.rowChunkLength * header.chunkCount + header.vertexCount * header.rowVertexLength + index * header.shCoefficientCount + shIndex);
              plySH[shIndex] = (compressedValue * (8 / 255) - 4) * 127.5 + 127.5;
            } else {
              const clampedValue = Scalar.Clamp(value * 127.5 + 127.5, 0, 255);
              plySH[shIndex] = clampedValue;
            }
          }
        }
        if (sh) {
          const shDim = header.shDegree == 1 ? 3 : header.shDegree == 2 ? 8 : 15;
          for (let j = 0; j < shDim; j++) {
            sh[j * 3 + 0] = plySH[j];
            sh[j * 3 + 1] = plySH[j + shDim];
            sh[j * 3 + 2] = plySH[j + shDim * 2];
          }
        }
        q.set(r1, r2, r3, r0);
        q.normalize();
        rot[0] = q.w * 127.5 + 127.5;
        rot[1] = q.x * 127.5 + 127.5;
        rot[2] = q.y * 127.5 + 127.5;
        rot[3] = q.z * 127.5 + 127.5;
        offset.value += header.rowVertexLength;
      }
      /**
       * Converts a .ply data with SH coefficients splat
       * if data array buffer is not ply, returns the original buffer
       * @param data the .ply data to load
       * @param useCoroutine use coroutine and yield
       * @returns the loaded splat buffer and optional array of sh coefficients
       */
      static *ConvertPLYWithSHToSplat(data, useCoroutine = false) {
        const header = _GaussianSplattingMesh.ParseHeader(data);
        if (!header) {
          return { buffer: data };
        }
        const offset = { value: 0 };
        const compressedChunks = _GaussianSplattingMesh._GetCompressedChunks(header, offset);
        for (let i = 0; i < header.vertexCount; i++) {
          _GaussianSplattingMesh._GetSplat(header, i, compressedChunks, offset);
          if (i % _GaussianSplattingMesh._PlyConversionBatchSize === 0 && useCoroutine) {
            yield;
          }
        }
        let sh = null;
        if (header.shDegree && header.shBuffer) {
          const textureCount = Math.ceil(header.shCoefficientCount / 16);
          let shIndexRead = 0;
          const ubuf = new Uint8Array(header.shBuffer);
          sh = [];
          const splatCount = header.vertexCount;
          const engine = EngineStore.LastCreatedEngine;
          if (engine) {
            const width = engine.getCaps().maxTextureSize;
            const height = Math.ceil(splatCount / width);
            for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {
              const texture = new Uint8Array(height * width * 4 * 4);
              sh.push(texture);
            }
            for (let i = 0; i < splatCount; i++) {
              for (let shIndexWrite = 0; shIndexWrite < header.shCoefficientCount; shIndexWrite++) {
                const shValue = ubuf[shIndexRead++];
                const textureIndex = Math.floor(shIndexWrite / 16);
                const shArray = sh[textureIndex];
                const byteIndexInTexture = shIndexWrite % 16;
                const offsetPerSplat = i * 16;
                shArray[byteIndexInTexture + offsetPerSplat] = shValue;
              }
            }
          }
        }
        return { buffer: header.buffer, sh };
      }
      /**
       * Converts a .ply data array buffer to splat
       * if data array buffer is not ply, returns the original buffer
       * @param data the .ply data to load
       * @param useCoroutine use coroutine and yield
       * @returns the loaded splat buffer without SH coefficient, whether ply contains or not SH.
       */
      static *ConvertPLYToSplat(data, useCoroutine = false) {
        const header = _GaussianSplattingMesh.ParseHeader(data);
        if (!header) {
          return data;
        }
        const offset = { value: 0 };
        const compressedChunks = _GaussianSplattingMesh._GetCompressedChunks(header, offset);
        for (let i = 0; i < header.vertexCount; i++) {
          _GaussianSplattingMesh._GetSplat(header, i, compressedChunks, offset);
          if (i % _GaussianSplattingMesh._PlyConversionBatchSize === 0 && useCoroutine) {
            yield;
          }
        }
        return header.buffer;
      }
      /**
       * Converts a .ply data array buffer to splat
       * if data array buffer is not ply, returns the original buffer
       * @param data the .ply data to load
       * @returns the loaded splat buffer
       */
      static async ConvertPLYToSplatAsync(data) {
        return await runCoroutineAsync(_GaussianSplattingMesh.ConvertPLYToSplat(data, true), createYieldingScheduler());
      }
      /**
       * Converts a .ply with SH data array buffer to splat
       * if data array buffer is not ply, returns the original buffer
       * @param data the .ply data to load
       * @returns the loaded splat buffer with SH
       */
      static async ConvertPLYWithSHToSplatAsync(data) {
        return await runCoroutineAsync(_GaussianSplattingMesh.ConvertPLYWithSHToSplat(data, true), createYieldingScheduler());
      }
      /**
       * Loads a .splat Gaussian Splatting array buffer asynchronously
       * @param data arraybuffer containing splat file
       * @returns a promise that resolves when the operation is complete
       */
      async loadDataAsync(data) {
        return await this.updateDataAsync(data);
      }
      /**
       * Loads a Gaussian or Splatting file asynchronously
       * @param url path to the splat file to load
       * @param scene optional scene it belongs to
       * @returns a promise that resolves when the operation is complete
       * @deprecated Please use SceneLoader.ImportMeshAsync instead
       */
      async loadFileAsync(url, scene) {
        await ImportMeshAsync(url, scene || EngineStore.LastCreatedScene, { pluginOptions: { splat: { gaussianSplattingMesh: this } } });
      }
      /**
       * Releases resources associated with this mesh.
       * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
       */
      dispose(doNotRecurse) {
        this._covariancesATexture?.dispose();
        this._covariancesBTexture?.dispose();
        this._centersTexture?.dispose();
        this._colorsTexture?.dispose();
        if (this._shTextures) {
          for (const shTexture of this._shTextures) {
            shTexture.dispose();
          }
        }
        if (this._partIndicesTexture) {
          this._partIndicesTexture.dispose();
        }
        this._covariancesATexture = null;
        this._covariancesBTexture = null;
        this._centersTexture = null;
        this._colorsTexture = null;
        this._shTextures = null;
        this._partIndicesTexture = null;
        this._partMatrices = [];
        this._worker?.terminate();
        this._worker = null;
        this._cameraViewInfos.forEach((cameraViewInfo) => {
          cameraViewInfo.mesh.dispose();
        });
        super.dispose(doNotRecurse, true);
      }
      _copyTextures(source) {
        this._covariancesATexture = source.covariancesATexture?.clone();
        this._covariancesBTexture = source.covariancesBTexture?.clone();
        this._centersTexture = source.centersTexture?.clone();
        this._colorsTexture = source.colorsTexture?.clone();
        this._partIndicesTexture = source._partIndicesTexture?.clone();
        if (source._shTextures) {
          this._shTextures = [];
          for (const shTexture of source._shTextures) {
            this._shTextures?.push(shTexture.clone());
          }
        }
      }
      /**
       * Returns a new Mesh object generated from the current mesh properties.
       * @param name is a string, the name given to the new mesh
       * @returns a new Gaussian Splatting Mesh
       */
      clone(name13 = "") {
        const newGS = new _GaussianSplattingMesh(name13, void 0, this.getScene());
        newGS._copySource(this);
        newGS.makeGeometryUnique();
        newGS._vertexCount = this._vertexCount;
        newGS._copyTextures(this);
        newGS._modelViewProjectionMatrix = Matrix.Identity();
        newGS._viewProjectionMatrix = Matrix.Identity();
        newGS._splatPositions = this._splatPositions;
        newGS._readyToDisplay = false;
        newGS._disableDepthSort = this._disableDepthSort;
        newGS._partMatrices = this._partMatrices.map((m) => m.clone());
        newGS._instanciateWorker();
        const binfo = this.getBoundingInfo();
        newGS.getBoundingInfo().reConstruct(binfo.minimum, binfo.maximum, this.getWorldMatrix());
        newGS.forcedInstanceCount = this.forcedInstanceCount;
        newGS.setEnabled(true);
        return newGS;
      }
      _makeEmptySplat(index, covA, covB, colorArray) {
        const covBSItemSize = this._useRGBACovariants ? 4 : 2;
        this._splatPositions[4 * index + 0] = 0;
        this._splatPositions[4 * index + 1] = 0;
        this._splatPositions[4 * index + 2] = 0;
        covA[index * 4 + 0] = ToHalfFloat(0);
        covA[index * 4 + 1] = ToHalfFloat(0);
        covA[index * 4 + 2] = ToHalfFloat(0);
        covA[index * 4 + 3] = ToHalfFloat(0);
        covB[index * covBSItemSize + 0] = ToHalfFloat(0);
        covB[index * covBSItemSize + 1] = ToHalfFloat(0);
        colorArray[index * 4 + 3] = 0;
      }
      _makeSplat(index, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum, options) {
        const matrixRotation = TmpVectors.Matrix[0];
        const matrixScale = TmpVectors.Matrix[1];
        const quaternion = TmpVectors.Quaternion[0];
        const covBSItemSize = this._useRGBACovariants ? 4 : 2;
        const x = fBuffer[8 * index + 0];
        const y = fBuffer[8 * index + 1] * (options.flipY ? -1 : 1);
        const z = fBuffer[8 * index + 2];
        this._splatPositions[4 * index + 0] = x;
        this._splatPositions[4 * index + 1] = y;
        this._splatPositions[4 * index + 2] = z;
        minimum.minimizeInPlaceFromFloats(x, y, z);
        maximum.maximizeInPlaceFromFloats(x, y, z);
        quaternion.set((uBuffer[32 * index + 28 + 1] - 127.5) / 127.5, (uBuffer[32 * index + 28 + 2] - 127.5) / 127.5, (uBuffer[32 * index + 28 + 3] - 127.5) / 127.5, -(uBuffer[32 * index + 28 + 0] - 127.5) / 127.5);
        quaternion.normalize();
        quaternion.toRotationMatrix(matrixRotation);
        Matrix.ScalingToRef(fBuffer[8 * index + 3 + 0] * 2, fBuffer[8 * index + 3 + 1] * 2, fBuffer[8 * index + 3 + 2] * 2, matrixScale);
        const m = matrixRotation.multiplyToRef(matrixScale, TmpVectors.Matrix[0]).m;
        const covariances = this._tmpCovariances;
        covariances[0] = m[0] * m[0] + m[1] * m[1] + m[2] * m[2];
        covariances[1] = m[0] * m[4] + m[1] * m[5] + m[2] * m[6];
        covariances[2] = m[0] * m[8] + m[1] * m[9] + m[2] * m[10];
        covariances[3] = m[4] * m[4] + m[5] * m[5] + m[6] * m[6];
        covariances[4] = m[4] * m[8] + m[5] * m[9] + m[6] * m[10];
        covariances[5] = m[8] * m[8] + m[9] * m[9] + m[10] * m[10];
        let factor = -1e4;
        for (let covIndex = 0; covIndex < 6; covIndex++) {
          factor = Math.max(factor, Math.abs(covariances[covIndex]));
        }
        this._splatPositions[4 * index + 3] = factor;
        const transform = factor;
        covA[index * 4 + 0] = ToHalfFloat(covariances[0] / transform);
        covA[index * 4 + 1] = ToHalfFloat(covariances[1] / transform);
        covA[index * 4 + 2] = ToHalfFloat(covariances[2] / transform);
        covA[index * 4 + 3] = ToHalfFloat(covariances[3] / transform);
        covB[index * covBSItemSize + 0] = ToHalfFloat(covariances[4] / transform);
        covB[index * covBSItemSize + 1] = ToHalfFloat(covariances[5] / transform);
        colorArray[index * 4 + 0] = uBuffer[32 * index + 24 + 0];
        colorArray[index * 4 + 1] = uBuffer[32 * index + 24 + 1];
        colorArray[index * 4 + 2] = uBuffer[32 * index + 24 + 2];
        colorArray[index * 4 + 3] = uBuffer[32 * index + 24 + 3];
      }
      // NB: partIndices is assumed to be padded to a round texture size
      _updateTextures(covA, covB, colorArray, sh, partIndices) {
        const textureSize = this._getTextureSize(this._vertexCount);
        const createTextureFromData = (data, width, height, format) => {
          return new RawTexture(data, width, height, format, this._scene, false, false, 2, 1);
        };
        const createTextureFromDataU8 = (data, width, height, format) => {
          return new RawTexture(data, width, height, format, this._scene, false, false, 2, 0);
        };
        const createTextureFromDataU32 = (data, width, height, format) => {
          return new RawTexture(data, width, height, format, this._scene, false, false, 1, 7);
        };
        const createTextureFromDataF16 = (data, width, height, format) => {
          return new RawTexture(data, width, height, format, this._scene, false, false, 2, 2);
        };
        const firstTime = this._covariancesATexture === null;
        const textureSizeChanged = this._textureSize.y < textureSize.y;
        if (!firstTime && !textureSizeChanged) {
          this._delayedTextureUpdate = { covA, covB, colors: colorArray, centers: this._splatPositions, sh, partIndices };
          const positions = Float32Array.from(this._splatPositions);
          const vertexCount = this._vertexCount;
          if (this._worker) {
            this._worker.postMessage({ positions, vertexCount }, [positions.buffer]);
          }
          if (sh && !this._shTextures) {
            this._shTextures = [];
            for (const shData of sh) {
              const buffer = new Uint32Array(shData.buffer);
              const shTexture = createTextureFromDataU32(buffer, textureSize.x, textureSize.y, 11);
              shTexture.wrapU = 0;
              shTexture.wrapV = 0;
              this._shTextures.push(shTexture);
            }
          }
          if (partIndices && !this._partIndicesTexture) {
            const buffer = new Uint8Array(partIndices);
            this._partIndicesTexture = createTextureFromDataU8(buffer, textureSize.x, textureSize.y, 6);
            this._partIndicesTexture.wrapU = 0;
            this._partIndicesTexture.wrapV = 0;
          }
          if (this._worker) {
            this._worker.postMessage({ partIndices: partIndices ?? null });
          }
          this._postToWorker(true);
        } else {
          this._textureSize = textureSize;
          this._covariancesATexture = createTextureFromDataF16(covA, textureSize.x, textureSize.y, 5);
          this._covariancesBTexture = createTextureFromDataF16(covB, textureSize.x, textureSize.y, this._useRGBACovariants ? 5 : 7);
          this._centersTexture = createTextureFromData(this._splatPositions, textureSize.x, textureSize.y, 5);
          this._colorsTexture = createTextureFromDataU8(colorArray, textureSize.x, textureSize.y, 5);
          if (sh) {
            this._shTextures = [];
            for (const shData of sh) {
              const buffer = new Uint32Array(shData.buffer);
              const shTexture = createTextureFromDataU32(buffer, textureSize.x, textureSize.y, 11);
              shTexture.wrapU = 0;
              shTexture.wrapV = 0;
              this._shTextures.push(shTexture);
            }
          }
          if (partIndices) {
            const buffer = new Uint8Array(partIndices);
            this._partIndicesTexture = createTextureFromDataU8(buffer, textureSize.x, textureSize.y, 6);
            this._partIndicesTexture.wrapU = 0;
            this._partIndicesTexture.wrapV = 0;
          }
          if (firstTime) {
            this._instanciateWorker();
          } else {
            if (this._worker) {
              const positions = Float32Array.from(this._splatPositions);
              const vertexCount = this._vertexCount;
              this._worker.postMessage({ positions, vertexCount }, [positions.buffer]);
              this._worker.postMessage({ partIndices: partIndices ?? null });
            }
            this._postToWorker(true);
          }
        }
      }
      *_updateData(data, isAsync, sh, partIndices, options = { flipY: false }) {
        if (!this._covariancesATexture) {
          this._readyToDisplay = false;
        }
        const uBuffer = new Uint8Array(data);
        const fBuffer = new Float32Array(uBuffer.buffer);
        if (this._keepInRam) {
          this._splatsData = data;
          this._shData = sh ? sh.map((arr) => new Uint8Array(arr)) : null;
        }
        const vertexCount = uBuffer.length / _GaussianSplattingMesh._RowOutputLength;
        if (vertexCount != this._vertexCount) {
          this._updateSplatIndexBuffer(vertexCount);
        }
        this._vertexCount = vertexCount;
        this._shDegree = sh ? sh.length : 0;
        const textureSize = this._getTextureSize(vertexCount);
        const textureLength = textureSize.x * textureSize.y;
        const lineCountUpdate = _GaussianSplattingMesh.ProgressiveUpdateAmount ?? textureSize.y;
        const textureLengthPerUpdate = textureSize.x * lineCountUpdate;
        this._splatPositions = new Float32Array(4 * textureLength);
        const covA = new Uint16Array(textureLength * 4);
        const covB = new Uint16Array((this._useRGBACovariants ? 4 : 2) * textureLength);
        const colorArray = new Uint8Array(textureLength * 4);
        if (partIndices) {
          this._partIndices = new Uint8Array(textureLength);
          this._partIndices.set(partIndices);
          let maxPartIndex = -1;
          for (let i = 0; i < partIndices.length; i++) {
            maxPartIndex = Math.max(maxPartIndex, partIndices[i]);
          }
          this._ensureMinimumPartMatricesLength(maxPartIndex + 1);
        }
        const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        if (_GaussianSplattingMesh.ProgressiveUpdateAmount) {
          this._updateTextures(covA, covB, colorArray, sh, this._partIndices ? this._partIndices : void 0);
          this.setEnabled(true);
          const partCount = Math.ceil(textureSize.y / lineCountUpdate);
          for (let partIndex = 0; partIndex < partCount; partIndex++) {
            const updateLine = partIndex * lineCountUpdate;
            const splatIndexBase = updateLine * textureSize.x;
            for (let i = 0; i < textureLengthPerUpdate; i++) {
              this._makeSplat(splatIndexBase + i, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum, options);
            }
            this._updateSubTextures(this._splatPositions, covA, covB, colorArray, updateLine, Math.min(lineCountUpdate, textureSize.y - updateLine));
            this.getBoundingInfo().reConstruct(minimum, maximum, this.getWorldMatrix());
            if (isAsync) {
              yield;
            }
          }
          const positions = Float32Array.from(this._splatPositions);
          const vertexCount2 = this._vertexCount;
          if (this._worker) {
            this._worker.postMessage({ positions, vertexCount: vertexCount2 }, [positions.buffer]);
            this._worker.postMessage({ partIndices });
          }
          this._sortIsDirty = true;
        } else {
          const paddedVertexCount = vertexCount + 15 & ~15;
          for (let i = 0; i < vertexCount; i++) {
            this._makeSplat(i, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum, options);
            if (isAsync && i % _GaussianSplattingMesh._SplatBatchSize === 0) {
              yield;
            }
          }
          for (let i = vertexCount; i < paddedVertexCount; i++) {
            this._makeEmptySplat(i, covA, covB, colorArray);
          }
          this._updateTextures(covA, covB, colorArray, sh, this._partIndices ? this._partIndices : void 0);
          this.getBoundingInfo().reConstruct(minimum, maximum, this.getWorldMatrix());
          this.setEnabled(true);
          this._sortIsDirty = true;
        }
        this._postToWorker(true);
      }
      /**
       * Update asynchronously the buffer
       * @param data array buffer containing center, color, orientation and scale of splats
       * @param sh optional array of uint8 array for SH data
       * @param partIndices optional array of uint8 for rig node indices
       * @returns a promise
       */
      async updateDataAsync(data, sh, partIndices) {
        return await runCoroutineAsync(this._updateData(data, true, sh, partIndices), createYieldingScheduler());
      }
      /**
       * @experimental
       * Update data from GS (position, orientation, color, scaling)
       * @param data array that contain all the datas
       * @param sh optional array of uint8 array for SH data
       * @param options optional informations on how to treat data (needs to be 3rd for backward compatibility)
       * @param partIndices optional array of uint8 for rig node indices
       */
      updateData(data, sh, options = { flipY: true }, partIndices) {
        runCoroutineSync(this._updateData(data, false, sh, partIndices, options));
      }
      /**
       * Refreshes the bounding info, taking into account all the thin instances defined
       * @returns the current Gaussian Splatting
       */
      refreshBoundingInfo() {
        this.thinInstanceRefreshBoundingInfo(false);
        return this;
      }
      // in case size is different
      _updateSplatIndexBuffer(vertexCount) {
        const paddedVertexCount = vertexCount + 15 & ~15;
        if (!this._splatIndex || vertexCount > this._splatIndex.length) {
          this._splatIndex = new Float32Array(paddedVertexCount);
          for (let i = 0; i < paddedVertexCount; i++) {
            this._splatIndex[i] = i;
          }
          this._cameraViewInfos.forEach((cameraViewInfos) => {
            cameraViewInfos.mesh.thinInstanceSetBuffer("splatIndex", this._splatIndex, 16, false);
          });
        }
        if ((!this._depthMix || vertexCount > this._depthMix.length) && !IsNative) {
          this._depthMix = new BigInt64Array(paddedVertexCount);
        }
        this.forcedInstanceCount = paddedVertexCount >> 4;
      }
      _updateSubTextures(centers, covA, covB, colors, lineStart, lineCount, sh, partIndices) {
        const updateTextureFromData = (texture, data, width, lineStart2, lineCount2) => {
          this.getEngine().updateTextureData(texture.getInternalTexture(), data, 0, lineStart2, width, lineCount2, 0, 0, false);
        };
        const textureSize = this._getTextureSize(this._vertexCount);
        const covBSItemSize = this._useRGBACovariants ? 4 : 2;
        const texelStart = lineStart * textureSize.x;
        const texelCount = lineCount * textureSize.x;
        const covAView = new Uint16Array(covA.buffer, texelStart * 4 * Uint16Array.BYTES_PER_ELEMENT, texelCount * 4);
        const covBView = new Uint16Array(covB.buffer, texelStart * covBSItemSize * Uint16Array.BYTES_PER_ELEMENT, texelCount * covBSItemSize);
        const colorsView = new Uint8Array(colors.buffer, texelStart * 4, texelCount * 4);
        const centersView = new Float32Array(centers.buffer, texelStart * 4 * Float32Array.BYTES_PER_ELEMENT, texelCount * 4);
        updateTextureFromData(this._covariancesATexture, covAView, textureSize.x, lineStart, lineCount);
        updateTextureFromData(this._covariancesBTexture, covBView, textureSize.x, lineStart, lineCount);
        updateTextureFromData(this._centersTexture, centersView, textureSize.x, lineStart, lineCount);
        updateTextureFromData(this._colorsTexture, colorsView, textureSize.x, lineStart, lineCount);
        if (sh) {
          for (let i = 0; i < sh.length; i++) {
            const componentCount = 4;
            const shView = new Uint32Array(sh[i].buffer, texelStart * componentCount * 4, texelCount * componentCount);
            updateTextureFromData(this._shTextures[i], shView, textureSize.x, lineStart, lineCount);
          }
        }
        if (partIndices && this._partIndicesTexture) {
          const partIndicesView = new Uint8Array(partIndices.buffer, texelStart, texelCount);
          updateTextureFromData(this._partIndicesTexture, partIndicesView, textureSize.x, lineStart, lineCount);
        }
      }
      _instanciateWorker() {
        if (!this._vertexCount) {
          return;
        }
        if (this._disableDepthSort) {
          return;
        }
        this._updateSplatIndexBuffer(this._vertexCount);
        if (IsNative) {
          return;
        }
        this._worker?.terminate();
        this._worker = new Worker(URL.createObjectURL(new Blob(["(", _GaussianSplattingMesh._CreateWorker.toString(), ")(self)"], {
          type: "application/javascript"
        })));
        const positions = Float32Array.from(this._splatPositions);
        const partIndices = this._partIndices ? new Uint8Array(this._partIndices) : null;
        const partMatrices = this._partMatrices.map((matrix) => new Float32Array(matrix.m));
        this._worker.postMessage({ positions }, [positions.buffer]);
        this._worker.postMessage({ partIndices });
        this._worker.postMessage({ partMatrices });
        this._worker.onmessage = (e) => {
          const vertexCountPadded = this._vertexCount + 15 & ~15;
          if (e.data.depthMix.length != vertexCountPadded) {
            this._canPostToWorker = true;
            this._postToWorker(true);
            this._sortIsDirty = false;
            return;
          }
          this._depthMix = e.data.depthMix;
          const cameraId = e.data.cameraId;
          const indexMix = new Uint32Array(e.data.depthMix.buffer);
          if (this._splatIndex) {
            for (let j = 0; j < vertexCountPadded; j++) {
              this._splatIndex[j] = indexMix[2 * j];
            }
          }
          if (this._delayedTextureUpdate) {
            const textureSize = this._getTextureSize(vertexCountPadded);
            this._updateSubTextures(this._delayedTextureUpdate.centers, this._delayedTextureUpdate.covA, this._delayedTextureUpdate.covB, this._delayedTextureUpdate.colors, 0, textureSize.y, this._delayedTextureUpdate.sh, this._delayedTextureUpdate.partIndices);
            this._delayedTextureUpdate = null;
          }
          const cameraViewInfos = this._cameraViewInfos.get(cameraId);
          if (cameraViewInfos) {
            if (cameraViewInfos.splatIndexBufferSet) {
              cameraViewInfos.mesh.thinInstanceBufferUpdated("splatIndex");
            } else {
              cameraViewInfos.mesh.thinInstanceSetBuffer("splatIndex", this._splatIndex, 16, false);
              cameraViewInfos.splatIndexBufferSet = true;
            }
          }
          this._canPostToWorker = true;
          this._readyToDisplay = true;
          if (this._sortIsDirty) {
            this._postToWorker(true);
            this._sortIsDirty = false;
          }
        };
      }
      _getTextureSize(length) {
        const engine = this._scene.getEngine();
        const width = engine.getCaps().maxTextureSize;
        let height = 1;
        if (engine.version === 1 && !engine.isWebGPU) {
          while (width * height < length) {
            height *= 2;
          }
        } else {
          height = Math.ceil(length / width);
        }
        if (height > width) {
          Logger.Error("GaussianSplatting texture size: (" + width + ", " + height + "), maxTextureSize: " + width);
          height = width;
        }
        return new Vector2(width, height);
      }
      /**
       * Gets the number of parts in the compound
       * @returns the number of parts in the compound, or 0 if the mesh is not a compound
       */
      get partCount() {
        return this._partMatrices.length;
      }
      /**
       * Sets the world matrix for a specific part of the compound (if this mesh is a compound).
       * This will trigger a re-sort of the mesh.
       * @param partIndex index of the part, that must be between 0 and partCount - 1
       * @param worldMatrix the world matrix to set
       */
      setWorldMatrixForPart(partIndex, worldMatrix) {
        this._partMatrices[partIndex].copyFrom(worldMatrix);
        if (this._worker) {
          this._worker.postMessage({ partMatrices: this._partMatrices.map((matrix) => new Float32Array(matrix.m)) });
        }
        this._postToWorker(true);
      }
      /**
       * Gets the world matrix for a specific part of the compound (if this mesh is a compound).
       * @param partIndex index of the part, that must be between 0 and partCount - 1
       * @returns the world matrix for the part, or the current world matrix of the mesh if the mesh is not a compound
       */
      getWorldMatrixForPart(partIndex) {
        return this._partMatrices[partIndex] ?? this.getWorldMatrix();
      }
      /**
       * Ensure that the part world matrix array is at least the given length.
       * NB: This length is used as reference for the number of parts in the compound.
       * Newly inserted parts are initialized with the current world matrix of the mesh.
       * @param length - The minimum length to ensure
       */
      _ensureMinimumPartMatricesLength(length) {
        if (this._partMatrices.length < length) {
          this._resizePartMatrices(length);
        }
      }
      /**
       * This sets the number of parts in the compound.
       * Warning: This must be consistent with the indices used in the partIndices texture.
       * Newly inserted parts are initialized with the current world matrix of the mesh.
       * @param length - The length to resize to
       */
      _resizePartMatrices(length) {
        if (this._partMatrices.length == length) {
          return;
        } else if (this._partMatrices.length > length) {
          this._partMatrices = this._partMatrices.slice(0, length);
          this._partVisibility = this._partVisibility.slice(0, length);
        } else {
          this.computeWorldMatrix(true);
          const defaultMatrix = this.getWorldMatrix();
          while (this._partMatrices.length < length) {
            this._partMatrices.push(defaultMatrix.clone());
            this._partVisibility.push(1);
          }
        }
        if (this._worker) {
          this._worker.postMessage({ partMatrices: this._partMatrices.map((matrix) => new Float32Array(matrix.m)) });
        }
        this._postToWorker(true);
      }
      /**
       * Add another mesh to this mesh, as a new part. This makes the current mesh a compound, if not already.
       * NB: The current mesh needs to be loaded with keepInRam: true.
       * @param other - The other mesh to add. This must be loaded with keepInRam: true.
       * @param disposeOther - Whether to dispose the other mesh after adding it to the current mesh.
       * @returns a placeholder mesh that can be used to manipulate the part transform
       */
      addPart(other, disposeOther = true) {
        const splatCountA = this._vertexCount;
        const splatsDataA = splatCountA == 0 ? new ArrayBuffer(0) : this.splatsData;
        const shDataA = this.shData;
        const splatCountB = other._vertexCount;
        const splatsDataB = other.splatsData;
        const shDataB = other.shData;
        const mergedShDataLength = Math.max(shDataA?.length || 0, shDataB?.length || 0);
        const hasMergedShData = shDataA !== null && shDataB !== null;
        if (!splatsDataA) {
          throw new Error(`To call addPart(), the current mesh must be loaded with keepInRam: true`);
        }
        const expectedSplatsDataSizeA = splatCountA * _GaussianSplattingMesh._RowOutputLength;
        if (splatsDataA.byteLength !== expectedSplatsDataSizeA) {
          throw new Error(`splatsDataA size (${splatsDataA.byteLength}) does not match expected size (${expectedSplatsDataSizeA})`);
        }
        if (!splatsDataB) {
          throw new Error(`To call addPart(), the other mesh must be loaded with keepInRam: true`);
        }
        const expectedSplatsDataSizeB = splatCountB * _GaussianSplattingMesh._RowOutputLength;
        if (splatsDataB.byteLength !== expectedSplatsDataSizeB) {
          throw new Error(`splatsDataB size (${splatsDataB.byteLength}) does not match expected size (${expectedSplatsDataSizeB})`);
        }
        if (other.partIndices) {
          throw new Error(`To call addPart(), the other mesh must not be a compound`);
        }
        const mergedSplatsData = new Uint8Array(splatsDataA.byteLength + splatsDataB.byteLength);
        mergedSplatsData.set(new Uint8Array(splatsDataA), 0);
        mergedSplatsData.set(new Uint8Array(splatsDataB), splatsDataA.byteLength);
        let mergedShData = void 0;
        if (hasMergedShData) {
          const bytesPerTexel = 16;
          const totalSplatCount = splatCountA + splatCountB;
          mergedShData = [];
          for (let i = 0; i < mergedShDataLength; i++) {
            const mergedShDataItem = new Uint8Array(totalSplatCount * bytesPerTexel);
            if (i < (shDataA?.length ?? 0)) {
              mergedShDataItem.set(shDataA[i], 0);
            }
            if (i < (shDataB?.length ?? 0)) {
              const byteOffset = bytesPerTexel * splatCountA;
              mergedShDataItem.set(shDataB[i], byteOffset);
            }
            mergedShData.push(mergedShDataItem);
          }
        }
        let newPartIndex = this.partCount;
        let partIndicesA = this.partIndices;
        if (!partIndicesA) {
          partIndicesA = new Uint8Array(splatCountA);
          newPartIndex = splatCountA > 0 ? 1 : 0;
        }
        if (partIndicesA.length < splatCountA) {
          throw new Error(`partIndices length (${partIndicesA.length}) should be at least vertexCount (${splatCountA}) in the current mesh`);
        }
        const partIndicesB = new Uint8Array(splatCountB).fill(newPartIndex);
        const mergedPartIndices = new Uint8Array(splatCountA + splatCountB);
        mergedPartIndices.set(partIndicesA.slice(0, splatCountA), 0);
        mergedPartIndices.set(partIndicesB, splatCountA);
        this.updateData(mergedSplatsData.buffer, mergedShData, { flipY: false }, mergedPartIndices);
        const partWorldMatrix = other.getWorldMatrix();
        this.setWorldMatrixForPart(newPartIndex, partWorldMatrix);
        if (disposeOther) {
          other.dispose();
        }
        const placeholderMesh = new Mesh(other.name, this.getScene());
        placeholderMesh.onAfterWorldMatrixUpdateObservable.add(() => {
          this.setWorldMatrixForPart(newPartIndex, placeholderMesh.getWorldMatrix());
        });
        Object.defineProperty(placeholderMesh, "isVisible", {
          get: () => {
            return (this._partVisibility[newPartIndex] ?? 1) > 0;
          },
          set: (value) => {
            this._partVisibility[newPartIndex] = value ? 1 : 0;
          }
        });
        Object.defineProperty(placeholderMesh, "visibility", {
          get: () => {
            return this._partVisibility[newPartIndex] ?? 1;
          },
          set: (value) => {
            this._partVisibility[newPartIndex] = Math.max(0, Math.min(1, value));
          }
        });
        const quaternion = new Quaternion();
        partWorldMatrix.decompose(placeholderMesh.scaling, quaternion, placeholderMesh.position);
        placeholderMesh.rotationQuaternion = quaternion;
        placeholderMesh.computeWorldMatrix(true);
        placeholderMesh.metadata = { partIndex: newPartIndex };
        return placeholderMesh;
      }
    };
    GaussianSplattingMesh._RowOutputLength = 3 * 4 + 3 * 4 + 4 + 4;
    GaussianSplattingMesh._SH_C0 = 0.28209479177387814;
    GaussianSplattingMesh._SplatBatchSize = 327680;
    GaussianSplattingMesh._PlyConversionBatchSize = 32768;
    GaussianSplattingMesh._BatchSize = 16;
    GaussianSplattingMesh._DefaultViewUpdateThreshold = 1e-4;
    GaussianSplattingMesh.ProgressiveUpdateAmount = 0;
    GaussianSplattingMesh._CreateWorker = function(self) {
      let positions;
      let depthMix;
      let indices;
      let floatMix;
      let partIndices;
      let partMatrices;
      function multiplyMatrices(matrix1, matrix2) {
        const result = new Float32Array(16);
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 4; j++) {
            for (let k = 0; k < 4; k++) {
              result[j * 4 + i] += matrix1[k * 4 + i] * matrix2[j * 4 + k];
            }
          }
        }
        return result;
      }
      self.onmessage = (e) => {
        if (e.data.positions) {
          positions = e.data.positions;
        } else if (e.data.partMatrices) {
          partMatrices = e.data.partMatrices;
        } else if (e.data.partIndices !== void 0) {
          partIndices = e.data.partIndices;
        } else {
          const cameraId = e.data.cameraId;
          const globalModelViewProjection = e.data.modelViewProjection;
          const viewProjection = e.data.viewProjection;
          const vertexCountPadded = positions.length / 4 + 15 & ~15;
          if (!positions || !globalModelViewProjection) {
            throw new Error("positions or modelViewProjection matrix is not defined!");
          }
          depthMix = e.data.depthMix;
          indices = new Uint32Array(depthMix.buffer);
          floatMix = new Float32Array(depthMix.buffer);
          for (let j = 0; j < vertexCountPadded; j++) {
            indices[2 * j] = j;
          }
          let depthFactor = -1;
          if (e.data.useRightHandedSystem) {
            depthFactor = 1;
          }
          if (partMatrices && partIndices) {
            const modelViewProjs = partMatrices.map((model) => multiplyMatrices(viewProjection, model));
            const length = partIndices.length;
            for (let j = 0; j < vertexCountPadded; j++) {
              const partIndex = partIndices[Math.min(j, length - 1)];
              const mvp = modelViewProjs[partIndex];
              floatMix[2 * j + 1] = 1e4 + (mvp[2] * positions[4 * j + 0] + mvp[6] * positions[4 * j + 1] + mvp[10] * positions[4 * j + 2] + mvp[14]) * depthFactor;
            }
          } else {
            const mvp = globalModelViewProjection;
            for (let j = 0; j < vertexCountPadded; j++) {
              floatMix[2 * j + 1] = 1e4 + (mvp[2] * positions[4 * j + 0] + mvp[6] * positions[4 * j + 1] + mvp[10] * positions[4 * j + 2] + mvp[14]) * depthFactor;
            }
          }
          depthMix.sort();
          self.postMessage({ depthMix, cameraId }, [depthMix.buffer]);
        }
      };
    };
  }
});

// node_modules/@babylonjs/core/Misc/deferred.js
var Deferred;
var init_deferred = __esm({
  "node_modules/@babylonjs/core/Misc/deferred.js"() {
    Deferred = class {
      /**
       * The resolve method of the promise associated with this deferred object.
       */
      get resolve() {
        return this._resolve;
      }
      /**
       * The reject method of the promise associated with this deferred object.
       */
      get reject() {
        return this._reject;
      }
      /**
       * Constructor for this deferred object.
       */
      constructor() {
        this.promise = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/filesInput.js
var FilesInput;
var init_filesInput = __esm({
  "node_modules/@babylonjs/core/Misc/filesInput.js"() {
    init_sceneLoader();
    init_logger();
    init_filesInputStore();
    init_sceneLoaderFlags();
    FilesInput = class _FilesInput {
      /**
       * List of files ready to be loaded
       */
      static get FilesToLoad() {
        return FilesInputStore.FilesToLoad;
      }
      /**
       * Creates a new FilesInput
       * @param engine defines the rendering engine
       * @param scene defines the hosting scene
       * @param sceneLoadedCallback callback called when scene (files provided) is loaded
       * @param progressCallback callback called to track progress
       * @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop
       * @param textureLoadingCallback callback called when a texture is loading
       * @param startingProcessingFilesCallback callback called when the system is about to process all files
       * @param onReloadCallback callback called when a reload is requested
       * @param errorCallback callback call if an error occurs
       * @param useAppend defines if the file loaded must be appended (true) or have the scene replaced (false, default behavior)
       * @param dontInjectRenderLoop defines if the render loop mustn't be injected into engine (default is false). Used only if useAppend is false.
       */
      constructor(engine, scene, sceneLoadedCallback, progressCallback, additionalRenderLoopLogicCallback, textureLoadingCallback, startingProcessingFilesCallback, onReloadCallback, errorCallback, useAppend = false, dontInjectRenderLoop = false) {
        this.useAppend = useAppend;
        this.dontInjectRenderLoop = dontInjectRenderLoop;
        this.onProcessFileCallback = () => {
          return true;
        };
        this.displayLoadingUI = true;
        this.loadAsync = async (sceneFile, onProgress) => this.useAppend ? await SceneLoader.AppendAsync("file:", sceneFile, this._currentScene, onProgress) : await SceneLoader.LoadAsync("file:", sceneFile, this._engine, onProgress);
        this._engine = engine;
        this._currentScene = scene;
        this._sceneLoadedCallback = sceneLoadedCallback;
        this._progressCallback = progressCallback;
        this._additionalRenderLoopLogicCallback = additionalRenderLoopLogicCallback;
        this._textureLoadingCallback = textureLoadingCallback;
        this._startingProcessingFilesCallback = startingProcessingFilesCallback;
        this._onReloadCallback = onReloadCallback;
        this._errorCallback = errorCallback;
      }
      /**
       * Calls this function to listen to drag'n'drop events on a specific DOM element
       * @param elementToMonitor defines the DOM element to track
       */
      // should probably be DragAndDrop
      // eslint-disable-next-line @typescript-eslint/naming-convention
      monitorElementForDragNDrop(elementToMonitor) {
        if (elementToMonitor) {
          this._elementToMonitor = elementToMonitor;
          this._dragEnterHandler = (e) => {
            this._drag(e);
          };
          this._dragOverHandler = (e) => {
            this._drag(e);
          };
          this._dropHandler = (e) => {
            this._drop(e);
          };
          this._elementToMonitor.addEventListener("dragenter", this._dragEnterHandler, false);
          this._elementToMonitor.addEventListener("dragover", this._dragOverHandler, false);
          this._elementToMonitor.addEventListener("drop", this._dropHandler, false);
        }
      }
      /** Gets the current list of files to load */
      get filesToLoad() {
        return this._filesToLoad;
      }
      /**
       * Release all associated resources
       */
      dispose() {
        if (!this._elementToMonitor) {
          return;
        }
        this._elementToMonitor.removeEventListener("dragenter", this._dragEnterHandler);
        this._elementToMonitor.removeEventListener("dragover", this._dragOverHandler);
        this._elementToMonitor.removeEventListener("drop", this._dropHandler);
      }
      _renderFunction() {
        if (this._additionalRenderLoopLogicCallback) {
          this._additionalRenderLoopLogicCallback();
        }
        if (this._currentScene) {
          if (this._textureLoadingCallback) {
            const remaining = this._currentScene.getWaitingItemsCount();
            if (remaining > 0) {
              this._textureLoadingCallback(remaining);
            }
          }
          this._currentScene.render();
        }
      }
      _drag(e) {
        e.stopPropagation();
        e.preventDefault();
      }
      _drop(eventDrop) {
        eventDrop.stopPropagation();
        eventDrop.preventDefault();
        this.loadFiles(eventDrop);
      }
      _traverseFolder(folder, files, remaining, callback) {
        const reader = folder.createReader();
        const relativePath = folder.fullPath.replace(/^\//, "").replace(/(.+?)\/?$/, "$1/");
        reader.readEntries((entries) => {
          remaining.count += entries.length;
          for (const entry of entries) {
            if (entry.isFile) {
              entry.file((file) => {
                file.correctName = relativePath + file.name;
                files.push(file);
                if (--remaining.count === 0) {
                  callback();
                }
              });
            } else if (entry.isDirectory) {
              this._traverseFolder(entry, files, remaining, callback);
            }
          }
          if (--remaining.count === 0) {
            callback();
          }
        });
      }
      _processFiles(files) {
        for (let i = 0; i < files.length; i++) {
          const name13 = files[i].correctName.toLowerCase();
          const extension = name13.split(".").pop();
          if (!this.onProcessFileCallback(files[i], name13, extension, (sceneFile) => this._sceneFileToLoad = sceneFile)) {
            continue;
          }
          if (SceneLoader.IsPluginForExtensionAvailable("." + extension)) {
            this._sceneFileToLoad = files[i];
          }
          _FilesInput.FilesToLoad[name13] = files[i];
        }
      }
      /**
       * Load files from a drop event
       * @param event defines the drop event to use as source
       */
      loadFiles(event) {
        if (event && event.dataTransfer && event.dataTransfer.files) {
          this._filesToLoad = event.dataTransfer.files;
        }
        if (event && event.target && event.target.files) {
          this._filesToLoad = event.target.files;
        }
        if (!this._filesToLoad || this._filesToLoad.length === 0) {
          return;
        }
        if (this._startingProcessingFilesCallback) {
          this._startingProcessingFilesCallback(this._filesToLoad);
        }
        if (this._filesToLoad && this._filesToLoad.length > 0) {
          const files = [];
          const folders = [];
          const items = event.dataTransfer ? event.dataTransfer.items : null;
          for (let i = 0; i < this._filesToLoad.length; i++) {
            const fileToLoad = this._filesToLoad[i];
            const name13 = fileToLoad.name.toLowerCase();
            let entry;
            fileToLoad.correctName = name13;
            if (items) {
              const item = items[i];
              if (item.getAsEntry) {
                entry = item.getAsEntry();
              } else if (item.webkitGetAsEntry) {
                entry = item.webkitGetAsEntry();
              }
            }
            if (!entry) {
              files.push(fileToLoad);
            } else {
              if (entry.isDirectory) {
                folders.push(entry);
              } else {
                files.push(fileToLoad);
              }
            }
          }
          if (folders.length === 0) {
            this._processFiles(files);
            this._processReload();
          } else {
            const remaining = { count: folders.length };
            for (const folder of folders) {
              this._traverseFolder(folder, files, remaining, () => {
                this._processFiles(files);
                if (remaining.count === 0) {
                  this._processReload();
                }
              });
            }
          }
        }
      }
      _processReload() {
        if (this._onReloadCallback) {
          this._onReloadCallback(this._sceneFileToLoad);
        } else {
          this.reload();
        }
      }
      /**
       * Reload the current scene from the loaded files
       */
      reload() {
        if (this._sceneFileToLoad) {
          if (!this.useAppend) {
            if (this._currentScene) {
              if (Logger.errorsCount > 0) {
                Logger.ClearLogCache();
              }
              this._engine.stopRenderLoop();
            }
          }
          SceneLoaderFlags.ShowLoadingScreen = false;
          if (this.displayLoadingUI) {
            this._engine.displayLoadingUI();
          }
          this.loadAsync(this._sceneFileToLoad, this._progressCallback).then((scene) => {
            if (!this.useAppend) {
              if (this._currentScene) {
                this._currentScene.dispose();
              }
              this._currentScene = scene;
              this._currentScene.executeWhenReady(() => {
                if (this.displayLoadingUI) {
                  this._engine.hideLoadingUI();
                }
                if (!this.dontInjectRenderLoop) {
                  this._engine.runRenderLoop(() => {
                    this._renderFunction();
                  });
                }
              });
            } else {
              if (this.displayLoadingUI) {
                this._engine.hideLoadingUI();
              }
            }
            if (this._sceneLoadedCallback && this._currentScene) {
              this._sceneLoadedCallback(this._sceneFileToLoad, this._currentScene);
            }
          }).catch((error) => {
            if (this.displayLoadingUI) {
              this._engine.hideLoadingUI();
            }
            if (this._errorCallback) {
              this._errorCallback(this._sceneFileToLoad, this._currentScene, error.message);
            }
          });
        } else {
          if (this._filesToLoad.length === 1) {
            const name13 = this._filesToLoad[0].name.toLowerCase();
            const extension = name13.split(".").pop();
            if (extension) {
              switch (extension.toLowerCase()) {
                case "dds":
                case "env":
                case "hdr": {
                  return;
                }
              }
            }
          }
          Logger.Error("Please provide a valid .babylon file.");
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/sceneSerializer.js
var SerializedGeometries, SerializeGeometry, SerializeMesh, FinalizeSingleNode, SceneSerializer;
var init_sceneSerializer = __esm({
  "node_modules/@babylonjs/core/Misc/sceneSerializer.js"() {
    init_mesh();
    init_multiMaterial();
    init_decorators_serialization();
    init_texture();
    init_logger();
    SerializedGeometries = [];
    SerializeGeometry = (geometry, serializationGeometries) => {
      if (geometry.doNotSerialize) {
        return;
      }
      serializationGeometries.vertexData.push(geometry.serializeVerticeData());
      SerializedGeometries[geometry.id] = true;
    };
    SerializeMesh = (mesh, serializationScene) => {
      const serializationObject = {};
      const geometry = mesh._geometry;
      if (geometry) {
        if (!mesh.getScene().getGeometryById(geometry.id)) {
          SerializeGeometry(geometry, serializationScene.geometries);
        }
      }
      if (mesh.serialize) {
        mesh.serialize(serializationObject);
      }
      return serializationObject;
    };
    FinalizeSingleNode = (node, serializationObject) => {
      if (node._isMesh) {
        const mesh = node;
        if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {
          const serializeMaterial = (material) => {
            serializationObject.materials = serializationObject.materials || [];
            if (mesh.material && !serializationObject.materials.some((mat) => mat.id === mesh.material.id)) {
              serializationObject.materials.push(material.serialize());
            }
          };
          if (mesh.material && !mesh.material.doNotSerialize) {
            if (mesh.material instanceof MultiMaterial) {
              serializationObject.multiMaterials = serializationObject.multiMaterials || [];
              if (!serializationObject.multiMaterials.some((mat) => mat.id === mesh.material.id)) {
                serializationObject.multiMaterials.push(mesh.material.serialize());
                for (const submaterial of mesh.material.subMaterials) {
                  if (submaterial) {
                    serializeMaterial(submaterial);
                  }
                }
              }
            } else {
              serializeMaterial(mesh.material);
            }
          } else if (!mesh.material) {
            serializeMaterial(mesh.getScene().defaultMaterial);
          }
          const geometry = mesh._geometry;
          if (geometry) {
            if (!serializationObject.geometries) {
              serializationObject.geometries = {};
              serializationObject.geometries.boxes = [];
              serializationObject.geometries.spheres = [];
              serializationObject.geometries.cylinders = [];
              serializationObject.geometries.toruses = [];
              serializationObject.geometries.grounds = [];
              serializationObject.geometries.planes = [];
              serializationObject.geometries.torusKnots = [];
              serializationObject.geometries.vertexData = [];
            }
            SerializeGeometry(geometry, serializationObject.geometries);
          }
          if (mesh.skeleton && !mesh.skeleton.doNotSerialize) {
            serializationObject.skeletons = serializationObject.skeletons || [];
            serializationObject.skeletons.push(mesh.skeleton.serialize());
          }
          serializationObject.meshes = serializationObject.meshes || [];
          serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));
        }
      } else if (node.getClassName() === "TransformNode") {
        const transformNode = node;
        serializationObject.transformNodes.push(transformNode.serialize());
      } else if (node.getClassName().indexOf("Camera") !== -1) {
        const camera = node;
        serializationObject.cameras.push(camera.serialize());
      } else if (node.getClassName().indexOf("Light") !== -1) {
        const light = node;
        serializationObject.lights.push(light.serialize());
      }
    };
    SceneSerializer = class _SceneSerializer {
      /**
       * Clear cache used by a previous serialization
       */
      static ClearCache() {
        SerializedGeometries = [];
      }
      /**
       * Serialize a scene into a JSON compatible object
       * Note that if the current engine does not support synchronous texture reading (like WebGPU), you should use SerializeAsync instead
       * as else you may not retrieve the proper base64 encoded texture data (when using the Texture.ForceSerializeBuffers flag)
       * @param scene defines the scene to serialize
       * @returns a JSON compatible object
       */
      static Serialize(scene) {
        return _SceneSerializer._Serialize(scene);
      }
      static _Serialize(scene, checkSyncReadSupported = true) {
        const serializationObject = {};
        if (checkSyncReadSupported && !scene.getEngine()._features.supportSyncTextureRead && Texture.ForceSerializeBuffers) {
          Logger.Warn("The serialization object may not contain the proper base64 encoded texture data! You should use the SerializeAsync method instead.");
        }
        _SceneSerializer.ClearCache();
        serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;
        serializationObject.autoClear = scene.autoClear;
        serializationObject.clearColor = scene.clearColor.asArray();
        serializationObject.ambientColor = scene.ambientColor.asArray();
        serializationObject.gravity = scene.gravity.asArray();
        serializationObject.collisionsEnabled = scene.collisionsEnabled;
        serializationObject.useRightHandedSystem = scene.useRightHandedSystem;
        if (scene.fogMode !== void 0 && scene.fogMode !== null) {
          serializationObject.fogMode = scene.fogMode;
        }
        if (scene.fogColor !== void 0 && scene.fogColor !== null) {
          serializationObject.fogColor = scene.fogColor.asArray();
        }
        if (scene.fogStart !== void 0 && scene.fogStart !== null) {
          serializationObject.fogStart = scene.fogStart;
        }
        if (scene.fogEnd !== void 0 && scene.fogEnd !== null) {
          serializationObject.fogEnd = scene.fogEnd;
        }
        if (scene.fogDensity !== void 0 && scene.fogDensity !== null) {
          serializationObject.fogDensity = scene.fogDensity;
        }
        if (scene.isPhysicsEnabled && scene.isPhysicsEnabled()) {
          const physicEngine = scene.getPhysicsEngine();
          if (physicEngine) {
            serializationObject.physicsEnabled = true;
            serializationObject.physicsGravity = physicEngine.gravity.asArray();
            serializationObject.physicsEngine = physicEngine.getPhysicsPluginName();
          }
        }
        if (scene.metadata) {
          serializationObject.metadata = scene.metadata;
        }
        serializationObject.morphTargetManagers = [];
        for (const abstractMesh of scene.meshes) {
          const manager = abstractMesh.morphTargetManager;
          if (manager) {
            serializationObject.morphTargetManagers.push(manager.serialize());
          }
        }
        serializationObject.lights = [];
        let index;
        let light;
        for (index = 0; index < scene.lights.length; index++) {
          light = scene.lights[index];
          if (!light.doNotSerialize) {
            serializationObject.lights.push(light.serialize());
          }
        }
        serializationObject.cameras = [];
        for (index = 0; index < scene.cameras.length; index++) {
          const camera = scene.cameras[index];
          if (!camera.doNotSerialize) {
            serializationObject.cameras.push(camera.serialize());
          }
        }
        if (scene.activeCamera) {
          serializationObject.activeCameraID = scene.activeCamera.id;
        }
        SerializationHelper.AppendSerializedAnimations(scene, serializationObject);
        if (scene.animationGroups && scene.animationGroups.length > 0) {
          serializationObject.animationGroups = [];
          for (let animationGroupIndex = 0; animationGroupIndex < scene.animationGroups.length; animationGroupIndex++) {
            const animationGroup = scene.animationGroups[animationGroupIndex];
            serializationObject.animationGroups.push(animationGroup.serialize());
          }
        }
        if (scene.reflectionProbes && scene.reflectionProbes.length > 0) {
          serializationObject.reflectionProbes = [];
          for (index = 0; index < scene.reflectionProbes.length; index++) {
            const reflectionProbe = scene.reflectionProbes[index];
            serializationObject.reflectionProbes.push(reflectionProbe.serialize());
          }
        }
        serializationObject.materials = [];
        serializationObject.multiMaterials = [];
        let material;
        for (index = 0; index < scene.materials.length; index++) {
          material = scene.materials[index];
          if (!material.doNotSerialize) {
            serializationObject.materials.push(material.serialize());
          }
        }
        serializationObject.multiMaterials = [];
        for (index = 0; index < scene.multiMaterials.length; index++) {
          const multiMaterial = scene.multiMaterials[index];
          serializationObject.multiMaterials.push(multiMaterial.serialize());
        }
        if (scene.environmentTexture) {
          if (scene.environmentTexture._files) {
            serializationObject.environmentTexture = scene.environmentTexture.serialize();
          } else {
            serializationObject.environmentTexture = scene.environmentTexture.name;
            serializationObject.environmentTextureRotationY = scene.environmentTexture.rotationY;
          }
        }
        serializationObject.environmentIntensity = scene.environmentIntensity;
        serializationObject.iblIntensity = scene.iblIntensity;
        serializationObject.skeletons = [];
        for (index = 0; index < scene.skeletons.length; index++) {
          const skeleton = scene.skeletons[index];
          if (!skeleton.doNotSerialize) {
            serializationObject.skeletons.push(skeleton.serialize());
          }
        }
        serializationObject.transformNodes = [];
        for (index = 0; index < scene.transformNodes.length; index++) {
          if (!scene.transformNodes[index].doNotSerialize) {
            serializationObject.transformNodes.push(scene.transformNodes[index].serialize());
          }
        }
        serializationObject.geometries = {};
        serializationObject.geometries.boxes = [];
        serializationObject.geometries.spheres = [];
        serializationObject.geometries.cylinders = [];
        serializationObject.geometries.toruses = [];
        serializationObject.geometries.grounds = [];
        serializationObject.geometries.planes = [];
        serializationObject.geometries.torusKnots = [];
        serializationObject.geometries.vertexData = [];
        SerializedGeometries = [];
        const geometries = scene.getGeometries();
        for (index = 0; index < geometries.length; index++) {
          const geometry = geometries[index];
          if (geometry.isReady()) {
            SerializeGeometry(geometry, serializationObject.geometries);
          }
        }
        serializationObject.meshes = [];
        for (index = 0; index < scene.meshes.length; index++) {
          const abstractMesh = scene.meshes[index];
          if (abstractMesh instanceof Mesh) {
            const mesh = abstractMesh;
            if (!mesh.doNotSerialize) {
              if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {
                serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));
              }
            }
          }
        }
        serializationObject.particleSystems = [];
        for (index = 0; index < scene.particleSystems.length; index++) {
          const particleSystem = scene.particleSystems[index];
          if (!particleSystem.doNotSerialize) {
            serializationObject.particleSystems.push(particleSystem.serialize(false));
          }
        }
        serializationObject.postProcesses = [];
        for (index = 0; index < scene.postProcesses.length; index++) {
          const postProcess = scene.postProcesses[index];
          if (!postProcess.doNotSerialize) {
            serializationObject.postProcesses.push(postProcess.serialize());
          }
        }
        if (scene.actionManager) {
          serializationObject.actions = scene.actionManager.serialize("scene");
        }
        for (const component of scene._serializableComponents) {
          component.serialize(serializationObject);
        }
        if (scene.spriteManagers) {
          serializationObject.spriteManagers = [];
          for (index = 0; index < scene.spriteManagers.length; index++) {
            const spriteManager = scene.spriteManagers[index];
            if (!spriteManager.doNotSerialize) {
              serializationObject.spriteManagers.push(spriteManager.serialize(true));
            }
          }
        }
        return serializationObject;
      }
      /**
       * Serialize a scene into a JSON compatible object
       * @param scene defines the scene to serialize
       * @returns a JSON promise compatible object
       */
      static async SerializeAsync(scene) {
        const serializationObject = _SceneSerializer._Serialize(scene, false);
        const promises = [];
        this._CollectPromises(serializationObject, promises);
        await Promise.all(promises);
        return serializationObject;
      }
      static _CollectPromises(obj, promises) {
        if (Array.isArray(obj)) {
          for (let i = 0; i < obj.length; ++i) {
            const o = obj[i];
            if (o instanceof Promise) {
              promises.push(o.then((res) => obj[i] = res));
            } else if (o instanceof Object || Array.isArray(o)) {
              this._CollectPromises(o, promises);
            }
          }
        } else if (obj instanceof Object) {
          for (const name13 in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, name13)) {
              const o = obj[name13];
              if (o instanceof Promise) {
                promises.push(o.then((res) => obj[name13] = res));
              } else if (o instanceof Object || Array.isArray(o)) {
                this._CollectPromises(o, promises);
              }
            }
          }
        }
      }
      /**
       * Serialize a mesh into a JSON compatible object
       * @param toSerialize defines the mesh to serialize
       * @param withParents defines if parents must be serialized as well
       * @param withChildren defines if children must be serialized as well
       * @returns a JSON compatible object
       */
      static SerializeMesh(toSerialize, withParents = false, withChildren = false) {
        const serializationObject = {};
        serializationObject.meshes = [];
        serializationObject.transformNodes = [];
        serializationObject.cameras = [];
        serializationObject.lights = [];
        _SceneSerializer.ClearCache();
        toSerialize = toSerialize instanceof Array ? toSerialize : [toSerialize];
        if (withParents || withChildren) {
          for (let i = 0; i < toSerialize.length; ++i) {
            if (withChildren) {
              const descendants = toSerialize[i].getDescendants();
              for (const node of descendants) {
                if (toSerialize.indexOf(node) < 0 && !node.doNotSerialize) {
                  toSerialize.push(node);
                }
              }
            }
            if (withParents && toSerialize[i].parent && toSerialize.indexOf(toSerialize[i].parent) < 0 && !toSerialize[i].parent.doNotSerialize) {
              toSerialize.push(toSerialize[i].parent);
            }
          }
        }
        for (const mesh of toSerialize) {
          FinalizeSingleNode(mesh, serializationObject);
        }
        return serializationObject;
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/videoRecorder.js
var VideoRecorder;
var init_videoRecorder = __esm({
  "node_modules/@babylonjs/core/Misc/videoRecorder.js"() {
    init_tools();
    VideoRecorder = class _VideoRecorder {
      /**
       * Returns whether or not the VideoRecorder is available in your browser.
       * @param engine Defines the Babylon Engine.
       * @param canvas Defines the canvas to record. If not provided, the engine canvas will be used.
       * @returns true if supported otherwise false.
       */
      static IsSupported(engine, canvas) {
        const targetCanvas = canvas ?? engine.getRenderingCanvas();
        return !!targetCanvas && typeof targetCanvas.captureStream === "function";
      }
      /**
       * True when a recording is already in progress.
       */
      get isRecording() {
        return !!this._canvas && this._isRecording;
      }
      /**
       * Create a new VideoCapture object which can help converting what you see in Babylon to a video file.
       * @param engine Defines the BabylonJS Engine you wish to record.
       * @param options Defines options that can be used to customize the capture.
       */
      constructor(engine, options = {}) {
        if (!_VideoRecorder.IsSupported(engine, options.canvas)) {
          throw "Your browser does not support recording so far.";
        }
        const canvas = options.canvas ?? engine.getRenderingCanvas();
        if (!canvas) {
          throw "The babylon engine must have a canvas to be recorded";
        }
        this._canvas = canvas;
        this._isRecording = false;
        this._options = {
          ..._VideoRecorder._DefaultOptions,
          ...options
        };
        const stream = this._canvas.captureStream(this._options.fps);
        if (this._options.audioTracks) {
          for (const track of this._options.audioTracks) {
            stream.addTrack(track);
          }
        }
        this._mediaRecorder = new MediaRecorder(stream, { mimeType: this._options.mimeType });
        this._mediaRecorder.ondataavailable = (evt) => this._handleDataAvailable(evt);
        this._mediaRecorder.onerror = (evt) => this._handleError(evt);
        this._mediaRecorder.onstop = () => this._handleStop();
      }
      /**
       * Stops the current recording before the default capture timeout passed in the startRecording function.
       */
      stopRecording() {
        if (!this._canvas || !this._mediaRecorder) {
          return;
        }
        if (!this.isRecording) {
          return;
        }
        this._isRecording = false;
        this._mediaRecorder.stop();
      }
      /**
       * Starts recording the canvas for a max duration specified in parameters.
       * @param fileName Defines the name of the file to be downloaded when the recording stop.
       * If null no automatic download will start and you can rely on the promise to get the data back.
       * @param maxDuration Defines the maximum recording time in seconds.
       * It defaults to 7 seconds. A value of zero will not stop automatically, you would need to call stopRecording manually.
       * @returns A promise callback at the end of the recording with the video data in Blob.
       */
      // eslint-disable-next-line @typescript-eslint/promise-function-async
      startRecording(fileName = "babylonjs.webm", maxDuration = 7) {
        if (!this._canvas || !this._mediaRecorder) {
          throw "Recorder has already been disposed";
        }
        if (this.isRecording) {
          throw "Recording already in progress";
        }
        if (maxDuration > 0) {
          setTimeout(() => {
            this.stopRecording();
          }, maxDuration * 1e3);
        }
        this._fileName = fileName;
        this._recordedChunks = [];
        this._resolve = null;
        this._reject = null;
        this._isRecording = true;
        this._mediaRecorder.start(this._options.recordChunckSize);
        return new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
      }
      /**
       * Releases internal resources used during the recording.
       */
      dispose() {
        this._canvas = null;
        this._mediaRecorder = null;
        this._recordedChunks = [];
        this._fileName = null;
        this._resolve = null;
        this._reject = null;
      }
      _handleDataAvailable(event) {
        if (event.data.size > 0) {
          this._recordedChunks.push(event.data);
        }
      }
      _handleError(event) {
        this.stopRecording();
        if (this._reject) {
          this._reject(event.error);
        } else {
          throw new event.error();
        }
      }
      _handleStop() {
        this.stopRecording();
        const superBuffer = new Blob(this._recordedChunks);
        if (this._resolve) {
          this._resolve(superBuffer);
        }
        window.URL.createObjectURL(superBuffer);
        if (this._fileName) {
          Tools.Download(superBuffer, this._fileName);
        }
      }
    };
    VideoRecorder._DefaultOptions = {
      mimeType: "video/webm",
      fps: 25,
      recordChunckSize: 3e3
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/fxaaPostProcess.js
var FxaaPostProcess;
var init_fxaaPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/fxaaPostProcess.js"() {
    init_texture();
    init_postProcess();
    init_typeStore();
    init_decorators_serialization();
    init_thinFXAAPostProcess();
    FxaaPostProcess = class _FxaaPostProcess extends PostProcess {
      /**
       * Gets a string identifying the name of the class
       * @returns "FxaaPostProcess" string
       */
      getClassName() {
        return "FxaaPostProcess";
      }
      constructor(name13, options, camera = null, samplingMode, engine, reusable, textureType = 0) {
        const localOptions = {
          uniforms: ThinFXAAPostProcess.Uniforms,
          size: typeof options === "number" ? options : void 0,
          camera,
          samplingMode: samplingMode || Texture.BILINEAR_SAMPLINGMODE,
          engine,
          reusable,
          textureType,
          ...options
        };
        super(name13, ThinFXAAPostProcess.FragmentUrl, {
          effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinFXAAPostProcess(name13, engine, localOptions) : void 0,
          ...localOptions
        });
        this.onApplyObservable.add((_effect) => {
          this._effectWrapper.texelSize = this.texelSize;
        });
      }
      /**
       * @internal
       */
      static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
        return SerializationHelper.Parse(() => {
          return new _FxaaPostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
        }, parsedPostProcess, scene, rootUrl);
      }
    };
    RegisterClass("BABYLON.FxaaPostProcess", FxaaPostProcess);
  }
});

// node_modules/@babylonjs/core/Misc/screenshotTools.js
function CreateScreenshot(engine, camera, size, successCallback, mimeType = "image/png", forceDownload = false, quality, useFill = false, clearWithSceneColor = false) {
  const { height, width } = GetScreenshotSize(engine, camera, size);
  if (!(height && width)) {
    Logger.Error("Invalid 'size' parameter !");
    return;
  }
  const scene = camera.getScene();
  let useRenderTarget = scene.activeCamera !== camera;
  if (scene.frameGraph) {
    const mainObjectRendererTask = FrameGraphUtils.FindMainObjectRenderer(scene.frameGraph);
    if (mainObjectRendererTask) {
      useRenderTarget = mainObjectRendererTask.camera !== camera;
    }
  }
  if (useRenderTarget) {
    CreateScreenshotUsingRenderTarget(engine, camera, size, (data) => {
      if (forceDownload) {
        const blob = new Blob([data]);
        Tools.DownloadBlob(blob);
        if (successCallback) {
          successCallback("");
        }
      } else if (successCallback) {
        successCallback(data);
      }
    }, mimeType, 1, engine.getCreationOptions().antialias, void 0, void 0, void 0, void 0, quality);
    return;
  }
  engine.onEndFrameObservable.addOnce(() => {
    if (!screenshotCanvas) {
      screenshotCanvas = document.createElement("canvas");
    }
    screenshotCanvas.width = width;
    screenshotCanvas.height = height;
    const renderContext = screenshotCanvas.getContext("2d");
    const renderingCanvas = engine.getRenderingCanvas();
    if (!renderContext || !renderingCanvas) {
      Logger.Error("Failed to create screenshot. Rendering context or rendering canvas is not available.");
      return;
    }
    const srcWidth = renderingCanvas.width;
    const srcHeight = renderingCanvas.height;
    const destWidth = screenshotCanvas.width;
    const destHeight = screenshotCanvas.height;
    const scaleX = destWidth / srcWidth;
    const scaleY = destHeight / srcHeight;
    const scale = useFill ? Math.max(scaleX, scaleY) : Math.min(scaleX, scaleY);
    const newWidth = srcWidth * scale;
    const newHeight = srcHeight * scale;
    const offsetX = (destWidth - newWidth) / 2;
    const offsetY = (destHeight - newHeight) / 2;
    renderContext.save();
    renderContext.fillStyle = clearWithSceneColor ? scene.clearColor.toHexString() : "rgba(0, 0, 0, 0)";
    renderContext.fillRect(0, 0, width, height);
    renderContext.restore();
    renderContext.drawImage(renderingCanvas, 0, 0, srcWidth, srcHeight, offsetX, offsetY, newWidth, newHeight);
    if (forceDownload) {
      Tools.EncodeScreenshotCanvasData(screenshotCanvas, void 0, mimeType, void 0, quality);
      if (successCallback) {
        successCallback("");
      }
    } else {
      Tools.EncodeScreenshotCanvasData(screenshotCanvas, successCallback, mimeType, void 0, quality);
    }
  });
}
async function CreateScreenshotAsync(engine, camera, size, mimeType = "image/png", quality, useFill = false, clearWithSceneColor = false, forceDownload = false) {
  return await new Promise((resolve, reject) => {
    CreateScreenshot(engine, camera, size, (data) => {
      if (typeof data !== "undefined") {
        resolve(data);
      } else {
        reject(new Error("Data is undefined"));
      }
    }, mimeType, forceDownload, quality, useFill, clearWithSceneColor);
  });
}
async function CreateScreenshotWithResizeAsync(engine, camera, width, height, mimeType = "image/png", quality, useFill = false) {
  return await new Promise((resolve) => {
    CreateScreenshot(engine, camera, { width, height }, () => {
      resolve();
    }, mimeType, true, quality, useFill);
  });
}
function CreateScreenshotUsingRenderTarget(engine, camera, size, successCallback, mimeType = "image/png", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true, quality, customizeTexture, customDumpData, timeoutInMilliseconds = 3e4, timeoutErrorCallback) {
  const scene = camera.getScene();
  if (scene.frameGraph) {
    CreateScreenshotForFrameGraphAsync(scene.frameGraph, camera, size, mimeType, samples, antialiasing, fileName, quality, customDumpData, !successCallback).then((data) => {
      if (successCallback) {
        successCallback(data);
      }
    });
    return;
  }
  const { height, width, finalWidth, finalHeight } = GetScreenshotSize(engine, camera, size);
  const targetTextureSize = { width, height };
  if (!(height && width)) {
    Logger.Error("Invalid 'size' parameter !");
    return;
  }
  engine.skipFrameRender = true;
  const originalGetRenderWidth = engine.getRenderWidth;
  const originalGetRenderHeight = engine.getRenderHeight;
  engine.getRenderWidth = (useScreen = false) => {
    if (!useScreen && engine._currentRenderTarget) {
      return engine._currentRenderTarget.width;
    }
    return width;
  };
  engine.getRenderHeight = (useScreen = false) => {
    if (!useScreen && engine._currentRenderTarget) {
      return engine._currentRenderTarget.height;
    }
    return height;
  };
  if (engine.onResizeObservable.hasObservers()) {
    engine.onResizeObservable.notifyObservers(engine);
  }
  const texture = new RenderTargetTexture("screenShot", targetTextureSize, scene, false, false, 0, false, Texture.BILINEAR_SAMPLINGMODE, void 0, enableStencilBuffer, void 0, void 0, void 0, samples);
  texture.renderList = scene.meshes.slice();
  texture.samples = samples;
  texture.renderSprites = renderSprites;
  texture.activeCamera = camera;
  texture.forceLayerMaskCheck = useLayerMask;
  customizeTexture?.(texture);
  const dumpDataFunc = customDumpData || DumpData;
  const renderWhenReady = () => {
    _RetryWithInterval(() => texture.isReadyForRendering() && camera.isReady(true), () => {
      engine.onEndFrameObservable.addOnce(() => {
        if (finalWidth === width && finalHeight === height) {
          texture.readPixels(void 0, void 0, void 0, false).then((data) => {
            dumpDataFunc(width, height, data, successCallback, mimeType, fileName, true, void 0, quality);
            texture.dispose();
          });
        } else {
          const importPromise = engine.isWebGPU ? import("./pass.fragment-UECRJZSP.js") : import("./pass.fragment-GQ4PNZOK.js");
          importPromise.then(async () => (
            // eslint-disable-next-line github/no-then
            await ApplyPostProcess("pass", texture.getInternalTexture(), scene, void 0, void 0, void 0, finalWidth, finalHeight).then((texture2) => {
              engine._readTexturePixels(texture2, finalWidth, finalHeight, -1, 0, null, true, false, 0, 0).then((data) => {
                dumpDataFunc(finalWidth, finalHeight, data, successCallback, mimeType, fileName, true, void 0, quality);
                texture2.dispose();
              });
            })
          ));
        }
      });
      scene.incrementRenderId();
      scene.resetCachedMaterial();
      const originalCamera = scene.activeCamera;
      const originalCameras = scene.activeCameras;
      const originalOutputRenderTarget = camera.outputRenderTarget;
      const originalSpritesEnabled = scene.spritesEnabled;
      scene.activeCamera = camera;
      scene.activeCameras = null;
      camera.outputRenderTarget = texture;
      scene.spritesEnabled = renderSprites;
      const currentMeshList = scene.meshes;
      scene.meshes = texture.renderList || scene.meshes;
      try {
        scene.render();
      } finally {
        scene.activeCamera = originalCamera;
        scene.activeCameras = originalCameras;
        camera.outputRenderTarget = originalOutputRenderTarget;
        scene.spritesEnabled = originalSpritesEnabled;
        scene.meshes = currentMeshList;
        engine.getRenderWidth = originalGetRenderWidth;
        engine.getRenderHeight = originalGetRenderHeight;
        if (engine.onResizeObservable.hasObservers()) {
          engine.onResizeObservable.notifyObservers(engine);
        }
        camera.getProjectionMatrix(true);
        engine.skipFrameRender = false;
      }
    }, () => {
      engine.skipFrameRender = false;
      engine.getRenderWidth = originalGetRenderWidth;
      engine.getRenderHeight = originalGetRenderHeight;
      timeoutErrorCallback?.();
    }, void 0, timeoutInMilliseconds);
  };
  const renderToTexture = () => {
    scene.incrementRenderId();
    scene.resetCachedMaterial();
    renderWhenReady();
  };
  if (antialiasing) {
    const fxaaPostProcess = new FxaaPostProcess("antialiasing", 1, scene.activeCamera);
    texture.addPostProcess(fxaaPostProcess);
    fxaaPostProcess.autoClear = true;
    fxaaPostProcess.onEffectCreatedObservable.addOnce((e) => {
      if (!e.isReady()) {
        e.onCompiled = () => {
          renderToTexture();
        };
      } else {
        renderToTexture();
      }
    });
  } else {
    renderToTexture();
  }
}
async function CreateScreenshotUsingRenderTargetAsync(engine, camera, size, mimeType = "image/png", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true, quality, customizeTexture, customDumpData) {
  return await new Promise((resolve, reject) => {
    CreateScreenshotUsingRenderTarget(engine, camera, size, (data) => {
      if (typeof data !== "undefined") {
        resolve(data);
      } else {
        reject(new Error("Data is undefined"));
      }
    }, mimeType, samples, antialiasing, fileName, renderSprites, enableStencilBuffer, useLayerMask, quality, customizeTexture, customDumpData);
  });
}
async function CreateScreenshotForFrameGraphAsync(frameGraph, camera, size, mimeType = "image/png", samples = 1, antialiasing = false, fileName, quality, customDumpData, automaticDownload = false, numberOfFramesToRender) {
  const engine = frameGraph.engine;
  const textureManager = frameGraph.textureManager;
  const { height, width, finalWidth, finalHeight } = GetScreenshotSize(engine, camera, size);
  const targetTextureSize = { width, height };
  const dumpDataFunc = customDumpData || DumpData;
  const tasks = frameGraph.tasks;
  const currentTaskListLength = tasks.length;
  const pausedExecution = frameGraph.pausedExecution;
  const currentParallelShaderCompile = engine.getCaps().parallelShaderCompile;
  textureManager.setBackBufferTextures(0, 0, {
    size: targetTextureSize,
    options: {
      createMipMaps: false,
      samples,
      types: [0],
      formats: [5],
      useSRGBBuffers: [false],
      creationFlags: [0],
      labels: ["screenshot color"]
    },
    sizeIsPercentage: false
  }, {
    size: targetTextureSize,
    options: {
      createMipMaps: false,
      samples,
      types: [0],
      formats: [engine.isStencilEnable ? 13 : 14],
      useSRGBBuffers: [false],
      creationFlags: [0],
      labels: ["screenshot depth"]
    },
    sizeIsPercentage: false
  });
  let outputTextureHandle = backbufferColorTextureHandle;
  if (antialiasing) {
    const task = new FrameGraphFXAATask("fxaa", frameGraph);
    task.sourceTexture = outputTextureHandle;
    outputTextureHandle = task.outputTexture;
    frameGraph.addTask(task);
  }
  if (finalWidth !== width || finalHeight !== height) {
    const task = new FrameGraphPassTask("pass", frameGraph);
    task.sourceTexture = outputTextureHandle;
    task.targetTexture = frameGraph.textureManager.createRenderTargetTexture("pass_output", {
      size: { width: finalWidth, height: finalHeight },
      options: {
        createMipMaps: false,
        types: [0],
        formats: [5],
        samples: 1,
        labels: ["screenshot_final_texture"],
        useSRGBBuffers: [false]
      },
      sizeIsPercentage: false
    });
    outputTextureHandle = task.outputTexture;
    frameGraph.addTask(task);
  }
  const mainObjectRendererTask = FrameGraphUtils.FindMainObjectRenderer(frameGraph);
  let currentCamera = null;
  if (mainObjectRendererTask) {
    currentCamera = mainObjectRendererTask.camera;
    mainObjectRendererTask.camera = camera;
  }
  engine.getCaps().parallelShaderCompile = void 0;
  await frameGraph.buildAsync();
  const numberOfFrames = numberOfFramesToRender ?? (textureManager.hasHistoryTextures ? 32 : 1);
  for (let i = 0; i < numberOfFrames; ++i) {
    frameGraph.execute();
  }
  frameGraph.pausedExecution = true;
  engine.getCaps().parallelShaderCompile = currentParallelShaderCompile;
  for (let i = currentTaskListLength; i < tasks.length; ++i) {
    frameGraph.tasks[i].dispose();
  }
  frameGraph.tasks.length = currentTaskListLength;
  if (mainObjectRendererTask && currentCamera) {
    mainObjectRendererTask.camera = currentCamera;
  }
  const texture = frameGraph.textureManager.getTextureFromHandle(outputTextureHandle);
  texture.incrementReferences();
  textureManager.resetBackBufferTextures();
  await frameGraph.buildAsync();
  frameGraph.pausedExecution = pausedExecution;
  return new Promise((resolve) => {
    engine._readTexturePixels(texture, finalWidth, finalHeight, -1, 0, null, true, false, 0, 0).then(async (data) => {
      texture.dispose();
      dumpDataFunc(finalWidth, finalHeight, data, automaticDownload ? void 0 : (data2) => resolve(data2), mimeType, fileName, true, void 0, quality);
      if (automaticDownload) {
        resolve(null);
      }
    });
  });
}
function GetScreenshotSize(engine, camera, size) {
  let height = 0;
  let width = 0;
  let finalWidth = 0;
  let finalHeight = 0;
  if (typeof size === "object") {
    const precision = size.precision ? Math.abs(size.precision) : 1;
    if (size.width && size.height) {
      height = size.height * precision;
      width = size.width * precision;
    } else if (size.width && !size.height) {
      width = size.width * precision;
      height = Math.round(width / engine.getAspectRatio(camera));
    } else if (size.height && !size.width) {
      height = size.height * precision;
      width = Math.round(height * engine.getAspectRatio(camera));
    } else {
      width = Math.round(engine.getRenderWidth() * precision);
      height = Math.round(width / engine.getAspectRatio(camera));
    }
    if (size.finalWidth && size.finalHeight) {
      finalHeight = size.finalHeight;
      finalWidth = size.finalWidth;
    } else if (size.finalWidth && !size.finalHeight) {
      finalWidth = size.finalWidth;
      finalHeight = Math.round(finalWidth / engine.getAspectRatio(camera));
    } else if (size.finalHeight && !size.finalWidth) {
      finalHeight = size.finalHeight;
      finalWidth = Math.round(finalHeight * engine.getAspectRatio(camera));
    } else {
      finalWidth = width;
      finalHeight = height;
    }
  } else if (!isNaN(size)) {
    height = size;
    width = size;
    finalWidth = size;
    finalHeight = size;
  }
  if (width) {
    width = Math.floor(width);
  }
  if (height) {
    height = Math.floor(height);
  }
  if (finalWidth) {
    finalWidth = Math.floor(finalWidth);
  }
  if (finalHeight) {
    finalHeight = Math.floor(finalHeight);
  }
  return { height: height | 0, width: width | 0, finalWidth: finalWidth | 0, finalHeight: finalHeight | 0 };
}
var screenshotCanvas, ScreenshotTools, initSideEffects;
var init_screenshotTools = __esm({
  "node_modules/@babylonjs/core/Misc/screenshotTools.js"() {
    init_texture();
    init_renderTargetTexture();
    init_fxaaPostProcess();
    init_logger();
    init_tools();
    init_dumpTools();
    init_textureTools();
    init_timingTools();
    init_frameGraphTypes();
    init_fxaaTask();
    init_passTask();
    init_frameGraphUtils();
    screenshotCanvas = null;
    ScreenshotTools = {
      /**
       * Captures a screenshot of the current rendering
       * Please note that simultaneous screenshots are not supported: you must wait until one screenshot is complete before taking another.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
       * @param engine defines the rendering engine
       * @param camera defines the source camera. If the camera is not the scene's active camera, {@link CreateScreenshotUsingRenderTarget} will be used instead, and `useFill` will be ignored
       * @param size This parameter can be set to a single number or to an object with the
       * following (optional) properties: precision, width, height. If a single number is passed,
       * it will be used for both width and height. If an object is passed, the screenshot size
       * will be derived from the parameters. The precision property is a multiplier allowing
       * rendering at a higher or lower resolution
       * @param successCallback defines the callback receives a single parameter which contains the
       * screenshot as a string of base64-encoded characters. This string can be assigned to the
       * src parameter of an <img> to display it
       * @param mimeType defines the MIME type of the screenshot image (default: image/png).
       * Check your browser for supported MIME types
       * @param forceDownload force the system to download the image even if a successCallback is provided
       * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
       * @param useFill fill the screenshot dimensions with the render canvas and clip any overflow. If false, fit the canvas within the screenshot, as in letterboxing.
       */
      CreateScreenshot,
      /**
       * Captures a screenshot of the current rendering
       * Please note that simultaneous screenshots are not supported: you must wait until one screenshot is complete before taking another.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
       * @param engine defines the rendering engine
       * @param camera defines the source camera. If the camera is not the scene's active camera, {@link CreateScreenshotUsingRenderTarget} will be used instead, and `useFill` will be ignored
       * @param size This parameter can be set to a single number or to an object with the
       * following (optional) properties: precision, width, height. If a single number is passed,
       * it will be used for both width and height. If an object is passed, the screenshot size
       * will be derived from the parameters. The precision property is a multiplier allowing
       * rendering at a higher or lower resolution
       * @param mimeType defines the MIME type of the screenshot image (default: image/png).
       * Check your browser for supported MIME types
       * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
       * @param useFill fill the screenshot dimensions with the render canvas and clip any overflow. If false, fit the canvas within the screenshot, as in letterboxing.
       * @param forceDownload force the system to download the image
       * @returns screenshot as a string of base64-encoded characters. This string can be assigned
       * to the src parameter of an <img> to display it
       */
      CreateScreenshotAsync,
      /**
       * Captures and automatically downloads a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)
       * If screenshot image data is needed, use {@link CreateScreenshotAsync} instead.
       * Please note that simultaneous screenshots are not supported: you must wait until one screenshot is complete before taking another.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
       * @param engine defines the rendering engine
       * @param camera defines the source camera. If the camera is not the scene's active camera, {@link CreateScreenshotUsingRenderTarget} will be used instead, and `useFill` will be ignored
       * @param width defines the expected width
       * @param height defines the expected height
       * @param mimeType defines the MIME type of the screenshot image (default: image/png).
       * Check your browser for supported MIME types
       * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
       * @param useFill fill the screenshot dimensions with the render canvas and clip any overflow. If false, fit the canvas within the screenshot, as in letterboxing.
       * @returns promise that resolves once the screenshot is taken
       */
      CreateScreenshotWithResizeAsync,
      /**
       * Generates an image screenshot from the specified camera.
       * Please note that simultaneous screenshots are not supported: you must wait until one screenshot is complete before taking another.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
       * @param engine The engine to use for rendering
       * @param camera The camera to use for rendering
       * @param size This parameter can be set to a single number or to an object with the
       * following (optional) properties: precision, width, height. If a single number is passed,
       * it will be used for both width and height. If an object is passed, the screenshot size
       * will be derived from the parameters. The precision property is a multiplier allowing
       * rendering at a higher or lower resolution
       * @param successCallback The callback receives a single parameter which contains the
       * screenshot as a string of base64-encoded characters. This string can be assigned to the
       * src parameter of an <img> to display it
       * @param mimeType The MIME type of the screenshot image (default: image/png).
       * Check your browser for supported MIME types
       * @param samples Texture samples (default: 1)
       * @param antialiasing Whether antialiasing should be turned on or not (default: false)
       * @param fileName A name for for the downloaded file.
       * @param renderSprites Whether the sprites should be rendered or not (default: false)
       * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)
       * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
       */
      CreateScreenshotUsingRenderTarget,
      /**
       * Generates an image screenshot from the specified camera.
       * Please note that simultaneous screenshots are not supported: you must wait until one screenshot is complete before taking another.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
       * @param engine The engine to use for rendering
       * @param camera The camera to use for rendering
       * @param size This parameter can be set to a single number or to an object with the
       * following (optional) properties: precision, width, height. If a single number is passed,
       * it will be used for both width and height. If an object is passed, the screenshot size
       * will be derived from the parameters. The precision property is a multiplier allowing
       * rendering at a higher or lower resolution
       * @param mimeType The MIME type of the screenshot image (default: image/png).
       * Check your browser for supported MIME types
       * @param samples Texture samples (default: 1)
       * @param antialiasing Whether antialiasing should be turned on or not (default: false)
       * @param fileName A name for for the downloaded file.
       * @param renderSprites Whether the sprites should be rendered or not (default: false)
       * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
       * @returns screenshot as a string of base64-encoded characters. This string can be assigned
       * to the src parameter of an <img> to display it
       */
      CreateScreenshotUsingRenderTargetAsync,
      /**
       * Generates an image screenshot from the specified frame graph and camera
       * Please note:
       *  - that the frame graph must write to the back buffer color for this to work! This is because the back buffer color is replaced by the texture of the screenshot during the operation.
       *  - the camera is set as the camera for the main object renderer of the frame graph during the operation, and restored afterwards.
       *    This will only work if the frame graph has a main object renderer (isMainObjectRenderer is true for one of its object renderers)
       *  - that simultaneous screenshots are not supported: you must wait until one screenshot is complete before taking another.
       * @param frameGraph The frame graph to use for rendering
       * @param camera The camera to use for rendering
       * @param size This parameter can be set to a single number or to an object with the
       * following (optional) properties: precision, width, height. If a single number is passed,
       * it will be used for both width and height. If an object is passed, the screenshot size
       * will be derived from the parameters. The precision property is a multiplier allowing
       * rendering at a higher or lower resolution
       * @param mimeType The MIME type of the screenshot image (default: image/png).
       * Check your browser for supported MIME types
       * @param samples Texture samples (default: 1)
       * @param antialiasing Whether antialiasing should be turned on or not (default: false)
       * @param fileName A name for for the downloaded file.
       * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
       * @param customDumpData The function to use to dump the data. If not provided, the default DumpData function will be used.
       * @param automaticDownload If true, the screenshot will be automatically downloaded as a file instead of being returned as a string: in this case, null is returned.
       * @returns screenshot as a string of base64-encoded characters. This string can be assigned
       * to the src parameter of an <img> to display it. If automaticDownload is true, null is returned instead
       */
      CreateScreenshotForFrameGraphAsync
    };
    initSideEffects = () => {
      Tools.CreateScreenshot = CreateScreenshot;
      Tools.CreateScreenshotAsync = CreateScreenshotAsync;
      Tools.CreateScreenshotUsingRenderTarget = CreateScreenshotUsingRenderTarget;
      Tools.CreateScreenshotUsingRenderTargetAsync = CreateScreenshotUsingRenderTargetAsync;
    };
    initSideEffects();
  }
});

// node_modules/@babylonjs/core/Misc/gradients.js
var ColorGradient, Color3Gradient, FactorGradient, GradientHelper;
var init_gradients = __esm({
  "node_modules/@babylonjs/core/Misc/gradients.js"() {
    init_math_color();
    ColorGradient = class {
      /**
       * Creates a new color4 gradient
       * @param gradient gets or sets the gradient value (between 0 and 1)
       * @param color1 gets or sets first associated color
       * @param color2 gets or sets first second color
       */
      constructor(gradient, color1, color2) {
        this.gradient = gradient;
        this.color1 = color1;
        this.color2 = color2;
      }
      /**
       * Will get a color picked randomly between color1 and color2.
       * If color2 is undefined then color1 will be used
       * @param result defines the target Color4 to store the result in
       */
      getColorToRef(result) {
        if (!this.color2) {
          result.copyFrom(this.color1);
          return;
        }
        Color4.LerpToRef(this.color1, this.color2, Math.random(), result);
      }
    };
    Color3Gradient = class {
      /**
       * Creates a new color3 gradient
       * @param gradient gets or sets the gradient value (between 0 and 1)
       * @param color gets or sets associated color
       */
      constructor(gradient, color) {
        this.gradient = gradient;
        this.color = color;
      }
    };
    FactorGradient = class {
      /**
       * Creates a new factor gradient
       * @param gradient gets or sets the gradient value (between 0 and 1)
       * @param factor1 gets or sets first associated factor
       * @param factor2 gets or sets second associated factor
       */
      constructor(gradient, factor1, factor2) {
        this.gradient = gradient;
        this.factor1 = factor1;
        this.factor2 = factor2;
      }
      /**
       * Will get a number picked randomly between factor1 and factor2.
       * If factor2 is undefined then factor1 will be used
       * @returns the picked number
       */
      getFactor() {
        if (this.factor2 === void 0 || this.factor2 === this.factor1) {
          return this.factor1;
        }
        return this.factor1 + (this.factor2 - this.factor1) * Math.random();
      }
    };
    GradientHelper = class {
      /**
       * Gets the current gradient from an array of IValueGradient
       * @param ratio defines the current ratio to get
       * @param gradients defines the array of IValueGradient
       * @param updateFunc defines the callback function used to get the final value from the selected gradients
       */
      static GetCurrentGradient(ratio, gradients, updateFunc) {
        if (gradients[0].gradient > ratio) {
          updateFunc(gradients[0], gradients[0], 1);
          return;
        }
        for (let gradientIndex = 0; gradientIndex < gradients.length - 1; gradientIndex++) {
          const currentGradient = gradients[gradientIndex];
          const nextGradient = gradients[gradientIndex + 1];
          if (ratio >= currentGradient.gradient && ratio <= nextGradient.gradient) {
            const scale = (ratio - currentGradient.gradient) / (nextGradient.gradient - currentGradient.gradient);
            updateFunc(currentGradient, nextGradient, scale);
            return;
          }
        }
        const lastIndex = gradients.length - 1;
        updateFunc(gradients[lastIndex], gradients[lastIndex], 1);
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/dataReader.js
var DataReader;
var init_dataReader = __esm({
  "node_modules/@babylonjs/core/Misc/dataReader.js"() {
    init_stringTools();
    DataReader = class {
      /**
       * Constructor
       * @param buffer The buffer to read
       */
      constructor(buffer) {
        this.byteOffset = 0;
        this.buffer = buffer;
      }
      /**
       * Loads the given byte length.
       * @param byteLength The byte length to load
       * @returns A promise that resolves when the load is complete
       */
      async loadAsync(byteLength) {
        const data = await this.buffer.readAsync(this.byteOffset, byteLength);
        this._dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
        this._dataByteOffset = 0;
      }
      /**
       * Read a unsigned 32-bit integer from the currently loaded data range.
       * @returns The 32-bit integer read
       */
      readUint32() {
        const value = this._dataView.getUint32(this._dataByteOffset, true);
        this._dataByteOffset += 4;
        this.byteOffset += 4;
        return value;
      }
      /**
       * Read a byte array from the currently loaded data range.
       * @param byteLength The byte length to read
       * @returns The byte array read
       */
      readUint8Array(byteLength) {
        const value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._dataByteOffset, byteLength);
        this._dataByteOffset += byteLength;
        this.byteOffset += byteLength;
        return value;
      }
      /**
       * Read a string from the currently loaded data range.
       * @param byteLength The byte length to read
       * @returns The string read
       */
      readString(byteLength) {
        return Decode(this.readUint8Array(byteLength));
      }
      /**
       * Skips the given byte length the currently loaded data range.
       * @param byteLength The byte length to skip
       */
      skipBytes(byteLength) {
        this._dataByteOffset += byteLength;
        this.byteOffset += byteLength;
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/dataStorage.js
var DataStorage;
var init_dataStorage = __esm({
  "node_modules/@babylonjs/core/Misc/dataStorage.js"() {
    DataStorage = class {
      static _GetStorage() {
        try {
          localStorage.setItem("test", "");
          localStorage.removeItem("test");
          return localStorage;
        } catch {
          const inMemoryStorage = {};
          return {
            getItem: (key) => {
              const value = inMemoryStorage[key];
              return value === void 0 ? null : value;
            },
            setItem: (key, value) => {
              inMemoryStorage[key] = value;
            }
          };
        }
      }
      /**
       * Reads a string from the data storage
       * @param key The key to read
       * @param defaultValue The value if the key doesn't exist
       * @returns The string value
       */
      static ReadString(key, defaultValue) {
        const value = this._Storage.getItem(key);
        return value !== null ? value : defaultValue;
      }
      /**
       * Writes a string to the data storage
       * @param key The key to write
       * @param value The value to write
       */
      static WriteString(key, value) {
        this._Storage.setItem(key, value);
      }
      /**
       * Reads a boolean from the data storage
       * @param key The key to read
       * @param defaultValue The value if the key doesn't exist
       * @returns The boolean value
       */
      static ReadBoolean(key, defaultValue) {
        const value = this._Storage.getItem(key);
        return value !== null ? value === "true" : defaultValue;
      }
      /**
       * Writes a boolean to the data storage
       * @param key The key to write
       * @param value The value to write
       */
      static WriteBoolean(key, value) {
        this._Storage.setItem(key, value ? "true" : "false");
      }
      /**
       * Reads a number from the data storage
       * @param key The key to read
       * @param defaultValue The value if the key doesn't exist
       * @returns The number value
       */
      static ReadNumber(key, defaultValue) {
        const value = this._Storage.getItem(key);
        return value !== null ? parseFloat(value) : defaultValue;
      }
      /**
       * Writes a number to the data storage
       * @param key The key to write
       * @param value The value to write
       */
      static WriteNumber(key, value) {
        this._Storage.setItem(key, value.toString());
      }
    };
    DataStorage._Storage = DataStorage._GetStorage();
  }
});

// node_modules/@babylonjs/core/Particles/particle.js
var Particle;
var init_particle = __esm({
  "node_modules/@babylonjs/core/Particles/particle.js"() {
    init_math_vector();
    init_math_color();
    init_math_scalar_functions();
    Particle = class _Particle {
      /**
       * Creates a new instance Particle
       * @param particleSystem the particle system the particle belongs to
       */
      constructor(particleSystem) {
        this.particleSystem = particleSystem;
        this.position = Vector3.Zero();
        this.direction = Vector3.Zero();
        this.color = new Color4(0, 0, 0, 0);
        this.colorStep = new Color4(0, 0, 0, 0);
        this.initialColor = new Color4(0, 0, 0, 0);
        this.colorDead = new Color4(0, 0, 0, 0);
        this.lifeTime = 1;
        this.age = 0;
        this.size = 0;
        this.scale = new Vector2(1, 1);
        this.angle = 0;
        this.angularSpeed = 0;
        this.cellIndex = 0;
        this._attachedSubEmitters = null;
        this._currentColor1 = new Color4(0, 0, 0, 0);
        this._currentColor2 = new Color4(0, 0, 0, 0);
        this._currentSize1 = 0;
        this._currentSize2 = 0;
        this._currentAngularSpeed1 = 0;
        this._currentAngularSpeed2 = 0;
        this._currentVelocity1 = 0;
        this._currentVelocity2 = 0;
        this._scaledDirection = Vector3.Zero();
        this._currentLimitVelocity1 = 0;
        this._currentLimitVelocity2 = 0;
        this._currentDrag1 = 0;
        this._currentDrag2 = 0;
        this.id = _Particle._Count++;
        if (!this.particleSystem.isAnimationSheetEnabled) {
          return;
        }
        this._updateCellInfoFromSystem();
      }
      _updateCellInfoFromSystem() {
        this.cellIndex = this.particleSystem.startSpriteCellID;
      }
      /**
       * Defines how the sprite cell index is updated for the particle
       */
      updateCellIndex() {
        let offsetAge = this.age;
        let changeSpeed = this.particleSystem.spriteCellChangeSpeed;
        if (this.particleSystem.spriteRandomStartCell) {
          if (this._randomCellOffset === void 0) {
            this._randomCellOffset = Math.random() * this.lifeTime;
          }
          if (changeSpeed === 0) {
            changeSpeed = 1;
            offsetAge = this._randomCellOffset;
          } else {
            offsetAge += this._randomCellOffset;
          }
        }
        const dist = this._initialEndSpriteCellId - this._initialStartSpriteCellId + 1;
        let ratio;
        if (this._initialSpriteCellLoop) {
          ratio = Clamp(offsetAge * changeSpeed % this.lifeTime / this.lifeTime);
        } else {
          ratio = Clamp(offsetAge * changeSpeed / this.lifeTime);
        }
        this.cellIndex = this._initialStartSpriteCellId + ratio * dist | 0;
      }
      /**
       * @internal
       */
      _inheritParticleInfoToSubEmitter(subEmitter) {
        if (subEmitter.particleSystem.emitter.position) {
          const emitterMesh = subEmitter.particleSystem.emitter;
          emitterMesh.position.copyFrom(this.position);
          if (subEmitter.inheritDirection) {
            const temp = TmpVectors.Vector3[0];
            this.direction.normalizeToRef(temp);
            emitterMesh.setDirection(temp, 0, Math.PI / 2);
          }
        } else {
          const emitterPosition = subEmitter.particleSystem.emitter;
          emitterPosition.copyFrom(this.position);
        }
        this.direction.scaleToRef(subEmitter.inheritedVelocityAmount / 2, TmpVectors.Vector3[0]);
        subEmitter.particleSystem._inheritedVelocityOffset.copyFrom(TmpVectors.Vector3[0]);
      }
      /** @internal */
      _inheritParticleInfoToSubEmitters() {
        if (this._attachedSubEmitters && this._attachedSubEmitters.length > 0) {
          for (const subEmitter of this._attachedSubEmitters) {
            this._inheritParticleInfoToSubEmitter(subEmitter);
          }
        }
      }
      /** @internal */
      _reset() {
        if (this.onReset) {
          this.onReset();
        }
        this.age = 0;
        this.id = _Particle._Count++;
        this._currentColorGradient = null;
        this._currentSizeGradient = null;
        this._currentAngularSpeedGradient = null;
        this._currentVelocityGradient = null;
        this._currentLimitVelocityGradient = null;
        this._currentDragGradient = null;
        this.cellIndex = this.particleSystem.startSpriteCellID;
        this._randomCellOffset = void 0;
        this._randomNoiseCoordinates1 = null;
        this._randomNoiseCoordinates2 = null;
      }
      /**
       * Copy the properties of particle to another one.
       * @param other the particle to copy the information to.
       */
      copyTo(other) {
        other.position.copyFrom(this.position);
        if (this._initialDirection) {
          if (other._initialDirection) {
            other._initialDirection.copyFrom(this._initialDirection);
          } else {
            other._initialDirection = this._initialDirection.clone();
          }
        } else {
          other._initialDirection = null;
        }
        other.direction.copyFrom(this.direction);
        if (this._localPosition) {
          if (other._localPosition) {
            other._localPosition.copyFrom(this._localPosition);
          } else {
            other._localPosition = this._localPosition.clone();
          }
        }
        other.color.copyFrom(this.color);
        other.colorStep.copyFrom(this.colorStep);
        other.initialColor.copyFrom(this.initialColor);
        other.colorDead.copyFrom(this.colorDead);
        other.lifeTime = this.lifeTime;
        other.age = this.age;
        other._randomCellOffset = this._randomCellOffset;
        other.size = this.size;
        other.scale.copyFrom(this.scale);
        other.angle = this.angle;
        other.angularSpeed = this.angularSpeed;
        other.particleSystem = this.particleSystem;
        other.cellIndex = this.cellIndex;
        other.id = this.id;
        other._attachedSubEmitters = this._attachedSubEmitters;
        if (this._currentColorGradient) {
          other._currentColorGradient = this._currentColorGradient;
          other._currentColor1.copyFrom(this._currentColor1);
          other._currentColor2.copyFrom(this._currentColor2);
        }
        if (this._currentSizeGradient) {
          other._currentSizeGradient = this._currentSizeGradient;
          other._currentSize1 = this._currentSize1;
          other._currentSize2 = this._currentSize2;
        }
        if (this._currentAngularSpeedGradient) {
          other._currentAngularSpeedGradient = this._currentAngularSpeedGradient;
          other._currentAngularSpeed1 = this._currentAngularSpeed1;
          other._currentAngularSpeed2 = this._currentAngularSpeed2;
        }
        if (this._currentVelocityGradient) {
          other._currentVelocityGradient = this._currentVelocityGradient;
          other._currentVelocity1 = this._currentVelocity1;
          other._currentVelocity2 = this._currentVelocity2;
        }
        if (this._currentLimitVelocityGradient) {
          other._currentLimitVelocityGradient = this._currentLimitVelocityGradient;
          other._currentLimitVelocity1 = this._currentLimitVelocity1;
          other._currentLimitVelocity2 = this._currentLimitVelocity2;
        }
        if (this._currentDragGradient) {
          other._currentDragGradient = this._currentDragGradient;
          other._currentDrag1 = this._currentDrag1;
          other._currentDrag2 = this._currentDrag2;
        }
        if (this.particleSystem.isAnimationSheetEnabled) {
          other._initialStartSpriteCellId = this._initialStartSpriteCellId;
          other._initialEndSpriteCellId = this._initialEndSpriteCellId;
          other._initialSpriteCellLoop = this._initialSpriteCellLoop;
        }
        if (this.particleSystem.useRampGradients) {
          if (other.remapData && this.remapData) {
            other.remapData.copyFrom(this.remapData);
          } else {
            other.remapData = new Vector4(0, 0, 0, 0);
          }
        }
        if (this._randomNoiseCoordinates1 && this._randomNoiseCoordinates2) {
          if (other._randomNoiseCoordinates1 && other._randomNoiseCoordinates2) {
            other._randomNoiseCoordinates1.copyFrom(this._randomNoiseCoordinates1);
            other._randomNoiseCoordinates2.copyFrom(this._randomNoiseCoordinates2);
          } else {
            other._randomNoiseCoordinates1 = this._randomNoiseCoordinates1.clone();
            other._randomNoiseCoordinates2 = this._randomNoiseCoordinates2.clone();
          }
        }
      }
    };
    Particle._Count = 0;
  }
});

// node_modules/@babylonjs/core/Particles/EmitterTypes/boxParticleEmitter.js
var BoxParticleEmitter;
var init_boxParticleEmitter = __esm({
  "node_modules/@babylonjs/core/Particles/EmitterTypes/boxParticleEmitter.js"() {
    init_math_vector();
    init_math_scalar_functions();
    init_deepCopier();
    BoxParticleEmitter = class _BoxParticleEmitter {
      /**
       * Creates a new instance BoxParticleEmitter
       */
      constructor() {
        this.direction1 = new Vector3(0, 1, 0);
        this.direction2 = new Vector3(0, 1, 0);
        this.minEmitBox = new Vector3(-0.5, -0.5, -0.5);
        this.maxEmitBox = new Vector3(0.5, 0.5, 0.5);
      }
      /**
       * Called by the particle System when the direction is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param directionToUpdate is the direction vector to update with the result
       * @param particle is the particle we are computed the direction for
       * @param isLocal defines if the direction should be set in local space
       */
      startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
        const randX = RandomRange(this.direction1.x, this.direction2.x);
        const randY = RandomRange(this.direction1.y, this.direction2.y);
        const randZ = RandomRange(this.direction1.z, this.direction2.z);
        if (isLocal) {
          directionToUpdate.x = randX;
          directionToUpdate.y = randY;
          directionToUpdate.z = randZ;
          return;
        }
        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
      }
      /**
       * Called by the particle System when the position is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param positionToUpdate is the position vector to update with the result
       * @param particle is the particle we are computed the position for
       * @param isLocal defines if the position should be set in local space
       */
      startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
        const randX = RandomRange(this.minEmitBox.x, this.maxEmitBox.x);
        const randY = RandomRange(this.minEmitBox.y, this.maxEmitBox.y);
        const randZ = RandomRange(this.minEmitBox.z, this.maxEmitBox.z);
        if (isLocal) {
          positionToUpdate.x = randX;
          positionToUpdate.y = randY;
          positionToUpdate.z = randZ;
          return;
        }
        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
      }
      /**
       * Clones the current emitter and returns a copy of it
       * @returns the new emitter
       */
      clone() {
        const newOne = new _BoxParticleEmitter();
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
      }
      /**
       * Called by the GPUParticleSystem to setup the update shader
       * @param uboOrEffect defines the update shader
       */
      applyToShader(uboOrEffect) {
        uboOrEffect.setVector3("direction1", this.direction1);
        uboOrEffect.setVector3("direction2", this.direction2);
        uboOrEffect.setVector3("minEmitBox", this.minEmitBox);
        uboOrEffect.setVector3("maxEmitBox", this.maxEmitBox);
      }
      /**
       * Creates the structure of the ubo for this particle emitter
       * @param ubo ubo to create the structure for
       */
      buildUniformLayout(ubo) {
        ubo.addUniform("direction1", 3);
        ubo.addUniform("direction2", 3);
        ubo.addUniform("minEmitBox", 3);
        ubo.addUniform("maxEmitBox", 3);
      }
      /**
       * Returns a string to use to update the GPU particles update shader
       * @returns a string containing the defines string
       */
      getEffectDefines() {
        return "#define BOXEMITTER";
      }
      /**
       * Returns the string "BoxParticleEmitter"
       * @returns a string containing the class name
       */
      getClassName() {
        return "BoxParticleEmitter";
      }
      /**
       * Serializes the particle system to a JSON object.
       * @returns the JSON object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.type = this.getClassName();
        serializationObject.direction1 = this.direction1.asArray();
        serializationObject.direction2 = this.direction2.asArray();
        serializationObject.minEmitBox = this.minEmitBox.asArray();
        serializationObject.maxEmitBox = this.maxEmitBox.asArray();
        return serializationObject;
      }
      /**
       * Parse properties from a JSON object
       * @param serializationObject defines the JSON object
       */
      parse(serializationObject) {
        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
        Vector3.FromArrayToRef(serializationObject.minEmitBox, 0, this.minEmitBox);
        Vector3.FromArrayToRef(serializationObject.maxEmitBox, 0, this.maxEmitBox);
      }
    };
  }
});

// node_modules/@babylonjs/core/Particles/subEmitter.js
var SubEmitterType, SubEmitter;
var init_subEmitter = __esm({
  "node_modules/@babylonjs/core/Particles/subEmitter.js"() {
    init_math_vector();
    init_devTools();
    init_typeStore();
    (function(SubEmitterType2) {
      SubEmitterType2[SubEmitterType2["ATTACHED"] = 0] = "ATTACHED";
      SubEmitterType2[SubEmitterType2["END"] = 1] = "END";
    })(SubEmitterType || (SubEmitterType = {}));
    SubEmitter = class _SubEmitter {
      /**
       * Creates a sub emitter
       * @param particleSystem the particle system to be used by the sub emitter
       */
      constructor(particleSystem) {
        this.particleSystem = particleSystem;
        this.type = 1;
        this.inheritDirection = false;
        this.inheritedVelocityAmount = 0;
        if (!particleSystem.emitter || !particleSystem.emitter.dispose) {
          const internalClass = GetClass("BABYLON.AbstractMesh");
          particleSystem.emitter = new internalClass("SubemitterSystemEmitter", particleSystem.getScene());
          particleSystem._disposeEmitterOnDispose = true;
        }
      }
      /**
       * Clones the sub emitter
       * @returns the cloned sub emitter
       */
      clone() {
        let emitter = this.particleSystem.emitter;
        if (!emitter) {
          emitter = new Vector3();
        } else if (emitter instanceof Vector3) {
          emitter = emitter.clone();
        } else if (emitter.getClassName().indexOf("Mesh") !== -1) {
          const internalClass = GetClass("BABYLON.Mesh");
          emitter = new internalClass("", emitter.getScene());
          emitter.isVisible = false;
        }
        const clone = new _SubEmitter(this.particleSystem.clone(this.particleSystem.name, emitter));
        clone.particleSystem.name += "Clone";
        clone.type = this.type;
        clone.inheritDirection = this.inheritDirection;
        clone.inheritedVelocityAmount = this.inheritedVelocityAmount;
        clone.particleSystem._disposeEmitterOnDispose = true;
        clone.particleSystem.disposeOnStop = true;
        return clone;
      }
      /**
       * Serialize current object to a JSON object
       * @param serializeTexture defines if the texture must be serialized as well
       * @returns the serialized object
       */
      serialize(serializeTexture = false) {
        const serializationObject = {};
        serializationObject.type = this.type;
        serializationObject.inheritDirection = this.inheritDirection;
        serializationObject.inheritedVelocityAmount = this.inheritedVelocityAmount;
        serializationObject.particleSystem = this.particleSystem.serialize(serializeTexture);
        return serializationObject;
      }
      /**
       * @internal
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      static _ParseParticleSystem(system, sceneOrEngine, rootUrl, doNotStart = false) {
        throw _WarnImport("ParseParticle");
      }
      /**
       * Creates a new SubEmitter from a serialized JSON version
       * @param serializationObject defines the JSON object to read from
       * @param sceneOrEngine defines the hosting scene or the hosting engine
       * @param rootUrl defines the rootUrl for data loading
       * @returns a new SubEmitter
       */
      static Parse(serializationObject, sceneOrEngine, rootUrl) {
        const system = serializationObject.particleSystem;
        const subEmitter = new _SubEmitter(_SubEmitter._ParseParticleSystem(system, sceneOrEngine, rootUrl, true));
        subEmitter.type = serializationObject.type;
        subEmitter.inheritDirection = serializationObject.inheritDirection;
        subEmitter.inheritedVelocityAmount = serializationObject.inheritedVelocityAmount;
        subEmitter.particleSystem._isSubEmitter = true;
        return subEmitter;
      }
      /** Release associated resources */
      dispose() {
        this.particleSystem.dispose();
      }
    };
  }
});

// node_modules/@babylonjs/core/Particles/EmitterTypes/meshParticleEmitter.js
var MeshParticleEmitter;
var init_meshParticleEmitter = __esm({
  "node_modules/@babylonjs/core/Particles/EmitterTypes/meshParticleEmitter.js"() {
    init_deepCopier();
    init_math_vector();
    init_math_scalar_functions();
    init_buffer();
    MeshParticleEmitter = class _MeshParticleEmitter {
      /** Defines the mesh to use as source */
      get mesh() {
        return this._mesh;
      }
      set mesh(value) {
        if (this._mesh === value) {
          return;
        }
        this._mesh = value;
        if (value) {
          this._indices = value.getIndices();
          this._positions = value.getVerticesData(VertexBuffer.PositionKind);
          this._normals = value.getVerticesData(VertexBuffer.NormalKind);
        } else {
          this._indices = null;
          this._positions = null;
          this._normals = null;
        }
      }
      /**
       * Creates a new instance MeshParticleEmitter
       * @param mesh defines the mesh to use as source
       */
      constructor(mesh = null) {
        this._indices = null;
        this._positions = null;
        this._normals = null;
        this._storedNormal = Vector3.Zero();
        this._mesh = null;
        this.direction1 = new Vector3(0, 1, 0);
        this.direction2 = new Vector3(0, 1, 0);
        this.useMeshNormalsForDirection = true;
        this.mesh = mesh;
      }
      /**
       * Called by the particle System when the direction is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param directionToUpdate is the direction vector to update with the result
       * @param particle is the particle we are computed the direction for
       * @param isLocal defines if the direction should be set in local space
       */
      startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
        if (this.useMeshNormalsForDirection && this._normals) {
          Vector3.TransformNormalToRef(this._storedNormal, worldMatrix, directionToUpdate);
          return;
        }
        const randX = RandomRange(this.direction1.x, this.direction2.x);
        const randY = RandomRange(this.direction1.y, this.direction2.y);
        const randZ = RandomRange(this.direction1.z, this.direction2.z);
        if (isLocal) {
          directionToUpdate.copyFromFloats(randX, randY, randZ);
          return;
        }
        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
      }
      /**
       * Called by the particle System when the position is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param positionToUpdate is the position vector to update with the result
       * @param particle is the particle we are computed the position for
       * @param isLocal defines if the position should be set in local space
       */
      startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
        if (!this._indices || !this._positions) {
          return;
        }
        const randomFaceIndex = 3 * (Math.random() * (this._indices.length / 3) | 0);
        const bu = Math.random();
        const bv = Math.random() * (1 - bu);
        const bw = 1 - bu - bv;
        const faceIndexA = this._indices[randomFaceIndex];
        const faceIndexB = this._indices[randomFaceIndex + 1];
        const faceIndexC = this._indices[randomFaceIndex + 2];
        const vertexA = TmpVectors.Vector3[0];
        const vertexB = TmpVectors.Vector3[1];
        const vertexC = TmpVectors.Vector3[2];
        const randomVertex = TmpVectors.Vector3[3];
        Vector3.FromArrayToRef(this._positions, faceIndexA * 3, vertexA);
        Vector3.FromArrayToRef(this._positions, faceIndexB * 3, vertexB);
        Vector3.FromArrayToRef(this._positions, faceIndexC * 3, vertexC);
        randomVertex.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;
        randomVertex.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;
        randomVertex.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;
        if (isLocal) {
          positionToUpdate.copyFromFloats(randomVertex.x, randomVertex.y, randomVertex.z);
        } else {
          Vector3.TransformCoordinatesFromFloatsToRef(randomVertex.x, randomVertex.y, randomVertex.z, worldMatrix, positionToUpdate);
        }
        if (this.useMeshNormalsForDirection && this._normals) {
          Vector3.FromArrayToRef(this._normals, faceIndexA * 3, vertexA);
          Vector3.FromArrayToRef(this._normals, faceIndexB * 3, vertexB);
          Vector3.FromArrayToRef(this._normals, faceIndexC * 3, vertexC);
          this._storedNormal.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;
          this._storedNormal.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;
          this._storedNormal.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;
        }
      }
      /**
       * Clones the current emitter and returns a copy of it
       * @returns the new emitter
       */
      clone() {
        const newOne = new _MeshParticleEmitter(this.mesh);
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
      }
      /**
       * Called by the GPUParticleSystem to setup the update shader
       * @param uboOrEffect defines the update shader
       */
      applyToShader(uboOrEffect) {
        uboOrEffect.setVector3("direction1", this.direction1);
        uboOrEffect.setVector3("direction2", this.direction2);
      }
      /**
       * Creates the structure of the ubo for this particle emitter
       * @param ubo ubo to create the structure for
       */
      buildUniformLayout(ubo) {
        ubo.addUniform("direction1", 3);
        ubo.addUniform("direction2", 3);
      }
      /**
       * Returns a string to use to update the GPU particles update shader
       * @returns a string containing the defines string
       */
      getEffectDefines() {
        return "";
      }
      /**
       * Returns the string "BoxParticleEmitter"
       * @returns a string containing the class name
       */
      getClassName() {
        return "MeshParticleEmitter";
      }
      /**
       * Serializes the particle system to a JSON object.
       * @returns the JSON object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.type = this.getClassName();
        serializationObject.direction1 = this.direction1.asArray();
        serializationObject.direction2 = this.direction2.asArray();
        serializationObject.meshId = this.mesh?.id;
        serializationObject.useMeshNormalsForDirection = this.useMeshNormalsForDirection;
        return serializationObject;
      }
      /**
       * Parse properties from a JSON object
       * @param serializationObject defines the JSON object
       * @param scene defines the hosting scene
       */
      parse(serializationObject, scene) {
        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
        if (serializationObject.meshId && scene) {
          this.mesh = scene.getLastMeshById(serializationObject.meshId);
        }
        this.useMeshNormalsForDirection = serializationObject.useMeshNormalsForDirection;
      }
    };
  }
});

// node_modules/@babylonjs/core/Particles/EmitterTypes/customParticleEmitter.js
var EmptyGeneratorFunc, CustomParticleEmitter;
var init_customParticleEmitter = __esm({
  "node_modules/@babylonjs/core/Particles/EmitterTypes/customParticleEmitter.js"() {
    init_deepCopier();
    init_math_vector();
    EmptyGeneratorFunc = () => {
    };
    CustomParticleEmitter = class _CustomParticleEmitter {
      /**
       * Creates a new instance CustomParticleEmitter
       */
      constructor() {
        this.particlePositionGenerator = EmptyGeneratorFunc;
        this.particleDestinationGenerator = EmptyGeneratorFunc;
        this.particleDirectionGenerator = EmptyGeneratorFunc;
      }
      /**
       * Called by the particle System when the direction is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param directionToUpdate is the direction vector to update with the result
       * @param particle is the particle we are computed the direction for
       * @param isLocal defines if the direction should be set in local space
       */
      startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
        const tmpVector = TmpVectors.Vector3[0];
        if (this.particleDirectionGenerator && this.particleDirectionGenerator !== EmptyGeneratorFunc) {
          this.particleDirectionGenerator(-1, particle, tmpVector);
        } else if (this.particleDestinationGenerator && this.particleDestinationGenerator !== EmptyGeneratorFunc) {
          this.particleDestinationGenerator(-1, particle, tmpVector);
          const diffVector = TmpVectors.Vector3[1];
          tmpVector.subtractToRef(particle.position, diffVector);
          diffVector.scaleToRef(1 / particle.lifeTime, tmpVector);
        } else {
          tmpVector.set(0, 0, 0);
        }
        if (isLocal) {
          directionToUpdate.copyFrom(tmpVector);
          return;
        }
        Vector3.TransformNormalToRef(tmpVector, worldMatrix, directionToUpdate);
      }
      /**
       * Called by the particle System when the position is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param positionToUpdate is the position vector to update with the result
       * @param particle is the particle we are computed the position for
       * @param isLocal defines if the position should be set in local space
       */
      startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
        const tmpVector = TmpVectors.Vector3[0];
        if (this.particlePositionGenerator && this.particlePositionGenerator !== EmptyGeneratorFunc) {
          this.particlePositionGenerator(-1, particle, tmpVector);
        } else {
          tmpVector.set(0, 0, 0);
        }
        if (isLocal) {
          positionToUpdate.copyFrom(tmpVector);
          return;
        }
        Vector3.TransformCoordinatesToRef(tmpVector, worldMatrix, positionToUpdate);
      }
      /**
       * Clones the current emitter and returns a copy of it
       * @returns the new emitter
       */
      clone() {
        const newOne = new _CustomParticleEmitter();
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
      }
      /**
       * Called by the GPUParticleSystem to setup the update shader
       * @param uboOrEffect defines the update shader
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      applyToShader(uboOrEffect) {
      }
      /**
       * Creates the structure of the ubo for this particle emitter
       * @param ubo ubo to create the structure for
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      buildUniformLayout(ubo) {
      }
      /**
       * Returns a string to use to update the GPU particles update shader
       * @returns a string containing the defines string
       */
      getEffectDefines() {
        return "#define CUSTOMEMITTER";
      }
      /**
       * Returns the string "PointParticleEmitter"
       * @returns a string containing the class name
       */
      getClassName() {
        return "CustomParticleEmitter";
      }
      /**
       * Serializes the particle system to a JSON object.
       * @returns the JSON object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.type = this.getClassName();
        serializationObject.particlePositionGenerator = this.particlePositionGenerator;
        serializationObject.particleDestinationGenerator = this.particleDestinationGenerator;
        return serializationObject;
      }
      /**
       * Parse properties from a JSON object
       * @param serializationObject defines the JSON object
       */
      parse(serializationObject) {
        if (serializationObject.particlePositionGenerator) {
          this.particlePositionGenerator = serializationObject.particlePositionGenerator;
        }
        if (serializationObject.particleDestinationGenerator) {
          this.particleDestinationGenerator = serializationObject.particleDestinationGenerator;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Particles/EmitterTypes/pointParticleEmitter.js
var PointParticleEmitter;
var init_pointParticleEmitter = __esm({
  "node_modules/@babylonjs/core/Particles/EmitterTypes/pointParticleEmitter.js"() {
    init_deepCopier();
    init_math_vector();
    init_math_scalar_functions();
    PointParticleEmitter = class _PointParticleEmitter {
      /**
       * Creates a new instance PointParticleEmitter
       */
      constructor() {
        this.direction1 = new Vector3(0, 1, 0);
        this.direction2 = new Vector3(0, 1, 0);
      }
      /**
       * Called by the particle System when the direction is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param directionToUpdate is the direction vector to update with the result
       * @param particle is the particle we are computed the direction for
       * @param isLocal defines if the direction should be set in local space
       */
      startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
        const randX = RandomRange(this.direction1.x, this.direction2.x);
        const randY = RandomRange(this.direction1.y, this.direction2.y);
        const randZ = RandomRange(this.direction1.z, this.direction2.z);
        if (isLocal) {
          directionToUpdate.copyFromFloats(randX, randY, randZ);
          return;
        }
        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
      }
      /**
       * Called by the particle System when the position is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param positionToUpdate is the position vector to update with the result
       * @param particle is the particle we are computed the position for
       * @param isLocal defines if the position should be set in local space
       */
      startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
        if (isLocal) {
          positionToUpdate.copyFromFloats(0, 0, 0);
          return;
        }
        Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, worldMatrix, positionToUpdate);
      }
      /**
       * Clones the current emitter and returns a copy of it
       * @returns the new emitter
       */
      clone() {
        const newOne = new _PointParticleEmitter();
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
      }
      /**
       * Called by the GPUParticleSystem to setup the update shader
       * @param uboOrEffect defines the update shader
       */
      applyToShader(uboOrEffect) {
        uboOrEffect.setVector3("direction1", this.direction1);
        uboOrEffect.setVector3("direction2", this.direction2);
      }
      /**
       * Creates the structure of the ubo for this particle emitter
       * @param ubo ubo to create the structure for
       */
      buildUniformLayout(ubo) {
        ubo.addUniform("direction1", 3);
        ubo.addUniform("direction2", 3);
      }
      /**
       * Returns a string to use to update the GPU particles update shader
       * @returns a string containing the defines string
       */
      getEffectDefines() {
        return "#define POINTEMITTER";
      }
      /**
       * Returns the string "PointParticleEmitter"
       * @returns a string containing the class name
       */
      getClassName() {
        return "PointParticleEmitter";
      }
      /**
       * Serializes the particle system to a JSON object.
       * @returns the JSON object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.type = this.getClassName();
        serializationObject.direction1 = this.direction1.asArray();
        serializationObject.direction2 = this.direction2.asArray();
        return serializationObject;
      }
      /**
       * Parse properties from a JSON object
       * @param serializationObject defines the JSON object
       */
      parse(serializationObject) {
        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
      }
    };
  }
});

// node_modules/@babylonjs/core/Particles/EmitterTypes/hemisphericParticleEmitter.js
var HemisphericParticleEmitter;
var init_hemisphericParticleEmitter = __esm({
  "node_modules/@babylonjs/core/Particles/EmitterTypes/hemisphericParticleEmitter.js"() {
    init_deepCopier();
    init_math_vector();
    init_math_scalar_functions();
    HemisphericParticleEmitter = class _HemisphericParticleEmitter {
      /**
       * Creates a new instance HemisphericParticleEmitter
       * @param radius the radius of the emission hemisphere (1 by default)
       * @param radiusRange the range of the emission hemisphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)
       * @param directionRandomizer defines how much to randomize the particle direction [0-1]
       */
      constructor(radius = 1, radiusRange = 1, directionRandomizer = 0) {
        this.radius = radius;
        this.radiusRange = radiusRange;
        this.directionRandomizer = directionRandomizer;
      }
      /**
       * Called by the particle System when the direction is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param directionToUpdate is the direction vector to update with the result
       * @param particle is the particle we are computed the direction for
       * @param isLocal defines if the direction should be set in local space
       */
      startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
        const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();
        const randX = RandomRange(0, this.directionRandomizer);
        const randY = RandomRange(0, this.directionRandomizer);
        const randZ = RandomRange(0, this.directionRandomizer);
        direction.x += randX;
        direction.y += randY;
        direction.z += randZ;
        direction.normalize();
        if (isLocal) {
          directionToUpdate.copyFrom(direction);
          return;
        }
        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);
      }
      /**
       * Called by the particle System when the position is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param positionToUpdate is the position vector to update with the result
       * @param particle is the particle we are computed the position for
       * @param isLocal defines if the position should be set in local space
       */
      startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
        const randRadius = this.radius - RandomRange(0, this.radius * this.radiusRange);
        const v = RandomRange(0, 1);
        const phi = RandomRange(0, 2 * Math.PI);
        const theta = Math.acos(2 * v - 1);
        const randX = randRadius * Math.cos(phi) * Math.sin(theta);
        const randY = randRadius * Math.cos(theta);
        const randZ = randRadius * Math.sin(phi) * Math.sin(theta);
        if (isLocal) {
          positionToUpdate.copyFromFloats(randX, Math.abs(randY), randZ);
          return;
        }
        Vector3.TransformCoordinatesFromFloatsToRef(randX, Math.abs(randY), randZ, worldMatrix, positionToUpdate);
      }
      /**
       * Clones the current emitter and returns a copy of it
       * @returns the new emitter
       */
      clone() {
        const newOne = new _HemisphericParticleEmitter(this.radius, this.directionRandomizer);
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
      }
      /**
       * Called by the GPUParticleSystem to setup the update shader
       * @param uboOrEffect defines the update shader
       */
      applyToShader(uboOrEffect) {
        uboOrEffect.setFloat("radius", this.radius);
        uboOrEffect.setFloat("radiusRange", this.radiusRange);
        uboOrEffect.setFloat("directionRandomizer", this.directionRandomizer);
      }
      /**
       * Creates the structure of the ubo for this particle emitter
       * @param ubo ubo to create the structure for
       */
      buildUniformLayout(ubo) {
        ubo.addUniform("radius", 1);
        ubo.addUniform("radiusRange", 1);
        ubo.addUniform("directionRandomizer", 1);
      }
      /**
       * Returns a string to use to update the GPU particles update shader
       * @returns a string containing the defines string
       */
      getEffectDefines() {
        return "#define HEMISPHERICEMITTER";
      }
      /**
       * Returns the string "HemisphericParticleEmitter"
       * @returns a string containing the class name
       */
      getClassName() {
        return "HemisphericParticleEmitter";
      }
      /**
       * Serializes the particle system to a JSON object.
       * @returns the JSON object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.type = this.getClassName();
        serializationObject.radius = this.radius;
        serializationObject.radiusRange = this.radiusRange;
        serializationObject.directionRandomizer = this.directionRandomizer;
        return serializationObject;
      }
      /**
       * Parse properties from a JSON object
       * @param serializationObject defines the JSON object
       */
      parse(serializationObject) {
        this.radius = serializationObject.radius;
        this.radiusRange = serializationObject.radiusRange;
        this.directionRandomizer = serializationObject.directionRandomizer;
      }
    };
  }
});

// node_modules/@babylonjs/core/Particles/EmitterTypes/sphereParticleEmitter.js
var SphereParticleEmitter, SphereDirectedParticleEmitter;
var init_sphereParticleEmitter = __esm({
  "node_modules/@babylonjs/core/Particles/EmitterTypes/sphereParticleEmitter.js"() {
    init_math_vector();
    init_math_scalar_functions();
    init_deepCopier();
    SphereParticleEmitter = class _SphereParticleEmitter {
      /**
       * Creates a new instance SphereParticleEmitter
       * @param radius the radius of the emission sphere (1 by default)
       * @param radiusRange the range of the emission sphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)
       * @param directionRandomizer defines how much to randomize the particle direction [0-1]
       */
      constructor(radius = 1, radiusRange = 1, directionRandomizer = 0) {
        this.radius = radius;
        this.radiusRange = radiusRange;
        this.directionRandomizer = directionRandomizer;
      }
      /**
       * Called by the particle System when the direction is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param directionToUpdate is the direction vector to update with the result
       * @param particle is the particle we are computed the direction for
       * @param isLocal defines if the direction should be set in local space
       */
      startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
        const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();
        const randX = RandomRange(0, this.directionRandomizer);
        const randY = RandomRange(0, this.directionRandomizer);
        const randZ = RandomRange(0, this.directionRandomizer);
        direction.x += randX;
        direction.y += randY;
        direction.z += randZ;
        direction.normalize();
        if (isLocal) {
          directionToUpdate.copyFrom(direction);
          return;
        }
        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);
      }
      /**
       * Called by the particle System when the position is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param positionToUpdate is the position vector to update with the result
       * @param particle is the particle we are computed the position for
       * @param isLocal defines if the position should be set in local space
       */
      startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
        const randRadius = this.radius - RandomRange(0, this.radius * this.radiusRange);
        const v = RandomRange(0, 1);
        const phi = RandomRange(0, 2 * Math.PI);
        const theta = Math.acos(2 * v - 1);
        const randX = randRadius * Math.cos(phi) * Math.sin(theta);
        const randY = randRadius * Math.cos(theta);
        const randZ = randRadius * Math.sin(phi) * Math.sin(theta);
        if (isLocal) {
          positionToUpdate.copyFromFloats(randX, randY, randZ);
          return;
        }
        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
      }
      /**
       * Clones the current emitter and returns a copy of it
       * @returns the new emitter
       */
      clone() {
        const newOne = new _SphereParticleEmitter(this.radius, this.directionRandomizer);
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
      }
      /**
       * Called by the GPUParticleSystem to setup the update shader
       * @param uboOrEffect defines the update shader
       */
      applyToShader(uboOrEffect) {
        uboOrEffect.setFloat("radius", this.radius);
        uboOrEffect.setFloat("radiusRange", this.radiusRange);
        uboOrEffect.setFloat("directionRandomizer", this.directionRandomizer);
      }
      /**
       * Creates the structure of the ubo for this particle emitter
       * @param ubo ubo to create the structure for
       */
      buildUniformLayout(ubo) {
        ubo.addUniform("radius", 1);
        ubo.addUniform("radiusRange", 1);
        ubo.addUniform("directionRandomizer", 1);
      }
      /**
       * Returns a string to use to update the GPU particles update shader
       * @returns a string containing the defines string
       */
      getEffectDefines() {
        return "#define SPHEREEMITTER";
      }
      /**
       * Returns the string "SphereParticleEmitter"
       * @returns a string containing the class name
       */
      getClassName() {
        return "SphereParticleEmitter";
      }
      /**
       * Serializes the particle system to a JSON object.
       * @returns the JSON object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.type = this.getClassName();
        serializationObject.radius = this.radius;
        serializationObject.radiusRange = this.radiusRange;
        serializationObject.directionRandomizer = this.directionRandomizer;
        return serializationObject;
      }
      /**
       * Parse properties from a JSON object
       * @param serializationObject defines the JSON object
       */
      parse(serializationObject) {
        this.radius = serializationObject.radius;
        this.radiusRange = serializationObject.radiusRange;
        this.directionRandomizer = serializationObject.directionRandomizer;
      }
    };
    SphereDirectedParticleEmitter = class _SphereDirectedParticleEmitter extends SphereParticleEmitter {
      /**
       * Creates a new instance SphereDirectedParticleEmitter
       * @param radius the radius of the emission sphere (1 by default)
       * @param direction1 the min limit of the emission direction (up vector by default)
       * @param direction2 the max limit of the emission direction (up vector by default)
       */
      constructor(radius = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
        super(radius);
        this.direction1 = direction1;
        this.direction2 = direction2;
      }
      /**
       * Called by the particle System when the direction is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param directionToUpdate is the direction vector to update with the result
       * @param particle is the particle we are computed the position for
       * @param isLocal defines if the direction should be set in local space
       */
      startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
        const randX = RandomRange(this.direction1.x, this.direction2.x);
        const randY = RandomRange(this.direction1.y, this.direction2.y);
        const randZ = RandomRange(this.direction1.z, this.direction2.z);
        if (isLocal) {
          directionToUpdate.copyFromFloats(randX, randY, randZ);
          return;
        }
        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
      }
      /**
       * Clones the current emitter and returns a copy of it
       * @returns the new emitter
       */
      clone() {
        const newOne = new _SphereDirectedParticleEmitter(this.radius, this.direction1, this.direction2);
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
      }
      /**
       * Called by the GPUParticleSystem to setup the update shader
       * @param uboOrEffect defines the update shader
       */
      applyToShader(uboOrEffect) {
        uboOrEffect.setFloat("radius", this.radius);
        uboOrEffect.setFloat("radiusRange", this.radiusRange);
        uboOrEffect.setVector3("direction1", this.direction1);
        uboOrEffect.setVector3("direction2", this.direction2);
      }
      /**
       * Creates the structure of the ubo for this particle emitter
       * @param ubo ubo to create the structure for
       */
      buildUniformLayout(ubo) {
        ubo.addUniform("radius", 1);
        ubo.addUniform("radiusRange", 1);
        ubo.addUniform("direction1", 3);
        ubo.addUniform("direction2", 3);
      }
      /**
       * Returns a string to use to update the GPU particles update shader
       * @returns a string containing the defines string
       */
      getEffectDefines() {
        return "#define SPHEREEMITTER\n#define DIRECTEDSPHEREEMITTER";
      }
      /**
       * Returns the string "SphereDirectedParticleEmitter"
       * @returns a string containing the class name
       */
      getClassName() {
        return "SphereDirectedParticleEmitter";
      }
      /**
       * Serializes the particle system to a JSON object.
       * @returns the JSON object
       */
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.direction1 = this.direction1.asArray();
        serializationObject.direction2 = this.direction2.asArray();
        return serializationObject;
      }
      /**
       * Parse properties from a JSON object
       * @param serializationObject defines the JSON object
       */
      parse(serializationObject) {
        super.parse(serializationObject);
        this.direction1.copyFrom(serializationObject.direction1);
        this.direction2.copyFrom(serializationObject.direction2);
      }
    };
  }
});

// node_modules/@babylonjs/core/Particles/EmitterTypes/cylinderParticleEmitter.js
var CylinderParticleEmitter, CylinderDirectedParticleEmitter;
var init_cylinderParticleEmitter = __esm({
  "node_modules/@babylonjs/core/Particles/EmitterTypes/cylinderParticleEmitter.js"() {
    init_math_vector();
    init_math_scalar_functions();
    init_deepCopier();
    CylinderParticleEmitter = class _CylinderParticleEmitter {
      /**
       * Creates a new instance CylinderParticleEmitter
       * @param radius the radius of the emission cylinder (1 by default)
       * @param height the height of the emission cylinder (1 by default)
       * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
       * @param directionRandomizer defines how much to randomize the particle direction [0-1]
       */
      constructor(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {
        this.radius = radius;
        this.height = height;
        this.radiusRange = radiusRange;
        this.directionRandomizer = directionRandomizer;
        this._tempVector = Vector3.Zero();
      }
      /**
       * Called by the particle System when the direction is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param directionToUpdate is the direction vector to update with the result
       * @param particle is the particle we are computed the direction for
       * @param isLocal defines if the direction should be set in local space
       * @param inverseWorldMatrix defines the inverted world matrix to use if isLocal is false
       */
      startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal, inverseWorldMatrix) {
        particle.position.subtractToRef(worldMatrix.getTranslation(), this._tempVector);
        this._tempVector.normalize();
        Vector3.TransformNormalToRef(this._tempVector, inverseWorldMatrix, this._tempVector);
        const randY = RandomRange(-this.directionRandomizer / 2, this.directionRandomizer / 2);
        let angle = Math.atan2(this._tempVector.x, this._tempVector.z);
        angle += RandomRange(-Math.PI / 2, Math.PI / 2) * this.directionRandomizer;
        this._tempVector.y = randY;
        this._tempVector.x = Math.sin(angle);
        this._tempVector.z = Math.cos(angle);
        this._tempVector.normalize();
        if (isLocal) {
          directionToUpdate.copyFrom(this._tempVector);
          return;
        }
        Vector3.TransformNormalFromFloatsToRef(this._tempVector.x, this._tempVector.y, this._tempVector.z, worldMatrix, directionToUpdate);
      }
      /**
       * Called by the particle System when the position is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param positionToUpdate is the position vector to update with the result
       * @param particle is the particle we are computed the position for
       * @param isLocal defines if the position should be set in local space
       */
      startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
        const yPos = RandomRange(-this.height / 2, this.height / 2);
        const angle = RandomRange(0, 2 * Math.PI);
        const radiusDistribution = RandomRange((1 - this.radiusRange) * (1 - this.radiusRange), 1);
        const positionRadius = Math.sqrt(radiusDistribution) * this.radius;
        const xPos = positionRadius * Math.cos(angle);
        const zPos = positionRadius * Math.sin(angle);
        if (isLocal) {
          positionToUpdate.copyFromFloats(xPos, yPos, zPos);
          return;
        }
        Vector3.TransformCoordinatesFromFloatsToRef(xPos, yPos, zPos, worldMatrix, positionToUpdate);
      }
      /**
       * Clones the current emitter and returns a copy of it
       * @returns the new emitter
       */
      clone() {
        const newOne = new _CylinderParticleEmitter(this.radius, this.directionRandomizer);
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
      }
      /**
       * Called by the GPUParticleSystem to setup the update shader
       * @param uboOrEffect defines the update shader
       */
      applyToShader(uboOrEffect) {
        uboOrEffect.setFloat("radius", this.radius);
        uboOrEffect.setFloat("height", this.height);
        uboOrEffect.setFloat("radiusRange", this.radiusRange);
        uboOrEffect.setFloat("directionRandomizer", this.directionRandomizer);
      }
      /**
       * Creates the structure of the ubo for this particle emitter
       * @param ubo ubo to create the structure for
       */
      buildUniformLayout(ubo) {
        ubo.addUniform("radius", 1);
        ubo.addUniform("height", 1);
        ubo.addUniform("radiusRange", 1);
        ubo.addUniform("directionRandomizer", 1);
      }
      /**
       * Returns a string to use to update the GPU particles update shader
       * @returns a string containing the defines string
       */
      getEffectDefines() {
        return "#define CYLINDEREMITTER";
      }
      /**
       * Returns the string "CylinderParticleEmitter"
       * @returns a string containing the class name
       */
      getClassName() {
        return "CylinderParticleEmitter";
      }
      /**
       * Serializes the particle system to a JSON object.
       * @returns the JSON object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.type = this.getClassName();
        serializationObject.radius = this.radius;
        serializationObject.height = this.height;
        serializationObject.radiusRange = this.radiusRange;
        serializationObject.directionRandomizer = this.directionRandomizer;
        return serializationObject;
      }
      /**
       * Parse properties from a JSON object
       * @param serializationObject defines the JSON object
       */
      parse(serializationObject) {
        this.radius = serializationObject.radius;
        this.height = serializationObject.height;
        this.radiusRange = serializationObject.radiusRange;
        this.directionRandomizer = serializationObject.directionRandomizer;
      }
    };
    CylinderDirectedParticleEmitter = class _CylinderDirectedParticleEmitter extends CylinderParticleEmitter {
      /**
       * Creates a new instance CylinderDirectedParticleEmitter
       * @param radius the radius of the emission cylinder (1 by default)
       * @param height the height of the emission cylinder (1 by default)
       * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
       * @param direction1 the min limit of the emission direction (up vector by default)
       * @param direction2 the max limit of the emission direction (up vector by default)
       */
      constructor(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
        super(radius, height, radiusRange);
        this.direction1 = direction1;
        this.direction2 = direction2;
      }
      /**
       * Called by the particle System when the direction is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param directionToUpdate is the direction vector to update with the result
       * @param _particle is the particle we are computed the direction for
       * @param isLocal defines if the direction should be set in local space
       */
      startDirectionFunction(worldMatrix, directionToUpdate, _particle, isLocal) {
        const randX = RandomRange(this.direction1.x, this.direction2.x);
        const randY = RandomRange(this.direction1.y, this.direction2.y);
        const randZ = RandomRange(this.direction1.z, this.direction2.z);
        if (isLocal) {
          directionToUpdate.copyFromFloats(randX, randY, randZ);
          return;
        }
        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
      }
      /**
       * Clones the current emitter and returns a copy of it
       * @returns the new emitter
       */
      clone() {
        const newOne = new _CylinderDirectedParticleEmitter(this.radius, this.height, this.radiusRange, this.direction1, this.direction2);
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
      }
      /**
       * Called by the GPUParticleSystem to setup the update shader
       * @param uboOrEffect defines the update shader
       */
      applyToShader(uboOrEffect) {
        uboOrEffect.setFloat("radius", this.radius);
        uboOrEffect.setFloat("height", this.height);
        uboOrEffect.setFloat("radiusRange", this.radiusRange);
        uboOrEffect.setVector3("direction1", this.direction1);
        uboOrEffect.setVector3("direction2", this.direction2);
      }
      /**
       * Creates the structure of the ubo for this particle emitter
       * @param ubo ubo to create the structure for
       */
      buildUniformLayout(ubo) {
        ubo.addUniform("radius", 1);
        ubo.addUniform("height", 1);
        ubo.addUniform("radiusRange", 1);
        ubo.addUniform("direction1", 3);
        ubo.addUniform("direction2", 3);
      }
      /**
       * Returns a string to use to update the GPU particles update shader
       * @returns a string containing the defines string
       */
      getEffectDefines() {
        return "#define CYLINDEREMITTER\n#define DIRECTEDCYLINDEREMITTER";
      }
      /**
       * Returns the string "CylinderDirectedParticleEmitter"
       * @returns a string containing the class name
       */
      getClassName() {
        return "CylinderDirectedParticleEmitter";
      }
      /**
       * Serializes the particle system to a JSON object.
       * @returns the JSON object
       */
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.direction1 = this.direction1.asArray();
        serializationObject.direction2 = this.direction2.asArray();
        return serializationObject;
      }
      /**
       * Parse properties from a JSON object
       * @param serializationObject defines the JSON object
       */
      parse(serializationObject) {
        super.parse(serializationObject);
        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
      }
    };
  }
});

// node_modules/@babylonjs/core/Particles/EmitterTypes/coneParticleEmitter.js
var ConeParticleEmitter, ConeDirectedParticleEmitter;
var init_coneParticleEmitter = __esm({
  "node_modules/@babylonjs/core/Particles/EmitterTypes/coneParticleEmitter.js"() {
    init_deepCopier();
    init_math_vector();
    init_math_scalar_functions();
    ConeParticleEmitter = class _ConeParticleEmitter {
      /**
       * Gets or sets the radius of the emission cone
       */
      get radius() {
        return this._radius;
      }
      set radius(value) {
        this._radius = value;
        this._buildHeight();
      }
      /**
       * Gets or sets the angle of the emission cone
       */
      get angle() {
        return this._angle;
      }
      set angle(value) {
        this._angle = value;
        this._buildHeight();
      }
      _buildHeight() {
        if (this._angle !== 0) {
          this._height = this._radius / Math.tan(this._angle / 2);
        } else {
          this._height = 1;
        }
      }
      /**
       * Creates a new instance ConeParticleEmitter
       * @param radius the radius of the emission cone (1 by default)
       * @param angle the cone base angle (PI by default)
       * @param directionRandomizer defines how much to randomize the particle direction [0-1] (default is 0)
       */
      constructor(radius = 1, angle = Math.PI, directionRandomizer = 0) {
        this.directionRandomizer = directionRandomizer;
        this.radiusRange = 1;
        this.heightRange = 1;
        this.emitFromSpawnPointOnly = false;
        this.angle = angle;
        this.radius = radius;
      }
      /**
       * Called by the particle System when the direction is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param directionToUpdate is the direction vector to update with the result
       * @param particle is the particle we are computed the direction for
       * @param isLocal defines if the direction should be set in local space
       */
      startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
        const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();
        const randX = RandomRange(0, this.directionRandomizer);
        const randY = RandomRange(0, this.directionRandomizer);
        const randZ = RandomRange(0, this.directionRandomizer);
        direction.x += randX;
        direction.y += randY;
        direction.z += randZ;
        direction.normalize();
        if (isLocal) {
          directionToUpdate.copyFrom(direction);
          return;
        }
        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);
      }
      /**
       * Called by the particle System when the position is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param positionToUpdate is the position vector to update with the result
       * @param particle is the particle we are computed the position for
       * @param isLocal defines if the position should be set in local space
       */
      startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {
        const s = RandomRange(0, Math.PI * 2);
        let h;
        if (!this.emitFromSpawnPointOnly) {
          h = RandomRange(0, this.heightRange);
          h = 1 - h * h;
        } else {
          h = 1e-4;
        }
        let radius = this._radius - RandomRange(0, this._radius * this.radiusRange);
        radius = radius * h;
        const randX = radius * Math.sin(s);
        const randZ = radius * Math.cos(s);
        const randY = h * this._height;
        if (isLocal) {
          positionToUpdate.x = randX;
          positionToUpdate.y = randY;
          positionToUpdate.z = randZ;
          return;
        }
        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
      }
      /**
       * Clones the current emitter and returns a copy of it
       * @returns the new emitter
       */
      clone() {
        const newOne = new _ConeParticleEmitter(this._radius, this._angle, this.directionRandomizer);
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
      }
      /**
       * Called by the GPUParticleSystem to setup the update shader
       * @param uboOrEffect defines the update shader
       */
      applyToShader(uboOrEffect) {
        uboOrEffect.setFloat2("radius", this._radius, this.radiusRange);
        uboOrEffect.setFloat("coneAngle", this._angle);
        uboOrEffect.setFloat2("height", this._height, this.heightRange);
        uboOrEffect.setFloat("directionRandomizer", this.directionRandomizer);
      }
      /**
       * Creates the structure of the ubo for this particle emitter
       * @param ubo ubo to create the structure for
       */
      buildUniformLayout(ubo) {
        ubo.addUniform("radius", 2);
        ubo.addUniform("coneAngle", 1);
        ubo.addUniform("height", 2);
        ubo.addUniform("directionRandomizer", 1);
      }
      /**
       * Returns a string to use to update the GPU particles update shader
       * @returns a string containing the defines string
       */
      getEffectDefines() {
        let defines = "#define CONEEMITTER";
        if (this.emitFromSpawnPointOnly) {
          defines += "\n#define CONEEMITTERSPAWNPOINT";
        }
        return defines;
      }
      /**
       * Returns the string "ConeParticleEmitter"
       * @returns a string containing the class name
       */
      getClassName() {
        return "ConeParticleEmitter";
      }
      /**
       * Serializes the particle system to a JSON object.
       * @returns the JSON object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.type = this.getClassName();
        serializationObject.radius = this._radius;
        serializationObject.angle = this._angle;
        serializationObject.directionRandomizer = this.directionRandomizer;
        serializationObject.radiusRange = this.radiusRange;
        serializationObject.heightRange = this.heightRange;
        serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;
        return serializationObject;
      }
      /**
       * Parse properties from a JSON object
       * @param serializationObject defines the JSON object
       */
      parse(serializationObject) {
        this.radius = serializationObject.radius;
        this.angle = serializationObject.angle;
        this.directionRandomizer = serializationObject.directionRandomizer;
        this.radiusRange = serializationObject.radiusRange !== void 0 ? serializationObject.radiusRange : 1;
        this.heightRange = serializationObject.radiusRange !== void 0 ? serializationObject.heightRange : 1;
        this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly !== void 0 ? serializationObject.emitFromSpawnPointOnly : false;
      }
    };
    ConeDirectedParticleEmitter = class _ConeDirectedParticleEmitter extends ConeParticleEmitter {
      constructor(radius = 1, angle = Math.PI, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
        super(radius, angle);
        this.direction1 = direction1;
        this.direction2 = direction2;
      }
      /**
       * Called by the particle System when the direction is computed for the created particle.
       * @param worldMatrix is the world matrix of the particle system
       * @param directionToUpdate is the direction vector to update with the result
       * @param particle is the particle we are computed the position for
       * @param isLocal defines if the direction should be set in local space
       */
      startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {
        const randX = RandomRange(this.direction1.x, this.direction2.x);
        const randY = RandomRange(this.direction1.y, this.direction2.y);
        const randZ = RandomRange(this.direction1.z, this.direction2.z);
        if (isLocal) {
          directionToUpdate.copyFromFloats(randX, randY, randZ);
          return;
        }
        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
      }
      /**
       * Clones the current emitter and returns a copy of it
       * @returns the new emitter
       */
      clone() {
        const newOne = new _ConeDirectedParticleEmitter(this.radius, this.angle, this.direction1, this.direction2);
        DeepCopier.DeepCopy(this, newOne);
        return newOne;
      }
      /**
       * Called by the GPUParticleSystem to setup the update shader
       * @param uboOrEffect defines the update shader
       */
      applyToShader(uboOrEffect) {
        uboOrEffect.setFloat("radius", this.radius);
        uboOrEffect.setFloat("radiusRange", this.radiusRange);
        uboOrEffect.setVector3("direction1", this.direction1);
        uboOrEffect.setVector3("direction2", this.direction2);
      }
      /**
       * Creates the structure of the ubo for this particle emitter
       * @param ubo ubo to create the structure for
       */
      buildUniformLayout(ubo) {
        ubo.addUniform("radius", 1);
        ubo.addUniform("radiusRange", 1);
        ubo.addUniform("direction1", 3);
        ubo.addUniform("direction2", 3);
      }
      /**
       * Returns a string to use to update the GPU particles update shader
       * @returns a string containing the defines string
       */
      getEffectDefines() {
        return "#define CONEEMITTER\n#define DIRECTEDCONEEMITTER";
      }
      /**
       * Returns the string "ConeDirectedParticleEmitter"
       * @returns a string containing the class name
       */
      getClassName() {
        return "ConeDirectedParticleEmitter";
      }
      /**
       * Serializes the particle system to a JSON object.
       * @returns the JSON object
       */
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.direction1 = this.direction1.asArray();
        serializationObject.direction2 = this.direction2.asArray();
        return serializationObject;
      }
      /**
       * Parse properties from a JSON object
       * @param serializationObject defines the JSON object
       */
      parse(serializationObject) {
        super.parse(serializationObject);
        this.direction1.copyFrom(serializationObject.direction1);
        this.direction2.copyFrom(serializationObject.direction2);
      }
    };
  }
});

// node_modules/@babylonjs/core/Particles/attractor.js
var ToAttractor, Force, ScaledForce, Attractor;
var init_attractor = __esm({
  "node_modules/@babylonjs/core/Particles/attractor.js"() {
    init_math_vector();
    ToAttractor = Vector3.Zero();
    Force = Vector3.Zero();
    ScaledForce = Vector3.Zero();
    Attractor = class {
      constructor() {
        this.strength = 0;
        this.position = Vector3.Zero();
      }
      /** @internal */
      _processParticle(particle, system) {
        this.position.subtractToRef(particle.position, ToAttractor);
        const distanceSquared = ToAttractor.lengthSquared() + 1;
        ToAttractor.normalize().scaleToRef(this.strength / distanceSquared, Force);
        Force.scaleToRef(system._tempScaledUpdateSpeed, ScaledForce);
        particle.direction.addInPlace(ScaledForce);
      }
      /**
       * Serializes the attractor to a JSON object.
       * @returns The serialized JSON object.
       */
      serialize() {
        return {
          position: this.position.asArray(),
          strength: this.strength
        };
      }
    };
  }
});

// node_modules/@babylonjs/core/Particles/thinParticleSystem.function.js
function _CreateColorData(particle, system) {
  const step = RandomRange(0, 1);
  Color4.LerpToRef(system.color1, system.color2, step, particle.color);
}
function _CreateColorDeadData(particle, system) {
  system.colorDead.subtractToRef(particle.color, system._colorDiff);
  system._colorDiff.scaleToRef(1 / particle.lifeTime, particle.colorStep);
}
function _CreateColorGradientsData(particle, system) {
  particle._currentColorGradient = system._colorGradients[0];
  particle._currentColorGradient.getColorToRef(particle.color);
  particle._currentColor1.copyFrom(particle.color);
  if (system._colorGradients.length > 1) {
    system._colorGradients[1].getColorToRef(particle._currentColor2);
  } else {
    particle._currentColor2.copyFrom(particle.color);
  }
}
function _ProcessColorGradients(particle, system) {
  const colorGradients = system._colorGradients;
  GradientHelper.GetCurrentGradient(system._ratio, colorGradients, (currentGradient, nextGradient, scale) => {
    if (currentGradient !== particle._currentColorGradient) {
      particle._currentColor1.copyFrom(particle._currentColor2);
      nextGradient.getColorToRef(particle._currentColor2);
      particle._currentColorGradient = currentGradient;
    }
    Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);
    if (particle.color.a < 0) {
      particle.color.a = 0;
    }
  });
}
function _ProcessColor(particle, system) {
  particle.colorStep.scaleToRef(system._scaledUpdateSpeed, system._scaledColorStep);
  particle.color.addInPlace(system._scaledColorStep);
  if (particle.color.a < 0) {
    particle.color.a = 0;
  }
}
function _ProcessAngularSpeedGradients(particle, system) {
  GradientHelper.GetCurrentGradient(system._ratio, system._angularSpeedGradients, (currentGradient, nextGradient, scale) => {
    if (currentGradient !== particle._currentAngularSpeedGradient) {
      particle._currentAngularSpeed1 = particle._currentAngularSpeed2;
      particle._currentAngularSpeed2 = nextGradient.getFactor();
      particle._currentAngularSpeedGradient = currentGradient;
    }
    particle.angularSpeed = Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);
  });
}
function _ProcessAngularSpeed(particle, system) {
  particle.angle += particle.angularSpeed * system._scaledUpdateSpeed;
}
function _CreateDirectionData(particle, system) {
  system.particleEmitterType.startDirectionFunction(system._emitterWorldMatrix, particle.direction, particle, system.isLocal, system._emitterInverseWorldMatrix);
}
function _CreateCustomDirectionData(particle, system) {
  system.startDirectionFunction(system._emitterWorldMatrix, particle.direction, particle, system.isLocal);
}
function _CreateVelocityGradients(particle, system) {
  particle._currentVelocityGradient = system._velocityGradients[0];
  particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();
  if (system._velocityGradients.length > 1) {
    particle._currentVelocity2 = system._velocityGradients[1].getFactor();
  } else {
    particle._currentVelocity2 = particle._currentVelocity1;
  }
}
function _CreateLimitVelocityGradients(particle, system) {
  particle._currentLimitVelocityGradient = system._limitVelocityGradients[0];
  particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();
  if (system._limitVelocityGradients.length > 1) {
    particle._currentLimitVelocity2 = system._limitVelocityGradients[1].getFactor();
  } else {
    particle._currentLimitVelocity2 = particle._currentLimitVelocity1;
  }
}
function _ProcessVelocityGradients(particle, system) {
  GradientHelper.GetCurrentGradient(system._ratio, system._velocityGradients, (currentGradient, nextGradient, scale) => {
    if (currentGradient !== particle._currentVelocityGradient) {
      particle._currentVelocity1 = particle._currentVelocity2;
      particle._currentVelocity2 = nextGradient.getFactor();
      particle._currentVelocityGradient = currentGradient;
    }
    particle._directionScale *= Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);
  });
}
function _ProcessLimitVelocityGradients(particle, system) {
  GradientHelper.GetCurrentGradient(system._ratio, system._limitVelocityGradients, (currentGradient, nextGradient, scale) => {
    if (currentGradient !== particle._currentLimitVelocityGradient) {
      particle._currentLimitVelocity1 = particle._currentLimitVelocity2;
      particle._currentLimitVelocity2 = nextGradient.getFactor();
      particle._currentLimitVelocityGradient = currentGradient;
    }
    const limitVelocity = Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);
    const currentVelocity = particle.direction.length();
    if (currentVelocity > limitVelocity) {
      particle.direction.scaleInPlace(system.limitVelocityDamping);
    }
  });
}
function _ProcessDirection(particle) {
  particle.direction.scaleToRef(particle._directionScale, particle._scaledDirection);
}
function _CreatePositionData(particle, system) {
  system.particleEmitterType.startPositionFunction(system._emitterWorldMatrix, particle.position, particle, system.isLocal);
}
function _CreateCustomPositionData(particle, system) {
  system.startPositionFunction(system._emitterWorldMatrix, particle.position, particle, system.isLocal);
}
function _CreateIsLocalData(particle, system) {
  if (!particle._localPosition) {
    particle._localPosition = particle.position.clone();
  } else {
    particle._localPosition.copyFrom(particle.position);
  }
  Vector3.TransformCoordinatesToRef(particle._localPosition, system._emitterWorldMatrix, particle.position);
}
function _ProcessPosition(particle, system) {
  if (system.isLocal && particle._localPosition) {
    particle._localPosition.addInPlace(particle._scaledDirection);
    Vector3.TransformCoordinatesToRef(particle._localPosition, system._emitterWorldMatrix, particle.position);
  } else {
    particle.position.addInPlace(particle._scaledDirection);
  }
}
function _CreateDragData(particle, system) {
  particle._currentDragGradient = system._dragGradients[0];
  particle._currentDrag1 = particle._currentDragGradient.getFactor();
  if (system._dragGradients.length > 1) {
    particle._currentDrag2 = system._dragGradients[1].getFactor();
  } else {
    particle._currentDrag2 = particle._currentDrag1;
  }
}
function _ProcessDragGradients(particle, system) {
  GradientHelper.GetCurrentGradient(system._ratio, system._dragGradients, (currentGradient, nextGradient, scale) => {
    if (currentGradient !== particle._currentDragGradient) {
      particle._currentDrag1 = particle._currentDrag2;
      particle._currentDrag2 = nextGradient.getFactor();
      particle._currentDragGradient = currentGradient;
    }
    const drag = Lerp(particle._currentDrag1, particle._currentDrag2, scale);
    particle._scaledDirection.scaleInPlace(1 - drag);
  });
}
function _CreateNoiseData(particle, _system) {
  if (particle._randomNoiseCoordinates1 && particle._randomNoiseCoordinates2) {
    particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());
    particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());
  } else {
    particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());
    particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());
  }
}
function _ProcessNoise(particle, system) {
  const noiseTextureData = system._noiseTextureData;
  const noiseTextureSize = system._noiseTextureSize;
  if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1 && particle._randomNoiseCoordinates2) {
    const fetchedColorR = system._fetchR(particle._randomNoiseCoordinates1.x, particle._randomNoiseCoordinates1.y, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
    const fetchedColorG = system._fetchR(particle._randomNoiseCoordinates1.z, particle._randomNoiseCoordinates2.x, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
    const fetchedColorB = system._fetchR(particle._randomNoiseCoordinates2.y, particle._randomNoiseCoordinates2.z, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
    const force = TmpVectors.Vector3[0];
    const scaledForce = TmpVectors.Vector3[1];
    force.copyFromFloats((2 * fetchedColorR - 1) * system.noiseStrength.x, (2 * fetchedColorG - 1) * system.noiseStrength.y, (2 * fetchedColorB - 1) * system.noiseStrength.z);
    force.scaleToRef(system._tempScaledUpdateSpeed, scaledForce);
    particle.direction.addInPlace(scaledForce);
  }
}
function _ProcessGravity(particle, system) {
  system.gravity.scaleToRef(system._tempScaledUpdateSpeed, system._scaledGravity);
  particle.direction.addInPlace(system._scaledGravity);
}
function _CreateSizeData(particle, system) {
  particle.size = RandomRange(system.minSize, system.maxSize);
  particle.scale.copyFromFloats(RandomRange(system.minScaleX, system.maxScaleX), RandomRange(system.minScaleY, system.maxScaleY));
}
function _CreateSizeGradientsData(particle, system) {
  particle._currentSizeGradient = system._sizeGradients[0];
  particle._currentSize1 = particle._currentSizeGradient.getFactor();
  particle.size = particle._currentSize1;
  if (system._sizeGradients.length > 1) {
    particle._currentSize2 = system._sizeGradients[1].getFactor();
  } else {
    particle._currentSize2 = particle._currentSize1;
  }
  particle.scale.copyFromFloats(RandomRange(system.minScaleX, system.maxScaleX), RandomRange(system.minScaleY, system.maxScaleY));
}
function _CreateStartSizeGradientsData(particle, system) {
  const ratio = system._actualFrame / system.targetStopDuration;
  GradientHelper.GetCurrentGradient(ratio, system._startSizeGradients, (currentGradient, nextGradient, scale) => {
    if (currentGradient !== system._currentStartSizeGradient) {
      system._currentStartSize1 = system._currentStartSize2;
      system._currentStartSize2 = nextGradient.getFactor();
      system._currentStartSizeGradient = currentGradient;
    }
    const value = Lerp(system._currentStartSize1, system._currentStartSize2, scale);
    particle.scale.scaleInPlace(value);
  });
}
function _ProcessSizeGradients(particle, system) {
  GradientHelper.GetCurrentGradient(system._ratio, system._sizeGradients, (currentGradient, nextGradient, scale) => {
    if (currentGradient !== particle._currentSizeGradient) {
      particle._currentSize1 = particle._currentSize2;
      particle._currentSize2 = nextGradient.getFactor();
      particle._currentSizeGradient = currentGradient;
    }
    particle.size = Lerp(particle._currentSize1, particle._currentSize2, scale);
  });
}
function _CreateRampData(particle, _system) {
  particle.remapData = new Vector4(0, 1, 0, 1);
}
function _ProcessRemapGradients(particle, system) {
  if (system._colorRemapGradients && system._colorRemapGradients.length > 0) {
    GradientHelper.GetCurrentGradient(system._ratio, system._colorRemapGradients, (currentGradient, nextGradient, scale) => {
      const min = Lerp(currentGradient.factor1, nextGradient.factor1, scale);
      const max = Lerp(currentGradient.factor2, nextGradient.factor2, scale);
      particle.remapData.x = min;
      particle.remapData.y = max - min;
    });
  }
  if (system._alphaRemapGradients && system._alphaRemapGradients.length > 0) {
    GradientHelper.GetCurrentGradient(system._ratio, system._alphaRemapGradients, (currentGradient, nextGradient, scale) => {
      const min = Lerp(currentGradient.factor1, nextGradient.factor1, scale);
      const max = Lerp(currentGradient.factor2, nextGradient.factor2, scale);
      particle.remapData.z = min;
      particle.remapData.w = max - min;
    });
  }
}
function _CreateLifeGradientsData(particle, system) {
  const ratio = Clamp(system._actualFrame / system.targetStopDuration);
  GradientHelper.GetCurrentGradient(ratio, system._lifeTimeGradients, (currentGradient, nextGradient) => {
    const factorGradient1 = currentGradient;
    const factorGradient2 = nextGradient;
    const lifeTime1 = factorGradient1.getFactor();
    const lifeTime2 = factorGradient2.getFactor();
    const gradient = (ratio - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);
    particle.lifeTime = Lerp(lifeTime1, lifeTime2, gradient);
  });
  system._emitPower = RandomRange(system.minEmitPower, system.maxEmitPower);
}
function _CreateLifetimeData(particle, system) {
  particle.lifeTime = RandomRange(system.minLifeTime, system.maxLifeTime);
  system._emitPower = RandomRange(system.minEmitPower, system.maxEmitPower);
}
function _CreateEmitPowerData(particle, system) {
  if (system._emitPower === 0) {
    if (!particle._initialDirection) {
      particle._initialDirection = particle.direction.clone();
    } else {
      particle._initialDirection.copyFrom(particle.direction);
    }
    particle.direction.set(0, 0, 0);
  } else {
    particle._initialDirection = null;
    particle.direction.scaleInPlace(system._emitPower);
  }
  particle.direction.addInPlace(system._inheritedVelocityOffset);
}
function _CreateAngleData(particle, system) {
  particle.angularSpeed = RandomRange(system.minAngularSpeed, system.maxAngularSpeed);
  particle.angle = RandomRange(system.minInitialRotation, system.maxInitialRotation);
}
function _CreateAngleGradientsData(particle, system) {
  particle._currentAngularSpeedGradient = system._angularSpeedGradients[0];
  particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();
  particle._currentAngularSpeed1 = particle.angularSpeed;
  if (system._angularSpeedGradients.length > 1) {
    particle._currentAngularSpeed2 = system._angularSpeedGradients[1].getFactor();
  } else {
    particle._currentAngularSpeed2 = particle._currentAngularSpeed1;
  }
  particle.angle = RandomRange(system.minInitialRotation, system.maxInitialRotation);
}
function _CreateSheetData(particle, system) {
  particle._initialStartSpriteCellId = system.startSpriteCellID;
  particle._initialEndSpriteCellId = system.endSpriteCellID;
  particle._initialSpriteCellLoop = system.spriteCellLoop;
}
var init_thinParticleSystem_function = __esm({
  "node_modules/@babylonjs/core/Particles/thinParticleSystem.function.js"() {
    init_math_color();
    init_gradients();
    init_math_scalar_functions();
    init_math_vector();
  }
});

// node_modules/@babylonjs/core/Particles/Queue/executionQueue.js
function _ConnectBefore(newOne, activeOne) {
  newOne.previousItem = activeOne.previousItem;
  newOne.nextItem = activeOne;
  if (activeOne.previousItem) {
    activeOne.previousItem.nextItem = newOne;
  }
  activeOne.previousItem = newOne;
}
function _ConnectAfter(newOne, activeOne) {
  newOne.previousItem = activeOne;
  newOne.nextItem = activeOne.nextItem;
  if (activeOne.nextItem) {
    activeOne.nextItem.previousItem = newOne;
  }
  activeOne.nextItem = newOne;
}
function _ConnectAtTheEnd(newOne, root) {
  let activeOne = root;
  while (activeOne.nextItem) {
    activeOne = activeOne.nextItem;
  }
  newOne.previousItem = activeOne;
  newOne.nextItem = activeOne.nextItem;
  activeOne.nextItem = newOne;
}
function _RemoveFromQueue(item) {
  if (item.previousItem) {
    item.previousItem.nextItem = item.nextItem;
  }
  if (item.nextItem) {
    item.nextItem.previousItem = item.previousItem;
  }
}
var init_executionQueue = __esm({
  "node_modules/@babylonjs/core/Particles/Queue/executionQueue.js"() {
  }
});

// node_modules/@babylonjs/core/Particles/thinParticleSystem.js
var ThinParticleSystem;
var init_thinParticleSystem = __esm({
  "node_modules/@babylonjs/core/Particles/thinParticleSystem.js"() {
    init_gradients();
    init_observable();
    init_math_vector();
    init_buffer();
    init_rawTexture();
    init_engineStore();
    init_baseParticleSystem();
    init_particle();
    init_drawWrapper();
    init_math_color();
    init_engine_alpha();
    init_clipPlaneMaterialHelper();
    init_materialHelper_functions();
    init_boxParticleEmitter();
    init_math_scalar_functions();
    init_imageProcessingConfiguration_functions();
    init_thinParticleSystem_function();
    init_executionQueue();
    ThinParticleSystem = class _ThinParticleSystem extends BaseParticleSystem {
      /**
       * This function can be defined to specify initial direction for every new particle.
       * It by default use the emitterType defined function
       */
      get startDirectionFunction() {
        return this._startDirectionFunction;
      }
      set startDirectionFunction(value) {
        if (this._startDirectionFunction === value) {
          return;
        }
        this._startDirectionFunction = value;
        if (value) {
          this._directionProcessing.process = _CreateCustomDirectionData;
        } else {
          this._directionProcessing.process = _CreateDirectionData;
        }
      }
      /**
       * This function can be defined to specify initial position for every new particle.
       * It by default use the emitterType defined function
       */
      get startPositionFunction() {
        return this._startPositionFunction;
      }
      set startPositionFunction(value) {
        if (this._startPositionFunction === value) {
          return;
        }
        this._startPositionFunction = value;
        if (value) {
          this._positionCreation.process = _CreateCustomPositionData;
        } else {
          this._positionCreation.process = _CreatePositionData;
        }
      }
      /**
       * Sets a callback that will be triggered when the system is disposed
       */
      set onDispose(callback) {
        if (this._onDisposeObserver) {
          this.onDisposeObservable.remove(this._onDisposeObserver);
        }
        this._onDisposeObserver = this.onDisposeObservable.add(callback);
      }
      /**
       * Gets a boolean indicating that the particle system was disposed
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /** Gets or sets a boolean indicating that ramp gradients must be used
       * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro#ramp-gradients
       */
      get useRampGradients() {
        return this._useRampGradients;
      }
      set useRampGradients(value) {
        if (this._useRampGradients === value) {
          return;
        }
        this._useRampGradients = value;
        this._resetEffect();
        if (value) {
          this._rampCreation = {
            process: _CreateRampData,
            previousItem: null,
            nextItem: null
          };
          _ConnectAfter(this._rampCreation, this._colorDeadCreation);
          if (this._gravityProcessing) {
            this._remapGradientProcessing = {
              process: _ProcessRemapGradients,
              previousItem: null,
              nextItem: null
            };
            _ConnectAfter(this._remapGradientProcessing, this._gravityProcessing);
          }
        } else {
          _RemoveFromQueue(this._rampCreation);
          _RemoveFromQueue(this._remapGradientProcessing);
        }
      }
      /**
       * Specifies if the particles are updated in emitter local space or world space
       */
      get isLocal() {
        return this._isLocal;
      }
      set isLocal(value) {
        if (this._isLocal === value) {
          return;
        }
        this._isLocal = value;
        if (value) {
          this._isLocalCreation = {
            process: _CreateIsLocalData,
            previousItem: null,
            nextItem: null
          };
          _ConnectAfter(this._isLocalCreation, this._positionCreation);
        } else {
          _RemoveFromQueue(this._isLocalCreation);
        }
      }
      /**
       * Gets the current list of active particles
       */
      get particles() {
        return this._particles;
      }
      /**
       * Gets the shader language used in this material.
       */
      get shaderLanguage() {
        return this._shaderLanguage;
      }
      /** @internal */
      get _isAnimationSheetEnabled() {
        return this._animationSheetEnabled;
      }
      set _isAnimationSheetEnabled(value) {
        if (this._animationSheetEnabled === value) {
          return;
        }
        this._animationSheetEnabled = value;
        if (value) {
          this._sheetCreation = {
            process: _CreateSheetData,
            previousItem: null,
            nextItem: null
          };
          _ConnectAfter(this._sheetCreation, this._colorDeadCreation);
        } else {
          _RemoveFromQueue(this._sheetCreation);
        }
        this._reset();
      }
      /**
       * Gets the number of particles active at the same time.
       * @returns The number of active particles.
       */
      getActiveCount() {
        return this._particles.length;
      }
      /**
       * Returns the string "ParticleSystem"
       * @returns a string containing the class name
       */
      getClassName() {
        return "ParticleSystem";
      }
      /**
       * Gets a boolean indicating that the system is stopping
       * @returns true if the system is currently stopping
       */
      isStopping() {
        return this._stopped && this.isAlive();
      }
      /**
       * Gets the custom effect used to render the particles
       * @param blendMode Blend mode for which the effect should be retrieved
       * @returns The effect
       */
      getCustomEffect(blendMode = 0) {
        return this._customWrappers[blendMode]?.effect ?? this._customWrappers[0].effect;
      }
      _getCustomDrawWrapper(blendMode = 0) {
        return this._customWrappers[blendMode] ?? this._customWrappers[0];
      }
      /**
       * Sets the custom effect used to render the particles
       * @param effect The effect to set
       * @param blendMode Blend mode for which the effect should be set
       */
      setCustomEffect(effect, blendMode = 0) {
        this._customWrappers[blendMode] = new DrawWrapper(this._engine);
        this._customWrappers[blendMode].effect = effect;
        if (this._customWrappers[blendMode].drawContext) {
          this._customWrappers[blendMode].drawContext.useInstancing = this._useInstancing;
        }
      }
      /**
       * Observable that will be called just before the particles are drawn
       */
      get onBeforeDrawParticlesObservable() {
        if (!this._onBeforeDrawParticlesObservable) {
          this._onBeforeDrawParticlesObservable = new Observable();
        }
        return this._onBeforeDrawParticlesObservable;
      }
      /**
       * Gets the name of the particle vertex shader
       */
      get vertexShaderName() {
        return "particles";
      }
      /**
       * Gets the vertex buffers used by the particle system
       */
      get vertexBuffers() {
        return this._vertexBuffers;
      }
      /**
       * Gets the index buffer used by the particle system (or null if no index buffer is used (if _useInstancing=true))
       */
      get indexBuffer() {
        return this._indexBuffer;
      }
      /**
       * Gets or sets a texture used to add random noise to particle positions
       */
      get noiseTexture() {
        return this._noiseTexture;
      }
      set noiseTexture(value) {
        if (this.noiseTexture === value) {
          return;
        }
        this._noiseTexture = value;
        if (!value) {
          _RemoveFromQueue(this._noiseCreation);
          _RemoveFromQueue(this._noiseProcessing);
          return;
        }
        this._noiseCreation = {
          process: _CreateNoiseData,
          previousItem: null,
          nextItem: null
        };
        _ConnectAfter(this._noiseCreation, this._colorDeadCreation);
        this._noiseProcessing = {
          process: _ProcessNoise,
          previousItem: null,
          nextItem: null
        };
        _ConnectAfter(this._noiseProcessing, this._positionProcessing);
      }
      /**
       * Instantiates a particle system.
       * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
       * @param name The name of the particle system
       * @param capacity The max number of particles alive at the same time
       * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene
       * @param customEffect a custom effect used to change the way particles are rendered by default
       * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture
       * @param epsilon Offset used to render the particles
       * @param noUpdateQueue If true, the particle system will start with an empty update queue
       */
      constructor(name13, capacity, sceneOrEngine, customEffect = null, isAnimationSheetEnabled = false, epsilon = 0.01, noUpdateQueue = false) {
        super(name13);
        this._emitterInverseWorldMatrix = Matrix.Identity();
        this._startDirectionFunction = null;
        this._startPositionFunction = null;
        this._inheritedVelocityOffset = new Vector3();
        this.onDisposeObservable = new Observable();
        this.onStoppedObservable = new Observable();
        this.onStartedObservable = new Observable();
        this._noiseTextureSize = null;
        this._noiseTextureData = null;
        this._particles = new Array();
        this._stockParticles = new Array();
        this._newPartsExcess = 0;
        this._vertexBuffers = {};
        this._scaledColorStep = new Color4(0, 0, 0, 0);
        this._colorDiff = new Color4(0, 0, 0, 0);
        this._scaledGravity = Vector3.Zero();
        this._currentRenderId = -1;
        this._useInstancing = false;
        this._isDisposed = false;
        this._started = false;
        this._stopped = false;
        this._actualFrame = 0;
        this._currentEmitRate1 = 0;
        this._currentEmitRate2 = 0;
        this._currentStartSize1 = 0;
        this._currentStartSize2 = 0;
        this.updateInAnimate = true;
        this._rawTextureWidth = 256;
        this._useRampGradients = false;
        this._updateQueueStart = null;
        this._startSizeCreation = null;
        this._createQueueStart = null;
        this._isLocal = false;
        this.isGPU = false;
        this._shaderLanguage = 0;
        this._onBeforeDrawParticlesObservable = null;
        this._emitFromParticle = (_particle) => {
        };
        this.recycleParticle = (particle) => {
          const lastParticle = this._particles.pop();
          if (lastParticle !== particle) {
            lastParticle.copyTo(particle);
          }
          this._stockParticles.push(lastParticle);
        };
        this._createParticle = () => {
          let particle;
          if (this._stockParticles.length !== 0) {
            particle = this._stockParticles.pop();
            particle._reset();
          } else {
            particle = new Particle(this);
          }
          this._prepareParticle(particle);
          return particle;
        };
        this.paused = false;
        this._shadersLoaded = false;
        this._capacity = capacity;
        this._epsilon = epsilon;
        if (!sceneOrEngine || sceneOrEngine.getClassName() === "Scene") {
          this._scene = sceneOrEngine || EngineStore.LastCreatedScene;
          this._engine = this._scene.getEngine();
          this.uniqueId = this._scene.getUniqueId();
          this._scene.particleSystems.push(this);
        } else {
          this._engine = sceneOrEngine;
          this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);
        }
        if (this._engine.getCaps().vertexArrayObject) {
          this._vertexArrayObject = null;
        }
        this._initShaderSourceAsync();
        this._lifeTimeCreation = {
          process: _CreateLifetimeData,
          previousItem: null,
          nextItem: null
        };
        this._positionCreation = {
          process: _CreatePositionData,
          previousItem: null,
          nextItem: null
        };
        _ConnectAfter(this._positionCreation, this._lifeTimeCreation);
        this._directionCreation = {
          process: _CreateDirectionData,
          previousItem: null,
          nextItem: null
        };
        _ConnectAfter(this._directionCreation, this._positionCreation);
        this._emitPowerCreation = {
          process: _CreateEmitPowerData,
          previousItem: null,
          nextItem: null
        };
        _ConnectAfter(this._emitPowerCreation, this._directionCreation);
        this._sizeCreation = {
          process: _CreateSizeData,
          previousItem: null,
          nextItem: null
        };
        _ConnectAfter(this._sizeCreation, this._emitPowerCreation);
        this._angleCreation = {
          process: _CreateAngleData,
          previousItem: null,
          nextItem: null
        };
        _ConnectAfter(this._angleCreation, this._sizeCreation);
        this._colorCreation = {
          process: _CreateColorData,
          previousItem: null,
          nextItem: null
        };
        _ConnectAfter(this._colorCreation, this._angleCreation);
        this._colorDeadCreation = {
          process: _CreateColorDeadData,
          previousItem: null,
          nextItem: null
        };
        _ConnectAfter(this._colorDeadCreation, this._colorCreation);
        this._createQueueStart = this._lifeTimeCreation;
        if (!noUpdateQueue) {
          this._colorProcessing = {
            process: _ProcessColor,
            previousItem: null,
            nextItem: null
          };
          this._angularSpeedProcessing = {
            process: _ProcessAngularSpeed,
            previousItem: null,
            nextItem: null
          };
          _ConnectAfter(this._angularSpeedProcessing, this._colorProcessing);
          this._directionProcessing = {
            process: _ProcessDirection,
            previousItem: null,
            nextItem: null
          };
          _ConnectAfter(this._directionProcessing, this._angularSpeedProcessing);
          this._positionProcessing = {
            process: _ProcessPosition,
            previousItem: null,
            nextItem: null
          };
          _ConnectAfter(this._positionProcessing, this._directionProcessing);
          this._gravityProcessing = {
            process: _ProcessGravity,
            previousItem: null,
            nextItem: null
          };
          _ConnectAfter(this._gravityProcessing, this._positionProcessing);
          this._updateQueueStart = this._colorProcessing;
        }
        this._isAnimationSheetEnabled = isAnimationSheetEnabled;
        this._attachImageProcessingConfiguration(null);
        this._customWrappers = { 0: new DrawWrapper(this._engine) };
        this._customWrappers[0].effect = customEffect;
        this._drawWrappers = [];
        this._useInstancing = this._engine.getCaps().instancedArrays;
        this._createIndexBuffer();
        this._createVertexBuffers();
        this.particleEmitterType = new BoxParticleEmitter();
        this.updateFunction = (particles) => {
          if (this.noiseTexture) {
            this._noiseTextureSize = this.noiseTexture.getSize();
            this.noiseTexture.getContent()?.then((data) => {
              this._noiseTextureData = data;
            });
          }
          const sameParticleArray = particles === this._particles;
          for (let index = 0; index < particles.length; index++) {
            const particle = particles[index];
            this._tempScaledUpdateSpeed = this._scaledUpdateSpeed;
            const previousAge = particle.age;
            particle.age += this._tempScaledUpdateSpeed;
            if (particle.age > particle.lifeTime) {
              const diff = particle.age - previousAge;
              const oldDiff = particle.lifeTime - previousAge;
              this._tempScaledUpdateSpeed = oldDiff * this._tempScaledUpdateSpeed / diff;
              particle.age = particle.lifeTime;
            }
            this._ratio = particle.age / particle.lifeTime;
            particle._directionScale = this._tempScaledUpdateSpeed;
            let currentQueueItem = this._updateQueueStart;
            while (currentQueueItem) {
              currentQueueItem.process(particle, this);
              currentQueueItem = currentQueueItem.nextItem;
            }
            if (this._isAnimationSheetEnabled && !noUpdateQueue) {
              particle.updateCellIndex();
            }
            particle._inheritParticleInfoToSubEmitters();
            if (particle.age >= particle.lifeTime) {
              this._emitFromParticle(particle);
              if (particle._attachedSubEmitters) {
                for (const subEmitter of particle._attachedSubEmitters) {
                  subEmitter.particleSystem.disposeOnStop = true;
                  subEmitter.particleSystem.stop();
                }
                particle._attachedSubEmitters = null;
              }
              this.recycleParticle(particle);
              if (sameParticleArray) {
                index--;
              }
              continue;
            }
          }
        };
      }
      /**
       * Serializes the particle system to a JSON object.
       * @param _serializeTexture Whether to serialize the texture information
       */
      serialize(_serializeTexture) {
        throw new Error("Method not implemented.");
      }
      /**
       * Clones the particle system.
       * @param name The name of the cloned object
       * @param newEmitter The new emitter to use
       * @param _cloneTexture Also clone the textures if true
       */
      clone(name13, newEmitter, _cloneTexture = false) {
        throw new Error("Method not implemented.");
      }
      _addFactorGradient(factorGradients, gradient, factor, factor2) {
        const newGradient = new FactorGradient(gradient, factor, factor2);
        factorGradients.push(newGradient);
        factorGradients.sort((a, b) => {
          if (a.gradient < b.gradient) {
            return -1;
          } else if (a.gradient > b.gradient) {
            return 1;
          }
          return 0;
        });
      }
      _removeFactorGradient(factorGradients, gradient) {
        if (!factorGradients) {
          return;
        }
        let index = 0;
        for (const factorGradient of factorGradients) {
          if (factorGradient.gradient === gradient) {
            factorGradients.splice(index, 1);
            break;
          }
          index++;
        }
      }
      _syncLifeTimeCreation() {
        if (this.targetStopDuration && this._lifeTimeGradients && this._lifeTimeGradients.length > 0) {
          this._lifeTimeCreation.process = _CreateLifeGradientsData;
          return;
        }
        this._lifeTimeCreation.process = _CreateLifetimeData;
      }
      _syncStartSizeCreation() {
        if (this._startSizeGradients && this._startSizeGradients[0] && this.targetStopDuration) {
          if (!this._startSizeCreation) {
            this._startSizeCreation = {
              process: _CreateStartSizeGradientsData,
              previousItem: null,
              nextItem: null
            };
            _ConnectAfter(this._startSizeCreation, this._sizeCreation);
          }
          return;
        }
        if (this._startSizeCreation) {
          _RemoveFromQueue(this._startSizeCreation);
          this._startSizeCreation = null;
        }
      }
      /**
       * The amount of time the particle system is running (depends of the overall update speed).
       */
      get targetStopDuration() {
        return this._targetStopDuration;
      }
      set targetStopDuration(value) {
        if (this.targetStopDuration === value) {
          return;
        }
        this._targetStopDuration = value;
        this._syncLifeTimeCreation();
        this._syncStartSizeCreation();
      }
      /**
       * Adds a new life time gradient
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param factor defines the life time factor to affect to the specified gradient
       * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
       * @returns the current particle system
       */
      addLifeTimeGradient(gradient, factor, factor2) {
        if (!this._lifeTimeGradients) {
          this._lifeTimeGradients = [];
        }
        this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);
        this._syncLifeTimeCreation();
        return this;
      }
      /**
       * Remove a specific life time gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeLifeTimeGradient(gradient) {
        this._removeFactorGradient(this._lifeTimeGradients, gradient);
        this._syncLifeTimeCreation();
        return this;
      }
      /**
       * Adds a new size gradient
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param factor defines the size factor to affect to the specified gradient
       * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
       * @returns the current particle system
       */
      addSizeGradient(gradient, factor, factor2) {
        if (!this._sizeGradients) {
          this._sizeGradients = [];
        }
        if (this._sizeGradients.length === 0) {
          this._sizeCreation.process = _CreateSizeGradientsData;
          this._sizeGradientProcessing = {
            process: _ProcessSizeGradients,
            previousItem: null,
            nextItem: null
          };
          _ConnectBefore(this._sizeGradientProcessing, this._gravityProcessing);
        }
        this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);
        return this;
      }
      /**
       * Remove a specific size gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeSizeGradient(gradient) {
        this._removeFactorGradient(this._sizeGradients, gradient);
        if (this._sizeGradients?.length === 0) {
          _RemoveFromQueue(this._sizeGradientProcessing);
          this._sizeCreation.process = _CreateSizeData;
        }
        return this;
      }
      /**
       * Adds a new color remap gradient
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param min defines the color remap minimal range
       * @param max defines the color remap maximal range
       * @returns the current particle system
       */
      addColorRemapGradient(gradient, min, max) {
        if (!this._colorRemapGradients) {
          this._colorRemapGradients = [];
        }
        this._addFactorGradient(this._colorRemapGradients, gradient, min, max);
        return this;
      }
      /**
       * Remove a specific color remap gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeColorRemapGradient(gradient) {
        this._removeFactorGradient(this._colorRemapGradients, gradient);
        return this;
      }
      /**
       * Adds a new alpha remap gradient
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param min defines the alpha remap minimal range
       * @param max defines the alpha remap maximal range
       * @returns the current particle system
       */
      addAlphaRemapGradient(gradient, min, max) {
        if (!this._alphaRemapGradients) {
          this._alphaRemapGradients = [];
        }
        this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);
        return this;
      }
      /**
       * Remove a specific alpha remap gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeAlphaRemapGradient(gradient) {
        this._removeFactorGradient(this._alphaRemapGradients, gradient);
        return this;
      }
      /**
       * Adds a new angular speed gradient
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param factor defines the angular speed  to affect to the specified gradient
       * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
       * @returns the current particle system
       */
      addAngularSpeedGradient(gradient, factor, factor2) {
        if (!this._angularSpeedGradients) {
          this._angularSpeedGradients = [];
        }
        if (this._angularSpeedGradients.length === 0) {
          this._angleCreation.process = _CreateAngleGradientsData;
          this._angularSpeedGradientProcessing = {
            process: _ProcessAngularSpeedGradients,
            previousItem: null,
            nextItem: null
          };
          _ConnectBefore(this._angularSpeedGradientProcessing, this._angularSpeedProcessing);
        }
        this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);
        return this;
      }
      /**
       * Remove a specific angular speed gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeAngularSpeedGradient(gradient) {
        this._removeFactorGradient(this._angularSpeedGradients, gradient);
        if (this._angularSpeedGradients?.length === 0) {
          this._angleCreation.process = _CreateAngleData;
          _RemoveFromQueue(this._angularSpeedGradientProcessing);
        }
        return this;
      }
      /**
       * Adds a new velocity gradient
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param factor defines the velocity to affect to the specified gradient
       * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
       * @returns the current particle system
       */
      addVelocityGradient(gradient, factor, factor2) {
        if (!this._velocityGradients) {
          this._velocityGradients = [];
        }
        if (this._velocityGradients.length === 0) {
          this._velocityCreation = {
            process: _CreateVelocityGradients,
            previousItem: null,
            nextItem: null
          };
          _ConnectAfter(this._velocityCreation, this._angleCreation);
          this._velocityGradientProcessing = {
            process: _ProcessVelocityGradients,
            previousItem: null,
            nextItem: null
          };
          _ConnectBefore(this._velocityGradientProcessing, this._directionProcessing);
        }
        this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);
        return this;
      }
      /**
       * Remove a specific velocity gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeVelocityGradient(gradient) {
        this._removeFactorGradient(this._velocityGradients, gradient);
        if (this._velocityGradients?.length === 0) {
          _RemoveFromQueue(this._velocityCreation);
          _RemoveFromQueue(this._velocityGradientProcessing);
        }
        return this;
      }
      /**
       * Adds a new limit velocity gradient
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param factor defines the limit velocity value to affect to the specified gradient
       * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
       * @returns the current particle system
       */
      addLimitVelocityGradient(gradient, factor, factor2) {
        if (!this._limitVelocityGradients) {
          this._limitVelocityGradients = [];
        }
        if (this._limitVelocityGradients.length === 0) {
          this._limitVelocityCreation = {
            process: _CreateLimitVelocityGradients,
            previousItem: null,
            nextItem: null
          };
          _ConnectAfter(this._limitVelocityCreation, this._angleCreation);
          this._limitVelocityGradientProcessing = {
            process: _ProcessLimitVelocityGradients,
            previousItem: null,
            nextItem: null
          };
          _ConnectAfter(this._limitVelocityGradientProcessing, this._directionProcessing);
        }
        this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);
        return this;
      }
      /**
       * Remove a specific limit velocity gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeLimitVelocityGradient(gradient) {
        this._removeFactorGradient(this._limitVelocityGradients, gradient);
        if (this._limitVelocityGradients?.length === 0) {
          _RemoveFromQueue(this._limitVelocityCreation);
          _RemoveFromQueue(this._limitVelocityGradientProcessing);
        }
        return this;
      }
      /**
       * Adds a new drag gradient
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param factor defines the drag value to affect to the specified gradient
       * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
       * @returns the current particle system
       */
      addDragGradient(gradient, factor, factor2) {
        if (!this._dragGradients) {
          this._dragGradients = [];
        }
        if (this._dragGradients.length === 0) {
          this._dragCreation = {
            process: _CreateDragData,
            previousItem: null,
            nextItem: null
          };
          _ConnectBefore(this._dragCreation, this._colorDeadCreation);
          this._dragGradientProcessing = {
            process: _ProcessDragGradients,
            previousItem: null,
            nextItem: null
          };
          _ConnectBefore(this._dragGradientProcessing, this._positionProcessing);
        }
        this._addFactorGradient(this._dragGradients, gradient, factor, factor2);
        return this;
      }
      /**
       * Remove a specific drag gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeDragGradient(gradient) {
        this._removeFactorGradient(this._dragGradients, gradient);
        if (this._dragGradients?.length === 0) {
          _RemoveFromQueue(this._dragCreation);
          _RemoveFromQueue(this._dragGradientProcessing);
        }
        return this;
      }
      /**
       * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param factor defines the emit rate value to affect to the specified gradient
       * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
       * @returns the current particle system
       */
      addEmitRateGradient(gradient, factor, factor2) {
        if (!this._emitRateGradients) {
          this._emitRateGradients = [];
        }
        this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);
        return this;
      }
      /**
       * Remove a specific emit rate gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeEmitRateGradient(gradient) {
        this._removeFactorGradient(this._emitRateGradients, gradient);
        return this;
      }
      /**
       * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param factor defines the start size value to affect to the specified gradient
       * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from
       * @returns the current particle system
       */
      addStartSizeGradient(gradient, factor, factor2) {
        if (!this._startSizeGradients) {
          this._startSizeGradients = [];
        }
        this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);
        this._syncStartSizeCreation();
        return this;
      }
      /**
       * Remove a specific start size gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeStartSizeGradient(gradient) {
        this._removeFactorGradient(this._startSizeGradients, gradient);
        this._syncStartSizeCreation();
        return this;
      }
      _createRampGradientTexture() {
        if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {
          return;
        }
        const data = new Uint8Array(this._rawTextureWidth * 4);
        const tmpColor = TmpColors.Color3[0];
        for (let x = 0; x < this._rawTextureWidth; x++) {
          const ratio = x / this._rawTextureWidth;
          GradientHelper.GetCurrentGradient(ratio, this._rampGradients, (currentGradient, nextGradient, scale) => {
            Color3.LerpToRef(currentGradient.color, nextGradient.color, scale, tmpColor);
            data[x * 4] = tmpColor.r * 255;
            data[x * 4 + 1] = tmpColor.g * 255;
            data[x * 4 + 2] = tmpColor.b * 255;
            data[x * 4 + 3] = 255;
          });
        }
        this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);
      }
      /**
       * Gets the current list of ramp gradients.
       * You must use addRampGradient and removeRampGradient to update this list
       * @returns the list of ramp gradients
       */
      getRampGradients() {
        return this._rampGradients;
      }
      /** Force the system to rebuild all gradients that need to be resync */
      forceRefreshGradients() {
        this._syncRampGradientTexture();
      }
      _syncRampGradientTexture() {
        if (!this._rampGradients) {
          return;
        }
        this._rampGradients.sort((a, b) => {
          if (a.gradient < b.gradient) {
            return -1;
          } else if (a.gradient > b.gradient) {
            return 1;
          }
          return 0;
        });
        if (this._rampGradientsTexture) {
          this._rampGradientsTexture.dispose();
          this._rampGradientsTexture = null;
        }
        this._createRampGradientTexture();
      }
      /**
       * Adds a new ramp gradient used to remap particle colors
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param color defines the color to affect to the specified gradient
       * @returns the current particle system
       */
      addRampGradient(gradient, color) {
        if (!this._rampGradients) {
          this._rampGradients = [];
        }
        const rampGradient = new Color3Gradient(gradient, color);
        this._rampGradients.push(rampGradient);
        this._syncRampGradientTexture();
        return this;
      }
      /**
       * Remove a specific ramp gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeRampGradient(gradient) {
        this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);
        this._rampGradientsTexture = null;
        if (this._rampGradients && this._rampGradients.length > 0) {
          this._createRampGradientTexture();
        }
        return this;
      }
      /**
       * Adds a new color gradient
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param color1 defines the color to affect to the specified gradient
       * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from
       * @returns this particle system
       */
      addColorGradient(gradient, color1, color2) {
        if (!this._colorGradients) {
          this._colorGradients = [];
        }
        if (this._colorGradients.length === 0) {
          this._colorCreation.process = _CreateColorGradientsData;
          this._colorProcessing.process = _ProcessColorGradients;
        }
        const colorGradient = new ColorGradient(gradient, color1, color2);
        this._colorGradients.push(colorGradient);
        this._colorGradients.sort((a, b) => {
          if (a.gradient < b.gradient) {
            return -1;
          } else if (a.gradient > b.gradient) {
            return 1;
          }
          return 0;
        });
        return this;
      }
      /**
       * Remove a specific color gradient
       * @param gradient defines the gradient to remove
       * @returns this particle system
       */
      removeColorGradient(gradient) {
        if (!this._colorGradients) {
          return this;
        }
        let index = 0;
        for (const colorGradient of this._colorGradients) {
          if (colorGradient.gradient === gradient) {
            this._colorGradients.splice(index, 1);
            break;
          }
          index++;
        }
        if (this._colorGradients.length === 0) {
          this._colorCreation.process = _CreateColorData;
          this._colorProcessing.process = _ProcessColor;
        }
        return this;
      }
      /**
       * Resets the draw wrappers cache
       */
      resetDrawCache() {
        if (!this._drawWrappers) {
          return;
        }
        for (const drawWrappers of this._drawWrappers) {
          if (drawWrappers) {
            for (const drawWrapper of drawWrappers) {
              drawWrapper?.dispose();
            }
          }
        }
        this._drawWrappers = [];
      }
      /** @internal */
      _fetchR(u, v, width, height, pixels) {
        u = Math.abs(u) * 0.5 + 0.5;
        v = Math.abs(v) * 0.5 + 0.5;
        const wrappedU = u * width % width | 0;
        const wrappedV = v * height % height | 0;
        const position = (wrappedU + wrappedV * width) * 4;
        return pixels[position] / 255;
      }
      _reset() {
        this._resetEffect();
      }
      _resetEffect() {
        if (this._vertexBuffer) {
          this._vertexBuffer.dispose();
          this._vertexBuffer = null;
        }
        if (this._spriteBuffer) {
          this._spriteBuffer.dispose();
          this._spriteBuffer = null;
        }
        if (this._vertexArrayObject) {
          this._engine.releaseVertexArrayObject(this._vertexArrayObject);
          this._vertexArrayObject = null;
        }
        this._createVertexBuffers();
      }
      _createVertexBuffers() {
        this._vertexBufferSize = this._useInstancing ? 10 : 12;
        if (this._isAnimationSheetEnabled) {
          this._vertexBufferSize += 1;
        }
        if (!this._isBillboardBased || this.billboardMode === 8 || this.billboardMode === 9) {
          this._vertexBufferSize += 3;
        }
        if (this._useRampGradients) {
          this._vertexBufferSize += 4;
        }
        const engine = this._engine;
        const vertexSize = this._vertexBufferSize * (this._useInstancing ? 1 : 4);
        this._vertexData = new Float32Array(this._capacity * vertexSize);
        this._vertexBuffer = new Buffer(engine, this._vertexData, true, vertexSize);
        let dataOffset = 0;
        const positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);
        this._vertexBuffers[VertexBuffer.PositionKind] = positions;
        dataOffset += 3;
        const colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);
        this._vertexBuffers[VertexBuffer.ColorKind] = colors;
        dataOffset += 4;
        const options = this._vertexBuffer.createVertexBuffer("angle", dataOffset, 1, this._vertexBufferSize, this._useInstancing);
        this._vertexBuffers["angle"] = options;
        dataOffset += 1;
        const size = this._vertexBuffer.createVertexBuffer("size", dataOffset, 2, this._vertexBufferSize, this._useInstancing);
        this._vertexBuffers["size"] = size;
        dataOffset += 2;
        if (this._isAnimationSheetEnabled) {
          const cellIndexBuffer = this._vertexBuffer.createVertexBuffer("cellIndex", dataOffset, 1, this._vertexBufferSize, this._useInstancing);
          this._vertexBuffers["cellIndex"] = cellIndexBuffer;
          dataOffset += 1;
        }
        if (!this._isBillboardBased || this.billboardMode === 8 || this.billboardMode === 9) {
          const directionBuffer = this._vertexBuffer.createVertexBuffer("direction", dataOffset, 3, this._vertexBufferSize, this._useInstancing);
          this._vertexBuffers["direction"] = directionBuffer;
          dataOffset += 3;
        }
        if (this._useRampGradients) {
          const rampDataBuffer = this._vertexBuffer.createVertexBuffer("remapData", dataOffset, 4, this._vertexBufferSize, this._useInstancing);
          this._vertexBuffers["remapData"] = rampDataBuffer;
          dataOffset += 4;
        }
        let offsets;
        if (this._useInstancing) {
          const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
          this._spriteBuffer = new Buffer(engine, spriteData, false, 2);
          offsets = this._spriteBuffer.createVertexBuffer("offset", 0, 2);
        } else {
          offsets = this._vertexBuffer.createVertexBuffer("offset", dataOffset, 2, this._vertexBufferSize, this._useInstancing);
          dataOffset += 2;
        }
        this._vertexBuffers["offset"] = offsets;
        this.resetDrawCache();
      }
      _createIndexBuffer() {
        if (this._useInstancing) {
          this._linesIndexBufferUseInstancing = this._engine.createIndexBuffer(new Uint32Array([0, 1, 1, 3, 3, 2, 2, 0, 0, 3]));
          return;
        }
        const indices = [];
        const indicesWireframe = [];
        let index = 0;
        for (let count = 0; count < this._capacity; count++) {
          indices.push(index);
          indices.push(index + 1);
          indices.push(index + 2);
          indices.push(index);
          indices.push(index + 2);
          indices.push(index + 3);
          indicesWireframe.push(index, index + 1, index + 1, index + 2, index + 2, index + 3, index + 3, index, index, index + 3);
          index += 4;
        }
        this._indexBuffer = this._engine.createIndexBuffer(indices);
        this._linesIndexBuffer = this._engine.createIndexBuffer(indicesWireframe);
      }
      /**
       * Gets the maximum number of particles active at the same time.
       * @returns The max number of active particles.
       */
      getCapacity() {
        return this._capacity;
      }
      /**
       * Gets whether there are still active particles in the system.
       * @returns True if it is alive, otherwise false.
       */
      isAlive() {
        return this._alive;
      }
      /**
       * Gets if the system has been started. (Note: this will still be true after stop is called)
       * @returns True if it has been started, otherwise false.
       */
      isStarted() {
        return this._started;
      }
      /** @internal */
      _preStart() {
      }
      /**
       * Starts the particle system and begins to emit
       * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)
       */
      start(delay = this.startDelay) {
        if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {
          throw "Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set";
        }
        if (delay) {
          this.startDelay = delay;
          setTimeout(() => {
            this.start(0);
          }, delay);
          return;
        }
        this._started = true;
        this._stopped = false;
        this._actualFrame = 0;
        this._preStart();
        if (this._emitRateGradients) {
          if (this._emitRateGradients.length > 0) {
            this._currentEmitRateGradient = this._emitRateGradients[0];
            this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();
            this._currentEmitRate2 = this._currentEmitRate1;
          }
          if (this._emitRateGradients.length > 1) {
            this._currentEmitRate2 = this._emitRateGradients[1].getFactor();
          }
        }
        if (this._startSizeGradients) {
          if (this._startSizeGradients.length > 0) {
            this._currentStartSizeGradient = this._startSizeGradients[0];
            this._currentStartSize1 = this._currentStartSizeGradient.getFactor();
            this._currentStartSize2 = this._currentStartSize1;
          }
          if (this._startSizeGradients.length > 1) {
            this._currentStartSize2 = this._startSizeGradients[1].getFactor();
          }
        }
        if (this.preWarmCycles) {
          if (this.emitter?.getClassName().indexOf("Mesh") !== -1) {
            this.emitter.computeWorldMatrix(true);
          }
          const noiseTextureAsProcedural = this.noiseTexture;
          if (noiseTextureAsProcedural && noiseTextureAsProcedural.onGeneratedObservable) {
            noiseTextureAsProcedural.onGeneratedObservable.addOnce(() => {
              setTimeout(() => {
                for (let index = 0; index < this.preWarmCycles; index++) {
                  this.animate(true);
                  noiseTextureAsProcedural.render();
                }
              });
            });
          } else {
            for (let index = 0; index < this.preWarmCycles; index++) {
              this.animate(true);
            }
          }
        }
        if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {
          this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);
        }
        this.onStartedObservable.notifyObservers(this);
      }
      /**
       * Stops the particle system.
       * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. The default value is true.
       */
      stop(stopSubEmitters = true) {
        if (this._stopped) {
          return;
        }
        this.onStoppedObservable.notifyObservers(this);
        this._stopped = true;
        this._postStop(stopSubEmitters);
      }
      /** @internal */
      _postStop(_stopSubEmitters) {
      }
      // Animation sheet
      /**
       * Remove all active particles
       */
      reset() {
        this._stockParticles.length = 0;
        this._particles.length = 0;
      }
      /**
       * @internal (for internal use only)
       */
      _appendParticleVertex(index, particle, offsetX, offsetY) {
        let offset = index * this._vertexBufferSize;
        const floatingOriginOffset = TmpVectors.Vector3[0].copyFrom(this._scene?.floatingOriginOffset || Vector3.ZeroReadOnly);
        this._vertexData[offset++] = particle.position.x + this.worldOffset.x - floatingOriginOffset.x;
        this._vertexData[offset++] = particle.position.y + this.worldOffset.y - floatingOriginOffset.y;
        this._vertexData[offset++] = particle.position.z + this.worldOffset.z - floatingOriginOffset.z;
        this._vertexData[offset++] = particle.color.r;
        this._vertexData[offset++] = particle.color.g;
        this._vertexData[offset++] = particle.color.b;
        this._vertexData[offset++] = particle.color.a;
        this._vertexData[offset++] = particle.angle;
        this._vertexData[offset++] = particle.scale.x * particle.size;
        this._vertexData[offset++] = particle.scale.y * particle.size;
        if (this._isAnimationSheetEnabled) {
          this._vertexData[offset++] = particle.cellIndex;
        }
        if (!this._isBillboardBased) {
          if (particle._initialDirection) {
            let initialDirection = particle._initialDirection;
            if (this.isLocal) {
              Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);
              initialDirection = TmpVectors.Vector3[0];
            }
            if (initialDirection.x === 0 && initialDirection.z === 0) {
              initialDirection.x = 1e-3;
            }
            this._vertexData[offset++] = initialDirection.x;
            this._vertexData[offset++] = initialDirection.y;
            this._vertexData[offset++] = initialDirection.z;
          } else {
            let direction = particle.direction;
            if (this.isLocal) {
              Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);
              direction = TmpVectors.Vector3[0];
            }
            if (direction.x === 0 && direction.z === 0) {
              direction.x = 1e-3;
            }
            this._vertexData[offset++] = direction.x;
            this._vertexData[offset++] = direction.y;
            this._vertexData[offset++] = direction.z;
          }
        } else if (this.billboardMode === 8 || this.billboardMode === 9) {
          this._vertexData[offset++] = particle.direction.x;
          this._vertexData[offset++] = particle.direction.y;
          this._vertexData[offset++] = particle.direction.z;
        }
        if (this._useRampGradients && particle.remapData) {
          this._vertexData[offset++] = particle.remapData.x;
          this._vertexData[offset++] = particle.remapData.y;
          this._vertexData[offset++] = particle.remapData.z;
          this._vertexData[offset++] = particle.remapData.w;
        }
        if (!this._useInstancing) {
          if (this._isAnimationSheetEnabled) {
            if (offsetX === 0) {
              offsetX = this._epsilon;
            } else if (offsetX === 1) {
              offsetX = 1 - this._epsilon;
            }
            if (offsetY === 0) {
              offsetY = this._epsilon;
            } else if (offsetY === 1) {
              offsetY = 1 - this._epsilon;
            }
          }
          this._vertexData[offset++] = offsetX;
          this._vertexData[offset++] = offsetY;
        }
      }
      /** @internal */
      _prepareParticle(_particle) {
      }
      _createNewOnes(newParticles) {
        let particle;
        for (let index = 0; index < newParticles; index++) {
          if (this._particles.length === this._capacity) {
            break;
          }
          particle = this._createParticle();
          this._particles.push(particle);
          let currentQueueItem = this._createQueueStart;
          while (currentQueueItem) {
            currentQueueItem.process(particle, this);
            currentQueueItem = currentQueueItem.nextItem;
          }
          particle._inheritParticleInfoToSubEmitters();
        }
      }
      _update(newParticles) {
        this._alive = this._particles.length > 0;
        if (this.emitter.position) {
          const emitterMesh = this.emitter;
          this._emitterWorldMatrix = emitterMesh.getWorldMatrix();
        } else {
          const emitterPosition = this.emitter;
          this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);
        }
        this._emitterWorldMatrix.invertToRef(this._emitterInverseWorldMatrix);
        this.updateFunction(this._particles);
        this._createNewOnes(newParticles);
      }
      /**
       * @internal
       */
      static _GetAttributeNamesOrOptions(isAnimationSheetEnabled = false, isBillboardBased = false, useRampGradients = false) {
        const attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, "angle", "offset", "size"];
        if (isAnimationSheetEnabled) {
          attributeNamesOrOptions.push("cellIndex");
        }
        if (!isBillboardBased) {
          attributeNamesOrOptions.push("direction");
        }
        if (useRampGradients) {
          attributeNamesOrOptions.push("remapData");
        }
        return attributeNamesOrOptions;
      }
      /**
       * @internal
       */
      static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false, applyFog = false) {
        const effectCreationOption = ["invView", "view", "projection", "textureMask", "translationPivot", "eyePosition"];
        AddClipPlaneUniforms(effectCreationOption);
        if (isAnimationSheetEnabled) {
          effectCreationOption.push("particlesInfos");
        }
        if (useLogarithmicDepth) {
          effectCreationOption.push("logarithmicDepthConstant");
        }
        if (applyFog) {
          effectCreationOption.push("vFogInfos");
          effectCreationOption.push("vFogColor");
        }
        return effectCreationOption;
      }
      /**
       * Fill the defines array according to the current settings of the particle system
       * @param defines Array to be updated
       * @param blendMode blend mode to take into account when updating the array
       * @param fillImageProcessing fills the image processing defines
       */
      fillDefines(defines, blendMode, fillImageProcessing = true) {
        if (this._scene) {
          PrepareStringDefinesForClipPlanes(this, this._scene, defines);
          if (this.applyFog && this._scene.fogEnabled && this._scene.fogMode !== 0) {
            defines.push("#define FOG");
          }
        }
        if (this._isAnimationSheetEnabled) {
          defines.push("#define ANIMATESHEET");
        }
        if (this.useLogarithmicDepth) {
          defines.push("#define LOGARITHMICDEPTH");
        }
        if (blendMode === BaseParticleSystem.BLENDMODE_MULTIPLY) {
          defines.push("#define BLENDMULTIPLYMODE");
        }
        if (this._useRampGradients) {
          defines.push("#define RAMPGRADIENT");
        }
        if (this._isBillboardBased) {
          defines.push("#define BILLBOARD");
          switch (this.billboardMode) {
            case 2:
              defines.push("#define BILLBOARDY");
              break;
            case 8:
            case 9:
              defines.push("#define BILLBOARDSTRETCHED");
              if (this.billboardMode === 9) {
                defines.push("#define BILLBOARDSTRETCHED_LOCAL");
              }
              break;
            case 7:
              defines.push("#define BILLBOARDMODE_ALL");
              break;
            default:
              break;
          }
        }
        if (fillImageProcessing && this._imageProcessingConfiguration) {
          this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);
          defines.push(this._imageProcessingConfigurationDefines.toString());
        }
      }
      /**
       * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system
       * @param uniforms Uniforms array to fill
       * @param attributes Attributes array to fill
       * @param samplers Samplers array to fill
       */
      fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers) {
        attributes.push(..._ThinParticleSystem._GetAttributeNamesOrOptions(this._isAnimationSheetEnabled, this._isBillboardBased && this.billboardMode !== 8 && this.billboardMode !== 9, this._useRampGradients));
        uniforms.push(..._ThinParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth, this.applyFog));
        samplers.push("diffuseSampler", "rampSampler");
        if (this._imageProcessingConfiguration) {
          PrepareUniformsForImageProcessing(uniforms, this._imageProcessingConfigurationDefines);
          PrepareSamplersForImageProcessing(samplers, this._imageProcessingConfigurationDefines);
        }
      }
      /**
       * @internal
       */
      _getWrapper(blendMode) {
        const customWrapper = this._getCustomDrawWrapper(blendMode);
        if (customWrapper?.effect) {
          return customWrapper;
        }
        const defines = [];
        this.fillDefines(defines, blendMode);
        const currentRenderPassId = this._engine._features.supportRenderPasses ? this._engine.currentRenderPassId : 0;
        let drawWrappers = this._drawWrappers[currentRenderPassId];
        if (!drawWrappers) {
          drawWrappers = this._drawWrappers[currentRenderPassId] = [];
        }
        let drawWrapper = drawWrappers[blendMode];
        if (!drawWrapper) {
          drawWrapper = new DrawWrapper(this._engine);
          if (drawWrapper.drawContext) {
            drawWrapper.drawContext.useInstancing = this._useInstancing;
          }
          drawWrappers[blendMode] = drawWrapper;
        }
        const join = defines.join("\n");
        if (drawWrapper.defines !== join) {
          const attributesNamesOrOptions = [];
          const effectCreationOption = [];
          const samplers = [];
          this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);
          drawWrapper.setEffect(this._engine.createEffect("particles", attributesNamesOrOptions, effectCreationOption, samplers, join, void 0, void 0, void 0, void 0, this._shaderLanguage), join);
        }
        return drawWrapper;
      }
      /**
       * Animates the particle system for the current frame by emitting new particles and or animating the living ones.
       * @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)
       */
      animate(preWarmOnly = false) {
        if (!this._started || this.paused) {
          return;
        }
        if (!preWarmOnly && this._scene) {
          if (!this.isReady()) {
            return;
          }
          if (this._currentRenderId === this._scene.getFrameId()) {
            return;
          }
          this._currentRenderId = this._scene.getFrameId();
        }
        this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : this._scene?.getAnimationRatio() || 1);
        let newParticles;
        if (this.manualEmitCount > -1) {
          newParticles = this.manualEmitCount;
          this._newPartsExcess = 0;
          this.manualEmitCount = 0;
        } else {
          const rate = this._calculateEmitRate();
          newParticles = rate * this._scaledUpdateSpeed >> 0;
          this._newPartsExcess += rate * this._scaledUpdateSpeed - newParticles;
        }
        if (this._newPartsExcess > 1) {
          newParticles += this._newPartsExcess >> 0;
          this._newPartsExcess -= this._newPartsExcess >> 0;
        }
        this._alive = false;
        if (!this._stopped) {
          this._actualFrame += this._scaledUpdateSpeed;
          if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {
            this.stop();
          }
        } else {
          newParticles = 0;
        }
        this._update(newParticles);
        if (this._stopped) {
          if (!this._alive) {
            this._started = false;
            if (this.onAnimationEnd) {
              this.onAnimationEnd();
            }
            if (this.disposeOnStop && this._scene) {
              this._scene._toBeDisposed.push(this);
            }
          }
        }
        if (!preWarmOnly) {
          let offset = 0;
          for (let index = 0; index < this._particles.length; index++) {
            const particle = this._particles[index];
            this._appendParticleVertices(offset, particle);
            offset += this._useInstancing ? 1 : 4;
          }
          if (this._vertexBuffer) {
            this._vertexBuffer.updateDirectly(this._vertexData, 0, this._particles.length);
          }
        }
        if (this.manualEmitCount === 0 && this.disposeOnStop) {
          this.stop();
        }
      }
      /**
       * Internal only. Calculates the current emit rate based on the gradients if any.
       * @returns The emit rate
       * @internal
       */
      _calculateEmitRate() {
        let rate = this.emitRate;
        if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {
          const ratio = this._actualFrame / this.targetStopDuration;
          GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, (currentGradient, nextGradient, scale) => {
            if (currentGradient !== this._currentEmitRateGradient) {
              this._currentEmitRate1 = this._currentEmitRate2;
              this._currentEmitRate2 = nextGradient.getFactor();
              this._currentEmitRateGradient = currentGradient;
            }
            rate = Lerp(this._currentEmitRate1, this._currentEmitRate2, scale);
          });
        }
        return rate;
      }
      _appendParticleVertices(offset, particle) {
        this._appendParticleVertex(offset++, particle, 0, 0);
        if (!this._useInstancing) {
          this._appendParticleVertex(offset++, particle, 1, 0);
          this._appendParticleVertex(offset++, particle, 1, 1);
          this._appendParticleVertex(offset++, particle, 0, 1);
        }
      }
      /**
       * Rebuilds the particle system.
       */
      rebuild() {
        if (this._engine.getCaps().vertexArrayObject) {
          this._vertexArrayObject = null;
        }
        this._createIndexBuffer();
        this._spriteBuffer?._rebuild();
        this._createVertexBuffers();
        this.resetDrawCache();
      }
      async _initShaderSourceAsync() {
        const engine = this._engine;
        if (engine.isWebGPU && !_ThinParticleSystem.ForceGLSL) {
          this._shaderLanguage = 1;
          await Promise.all([import("./particles.vertex-QKJ7L7ZO.js"), import("./particles.fragment-2UGQOGGF.js")]);
        } else {
          await Promise.all([import("./particles.vertex-KIDK7GLI.js"), import("./particles.fragment-PFNK2C3R.js")]);
        }
        this._shadersLoaded = true;
      }
      /**
       * Is this system ready to be used/rendered
       * @returns true if the system is ready
       */
      isReady() {
        if (!this._shadersLoaded) {
          return false;
        }
        if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {
          return false;
        }
        if (this.blendMode !== BaseParticleSystem.BLENDMODE_MULTIPLYADD) {
          if (!this._getWrapper(this.blendMode).effect.isReady()) {
            return false;
          }
        } else {
          if (!this._getWrapper(BaseParticleSystem.BLENDMODE_MULTIPLY).effect.isReady()) {
            return false;
          }
          if (!this._getWrapper(BaseParticleSystem.BLENDMODE_ADD).effect.isReady()) {
            return false;
          }
        }
        return true;
      }
      _render(blendMode) {
        const drawWrapper = this._getWrapper(blendMode);
        const effect = drawWrapper.effect;
        const engine = this._engine;
        engine.enableEffect(drawWrapper);
        const viewMatrix = this.defaultViewMatrix ?? this._scene.getViewMatrix();
        effect.setTexture("diffuseSampler", this.particleTexture);
        effect.setMatrix("view", viewMatrix);
        effect.setMatrix("projection", this.defaultProjectionMatrix ?? this._scene.getProjectionMatrix());
        if (this._isAnimationSheetEnabled && this.particleTexture) {
          const baseSize = this.particleTexture.getBaseSize();
          effect.setFloat3("particlesInfos", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);
        }
        effect.setVector2("translationPivot", this.translationPivot);
        effect.setFloat4("textureMask", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);
        if (this._isBillboardBased && this._scene) {
          const camera = this._scene.activeCamera;
          effect.setVector3("eyePosition", camera.globalPosition);
        }
        if (this._rampGradientsTexture) {
          if (!this._rampGradients || !this._rampGradients.length) {
            this._rampGradientsTexture.dispose();
            this._rampGradientsTexture = null;
          }
          effect.setTexture("rampSampler", this._rampGradientsTexture);
        }
        const defines = effect.defines;
        if (this._scene) {
          BindClipPlane(effect, this, this._scene);
          if (this.applyFog) {
            BindFogParameters(this._scene, void 0, effect);
          }
        }
        if (defines.indexOf("#define BILLBOARDMODE_ALL") >= 0) {
          viewMatrix.invertToRef(TmpVectors.Matrix[0]);
          effect.setMatrix("invView", TmpVectors.Matrix[0]);
        }
        if (this._vertexArrayObject !== void 0) {
          if (this._scene?.forceWireframe) {
            engine.bindBuffers(this._vertexBuffers, this._linesIndexBufferUseInstancing, effect);
          } else {
            if (!this._vertexArrayObject) {
              this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);
            }
            this._engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);
          }
        } else {
          if (!this._indexBuffer) {
            engine.bindBuffers(this._vertexBuffers, this._scene?.forceWireframe ? this._linesIndexBufferUseInstancing : null, effect);
          } else {
            engine.bindBuffers(this._vertexBuffers, this._scene?.forceWireframe ? this._linesIndexBuffer : this._indexBuffer, effect);
          }
        }
        if (this.useLogarithmicDepth && this._scene) {
          BindLogDepth(defines, effect, this._scene);
        }
        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
          this._imageProcessingConfiguration.bind(effect);
        }
        this._setEngineBasedOnBlendMode(blendMode);
        if (this._onBeforeDrawParticlesObservable) {
          this._onBeforeDrawParticlesObservable.notifyObservers(effect);
        }
        if (this._useInstancing) {
          if (this._scene?.forceWireframe) {
            engine.drawElementsType(6, 0, 10, this._particles.length);
          } else {
            engine.drawArraysType(7, 0, 4, this._particles.length);
          }
        } else {
          if (this._scene?.forceWireframe) {
            engine.drawElementsType(1, 0, this._particles.length * 10);
          } else {
            engine.drawElementsType(0, 0, this._particles.length * 6);
          }
        }
        return this._particles.length;
      }
      /**
       * Renders the particle system in its current state.
       * @returns the current number of particles
       */
      render() {
        if (!this.isReady() || !this._particles.length) {
          return 0;
        }
        const engine = this._engine;
        if (engine.setState) {
          engine.setState(false);
          if (this.forceDepthWrite) {
            engine.setDepthWrite(true);
          }
        }
        let outparticles = 0;
        if (this.blendMode === BaseParticleSystem.BLENDMODE_MULTIPLYADD) {
          outparticles = this._render(BaseParticleSystem.BLENDMODE_MULTIPLY) + this._render(BaseParticleSystem.BLENDMODE_ADD);
        } else {
          outparticles = this._render(this.blendMode);
        }
        this._engine.unbindInstanceAttributes();
        this._engine.setAlphaMode(0);
        return outparticles;
      }
      /** @internal */
      _onDispose(_disposeAttachedSubEmitters = false, _disposeEndSubEmitters = false) {
      }
      /**
       * Disposes the particle system and free the associated resources
       * @param disposeTexture defines if the particle texture must be disposed as well (true by default)
       * @param disposeAttachedSubEmitters defines if the attached sub-emitters must be disposed as well (false by default)
       * @param disposeEndSubEmitters defines if the end type sub-emitters must be disposed as well (false by default)
       */
      dispose(disposeTexture = true, disposeAttachedSubEmitters = false, disposeEndSubEmitters = false) {
        this.resetDrawCache();
        if (this._vertexBuffer) {
          this._vertexBuffer.dispose();
          this._vertexBuffer = null;
        }
        if (this._spriteBuffer) {
          this._spriteBuffer.dispose();
          this._spriteBuffer = null;
        }
        if (this._indexBuffer) {
          this._engine._releaseBuffer(this._indexBuffer);
          this._indexBuffer = null;
        }
        if (this._linesIndexBuffer) {
          this._engine._releaseBuffer(this._linesIndexBuffer);
          this._linesIndexBuffer = null;
        }
        if (this._linesIndexBufferUseInstancing) {
          this._engine._releaseBuffer(this._linesIndexBufferUseInstancing);
          this._linesIndexBufferUseInstancing = null;
        }
        if (this._vertexArrayObject) {
          this._engine.releaseVertexArrayObject(this._vertexArrayObject);
          this._vertexArrayObject = null;
        }
        if (disposeTexture && this.particleTexture) {
          this.particleTexture.dispose();
          this.particleTexture = null;
        }
        if (disposeTexture && this.noiseTexture) {
          this.noiseTexture.dispose();
          this.noiseTexture = null;
        }
        if (this._rampGradientsTexture) {
          this._rampGradientsTexture.dispose();
          this._rampGradientsTexture = null;
        }
        this._onDispose(disposeAttachedSubEmitters, disposeEndSubEmitters);
        if (this._onBeforeDrawParticlesObservable) {
          this._onBeforeDrawParticlesObservable.clear();
        }
        if (this._scene) {
          const index = this._scene.particleSystems.indexOf(this);
          if (index > -1) {
            this._scene.particleSystems.splice(index, 1);
          }
          this._scene._activeParticleSystems.dispose();
        }
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
        this.onStoppedObservable.clear();
        this.onStartedObservable.clear();
        this.reset();
        this._isDisposed = true;
      }
    };
    ThinParticleSystem.ForceGLSL = false;
  }
});

// node_modules/@babylonjs/core/Particles/particleSystem.functions.js
function CreatePointEmitter(direction1, direction2) {
  const particleEmitter = new PointParticleEmitter();
  particleEmitter.direction1 = direction1;
  particleEmitter.direction2 = direction2;
  return particleEmitter;
}
function CreateHemisphericEmitter(radius = 1, radiusRange = 1) {
  return new HemisphericParticleEmitter(radius, radiusRange);
}
function CreateSphereEmitter(radius = 1, radiusRange = 1) {
  return new SphereParticleEmitter(radius, radiusRange);
}
function CreateDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
  return new SphereDirectedParticleEmitter(radius, direction1, direction2);
}
function CreateCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {
  return new CylinderParticleEmitter(radius, height, radiusRange, directionRandomizer);
}
function CreateDirectedCylinderEmitter(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
  return new CylinderDirectedParticleEmitter(radius, height, radiusRange, direction1, direction2);
}
function CreateConeEmitter(radius = 1, angle = Math.PI / 4) {
  return new ConeParticleEmitter(radius, angle);
}
function CreateDirectedConeEmitter(radius = 1, angle = Math.PI / 4, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
  return new ConeDirectedParticleEmitter(radius, angle, direction1, direction2);
}
var init_particleSystem_functions = __esm({
  "node_modules/@babylonjs/core/Particles/particleSystem.functions.js"() {
    init_math_vector();
    init_pointParticleEmitter();
    init_hemisphericParticleEmitter();
    init_sphereParticleEmitter();
    init_cylinderParticleEmitter();
    init_coneParticleEmitter();
  }
});

// node_modules/@babylonjs/core/Particles/particleSystem.js
var ParticleSystem;
var init_particleSystem = __esm({
  "node_modules/@babylonjs/core/Particles/particleSystem.js"() {
    init_thinParticleSystem();
    init_subEmitter();
    init_math_color();
    init_math_vector();
    init_abstractEngine();
    init_typeStore();
    init_decorators_serialization();
    init_meshParticleEmitter();
    init_customParticleEmitter();
    init_boxParticleEmitter();
    init_pointParticleEmitter();
    init_hemisphericParticleEmitter();
    init_sphereParticleEmitter();
    init_cylinderParticleEmitter();
    init_coneParticleEmitter();
    init_particleSystem_functions();
    init_attractor();
    init_executionQueue();
    ParticleSystem = class _ParticleSystem extends ThinParticleSystem {
      constructor() {
        super(...arguments);
        this._disposeEmitterOnDispose = false;
        this.doNotSerialize = false;
        this.canStart = () => {
          return true;
        };
        this._flowMap = null;
        this._flowMapUpdate = null;
        this._source = null;
        this._blockReference = 0;
        this.flowMapStrength = 1;
        this._attractors = [];
        this._attractorUpdate = null;
        this.metadata = null;
        this._emitFromParticle = (particle) => {
          if (!this._subEmitters || this._subEmitters.length === 0) {
            return;
          }
          const templateIndex = Math.floor(Math.random() * this._subEmitters.length);
          for (const subEmitter of this._subEmitters[templateIndex]) {
            if (subEmitter.type === 1) {
              const subSystem = subEmitter.clone();
              particle._inheritParticleInfoToSubEmitter(subSystem);
              subSystem.particleSystem._rootParticleSystem = this;
              this.activeSubSystems.push(subSystem.particleSystem);
              subSystem.particleSystem.start();
            }
          }
        };
      }
      /**
       * Creates a Point Emitter for the particle system (emits directly from the emitter position)
       * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
       * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
       * @returns the emitter
       */
      createPointEmitter(direction1, direction2) {
        const particleEmitter = CreatePointEmitter(direction1, direction2);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
      }
      /**
       * Gets the NodeParticleSystemSet that this particle system belongs to.
       */
      get source() {
        return this._source;
      }
      /**
       * Returns true if the particle system was generated by a node particle system set
       */
      get isNodeGenerated() {
        return this._source !== null;
      }
      /** Gets or sets the current flow map */
      get flowMap() {
        return this._flowMap;
      }
      set flowMap(value) {
        if (this._flowMap === value) {
          return;
        }
        this._flowMap = value;
        if (this._flowMapUpdate) {
          _RemoveFromQueue(this._flowMapUpdate);
          this._flowMapUpdate = null;
        }
        if (value) {
          this._flowMapUpdate = {
            process: (particle) => {
              const matrix = this.getScene()?.getTransformMatrix();
              this._flowMap._processParticle(particle, this.flowMapStrength * this._tempScaledUpdateSpeed, matrix);
            },
            previousItem: null,
            nextItem: null
          };
          _ConnectAfter(this._flowMapUpdate, this._directionProcessing);
        }
      }
      /**
       * The list of attractors used to change the direction of the particles in the system.
       * Please note that this is a copy of the internal array. If you want to modify it, please use the addAttractor and removeAttractor methods.
       */
      get attractors() {
        return this._attractors.slice(0);
      }
      /**
       * Add an attractor to the particle system. Attractors are used to change the direction of the particles in the system.
       * @param attractor The attractor to add to the particle system
       */
      addAttractor(attractor) {
        this._attractors.push(attractor);
        if (this._attractors.length === 1) {
          this._attractorUpdate = {
            process: (particle) => {
              for (const attractor2 of this._attractors) {
                attractor2._processParticle(particle, this);
              }
            },
            previousItem: null,
            nextItem: null
          };
          _ConnectAfter(this._attractorUpdate, this._directionProcessing);
        }
      }
      /**
       * Removes an attractor from the particle system. Attractors are used to change the direction of the particles in the system.
       * @param attractor The attractor to remove from the particle system
       */
      removeAttractor(attractor) {
        const index = this._attractors.indexOf(attractor);
        if (index !== -1) {
          this._attractors.splice(index, 1);
        }
        if (this._attractors.length === 0) {
          _RemoveFromQueue(this._attractorUpdate);
        }
      }
      /**
       * Starts the particle system and begins to emit
       * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)
       */
      start(delay = this.startDelay) {
        if (!this.canStart()) {
          return;
        }
        super.start(delay);
      }
      /**
       * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)
       * @param radius The radius of the hemisphere to emit from
       * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
       * @returns the emitter
       */
      createHemisphericEmitter(radius = 1, radiusRange = 1) {
        const particleEmitter = CreateHemisphericEmitter(radius, radiusRange);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
      }
      /**
       * Creates a Sphere Emitter for the particle system (emits along the sphere radius)
       * @param radius The radius of the sphere to emit from
       * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
       * @returns the emitter
       */
      createSphereEmitter(radius = 1, radiusRange = 1) {
        const particleEmitter = CreateSphereEmitter(radius, radiusRange);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
      }
      /**
       * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)
       * @param radius The radius of the sphere to emit from
       * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere
       * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere
       * @returns the emitter
       */
      createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
        const particleEmitter = CreateDirectedSphereEmitter(radius, direction1, direction2);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
      }
      /**
       * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)
       * @param radius The radius of the emission cylinder
       * @param height The height of the emission cylinder
       * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius
       * @param directionRandomizer How much to randomize the particle direction [0-1]
       * @returns the emitter
       */
      createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {
        const particleEmitter = CreateCylinderEmitter(radius, height, radiusRange, directionRandomizer);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
      }
      /**
       * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)
       * @param radius The radius of the cylinder to emit from
       * @param height The height of the emission cylinder
       * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
       * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder
       * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder
       * @returns the emitter
       */
      createDirectedCylinderEmitter(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
        const particleEmitter = CreateDirectedCylinderEmitter(radius, height, radiusRange, direction1, direction2);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
      }
      /**
       * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)
       * @param radius The radius of the cone to emit from
       * @param angle The base angle of the cone
       * @returns the emitter
       */
      createConeEmitter(radius = 1, angle = Math.PI / 4) {
        const particleEmitter = CreateConeEmitter(radius, angle);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
      }
      /**
       * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)
       * @param radius The radius of the cone to emit from
       * @param angle The base angle of the cone
       * @param direction1 Particles are emitted between the direction1 and direction2 from within the cone
       * @param direction2 Particles are emitted between the direction1 and direction2 from within the cone
       * @returns the emitter
       */
      createDirectedConeEmitter(radius = 1, angle = Math.PI / 4, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
        const particleEmitter = CreateDirectedConeEmitter(radius, angle, direction1, direction2);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
      }
      /**
       * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)
       * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
       * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
       * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox
       * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox
       * @returns the emitter
       */
      createBoxEmitter(direction1, direction2, minEmitBox, maxEmitBox) {
        const particleEmitter = new BoxParticleEmitter();
        this.particleEmitterType = particleEmitter;
        this.direction1 = direction1;
        this.direction2 = direction2;
        this.minEmitBox = minEmitBox;
        this.maxEmitBox = maxEmitBox;
        return particleEmitter;
      }
      _prepareSubEmitterInternalArray() {
        this._subEmitters = new Array();
        if (this.subEmitters) {
          for (const subEmitter of this.subEmitters) {
            if (subEmitter instanceof _ParticleSystem) {
              this._subEmitters.push([new SubEmitter(subEmitter)]);
            } else if (subEmitter instanceof SubEmitter) {
              this._subEmitters.push([subEmitter]);
            } else if (subEmitter instanceof Array) {
              this._subEmitters.push(subEmitter);
            }
          }
        }
      }
      _stopSubEmitters() {
        if (!this.activeSubSystems) {
          return;
        }
        for (const subSystem of this.activeSubSystems) {
          subSystem.stop(true);
        }
        this.activeSubSystems = [];
      }
      _removeFromRoot() {
        if (!this._rootParticleSystem) {
          return;
        }
        const index = this._rootParticleSystem.activeSubSystems.indexOf(this);
        if (index !== -1) {
          this._rootParticleSystem.activeSubSystems.splice(index, 1);
        }
        this._rootParticleSystem = null;
      }
      /** @internal */
      _preStart() {
        this._prepareSubEmitterInternalArray();
        if (this._subEmitters && this._subEmitters.length != 0) {
          this.activeSubSystems = [];
        }
      }
      /** @internal */
      _postStop(stopSubEmitters) {
        if (stopSubEmitters) {
          this._stopSubEmitters();
        }
      }
      /** @internal */
      _prepareParticle(particle) {
        if (this._subEmitters && this._subEmitters.length > 0) {
          const subEmitters = this._subEmitters[Math.floor(Math.random() * this._subEmitters.length)];
          particle._attachedSubEmitters = [];
          for (const subEmitter of subEmitters) {
            if (subEmitter.type === 0) {
              const newEmitter = subEmitter.clone();
              particle._attachedSubEmitters.push(newEmitter);
              newEmitter.particleSystem.start();
            }
          }
        }
      }
      /** @internal */
      _onDispose(disposeAttachedSubEmitters = false, disposeEndSubEmitters = false) {
        this._removeFromRoot();
        if (this.subEmitters && !this._subEmitters) {
          this._prepareSubEmitterInternalArray();
        }
        if (disposeAttachedSubEmitters) {
          if (this.particles) {
            for (const particle of this.particles) {
              if (particle._attachedSubEmitters) {
                for (let i = particle._attachedSubEmitters.length - 1; i >= 0; i -= 1) {
                  particle._attachedSubEmitters[i].dispose();
                }
              }
            }
          }
        }
        if (disposeEndSubEmitters) {
          if (this.activeSubSystems) {
            for (let i = this.activeSubSystems.length - 1; i >= 0; i -= 1) {
              this.activeSubSystems[i].dispose();
            }
          }
        }
        if (this._subEmitters && this._subEmitters.length) {
          for (let index = 0; index < this._subEmitters.length; index++) {
            for (const subEmitter of this._subEmitters[index]) {
              subEmitter.dispose();
            }
          }
          this._subEmitters = [];
          this.subEmitters = [];
        }
        if (this._disposeEmitterOnDispose && this.emitter && this.emitter.dispose) {
          this.emitter.dispose(true);
        }
      }
      /**
       * @internal
       */
      static _Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl) {
        let scene;
        if (sceneOrEngine instanceof AbstractEngine) {
          scene = null;
        } else {
          scene = sceneOrEngine;
        }
        const internalClass = GetClass("BABYLON.Texture");
        if (internalClass && scene) {
          if (parsedParticleSystem.texture) {
            particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl);
          } else if (parsedParticleSystem.textureName) {
            particleSystem.particleTexture = new internalClass(rootUrl + parsedParticleSystem.textureName, scene, false, parsedParticleSystem.invertY !== void 0 ? parsedParticleSystem.invertY : true);
            particleSystem.particleTexture.name = parsedParticleSystem.textureName;
          }
        }
        if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === void 0) {
          particleSystem.emitter = Vector3.Zero();
        } else if (parsedParticleSystem.emitterId && scene) {
          particleSystem.emitter = scene.getLastMeshById(parsedParticleSystem.emitterId);
        } else {
          particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);
        }
        particleSystem.isLocal = !!parsedParticleSystem.isLocal;
        if (parsedParticleSystem.renderingGroupId !== void 0) {
          particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;
        }
        if (parsedParticleSystem.isBillboardBased !== void 0) {
          particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;
        }
        if (parsedParticleSystem.billboardMode !== void 0) {
          particleSystem.billboardMode = parsedParticleSystem.billboardMode;
        }
        if (parsedParticleSystem.useLogarithmicDepth !== void 0) {
          particleSystem.useLogarithmicDepth = parsedParticleSystem.useLogarithmicDepth;
        }
        if (parsedParticleSystem.animations) {
          for (let animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {
            const parsedAnimation = parsedParticleSystem.animations[animationIndex];
            const internalClass2 = GetClass("BABYLON.Animation");
            if (internalClass2) {
              particleSystem.animations.push(internalClass2.Parse(parsedAnimation));
            }
          }
          particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;
          particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;
          particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;
          particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;
        }
        if (parsedParticleSystem.autoAnimate && scene) {
          scene.beginAnimation(particleSystem, parsedParticleSystem.autoAnimateFrom, parsedParticleSystem.autoAnimateTo, parsedParticleSystem.autoAnimateLoop, parsedParticleSystem.autoAnimateSpeed || 1);
        }
        particleSystem.startDelay = parsedParticleSystem.startDelay | 0;
        particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;
        particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;
        particleSystem.minSize = parsedParticleSystem.minSize;
        particleSystem.maxSize = parsedParticleSystem.maxSize;
        if (parsedParticleSystem.minScaleX) {
          particleSystem.minScaleX = parsedParticleSystem.minScaleX;
          particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;
          particleSystem.minScaleY = parsedParticleSystem.minScaleY;
          particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;
        }
        if (parsedParticleSystem.preWarmCycles !== void 0) {
          particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;
          particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;
        }
        if (parsedParticleSystem.minInitialRotation !== void 0) {
          particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;
          particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;
        }
        particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;
        particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;
        particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;
        particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;
        particleSystem.emitRate = parsedParticleSystem.emitRate;
        particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);
        if (parsedParticleSystem.noiseStrength) {
          particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);
        }
        particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);
        particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);
        particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);
        particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;
        particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;
        particleSystem.blendMode = parsedParticleSystem.blendMode;
        if (parsedParticleSystem.colorGradients) {
          for (const colorGradient of parsedParticleSystem.colorGradients) {
            particleSystem.addColorGradient(colorGradient.gradient, Color4.FromArray(colorGradient.color1), colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : void 0);
          }
        }
        if (parsedParticleSystem.rampGradients) {
          for (const rampGradient of parsedParticleSystem.rampGradients) {
            particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));
          }
          particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;
        }
        if (parsedParticleSystem.colorRemapGradients) {
          for (const colorRemapGradient of parsedParticleSystem.colorRemapGradients) {
            particleSystem.addColorRemapGradient(colorRemapGradient.gradient, colorRemapGradient.factor1 !== void 0 ? colorRemapGradient.factor1 : colorRemapGradient.factor, colorRemapGradient.factor2);
          }
        }
        if (parsedParticleSystem.alphaRemapGradients) {
          for (const alphaRemapGradient of parsedParticleSystem.alphaRemapGradients) {
            particleSystem.addAlphaRemapGradient(alphaRemapGradient.gradient, alphaRemapGradient.factor1 !== void 0 ? alphaRemapGradient.factor1 : alphaRemapGradient.factor, alphaRemapGradient.factor2);
          }
        }
        if (parsedParticleSystem.sizeGradients) {
          for (const sizeGradient of parsedParticleSystem.sizeGradients) {
            particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== void 0 ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);
          }
        }
        if (parsedParticleSystem.angularSpeedGradients) {
          for (const angularSpeedGradient of parsedParticleSystem.angularSpeedGradients) {
            particleSystem.addAngularSpeedGradient(angularSpeedGradient.gradient, angularSpeedGradient.factor1 !== void 0 ? angularSpeedGradient.factor1 : angularSpeedGradient.factor, angularSpeedGradient.factor2);
          }
        }
        if (parsedParticleSystem.velocityGradients) {
          for (const velocityGradient of parsedParticleSystem.velocityGradients) {
            particleSystem.addVelocityGradient(velocityGradient.gradient, velocityGradient.factor1 !== void 0 ? velocityGradient.factor1 : velocityGradient.factor, velocityGradient.factor2);
          }
        }
        if (parsedParticleSystem.dragGradients) {
          for (const dragGradient of parsedParticleSystem.dragGradients) {
            particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== void 0 ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);
          }
        }
        if (parsedParticleSystem.emitRateGradients) {
          for (const emitRateGradient of parsedParticleSystem.emitRateGradients) {
            particleSystem.addEmitRateGradient(emitRateGradient.gradient, emitRateGradient.factor1 !== void 0 ? emitRateGradient.factor1 : emitRateGradient.factor, emitRateGradient.factor2);
          }
        }
        if (parsedParticleSystem.startSizeGradients) {
          for (const startSizeGradient of parsedParticleSystem.startSizeGradients) {
            particleSystem.addStartSizeGradient(startSizeGradient.gradient, startSizeGradient.factor1 !== void 0 ? startSizeGradient.factor1 : startSizeGradient.factor, startSizeGradient.factor2);
          }
        }
        if (parsedParticleSystem.lifeTimeGradients) {
          for (const lifeTimeGradient of parsedParticleSystem.lifeTimeGradients) {
            particleSystem.addLifeTimeGradient(lifeTimeGradient.gradient, lifeTimeGradient.factor1 !== void 0 ? lifeTimeGradient.factor1 : lifeTimeGradient.factor, lifeTimeGradient.factor2);
          }
        }
        if (parsedParticleSystem.limitVelocityGradients) {
          for (const limitVelocityGradient of parsedParticleSystem.limitVelocityGradients) {
            particleSystem.addLimitVelocityGradient(limitVelocityGradient.gradient, limitVelocityGradient.factor1 !== void 0 ? limitVelocityGradient.factor1 : limitVelocityGradient.factor, limitVelocityGradient.factor2);
          }
          particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;
        }
        if (parsedParticleSystem.noiseTexture && scene) {
          const internalClass2 = GetClass("BABYLON.ProceduralTexture");
          particleSystem.noiseTexture = internalClass2.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);
        }
        let emitterType;
        if (parsedParticleSystem.particleEmitterType) {
          switch (parsedParticleSystem.particleEmitterType.type) {
            case "SphereParticleEmitter":
              emitterType = new SphereParticleEmitter();
              break;
            case "SphereDirectedParticleEmitter":
              emitterType = new SphereDirectedParticleEmitter();
              break;
            case "ConeEmitter":
            case "ConeParticleEmitter":
              emitterType = new ConeParticleEmitter();
              break;
            case "ConeDirectedParticleEmitter":
              emitterType = new ConeDirectedParticleEmitter();
              break;
            case "CylinderParticleEmitter":
              emitterType = new CylinderParticleEmitter();
              break;
            case "CylinderDirectedParticleEmitter":
              emitterType = new CylinderDirectedParticleEmitter();
              break;
            case "HemisphericParticleEmitter":
              emitterType = new HemisphericParticleEmitter();
              break;
            case "PointParticleEmitter":
              emitterType = new PointParticleEmitter();
              break;
            case "MeshParticleEmitter":
              emitterType = new MeshParticleEmitter();
              break;
            case "CustomParticleEmitter":
              emitterType = new CustomParticleEmitter();
              break;
            case "BoxEmitter":
            case "BoxParticleEmitter":
            default:
              emitterType = new BoxParticleEmitter();
              break;
          }
          emitterType.parse(parsedParticleSystem.particleEmitterType, scene);
        } else {
          emitterType = new BoxParticleEmitter();
          emitterType.parse(parsedParticleSystem, scene);
        }
        particleSystem.particleEmitterType = emitterType;
        particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;
        particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;
        particleSystem.spriteCellLoop = parsedParticleSystem.spriteCellLoop ?? true;
        particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;
        particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;
        particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;
        particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;
        particleSystem.disposeOnStop = parsedParticleSystem.disposeOnStop ?? false;
        particleSystem.manualEmitCount = parsedParticleSystem.manualEmitCount ?? -1;
      }
      /**
       * Parses a JSON object to create a particle system.
       * @param parsedParticleSystem The JSON object to parse
       * @param sceneOrEngine The scene or the engine to create the particle system in
       * @param rootUrl The root url to use to load external dependencies like texture
       * @param doNotStart Ignore the preventAutoStart attribute and does not start
       * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)
       * @returns the Parsed particle system
       */
      static Parse(parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart = false, capacity) {
        const name13 = parsedParticleSystem.name;
        let custom = null;
        let program = null;
        let engine;
        let scene;
        if (sceneOrEngine instanceof AbstractEngine) {
          engine = sceneOrEngine;
        } else {
          scene = sceneOrEngine;
          engine = scene.getEngine();
        }
        if (parsedParticleSystem.customShader && engine.createEffectForParticles) {
          program = parsedParticleSystem.customShader;
          const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join("\n") : "";
          custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);
        }
        const particleSystem = new _ParticleSystem(name13, capacity || parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);
        particleSystem.customShader = program;
        particleSystem._rootUrl = rootUrl;
        if (parsedParticleSystem.id) {
          particleSystem.id = parsedParticleSystem.id;
        }
        if (parsedParticleSystem.subEmitters) {
          particleSystem.subEmitters = [];
          for (const cell of parsedParticleSystem.subEmitters) {
            const cellArray = [];
            for (const sub of cell) {
              cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));
            }
            particleSystem.subEmitters.push(cellArray);
          }
        }
        if (parsedParticleSystem.attractors) {
          for (const attractor of parsedParticleSystem.attractors) {
            const newAttractor = new Attractor();
            newAttractor.position = Vector3.FromArray(attractor.position);
            newAttractor.strength = attractor.strength;
            particleSystem.addAttractor(newAttractor);
          }
        }
        _ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);
        if (parsedParticleSystem.textureMask) {
          particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);
        }
        if (parsedParticleSystem.worldOffset) {
          particleSystem.worldOffset = Vector3.FromArray(parsedParticleSystem.worldOffset);
        }
        if (parsedParticleSystem.preventAutoStart) {
          particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;
        }
        if (parsedParticleSystem.metadata) {
          particleSystem.metadata = parsedParticleSystem.metadata;
        }
        if (!doNotStart && !particleSystem.preventAutoStart) {
          particleSystem.start();
        }
        return particleSystem;
      }
      /**
       * Serializes the particle system to a JSON object
       * @param serializeTexture defines if the texture must be serialized as well
       * @returns the JSON object
       */
      serialize(serializeTexture = false) {
        const serializationObject = {};
        _ParticleSystem._Serialize(serializationObject, this, serializeTexture);
        serializationObject.textureMask = this.textureMask.asArray();
        serializationObject.customShader = this.customShader;
        serializationObject.preventAutoStart = this.preventAutoStart;
        serializationObject.worldOffset = this.worldOffset.asArray();
        if (this.metadata) {
          serializationObject.metadata = this.metadata;
        }
        if (this.subEmitters) {
          serializationObject.subEmitters = [];
          if (!this._subEmitters) {
            this._prepareSubEmitterInternalArray();
          }
          for (const subs of this._subEmitters) {
            const cell = [];
            for (const sub of subs) {
              if (!sub.particleSystem.doNotSerialize) {
                cell.push(sub.serialize(serializeTexture));
              }
            }
            serializationObject.subEmitters.push(cell);
          }
        }
        if (this._attractors && this._attractors.length) {
          serializationObject.attractors = [];
          for (const attractor of this._attractors) {
            serializationObject.attractors.push(attractor.serialize());
          }
        }
        return serializationObject;
      }
      /**
       * @internal
       */
      static _Serialize(serializationObject, particleSystem, serializeTexture) {
        serializationObject.name = particleSystem.name;
        serializationObject.id = particleSystem.id;
        serializationObject.capacity = particleSystem.getCapacity();
        serializationObject.disposeOnStop = particleSystem.disposeOnStop;
        serializationObject.manualEmitCount = particleSystem.manualEmitCount;
        if (particleSystem.emitter.position) {
          const emitterMesh = particleSystem.emitter;
          serializationObject.emitterId = emitterMesh.id;
        } else {
          const emitterPosition = particleSystem.emitter;
          serializationObject.emitter = emitterPosition.asArray();
        }
        if (particleSystem.particleEmitterType) {
          serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();
        }
        if (particleSystem.particleTexture) {
          if (serializeTexture) {
            serializationObject.texture = particleSystem.particleTexture.serialize();
          } else {
            serializationObject.textureName = particleSystem.particleTexture.name;
            serializationObject.invertY = !!particleSystem.particleTexture._invertY;
          }
        }
        serializationObject.isLocal = particleSystem.isLocal;
        SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);
        serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;
        serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;
        serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;
        serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop;
        serializationObject.startDelay = particleSystem.startDelay;
        serializationObject.renderingGroupId = particleSystem.renderingGroupId;
        serializationObject.isBillboardBased = particleSystem.isBillboardBased;
        serializationObject.billboardMode = particleSystem.billboardMode;
        serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;
        serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;
        serializationObject.minSize = particleSystem.minSize;
        serializationObject.maxSize = particleSystem.maxSize;
        serializationObject.minScaleX = particleSystem.minScaleX;
        serializationObject.maxScaleX = particleSystem.maxScaleX;
        serializationObject.minScaleY = particleSystem.minScaleY;
        serializationObject.maxScaleY = particleSystem.maxScaleY;
        serializationObject.minEmitPower = particleSystem.minEmitPower;
        serializationObject.maxEmitPower = particleSystem.maxEmitPower;
        serializationObject.minLifeTime = particleSystem.minLifeTime;
        serializationObject.maxLifeTime = particleSystem.maxLifeTime;
        serializationObject.emitRate = particleSystem.emitRate;
        serializationObject.gravity = particleSystem.gravity.asArray();
        serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();
        serializationObject.color1 = particleSystem.color1.asArray();
        serializationObject.color2 = particleSystem.color2.asArray();
        serializationObject.colorDead = particleSystem.colorDead.asArray();
        serializationObject.updateSpeed = particleSystem.updateSpeed;
        serializationObject.targetStopDuration = particleSystem.targetStopDuration;
        serializationObject.blendMode = particleSystem.blendMode;
        serializationObject.preWarmCycles = particleSystem.preWarmCycles;
        serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;
        serializationObject.minInitialRotation = particleSystem.minInitialRotation;
        serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;
        serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;
        serializationObject.spriteCellLoop = particleSystem.spriteCellLoop;
        serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;
        serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;
        serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;
        serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;
        serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;
        serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;
        serializationObject.useLogarithmicDepth = particleSystem.useLogarithmicDepth;
        const colorGradients = particleSystem.getColorGradients();
        if (colorGradients) {
          serializationObject.colorGradients = [];
          for (const colorGradient of colorGradients) {
            const serializedGradient = {
              gradient: colorGradient.gradient,
              color1: colorGradient.color1.asArray()
            };
            if (colorGradient.color2) {
              serializedGradient.color2 = colorGradient.color2.asArray();
            } else {
              serializedGradient.color2 = colorGradient.color1.asArray();
            }
            serializationObject.colorGradients.push(serializedGradient);
          }
        }
        const rampGradients = particleSystem.getRampGradients();
        if (rampGradients) {
          serializationObject.rampGradients = [];
          for (const rampGradient of rampGradients) {
            const serializedGradient = {
              gradient: rampGradient.gradient,
              color: rampGradient.color.asArray()
            };
            serializationObject.rampGradients.push(serializedGradient);
          }
          serializationObject.useRampGradients = particleSystem.useRampGradients;
        }
        const colorRemapGradients = particleSystem.getColorRemapGradients();
        if (colorRemapGradients) {
          serializationObject.colorRemapGradients = [];
          for (const colorRemapGradient of colorRemapGradients) {
            const serializedGradient = {
              gradient: colorRemapGradient.gradient,
              factor1: colorRemapGradient.factor1
            };
            if (colorRemapGradient.factor2 !== void 0) {
              serializedGradient.factor2 = colorRemapGradient.factor2;
            } else {
              serializedGradient.factor2 = colorRemapGradient.factor1;
            }
            serializationObject.colorRemapGradients.push(serializedGradient);
          }
        }
        const alphaRemapGradients = particleSystem.getAlphaRemapGradients();
        if (alphaRemapGradients) {
          serializationObject.alphaRemapGradients = [];
          for (const alphaRemapGradient of alphaRemapGradients) {
            const serializedGradient = {
              gradient: alphaRemapGradient.gradient,
              factor1: alphaRemapGradient.factor1
            };
            if (alphaRemapGradient.factor2 !== void 0) {
              serializedGradient.factor2 = alphaRemapGradient.factor2;
            } else {
              serializedGradient.factor2 = alphaRemapGradient.factor1;
            }
            serializationObject.alphaRemapGradients.push(serializedGradient);
          }
        }
        const sizeGradients = particleSystem.getSizeGradients();
        if (sizeGradients) {
          serializationObject.sizeGradients = [];
          for (const sizeGradient of sizeGradients) {
            const serializedGradient = {
              gradient: sizeGradient.gradient,
              factor1: sizeGradient.factor1
            };
            if (sizeGradient.factor2 !== void 0) {
              serializedGradient.factor2 = sizeGradient.factor2;
            } else {
              serializedGradient.factor2 = sizeGradient.factor1;
            }
            serializationObject.sizeGradients.push(serializedGradient);
          }
        }
        const angularSpeedGradients = particleSystem.getAngularSpeedGradients();
        if (angularSpeedGradients) {
          serializationObject.angularSpeedGradients = [];
          for (const angularSpeedGradient of angularSpeedGradients) {
            const serializedGradient = {
              gradient: angularSpeedGradient.gradient,
              factor1: angularSpeedGradient.factor1
            };
            if (angularSpeedGradient.factor2 !== void 0) {
              serializedGradient.factor2 = angularSpeedGradient.factor2;
            } else {
              serializedGradient.factor2 = angularSpeedGradient.factor1;
            }
            serializationObject.angularSpeedGradients.push(serializedGradient);
          }
        }
        const velocityGradients = particleSystem.getVelocityGradients();
        if (velocityGradients) {
          serializationObject.velocityGradients = [];
          for (const velocityGradient of velocityGradients) {
            const serializedGradient = {
              gradient: velocityGradient.gradient,
              factor1: velocityGradient.factor1
            };
            if (velocityGradient.factor2 !== void 0) {
              serializedGradient.factor2 = velocityGradient.factor2;
            } else {
              serializedGradient.factor2 = velocityGradient.factor1;
            }
            serializationObject.velocityGradients.push(serializedGradient);
          }
        }
        const dragGradients = particleSystem.getDragGradients();
        if (dragGradients) {
          serializationObject.dragGradients = [];
          for (const dragGradient of dragGradients) {
            const serializedGradient = {
              gradient: dragGradient.gradient,
              factor1: dragGradient.factor1
            };
            if (dragGradient.factor2 !== void 0) {
              serializedGradient.factor2 = dragGradient.factor2;
            } else {
              serializedGradient.factor2 = dragGradient.factor1;
            }
            serializationObject.dragGradients.push(serializedGradient);
          }
        }
        const emitRateGradients = particleSystem.getEmitRateGradients();
        if (emitRateGradients) {
          serializationObject.emitRateGradients = [];
          for (const emitRateGradient of emitRateGradients) {
            const serializedGradient = {
              gradient: emitRateGradient.gradient,
              factor1: emitRateGradient.factor1
            };
            if (emitRateGradient.factor2 !== void 0) {
              serializedGradient.factor2 = emitRateGradient.factor2;
            } else {
              serializedGradient.factor2 = emitRateGradient.factor1;
            }
            serializationObject.emitRateGradients.push(serializedGradient);
          }
        }
        const startSizeGradients = particleSystem.getStartSizeGradients();
        if (startSizeGradients) {
          serializationObject.startSizeGradients = [];
          for (const startSizeGradient of startSizeGradients) {
            const serializedGradient = {
              gradient: startSizeGradient.gradient,
              factor1: startSizeGradient.factor1
            };
            if (startSizeGradient.factor2 !== void 0) {
              serializedGradient.factor2 = startSizeGradient.factor2;
            } else {
              serializedGradient.factor2 = startSizeGradient.factor1;
            }
            serializationObject.startSizeGradients.push(serializedGradient);
          }
        }
        const lifeTimeGradients = particleSystem.getLifeTimeGradients();
        if (lifeTimeGradients) {
          serializationObject.lifeTimeGradients = [];
          for (const lifeTimeGradient of lifeTimeGradients) {
            const serializedGradient = {
              gradient: lifeTimeGradient.gradient,
              factor1: lifeTimeGradient.factor1
            };
            if (lifeTimeGradient.factor2 !== void 0) {
              serializedGradient.factor2 = lifeTimeGradient.factor2;
            } else {
              serializedGradient.factor2 = lifeTimeGradient.factor1;
            }
            serializationObject.lifeTimeGradients.push(serializedGradient);
          }
        }
        const limitVelocityGradients = particleSystem.getLimitVelocityGradients();
        if (limitVelocityGradients) {
          serializationObject.limitVelocityGradients = [];
          for (const limitVelocityGradient of limitVelocityGradients) {
            const serializedGradient = {
              gradient: limitVelocityGradient.gradient,
              factor1: limitVelocityGradient.factor1
            };
            if (limitVelocityGradient.factor2 !== void 0) {
              serializedGradient.factor2 = limitVelocityGradient.factor2;
            } else {
              serializedGradient.factor2 = limitVelocityGradient.factor1;
            }
            serializationObject.limitVelocityGradients.push(serializedGradient);
          }
          serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;
        }
        if (particleSystem.noiseTexture) {
          serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();
        }
      }
      // Clone
      /**
       * Clones the particle system.
       * @param name The name of the cloned object
       * @param newEmitter The new emitter to use
       * @param cloneTexture Also clone the textures if true
       * @returns the cloned particle system
       */
      clone(name13, newEmitter, cloneTexture = false) {
        const custom = { ...this._customWrappers };
        let program = null;
        const engine = this._engine;
        if (engine.createEffectForParticles) {
          if (this.customShader != null) {
            program = this.customShader;
            const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join("\n") : "";
            const effect = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);
            if (!custom[0]) {
              this.setCustomEffect(effect, 0);
            } else {
              custom[0].effect = effect;
            }
          }
        }
        const serialization = this.serialize(cloneTexture);
        const result = _ParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);
        result.name = name13;
        result.customShader = program;
        result._customWrappers = custom;
        if (newEmitter === void 0) {
          newEmitter = this.emitter;
        }
        if (this.noiseTexture) {
          result.noiseTexture = this.noiseTexture.clone();
        }
        result.emitter = newEmitter;
        if (!this.preventAutoStart) {
          result.start();
        }
        return result;
      }
    };
    ParticleSystem.BILLBOARDMODE_Y = 2;
    ParticleSystem.BILLBOARDMODE_ALL = 7;
    ParticleSystem.BILLBOARDMODE_STRETCHED = 8;
    ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL = 9;
    SubEmitter._ParseParticleSystem = ParticleSystem.Parse;
  }
});

// node_modules/@babylonjs/core/Misc/sceneRecorder.js
var SceneRecorder;
var init_sceneRecorder = __esm({
  "node_modules/@babylonjs/core/Misc/sceneRecorder.js"() {
    init_sceneSerializer();
    init_mesh();
    init_light();
    init_camera();
    init_skeleton();
    init_material();
    init_multiMaterial();
    init_transformNode();
    init_particleSystem();
    init_morphTargetManager();
    init_shadowGenerator();
    init_postProcess();
    init_texture();
    init_decorators_serialization();
    SceneRecorder = class {
      constructor() {
        this._trackedScene = null;
      }
      /**
       * Track a given scene. This means the current scene state will be considered the original state
       * @param scene defines the scene to track
       */
      track(scene) {
        this._trackedScene = scene;
        SerializationHelper.AllowLoadingUniqueId = true;
        this._savedJSON = SceneSerializer.Serialize(scene);
        SerializationHelper.AllowLoadingUniqueId = false;
      }
      /**
       * Get the delta between current state and original state
       * @returns a any containing the delta
       */
      getDelta() {
        if (!this._trackedScene) {
          return null;
        }
        const currentForceSerializeBuffers = Texture.ForceSerializeBuffers;
        Texture.ForceSerializeBuffers = false;
        SerializationHelper.AllowLoadingUniqueId = true;
        const newJSON = SceneSerializer.Serialize(this._trackedScene);
        SerializationHelper.AllowLoadingUniqueId = false;
        const deltaJSON = {};
        for (const node in newJSON) {
          this._compareCollections(node, this._savedJSON[node], newJSON[node], deltaJSON);
        }
        Texture.ForceSerializeBuffers = currentForceSerializeBuffers;
        return deltaJSON;
      }
      _compareArray(key, original, current, deltaJSON) {
        if (original.length === 0 && current.length === 0) {
          return true;
        }
        if (original.length && !isNaN(original[0]) || current.length && !isNaN(current[0])) {
          if (original.length !== current.length) {
            return false;
          }
          if (original.length === 0) {
            return true;
          }
          for (let index = 0; index < original.length; index++) {
            if (original[index] !== current[index]) {
              deltaJSON[key] = current;
              return false;
            }
          }
          return true;
        }
        const originalUniqueIds = [];
        for (let index = 0; index < original.length; index++) {
          const originalObject = original[index];
          const originalUniqueId = originalObject.uniqueId;
          originalUniqueIds.push(originalUniqueId);
          const currentObjects = current.filter((c) => c.uniqueId === originalUniqueId);
          if (currentObjects.length) {
            const currentObject = currentObjects[0];
            const newObject = {};
            if (!this._compareObjects(originalObject, currentObject, newObject)) {
              if (!deltaJSON[key]) {
                deltaJSON[key] = [];
              }
              newObject.__state = {
                id: currentObject.id || currentObject.name
              };
              deltaJSON[key].push(newObject);
            }
          } else {
            const newObject = {
              __state: {
                deleteId: originalObject.id || originalObject.name
              }
            };
            if (!deltaJSON[key]) {
              deltaJSON[key] = [];
            }
            deltaJSON[key].push(newObject);
          }
        }
        for (let index = 0; index < current.length; index++) {
          const currentObject = current[index];
          const currentUniqueId = currentObject.uniqueId;
          if (originalUniqueIds.indexOf(currentUniqueId) === -1) {
            if (!deltaJSON[key]) {
              deltaJSON[key] = [];
            }
            deltaJSON[key].push(currentObject);
          }
        }
        return true;
      }
      _compareObjects(originalObjet, currentObject, deltaJSON) {
        let aDifferenceWasFound = false;
        for (const prop in originalObjet) {
          if (!Object.prototype.hasOwnProperty.call(originalObjet, prop)) {
            continue;
          }
          const originalValue = originalObjet[prop];
          const currentValue = currentObject[prop];
          let diffFound = false;
          if (Array.isArray(originalValue)) {
            diffFound = JSON.stringify(originalValue) !== JSON.stringify(currentValue);
          } else if (!isNaN(originalValue) || Object.prototype.toString.call(originalValue) == "[object String]") {
            diffFound = originalValue !== currentValue;
          } else if (typeof originalValue === "object" && typeof currentValue === "object") {
            const newObject = {};
            if (!this._compareObjects(originalValue, currentValue, newObject)) {
              deltaJSON[prop] = newObject;
              aDifferenceWasFound = true;
            }
          }
          if (diffFound) {
            aDifferenceWasFound = true;
            deltaJSON[prop] = currentValue;
          }
        }
        return !aDifferenceWasFound;
      }
      _compareCollections(key, original, current, deltaJSON) {
        if (original === current) {
          return;
        }
        if (original && current) {
          if (Array.isArray(original) && Array.isArray(current)) {
            if (this._compareArray(key, original, current, deltaJSON)) {
              return;
            }
          } else if (typeof original === "object" && typeof current === "object") {
            const newObject = {};
            if (!this._compareObjects(original, current, newObject)) {
              deltaJSON[key] = newObject;
            }
            return;
          }
        }
      }
      /**
       * Dispose the recorder.
       */
      dispose() {
        this._trackedScene = null;
        this._savedJSON = null;
      }
      static GetShadowGeneratorById(scene, id) {
        const allGenerators = scene.lights.map((l) => l.getShadowGenerators());
        for (const generators of allGenerators) {
          if (generators) {
            const iterator = generators.values();
            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
              const generator = key.value;
              if (generator && generator.id === id) {
                return generator;
              }
            }
          }
        }
        return null;
      }
      /**
       * Apply a given delta to a given scene
       * @param deltaJSON defines the JSON containing the delta
       * @param scene defines the scene to apply the delta to
       */
      static ApplyDelta(deltaJSON, scene) {
        if (typeof deltaJSON === "string") {
          deltaJSON = JSON.parse(deltaJSON);
        }
        const anyScene = scene;
        for (const prop in deltaJSON) {
          const source = deltaJSON[prop];
          const property = anyScene[prop];
          if (Array.isArray(property) || prop === "shadowGenerators") {
            switch (prop) {
              case "cameras":
                this._ApplyDeltaForEntity(source, scene, scene.getCameraById.bind(scene), (data) => Camera.Parse(data, scene));
                break;
              case "lights":
                this._ApplyDeltaForEntity(source, scene, scene.getLightById.bind(scene), (data) => Light.Parse(data, scene));
                break;
              case "shadowGenerators":
                this._ApplyDeltaForEntity(source, scene, (id) => this.GetShadowGeneratorById(scene, id), (data) => ShadowGenerator.Parse(data, scene));
                break;
              case "meshes":
                this._ApplyDeltaForEntity(source, scene, scene.getMeshById.bind(scene), (data) => Mesh.Parse(data, scene, ""));
                break;
              case "skeletons":
                this._ApplyDeltaForEntity(source, scene, scene.getSkeletonById.bind(scene), (data) => Skeleton.Parse(data, scene));
                break;
              case "materials":
                this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), (data) => Material.Parse(data, scene, ""));
                break;
              case "multiMaterials":
                this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), (data) => MultiMaterial.Parse(data, scene, ""));
                break;
              case "transformNodes":
                this._ApplyDeltaForEntity(source, scene, scene.getTransformNodeById.bind(scene), (data) => TransformNode.Parse(data, scene, ""));
                break;
              case "particleSystems":
                this._ApplyDeltaForEntity(source, scene, scene.getParticleSystemById.bind(scene), (data) => ParticleSystem.Parse(data, scene, ""));
                break;
              case "morphTargetManagers":
                this._ApplyDeltaForEntity(source, scene, scene.getMorphTargetById.bind(scene), (data) => MorphTargetManager.Parse(data, scene));
                break;
              case "postProcesses":
                this._ApplyDeltaForEntity(source, scene, scene.getPostProcessByName.bind(scene), (data) => PostProcess.Parse(data, scene, ""));
                break;
            }
          } else if (!isNaN(property)) {
            anyScene[prop] = source;
          } else if (property.fromArray) {
            property.fromArray(source);
          }
        }
      }
      static _ApplyPropertiesToEntity(deltaJSON, entity) {
        for (const prop in deltaJSON) {
          const source = deltaJSON[prop];
          const property = entity[prop];
          if (property === void 0) {
            continue;
          }
          if (!isNaN(property) || Array.isArray(property)) {
            entity[prop] = source;
          } else if (property.fromArray) {
            property.fromArray(source);
          } else if (typeof property === "object" && property !== null) {
            this._ApplyPropertiesToEntity(source, property);
          }
        }
      }
      static _ApplyDeltaForEntity(sources, scene, finder, addNew) {
        for (const source of sources) {
          if (source.__state && source.__state.id !== void 0) {
            const targetEntity = finder(source.__state.id);
            if (targetEntity) {
              this._ApplyPropertiesToEntity(source, targetEntity);
              SerializationHelper.ParseProperties(source, targetEntity, scene, null);
            }
          } else if (source.__state && source.__state.deleteId !== void 0) {
            const target = finder(source.__state.deleteId);
            target?.dispose();
          } else {
            addNew(source);
          }
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/pressureObserverWrapper.js
var PressureObserverWrapper;
var init_pressureObserverWrapper = __esm({
  "node_modules/@babylonjs/core/Misc/pressureObserverWrapper.js"() {
    init_observable();
    PressureObserverWrapper = class _PressureObserverWrapper {
      /**
       * A pressure observer will call this callback, whenever these thresholds are met.
       * @param options An object containing the thresholds used to decide what value to to return for each update property (average of start and end of a threshold boundary).
       */
      constructor(options) {
        this._observer = null;
        this._currentState = [];
        this.onPressureChanged = new Observable();
        if (_PressureObserverWrapper.IsAvailable) {
          this._observer = new PressureObserver((update) => {
            this._currentState = update;
            this.onPressureChanged.notifyObservers(update);
          }, options);
        }
      }
      /**
       * Returns true if PressureObserver is available for use, false otherwise.
       */
      static get IsAvailable() {
        return typeof PressureObserver !== "undefined" && PressureObserver.knownSources && PressureObserver.knownSources.includes("cpu");
      }
      /**
       * Method that must be called to begin observing changes, and triggering callbacks.
       * @param source defines the source to observe
       */
      observe(source) {
        try {
          this._observer?.observe(source).catch(() => {
          });
          this.onPressureChanged.notifyObservers(this._currentState);
        } catch {
        }
      }
      /**
       * Method that must be called to stop observing changes and triggering callbacks (cleanup function).
       * @param source defines the source to unobserve
       */
      unobserve(source) {
        try {
          this._observer?.unobserve(source);
        } catch {
        }
      }
      /**
       * Release the associated resources.
       */
      dispose() {
        this._observer?.disconnect();
        this._observer = null;
        this.onPressureChanged.clear();
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/PerformanceViewer/dynamicFloat32Array.js
var GrowthFactor, DynamicFloat32Array;
var init_dynamicFloat32Array = __esm({
  "node_modules/@babylonjs/core/Misc/PerformanceViewer/dynamicFloat32Array.js"() {
    GrowthFactor = 1.5;
    DynamicFloat32Array = class {
      /**
       * Creates a new DynamicFloat32Array with the desired item capacity.
       * @param itemCapacity The initial item capacity you would like to set for the array.
       */
      constructor(itemCapacity) {
        this._view = new Float32Array(itemCapacity);
        this._itemLength = 0;
      }
      /**
       * The number of items currently in the array.
       */
      get itemLength() {
        return this._itemLength;
      }
      /**
       * Gets value at index, NaN if no such index exists.
       * @param index the index to get the value at.
       * @returns the value at the index provided.
       */
      at(index) {
        if (index < 0 || index >= this._itemLength) {
          return NaN;
        }
        return this._view[index];
      }
      /**
       * Gets a view of the original array from start to end (exclusive of end).
       * @param start starting index.
       * @param end ending index.
       * @returns a subarray of the original array.
       */
      subarray(start, end) {
        if (start >= end || start < 0) {
          return new Float32Array(0);
        }
        if (end > this._itemLength) {
          end = this._itemLength;
        }
        return this._view.subarray(start, end);
      }
      /**
       * Pushes items to the end of the array.
       * @param item The item to push into the array.
       */
      push(item) {
        this._view[this._itemLength] = item;
        this._itemLength++;
        if (this._itemLength >= this._view.length) {
          this._growArray();
        }
      }
      /**
       * Grows the array by the growth factor when necessary.
       */
      _growArray() {
        const newCapacity = Math.floor(this._view.length * GrowthFactor);
        const view = new Float32Array(newCapacity);
        view.set(this._view);
        this._view = view;
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollector.js
var InitialArraySize, NumberOfBitsInHexcode, HexPadding, TimestampColHeader, NumPointsColHeader, CarriageReturnRegex, ExportedDataSeparator, PerformanceViewerCollector;
var init_performanceViewerCollector = __esm({
  "node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollector.js"() {
    init_observable();
    init_precisionDate();
    init_tools();
    init_dynamicFloat32Array();
    InitialArraySize = 1800;
    NumberOfBitsInHexcode = 24;
    HexPadding = "0";
    TimestampColHeader = "timestamp";
    NumPointsColHeader = "numPoints";
    CarriageReturnRegex = /\r/g;
    ExportedDataSeparator = "@";
    PerformanceViewerCollector = class _PerformanceViewerCollector {
      /**
       * The offset for when actual data values start appearing inside a slice.
       */
      static get SliceDataOffset() {
        return 2;
      }
      /**
       * The offset for the value of the number of points inside a slice.
       */
      static get NumberOfPointsOffset() {
        return 1;
      }
      /**
       * Handles the creation of a performance viewer collector.
       * @param _scene the scene to collect on.
       * @param _enabledStrategyCallbacks the list of data to collect with callbacks for initialization purposes.
       */
      constructor(_scene, _enabledStrategyCallbacks) {
        this._scene = _scene;
        this._collectDataAtFrame = () => {
          const timestamp = PrecisionDate.Now - this._startingTimestamp;
          const numPoints = this.datasets.ids.length;
          const numberOfIndices = this.datasets.startingIndices.itemLength;
          let startingIndex = 0;
          if (numberOfIndices > 0) {
            const previousStartingIndex = this.datasets.startingIndices.at(numberOfIndices - 1);
            startingIndex = previousStartingIndex + this.datasets.data.at(previousStartingIndex + _PerformanceViewerCollector.NumberOfPointsOffset) + _PerformanceViewerCollector.SliceDataOffset;
          }
          this.datasets.startingIndices.push(startingIndex);
          this.datasets.data.push(timestamp);
          this.datasets.data.push(numPoints);
          for (const id of this.datasets.ids) {
            const strategy = this._strategies.get(id);
            if (!strategy) {
              return;
            }
            this.datasets.data.push(strategy.getData());
          }
          if (this.datasetObservable.hasObservers()) {
            const slice = [timestamp, numPoints];
            for (let i = 0; i < numPoints; i++) {
              slice.push(this.datasets.data.at(startingIndex + _PerformanceViewerCollector.SliceDataOffset + i));
            }
            this.datasetObservable.notifyObservers(slice);
          }
        };
        this.datasets = {
          ids: [],
          data: new DynamicFloat32Array(InitialArraySize),
          startingIndices: new DynamicFloat32Array(InitialArraySize)
        };
        this._strategies = /* @__PURE__ */ new Map();
        this._datasetMeta = /* @__PURE__ */ new Map();
        this._eventRestoreSet = /* @__PURE__ */ new Set();
        this._customEventObservable = new Observable();
        this.datasetObservable = new Observable();
        this.metadataObservable = new Observable((observer) => observer.callback(this._datasetMeta, new EventState(0)));
        if (_enabledStrategyCallbacks) {
          this.addCollectionStrategies(..._enabledStrategyCallbacks);
        }
      }
      /**
       * Registers a custom string event which will be callable via sendEvent. This method returns an event object which will contain the id of the event.
       * The user can set a value optionally, which will be used in the sendEvent method. If the value is set, we will record this value at the end of each frame,
       * if not we will increment our counter and record the value of the counter at the end of each frame. The value recorded is 0 if no sendEvent method is called, within a frame.
       * @param name The name of the event to register
       * @param forceUpdate if the code should force add an event, and replace the last one.
       * @param category the category for that event
       * @returns The event registered, used in sendEvent
       */
      registerEvent(name13, forceUpdate, category) {
        if (this._strategies.has(name13) && !forceUpdate) {
          return;
        }
        if (this._strategies.has(name13) && forceUpdate) {
          this._strategies.get(name13)?.dispose();
          this._strategies.delete(name13);
        }
        const strategy = (scene) => {
          let counter = 0;
          let value = 0;
          const afterRenderObserver = scene.onAfterRenderObservable.add(() => {
            value = counter;
            counter = 0;
          });
          const stringObserver = this._customEventObservable.add((eventVal) => {
            if (name13 !== eventVal.name) {
              return;
            }
            if (eventVal.value !== void 0) {
              counter = eventVal.value;
            } else {
              counter++;
            }
          });
          return {
            id: name13,
            getData: () => value,
            dispose: () => {
              scene.onAfterRenderObservable.remove(afterRenderObserver);
              this._customEventObservable.remove(stringObserver);
            }
          };
        };
        const event = {
          name: name13
        };
        this._eventRestoreSet.add(name13);
        this.addCollectionStrategies({ strategyCallback: strategy, category });
        return event;
      }
      /**
       * Lets the perf collector handle an event, occurences or event value depending on if the event.value params is set.
       * @param event the event to handle an occurence for
       */
      sendEvent(event) {
        this._customEventObservable.notifyObservers(event);
      }
      /**
       * This event restores all custom string events if necessary.
       */
      _restoreStringEvents() {
        if (this._eventRestoreSet.size !== this._customEventObservable.observers.length) {
          this._eventRestoreSet.forEach((event) => {
            this.registerEvent(event, true);
          });
        }
      }
      /**
       * This method adds additional collection strategies for data collection purposes.
       * @param strategyCallbacks the list of data to collect with callbacks.
       */
      addCollectionStrategies(...strategyCallbacks) {
        for (let { strategyCallback, category, hidden } of strategyCallbacks) {
          const strategy = strategyCallback(this._scene);
          if (this._strategies.has(strategy.id)) {
            strategy.dispose();
            continue;
          }
          this.datasets.ids.push(strategy.id);
          if (category) {
            category = category.replace(new RegExp(ExportedDataSeparator, "g"), "");
          }
          this._datasetMeta.set(strategy.id, {
            color: this._getHexColorFromId(strategy.id),
            category,
            hidden
          });
          this._strategies.set(strategy.id, strategy);
        }
        this.metadataObservable.notifyObservers(this._datasetMeta);
      }
      /**
       * Gets a 6 character hexcode representing the colour from a passed in string.
       * @param id the string to get a hex code for.
       * @returns a hexcode hashed from the id.
       */
      _getHexColorFromId(id) {
        let hash = 0;
        for (let i = 0; i < id.length; i++) {
          hash = id.charCodeAt(i) + ((hash << 5) - hash);
        }
        let hex = "#";
        for (let i = 0; i < NumberOfBitsInHexcode; i += 8) {
          const octet = hash >> i & 255;
          const toStr = HexPadding + octet.toString(16);
          hex += toStr.substring(toStr.length - 2);
        }
        return hex;
      }
      /**
       * Collects and then sends the latest slice to any observers by using the appropriate strategy when the user wants.
       * The slice will be of the form [timestamp, numberOfPoints, value1, value2...]
       * This method does not add onto the collected data accessible via the datasets variable.
       */
      getCurrentSlice() {
        const timestamp = PrecisionDate.Now - this._startingTimestamp;
        const numPoints = this.datasets.ids.length;
        const slice = [timestamp, numPoints];
        for (const id of this.datasets.ids) {
          const strategy = this._strategies.get(id);
          if (!strategy) {
            return;
          }
          if (this.datasetObservable.hasObservers()) {
            slice.push(strategy.getData());
          }
        }
        if (this.datasetObservable.hasObservers()) {
          this.datasetObservable.notifyObservers(slice);
        }
      }
      /**
       * Updates a property for a dataset's metadata with the value provided.
       * @param id the id of the dataset which needs its metadata updated.
       * @param prop the property to update.
       * @param value the value to update the property with.
       */
      updateMetadata(id, prop, value) {
        const meta = this._datasetMeta.get(id);
        if (!meta) {
          return;
        }
        meta[prop] = value;
        this.metadataObservable.notifyObservers(this._datasetMeta);
      }
      /**
       * Completely clear, data, ids, and strategies saved to this performance collector.
       * @param preserveStringEventsRestore if it should preserve the string events, by default will clear string events registered when called.
       */
      clear(preserveStringEventsRestore) {
        this.datasets.data = new DynamicFloat32Array(InitialArraySize);
        this.datasets.ids.length = 0;
        this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);
        this._datasetMeta.clear();
        this._strategies.forEach((strategy) => strategy.dispose());
        this._strategies.clear();
        if (!preserveStringEventsRestore) {
          this._eventRestoreSet.clear();
        }
        this._hasLoadedData = false;
      }
      /**
       * Accessor which lets the caller know if the performance collector has data loaded from a file or not!
       * Call clear() to reset this value.
       * @returns true if the data is loaded from a file, false otherwise.
       */
      get hasLoadedData() {
        return this._hasLoadedData;
      }
      /**
       * Given a string containing file data, this function parses the file data into the datasets object.
       * It returns a boolean to indicate if this object was successfully loaded with the data.
       * @param data string content representing the file data.
       * @param keepDatasetMeta if it should use reuse the existing dataset metadata
       * @returns true if the data was successfully loaded, false otherwise.
       */
      loadFromFileData(data, keepDatasetMeta) {
        const lines = data.replace(CarriageReturnRegex, "").split("\n").map((line) => line.split(",").filter((s) => s.length > 0)).filter((line) => line.length > 0);
        const timestampIndex = 0;
        const numPointsIndex = _PerformanceViewerCollector.NumberOfPointsOffset;
        if (lines.length < 2) {
          return false;
        }
        const parsedDatasets = {
          ids: [],
          data: new DynamicFloat32Array(InitialArraySize),
          startingIndices: new DynamicFloat32Array(InitialArraySize)
        };
        const [firstLine, ...dataLines] = lines;
        if (firstLine.length < 2 || firstLine[timestampIndex] !== TimestampColHeader || firstLine[numPointsIndex] !== NumPointsColHeader) {
          return false;
        }
        const idCategoryMap = /* @__PURE__ */ new Map();
        for (let i = _PerformanceViewerCollector.SliceDataOffset; i < firstLine.length; i++) {
          const [id, category] = firstLine[i].split(ExportedDataSeparator);
          parsedDatasets.ids.push(id);
          idCategoryMap.set(id, category);
        }
        let startingIndex = 0;
        for (const line of dataLines) {
          if (line.length < 2) {
            return false;
          }
          const timestamp = parseFloat(line[timestampIndex]);
          const numPoints = parseInt(line[numPointsIndex]);
          if (isNaN(numPoints) || isNaN(timestamp)) {
            return false;
          }
          parsedDatasets.data.push(timestamp);
          parsedDatasets.data.push(numPoints);
          if (numPoints + _PerformanceViewerCollector.SliceDataOffset !== line.length) {
            return false;
          }
          for (let i = _PerformanceViewerCollector.SliceDataOffset; i < line.length; i++) {
            const val = parseFloat(line[i]);
            if (isNaN(val)) {
              return false;
            }
            parsedDatasets.data.push(val);
          }
          parsedDatasets.startingIndices.push(startingIndex);
          startingIndex += line.length;
        }
        this.datasets.ids = parsedDatasets.ids;
        this.datasets.data = parsedDatasets.data;
        this.datasets.startingIndices = parsedDatasets.startingIndices;
        if (!keepDatasetMeta) {
          this._datasetMeta.clear();
        }
        this._strategies.forEach((strategy) => strategy.dispose());
        this._strategies.clear();
        if (!keepDatasetMeta) {
          for (const id of this.datasets.ids) {
            const category = idCategoryMap.get(id);
            this._datasetMeta.set(id, { category, color: this._getHexColorFromId(id) });
          }
        }
        this.metadataObservable.notifyObservers(this._datasetMeta);
        this._hasLoadedData = true;
        return true;
      }
      /**
       * Exports the datasets inside of the collector to a csv.
       */
      exportDataToCsv() {
        let csvContent = "";
        csvContent += `${TimestampColHeader},${NumPointsColHeader}`;
        for (let i = 0; i < this.datasets.ids.length; i++) {
          csvContent += `,${this.datasets.ids[i]}`;
          if (this._datasetMeta) {
            const meta = this._datasetMeta.get(this.datasets.ids[i]);
            if (meta?.category) {
              csvContent += `${ExportedDataSeparator}${meta.category}`;
            }
          }
        }
        csvContent += "\n";
        for (let i = 0; i < this.datasets.startingIndices.itemLength; i++) {
          const startingIndex = this.datasets.startingIndices.at(i);
          const timestamp = this.datasets.data.at(startingIndex);
          const numPoints = this.datasets.data.at(startingIndex + _PerformanceViewerCollector.NumberOfPointsOffset);
          csvContent += `${timestamp},${numPoints}`;
          for (let offset = 0; offset < numPoints; offset++) {
            csvContent += `,${this.datasets.data.at(startingIndex + _PerformanceViewerCollector.SliceDataOffset + offset)}`;
          }
          for (let diff = 0; diff < this.datasets.ids.length - numPoints; diff++) {
            csvContent += ",";
          }
          csvContent += "\n";
        }
        const fileName = `${(/* @__PURE__ */ new Date()).toISOString()}-perfdata.csv`;
        Tools.Download(new Blob([csvContent], { type: "text/csv" }), fileName);
      }
      /**
       * Starts the realtime collection of data.
       * @param shouldPreserve optional boolean param, if set will preserve the dataset between calls of start.
       */
      start(shouldPreserve) {
        if (!shouldPreserve) {
          this.datasets.data = new DynamicFloat32Array(InitialArraySize);
          this.datasets.startingIndices = new DynamicFloat32Array(InitialArraySize);
          this._startingTimestamp = PrecisionDate.Now;
        } else if (this._startingTimestamp === void 0) {
          this._startingTimestamp = PrecisionDate.Now;
        }
        this._scene.onAfterRenderObservable.add(this._collectDataAtFrame);
        this._restoreStringEvents();
        this._isStarted = true;
      }
      /**
       * Stops the collection of data.
       */
      stop() {
        this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);
        this._isStarted = false;
      }
      /**
       * Returns if the perf collector has been started or not.
       */
      get isStarted() {
        return this._isStarted;
      }
      /**
       * Disposes of the object
       */
      dispose() {
        this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame);
        this._datasetMeta.clear();
        this._strategies.forEach((strategy) => {
          strategy.dispose();
        });
        this.datasetObservable.clear();
        this.metadataObservable.clear();
        this._isStarted = false;
        this.datasets = null;
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollectionStrategies.js
var DefaultDisposeImpl, PerfCollectionStrategy;
var init_performanceViewerCollectionStrategies = __esm({
  "node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollectionStrategies.js"() {
    init_engineInstrumentation();
    init_precisionDate();
    init_sceneInstrumentation();
    init_pressureObserverWrapper();
    DefaultDisposeImpl = () => {
    };
    PerfCollectionStrategy = class {
      /**
       * Gets the initializer for the strategy used for collection of fps metrics
       * @returns the initializer for the fps strategy
       */
      static FpsStrategy() {
        return (scene) => {
          const engine = scene.getEngine();
          return {
            id: "FPS",
            getData: () => engine.getFps(),
            dispose: DefaultDisposeImpl
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of thermal utilization metrics.
       * Needs the experimental pressure API.
       * @returns the initializer for the thermal utilization strategy
       */
      static ThermalStrategy() {
        return this._PressureStrategy("Thermal utilization", "thermal");
      }
      /**
       * Gets the initializer for the strategy used for collection of power supply utilization metrics.
       * Needs the experimental pressure API.
       * @returns the initializer for the power supply utilization strategy
       */
      static PowerSupplyStrategy() {
        return this._PressureStrategy("Power supply utilization", "power-supply");
      }
      /**
       * Gets the initializer for the strategy used for collection of pressure metrics.
       * Needs the experimental pressure API.
       * @returns the initializer for the pressure strategy
       */
      static PressureStrategy() {
        return this._PressureStrategy("Pressure");
      }
      static _PressureStrategy(name13, factor = null) {
        return () => {
          let value = 0;
          const wrapper = new PressureObserverWrapper();
          wrapper.observe("cpu");
          wrapper.onPressureChanged.add((update) => {
            for (const record of update) {
              if (factor && record.factors.includes(factor) || !factor && (record.factors?.length ?? 0) === 0) {
                switch (record.state) {
                  case "nominal":
                    value = 0;
                    break;
                  case "fair":
                    value = 0.25;
                    break;
                  case "serious":
                    value = 0.5;
                    break;
                  case "critical":
                    value = 1;
                    break;
                }
              }
            }
          });
          return {
            id: name13,
            getData: () => value,
            dispose: () => wrapper.dispose()
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of total meshes metrics.
       * @returns the initializer for the total meshes strategy
       */
      static TotalMeshesStrategy() {
        return (scene) => {
          return {
            id: "Total meshes",
            getData: () => scene.meshes.length,
            dispose: DefaultDisposeImpl
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of active meshes metrics.
       * @returns the initializer for the active meshes strategy
       */
      static ActiveMeshesStrategy() {
        return (scene) => {
          return {
            id: "Active meshes",
            getData: () => scene.getActiveMeshes().length,
            dispose: DefaultDisposeImpl
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of active indices metrics.
       * @returns the initializer for the active indices strategy
       */
      static ActiveIndicesStrategy() {
        return (scene) => {
          return {
            id: "Active indices",
            getData: () => scene.getActiveIndices(),
            dispose: DefaultDisposeImpl
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of active faces metrics.
       * @returns the initializer for the active faces strategy
       */
      static ActiveFacesStrategy() {
        return (scene) => {
          return {
            id: "Active faces",
            getData: () => scene.getActiveIndices() / 3,
            dispose: DefaultDisposeImpl
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of active bones metrics.
       * @returns the initializer for the active bones strategy
       */
      static ActiveBonesStrategy() {
        return (scene) => {
          return {
            id: "Active bones",
            getData: () => scene.getActiveBones(),
            dispose: DefaultDisposeImpl
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of active particles metrics.
       * @returns the initializer for the active particles strategy
       */
      static ActiveParticlesStrategy() {
        return (scene) => {
          return {
            id: "Active particles",
            getData: () => scene.getActiveParticles(),
            dispose: DefaultDisposeImpl
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of draw calls metrics.
       * @returns the initializer for the draw calls strategy
       */
      static DrawCallsStrategy() {
        return (scene) => {
          let drawCalls = 0;
          const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {
            scene.getEngine()._drawCalls.fetchNewFrame();
          });
          const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {
            drawCalls = scene.getEngine()._drawCalls.current;
          });
          return {
            id: "Draw calls",
            getData: () => drawCalls,
            dispose: () => {
              scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);
              scene.onAfterRenderObservable.remove(onAfterRenderObserver);
            }
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of total lights metrics.
       * @returns the initializer for the total lights strategy
       */
      static TotalLightsStrategy() {
        return (scene) => {
          return {
            id: "Total lights",
            getData: () => scene.lights.length,
            dispose: DefaultDisposeImpl
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of total vertices metrics.
       * @returns the initializer for the total vertices strategy
       */
      static TotalVerticesStrategy() {
        return (scene) => {
          return {
            id: "Total vertices",
            getData: () => scene.getTotalVertices(),
            dispose: DefaultDisposeImpl
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of total materials metrics.
       * @returns the initializer for the total materials strategy
       */
      static TotalMaterialsStrategy() {
        return (scene) => {
          return {
            id: "Total materials",
            getData: () => scene.materials.length,
            dispose: DefaultDisposeImpl
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of total textures metrics.
       * @returns the initializer for the total textures strategy
       */
      static TotalTexturesStrategy() {
        return (scene) => {
          return {
            id: "Total textures",
            getData: () => scene.textures.length,
            dispose: DefaultDisposeImpl
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of absolute fps metrics.
       * @returns the initializer for the absolute fps strategy
       */
      static AbsoluteFpsStrategy() {
        return (scene) => {
          const sceneInstrumentation = new SceneInstrumentation(scene);
          sceneInstrumentation.captureFrameTime = true;
          return {
            id: "Absolute FPS",
            getData: () => {
              return 1e3 / sceneInstrumentation.frameTimeCounter.lastSecAverage;
            },
            dispose: DefaultDisposeImpl
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of meshes selection time metrics.
       * @returns the initializer for the meshes selection time strategy
       */
      static MeshesSelectionStrategy() {
        return (scene) => {
          let startTime = PrecisionDate.Now;
          let timeTaken = 0;
          const onBeforeActiveMeshesObserver = scene.onBeforeActiveMeshesEvaluationObservable.add(() => {
            startTime = PrecisionDate.Now;
          });
          const onAfterActiveMeshesObserver = scene.onAfterActiveMeshesEvaluationObservable.add(() => {
            timeTaken = PrecisionDate.Now - startTime;
          });
          return {
            id: "Meshes Selection",
            getData: () => timeTaken,
            dispose: () => {
              scene.onBeforeActiveMeshesEvaluationObservable.remove(onBeforeActiveMeshesObserver);
              scene.onAfterActiveMeshesEvaluationObservable.remove(onAfterActiveMeshesObserver);
            }
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of render targets time metrics.
       * @returns the initializer for the render targets time strategy
       */
      static RenderTargetsStrategy() {
        return (scene) => {
          let startTime = PrecisionDate.Now;
          let timeTaken = 0;
          const onBeforeRenderTargetsObserver = scene.onBeforeRenderTargetsRenderObservable.add(() => {
            startTime = PrecisionDate.Now;
          });
          const onAfterRenderTargetsObserver = scene.onAfterRenderTargetsRenderObservable.add(() => {
            timeTaken = PrecisionDate.Now - startTime;
          });
          return {
            id: "Render Targets",
            getData: () => timeTaken,
            dispose: () => {
              scene.onBeforeRenderTargetsRenderObservable.remove(onBeforeRenderTargetsObserver);
              scene.onAfterRenderTargetsRenderObservable.remove(onAfterRenderTargetsObserver);
            }
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of particles time metrics.
       * @returns the initializer for the particles time strategy
       */
      static ParticlesStrategy() {
        return (scene) => {
          let startTime = PrecisionDate.Now;
          let timeTaken = 0;
          const onBeforeParticlesObserver = scene.onBeforeParticlesRenderingObservable.add(() => {
            startTime = PrecisionDate.Now;
          });
          const onAfterParticlesObserver = scene.onAfterParticlesRenderingObservable.add(() => {
            timeTaken = PrecisionDate.Now - startTime;
          });
          return {
            id: "Particles",
            getData: () => timeTaken,
            dispose: () => {
              scene.onBeforeParticlesRenderingObservable.remove(onBeforeParticlesObserver);
              scene.onAfterParticlesRenderingObservable.remove(onAfterParticlesObserver);
            }
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of sprites time metrics.
       * @returns the initializer for the sprites time strategy
       */
      static SpritesStrategy() {
        return (scene) => {
          let startTime = PrecisionDate.Now;
          let timeTaken = 0;
          const onBeforeSpritesObserver = scene.onBeforeSpritesRenderingObservable?.add(() => {
            startTime = PrecisionDate.Now;
          });
          const onAfterSpritesObserver = scene.onAfterSpritesRenderingObservable?.add(() => {
            timeTaken = PrecisionDate.Now - startTime;
          });
          return {
            id: "Sprites",
            getData: () => timeTaken,
            dispose: () => {
              scene.onBeforeSpritesRenderingObservable?.remove(onBeforeSpritesObserver);
              scene.onAfterSpritesRenderingObservable?.remove(onAfterSpritesObserver);
            }
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of animations time metrics.
       * @returns the initializer for the animations time strategy
       */
      static AnimationsStrategy() {
        return (scene) => {
          let startTime = PrecisionDate.Now;
          let timeTaken = 0;
          const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {
            startTime = PrecisionDate.Now;
          });
          const onAfterAnimationsObserver = scene.onAfterAnimationsObservable.add(() => {
            timeTaken = PrecisionDate.Now - startTime;
          });
          return {
            id: "Animations",
            getData: () => timeTaken,
            dispose: () => {
              scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);
              scene.onAfterAnimationsObservable.remove(onAfterAnimationsObserver);
            }
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of physics time metrics.
       * @returns the initializer for the physics time strategy
       */
      static PhysicsStrategy() {
        return (scene) => {
          let startTime = PrecisionDate.Now;
          let timeTaken = 0;
          const onBeforePhysicsObserver = scene.onBeforePhysicsObservable?.add(() => {
            startTime = PrecisionDate.Now;
          });
          const onAfterPhysicsObserver = scene.onAfterPhysicsObservable?.add(() => {
            timeTaken = PrecisionDate.Now - startTime;
          });
          return {
            id: "Physics",
            getData: () => timeTaken,
            dispose: () => {
              scene.onBeforePhysicsObservable?.remove(onBeforePhysicsObserver);
              scene.onAfterPhysicsObservable?.remove(onAfterPhysicsObserver);
            }
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of render time metrics.
       * @returns the initializer for the render time strategy
       */
      static RenderStrategy() {
        return (scene) => {
          let startTime = PrecisionDate.Now;
          let timeTaken = 0;
          const onBeforeDrawPhaseObserver = scene.onBeforeDrawPhaseObservable.add(() => {
            startTime = PrecisionDate.Now;
          });
          const onAfterDrawPhaseObserver = scene.onAfterDrawPhaseObservable.add(() => {
            timeTaken = PrecisionDate.Now - startTime;
          });
          return {
            id: "Render",
            getData: () => timeTaken,
            dispose: () => {
              scene.onBeforeDrawPhaseObservable.remove(onBeforeDrawPhaseObserver);
              scene.onAfterDrawPhaseObservable.remove(onAfterDrawPhaseObserver);
            }
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of total frame time metrics.
       * @returns the initializer for the total frame time strategy
       */
      static FrameTotalStrategy() {
        return (scene) => {
          let startTime = PrecisionDate.Now;
          let timeTaken = 0;
          const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {
            startTime = PrecisionDate.Now;
          });
          const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {
            timeTaken = PrecisionDate.Now - startTime;
          });
          return {
            id: "Frame Total",
            getData: () => timeTaken,
            dispose: () => {
              scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);
              scene.onAfterRenderObservable.remove(onAfterRenderObserver);
            }
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of inter-frame time metrics.
       * @returns the initializer for the inter-frame time strategy
       */
      static InterFrameStrategy() {
        return (scene) => {
          let startTime = PrecisionDate.Now;
          let timeTaken = 0;
          const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {
            timeTaken = PrecisionDate.Now - startTime;
          });
          const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {
            startTime = PrecisionDate.Now;
          });
          return {
            id: "Inter-frame",
            getData: () => timeTaken,
            dispose: () => {
              scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);
              scene.onAfterRenderObservable.remove(onAfterRenderObserver);
            }
          };
        };
      }
      /**
       * Gets the initializer for the strategy used for collection of gpu frame time metrics.
       * @returns the initializer for the gpu frame time strategy
       */
      static GpuFrameTimeStrategy() {
        return (scene) => {
          const engineInstrumentation = new EngineInstrumentation(scene.getEngine());
          engineInstrumentation.captureGPUFrameTime = true;
          return {
            id: "GPU frame time",
            getData: () => Math.max(engineInstrumentation.gpuFrameTimeCounter.current * 1e-6, 0),
            dispose: () => {
              engineInstrumentation.dispose();
            }
          };
        };
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerSceneExtension.js
var init_performanceViewerSceneExtension = __esm({
  "node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerSceneExtension.js"() {
    init_scene();
    init_performanceViewerCollector();
    Scene.prototype.getPerfCollector = function() {
      if (!this._perfCollector) {
        this._perfCollector = new PerformanceViewerCollector(this);
      }
      return this._perfCollector;
    };
  }
});

// node_modules/@babylonjs/core/Shaders/equirectangularPanorama.fragment.js
var name5, shader5;
var init_equirectangularPanorama_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/equirectangularPanorama.fragment.js"() {
    init_shaderStore();
    name5 = "equirectangularPanoramaPixelShader";
    shader5 = `#ifdef GL_ES
precision highp float;
#endif
#define M_PI 3.1415926535897932384626433832795
varying vec2 vUV;uniform samplerCube cubeMap;void main(void) {vec2 uv=vUV;float longitude=uv.x*2.*M_PI-M_PI+M_PI/2.;float latitude=(1.-uv.y)*M_PI;vec3 dir=vec3(
- sin( longitude )*sin( latitude ),
cos( latitude ),
- cos( longitude )*sin( latitude )
);normalize( dir );gl_FragColor=textureCube( cubeMap,dir );}`;
    if (!ShaderStore.ShadersStore[name5]) {
      ShaderStore.ShadersStore[name5] = shader5;
    }
  }
});

// node_modules/@babylonjs/core/Misc/equirectangularCapture.js
async function captureEquirectangularFromScene(scene, options) {
  const probe = options.probe ?? new ReflectionProbe("tempProbe", options.size, scene);
  const wasProbeProvided = !!options.probe;
  if (!wasProbeProvided) {
    if (options.position) {
      probe.position = options.position.clone();
    } else if (scene.activeCamera) {
      probe.position = scene.activeCamera.position.clone();
    }
  }
  const meshesToConsider = options.meshesFilter ? scene.meshes.filter(options.meshesFilter) : scene.meshes;
  probe.renderList?.push(...meshesToConsider);
  probe.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
  probe.cubeTexture.render();
  const dumpTexture = new CustomProceduralTexture("tempProceduralTexture", "equirectangularPanorama", { width: options.size * 2, height: options.size }, scene);
  dumpTexture.setTexture("cubeMap", probe.cubeTexture);
  return await new Promise((resolve, reject) => {
    dumpTexture.onGeneratedObservable.addOnce(() => {
      const pixelDataPromise = dumpTexture.readPixels();
      if (!pixelDataPromise) {
        reject(new Error("No Pixel Data found on procedural texture"));
        dumpTexture.dispose();
        if (!wasProbeProvided) {
          probe.dispose();
        }
        return;
      }
      pixelDataPromise.then((pixelData) => {
        dumpTexture.dispose();
        if (!wasProbeProvided) {
          probe.dispose();
        }
        if (options.filename) {
          DumpData(options.size * 2, options.size, pixelData, void 0, "image/png", options.filename);
          resolve(null);
        } else {
          resolve(pixelData);
        }
      });
    });
  });
}
var init_equirectangularCapture = __esm({
  "node_modules/@babylonjs/core/Misc/equirectangularCapture.js"() {
    init_reflectionProbe();
    init_renderTargetTexture();
    init_customProceduralTexture();
    init_dumpTools();
    init_equirectangularPanorama_fragment();
  }
});

// node_modules/@babylonjs/core/Misc/asyncLock.js
var AsyncLock;
var init_asyncLock = __esm({
  "node_modules/@babylonjs/core/Misc/asyncLock.js"() {
    init_deferred();
    AsyncLock = class {
      constructor() {
        this._currentOperation = Promise.resolve();
      }
      /**
       * Executes the provided function when the lock is acquired (e.g. when the previous operation finishes).
       * @param func The function to execute.
       * @param signal An optional signal that can be used to abort the operation.
       * @returns A promise that resolves when the func finishes executing.
       */
      // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
      lockAsync(func, signal) {
        signal?.throwIfAborted();
        const wrappedFunc = signal ? (
          // eslint-disable-next-line @typescript-eslint/promise-function-async
          () => {
            signal.throwIfAborted();
            return func();
          }
        ) : func;
        const newOperation = this._currentOperation.then(wrappedFunc);
        this._currentOperation = new Promise((resolve) => {
          newOperation.then(() => resolve(), resolve);
        });
        return newOperation;
      }
      /**
       * Executes the provided function when all the specified locks are acquired.
       * @param func The function to execute.
       * @param locks The locks to acquire.
       * @param signal An optional signal that can be used to abort the operation.
       * @returns A promise that resolves when the func finishes executing.
       */
      static async LockAsync(func, locks, signal) {
        signal?.throwIfAborted();
        if (locks.length === 0) {
          return await func();
        }
        const deferred = new Deferred();
        let acquiredLocks = 0;
        for (const lock of locks) {
          lock.lockAsync(async () => {
            acquiredLocks++;
            if (acquiredLocks === locks.length) {
              deferred.resolve(await func());
            }
            return await deferred.promise;
          }, signal).catch((e) => deferred.reject(e));
        }
        return await deferred.promise;
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/lazy.js
var Lazy;
var init_lazy = __esm({
  "node_modules/@babylonjs/core/Misc/lazy.js"() {
    Lazy = class {
      /**
       * Creates a new instance of the Lazy class.
       * @param factory A function that creates the value.
       */
      constructor(factory) {
        this._factory = factory;
      }
      /**
       * Gets the lazily initialized value.
       */
      get value() {
        if (this._factory) {
          this._value = this._factory();
          this._factory = void 0;
        }
        return this._value;
      }
    };
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration2.js
var name6, shader6;
var init_clipPlaneFragmentDeclaration2 = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration2.js"() {
    init_shaderStore();
    name6 = "clipPlaneFragmentDeclaration2";
    shader6 = `#ifdef CLIPPLANE
in float fClipDistance;
#endif
#ifdef CLIPPLANE2
in float fClipDistance2;
#endif
#ifdef CLIPPLANE3
in float fClipDistance3;
#endif
#ifdef CLIPPLANE4
in float fClipDistance4;
#endif
#ifdef CLIPPLANE5
in float fClipDistance5;
#endif
#ifdef CLIPPLANE6
in float fClipDistance6;
#endif
`;
    if (!ShaderStore.IncludesShadersStore[name6]) {
      ShaderStore.IncludesShadersStore[name6] = shader6;
    }
  }
});

// node_modules/@babylonjs/core/Shaders/gpuRenderParticles.fragment.js
var name7, shader7;
var init_gpuRenderParticles_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/gpuRenderParticles.fragment.js"() {
    init_shaderStore();
    init_clipPlaneFragmentDeclaration2();
    init_imageProcessingDeclaration();
    init_logDepthDeclaration();
    init_helperFunctions();
    init_imageProcessingFunctions();
    init_fogFragmentDeclaration();
    init_clipPlaneFragment();
    init_logDepthFragment();
    init_fogFragment();
    name7 = "gpuRenderParticlesPixelShader";
    shader7 = `precision highp float;
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
uniform sampler2D diffuseSampler;varying vec2 vUV;varying vec4 vColor;
#include<clipPlaneFragmentDeclaration2> 
#include<imageProcessingDeclaration>
#include<logDepthDeclaration>
#include<helperFunctions>
#include<imageProcessingFunctions>
#include<fogFragmentDeclaration>
void main() {
#include<clipPlaneFragment> 
vec4 textureColor=texture2D(diffuseSampler,vUV);gl_FragColor=textureColor*vColor;
#ifdef BLENDMULTIPLYMODE
float alpha=vColor.a*textureColor.a;gl_FragColor.rgb=gl_FragColor.rgb*alpha+vec3(1.0)*(1.0-alpha);
#endif 
#include<logDepthFragment>
#include<fogFragment>(color,gl_FragColor)
#ifdef IMAGEPROCESSINGPOSTPROCESS
gl_FragColor.rgb=toLinearSpace(gl_FragColor.rgb);
#else
#ifdef IMAGEPROCESSING
gl_FragColor.rgb=toLinearSpace(gl_FragColor.rgb);gl_FragColor=applyImageProcessing(gl_FragColor);
#endif
#endif
}
`;
    if (!ShaderStore.ShadersStore[name7]) {
      ShaderStore.ShadersStore[name7] = shader7;
    }
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration2.js
var name8, shader8;
var init_clipPlaneVertexDeclaration2 = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration2.js"() {
    init_shaderStore();
    name8 = "clipPlaneVertexDeclaration2";
    shader8 = `#ifdef CLIPPLANE
uniform vec4 vClipPlane;out float fClipDistance;
#endif
#ifdef CLIPPLANE2
uniform vec4 vClipPlane2;out float fClipDistance2;
#endif
#ifdef CLIPPLANE3
uniform vec4 vClipPlane3;out float fClipDistance3;
#endif
#ifdef CLIPPLANE4
uniform vec4 vClipPlane4;out float fClipDistance4;
#endif
#ifdef CLIPPLANE5
uniform vec4 vClipPlane5;out float fClipDistance5;
#endif
#ifdef CLIPPLANE6
uniform vec4 vClipPlane6;out float fClipDistance6;
#endif
`;
    if (!ShaderStore.IncludesShadersStore[name8]) {
      ShaderStore.IncludesShadersStore[name8] = shader8;
    }
  }
});

// node_modules/@babylonjs/core/Shaders/gpuRenderParticles.vertex.js
var name9, shader9;
var init_gpuRenderParticles_vertex = __esm({
  "node_modules/@babylonjs/core/Shaders/gpuRenderParticles.vertex.js"() {
    init_shaderStore();
    init_clipPlaneVertexDeclaration2();
    init_fogVertexDeclaration();
    init_logDepthDeclaration();
    init_clipPlaneVertex();
    init_fogVertex();
    init_logDepthVertex();
    name9 = "gpuRenderParticlesVertexShader";
    shader9 = `precision highp float;uniform mat4 view;uniform mat4 projection;uniform vec2 translationPivot;uniform vec3 worldOffset;
#ifdef LOCAL
uniform mat4 emitterWM;
#endif
attribute vec3 position;attribute float age;attribute float life;attribute vec3 size;
#ifndef BILLBOARD
attribute vec3 initialDirection;
#endif
#ifdef BILLBOARDSTRETCHED
attribute vec3 direction;
#endif
attribute float angle;
#ifdef ANIMATESHEET
attribute float cellIndex;
#endif
attribute vec2 offset;attribute vec2 uv;varying vec2 vUV;varying vec4 vColor;varying vec3 vPositionW;
#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)
uniform mat4 invView;
#endif
#include<clipPlaneVertexDeclaration2>
#include<fogVertexDeclaration>
#include<logDepthDeclaration>
#ifdef COLORGRADIENTS
uniform sampler2D colorGradientSampler;
#else
uniform vec4 colorDead;attribute vec4 color;
#endif
#ifdef ANIMATESHEET
uniform vec3 sheetInfos;
#endif
#ifdef BILLBOARD
uniform vec3 eyePosition;
#endif
vec3 rotate(vec3 yaxis,vec3 rotatedCorner) {vec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));vec3 zaxis=normalize(cross(yaxis,xaxis));vec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);vec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);vec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);mat3 rotMatrix= mat3(row0,row1,row2);vec3 alignedCorner=rotMatrix*rotatedCorner;
#ifdef LOCAL
return ((emitterWM*vec4(position,1.0)).xyz+worldOffset)+alignedCorner;
#else
return (position+worldOffset)+alignedCorner;
#endif
}
#ifdef BILLBOARDSTRETCHED
vec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {vec3 normalizedToCamera=normalize(toCamera);vec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));vec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));vec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);vec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);vec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);mat3 rotMatrix= mat3(row0,row1,row2);vec3 alignedCorner=rotMatrix*rotatedCorner;
#ifdef LOCAL
return ((emitterWM*vec4(position,1.0)).xyz+worldOffset)+alignedCorner;
#else
return (position+worldOffset)+alignedCorner;
#endif
}
#endif
void main() {
#ifdef ANIMATESHEET
float rowOffset=floor(cellIndex/sheetInfos.z);float columnOffset=cellIndex-rowOffset*sheetInfos.z;vec2 uvScale=sheetInfos.xy;vec2 uvOffset=vec2(uv.x ,1.0-uv.y);vUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;
#else
vUV=uv;
#endif
float ratio=min(1.0,age/life);
#ifdef COLORGRADIENTS
vColor=texture2D(colorGradientSampler,vec2(ratio,0));
#else
vColor=color*vec4(1.0-ratio)+colorDead*vec4(ratio);
#endif
vec2 cornerPos=(offset-translationPivot)*size.yz*size.x;
#ifdef BILLBOARD
vec4 rotatedCorner;rotatedCorner.w=0.;
#ifdef BILLBOARDY
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.y=0.;rotatedCorner.xz+=translationPivot;vec3 yaxis=(position+worldOffset)-eyePosition;yaxis.y=0.;vPositionW=rotate(normalize(yaxis),rotatedCorner.xyz);vec4 viewPosition=(view*vec4(vPositionW,1.0));
#elif defined(BILLBOARDSTRETCHED)
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;rotatedCorner.xy+=translationPivot;vec3 toCamera=(position+worldOffset)-eyePosition;vPositionW=rotateAlign(toCamera,rotatedCorner.xyz);vec4 viewPosition=(view*vec4(vPositionW,1.0));
#else
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;rotatedCorner.xy+=translationPivot;
#ifdef LOCAL
vec4 viewPosition=view*vec4(((emitterWM*vec4(position,1.0)).xyz+worldOffset),1.0)+rotatedCorner;
#else
vec4 viewPosition=view*vec4((position+worldOffset),1.0)+rotatedCorner;
#endif
vPositionW=(invView*viewPosition).xyz;
#endif
#else
vec3 rotatedCorner;rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=0.;rotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.xz+=translationPivot;vec3 yaxis=normalize(initialDirection);vPositionW=rotate(yaxis,rotatedCorner);vec4 viewPosition=view*vec4(vPositionW,1.0);
#endif
gl_Position=projection*viewPosition;
#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6) || defined(FOG)
vec4 worldPos=vec4(vPositionW,1.0);
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<logDepthVertex>
}`;
    if (!ShaderStore.ShadersStore[name9]) {
      ShaderStore.ShadersStore[name9] = shader9;
    }
  }
});

// node_modules/@babylonjs/core/Particles/gpuParticleSystem.js
var GPUParticleSystem;
var init_gpuParticleSystem = __esm({
  "node_modules/@babylonjs/core/Particles/gpuParticleSystem.js"() {
    init_gradients();
    init_observable();
    init_math_vector();
    init_math_color();
    init_math_scalar_functions();
    init_buffer();
    init_baseParticleSystem();
    init_particleSystem();
    init_boxParticleEmitter();
    init_imageProcessingConfiguration();
    init_rawTexture();
    init_engineStore();
    init_customParticleEmitter();
    init_abstractEngine();
    init_drawWrapper();
    init_typeStore();
    init_clipPlaneMaterialHelper();
    init_scene();
    init_engine_transformFeedback();
    init_gpuRenderParticles_fragment();
    init_gpuRenderParticles_vertex();
    init_materialHelper_functions();
    init_particleSystem_functions();
    GPUParticleSystem = class _GPUParticleSystem extends BaseParticleSystem {
      /**
       * Gets a boolean indicating if the GPU particles can be rendered on current browser
       */
      static get IsSupported() {
        if (!EngineStore.LastCreatedEngine) {
          return false;
        }
        const caps = EngineStore.LastCreatedEngine.getCaps();
        return caps.supportTransformFeedbacks || caps.supportComputeShaders;
      }
      _createIndexBuffer() {
        this._linesIndexBufferUseInstancing = this._engine.createIndexBuffer(new Uint32Array([0, 1, 1, 3, 3, 2, 2, 0, 0, 3]), void 0, "GPUParticleSystemLinesIndexBuffer");
      }
      /**
       * Gets the maximum number of particles active at the same time.
       * @returns The max number of active particles.
       */
      getCapacity() {
        return this._capacity;
      }
      /**
       * Gets or set the number of active particles
       * The value cannot be greater than "capacity" (if it is, it will be limited to "capacity").
       */
      get maxActiveParticleCount() {
        return this._maxActiveParticleCount;
      }
      set maxActiveParticleCount(value) {
        this._maxActiveParticleCount = Math.min(value, this._capacity);
      }
      /**
       * Gets or set the number of active particles
       * @deprecated Please use maxActiveParticleCount instead.
       */
      get activeParticleCount() {
        return this.maxActiveParticleCount;
      }
      set activeParticleCount(value) {
        this.maxActiveParticleCount = value;
      }
      /**
       * Creates a Point Emitter for the particle system (emits directly from the emitter position)
       * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
       * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
       * @returns the emitter
       */
      createPointEmitter(direction1, direction2) {
        const particleEmitter = CreatePointEmitter(direction1, direction2);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
      }
      /**
       * Creates a Hemisphere Emitter for the particle system (emits along the hemisphere radius)
       * @param radius The radius of the hemisphere to emit from
       * @param radiusRange The range of the hemisphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
       * @returns the emitter
       */
      createHemisphericEmitter(radius = 1, radiusRange = 1) {
        const particleEmitter = CreateHemisphericEmitter(radius, radiusRange);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
      }
      /**
       * Creates a Sphere Emitter for the particle system (emits along the sphere radius)
       * @param radius The radius of the sphere to emit from
       * @param radiusRange The range of the sphere to emit from [0-1] 0 Surface Only, 1 Entire Radius
       * @returns the emitter
       */
      createSphereEmitter(radius = 1, radiusRange = 1) {
        const particleEmitter = CreateSphereEmitter(radius, radiusRange);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
      }
      /**
       * Creates a Directed Sphere Emitter for the particle system (emits between direction1 and direction2)
       * @param radius The radius of the sphere to emit from
       * @param direction1 Particles are emitted between the direction1 and direction2 from within the sphere
       * @param direction2 Particles are emitted between the direction1 and direction2 from within the sphere
       * @returns the emitter
       */
      createDirectedSphereEmitter(radius = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
        const particleEmitter = CreateDirectedSphereEmitter(radius, direction1, direction2);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
      }
      /**
       * Creates a Cylinder Emitter for the particle system (emits from the cylinder to the particle position)
       * @param radius The radius of the emission cylinder
       * @param height The height of the emission cylinder
       * @param radiusRange The range of emission [0-1] 0 Surface only, 1 Entire Radius
       * @param directionRandomizer How much to randomize the particle direction [0-1]
       * @returns the emitter
       */
      createCylinderEmitter(radius = 1, height = 1, radiusRange = 1, directionRandomizer = 0) {
        const particleEmitter = CreateCylinderEmitter(radius, height, radiusRange, directionRandomizer);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
      }
      /**
       * Creates a Directed Cylinder Emitter for the particle system (emits between direction1 and direction2)
       * @param radius The radius of the cylinder to emit from
       * @param height The height of the emission cylinder
       * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)
       * @param direction1 Particles are emitted between the direction1 and direction2 from within the cylinder
       * @param direction2 Particles are emitted between the direction1 and direction2 from within the cylinder
       * @returns the emitter
       */
      createDirectedCylinderEmitter(radius = 1, height = 1, radiusRange = 1, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
        const particleEmitter = CreateDirectedCylinderEmitter(radius, height, radiusRange, direction1, direction2);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
      }
      /**
       * Creates a Cone Emitter for the particle system (emits from the cone to the particle position)
       * @param radius The radius of the cone to emit from
       * @param angle The base angle of the cone
       * @returns the emitter
       */
      createConeEmitter(radius = 1, angle = Math.PI / 4) {
        const particleEmitter = CreateConeEmitter(radius, angle);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
      }
      createDirectedConeEmitter(radius = 1, angle = Math.PI / 4, direction1 = new Vector3(0, 1, 0), direction2 = new Vector3(0, 1, 0)) {
        const particleEmitter = CreateDirectedConeEmitter(radius, angle, direction1, direction2);
        this.particleEmitterType = particleEmitter;
        return particleEmitter;
      }
      /**
       * Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)
       * @param direction1 Particles are emitted between the direction1 and direction2 from within the box
       * @param direction2 Particles are emitted between the direction1 and direction2 from within the box
       * @param minEmitBox Particles are emitted from the box between minEmitBox and maxEmitBox
       * @param maxEmitBox  Particles are emitted from the box between minEmitBox and maxEmitBox
       * @returns the emitter
       */
      createBoxEmitter(direction1, direction2, minEmitBox, maxEmitBox) {
        const particleEmitter = new BoxParticleEmitter();
        this.particleEmitterType = particleEmitter;
        this.direction1 = direction1;
        this.direction2 = direction2;
        this.minEmitBox = minEmitBox;
        this.maxEmitBox = maxEmitBox;
        return particleEmitter;
      }
      /** Gets or sets the current flow map */
      get flowMap() {
        return this._flowMap;
      }
      set flowMap(value) {
        if (this._flowMap === value) {
          return;
        }
        this._flowMap = value;
      }
      /**
       * Is this system ready to be used/rendered
       * @returns true if the system is ready
       */
      isReady() {
        if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || this._flowMap && !this._flowMap.isReady() || !this.particleTexture || !this.particleTexture.isReady() || this._rebuildingAfterContextLost) {
          return false;
        }
        if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {
          if (!this._getWrapper(this.blendMode).effect.isReady()) {
            return false;
          }
        } else {
          if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect.isReady()) {
            return false;
          }
          if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect.isReady()) {
            return false;
          }
        }
        if (!this._platform.isUpdateBufferCreated()) {
          this._recreateUpdateEffect();
          return false;
        }
        return this._platform.isUpdateBufferReady();
      }
      /**
       * Gets if the system has been started. (Note: this will still be true after stop is called)
       * @returns True if it has been started, otherwise false.
       */
      isStarted() {
        return this._started;
      }
      /**
       * Gets if the system has been stopped. (Note: rendering is still happening but the system is frozen)
       * @returns True if it has been stopped, otherwise false.
       */
      isStopped() {
        return this._stopped;
      }
      /**
       * Gets a boolean indicating that the system is stopping
       * @returns true if the system is currently stopping
       */
      isStopping() {
        return false;
      }
      /**
       * Gets the number of particles active at the same time.
       * @returns The number of active particles.
       */
      getActiveCount() {
        return this._currentActiveCount;
      }
      /**
       * Starts the particle system and begins to emit
       * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)
       */
      start(delay = this.startDelay) {
        if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {
          throw "Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set";
        }
        if (delay) {
          setTimeout(() => {
            this.start(0);
          }, delay);
          return;
        }
        this._started = true;
        this._stopped = false;
        this._actualFrame = 0;
        this._preWarmDone = false;
        if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {
          this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);
        }
      }
      /**
       * Stops the particle system.
       */
      stop() {
        if (this._stopped) {
          return;
        }
        this.onStoppedObservable.notifyObservers(this);
        this._stopped = true;
      }
      /**
       * Remove all active particles
       */
      reset() {
        this._releaseBuffers();
        this._platform.releaseVertexBuffers();
        this._currentActiveCount = 0;
        this._targetIndex = 0;
      }
      /**
       * Returns the string "GPUParticleSystem"
       * @returns a string containing the class name
       */
      getClassName() {
        return "GPUParticleSystem";
      }
      /**
       * Gets the custom effect used to render the particles
       * @param blendMode Blend mode for which the effect should be retrieved
       * @returns The effect
       */
      getCustomEffect(blendMode = 0) {
        return this._customWrappers[blendMode]?.effect ?? this._customWrappers[0].effect;
      }
      _getCustomDrawWrapper(blendMode = 0) {
        return this._customWrappers[blendMode] ?? this._customWrappers[0];
      }
      /**
       * Sets the custom effect used to render the particles
       * @param effect The effect to set
       * @param blendMode Blend mode for which the effect should be set
       */
      setCustomEffect(effect, blendMode = 0) {
        this._customWrappers[blendMode] = new DrawWrapper(this._engine);
        this._customWrappers[blendMode].effect = effect;
      }
      /**
       * Observable that will be called just before the particles are drawn
       */
      get onBeforeDrawParticlesObservable() {
        if (!this._onBeforeDrawParticlesObservable) {
          this._onBeforeDrawParticlesObservable = new Observable();
        }
        return this._onBeforeDrawParticlesObservable;
      }
      /**
       * Gets the name of the particle vertex shader
       */
      get vertexShaderName() {
        return "gpuRenderParticles";
      }
      /**
       * Gets the vertex buffers used by the particle system
       * Should be called after render() has been called for the current frame so that the buffers returned are the ones that have been updated
       * in the current frame (there's a ping-pong between two sets of buffers - for a given frame, one set is used as the source and the other as the destination)
       */
      get vertexBuffers() {
        return this._renderVertexBuffers[this._targetIndex ^ 1];
      }
      /**
       * Gets the index buffer used by the particle system (null for GPU particle systems)
       */
      get indexBuffer() {
        return null;
      }
      _removeGradientAndTexture(gradient, gradients, texture) {
        super._removeGradientAndTexture(gradient, gradients, texture);
        this._releaseBuffers();
        return this;
      }
      /**
       * Adds a new color gradient
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param color1 defines the color to affect to the specified gradient
       * @returns the current particle system
       */
      addColorGradient(gradient, color1) {
        if (!this._colorGradients) {
          this._colorGradients = [];
        }
        const colorGradient = new ColorGradient(gradient, color1);
        this._colorGradients.push(colorGradient);
        this._refreshColorGradient(true);
        this._releaseBuffers();
        return this;
      }
      _refreshColorGradient(reorder = false) {
        if (this._colorGradients) {
          if (reorder) {
            this._colorGradients.sort((a, b) => {
              if (a.gradient < b.gradient) {
                return -1;
              } else if (a.gradient > b.gradient) {
                return 1;
              }
              return 0;
            });
          }
          if (this._colorGradientsTexture) {
            this._colorGradientsTexture.dispose();
            this._colorGradientsTexture = null;
          }
        }
      }
      /** Force the system to rebuild all gradients that need to be resync */
      forceRefreshGradients() {
        this._refreshColorGradient();
        this._refreshFactorGradient(this._sizeGradients, "_sizeGradientsTexture");
        this._refreshFactorGradient(this._angularSpeedGradients, "_angularSpeedGradientsTexture");
        this._refreshFactorGradient(this._velocityGradients, "_velocityGradientsTexture");
        this._refreshFactorGradient(this._limitVelocityGradients, "_limitVelocityGradientsTexture");
        this._refreshFactorGradient(this._dragGradients, "_dragGradientsTexture");
        this.reset();
      }
      /**
       * Remove a specific color gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeColorGradient(gradient) {
        this._removeGradientAndTexture(gradient, this._colorGradients, this._colorGradientsTexture);
        this._colorGradientsTexture = null;
        return this;
      }
      /**
       * Resets the draw wrappers cache
       */
      resetDrawCache() {
        for (const blendMode in this._drawWrappers) {
          const drawWrapper = this._drawWrappers[blendMode];
          drawWrapper.drawContext?.reset();
        }
      }
      _addFactorGradient(factorGradients, gradient, factor) {
        const valueGradient = new FactorGradient(gradient, factor);
        factorGradients.push(valueGradient);
        this._releaseBuffers();
      }
      /**
       * Adds a new size gradient
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param factor defines the size factor to affect to the specified gradient
       * @returns the current particle system
       */
      addSizeGradient(gradient, factor) {
        if (!this._sizeGradients) {
          this._sizeGradients = [];
        }
        this._addFactorGradient(this._sizeGradients, gradient, factor);
        this._refreshFactorGradient(this._sizeGradients, "_sizeGradientsTexture", true);
        this._releaseBuffers();
        return this;
      }
      /**
       * Remove a specific size gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeSizeGradient(gradient) {
        this._removeGradientAndTexture(gradient, this._sizeGradients, this._sizeGradientsTexture);
        this._sizeGradientsTexture = null;
        return this;
      }
      _refreshFactorGradient(factorGradients, textureName, reorder = false) {
        if (!factorGradients) {
          return;
        }
        if (reorder) {
          factorGradients.sort((a, b) => {
            if (a.gradient < b.gradient) {
              return -1;
            } else if (a.gradient > b.gradient) {
              return 1;
            }
            return 0;
          });
        }
        const that = this;
        if (that[textureName]) {
          that[textureName].dispose();
          that[textureName] = null;
        }
      }
      /**
       * Adds a new angular speed gradient
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param factor defines the angular speed to affect to the specified gradient
       * @returns the current particle system
       */
      addAngularSpeedGradient(gradient, factor) {
        if (!this._angularSpeedGradients) {
          this._angularSpeedGradients = [];
        }
        this._addFactorGradient(this._angularSpeedGradients, gradient, factor);
        this._refreshFactorGradient(this._angularSpeedGradients, "_angularSpeedGradientsTexture", true);
        this._releaseBuffers();
        return this;
      }
      /**
       * Remove a specific angular speed gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeAngularSpeedGradient(gradient) {
        this._removeGradientAndTexture(gradient, this._angularSpeedGradients, this._angularSpeedGradientsTexture);
        this._angularSpeedGradientsTexture = null;
        return this;
      }
      /**
       * Adds a new velocity gradient
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param factor defines the velocity to affect to the specified gradient
       * @returns the current particle system
       */
      addVelocityGradient(gradient, factor) {
        if (!this._velocityGradients) {
          this._velocityGradients = [];
        }
        this._addFactorGradient(this._velocityGradients, gradient, factor);
        this._refreshFactorGradient(this._velocityGradients, "_velocityGradientsTexture", true);
        this._releaseBuffers();
        return this;
      }
      /**
       * Remove a specific velocity gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeVelocityGradient(gradient) {
        this._removeGradientAndTexture(gradient, this._velocityGradients, this._velocityGradientsTexture);
        this._velocityGradientsTexture = null;
        return this;
      }
      /**
       * Adds a new limit velocity gradient
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param factor defines the limit velocity value to affect to the specified gradient
       * @returns the current particle system
       */
      addLimitVelocityGradient(gradient, factor) {
        if (!this._limitVelocityGradients) {
          this._limitVelocityGradients = [];
        }
        this._addFactorGradient(this._limitVelocityGradients, gradient, factor);
        this._refreshFactorGradient(this._limitVelocityGradients, "_limitVelocityGradientsTexture", true);
        this._releaseBuffers();
        return this;
      }
      /**
       * Remove a specific limit velocity gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeLimitVelocityGradient(gradient) {
        this._removeGradientAndTexture(gradient, this._limitVelocityGradients, this._limitVelocityGradientsTexture);
        this._limitVelocityGradientsTexture = null;
        return this;
      }
      /**
       * Adds a new drag gradient
       * @param gradient defines the gradient to use (between 0 and 1)
       * @param factor defines the drag value to affect to the specified gradient
       * @returns the current particle system
       */
      addDragGradient(gradient, factor) {
        if (!this._dragGradients) {
          this._dragGradients = [];
        }
        this._addFactorGradient(this._dragGradients, gradient, factor);
        this._refreshFactorGradient(this._dragGradients, "_dragGradientsTexture", true);
        this._releaseBuffers();
        return this;
      }
      /**
       * Remove a specific drag gradient
       * @param gradient defines the gradient to remove
       * @returns the current particle system
       */
      removeDragGradient(gradient) {
        this._removeGradientAndTexture(gradient, this._dragGradients, this._dragGradientsTexture);
        this._dragGradientsTexture = null;
        return this;
      }
      /**
       * Not supported by GPUParticleSystem
       * @returns the current particle system
       */
      addEmitRateGradient() {
        return this;
      }
      /**
       * Not supported by GPUParticleSystem
       * @returns the current particle system
       */
      removeEmitRateGradient() {
        return this;
      }
      /**
       * Not supported by GPUParticleSystem
       * @returns the current particle system
       */
      addStartSizeGradient() {
        return this;
      }
      /**
       * Not supported by GPUParticleSystem
       * @returns the current particle system
       */
      removeStartSizeGradient() {
        return this;
      }
      /**
       * Not supported by GPUParticleSystem
       * @returns the current particle system
       */
      addColorRemapGradient() {
        return this;
      }
      /**
       * Not supported by GPUParticleSystem
       * @returns the current particle system
       */
      removeColorRemapGradient() {
        return this;
      }
      /**
       * Not supported by GPUParticleSystem
       * @returns the current particle system
       */
      addAlphaRemapGradient() {
        return this;
      }
      /**
       * Not supported by GPUParticleSystem
       * @returns the current particle system
       */
      removeAlphaRemapGradient() {
        return this;
      }
      /**
       * Not supported by GPUParticleSystem
       * @returns the current particle system
       */
      addRampGradient() {
        return this;
      }
      /**
       * Not supported by GPUParticleSystem
       * @returns the current particle system
       */
      removeRampGradient() {
        return this;
      }
      /**
       * Not supported by GPUParticleSystem
       * @returns the list of ramp gradients
       */
      getRampGradients() {
        return null;
      }
      /**
       * Not supported by GPUParticleSystem
       * Gets or sets a boolean indicating that ramp gradients must be used
       * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro#ramp-gradients
       */
      get useRampGradients() {
        return false;
      }
      set useRampGradients(value) {
      }
      /**
       * Not supported by GPUParticleSystem
       * @returns the current particle system
       */
      addLifeTimeGradient() {
        return this;
      }
      /**
       * Not supported by GPUParticleSystem
       * @returns the current particle system
       */
      removeLifeTimeGradient() {
        return this;
      }
      /**
       * Instantiates a GPU particle system.
       * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
       * @param name The name of the particle system
       * @param options The options used to create the system
       * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene
       * @param customEffect a custom effect used to change the way particles are rendered by default
       * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture
       */
      constructor(name13, options, sceneOrEngine, customEffect = null, isAnimationSheetEnabled = false) {
        super(name13);
        this.layerMask = 268435455;
        this._accumulatedCount = 0;
        this._renderVertexBuffers = [];
        this._targetIndex = 0;
        this._currentRenderId = -1;
        this._currentRenderingCameraUniqueId = -1;
        this._started = false;
        this._stopped = false;
        this._timeDelta = 0;
        this.updateInAnimate = false;
        this._actualFrame = 0;
        this._rawTextureWidth = 256;
        this._rebuildingAfterContextLost = false;
        this.doNotSerialize = false;
        this.onDisposeObservable = new Observable();
        this.onStoppedObservable = new Observable();
        this.onStartedObservable = new Observable();
        this.forceDepthWrite = false;
        this._preWarmDone = false;
        this.isLocal = false;
        this.isGPU = true;
        this.metadata = null;
        this._flowMap = null;
        this.flowMapStrength = 1;
        this._onBeforeDrawParticlesObservable = null;
        if (!sceneOrEngine || sceneOrEngine.getClassName() === "Scene") {
          this._scene = sceneOrEngine || EngineStore.LastCreatedScene;
          this._engine = this._scene.getEngine();
          this.uniqueId = this._scene.getUniqueId();
          this._scene.particleSystems.push(this);
        } else {
          this._engine = sceneOrEngine;
          this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);
        }
        if (this._engine.getCaps().supportComputeShaders) {
          if (!GetClass("BABYLON.ComputeShaderParticleSystem")) {
            throw new Error("The ComputeShaderParticleSystem class is not available! Make sure you have imported it.");
          }
          this._platform = new (GetClass("BABYLON.ComputeShaderParticleSystem"))(this, this._engine);
        } else {
          if (!GetClass("BABYLON.WebGL2ParticleSystem")) {
            throw new Error("The WebGL2ParticleSystem class is not available! Make sure you have imported it.");
          }
          this._platform = new (GetClass("BABYLON.WebGL2ParticleSystem"))(this, this._engine);
        }
        this._customWrappers = { 0: new DrawWrapper(this._engine) };
        this._customWrappers[0].effect = customEffect;
        this._drawWrappers = { 0: new DrawWrapper(this._engine) };
        if (this._drawWrappers[0].drawContext) {
          this._drawWrappers[0].drawContext.useInstancing = true;
        }
        this._createIndexBuffer();
        this._attachImageProcessingConfiguration(null);
        options = options ?? {};
        if (!options.randomTextureSize) {
          delete options.randomTextureSize;
        }
        const fullOptions = {
          capacity: 5e4,
          randomTextureSize: this._engine.getCaps().maxTextureSize,
          ...options
        };
        const optionsAsNumber = options;
        if (isFinite(optionsAsNumber)) {
          fullOptions.capacity = optionsAsNumber;
        }
        this._capacity = fullOptions.capacity;
        this._maxActiveParticleCount = fullOptions.capacity;
        this._currentActiveCount = 0;
        this._isAnimationSheetEnabled = isAnimationSheetEnabled;
        this.particleEmitterType = new BoxParticleEmitter();
        const maxTextureSize = Math.min(this._engine.getCaps().maxTextureSize, fullOptions.randomTextureSize);
        let d = [];
        for (let i = 0; i < maxTextureSize; ++i) {
          d.push(Math.random());
          d.push(Math.random());
          d.push(Math.random());
          d.push(Math.random());
        }
        this._randomTexture = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);
        this._randomTexture.name = "GPUParticleSystem_random1";
        this._randomTexture.wrapU = 1;
        this._randomTexture.wrapV = 1;
        d = [];
        for (let i = 0; i < maxTextureSize; ++i) {
          d.push(Math.random());
          d.push(Math.random());
          d.push(Math.random());
          d.push(Math.random());
        }
        this._randomTexture2 = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);
        this._randomTexture2.name = "GPUParticleSystem_random2";
        this._randomTexture2.wrapU = 1;
        this._randomTexture2.wrapV = 1;
        this._randomTextureSize = maxTextureSize;
      }
      _reset() {
        this._releaseBuffers();
      }
      _createVertexBuffers(updateBuffer, renderBuffer, spriteSource) {
        const renderVertexBuffers = {};
        renderVertexBuffers["position"] = renderBuffer.createVertexBuffer("position", 0, 3, this._attributesStrideSize, true);
        let offset = 3;
        renderVertexBuffers["age"] = renderBuffer.createVertexBuffer("age", offset, 1, this._attributesStrideSize, true);
        offset += 1;
        renderVertexBuffers["size"] = renderBuffer.createVertexBuffer("size", offset, 3, this._attributesStrideSize, true);
        offset += 3;
        renderVertexBuffers["life"] = renderBuffer.createVertexBuffer("life", offset, 1, this._attributesStrideSize, true);
        offset += 1;
        offset += 4;
        if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {
          renderVertexBuffers["direction"] = renderBuffer.createVertexBuffer("direction", offset, 3, this._attributesStrideSize, true);
        }
        offset += 3;
        if (this._platform.alignDataInBuffer) {
          offset += 1;
        }
        if (this.particleEmitterType instanceof CustomParticleEmitter) {
          offset += 3;
          if (this._platform.alignDataInBuffer) {
            offset += 1;
          }
        }
        if (!this._colorGradientsTexture) {
          renderVertexBuffers["color"] = renderBuffer.createVertexBuffer("color", offset, 4, this._attributesStrideSize, true);
          offset += 4;
        }
        if (!this._isBillboardBased) {
          renderVertexBuffers["initialDirection"] = renderBuffer.createVertexBuffer("initialDirection", offset, 3, this._attributesStrideSize, true);
          offset += 3;
          if (this._platform.alignDataInBuffer) {
            offset += 1;
          }
        }
        if (this.noiseTexture) {
          renderVertexBuffers["noiseCoordinates1"] = renderBuffer.createVertexBuffer("noiseCoordinates1", offset, 3, this._attributesStrideSize, true);
          offset += 3;
          if (this._platform.alignDataInBuffer) {
            offset += 1;
          }
          renderVertexBuffers["noiseCoordinates2"] = renderBuffer.createVertexBuffer("noiseCoordinates2", offset, 3, this._attributesStrideSize, true);
          offset += 3;
          if (this._platform.alignDataInBuffer) {
            offset += 1;
          }
        }
        renderVertexBuffers["angle"] = renderBuffer.createVertexBuffer("angle", offset, 1, this._attributesStrideSize, true);
        if (this._angularSpeedGradientsTexture) {
          offset++;
        } else {
          offset += 2;
        }
        if (this._isAnimationSheetEnabled) {
          renderVertexBuffers["cellIndex"] = renderBuffer.createVertexBuffer("cellIndex", offset, 1, this._attributesStrideSize, true);
          offset += 1;
          if (this.spriteRandomStartCell) {
            renderVertexBuffers["cellStartOffset"] = renderBuffer.createVertexBuffer("cellStartOffset", offset, 1, this._attributesStrideSize, true);
            offset += 1;
          }
        }
        renderVertexBuffers["offset"] = spriteSource.createVertexBuffer("offset", 0, 2);
        renderVertexBuffers["uv"] = spriteSource.createVertexBuffer("uv", 2, 2);
        this._renderVertexBuffers.push(renderVertexBuffers);
        this._platform.createVertexBuffers(updateBuffer, renderVertexBuffers);
        this.resetDrawCache();
      }
      _initialize(force = false) {
        if (this._buffer0 && !force) {
          return;
        }
        const engine = this._engine;
        const data = [];
        this._attributesStrideSize = 21;
        this._targetIndex = 0;
        if (this._platform.alignDataInBuffer) {
          this._attributesStrideSize += 1;
        }
        if (this.particleEmitterType instanceof CustomParticleEmitter) {
          this._attributesStrideSize += 3;
          if (this._platform.alignDataInBuffer) {
            this._attributesStrideSize += 1;
          }
        }
        if (!this.isBillboardBased) {
          this._attributesStrideSize += 3;
          if (this._platform.alignDataInBuffer) {
            this._attributesStrideSize += 1;
          }
        }
        if (this._colorGradientsTexture) {
          this._attributesStrideSize -= 4;
        }
        if (this._angularSpeedGradientsTexture) {
          this._attributesStrideSize -= 1;
        }
        if (this._isAnimationSheetEnabled) {
          this._attributesStrideSize += 1;
          if (this.spriteRandomStartCell) {
            this._attributesStrideSize += 1;
          }
        }
        if (this.noiseTexture) {
          this._attributesStrideSize += 6;
          if (this._platform.alignDataInBuffer) {
            this._attributesStrideSize += 2;
          }
        }
        if (this._platform.alignDataInBuffer) {
          this._attributesStrideSize += 3 - (this._attributesStrideSize + 3 & 3);
        }
        const usingCustomEmitter = this.particleEmitterType instanceof CustomParticleEmitter;
        const tmpVector = TmpVectors.Vector3[0];
        let offset = 0;
        for (let particleIndex = 0; particleIndex < this._capacity; particleIndex++) {
          data.push(0);
          data.push(0);
          data.push(0);
          data.push(0);
          data.push(0);
          data.push(0);
          data.push(0);
          data.push(0);
          data.push(Math.random());
          data.push(Math.random());
          data.push(Math.random());
          data.push(Math.random());
          if (usingCustomEmitter) {
            this.particleEmitterType.particleDestinationGenerator(particleIndex, null, tmpVector);
            data.push(tmpVector.x);
            data.push(tmpVector.y);
            data.push(tmpVector.z);
          } else {
            data.push(0);
            data.push(0);
            data.push(0);
          }
          if (this._platform.alignDataInBuffer) {
            data.push(0);
          }
          offset += 16;
          if (usingCustomEmitter) {
            this.particleEmitterType.particlePositionGenerator(particleIndex, null, tmpVector);
            data.push(tmpVector.x);
            data.push(tmpVector.y);
            data.push(tmpVector.z);
            if (this._platform.alignDataInBuffer) {
              data.push(0);
            }
            offset += 4;
          }
          if (!this._colorGradientsTexture) {
            data.push(0);
            data.push(0);
            data.push(0);
            data.push(0);
            offset += 4;
          }
          if (!this.isBillboardBased) {
            data.push(0);
            data.push(0);
            data.push(0);
            if (this._platform.alignDataInBuffer) {
              data.push(0);
            }
            offset += 4;
          }
          if (this.noiseTexture) {
            data.push(Math.random());
            data.push(Math.random());
            data.push(Math.random());
            if (this._platform.alignDataInBuffer) {
              data.push(0);
            }
            data.push(Math.random());
            data.push(Math.random());
            data.push(Math.random());
            if (this._platform.alignDataInBuffer) {
              data.push(0);
            }
            offset += 8;
          }
          data.push(0);
          offset += 1;
          if (!this._angularSpeedGradientsTexture) {
            data.push(0);
            offset += 1;
          }
          if (this._isAnimationSheetEnabled) {
            data.push(0);
            offset += 1;
            if (this.spriteRandomStartCell) {
              data.push(0);
              offset += 1;
            }
          }
          if (this._platform.alignDataInBuffer) {
            let numDummies = 3 - (offset + 3 & 3);
            offset += numDummies;
            while (numDummies-- > 0) {
              data.push(0);
            }
          }
        }
        const spriteData = new Float32Array([0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1, 0.5, -0.5, 1, 0, -0.5, -0.5, 0, 0]);
        const bufferData1 = this._platform.createParticleBuffer(data);
        const bufferData2 = this._platform.createParticleBuffer(data);
        this._buffer0 = new Buffer(engine, bufferData1, false, this._attributesStrideSize);
        this._buffer1 = new Buffer(engine, bufferData2, false, this._attributesStrideSize);
        this._spriteBuffer = new Buffer(engine, spriteData, false, 4);
        this._renderVertexBuffers = [];
        this._createVertexBuffers(this._buffer0, this._buffer1, this._spriteBuffer);
        this._createVertexBuffers(this._buffer1, this._buffer0, this._spriteBuffer);
        this._sourceBuffer = this._buffer0;
        this._targetBuffer = this._buffer1;
      }
      /** @internal */
      _recreateUpdateEffect() {
        this._createColorGradientTexture();
        this._createSizeGradientTexture();
        this._createAngularSpeedGradientTexture();
        this._createVelocityGradientTexture();
        this._createLimitVelocityGradientTexture();
        this._createDragGradientTexture();
        let defines = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : "";
        if (this._isBillboardBased) {
          defines += "\n#define BILLBOARD";
        }
        if (this._colorGradientsTexture) {
          defines += "\n#define COLORGRADIENTS";
        }
        if (this._sizeGradientsTexture) {
          defines += "\n#define SIZEGRADIENTS";
        }
        if (this._angularSpeedGradientsTexture) {
          defines += "\n#define ANGULARSPEEDGRADIENTS";
        }
        if (this._velocityGradientsTexture) {
          defines += "\n#define VELOCITYGRADIENTS";
        }
        if (this._limitVelocityGradientsTexture) {
          defines += "\n#define LIMITVELOCITYGRADIENTS";
        }
        if (this._dragGradientsTexture) {
          defines += "\n#define DRAGGRADIENTS";
        }
        if (this._flowMap) {
          defines += "\n#define FLOWMAP";
        }
        if (this.isAnimationSheetEnabled) {
          defines += "\n#define ANIMATESHEET";
          if (this.spriteRandomStartCell) {
            defines += "\n#define ANIMATESHEETRANDOMSTART";
          }
        }
        if (this.noiseTexture) {
          defines += "\n#define NOISE";
        }
        if (this.isLocal) {
          defines += "\n#define LOCAL";
        }
        if (this._platform.isUpdateBufferCreated() && this._cachedUpdateDefines === defines) {
          return this._platform.isUpdateBufferReady();
        }
        this._cachedUpdateDefines = defines;
        this._updateBuffer = this._platform.createUpdateBuffer(defines);
        return this._platform.isUpdateBufferReady();
      }
      /**
       * @internal
       */
      _getWrapper(blendMode) {
        const customWrapper = this._getCustomDrawWrapper(blendMode);
        if (customWrapper?.effect) {
          return customWrapper;
        }
        const defines = [];
        this.fillDefines(defines, blendMode);
        let drawWrapper = this._drawWrappers[blendMode];
        if (!drawWrapper) {
          drawWrapper = new DrawWrapper(this._engine);
          if (drawWrapper.drawContext) {
            drawWrapper.drawContext.useInstancing = true;
          }
          this._drawWrappers[blendMode] = drawWrapper;
        }
        const join = defines.join("\n");
        if (drawWrapper.defines !== join) {
          const attributes = [];
          const uniforms = [];
          const samplers = [];
          this.fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers);
          drawWrapper.setEffect(this._engine.createEffect("gpuRenderParticles", attributes, uniforms, samplers, join), join);
        }
        return drawWrapper;
      }
      /**
       * @internal
       */
      static _GetAttributeNamesOrOptions(hasColorGradients = false, isAnimationSheetEnabled = false, isBillboardBased = false, isBillboardStretched = false) {
        const attributeNamesOrOptions = [VertexBuffer.PositionKind, "age", "life", "size", "angle"];
        if (!hasColorGradients) {
          attributeNamesOrOptions.push(VertexBuffer.ColorKind);
        }
        if (isAnimationSheetEnabled) {
          attributeNamesOrOptions.push("cellIndex");
        }
        if (!isBillboardBased) {
          attributeNamesOrOptions.push("initialDirection");
        }
        if (isBillboardStretched) {
          attributeNamesOrOptions.push("direction");
        }
        attributeNamesOrOptions.push("offset", VertexBuffer.UVKind);
        return attributeNamesOrOptions;
      }
      /**
       * @internal
       */
      static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false, applyFog = false) {
        const effectCreationOption = ["emitterWM", "worldOffset", "view", "projection", "colorDead", "invView", "translationPivot", "eyePosition"];
        AddClipPlaneUniforms(effectCreationOption);
        if (isAnimationSheetEnabled) {
          effectCreationOption.push("sheetInfos");
        }
        if (useLogarithmicDepth) {
          effectCreationOption.push("logarithmicDepthConstant");
        }
        if (applyFog) {
          effectCreationOption.push("vFogInfos");
          effectCreationOption.push("vFogColor");
        }
        return effectCreationOption;
      }
      /**
       * Fill the defines array according to the current settings of the particle system
       * @param defines Array to be updated
       * @param blendMode blend mode to take into account when updating the array
       * @param fillImageProcessing fills the image processing defines
       */
      fillDefines(defines, blendMode = 0, fillImageProcessing = true) {
        if (this._scene) {
          PrepareStringDefinesForClipPlanes(this, this._scene, defines);
          if (this.applyFog && this._scene.fogEnabled && this._scene.fogMode !== Scene.FOGMODE_NONE) {
            defines.push("#define FOG");
          }
        }
        if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {
          defines.push("#define BLENDMULTIPLYMODE");
        }
        if (this.isLocal) {
          defines.push("#define LOCAL");
        }
        if (this.useLogarithmicDepth) {
          defines.push("#define LOGARITHMICDEPTH");
        }
        if (this._isBillboardBased) {
          defines.push("#define BILLBOARD");
          switch (this.billboardMode) {
            case ParticleSystem.BILLBOARDMODE_Y:
              defines.push("#define BILLBOARDY");
              break;
            case ParticleSystem.BILLBOARDMODE_STRETCHED:
              defines.push("#define BILLBOARDSTRETCHED");
              break;
            case ParticleSystem.BILLBOARDMODE_ALL:
              defines.push("#define BILLBOARDMODE_ALL");
              break;
            default:
              break;
          }
        }
        if (this._colorGradientsTexture) {
          defines.push("#define COLORGRADIENTS");
        }
        if (this.isAnimationSheetEnabled) {
          defines.push("#define ANIMATESHEET");
        }
        if (fillImageProcessing && this._imageProcessingConfiguration) {
          this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);
          defines.push("" + this._imageProcessingConfigurationDefines.toString());
        }
      }
      /**
       * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system
       * @param uniforms Uniforms array to fill
       * @param attributes Attributes array to fill
       * @param samplers Samplers array to fill
       */
      fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers) {
        attributes.push(..._GPUParticleSystem._GetAttributeNamesOrOptions(!!this._colorGradientsTexture, this._isAnimationSheetEnabled, this._isBillboardBased, this._isBillboardBased && this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED));
        uniforms.push(..._GPUParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth, this.applyFog));
        samplers.push("diffuseSampler", "colorGradientSampler");
        if (this._imageProcessingConfiguration) {
          ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);
          ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);
        }
      }
      /**
       * Animates the particle system for the current frame by emitting new particles and or animating the living ones.
       * @param preWarm defines if we are in the pre-warmimg phase
       */
      animate(preWarm = false) {
        this._timeDelta = this.updateSpeed * (preWarm ? this.preWarmStepOffset : this._scene?.getAnimationRatio() || 1);
        this._actualFrame += this._timeDelta;
        if (!this._stopped) {
          if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {
            this.stop();
          }
        }
        if (this.updateInAnimate) {
          this._update();
        }
      }
      _createFactorGradientTexture(factorGradients, textureName) {
        const texture = this[textureName];
        if (!factorGradients || !factorGradients.length || texture) {
          return;
        }
        const data = new Float32Array(this._rawTextureWidth);
        for (let x = 0; x < this._rawTextureWidth; x++) {
          const ratio = x / this._rawTextureWidth;
          GradientHelper.GetCurrentGradient(ratio, factorGradients, (currentGradient, nextGradient, scale) => {
            data[x] = Lerp(currentGradient.factor1, nextGradient.factor1, scale);
          });
        }
        this[textureName] = RawTexture.CreateRTexture(data, this._rawTextureWidth, 1, this._scene || this._engine, false, false, 1);
        this[textureName].name = textureName.substring(1);
      }
      _createSizeGradientTexture() {
        this._createFactorGradientTexture(this._sizeGradients, "_sizeGradientsTexture");
      }
      _createAngularSpeedGradientTexture() {
        this._createFactorGradientTexture(this._angularSpeedGradients, "_angularSpeedGradientsTexture");
      }
      _createVelocityGradientTexture() {
        this._createFactorGradientTexture(this._velocityGradients, "_velocityGradientsTexture");
      }
      _createLimitVelocityGradientTexture() {
        this._createFactorGradientTexture(this._limitVelocityGradients, "_limitVelocityGradientsTexture");
      }
      _createDragGradientTexture() {
        this._createFactorGradientTexture(this._dragGradients, "_dragGradientsTexture");
      }
      _createColorGradientTexture() {
        if (!this._colorGradients || !this._colorGradients.length || this._colorGradientsTexture) {
          return;
        }
        const data = new Uint8Array(this._rawTextureWidth * 4);
        const tmpColor = TmpColors.Color4[0];
        for (let x = 0; x < this._rawTextureWidth; x++) {
          const ratio = x / this._rawTextureWidth;
          GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {
            Color4.LerpToRef(currentGradient.color1, nextGradient.color1, scale, tmpColor);
            data[x * 4] = tmpColor.r * 255;
            data[x * 4 + 1] = tmpColor.g * 255;
            data[x * 4 + 2] = tmpColor.b * 255;
            data[x * 4 + 3] = tmpColor.a * 255;
          });
        }
        this._colorGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);
        this._colorGradientsTexture.name = "colorGradients";
      }
      _render(blendMode, emitterWM) {
        const drawWrapper = this._getWrapper(blendMode);
        const effect = drawWrapper.effect;
        this._engine.enableEffect(drawWrapper);
        const viewMatrix = this._scene?.getViewMatrix() || Matrix.IdentityReadOnly;
        effect.setMatrix("view", viewMatrix);
        effect.setMatrix("projection", this.defaultProjectionMatrix ?? this._scene.getProjectionMatrix());
        effect.setTexture("diffuseSampler", this.particleTexture);
        effect.setVector2("translationPivot", this.translationPivot);
        const worldOffset = this.worldOffset.subtractToRef(this._scene?.floatingOriginOffset || Vector3.ZeroReadOnly, TmpVectors.Vector3[0]);
        effect.setVector3("worldOffset", worldOffset);
        if (this.isLocal) {
          effect.setMatrix("emitterWM", emitterWM);
        }
        if (this._colorGradientsTexture) {
          effect.setTexture("colorGradientSampler", this._colorGradientsTexture);
        } else {
          effect.setDirectColor4("colorDead", this.colorDead);
        }
        if (this._isAnimationSheetEnabled && this.particleTexture) {
          const baseSize = this.particleTexture.getBaseSize();
          effect.setFloat3("sheetInfos", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);
        }
        if (this._isBillboardBased && this._scene) {
          const camera = this._scene.activeCamera;
          effect.setVector3("eyePosition", camera.globalPosition);
        }
        const defines = effect.defines;
        if (this._scene) {
          BindClipPlane(effect, this, this._scene);
          if (this.applyFog) {
            BindFogParameters(this._scene, void 0, effect);
          }
        }
        if (defines.indexOf("#define BILLBOARDMODE_ALL") >= 0) {
          const invView = viewMatrix.clone();
          invView.invert();
          effect.setMatrix("invView", invView);
        }
        if (this.useLogarithmicDepth && this._scene) {
          BindLogDepth(defines, effect, this._scene);
        }
        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
          this._imageProcessingConfiguration.bind(effect);
        }
        this._setEngineBasedOnBlendMode(blendMode);
        this._platform.bindDrawBuffers(this._targetIndex, effect, this._scene?.forceWireframe ? this._linesIndexBufferUseInstancing : null);
        if (this._onBeforeDrawParticlesObservable) {
          this._onBeforeDrawParticlesObservable.notifyObservers(effect);
        }
        if (this._scene?.forceWireframe) {
          this._engine.drawElementsType(6, 0, 10, this._currentActiveCount);
        } else {
          this._engine.drawArraysType(7, 0, 4, this._currentActiveCount);
        }
        this._engine.setAlphaMode(0);
        if (this._scene?.forceWireframe) {
          this._engine.unbindInstanceAttributes();
        }
        return this._currentActiveCount;
      }
      /** @internal */
      _update(emitterWM) {
        if (!this.emitter || !this._targetBuffer) {
          return;
        }
        if (!this._recreateUpdateEffect() || this._rebuildingAfterContextLost) {
          return;
        }
        if (!emitterWM) {
          if (this.emitter.position) {
            const emitterMesh = this.emitter;
            emitterWM = emitterMesh.getWorldMatrix();
          } else {
            const emitterPosition = this.emitter;
            emitterWM = TmpVectors.Matrix[0];
            Matrix.TranslationToRef(emitterPosition.x, emitterPosition.y, emitterPosition.z, emitterWM);
          }
        }
        const engine = this._engine;
        const depthWriteState = engine.getDepthWrite();
        engine.setDepthWrite(false);
        this._platform.preUpdateParticleBuffer();
        this._updateBuffer.setFloat("currentCount", this._currentActiveCount);
        this._updateBuffer.setFloat("timeDelta", this._timeDelta);
        this._updateBuffer.setFloat("stopFactor", this._stopped ? 0 : 1);
        this._updateBuffer.setInt("randomTextureSize", this._randomTextureSize);
        this._updateBuffer.setFloat2("lifeTime", this.minLifeTime, this.maxLifeTime);
        this._updateBuffer.setFloat2("emitPower", this.minEmitPower, this.maxEmitPower);
        if (!this._colorGradientsTexture) {
          this._updateBuffer.setDirectColor4("color1", this.color1);
          this._updateBuffer.setDirectColor4("color2", this.color2);
        }
        this._updateBuffer.setFloat2("sizeRange", this.minSize, this.maxSize);
        this._updateBuffer.setFloat4("scaleRange", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY);
        this._updateBuffer.setFloat4("angleRange", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation);
        this._updateBuffer.setVector3("gravity", this.gravity);
        if (this._limitVelocityGradientsTexture) {
          this._updateBuffer.setFloat("limitVelocityDamping", this.limitVelocityDamping);
        }
        if (this.particleEmitterType) {
          this.particleEmitterType.applyToShader(this._updateBuffer);
        }
        if (this._isAnimationSheetEnabled) {
          this._updateBuffer.setFloat4("cellInfos", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed, this.spriteCellLoop ? 1 : 0);
        }
        if (this.noiseTexture) {
          this._updateBuffer.setVector3("noiseStrength", this.noiseStrength);
        }
        if (this._flowMap) {
          const scene = this.getScene();
          this._updateBuffer.setFloat("flowMapStrength", this.flowMapStrength);
          this._updateBuffer.setMatrix("flowMapProjection", scene.getTransformMatrix());
        }
        if (!this.isLocal) {
          this._updateBuffer.setMatrix("emitterWM", emitterWM);
        }
        this._platform.updateParticleBuffer(this._targetIndex, this._targetBuffer, this._currentActiveCount);
        this._targetIndex++;
        if (this._targetIndex === 2) {
          this._targetIndex = 0;
        }
        const tmpBuffer = this._sourceBuffer;
        this._sourceBuffer = this._targetBuffer;
        this._targetBuffer = tmpBuffer;
        engine.setDepthWrite(depthWriteState);
      }
      /**
       * Renders the particle system in its current state
       * @param preWarm defines if the system should only update the particles but not render them
       * @param forceUpdateOnly if true, force to only update the particles and never display them (meaning, even if preWarm=false, when forceUpdateOnly=true the particles won't be displayed)
       * @returns the current number of particles
       */
      render(preWarm = false, forceUpdateOnly = false) {
        if (!this._started) {
          return 0;
        }
        if (!this.isReady()) {
          return 0;
        }
        if (!preWarm && this._scene) {
          if (!this._preWarmDone && this.preWarmCycles) {
            for (let index = 0; index < this.preWarmCycles; index++) {
              this.animate(true);
              this.render(true, true);
            }
            this._preWarmDone = true;
          }
          if (this._currentRenderId === this._scene.getRenderId() && (!this._scene.activeCamera || this._scene.activeCamera && this._currentRenderingCameraUniqueId === this._scene.activeCamera.uniqueId)) {
            return 0;
          }
          this._currentRenderId = this._scene.getRenderId();
          if (this._scene.activeCamera) {
            this._currentRenderingCameraUniqueId = this._scene.activeCamera.uniqueId;
          }
        }
        this._initialize();
        if (this.manualEmitCount > -1) {
          this._accumulatedCount += this.manualEmitCount;
          this.manualEmitCount = 0;
        } else {
          this._accumulatedCount += this.emitRate * this._timeDelta;
        }
        if (this._accumulatedCount >= 1) {
          const intPart = this._accumulatedCount | 0;
          this._accumulatedCount -= intPart;
          this._currentActiveCount += intPart;
        }
        this._currentActiveCount = Math.min(this._maxActiveParticleCount, this._currentActiveCount);
        if (!this._currentActiveCount) {
          return 0;
        }
        let emitterWM;
        if (this.emitter.position) {
          const emitterMesh = this.emitter;
          emitterWM = emitterMesh.getWorldMatrix();
        } else {
          const emitterPosition = this.emitter;
          emitterWM = TmpVectors.Matrix[0];
          Matrix.TranslationToRef(emitterPosition.x, emitterPosition.y, emitterPosition.z, emitterWM);
        }
        const engine = this._engine;
        if (!this.updateInAnimate) {
          this._update(emitterWM);
        }
        let outparticles = 0;
        if (!preWarm && !forceUpdateOnly) {
          engine.setState(false);
          if (this.forceDepthWrite) {
            engine.setDepthWrite(true);
          }
          if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {
            outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY, emitterWM) + this._render(ParticleSystem.BLENDMODE_ADD, emitterWM);
          } else {
            outparticles = this._render(this.blendMode, emitterWM);
          }
          this._engine.setAlphaMode(0);
        }
        return outparticles;
      }
      /**
       * Rebuilds the particle system
       */
      rebuild() {
        const checkUpdateEffect = () => {
          if (!this._recreateUpdateEffect() || !this._platform.isUpdateBufferReady()) {
            setTimeout(checkUpdateEffect, 10);
          } else {
            this._initialize(true);
            this._rebuildingAfterContextLost = false;
          }
        };
        this._createIndexBuffer();
        this._cachedUpdateDefines = "";
        this._platform.contextLost();
        this._rebuildingAfterContextLost = true;
        checkUpdateEffect();
      }
      _releaseBuffers() {
        if (this._buffer0) {
          this._buffer0.dispose();
          this._buffer0 = null;
        }
        if (this._buffer1) {
          this._buffer1.dispose();
          this._buffer1 = null;
        }
        if (this._spriteBuffer) {
          this._spriteBuffer.dispose();
          this._spriteBuffer = null;
        }
        this._platform.releaseBuffers();
      }
      /**
       * Disposes the particle system and free the associated resources
       * @param disposeTexture defines if the particule texture must be disposed as well (true by default)
       */
      dispose(disposeTexture = true) {
        for (const blendMode in this._drawWrappers) {
          const drawWrapper = this._drawWrappers[blendMode];
          drawWrapper.dispose();
        }
        this._drawWrappers = {};
        if (this._scene) {
          const index = this._scene.particleSystems.indexOf(this);
          if (index > -1) {
            this._scene.particleSystems.splice(index, 1);
          }
        }
        this._releaseBuffers();
        this._platform.releaseVertexBuffers();
        for (let i = 0; i < this._renderVertexBuffers.length; ++i) {
          const rvb = this._renderVertexBuffers[i];
          for (const key in rvb) {
            rvb[key].dispose();
          }
        }
        this._renderVertexBuffers = [];
        if (this._colorGradientsTexture) {
          this._colorGradientsTexture.dispose();
          this._colorGradientsTexture = null;
        }
        if (this._sizeGradientsTexture) {
          this._sizeGradientsTexture.dispose();
          this._sizeGradientsTexture = null;
        }
        if (this._angularSpeedGradientsTexture) {
          this._angularSpeedGradientsTexture.dispose();
          this._angularSpeedGradientsTexture = null;
        }
        if (this._velocityGradientsTexture) {
          this._velocityGradientsTexture.dispose();
          this._velocityGradientsTexture = null;
        }
        if (this._limitVelocityGradientsTexture) {
          this._limitVelocityGradientsTexture.dispose();
          this._limitVelocityGradientsTexture = null;
        }
        if (this._dragGradientsTexture) {
          this._dragGradientsTexture.dispose();
          this._dragGradientsTexture = null;
        }
        if (this._randomTexture) {
          this._randomTexture.dispose();
          this._randomTexture = null;
        }
        if (this._randomTexture2) {
          this._randomTexture2.dispose();
          this._randomTexture2 = null;
        }
        if (disposeTexture && this.particleTexture) {
          this.particleTexture.dispose();
          this.particleTexture = null;
        }
        if (disposeTexture && this.noiseTexture) {
          this.noiseTexture.dispose();
          this.noiseTexture = null;
        }
        this.onStoppedObservable.clear();
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
      }
      /**
       * Clones the particle system.
       * @param name The name of the cloned object
       * @param newEmitter The new emitter to use
       * @param cloneTexture Also clone the textures if true
       * @returns the cloned particle system
       */
      clone(name13, newEmitter, cloneTexture = false) {
        const custom = { ...this._customWrappers };
        let program = null;
        const engine = this._engine;
        if (engine.createEffectForParticles) {
          if (this.customShader != null) {
            program = this.customShader;
            const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join("\n") : "";
            custom[0] = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines, void 0, void 0, void 0, this);
          }
        }
        const serialization = this.serialize(cloneTexture);
        const result = _GPUParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);
        result.name = name13;
        result.customShader = program;
        result._customWrappers = custom;
        if (newEmitter === void 0) {
          newEmitter = this.emitter;
        }
        if (this.noiseTexture) {
          result.noiseTexture = this.noiseTexture.clone();
        }
        result.emitter = newEmitter;
        return result;
      }
      /**
       * Serializes the particle system to a JSON object
       * @param serializeTexture defines if the texture must be serialized as well
       * @returns the JSON object
       */
      serialize(serializeTexture = false) {
        const serializationObject = {};
        ParticleSystem._Serialize(serializationObject, this, serializeTexture);
        serializationObject.activeParticleCount = this.activeParticleCount;
        serializationObject.randomTextureSize = this._randomTextureSize;
        serializationObject.customShader = this.customShader;
        serializationObject.preventAutoStart = this.preventAutoStart;
        serializationObject.worldOffset = this.worldOffset.asArray();
        if (this.metadata) {
          serializationObject.metadata = this.metadata;
        }
        return serializationObject;
      }
      /**
       * Parses a JSON object to create a GPU particle system.
       * @param parsedParticleSystem The JSON object to parse
       * @param sceneOrEngine The scene or the engine to create the particle system in
       * @param rootUrl The root url to use to load external dependencies like texture
       * @param doNotStart Ignore the preventAutoStart attribute and does not start
       * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)
       * @returns the parsed GPU particle system
       */
      static Parse(parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart = false, capacity) {
        const name13 = parsedParticleSystem.name;
        let engine;
        let scene;
        if (sceneOrEngine instanceof AbstractEngine) {
          engine = sceneOrEngine;
        } else {
          scene = sceneOrEngine;
          engine = scene.getEngine();
        }
        const particleSystem = new _GPUParticleSystem(name13, { capacity: capacity || parsedParticleSystem.capacity, randomTextureSize: parsedParticleSystem.randomTextureSize }, sceneOrEngine, null, parsedParticleSystem.isAnimationSheetEnabled);
        particleSystem._rootUrl = rootUrl;
        if (parsedParticleSystem.customShader && engine.createEffectForParticles) {
          const program = parsedParticleSystem.customShader;
          const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join("\n") : "";
          const custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines, void 0, void 0, void 0, particleSystem);
          particleSystem.setCustomEffect(custom, 0);
          particleSystem.customShader = program;
        }
        if (parsedParticleSystem.id) {
          particleSystem.id = parsedParticleSystem.id;
        }
        if (parsedParticleSystem.activeParticleCount) {
          particleSystem.activeParticleCount = parsedParticleSystem.activeParticleCount;
        }
        ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);
        if (parsedParticleSystem.worldOffset) {
          particleSystem.worldOffset = Vector3.FromArray(parsedParticleSystem.worldOffset);
        }
        if (parsedParticleSystem.preventAutoStart) {
          particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;
        }
        if (parsedParticleSystem.metadata) {
          particleSystem.metadata = parsedParticleSystem.metadata;
        }
        if (!doNotStart && !particleSystem.preventAutoStart) {
          particleSystem.start();
        }
        return particleSystem;
      }
    };
  }
});

// node_modules/@babylonjs/core/Particles/particleSystemSet.js
var ParticleSystemSet;
var init_particleSystemSet = __esm({
  "node_modules/@babylonjs/core/Particles/particleSystemSet.js"() {
    init_math_color();
    init_sphereBuilder();
    init_gpuParticleSystem();
    init_engineStore();
    init_particleSystem();
    init_standardMaterial();
    ParticleSystemSet = class _ParticleSystemSet {
      constructor() {
        this._emitterNodeIsOwned = true;
        this.systems = [];
      }
      /**
       * Gets or sets the emitter node used with this set
       */
      get emitterNode() {
        return this._emitterNode;
      }
      set emitterNode(value) {
        if (this._emitterNodeIsOwned && this._emitterNode) {
          if (this._emitterNode.dispose) {
            this._emitterNode.dispose();
          }
          this._emitterNodeIsOwned = false;
        }
        for (const system of this.systems) {
          system.emitter = value;
        }
        this._emitterNode = value;
      }
      /**
       * Creates a new emitter mesh as a sphere
       * @param options defines the options used to create the sphere
       * @param options.diameter
       * @param options.segments
       * @param options.color
       * @param renderingGroupId defines the renderingGroupId to use for the sphere
       * @param scene defines the hosting scene
       */
      setEmitterAsSphere(options, renderingGroupId, scene) {
        if (this._emitterNodeIsOwned && this._emitterNode) {
          if (this._emitterNode.dispose) {
            this._emitterNode.dispose();
          }
        }
        this._emitterNodeIsOwned = true;
        this._emitterCreationOptions = {
          kind: "Sphere",
          options,
          renderingGroupId
        };
        const emitterMesh = CreateSphere("emitterSphere", { diameter: options.diameter, segments: options.segments }, scene);
        emitterMesh.renderingGroupId = renderingGroupId;
        const material = new StandardMaterial("emitterSphereMaterial", scene);
        material.emissiveColor = options.color;
        emitterMesh.material = material;
        for (const system of this.systems) {
          system.emitter = emitterMesh;
        }
        this._emitterNode = emitterMesh;
      }
      /**
       * Starts all particle systems of the set
       * @param emitter defines an optional mesh to use as emitter for the particle systems
       */
      start(emitter) {
        for (const system of this.systems) {
          if (emitter) {
            system.emitter = emitter;
          }
          system.start();
        }
      }
      /**
       * Release all associated resources
       */
      dispose() {
        for (const system of this.systems) {
          system.dispose();
        }
        this.systems.length = 0;
        if (this._emitterNode) {
          if (this._emitterNode.dispose) {
            this._emitterNode.dispose();
          }
          this._emitterNode = null;
        }
      }
      /**
       * Serialize the set into a JSON compatible object
       * @param serializeTexture defines if the texture must be serialized as well
       * @returns a JSON compatible representation of the set
       */
      serialize(serializeTexture = false) {
        const result = {};
        result.systems = [];
        for (const system of this.systems) {
          if (!system.doNotSerialize) {
            result.systems.push(system.serialize(serializeTexture));
          }
        }
        if (this._emitterNode) {
          result.emitter = this._emitterCreationOptions;
        }
        return result;
      }
      /**
       * Parse a new ParticleSystemSet from a serialized source
       * @param data defines a JSON compatible representation of the set
       * @param scene defines the hosting scene
       * @param gpu defines if we want GPU particles or CPU particles
       * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)
       * @returns a new ParticleSystemSet
       */
      static Parse(data, scene, gpu = false, capacity) {
        const result = new _ParticleSystemSet();
        const rootUrl = this.BaseAssetsUrl + "/textures/";
        scene = scene || EngineStore.LastCreatedScene;
        for (const system of data.systems) {
          result.systems.push(gpu ? GPUParticleSystem.Parse(system, scene, rootUrl, true, capacity) : ParticleSystem.Parse(system, scene, rootUrl, true, capacity));
        }
        if (data.emitter) {
          const options = data.emitter.options;
          switch (data.emitter.kind) {
            case "Sphere":
              result.setEmitterAsSphere({
                diameter: options.diameter,
                segments: options.segments,
                color: Color3.FromArray(options.color)
              }, data.emitter.renderingGroupId, scene);
              break;
          }
        }
        return result;
      }
    };
    ParticleSystemSet.BaseAssetsUrl = "https://assets.babylonjs.com/particles";
  }
});

// node_modules/@babylonjs/core/Particles/particleHelper.js
var ParticleHelper;
var init_particleHelper = __esm({
  "node_modules/@babylonjs/core/Particles/particleHelper.js"() {
    init_tools();
    init_math_color();
    init_texture();
    init_engineStore();
    init_gpuParticleSystem();
    init_particleSystemSet();
    init_particleSystem();
    init_webRequest();
    ParticleHelper = class _ParticleHelper {
      /**
       * Create a default particle system that you can tweak
       * @param emitter defines the emitter to use
       * @param capacity defines the system capacity (default is 500 particles)
       * @param scene defines the hosting scene
       * @param useGPU defines if a GPUParticleSystem must be created (default is false)
       * @returns the new Particle system
       */
      static CreateDefault(emitter, capacity = 500, scene, useGPU = false) {
        let system;
        if (useGPU) {
          system = new GPUParticleSystem("default system", { capacity }, scene);
        } else {
          system = new ParticleSystem("default system", capacity, scene);
        }
        system.emitter = emitter;
        const textureUrl = Tools.GetAssetUrl("https://assets.babylonjs.com/core/textures/flare.png");
        system.particleTexture = new Texture(textureUrl, system.getScene());
        system.createConeEmitter(0.1, Math.PI / 4);
        system.color1 = new Color4(1, 1, 1, 1);
        system.color2 = new Color4(1, 1, 1, 1);
        system.colorDead = new Color4(1, 1, 1, 0);
        system.minSize = 0.1;
        system.maxSize = 0.1;
        system.minEmitPower = 2;
        system.maxEmitPower = 2;
        system.updateSpeed = 1 / 60;
        system.emitRate = 30;
        return system;
      }
      /**
       * This is the main static method (one-liner) of this helper to create different particle systems
       * @param type This string represents the type to the particle system to create
       * @param scene The scene where the particle system should live
       * @param gpu If the system will use gpu
       * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)
       * @returns the ParticleSystemSet created
       */
      // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
      static CreateAsync(type, scene, gpu = false, capacity) {
        if (!scene) {
          scene = EngineStore.LastCreatedScene;
        }
        const token = {};
        scene.addPendingData(token);
        return new Promise((resolve, reject) => {
          if (gpu && !GPUParticleSystem.IsSupported) {
            scene.removePendingData(token);
            return reject("Particle system with GPU is not supported.");
          }
          Tools.LoadFile(`${_ParticleHelper.BaseAssetsUrl}/systems/${type}.json`, (data) => {
            scene.removePendingData(token);
            const newData = JSON.parse(data.toString());
            return resolve(ParticleSystemSet.Parse(newData, scene, gpu, capacity));
          }, void 0, void 0, void 0, () => {
            scene.removePendingData(token);
            return reject(`An error occurred with the creation of your particle system. Check if your type '${type}' exists.`);
          });
        });
      }
      /**
       * Static function used to export a particle system to a ParticleSystemSet variable.
       * Please note that the emitter shape is not exported
       * @param systems defines the particle systems to export
       * @returns the created particle system set
       */
      static ExportSet(systems) {
        const set = new ParticleSystemSet();
        for (const system of systems) {
          set.systems.push(system);
        }
        return set;
      }
      /**
       * Creates a particle system from a snippet saved in a remote file
       * @param name defines the name of the particle system to create (can be null or empty to use the one from the json data)
       * @param url defines the url to load from
       * @param scene defines the hosting scene
       * @param gpu If the system will use gpu
       * @param rootUrl defines the root URL to use to load textures and relative dependencies
       * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)
       * @returns a promise that will resolve to the new particle system
       */
      // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
      static ParseFromFileAsync(name13, url, scene, gpu = false, rootUrl = "", capacity) {
        return new Promise((resolve, reject) => {
          const request = new WebRequest();
          request.addEventListener("readystatechange", () => {
            if (request.readyState == 4) {
              if (request.status == 200) {
                const serializationObject = JSON.parse(request.responseText);
                let output;
                if (gpu) {
                  output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);
                } else {
                  output = ParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);
                }
                if (name13) {
                  output.name = name13;
                }
                resolve(output);
              } else {
                reject("Unable to load the particle system");
              }
            }
          });
          request.open("GET", url);
          request.send();
        });
      }
      /**
       * Creates a particle system from a snippet saved by the particle system editor
       * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)
       * @param scene defines the hosting scene
       * @param gpu If the system will use gpu
       * @param rootUrl defines the root URL to use to load textures and relative dependencies
       * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)
       * @returns a promise that will resolve to the new particle system
       */
      // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
      static ParseFromSnippetAsync(snippetId, scene, gpu = false, rootUrl = "", capacity) {
        if (snippetId === "_BLANK") {
          const system = this.CreateDefault(null);
          system.start();
          return Promise.resolve(system);
        }
        return new Promise((resolve, reject) => {
          const request = new WebRequest();
          request.addEventListener("readystatechange", () => {
            if (request.readyState == 4) {
              if (request.status == 200) {
                const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
                const serializationObject = JSON.parse(snippet.particleSystem);
                let output;
                if (gpu) {
                  output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);
                } else {
                  output = ParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);
                }
                output.snippetId = snippetId;
                resolve(output);
              } else {
                reject("Unable to load the snippet " + snippetId);
              }
            }
          });
          request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
          request.send();
        });
      }
    };
    ParticleHelper.BaseAssetsUrl = ParticleSystemSet.BaseAssetsUrl;
    ParticleHelper.SnippetUrl = `https://snippet.babylonjs.com`;
    ParticleHelper.CreateFromSnippetAsync = ParticleHelper.ParseFromSnippetAsync;
  }
});

// node_modules/@babylonjs/core/Particles/flowMap.js
var FlowVector, ScaledFlowVector, ScreenPos, FlowMap;
var init_flowMap = __esm({
  "node_modules/@babylonjs/core/Particles/flowMap.js"() {
    init_math_vector();
    init_textureTools();
    FlowVector = new Vector3(0, 0, 0);
    ScaledFlowVector = new Vector3(0, 0, 0);
    ScreenPos = new Vector3(0, 0, 0);
    FlowMap = class _FlowMap {
      /**
       * Create a new flow map.
       * @param width defines the width of the flow map
       * @param height defines the height of the flow map
       * @param data defines the data of the flow map
       */
      constructor(width, height, data) {
        this.width = width;
        this.height = height;
        this.data = data;
      }
      processFlowable(flowable, strength = 1, flowMapSamplePosOrTransformationMatrix) {
        if (!flowMapSamplePosOrTransformationMatrix) {
          return;
        }
        if (flowMapSamplePosOrTransformationMatrix instanceof Matrix) {
          Vector3.TransformCoordinatesToRef(flowable.position, flowMapSamplePosOrTransformationMatrix, ScreenPos);
        } else {
          ScreenPos.x = flowMapSamplePosOrTransformationMatrix.x;
          ScreenPos.y = flowMapSamplePosOrTransformationMatrix.y;
          ScreenPos.z = flowMapSamplePosOrTransformationMatrix.z;
        }
        const u = ScreenPos.x * 0.5 + 0.5;
        const v = 1 - (ScreenPos.y * 0.5 + 0.5);
        const x = Math.floor(u * this.width);
        const y = Math.floor(v * this.height);
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
          return;
        }
        const index = (y * this.width + x) * 4;
        const r = this.data[index];
        const g = this.data[index + 1];
        const b = this.data[index + 2];
        const a = this.data[index + 3];
        const fx = r / 255 * 2 - 1;
        const fy = g / 255 * 2 - 1;
        const fz = b / 255 * 2 - 1;
        const localStrength = a / 255;
        FlowVector.set(fx, fy, fz);
        FlowVector.scaleToRef(strength * localStrength, ScaledFlowVector);
        flowable.direction.addInPlace(ScaledFlowVector);
      }
      /** @internal */
      _processParticle(particle, strength = 1, matrix) {
        this.processFlowable(particle, strength, matrix);
      }
      /**
       * Creates a FlowMap from a url.
       * @param url The url of the image to load
       * @returns a promise that resolves to a FlowMap object
       */
      static async FromUrlAsync(url) {
        return await new Promise((resolve, reject) => {
          const flowCanvas = document.createElement("canvas");
          const flowCtx = flowCanvas.getContext("2d");
          let flowImageData = null;
          const flowMapImage = new Image();
          flowMapImage.crossOrigin = "anonymous";
          flowMapImage.src = url;
          flowMapImage.onerror = (e) => {
            reject(new Error(`Failed to load image: ${url} : ${e}`));
          };
          flowMapImage.onload = () => {
            flowCanvas.width = flowMapImage.width;
            flowCanvas.height = flowMapImage.height;
            flowCtx.drawImage(flowMapImage, 0, 0);
            flowImageData = flowCtx.getImageData(0, 0, flowCanvas.width, flowCanvas.height);
            resolve(new _FlowMap(flowCanvas.width, flowCanvas.height, flowImageData.data));
          };
        });
      }
      /**
       * Load from a texture
       * @param texture defines the source texture
       * @returns a promise fulfilled when image data is loaded
       */
      static async ExtractFromTextureAsync(texture) {
        const data = await TextureTools.GetTextureDataAsync(texture);
        const { width, height } = texture.getSize();
        return new _FlowMap(width, height, new Uint8ClampedArray(data));
      }
    };
  }
});

// node_modules/@babylonjs/core/Particles/Node/Enums/nodeParticleBlockConnectionPointTypes.js
var NodeParticleBlockConnectionPointTypes;
var init_nodeParticleBlockConnectionPointTypes = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Enums/nodeParticleBlockConnectionPointTypes.js"() {
    (function(NodeParticleBlockConnectionPointTypes2) {
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["Int"] = 1] = "Int";
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["Float"] = 2] = "Float";
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["Vector2"] = 4] = "Vector2";
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["Vector3"] = 8] = "Vector3";
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["Matrix"] = 16] = "Matrix";
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["Particle"] = 32] = "Particle";
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["Texture"] = 64] = "Texture";
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["Color4"] = 128] = "Color4";
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["FloatGradient"] = 256] = "FloatGradient";
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["Vector2Gradient"] = 512] = "Vector2Gradient";
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["Vector3Gradient"] = 1024] = "Vector3Gradient";
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["Color4Gradient"] = 2048] = "Color4Gradient";
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["System"] = 4096] = "System";
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["AutoDetect"] = 8192] = "AutoDetect";
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["BasedOnInput"] = 16384] = "BasedOnInput";
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["Undefined"] = 32768] = "Undefined";
      NodeParticleBlockConnectionPointTypes2[NodeParticleBlockConnectionPointTypes2["All"] = 65535] = "All";
    })(NodeParticleBlockConnectionPointTypes || (NodeParticleBlockConnectionPointTypes = {}));
  }
});

// node_modules/@babylonjs/core/Particles/Node/nodeParticleBlockConnectionPoint.js
var NodeParticleConnectionPointCompatibilityStates, NodeParticleConnectionPointDirection, NodeParticleConnectionPoint;
var init_nodeParticleBlockConnectionPoint = __esm({
  "node_modules/@babylonjs/core/Particles/Node/nodeParticleBlockConnectionPoint.js"() {
    init_observable();
    init_nodeParticleBlockConnectionPointTypes();
    (function(NodeParticleConnectionPointCompatibilityStates2) {
      NodeParticleConnectionPointCompatibilityStates2[NodeParticleConnectionPointCompatibilityStates2["Compatible"] = 0] = "Compatible";
      NodeParticleConnectionPointCompatibilityStates2[NodeParticleConnectionPointCompatibilityStates2["TypeIncompatible"] = 1] = "TypeIncompatible";
      NodeParticleConnectionPointCompatibilityStates2[NodeParticleConnectionPointCompatibilityStates2["HierarchyIssue"] = 2] = "HierarchyIssue";
    })(NodeParticleConnectionPointCompatibilityStates || (NodeParticleConnectionPointCompatibilityStates = {}));
    (function(NodeParticleConnectionPointDirection2) {
      NodeParticleConnectionPointDirection2[NodeParticleConnectionPointDirection2["Input"] = 0] = "Input";
      NodeParticleConnectionPointDirection2[NodeParticleConnectionPointDirection2["Output"] = 1] = "Output";
    })(NodeParticleConnectionPointDirection || (NodeParticleConnectionPointDirection = {}));
    NodeParticleConnectionPoint = class {
      /** Gets the direction of the point */
      get direction() {
        return this._direction;
      }
      /**
       * Gets or sets the connection point type (default is float)
       */
      get type() {
        if (this._type === NodeParticleBlockConnectionPointTypes.AutoDetect) {
          if (this._ownerBlock.isInput) {
            return this._ownerBlock.type;
          }
          if (this._connectedPoint) {
            return this._connectedPoint.type;
          }
          if (this._linkedConnectionSource) {
            if (this._linkedConnectionSource.isConnected) {
              return this._linkedConnectionSource.type;
            }
            if (this._linkedConnectionSource._defaultConnectionPointType) {
              return this._linkedConnectionSource._defaultConnectionPointType;
            }
          }
          if (this._defaultConnectionPointType) {
            return this._defaultConnectionPointType;
          }
        }
        if (this._type === NodeParticleBlockConnectionPointTypes.BasedOnInput) {
          if (this._typeConnectionSource) {
            if (!this._typeConnectionSource.isConnected && this._defaultConnectionPointType) {
              return this._defaultConnectionPointType;
            }
            if (this._typeConnectionSourceTranslation) {
              return this._typeConnectionSourceTranslation(this._typeConnectionSource.type);
            }
            return this._typeConnectionSource.type;
          } else if (this._defaultConnectionPointType) {
            return this._defaultConnectionPointType;
          }
        }
        return this._type;
      }
      set type(value) {
        this._type = value;
      }
      /**
       * Gets a boolean indicating that the current point is connected to another NodeMaterialBlock
       */
      get isConnected() {
        return this.connectedPoint !== null || this.hasEndpoints;
      }
      /** Get the other side of the connection (if any) */
      get connectedPoint() {
        return this._connectedPoint;
      }
      /** Get the block that owns this connection point */
      get ownerBlock() {
        return this._ownerBlock;
      }
      /** Get the block connected on the other side of this connection (if any) */
      get sourceBlock() {
        if (!this._connectedPoint) {
          return null;
        }
        return this._connectedPoint.ownerBlock;
      }
      /** Get the block connected on the endpoints of this connection (if any) */
      get connectedBlocks() {
        if (this._endpoints.length === 0) {
          return [];
        }
        return this._endpoints.map((e) => e.ownerBlock);
      }
      /** Gets the list of connected endpoints */
      get endpoints() {
        return this._endpoints;
      }
      /** Gets a boolean indicating if that output point is connected to at least one input */
      get hasEndpoints() {
        return this._endpoints && this._endpoints.length > 0;
      }
      /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */
      get innerType() {
        if (this._linkedConnectionSource && !this._isMainLinkSource && this._linkedConnectionSource.isConnected) {
          return this.type;
        }
        return this._type;
      }
      /**
       * Creates a new connection point
       * @param name defines the connection point name
       * @param ownerBlock defines the block hosting this connection point
       * @param direction defines the direction of the connection point
       */
      constructor(name13, ownerBlock, direction) {
        this._connectedPoint = null;
        this._storedValue = null;
        this._storedFunction = null;
        this._acceptedConnectionPointType = null;
        this._endpoints = new Array();
        this._type = NodeParticleBlockConnectionPointTypes.Particle;
        this._linkedConnectionSource = null;
        this._typeConnectionSource = null;
        this._typeConnectionSourceTranslation = null;
        this._defaultConnectionPointType = null;
        this._isMainLinkSource = false;
        this.acceptedConnectionPointTypes = [];
        this.excludedConnectionPointTypes = [];
        this.onConnectionObservable = new Observable();
        this.onDisconnectionObservable = new Observable();
        this.isExposedOnFrame = false;
        this.exposedPortPosition = -1;
        this.defaultValue = null;
        this.value = null;
        this.valueMin = null;
        this.valueMax = null;
        this._ownerBlock = ownerBlock;
        this.name = name13;
        this._direction = direction;
      }
      /**
       * Gets the current class name e.g. "NodeMaterialConnectionPoint"
       * @returns the class name
       */
      getClassName() {
        return "NodeParticleConnectionPoint";
      }
      /**
       * Gets the value represented by this connection point
       * @param state current evaluation state
       * @returns the connected value or the value if nothing is connected
       */
      getConnectedValue(state) {
        if (this.isConnected) {
          if (this._connectedPoint?._storedFunction) {
            return this._connectedPoint._storedFunction(state);
          }
          return this._connectedPoint._storedValue;
        }
        return this.value;
      }
      /**
       * Gets a boolean indicating if the current point can be connected to another point
       * @param connectionPoint defines the other connection point
       * @returns a boolean
       */
      canConnectTo(connectionPoint) {
        return this.checkCompatibilityState(connectionPoint) === 0;
      }
      /**
       * Gets a number indicating if the current point can be connected to another point
       * @param connectionPoint defines the other connection point
       * @returns a number defining the compatibility state
       */
      checkCompatibilityState(connectionPoint) {
        const ownerBlock = this._ownerBlock;
        const otherBlock = connectionPoint.ownerBlock;
        if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeParticleBlockConnectionPointTypes.AutoDetect) {
          if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) {
            return 0;
          } else {
            return 1;
          }
        }
        if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {
          return 1;
        }
        let targetBlock = otherBlock;
        let sourceBlock = ownerBlock;
        if (this.direction === 0) {
          targetBlock = ownerBlock;
          sourceBlock = otherBlock;
        }
        if (targetBlock.isAnAncestorOf(sourceBlock)) {
          return 2;
        }
        return 0;
      }
      /**
       * Connect this point to another connection point
       * @param connectionPoint defines the other connection point
       * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)
       * @returns the current connection point
       */
      connectTo(connectionPoint, ignoreConstraints = false) {
        if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {
          throw `Cannot connect these two connectors. source: "${this.ownerBlock.name}".${this.name}, target: "${connectionPoint.ownerBlock.name}".${connectionPoint.name}`;
        }
        this._endpoints.push(connectionPoint);
        connectionPoint._connectedPoint = this;
        this.onConnectionObservable.notifyObservers(connectionPoint);
        connectionPoint.onConnectionObservable.notifyObservers(this);
        return this;
      }
      /**
       * Disconnect this point from one of his endpoint
       * @param endpoint defines the other connection point
       * @returns the current connection point
       */
      disconnectFrom(endpoint) {
        const index = this._endpoints.indexOf(endpoint);
        if (index === -1) {
          return this;
        }
        this._endpoints.splice(index, 1);
        endpoint._connectedPoint = null;
        this.onDisconnectionObservable.notifyObservers(endpoint);
        endpoint.onDisconnectionObservable.notifyObservers(this);
        return this;
      }
      /**
       * Fill the list of excluded connection point types with all types other than those passed in the parameter
       * @param mask Types (ORed values of NodeMaterialBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list
       */
      addExcludedConnectionPointFromAllowedTypes(mask) {
        let bitmask = 1;
        while (bitmask < NodeParticleBlockConnectionPointTypes.All) {
          if (!(mask & bitmask)) {
            this.excludedConnectionPointTypes.push(bitmask);
          }
          bitmask = bitmask << 1;
        }
      }
      /**
       * Serializes this point in a JSON representation
       * @param isInput defines if the connection point is an input (default is true)
       * @returns the serialized point object
       */
      serialize(isInput = true) {
        const serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.displayName = this.displayName;
        if (this.value !== void 0 && this.value !== null) {
          if (this.value.asArray) {
            serializationObject.valueType = "BABYLON." + this.value.getClassName();
            serializationObject.value = this.value.asArray();
          } else {
            serializationObject.valueType = "number";
            serializationObject.value = this.value;
          }
        }
        if (isInput && this.connectedPoint) {
          serializationObject.inputName = this.name;
          serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;
          serializationObject.targetConnectionName = this.connectedPoint.name;
          serializationObject.isExposedOnFrame = true;
          serializationObject.exposedPortPosition = this.exposedPortPosition;
        }
        if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {
          serializationObject.isExposedOnFrame = true;
          serializationObject.exposedPortPosition = this.exposedPortPosition;
        }
        return serializationObject;
      }
      /**
       * Release resources
       */
      dispose() {
        this.onConnectionObservable.clear();
        this.onDisconnectionObservable.clear();
      }
    };
  }
});

// node_modules/@babylonjs/core/Particles/Node/nodeParticleBlock.js
var NodeParticleBlock;
var init_nodeParticleBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/nodeParticleBlock.js"() {
    init_tslib_es6();
    init_decorators();
    init_uniqueIdGenerator();
    init_nodeParticleBlockConnectionPoint();
    init_logger();
    init_observable();
    init_typeStore();
    NodeParticleBlock = class {
      /**
       * Gets a boolean indicating if this block is a teleport out
       */
      get isTeleportOut() {
        return this._isTeleportOut;
      }
      /**
       * Gets a boolean indicating if this block is a teleport in
       */
      get isTeleportIn() {
        return this._isTeleportIn;
      }
      /**
       * Gets a boolean indicating that this block is a system block
       */
      get isSystem() {
        return this._isSystem;
      }
      /**
       * Gets a boolean indicating that this block is an input block
       */
      get isInput() {
        return this._isInput;
      }
      /**
       * Gets a boolean indicating if this block is a debug block
       */
      get isDebug() {
        return this._isDebug;
      }
      /**
       * Gets or set the name of the block
       */
      get name() {
        return this._name;
      }
      set name(value) {
        this._name = value;
      }
      /**
       * Gets the current class name e.g. "NodeParticleBlock"
       * @returns the class name
       */
      getClassName() {
        return "NodeParticleBlock";
      }
      /**
       * Gets the list of input points
       */
      get inputs() {
        return this._inputs;
      }
      /** Gets the list of output points */
      get outputs() {
        return this._outputs;
      }
      /**
       * Creates a new NodeParticleBlock
       * @param name defines the block name
       */
      constructor(name13) {
        this._name = "";
        this._isInput = false;
        this._isSystem = false;
        this._isDebug = false;
        this._isTeleportOut = false;
        this._isTeleportIn = false;
        this._inputs = new Array();
        this._outputs = new Array();
        this.onBuildObservable = new Observable();
        this.onDisposeObservable = new Observable();
        this.onInputChangedObservable = new Observable();
        this.visibleOnFrame = false;
        this._name = name13;
        this.uniqueId = UniqueIdGenerator.UniqueId;
      }
      _inputRename(name13) {
        return name13;
      }
      _outputRename(name13) {
        return name13;
      }
      /**
       * Checks if the current block is an ancestor of a given block
       * @param block defines the potential descendant block to check
       * @returns true if block is a descendant
       */
      isAnAncestorOf(block) {
        for (const output of this._outputs) {
          if (!output.hasEndpoints) {
            continue;
          }
          for (const endpoint of output.endpoints) {
            if (endpoint.ownerBlock === block) {
              return true;
            }
            if (endpoint.ownerBlock.isAnAncestorOf(block)) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Checks if the current block is an ancestor of a given type
       * @param type defines the potential type to check
       * @returns true if block is a descendant
       */
      isAnAncestorOfType(type) {
        if (this.getClassName() === type) {
          return true;
        }
        for (const output of this._outputs) {
          if (!output.hasEndpoints) {
            continue;
          }
          for (const endpoint of output.endpoints) {
            if (endpoint.ownerBlock.isAnAncestorOfType(type)) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Find an input by its name
       * @param name defines the name of the input to look for
       * @returns the input or null if not found
       */
      getInputByName(name13) {
        const filter = this._inputs.filter((e) => e.name === name13);
        if (filter.length) {
          return filter[0];
        }
        return null;
      }
      _linkConnectionTypes(inputIndex0, inputIndex1, looseCoupling = false) {
        if (looseCoupling) {
          this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];
        } else {
          this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];
          this._inputs[inputIndex0]._isMainLinkSource = true;
        }
        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];
      }
      /**
       * Register a new input. Must be called inside a block constructor
       * @param name defines the connection point name
       * @param type defines the connection point type
       * @param isOptional defines a boolean indicating that this input can be omitted
       * @param value value to return if there is no connection
       * @param valueMin min value accepted for value
       * @param valueMax max value accepted for value
       * @returns the current block
       */
      registerInput(name13, type, isOptional = false, value, valueMin, valueMax) {
        const point = new NodeParticleConnectionPoint(
          name13,
          this,
          0
          /* NodeParticleConnectionPointDirection.Input */
        );
        point.type = type;
        point.isOptional = isOptional;
        point.defaultValue = value;
        point.value = value;
        point.valueMin = valueMin;
        point.valueMax = valueMax;
        this._inputs.push(point);
        this.onInputChangedObservable.notifyObservers(point);
        return this;
      }
      /**
       * Register a new output. Must be called inside a block constructor
       * @param name defines the connection point name
       * @param type defines the connection point type
       * @param point an already created connection point. If not provided, create a new one
       * @returns the current block
       */
      registerOutput(name13, type, point) {
        point = point ?? new NodeParticleConnectionPoint(
          name13,
          this,
          1
          /* NodeParticleConnectionPointDirection.Output */
        );
        point.type = type;
        this._outputs.push(point);
        return this;
      }
      /**
       * Builds the block. Must be implemented by derived classes.
       * @param _state defines the current build state
       */
      _build(_state) {
      }
      _customBuildStep(_state) {
      }
      /**
       * Builds the block
       * @param state defines the current build state
       * @returns the built block
       */
      build(state) {
        if (this._buildId === state.buildId) {
          return true;
        }
        if (this._outputs.length > 0) {
          if (!this._outputs.some((o) => o.hasEndpoints) && !this.isDebug && !this.isSystem) {
            return false;
          }
        }
        this._buildId = state.buildId;
        for (const input of this._inputs) {
          if (!input.connectedPoint) {
            if (!input.isOptional) {
              state.notConnectedNonOptionalInputs.push(input);
            }
            continue;
          }
          const block = input.connectedPoint.ownerBlock;
          if (block && block !== this && !block.isSystem) {
            block.build(state);
          }
        }
        this._customBuildStep(state);
        if (state.verbose) {
          Logger.Log(`Building ${this.name} [${this.getClassName()}]`);
        }
        this._build(state);
        this.onBuildObservable.notifyObservers(this);
        return false;
      }
      /**
       * Serializes this block in a JSON representation
       * @returns the serialized block object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.customType = "BABYLON." + this.getClassName();
        serializationObject.id = this.uniqueId;
        serializationObject.name = this.name;
        serializationObject.visibleOnFrame = this.visibleOnFrame;
        serializationObject.comments = this.comments;
        serializationObject.inputs = [];
        serializationObject.outputs = [];
        for (const input of this.inputs) {
          serializationObject.inputs.push(input.serialize());
        }
        for (const output of this.outputs) {
          serializationObject.outputs.push(output.serialize(false));
        }
        return serializationObject;
      }
      /**
       * @internal
       */
      _deserialize(serializationObject) {
        this._name = serializationObject.name;
        this.comments = serializationObject.comments;
        this.visibleOnFrame = !!serializationObject.visibleOnFrame;
        this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);
      }
      _deserializePortDisplayNamesAndExposedOnFrame(serializationObject) {
        const serializedInputs = serializationObject.inputs;
        const serializedOutputs = serializationObject.outputs;
        if (serializedInputs) {
          for (const port of serializedInputs) {
            const input = this.inputs.find((i) => i.name === port.name);
            if (!input) {
              return;
            }
            if (port.displayName) {
              input.displayName = port.displayName;
            }
            if (port.isExposedOnFrame) {
              input.isExposedOnFrame = port.isExposedOnFrame;
              input.exposedPortPosition = port.exposedPortPosition;
            }
            if (port.value !== void 0 && port.value !== null) {
              if (port.valueType === "number") {
                input.value = port.value;
              } else {
                const valueType = GetClass(port.valueType);
                if (valueType) {
                  input.value = valueType.FromArray(port.value);
                }
              }
            }
          }
        }
        if (serializedOutputs) {
          for (let i = 0; i < serializedOutputs.length; i++) {
            const port = serializedOutputs[i];
            if (port.displayName) {
              this.outputs[i].displayName = port.displayName;
            }
            if (port.isExposedOnFrame) {
              this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;
              this.outputs[i].exposedPortPosition = port.exposedPortPosition;
            }
          }
        }
      }
      /**
       * Clone the current block to a new identical block
       * @returns a copy of the current block
       */
      clone() {
        const serializationObject = this.serialize();
        const blockType = GetClass(serializationObject.customType);
        if (blockType) {
          const block = new blockType();
          block._deserialize(serializationObject);
          return block;
        }
        return null;
      }
      /**
       * Release resources
       */
      dispose() {
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
        for (const input of this.inputs) {
          input.dispose();
        }
        for (const output of this.outputs) {
          output.dispose();
        }
        this.onBuildObservable.clear();
        this.onInputChangedObservable.clear();
      }
    };
    __decorate([
      serialize("comment")
    ], NodeParticleBlock.prototype, "comments", void 0);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Enums/nodeParticleContextualSources.js
var NodeParticleContextualSources;
var init_nodeParticleContextualSources = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Enums/nodeParticleContextualSources.js"() {
    (function(NodeParticleContextualSources2) {
      NodeParticleContextualSources2[NodeParticleContextualSources2["None"] = 0] = "None";
      NodeParticleContextualSources2[NodeParticleContextualSources2["Position"] = 1] = "Position";
      NodeParticleContextualSources2[NodeParticleContextualSources2["Direction"] = 2] = "Direction";
      NodeParticleContextualSources2[NodeParticleContextualSources2["Age"] = 3] = "Age";
      NodeParticleContextualSources2[NodeParticleContextualSources2["Lifetime"] = 4] = "Lifetime";
      NodeParticleContextualSources2[NodeParticleContextualSources2["Color"] = 5] = "Color";
      NodeParticleContextualSources2[NodeParticleContextualSources2["ScaledDirection"] = 6] = "ScaledDirection";
      NodeParticleContextualSources2[NodeParticleContextualSources2["Scale"] = 7] = "Scale";
      NodeParticleContextualSources2[NodeParticleContextualSources2["AgeGradient"] = 8] = "AgeGradient";
      NodeParticleContextualSources2[NodeParticleContextualSources2["Angle"] = 9] = "Angle";
      NodeParticleContextualSources2[NodeParticleContextualSources2["SpriteCellIndex"] = 16] = "SpriteCellIndex";
      NodeParticleContextualSources2[NodeParticleContextualSources2["SpriteCellStart"] = 17] = "SpriteCellStart";
      NodeParticleContextualSources2[NodeParticleContextualSources2["SpriteCellEnd"] = 18] = "SpriteCellEnd";
      NodeParticleContextualSources2[NodeParticleContextualSources2["InitialColor"] = 19] = "InitialColor";
      NodeParticleContextualSources2[NodeParticleContextualSources2["ColorDead"] = 20] = "ColorDead";
      NodeParticleContextualSources2[NodeParticleContextualSources2["InitialDirection"] = 21] = "InitialDirection";
      NodeParticleContextualSources2[NodeParticleContextualSources2["ColorStep"] = 22] = "ColorStep";
      NodeParticleContextualSources2[NodeParticleContextualSources2["ScaledColorStep"] = 23] = "ScaledColorStep";
      NodeParticleContextualSources2[NodeParticleContextualSources2["LocalPositionUpdated"] = 24] = "LocalPositionUpdated";
      NodeParticleContextualSources2[NodeParticleContextualSources2["Size"] = 25] = "Size";
      NodeParticleContextualSources2[NodeParticleContextualSources2["DirectionScale"] = 32] = "DirectionScale";
    })(NodeParticleContextualSources || (NodeParticleContextualSources = {}));
  }
});

// node_modules/@babylonjs/core/Particles/Node/Enums/nodeParticleSystemSources.js
var NodeParticleSystemSources;
var init_nodeParticleSystemSources = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Enums/nodeParticleSystemSources.js"() {
    (function(NodeParticleSystemSources2) {
      NodeParticleSystemSources2[NodeParticleSystemSources2["None"] = 0] = "None";
      NodeParticleSystemSources2[NodeParticleSystemSources2["Time"] = 1] = "Time";
      NodeParticleSystemSources2[NodeParticleSystemSources2["Delta"] = 2] = "Delta";
      NodeParticleSystemSources2[NodeParticleSystemSources2["Emitter"] = 3] = "Emitter";
      NodeParticleSystemSources2[NodeParticleSystemSources2["CameraPosition"] = 4] = "CameraPosition";
    })(NodeParticleSystemSources || (NodeParticleSystemSources = {}));
  }
});

// node_modules/@babylonjs/core/Particles/Node/nodeParticleBuildState.js
var NodeParticleBuildState;
var init_nodeParticleBuildState = __esm({
  "node_modules/@babylonjs/core/Particles/Node/nodeParticleBuildState.js"() {
    init_math_color();
    init_math_vector();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleContextualSources();
    init_nodeParticleSystemSources();
    NodeParticleBuildState = class {
      constructor() {
        this.notConnectedNonOptionalInputs = [];
        this.particleContext = null;
        this.systemContext = null;
        this.gradientIndex = 0;
        this.nextGradientIndex = 0;
      }
      /**
       * Emits errors if any
       */
      emitErrors() {
        let errorMessage = "";
        for (const notConnectedInput of this.notConnectedNonOptionalInputs) {
          errorMessage += `input ${notConnectedInput.name} from block ${notConnectedInput.ownerBlock.name}[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.
`;
        }
        if (errorMessage) {
          throw "Build of Node Particle System Set failed:\n" + errorMessage;
        }
      }
      /**
       * Adapt a value to a target type
       * @param source defines the value to adapt
       * @param targetType defines the target type
       * @returns the adapted value
       */
      adapt(source, targetType) {
        const value = source.getConnectedValue(this) || 0;
        if (source.type === targetType) {
          return value;
        }
        switch (targetType) {
          case NodeParticleBlockConnectionPointTypes.Vector2:
            return new Vector2(value, value);
          case NodeParticleBlockConnectionPointTypes.Vector3:
            return new Vector3(value, value, value);
          case NodeParticleBlockConnectionPointTypes.Color4:
            return new Color4(value, value, value, value);
        }
        return null;
      }
      /**
       * Gets the value associated with a contextual source
       * @param source Source of the contextual value
       * @returns the value associated with the source
       */
      getContextualValue(source) {
        if (!this.particleContext || !this.systemContext) {
          return null;
        }
        switch (source) {
          case NodeParticleContextualSources.Position:
            return this.particleContext.position;
          case NodeParticleContextualSources.Direction:
            return this.particleContext.direction;
          case NodeParticleContextualSources.DirectionScale:
            return this.particleContext._directionScale;
          case NodeParticleContextualSources.ScaledDirection:
            this.particleContext.direction.scaleToRef(this.particleContext._directionScale, this.particleContext._scaledDirection);
            return this.particleContext._scaledDirection;
          case NodeParticleContextualSources.Color:
            return this.particleContext.color;
          case NodeParticleContextualSources.InitialColor:
            return this.particleContext.initialColor;
          case NodeParticleContextualSources.ColorDead:
            return this.particleContext.colorDead;
          case NodeParticleContextualSources.Age:
            return this.particleContext.age;
          case NodeParticleContextualSources.Lifetime:
            return this.particleContext.lifeTime;
          case NodeParticleContextualSources.Angle:
            return this.particleContext.angle;
          case NodeParticleContextualSources.Scale:
            return this.particleContext.scale;
          case NodeParticleContextualSources.Size:
            return this.particleContext.size;
          case NodeParticleContextualSources.AgeGradient:
            return this.particleContext.age / this.particleContext.lifeTime;
          case NodeParticleContextualSources.SpriteCellEnd:
            return this.systemContext.endSpriteCellID;
          case NodeParticleContextualSources.SpriteCellIndex:
            return this.particleContext.cellIndex;
          case NodeParticleContextualSources.SpriteCellStart:
            return this.systemContext.startSpriteCellID;
          case NodeParticleContextualSources.InitialDirection:
            return this.particleContext._initialDirection;
          case NodeParticleContextualSources.ColorStep:
            return this.particleContext.colorStep;
          case NodeParticleContextualSources.ScaledColorStep:
            this.particleContext.colorStep.scaleToRef(this.systemContext._scaledUpdateSpeed, this.systemContext._scaledColorStep);
            return this.systemContext._scaledColorStep;
          case NodeParticleContextualSources.LocalPositionUpdated:
            this.particleContext.direction.scaleToRef(this.particleContext._directionScale, this.particleContext._scaledDirection);
            this.particleContext._localPosition.addInPlace(this.particleContext._scaledDirection);
            Vector3.TransformCoordinatesToRef(this.particleContext._localPosition, this.systemContext._emitterWorldMatrix, this.particleContext.position);
            return this.particleContext.position;
        }
        return null;
      }
      /**
       * Gets the emitter world matrix
       */
      get emitterWorldMatrix() {
        if (!this.systemContext) {
          return null;
        }
        return this.systemContext._emitterWorldMatrix;
      }
      /**
       * Gets the emitter inverse world matrix
       */
      get emitterInverseWorldMatrix() {
        if (!this.systemContext) {
          return null;
        }
        return this.systemContext._emitterInverseWorldMatrix;
      }
      /**
       * Gets the emitter position
       */
      get emitterPosition() {
        if (!this.systemContext) {
          return null;
        }
        if (!this.systemContext.emitter) {
          return null;
        }
        if (this.systemContext.emitter instanceof Vector3) {
          return this.systemContext.emitter;
        }
        return this.systemContext.emitter.absolutePosition;
      }
      /**
       * Gets the value associated with a system source
       * @param source Source of the system value
       * @returns the value associated with the source
       */
      getSystemValue(source) {
        if (!this.systemContext) {
          return null;
        }
        switch (source) {
          case NodeParticleSystemSources.Time:
            return this.systemContext._actualFrame;
          case NodeParticleSystemSources.Delta:
            return this.systemContext._scaledUpdateSpeed;
          case NodeParticleSystemSources.Emitter:
            return this.emitterPosition;
          case NodeParticleSystemSources.CameraPosition:
            return this.scene.activeCamera?.globalPosition || Vector3.Zero();
        }
        return null;
      }
    };
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/particleGradientBlock.js
var ParticleGradientBlock;
var init_particleGradientBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/particleGradientBlock.js"() {
    init_typeStore();
    init_nodeParticleBlock();
    init_nodeParticleBlockConnectionPointTypes();
    init_math_scalar_functions();
    init_math_color();
    init_math_vector();
    ParticleGradientBlock = class extends NodeParticleBlock {
      /**
       * Creates a new ParticleGradientBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this._entryCount = 1;
        this.registerInput("gradient", NodeParticleBlockConnectionPointTypes.Float, true, 1, 0, 1);
        this.registerInput("value0", NodeParticleBlockConnectionPointTypes.AutoDetect);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.BasedOnInput);
        this._outputs[0]._typeConnectionSource = this._inputs[1];
        this._outputs[0]._typeConnectionSourceTranslation = (type) => {
          switch (type) {
            case NodeParticleBlockConnectionPointTypes.FloatGradient:
              return NodeParticleBlockConnectionPointTypes.Float;
            case NodeParticleBlockConnectionPointTypes.Vector2Gradient:
              return NodeParticleBlockConnectionPointTypes.Vector2;
            case NodeParticleBlockConnectionPointTypes.Vector3Gradient:
              return NodeParticleBlockConnectionPointTypes.Vector3;
            case NodeParticleBlockConnectionPointTypes.Color4Gradient:
              return NodeParticleBlockConnectionPointTypes.Color4;
          }
          return type;
        };
        this._inputs[1].addExcludedConnectionPointFromAllowedTypes(NodeParticleBlockConnectionPointTypes.FloatGradient | NodeParticleBlockConnectionPointTypes.Vector2Gradient | NodeParticleBlockConnectionPointTypes.Vector3Gradient | NodeParticleBlockConnectionPointTypes.Color4Gradient);
        this._manageExtendedInputs(1);
      }
      _extend() {
        this._entryCount++;
        this.registerInput("value" + (this._entryCount - 1), NodeParticleBlockConnectionPointTypes.AutoDetect, true);
        this._linkConnectionTypes(1, this._entryCount);
        this._manageExtendedInputs(this._entryCount);
      }
      _manageExtendedInputs(index) {
        this._inputs[index].onConnectionObservable.add(() => {
          if (this._entryCount > index) {
            return;
          }
          this._extend();
        });
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "ParticleGradientBlock";
      }
      /**
       * Gets the gradient operand input component
       */
      get gradient() {
        return this._inputs[0];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      _build() {
        const entries = [];
        for (let i = 1; i < this._inputs.length; i++) {
          if (this._inputs[i].isConnected) {
            entries.push(this._inputs[i].connectedPoint?.ownerBlock);
          }
        }
        entries.sort((a, b) => {
          return a.reference - b.reference;
        });
        this.output._storedFunction = (state) => {
          const gradient = this.gradient.getConnectedValue(state);
          if (entries.length === 1) {
            return entries[0].value.getConnectedValue(state);
          }
          let nextEntry = null;
          for (let i = entries.length - 1; i >= 0; i--) {
            const entry = entries[i];
            if (entry.reference <= gradient) {
              const currentValue = entry.value.getConnectedValue(state);
              if (nextEntry) {
                const nextValue = nextEntry.value.getConnectedValue(state);
                const nextReference = nextEntry.reference;
                const currentReference = entry.reference;
                const scale = Math.max(0, Math.min(1, (gradient - currentReference) / (nextReference - currentReference)));
                switch (this.output.type) {
                  case NodeParticleBlockConnectionPointTypes.Float:
                    return Lerp(currentValue, nextValue, scale);
                  case NodeParticleBlockConnectionPointTypes.Vector2:
                    return Vector2.Lerp(currentValue, nextValue, scale);
                  case NodeParticleBlockConnectionPointTypes.Vector3:
                    return Vector3.Lerp(currentValue, nextValue, scale);
                  case NodeParticleBlockConnectionPointTypes.Color4:
                    return Color4.Lerp(currentValue, nextValue, scale);
                }
              }
              return currentValue;
            }
            nextEntry = entry;
          }
          return 0;
        };
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject._entryCount = this._entryCount;
        return serializationObject;
      }
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        if (serializationObject._entryCount && serializationObject._entryCount > 1) {
          for (let i = 1; i < serializationObject._entryCount; i++) {
            this._extend();
          }
        }
      }
    };
    RegisterClass("BABYLON.ParticleGradientBlock", ParticleGradientBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Triggers/triggerTools.js
function _TriggerSubEmitter(template, scene, location) {
  const newState = new NodeParticleBuildState();
  newState.scene = scene;
  const clone = template.createSystem(newState);
  clone.canStart = () => true;
  clone.emitter = location.clone();
  clone.disposeOnStop = true;
  clone.start();
  return clone;
}
var init_triggerTools = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Triggers/triggerTools.js"() {
    init_nodeParticleBuildState();
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/systemBlock.js
var SystemBlock;
var init_systemBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/systemBlock.js"() {
    init_tslib_es6();
    init_nodeDecorator();
    init_typeStore();
    init_math_vector();
    init_math_color();
    init_baseParticleSystem();
    init_nodeParticleBlock();
    init_triggerTools();
    init_nodeParticleBlockConnectionPointTypes();
    init_particleGradientBlock();
    SystemBlock = class _SystemBlock extends NodeParticleBlock {
      /**
       * Create a new SystemBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.blendMode = BaseParticleSystem.BLENDMODE_ONEONE;
        this.capacity = 1e3;
        this.manualEmitCount = -1;
        this.startDelay = 0;
        this.updateSpeed = 0.0167;
        this.preWarmCycles = 0;
        this.preWarmStepOffset = 0;
        this.isBillboardBased = true;
        this.billBoardMode = 7;
        this.isLocal = false;
        this.disposeOnStop = false;
        this.doNoStart = false;
        this._internalId = _SystemBlock._IdCounter++;
        this._isSystem = true;
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerInput("emitRate", NodeParticleBlockConnectionPointTypes.Int, true, 10, 0);
        this.registerInput("texture", NodeParticleBlockConnectionPointTypes.Texture);
        this.registerInput("translationPivot", NodeParticleBlockConnectionPointTypes.Vector2, true);
        this.registerInput("textureMask", NodeParticleBlockConnectionPointTypes.Color4, true);
        this.registerInput("targetStopDuration", NodeParticleBlockConnectionPointTypes.Float, true, 0, 0);
        this.registerInput("onStart", NodeParticleBlockConnectionPointTypes.System, true);
        this.registerInput("onEnd", NodeParticleBlockConnectionPointTypes.System, true);
        this.registerInput("rampGradient", NodeParticleBlockConnectionPointTypes.Color4, true);
        this.registerInput("emitterPosition", NodeParticleBlockConnectionPointTypes.Vector3, true, Vector3.Zero());
        this.registerOutput("system", NodeParticleBlockConnectionPointTypes.System);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "SystemBlock";
      }
      /**
       * Gets the particle input component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the emitRate input component
       */
      get emitRate() {
        return this._inputs[1];
      }
      /**
       * Gets the texture input component
       */
      get texture() {
        return this._inputs[2];
      }
      /**
       * Gets the translationPivot input component
       */
      get translationPivot() {
        return this._inputs[3];
      }
      /**
       * Gets the textureMask input component
       */
      get textureMask() {
        return this._inputs[4];
      }
      /**
       * Gets the targetStopDuration input component
       */
      get targetStopDuration() {
        return this._inputs[5];
      }
      /**
       * Gets the onStart input component
       */
      get onStart() {
        return this._inputs[6];
      }
      /**
       * Gets the onEnd input component
       */
      get onEnd() {
        return this._inputs[7];
      }
      /**
       * Gets the rampGradient input component
       */
      get rampGradient() {
        return this._inputs[8];
      }
      /**
       * Gets the emitterPosition input component
       */
      get emitterPosition() {
        return this._inputs[9];
      }
      /**
       * Gets the system output component
       */
      get system() {
        return this._outputs[0];
      }
      /**
       * Builds the block and return a functional particle system
       * @param state defines the building state
       * @returns the built particle system
       */
      createSystem(state) {
        state.capacity = this.capacity;
        state.buildId = this._buildId++;
        this.build(state);
        const particleSystem = this.particle.getConnectedValue(state);
        particleSystem.particleTexture = this.texture.getConnectedValue(state);
        particleSystem.emitRate = this.emitRate.getConnectedValue(state);
        particleSystem.manualEmitCount = this.manualEmitCount;
        particleSystem.updateSpeed = this.updateSpeed;
        particleSystem.preWarmCycles = this.preWarmCycles;
        particleSystem.preWarmStepOffset = this.preWarmStepOffset;
        particleSystem.blendMode = this.blendMode;
        particleSystem.name = this.name;
        particleSystem._targetStopDuration = this.targetStopDuration.getConnectedValue(state) ?? 0;
        particleSystem.startDelay = this.startDelay;
        particleSystem.isBillboardBased = this.isBillboardBased;
        particleSystem.billboardMode = this.billBoardMode;
        particleSystem.translationPivot = this.translationPivot.getConnectedValue(state) || Vector2.Zero();
        particleSystem.textureMask = this.textureMask.getConnectedValue(state) ?? new Color4(1, 1, 1, 1);
        particleSystem.isLocal = this.isLocal;
        particleSystem.disposeOnStop = this.disposeOnStop;
        particleSystem.emitter = this.emitterPosition.getConnectedValue(state) ?? Vector3.Zero();
        particleSystem._calculateEmitRate = () => {
          state.systemContext = particleSystem;
          return this.emitRate.getConnectedValue(state);
        };
        particleSystem.useRampGradients = false;
        if (this.rampGradient.isConnected) {
          if (this.rampGradient.connectedPoint?.ownerBlock instanceof ParticleGradientBlock) {
            const gradientInputs = this.rampGradient.connectedPoint?.ownerBlock.inputs;
            for (let i = 1; i < gradientInputs.length; i++) {
              if (gradientInputs[i].isConnected) {
                const rampEntry = gradientInputs[i].connectedPoint?.ownerBlock;
                const color = rampEntry._inputs[0].getConnectedValue(state);
                particleSystem.addRampGradient(rampEntry.reference, new Color3(color.r, color.g, color.b));
                particleSystem.useRampGradients = true;
              }
            }
          } else {
            const color = this.rampGradient.getConnectedValue(state);
            particleSystem.addRampGradient(0, new Color3(color.r, color.g, color.b));
            particleSystem.useRampGradients = true;
          }
        }
        this.system._storedValue = this;
        particleSystem.canStart = () => {
          return !this.doNoStart;
        };
        particleSystem.onStartedObservable.add((system) => {
          const onStartSystem = this.onStart.getConnectedValue(state);
          if (onStartSystem) {
            system.onStartedObservable.addOnce(() => {
              state.systemContext = particleSystem;
              const clone = _TriggerSubEmitter(onStartSystem, state.scene, state.emitterPosition);
              this.onDisposeObservable.addOnce(() => {
                clone.dispose();
              });
            });
          }
          const onEndSystem = this.onEnd.getConnectedValue(state);
          if (onEndSystem) {
            system.onStoppedObservable.addOnce(() => {
              state.systemContext = particleSystem;
              const clone = _TriggerSubEmitter(onEndSystem, state.scene, state.emitterPosition);
              this.onDisposeObservable.addOnce(() => {
                clone.dispose();
              });
            });
          }
        });
        this.onDisposeObservable.addOnce(() => {
          particleSystem.dispose();
        });
        return particleSystem;
      }
      /**
       * Serializes the system block
       * @returns The serialized object
       */
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.capacity = this.capacity;
        serializationObject.manualEmitCount = this.manualEmitCount;
        serializationObject.blendMode = this.blendMode;
        serializationObject.updateSpeed = this.updateSpeed;
        serializationObject.preWarmCycles = this.preWarmCycles;
        serializationObject.preWarmStepOffset = this.preWarmStepOffset;
        serializationObject.isBillboardBased = this.isBillboardBased;
        serializationObject.billBoardMode = this.billBoardMode;
        serializationObject.isLocal = this.isLocal;
        serializationObject.disposeOnStop = this.disposeOnStop;
        serializationObject.doNoStart = this.doNoStart;
        serializationObject.startDelay = this.startDelay;
        return serializationObject;
      }
      /**
       * Deserializes the system block
       * @param serializationObject The serialized system
       */
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        this.capacity = serializationObject.capacity;
        this.manualEmitCount = serializationObject.manualEmitCount ?? -1;
        this.updateSpeed = serializationObject.updateSpeed ?? 0.0167;
        this.preWarmCycles = serializationObject.preWarmCycles ?? 0;
        this.preWarmStepOffset = serializationObject.preWarmStepOffset ?? 0;
        this.isBillboardBased = serializationObject.isBillboardBased ?? true;
        this.billBoardMode = serializationObject.billBoardMode ?? 7;
        this.isLocal = serializationObject.isLocal ?? false;
        this.disposeOnStop = serializationObject.disposeOnStop ?? false;
        this.doNoStart = !!serializationObject.doNoStart;
        if (serializationObject.emitRate !== void 0) {
          this.emitRate.value = serializationObject.emitRate;
        }
        if (serializationObject.blendMode !== void 0) {
          this.blendMode = serializationObject.blendMode;
        }
        if (serializationObject.startDelay !== void 0) {
          this.startDelay = serializationObject.startDelay;
        }
      }
    };
    SystemBlock._IdCounter = 0;
    __decorate([
      editableInPropertyPage("Blend mode", 5, "ADVANCED", {
        notifiers: { rebuild: true },
        embedded: true,
        options: [
          { label: "Blend Mode OneOne", value: BaseParticleSystem.BLENDMODE_ONEONE },
          { label: "Blend Mode Standard", value: BaseParticleSystem.BLENDMODE_STANDARD },
          { label: "Blend Mode Add", value: BaseParticleSystem.BLENDMODE_ADD },
          { label: "Blend Mode Multiply", value: BaseParticleSystem.BLENDMODE_MULTIPLY },
          { label: "Blend Mode MultiplyAdd", value: BaseParticleSystem.BLENDMODE_MULTIPLYADD }
        ]
      })
    ], SystemBlock.prototype, "blendMode", void 0);
    __decorate([
      editableInPropertyPage("Capacity", 2, "ADVANCED", { embedded: true, notifiers: { rebuild: true }, min: 0, max: 1e4 })
    ], SystemBlock.prototype, "capacity", void 0);
    __decorate([
      editableInPropertyPage("Manual emit count", 2, "ADVANCED", { embedded: true, notifiers: { rebuild: true }, min: -1 })
    ], SystemBlock.prototype, "manualEmitCount", void 0);
    __decorate([
      editableInPropertyPage("Delay start(ms)", 1, "ADVANCED", { embedded: true, notifiers: { rebuild: true }, min: 0 })
    ], SystemBlock.prototype, "startDelay", void 0);
    __decorate([
      editableInPropertyPage("updateSpeed", 1, "ADVANCED", { embedded: true, notifiers: { rebuild: true }, min: 0, max: 0.1 })
    ], SystemBlock.prototype, "updateSpeed", void 0);
    __decorate([
      editableInPropertyPage("Pre-warm cycles", 1, "ADVANCED", { embedded: true, notifiers: { rebuild: true }, min: 0 })
    ], SystemBlock.prototype, "preWarmCycles", void 0);
    __decorate([
      editableInPropertyPage("Pre-warm step multiplier", 1, "ADVANCED", { embedded: true, notifiers: { rebuild: true }, min: 0 })
    ], SystemBlock.prototype, "preWarmStepOffset", void 0);
    __decorate([
      editableInPropertyPage("Is billboard based", 0, "ADVANCED", { embedded: true, notifiers: { rebuild: true } })
    ], SystemBlock.prototype, "isBillboardBased", void 0);
    __decorate([
      editableInPropertyPage("Billboard mode", 5, "ADVANCED", {
        notifiers: { rebuild: true },
        embedded: true,
        options: [
          { label: "Billboard Mode All", value: 7 },
          { label: "Billboard Mode Y", value: 2 },
          { label: "Billboard Mode Stretched", value: 8 },
          { label: "Billboard Mode Stretched Local", value: 9 }
        ]
      })
    ], SystemBlock.prototype, "billBoardMode", void 0);
    __decorate([
      editableInPropertyPage("Is local", 0, "ADVANCED", { embedded: true, notifiers: { rebuild: true } })
    ], SystemBlock.prototype, "isLocal", void 0);
    __decorate([
      editableInPropertyPage("Dispose on stop", 0, "ADVANCED", { embedded: true, notifiers: { rebuild: true } })
    ], SystemBlock.prototype, "disposeOnStop", void 0);
    __decorate([
      editableInPropertyPage("Do no start", 0, "ADVANCED", { embedded: true, notifiers: { rebuild: true } })
    ], SystemBlock.prototype, "doNoStart", void 0);
    RegisterClass("BABYLON.SystemBlock", SystemBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/particleInputBlock.js
var ParticleInputBlock;
var init_particleInputBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/particleInputBlock.js"() {
    init_observable();
    init_typeStore();
    init_math_vector();
    init_nodeParticleBlock();
    init_nodeParticleBlockConnectionPointTypes();
    init_math_color();
    init_nodeParticleContextualSources();
    init_nodeParticleSystemSources();
    ParticleInputBlock = class extends NodeParticleBlock {
      /**
       * Gets or sets the connection point type (default is float)
       */
      get type() {
        if (this._type === NodeParticleBlockConnectionPointTypes.AutoDetect) {
          if (this.value != null) {
            if (!isNaN(this.value)) {
              this._type = NodeParticleBlockConnectionPointTypes.Float;
              return this._type;
            }
            switch (this.value.getClassName()) {
              case "Vector2":
                this._type = NodeParticleBlockConnectionPointTypes.Vector2;
                return this._type;
              case "Vector3":
                this._type = NodeParticleBlockConnectionPointTypes.Vector3;
                return this._type;
              case "Color4":
                this._type = NodeParticleBlockConnectionPointTypes.Color4;
                return this._type;
              case "Matrix":
                this._type = NodeParticleBlockConnectionPointTypes.Matrix;
                return this._type;
            }
          }
        }
        return this._type;
      }
      /**
       * Gets a boolean indicating that the current connection point is a system source
       */
      get isSystemSource() {
        return this._contextualSource === NodeParticleContextualSources.None && this._systemSource !== NodeParticleSystemSources.None;
      }
      /**
       * Gets or sets the system source used by this input block
       */
      get systemSource() {
        return this._systemSource;
      }
      set systemSource(value) {
        this._systemSource = value;
        if (value !== NodeParticleSystemSources.None) {
          this._contextualSource = NodeParticleContextualSources.None;
          this._type = NodeParticleBlockConnectionPointTypes.Float;
          switch (value) {
            case NodeParticleSystemSources.Time:
            case NodeParticleSystemSources.Delta:
              this._type = NodeParticleBlockConnectionPointTypes.Float;
              break;
            case NodeParticleSystemSources.Emitter:
            case NodeParticleSystemSources.CameraPosition:
              this._type = NodeParticleBlockConnectionPointTypes.Vector3;
              break;
          }
          if (this.output) {
            this.output.type = this._type;
          }
        }
      }
      /**
       * Gets a boolean indicating that the current connection point is a contextual value
       */
      get isContextual() {
        return this._contextualSource !== NodeParticleContextualSources.None;
      }
      /**
       * Gets or sets the current contextual value
       */
      get contextualValue() {
        return this._contextualSource;
      }
      set contextualValue(value) {
        this._contextualSource = value;
        if (value !== NodeParticleContextualSources.None) {
          this._systemSource = NodeParticleSystemSources.None;
          switch (value) {
            case NodeParticleContextualSources.Scale:
              this._type = NodeParticleBlockConnectionPointTypes.Vector2;
              break;
            case NodeParticleContextualSources.Position:
            case NodeParticleContextualSources.Direction:
            case NodeParticleContextualSources.ScaledDirection:
            case NodeParticleContextualSources.InitialDirection:
            case NodeParticleContextualSources.LocalPositionUpdated:
              this._type = NodeParticleBlockConnectionPointTypes.Vector3;
              break;
            case NodeParticleContextualSources.Color:
            case NodeParticleContextualSources.InitialColor:
            case NodeParticleContextualSources.ColorDead:
            case NodeParticleContextualSources.ColorStep:
            case NodeParticleContextualSources.ScaledColorStep:
              this._type = NodeParticleBlockConnectionPointTypes.Color4;
              break;
            case NodeParticleContextualSources.Age:
            case NodeParticleContextualSources.Lifetime:
            case NodeParticleContextualSources.Angle:
            case NodeParticleContextualSources.AgeGradient:
            case NodeParticleContextualSources.Size:
            case NodeParticleContextualSources.DirectionScale:
              this._type = NodeParticleBlockConnectionPointTypes.Float;
              break;
            case NodeParticleContextualSources.SpriteCellEnd:
            case NodeParticleContextualSources.SpriteCellStart:
            case NodeParticleContextualSources.SpriteCellIndex:
              this._type = NodeParticleBlockConnectionPointTypes.Int;
              break;
          }
          if (this.output) {
            this.output.type = this._type;
          }
        }
      }
      /**
       * Creates a new InputBlock
       * @param name defines the block name
       * @param type defines the type of the input (can be set to NodeParticleBlockConnectionPointTypes.AutoDetect)
       */
      constructor(name13, type = NodeParticleBlockConnectionPointTypes.AutoDetect) {
        super(name13);
        this._type = NodeParticleBlockConnectionPointTypes.Undefined;
        this.min = 0;
        this.max = 0;
        this.groupInInspector = "";
        this.displayInInspector = true;
        this.onValueChangedObservable = new Observable();
        this._systemSource = NodeParticleSystemSources.None;
        this._contextualSource = NodeParticleContextualSources.None;
        this._type = type;
        this._isInput = true;
        this._storedValue = null;
        this.setDefaultValue();
        this.registerOutput("output", type);
      }
      /**
       * Gets or sets the value of that point.
       * Please note that this value will be ignored if valueCallback is defined
       */
      get value() {
        return this._storedValue;
      }
      set value(value) {
        if (this.type === NodeParticleBlockConnectionPointTypes.Float) {
          if (this.min !== this.max) {
            value = Math.max(this.min, value);
            value = Math.min(this.max, value);
          }
        }
        this._storedValue = value;
        this.onValueChangedObservable.notifyObservers(this);
      }
      /**
       * Gets or sets a callback used to get the value of that point.
       * Please note that setting this value will force the connection point to ignore the value property
       */
      get valueCallback() {
        return this._valueCallback;
      }
      set valueCallback(value) {
        this._valueCallback = value;
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "ParticleInputBlock";
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Set the input block to its default value (based on its type)
       */
      setDefaultValue() {
        switch (this.type) {
          case NodeParticleBlockConnectionPointTypes.Int:
          case NodeParticleBlockConnectionPointTypes.Float:
            this.value = 0;
            break;
          case NodeParticleBlockConnectionPointTypes.Vector2:
            this.value = Vector2.Zero();
            break;
          case NodeParticleBlockConnectionPointTypes.Vector3:
            this.value = Vector3.Zero();
            break;
          case NodeParticleBlockConnectionPointTypes.Color4:
            this.value = new Color4(1, 1, 1, 1);
            break;
          case NodeParticleBlockConnectionPointTypes.Matrix:
            this.value = Matrix.Identity();
            break;
        }
      }
      _build(state) {
        super._build(state);
        if (this.isSystemSource) {
          this.output._storedValue = null;
          this.output._storedFunction = (state2) => {
            return state2.getSystemValue(this._systemSource);
          };
        } else if (this.isContextual) {
          this.output._storedValue = null;
          this.output._storedFunction = (state2) => {
            return state2.getContextualValue(this._contextualSource);
          };
        } else {
          this.output._storedValue = this.value;
          this.output._storedFunction = () => {
            return this.value;
          };
        }
      }
      dispose() {
        this.onValueChangedObservable.clear();
        super.dispose();
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.type = this.type;
        serializationObject.contextualValue = this.contextualValue;
        serializationObject.systemSource = this.systemSource;
        serializationObject.min = this.min;
        serializationObject.max = this.max;
        serializationObject.groupInInspector = this.groupInInspector;
        serializationObject.displayInInspector = this.displayInInspector;
        if (this._storedValue !== null && !this.isContextual && !this.isSystemSource) {
          if (this._storedValue.asArray) {
            serializationObject.valueType = "BABYLON." + this._storedValue.getClassName();
            serializationObject.value = this._storedValue.asArray();
          } else {
            serializationObject.valueType = "number";
            serializationObject.value = this._storedValue;
          }
        }
        return serializationObject;
      }
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        this._type = serializationObject.type;
        this.contextualValue = serializationObject.contextualValue;
        this.systemSource = serializationObject.systemSource || NodeParticleSystemSources.None;
        this.min = serializationObject.min || 0;
        this.max = serializationObject.max || 0;
        this.groupInInspector = serializationObject.groupInInspector || "";
        if (serializationObject.displayInInspector !== void 0) {
          this.displayInInspector = serializationObject.displayInInspector;
        }
        if (!serializationObject.valueType) {
          return;
        }
        if (serializationObject.valueType === "number") {
          this._storedValue = serializationObject.value;
        } else {
          const valueType = GetClass(serializationObject.valueType);
          if (valueType) {
            this._storedValue = valueType.FromArray(serializationObject.value);
          }
        }
      }
    };
    RegisterClass("BABYLON.ParticleInputBlock", ParticleInputBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/particleSourceTextureBlock.js
var ParticleTextureSourceBlock;
var init_particleSourceTextureBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/particleSourceTextureBlock.js"() {
    init_texture();
    init_typeStore();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleBlock();
    init_textureTools();
    ParticleTextureSourceBlock = class extends NodeParticleBlock {
      /**
       * Gets or sets the URL of the texture to be used by this block.
       */
      get url() {
        return this._url;
      }
      set url(value) {
        if (this._url === value) {
          return;
        }
        this._cachedData = null;
        this._url = value;
        this._textureDataUrl = "";
        this._sourceTexture = null;
      }
      /**
       * Gets or sets the data URL of the texture to be used by this block.
       * This is a base64 encoded string representing the texture data.
       */
      get textureDataUrl() {
        return this._textureDataUrl;
      }
      set textureDataUrl(value) {
        if (this._textureDataUrl === value) {
          return;
        }
        this._cachedData = null;
        this._textureDataUrl = value;
        this._url = "";
        this._sourceTexture = null;
      }
      /**
       * Directly sets the texture to be used by this block.
       * This value will not be serialized.
       */
      set sourceTexture(value) {
        if (this._sourceTexture === value) {
          return;
        }
        this._cachedData = null;
        this._sourceTexture = value;
        this._url = value.url || "";
        this._textureDataUrl = "";
      }
      /**
       * Create a new ParticleTextureSourceBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this._url = "";
        this._textureDataUrl = "";
        this._sourceTexture = null;
        this._cachedData = null;
        this._clonedTextures = [];
        this.invertY = true;
        this.serializedCachedData = false;
        this.registerOutput("texture", NodeParticleBlockConnectionPointTypes.Texture);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "ParticleTextureSourceBlock";
      }
      /**
       * Gets the texture output component
       */
      get texture() {
        return this._outputs[0];
      }
      /**
       * Gets the texture content as a promise
       * @returns a promise that resolves to the texture content, including width, height, and pixel data
       */
      async extractTextureContentAsync() {
        if (!this.texture._storedValue && !this._sourceTexture) {
          return null;
        }
        if (this._cachedData) {
          return this._cachedData;
        }
        const texture = this.texture._storedValue || this._sourceTexture;
        return await new Promise((resolve, reject) => {
          if (!texture.isReady()) {
            texture.onLoadObservable.addOnce(async () => {
              try {
                this._cachedData = await this.extractTextureContentAsync();
                resolve(this._cachedData);
              } catch (e) {
                reject(e);
              }
            });
            return;
          }
          const size = texture.getSize();
          if (texture.getContent) {
            const proceduralTexture = texture;
            proceduralTexture.getContent()?.then((data) => {
              this._cachedData = {
                width: size.width,
                height: size.height,
                data
              };
              resolve(this._cachedData);
            }).catch(reject);
          } else {
            TextureTools.GetTextureDataAsync(texture, size.width, size.height).then((data) => {
              this._cachedData = {
                width: size.width,
                height: size.height,
                data: new Uint8ClampedArray(data)
              };
              texture.dispose();
              resolve(this._cachedData);
            }).catch(reject);
          }
        });
      }
      /**
       * Builds the block
       * @param state defines the current build state
       */
      _build(state) {
        if (this._sourceTexture) {
          const sourceScene = this._sourceTexture.getScene?.();
          const sourceEngine = sourceScene?.getEngine?.();
          const targetEngine = state.scene.getEngine();
          if (sourceEngine && sourceEngine !== targetEngine) {
            const url = this._sourceTexture.url || this._url;
            if (url) {
              const invertY = this._sourceTexture.invertY ?? this.invertY;
              const tex2 = new Texture(url, state.scene, void 0, invertY);
              this._copyTextureProperties(this._sourceTexture, tex2);
              this._clonedTextures.push(tex2);
              this.texture._storedValue = tex2;
              return;
            }
            this.texture._storedValue = this._sourceTexture;
            return;
          }
          const cloned = this._sourceTexture.clone();
          if (cloned) {
            this._clonedTextures.push(cloned);
            this.texture._storedValue = cloned;
          } else {
            this.texture._storedValue = this._sourceTexture;
          }
          return;
        }
        if (!this._textureDataUrl && !this._url) {
          this.texture._storedValue = null;
          return;
        }
        if (this._textureDataUrl) {
          const tex2 = new Texture(this._textureDataUrl, state.scene, void 0, this.invertY);
          this._clonedTextures.push(tex2);
          this.texture._storedValue = tex2;
          return;
        }
        const tex = new Texture(this._url, state.scene, void 0, this.invertY);
        this._clonedTextures.push(tex);
        this.texture._storedValue = tex;
      }
      /**
       * Serializes this block
       * @returns the serialization object
       */
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.url = this.url;
        serializationObject.serializedCachedData = this.serializedCachedData;
        serializationObject.invertY = this.invertY;
        if (this.serializedCachedData) {
          serializationObject.textureDataUrl = this.textureDataUrl;
        }
        return serializationObject;
      }
      /**
       * Deserializes this block from a serialization object
       * @param serializationObject the serialization object
       */
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        this.url = serializationObject.url;
        this.serializedCachedData = !!serializationObject.serializedCachedData;
        this.invertY = !!serializationObject.invertY;
        if (serializationObject.textureDataUrl) {
          this.textureDataUrl = serializationObject.textureDataUrl;
        }
      }
      /**
       * Disposes the block and its associated resources
       */
      dispose() {
        for (const tex of this._clonedTextures) {
          tex.dispose();
        }
        this._clonedTextures = [];
        this.texture._storedValue = null;
        super.dispose();
      }
      /**
       * Copies texture properties from source to target texture
       * @param source - The source texture to copy properties from
       * @param target - The target texture to copy properties to
       */
      _copyTextureProperties(source, target) {
        target.hasAlpha = source.hasAlpha;
        target.level = source.level;
        target.coordinatesIndex = source.coordinatesIndex;
        target.coordinatesMode = source.coordinatesMode;
        target.wrapU = source.wrapU;
        target.wrapV = source.wrapV;
        target.wrapR = source.wrapR;
        target.anisotropicFilteringLevel = source.anisotropicFilteringLevel;
        const sourceTexture = source;
        const targetTexture = target;
        if (sourceTexture.uOffset !== void 0 && targetTexture.uOffset !== void 0) {
          targetTexture.uOffset = sourceTexture.uOffset;
          targetTexture.vOffset = sourceTexture.vOffset;
          targetTexture.uScale = sourceTexture.uScale;
          targetTexture.vScale = sourceTexture.vScale;
          targetTexture.uAng = sourceTexture.uAng;
          targetTexture.vAng = sourceTexture.vAng;
          targetTexture.wAng = sourceTexture.wAng;
        }
      }
    };
    RegisterClass("BABYLON.ParticleTextureSourceBlock", ParticleTextureSourceBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updatePositionBlock.js
var UpdatePositionBlock;
var init_updatePositionBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updatePositionBlock.js"() {
    init_typeStore();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleBlock();
    init_executionQueue();
    UpdatePositionBlock = class extends NodeParticleBlock {
      /**
       * Create a new UpdateDirectionBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerInput("position", NodeParticleBlockConnectionPointTypes.Vector3);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the particle component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the position input component
       */
      get position() {
        return this._inputs[1];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "UpdatePositionBlock";
      }
      /**
       * Builds the block
       * @param state defines the current build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        this.output._storedValue = system;
        if (!this.position.isConnected) {
          return;
        }
        const processPosition = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          particle.position.copyFrom(this.position.getConnectedValue(state));
        };
        const positionProcessing = {
          process: processPosition,
          previousItem: null,
          nextItem: null
        };
        if (system._updateQueueStart) {
          _ConnectAtTheEnd(positionProcessing, system._updateQueueStart);
        } else {
          system._updateQueueStart = positionProcessing;
        }
      }
    };
    RegisterClass("BABYLON.UpdatePositionBlock", UpdatePositionBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/particleMathBlock.js
var ParticleMathBlockOperations, ParticleMathBlock;
var init_particleMathBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/particleMathBlock.js"() {
    init_tslib_es6();
    init_typeStore();
    init_math_vector();
    init_nodeDecorator();
    init_nodeParticleBlock();
    init_nodeParticleBlockConnectionPointTypes();
    init_math_color();
    (function(ParticleMathBlockOperations2) {
      ParticleMathBlockOperations2[ParticleMathBlockOperations2["Add"] = 0] = "Add";
      ParticleMathBlockOperations2[ParticleMathBlockOperations2["Subtract"] = 1] = "Subtract";
      ParticleMathBlockOperations2[ParticleMathBlockOperations2["Multiply"] = 2] = "Multiply";
      ParticleMathBlockOperations2[ParticleMathBlockOperations2["Divide"] = 3] = "Divide";
      ParticleMathBlockOperations2[ParticleMathBlockOperations2["Max"] = 4] = "Max";
      ParticleMathBlockOperations2[ParticleMathBlockOperations2["Min"] = 5] = "Min";
    })(ParticleMathBlockOperations || (ParticleMathBlockOperations = {}));
    ParticleMathBlock = class extends NodeParticleBlock {
      /**
       * Create a new ParticleMathBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.operation = ParticleMathBlockOperations.Add;
        this.registerInput("left", NodeParticleBlockConnectionPointTypes.AutoDetect);
        this.registerInput("right", NodeParticleBlockConnectionPointTypes.AutoDetect);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.BasedOnInput);
        this.output._typeConnectionSource = this.left;
        const excludedConnectionPointTypes = [
          NodeParticleBlockConnectionPointTypes.Matrix,
          NodeParticleBlockConnectionPointTypes.Particle,
          NodeParticleBlockConnectionPointTypes.Texture,
          NodeParticleBlockConnectionPointTypes.System,
          NodeParticleBlockConnectionPointTypes.FloatGradient,
          NodeParticleBlockConnectionPointTypes.Color4Gradient,
          NodeParticleBlockConnectionPointTypes.Vector2Gradient,
          NodeParticleBlockConnectionPointTypes.Vector3Gradient
        ];
        this.left.excludedConnectionPointTypes.push(...excludedConnectionPointTypes);
        this.right.excludedConnectionPointTypes.push(...excludedConnectionPointTypes);
        this._linkConnectionTypes(0, 1);
        this._connectionObservers = [
          this.left.onConnectionObservable.add(() => this._updateInputOutputTypes()),
          this.left.onDisconnectionObservable.add(() => this._updateInputOutputTypes()),
          this.right.onConnectionObservable.add(() => this._updateInputOutputTypes()),
          this.right.onDisconnectionObservable.add(() => this._updateInputOutputTypes())
        ];
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "ParticleMathBlock";
      }
      /**
       * Gets the left input component
       */
      get left() {
        return this._inputs[0];
      }
      /**
       * Gets the right input component
       */
      get right() {
        return this._inputs[1];
      }
      /**
       * Gets the geometry output component
       */
      get output() {
        return this._outputs[0];
      }
      _build(state) {
        let func;
        const left = this.left;
        const right = this.right;
        if (!left.isConnected || !right.isConnected) {
          this.output._storedFunction = null;
          this.output._storedValue = null;
          return;
        }
        const leftIsScalar = left.type === NodeParticleBlockConnectionPointTypes.Float || left.type === NodeParticleBlockConnectionPointTypes.Int;
        const rightIsScalar = right.type === NodeParticleBlockConnectionPointTypes.Float || right.type === NodeParticleBlockConnectionPointTypes.Int;
        const isScalar = leftIsScalar && rightIsScalar;
        switch (this.operation) {
          case ParticleMathBlockOperations.Add: {
            if (isScalar) {
              func = (state2) => {
                return left.getConnectedValue(state2) + right.getConnectedValue(state2);
              };
            } else if (leftIsScalar) {
              func = (state2) => {
                return state2.adapt(left, right.type).add(right.getConnectedValue(state2));
              };
            } else {
              func = (state2) => {
                return left.getConnectedValue(state2).add(state2.adapt(right, left.type));
              };
            }
            break;
          }
          case ParticleMathBlockOperations.Subtract: {
            if (isScalar) {
              func = (state2) => {
                return left.getConnectedValue(state2) - right.getConnectedValue(state2);
              };
            } else if (leftIsScalar) {
              func = (state2) => {
                return state2.adapt(left, right.type).subtract(right.getConnectedValue(state2));
              };
            } else {
              func = (state2) => {
                return left.getConnectedValue(state2).subtract(state2.adapt(right, left.type));
              };
            }
            break;
          }
          case ParticleMathBlockOperations.Multiply: {
            if (isScalar) {
              func = (state2) => {
                return left.getConnectedValue(state2) * right.getConnectedValue(state2);
              };
            } else if (leftIsScalar) {
              func = (state2) => {
                return state2.adapt(left, right.type).multiply(right.getConnectedValue(state2));
              };
            } else {
              func = (state2) => {
                return left.getConnectedValue(state2).multiply(state2.adapt(right, left.type));
              };
            }
            break;
          }
          case ParticleMathBlockOperations.Divide: {
            if (isScalar) {
              func = (state2) => {
                return left.getConnectedValue(state2) / right.getConnectedValue(state2);
              };
            } else if (leftIsScalar) {
              func = (state2) => {
                return state2.adapt(left, right.type).divide(right.getConnectedValue(state2));
              };
            } else {
              func = (state2) => {
                return left.getConnectedValue(state2).divide(state2.adapt(right, left.type));
              };
            }
            break;
          }
          case ParticleMathBlockOperations.Min: {
            if (isScalar) {
              func = (state2) => {
                return Math.min(left.getConnectedValue(state2), right.getConnectedValue(state2));
              };
            } else {
              const [vector, scalar] = leftIsScalar ? [right, left] : [left, right];
              switch (vector.type) {
                case NodeParticleBlockConnectionPointTypes.Vector2: {
                  func = (state2) => {
                    return Vector2.Minimize(vector.getConnectedValue(state2), state2.adapt(scalar, vector.type));
                  };
                  break;
                }
                case NodeParticleBlockConnectionPointTypes.Vector3: {
                  func = (state2) => {
                    return Vector3.Minimize(vector.getConnectedValue(state2), state2.adapt(scalar, vector.type));
                  };
                  break;
                }
                case NodeParticleBlockConnectionPointTypes.Color4: {
                  func = (state2) => {
                    const other = vector.getConnectedValue(state2);
                    const { r, g, b, a } = state2.adapt(scalar, vector.type);
                    return new Color4(Math.min(other.r, r), Math.min(other.g, g), Math.min(other.b, b), Math.min(other.a, a));
                  };
                  break;
                }
              }
            }
            break;
          }
          case ParticleMathBlockOperations.Max: {
            if (isScalar) {
              func = (state2) => {
                return Math.max(left.getConnectedValue(state2), right.getConnectedValue(state2));
              };
            } else {
              const [vector, scalar] = leftIsScalar ? [right, left] : [left, right];
              switch (vector.type) {
                case NodeParticleBlockConnectionPointTypes.Vector2: {
                  func = (state2) => {
                    return Vector2.Maximize(vector.getConnectedValue(state2), state2.adapt(scalar, vector.type));
                  };
                  break;
                }
                case NodeParticleBlockConnectionPointTypes.Vector3: {
                  func = (state2) => {
                    return Vector3.Maximize(vector.getConnectedValue(state2), state2.adapt(scalar, vector.type));
                  };
                  break;
                }
                case NodeParticleBlockConnectionPointTypes.Color4: {
                  func = (state2) => {
                    const other = vector.getConnectedValue(state2);
                    const { r, g, b, a } = state2.adapt(scalar, vector.type);
                    return new Color4(Math.max(other.r, r), Math.min(other.g, g), Math.min(other.b, b), Math.min(other.a, a));
                  };
                  break;
                }
              }
              break;
            }
          }
        }
        this.output._storedFunction = (state2) => {
          if (left.type === NodeParticleBlockConnectionPointTypes.Int) {
            return func(state2) | 0;
          }
          return func(state2);
        };
      }
      _updateInputOutputTypes() {
        this.output._typeConnectionSource = this.left;
        if (this.left.isConnected && this.right.isConnected) {
          if (this.left.type === NodeParticleBlockConnectionPointTypes.Int || this.left.type === NodeParticleBlockConnectionPointTypes.Float && this.right.type !== NodeParticleBlockConnectionPointTypes.Int) {
            this.output._typeConnectionSource = this.right;
          }
        } else if (this.left.isConnected !== this.right.isConnected) {
          this.output._typeConnectionSource = this.left.isConnected ? this.left : this.right;
        }
        if (this.left.isConnected || this.right.isConnected) {
          for (const [first, second] of [
            [this.left, this.right],
            [this.right, this.left]
          ]) {
            first.acceptedConnectionPointTypes = [NodeParticleBlockConnectionPointTypes.Int, NodeParticleBlockConnectionPointTypes.Float];
            if (second.isConnected) {
              first.acceptedConnectionPointTypes.push(second.type);
              if (second.type === NodeParticleBlockConnectionPointTypes.Int || second.type === NodeParticleBlockConnectionPointTypes.Float) {
                first.acceptedConnectionPointTypes.push(NodeParticleBlockConnectionPointTypes.Vector2, NodeParticleBlockConnectionPointTypes.Vector3, NodeParticleBlockConnectionPointTypes.Color4);
              }
            }
          }
        }
      }
      /**
       * Release resources
       */
      dispose() {
        super.dispose();
        for (const observer of this._connectionObservers) {
          observer.remove();
        }
        this._connectionObservers.length = 0;
      }
      /**
       * Serializes this block in a JSON representation
       * @returns the serialized block object
       */
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.operation = this.operation;
        return serializationObject;
      }
      /**
       * Deserializes the block from a JSON object
       * @param serializationObject the JSON object to deserialize from
       */
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        this.operation = serializationObject.operation;
      }
    };
    __decorate([
      editableInPropertyPage("Operation", 5, "ADVANCED", {
        notifiers: { rebuild: true },
        embedded: true,
        options: [
          { label: "Add", value: ParticleMathBlockOperations.Add },
          { label: "Subtract", value: ParticleMathBlockOperations.Subtract },
          { label: "Multiply", value: ParticleMathBlockOperations.Multiply },
          { label: "Divide", value: ParticleMathBlockOperations.Divide },
          { label: "Max", value: ParticleMathBlockOperations.Max },
          { label: "Min", value: ParticleMathBlockOperations.Min }
        ]
      })
    ], ParticleMathBlock.prototype, "operation", void 0);
    RegisterClass("BABYLON.ParticleMathBlock", ParticleMathBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/emitters.functions.js
function _CreateLocalPositionData(particle) {
  if (!particle._localPosition) {
    particle._localPosition = particle.position.clone();
  } else {
    particle._localPosition.copyFrom(particle.position);
  }
}
var init_emitters_functions = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/emitters.functions.js"() {
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/boxShapeBlock.js
var BoxShapeBlock;
var init_boxShapeBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/boxShapeBlock.js"() {
    init_typeStore();
    init_nodeParticleBlockConnectionPointTypes();
    init_math_vector();
    init_nodeParticleBlock();
    init_math_scalar_functions();
    init_emitters_functions();
    BoxShapeBlock = class extends NodeParticleBlock {
      /**
       * Create a new BoxShapeBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerInput("direction1", NodeParticleBlockConnectionPointTypes.Vector3, true, new Vector3(0, 1, 0));
        this.registerInput("direction2", NodeParticleBlockConnectionPointTypes.Vector3, true, new Vector3(0, 1, 0));
        this.registerInput("minEmitBox", NodeParticleBlockConnectionPointTypes.Vector3, true, new Vector3(-0.5, -0.5, -0.5));
        this.registerInput("maxEmitBox", NodeParticleBlockConnectionPointTypes.Vector3, true, new Vector3(0.5, 0.5, 0.5));
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "BoxShapeBlock";
      }
      /**
       * Gets the particle input component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the direction1 input component
       */
      get direction1() {
        return this._inputs[1];
      }
      /**
       * Gets the direction2 input component
       */
      get direction2() {
        return this._inputs[2];
      }
      /**
       * Gets the minEmitBox input component
       */
      get minEmitBox() {
        return this._inputs[3];
      }
      /**
       * Gets the maxEmitBox input component
       */
      get maxEmitBox() {
        return this._inputs[4];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Builds the block
       * @param state defines the build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        system._directionCreation.process = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          const direction1 = this.direction1.getConnectedValue(state);
          const direction2 = this.direction2.getConnectedValue(state);
          const randX = RandomRange(direction1.x, direction2.x);
          const randY = RandomRange(direction1.y, direction2.y);
          const randZ = RandomRange(direction1.z, direction2.z);
          if (system.isLocal) {
            particle.direction.copyFromFloats(randX, randY, randZ);
          } else {
            Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, state.emitterWorldMatrix, particle.direction);
          }
          particle._initialDirection = particle.direction.clone();
        };
        system._positionCreation.process = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          const minEmitBox = this.minEmitBox.getConnectedValue(state);
          const maxEmitBox = this.maxEmitBox.getConnectedValue(state);
          const randX = RandomRange(minEmitBox.x, maxEmitBox.x);
          const randY = RandomRange(minEmitBox.y, maxEmitBox.y);
          const randZ = RandomRange(minEmitBox.z, maxEmitBox.z);
          if (system.isLocal) {
            particle.position.copyFromFloats(randX, randY, randZ);
          } else {
            Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, state.emitterWorldMatrix, particle.position);
          }
          _CreateLocalPositionData(particle);
        };
        this.output._storedValue = system;
      }
    };
    RegisterClass("BABYLON.BoxShapeBlock", BoxShapeBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/createParticleBlock.js
var ColorDiff, CreateParticleBlock;
var init_createParticleBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/createParticleBlock.js"() {
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleBlock();
    init_particleSystem();
    init_math_color();
    init_math_vector();
    init_typeStore();
    init_pointParticleEmitter();
    ColorDiff = new Color4();
    CreateParticleBlock = class extends NodeParticleBlock {
      /**
       * Create a new CreateParticleBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.registerInput("emitPower", NodeParticleBlockConnectionPointTypes.Float, true, 1);
        this.registerInput("lifeTime", NodeParticleBlockConnectionPointTypes.Float, true, 1);
        this.registerInput("color", NodeParticleBlockConnectionPointTypes.Color4, true, new Color4(1, 1, 1, 1));
        this.registerInput("colorDead", NodeParticleBlockConnectionPointTypes.Color4, true, new Color4(0, 0, 0, 0));
        this.registerInput("scale", NodeParticleBlockConnectionPointTypes.Vector2, true, new Vector2(1, 1));
        this.registerInput("angle", NodeParticleBlockConnectionPointTypes.Float, true, 0);
        this.registerInput("size", NodeParticleBlockConnectionPointTypes.Float, true, 1);
        this.registerOutput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.scale.acceptedConnectionPointTypes.push(NodeParticleBlockConnectionPointTypes.Float);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "CreateParticleBlock";
      }
      /**
       * Gets the emitPower input component
       */
      get emitPower() {
        return this._inputs[0];
      }
      /**
       * Gets the lifeTime input component
       */
      get lifeTime() {
        return this._inputs[1];
      }
      /**
       * Gets the color input component
       */
      get color() {
        return this._inputs[2];
      }
      /**
       * Gets the color dead input component
       */
      get colorDead() {
        return this._inputs[3];
      }
      /**
       * Gets the scale input component
       */
      get scale() {
        return this._inputs[4];
      }
      /**
       * Gets the angle input component
       */
      get angle() {
        return this._inputs[5];
      }
      /**
       * Gets the size component
       */
      get size() {
        return this._inputs[6];
      }
      /**
       * Gets the particle output component
       */
      get particle() {
        return this._outputs[0];
      }
      /**
       * @internal
       */
      _build(state) {
        const system = new ParticleSystem(this.name, state.capacity, state.scene, null, false, void 0, true);
        system.particleEmitterType = new PointParticleEmitter();
        system._lifeTimeCreation.process = (particle, system2) => {
          state.particleContext = particle;
          particle.lifeTime = this.lifeTime.getConnectedValue(state);
          system2._emitPower = this.emitPower.getConnectedValue(state);
        };
        system._colorCreation.process = (particle) => {
          state.particleContext = particle;
          const color = this.color.getConnectedValue(state);
          if (color !== void 0) {
            particle.color.copyFrom(color);
          }
        };
        system._colorDeadCreation.process = (particle) => {
          state.particleContext = particle;
          particle.colorDead.copyFrom(this.colorDead.getConnectedValue(state));
          particle.initialColor.copyFrom(particle.color);
          particle.colorDead.subtractToRef(particle.initialColor, ColorDiff);
          ColorDiff.scaleToRef(1 / particle.lifeTime, particle.colorStep);
        };
        system._sizeCreation.process = (particle) => {
          state.particleContext = particle;
          const size = this.size.getConnectedValue(state);
          if (size !== void 0) {
            particle.size = size;
          } else {
            particle.size = 1;
          }
          const scale = this.scale.getConnectedValue(state);
          if (scale.x !== void 0) {
            particle.scale.x = scale.x;
            particle.scale.y = scale.y;
          } else {
            particle.scale.x = scale;
            particle.scale.y = scale;
          }
        };
        system._angleCreation.process = (particle) => {
          state.particleContext = particle;
          particle.angle = this.angle.getConnectedValue(state);
        };
        this.particle._storedValue = system;
      }
    };
    RegisterClass("BABYLON.CreateParticleBlock", CreateParticleBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/nodeParticleSystemSet.js
var NodeParticleSystemSet;
var init_nodeParticleSystemSet = __esm({
  "node_modules/@babylonjs/core/Particles/Node/nodeParticleSystemSet.js"() {
    init_tslib_es6();
    init_decorators();
    init_particleSystemSet();
    init_systemBlock();
    init_nodeParticleBuildState();
    init_decorators_serialization();
    init_observable();
    init_typeStore();
    init_webRequest();
    init_tools();
    init_abstractEngine();
    init_particleInputBlock();
    init_particleSourceTextureBlock();
    init_nodeParticleContextualSources();
    init_updatePositionBlock();
    init_particleMathBlock();
    init_boxShapeBlock();
    init_createParticleBlock();
    NodeParticleSystemSet = class _NodeParticleSystemSet {
      /**
       * Gets the system blocks
       */
      get systemBlocks() {
        return this._systemBlocks;
      }
      /**
       * Gets the list of input blocks attached to this material
       * @returns an array of InputBlocks
       */
      get inputBlocks() {
        const blocks = [];
        for (const block of this.attachedBlocks) {
          if (block.isInput) {
            blocks.push(block);
          }
        }
        return blocks;
      }
      /**
       * Get a block by its name
       * @param name defines the name of the block to retrieve
       * @returns the required block or null if not found
       */
      getBlockByName(name13) {
        let result = null;
        for (const block of this.attachedBlocks) {
          if (block.name === name13) {
            if (!result) {
              result = block;
            } else {
              Tools.Warn("More than one block was found with the name `" + name13 + "`");
              return result;
            }
          }
        }
        return result;
      }
      /**
       * Get a block using a predicate
       * @param predicate defines the predicate used to find the good candidate
       * @returns the required block or null if not found
       */
      getBlockByPredicate(predicate) {
        for (const block of this.attachedBlocks) {
          if (predicate(block)) {
            return block;
          }
        }
        return null;
      }
      /**
       * Get an input block using a predicate
       * @param predicate defines the predicate used to find the good candidate
       * @returns the required input block or null if not found
       */
      getInputBlockByPredicate(predicate) {
        for (const block of this.attachedBlocks) {
          if (block.isInput && predicate(block)) {
            return block;
          }
        }
        return null;
      }
      /**
       * Creates a new set
       * @param name defines the name of the set
       */
      constructor(name13) {
        this._systemBlocks = [];
        this._buildId = 0;
        this.attachedBlocks = [];
        this.editorData = null;
        this.onBuildObservable = new Observable();
        this.BJSNODEPARTICLEEDITOR = this._getGlobalNodeParticleEditor();
        this.name = name13;
      }
      /**
       * Gets the current class name of the node particle set e.g. "NodeParticleSystemSet"
       * @returns the class name
       */
      getClassName() {
        return "NodeParticleSystemSet";
      }
      _initializeBlock(node, autoConfigure = true) {
        if (this.attachedBlocks.indexOf(node) === -1) {
          this.attachedBlocks.push(node);
        }
        for (const input of node.inputs) {
          const connectedPoint = input.connectedPoint;
          if (connectedPoint) {
            const block = connectedPoint.ownerBlock;
            if (block !== node) {
              this._initializeBlock(block, autoConfigure);
            }
          }
        }
      }
      /** Get the editor from bundle or global
       * @returns the global NPE
       */
      _getGlobalNodeParticleEditor() {
        if (typeof NODEPARTICLEEDITOR !== "undefined") {
          return NODEPARTICLEEDITOR;
        }
        if (typeof BABYLON !== "undefined" && typeof BABYLON.NodeParticleEditor !== "undefined") {
          return BABYLON;
        }
        return void 0;
      }
      /** Creates the node editor window.
       * @param additionalConfig Define the configuration of the editor
       */
      _createNodeParticleEditor(additionalConfig) {
        const nodeEditorConfig = {
          nodeParticleSet: this,
          ...additionalConfig
        };
        this.BJSNODEPARTICLEEDITOR.NodeParticleEditor.Show(nodeEditorConfig);
      }
      /**
       * Launch the node particle editor
       * @param config Define the configuration of the editor
       * @returns a promise fulfilled when the node editor is visible
       */
      async editAsync(config) {
        return await new Promise((resolve) => {
          this.BJSNODEPARTICLEEDITOR = this.BJSNODEPARTICLEEDITOR || this._getGlobalNodeParticleEditor();
          if (typeof this.BJSNODEPARTICLEEDITOR == "undefined") {
            const editorUrl = config && config.editorURL ? config.editorURL : _NodeParticleSystemSet.EditorURL;
            Tools.LoadBabylonScript(editorUrl, () => {
              this.BJSNODEPARTICLEEDITOR = this.BJSNODEPARTICLEEDITOR || this._getGlobalNodeParticleEditor();
              this._createNodeParticleEditor(config?.nodeEditorConfig);
              resolve();
            });
          } else {
            this._createNodeParticleEditor(config?.nodeEditorConfig);
            resolve();
          }
        });
      }
      /**
       * Builds the particle system set from the defined blocks.
       * @param scene defines the hosting scene
       * @param verbose defines whether to log detailed information during the build process (false by default)
       * @returns a promise that resolves to the built particle system set
       */
      async buildAsync(scene, verbose = false) {
        return await new Promise((resolve) => {
          const output = new ParticleSystemSet();
          for (const block of this._systemBlocks) {
            this._initializeBlock(block);
          }
          for (const block of this.systemBlocks) {
            const state = new NodeParticleBuildState();
            state.buildId = this._buildId++;
            state.scene = scene;
            state.verbose = verbose;
            const system = block.createSystem(state);
            system._source = this;
            system._blockReference = block._internalId;
            state.emitErrors();
            output.systems.push(system);
          }
          this.onBuildObservable.notifyObservers(this);
          resolve(output);
        });
      }
      /**
       * Clear the current node particle set
       */
      clear() {
        this.attachedBlocks.length = 0;
        this._systemBlocks.length = 0;
      }
      /**
       * Clear the current set and restore it to a default state
       */
      setToDefault() {
        this.clear();
        this.editorData = null;
        const system = new SystemBlock("Particle system");
        const updatePositionBlock = new UpdatePositionBlock("Update position");
        updatePositionBlock.output.connectTo(system.particle);
        const positionBlock = new ParticleInputBlock("Position");
        positionBlock.contextualValue = NodeParticleContextualSources.Position;
        const directionBlock = new ParticleInputBlock("Scaled direction");
        directionBlock.contextualValue = NodeParticleContextualSources.ScaledDirection;
        const addBlock = new ParticleMathBlock("Add");
        addBlock.operation = ParticleMathBlockOperations.Add;
        positionBlock.output.connectTo(addBlock.left);
        directionBlock.output.connectTo(addBlock.right);
        addBlock.output.connectTo(updatePositionBlock.position);
        const createParticleBlock = new CreateParticleBlock("Create particle");
        const emitterShape = new BoxShapeBlock("Box shape");
        createParticleBlock.particle.connectTo(emitterShape.particle);
        emitterShape.output.connectTo(updatePositionBlock.particle);
        const textureBlock = new ParticleTextureSourceBlock("Texture");
        textureBlock.texture.connectTo(system.texture);
        textureBlock.url = Tools.GetAssetUrl("https://assets.babylonjs.com/core/textures/flare.png");
        this._systemBlocks.push(system);
      }
      /**
       * Remove a block from the current system set
       * @param block defines the block to remove
       */
      removeBlock(block) {
        const attachedBlockIndex = this.attachedBlocks.indexOf(block);
        if (attachedBlockIndex > -1) {
          this.attachedBlocks.splice(attachedBlockIndex, 1);
        }
        if (block.isSystem) {
          const index = this._systemBlocks.indexOf(block);
          if (index > -1) {
            this._systemBlocks.splice(index, 1);
          }
        }
      }
      /**
       * Clear the current graph and load a new one from a serialization object
       * @param source defines the JSON representation of the particle set
       * @param merge defines whether or not the source must be merged or replace the current content
       */
      parseSerializedObject(source, merge = false) {
        if (!merge) {
          this.clear();
        }
        const map = {};
        for (const parsedBlock of source.blocks) {
          const blockType = GetClass(parsedBlock.customType);
          if (blockType) {
            const block = new blockType();
            block._deserialize(parsedBlock);
            map[parsedBlock.id] = block;
            this.attachedBlocks.push(block);
            if (block.isSystem) {
              this._systemBlocks.push(block);
            }
          }
        }
        for (const block of this.attachedBlocks) {
          if (block.isTeleportOut) {
            const teleportOut = block;
            const id = teleportOut._tempEntryPointUniqueId;
            if (id) {
              const source2 = map[id];
              if (source2) {
                source2.attachToEndpoint(teleportOut);
              }
            }
          }
        }
        for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {
          const parsedBlock = source.blocks[blockIndex];
          const block = map[parsedBlock.id];
          if (!block) {
            continue;
          }
          if (block.inputs.length && parsedBlock.inputs.some((i) => i.targetConnectionName) && !merge) {
            continue;
          }
          this._restoreConnections(block, source, map);
        }
        if (source.locations || source.editorData && source.editorData.locations) {
          const locations = source.locations || source.editorData.locations;
          for (const location of locations) {
            if (map[location.blockId]) {
              location.blockId = map[location.blockId].uniqueId;
            }
          }
          if (merge && this.editorData && this.editorData.locations) {
            locations.concat(this.editorData.locations);
          }
          if (source.locations) {
            this.editorData = {
              locations
            };
          } else {
            this.editorData = source.editorData;
            this.editorData.locations = locations;
          }
          const blockMap = {};
          for (const key in map) {
            blockMap[key] = map[key].uniqueId;
          }
          this.editorData.map = blockMap;
        }
        this.comment = source.comment;
      }
      _restoreConnections(block, source, map) {
        for (const outputPoint of block.outputs) {
          for (const candidate of source.blocks) {
            const target = map[candidate.id];
            if (!target) {
              continue;
            }
            for (const input of candidate.inputs) {
              if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {
                const inputPoint = target.getInputByName(input.inputName);
                if (!inputPoint || inputPoint.isConnected) {
                  continue;
                }
                outputPoint.connectTo(inputPoint, true);
                this._restoreConnections(target, source, map);
                continue;
              }
            }
          }
        }
      }
      /**
       * Serializes this node particle set in a JSON representation
       * @param selectedBlocks defines the list of blocks to save (if null the whole node particle set will be saved)
       * @returns the serialized particle system set object
       */
      serialize(selectedBlocks) {
        const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);
        serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData));
        let blocks = [];
        if (selectedBlocks) {
          blocks = selectedBlocks;
        } else {
          serializationObject.customType = "BABYLON.NodeParticleSystemSet";
        }
        serializationObject.blocks = [];
        for (const block of blocks) {
          serializationObject.blocks.push(block.serialize());
        }
        if (!selectedBlocks) {
          for (const block of this.attachedBlocks) {
            if (blocks.indexOf(block) !== -1) {
              continue;
            }
            serializationObject.blocks.push(block.serialize());
          }
        }
        return serializationObject;
      }
      /**
       * Makes a duplicate of the current particle system set.
       * @param name defines the name to use for the new particle system set
       * @returns the cloned particle system set
       */
      clone(name13) {
        const serializationObject = this.serialize();
        const clone = SerializationHelper.Clone(() => new _NodeParticleSystemSet(name13), this);
        clone.name = name13;
        clone.snippetId = this.snippetId;
        clone.parseSerializedObject(serializationObject);
        clone._buildId = this._buildId;
        return clone;
      }
      /**
       * Disposes the resources
       */
      dispose() {
        for (const block of this.attachedBlocks) {
          block.dispose();
        }
        this.attachedBlocks.length = 0;
        this.onBuildObservable.clear();
      }
      /**
       * Creates a new node particle set set to default basic configuration
       * @param name defines the name of the particle set
       * @returns a new NodeParticleSystemSet
       */
      static CreateDefault(name13) {
        const nodeParticleSet = new _NodeParticleSystemSet(name13);
        nodeParticleSet.setToDefault();
        return nodeParticleSet;
      }
      /**
       * Creates a node particle set from parsed data
       * @param source defines the JSON representation of the particle set
       * @returns a new node particle set
       */
      static Parse(source) {
        const nodeParticleSet = SerializationHelper.Parse(() => new _NodeParticleSystemSet(source.name), source, null);
        nodeParticleSet.parseSerializedObject(source);
        return nodeParticleSet;
      }
      /**
       * Creates a node particle set from a snippet saved in a remote file
       * @param name defines the name of the node particle set to create
       * @param url defines the url to load from
       * @param nodeParticleSet defines a node particle set to update (instead of creating a new one)
       * @returns a promise that will resolve to the new node particle set
       */
      // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
      static ParseFromFileAsync(name13, url, nodeParticleSet) {
        return new Promise((resolve, reject) => {
          const request = new WebRequest();
          request.addEventListener("readystatechange", () => {
            if (request.readyState == 4) {
              if (request.status == 200) {
                const serializationObject = JSON.parse(request.responseText);
                if (!nodeParticleSet) {
                  nodeParticleSet = SerializationHelper.Parse(() => new _NodeParticleSystemSet(name13), serializationObject, null);
                }
                nodeParticleSet.parseSerializedObject(serializationObject);
                resolve(nodeParticleSet);
              } else {
                reject("Unable to load the node particle system set");
              }
            }
          });
          request.open("GET", url);
          request.send();
        });
      }
      /**
       * Creates a node particle set from a snippet saved by the node particle editor
       * @param snippetId defines the snippet to load
       * @param nodeParticleSet defines a node particle set to update (instead of creating a new one)
       * @returns a promise that will resolve to the new node particle set
       */
      // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
      static ParseFromSnippetAsync(snippetId, nodeParticleSet) {
        if (snippetId === "_BLANK") {
          return Promise.resolve(_NodeParticleSystemSet.CreateDefault("blank"));
        }
        return new Promise((resolve, reject) => {
          const request = new WebRequest();
          request.addEventListener("readystatechange", () => {
            if (request.readyState == 4) {
              if (request.status == 200) {
                const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
                const serializationObject = JSON.parse(snippet.nodeParticle);
                if (!nodeParticleSet) {
                  nodeParticleSet = SerializationHelper.Parse(() => new _NodeParticleSystemSet(snippetId), serializationObject, null);
                }
                nodeParticleSet.parseSerializedObject(serializationObject);
                nodeParticleSet.snippetId = snippetId;
                try {
                  resolve(nodeParticleSet);
                } catch (err) {
                  reject(err);
                }
              } else {
                reject("Unable to load the snippet " + snippetId);
              }
            }
          });
          request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
          request.send();
        });
      }
    };
    NodeParticleSystemSet.EditorURL = `${Tools._DefaultCdnUrl}/v${AbstractEngine.Version}/nodeParticleEditor/babylon.nodeParticleEditor.js`;
    NodeParticleSystemSet.SnippetUrl = `https://snippet.babylonjs.com`;
    __decorate([
      serialize()
    ], NodeParticleSystemSet.prototype, "name", void 0);
    __decorate([
      serialize("comment")
    ], NodeParticleSystemSet.prototype, "comment", void 0);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/particleConverterBlock.js
var ParticleConverterBlock;
var init_particleConverterBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/particleConverterBlock.js"() {
    init_math_color();
    init_math_vector();
    init_typeStore();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleBlock();
    ParticleConverterBlock = class extends NodeParticleBlock {
      /**
       * Create a new ParticleConverterBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.registerInput("color ", NodeParticleBlockConnectionPointTypes.Color4, true);
        this.registerInput("xyz ", NodeParticleBlockConnectionPointTypes.Vector3, true);
        this.registerInput("xy ", NodeParticleBlockConnectionPointTypes.Vector2, true);
        this.registerInput("zw ", NodeParticleBlockConnectionPointTypes.Vector2, true);
        this.registerInput("x ", NodeParticleBlockConnectionPointTypes.Float, true);
        this.registerInput("y ", NodeParticleBlockConnectionPointTypes.Float, true);
        this.registerInput("z ", NodeParticleBlockConnectionPointTypes.Float, true);
        this.registerInput("w ", NodeParticleBlockConnectionPointTypes.Float, true);
        this.registerOutput("color", NodeParticleBlockConnectionPointTypes.Color4);
        this.registerOutput("xyz", NodeParticleBlockConnectionPointTypes.Vector3);
        this.registerOutput("xy", NodeParticleBlockConnectionPointTypes.Vector2);
        this.registerOutput("zw", NodeParticleBlockConnectionPointTypes.Vector2);
        this.registerOutput("x", NodeParticleBlockConnectionPointTypes.Float);
        this.registerOutput("y", NodeParticleBlockConnectionPointTypes.Float);
        this.registerOutput("z", NodeParticleBlockConnectionPointTypes.Float);
        this.registerOutput("w", NodeParticleBlockConnectionPointTypes.Float);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "ParticleConverterBlock";
      }
      /**
       * Gets the color component (input)
       */
      get colorIn() {
        return this._inputs[0];
      }
      /**
       * Gets the xyz component (input)
       */
      get xyzIn() {
        return this._inputs[1];
      }
      /**
       * Gets the xy component (input)
       */
      get xyIn() {
        return this._inputs[2];
      }
      /**
       * Gets the zw component (input)
       */
      get zwIn() {
        return this._inputs[3];
      }
      /**
       * Gets the x component (input)
       */
      get xIn() {
        return this._inputs[4];
      }
      /**
       * Gets the y component (input)
       */
      get yIn() {
        return this._inputs[5];
      }
      /**
       * Gets the z component (input)
       */
      get zIn() {
        return this._inputs[6];
      }
      /**
       * Gets the w component (input)
       */
      get wIn() {
        return this._inputs[7];
      }
      /**
       * Gets the xyzw component (output)
       */
      get colorOut() {
        return this._outputs[0];
      }
      /**
       * Gets the xyz component (output)
       */
      get xyzOut() {
        return this._outputs[1];
      }
      /**
       * Gets the xy component (output)
       */
      get xyOut() {
        return this._outputs[2];
      }
      /**
       * Gets the zw component (output)
       */
      get zwOut() {
        return this._outputs[3];
      }
      /**
       * Gets the x component (output)
       */
      get xOut() {
        return this._outputs[4];
      }
      /**
       * Gets the y component (output)
       */
      get yOut() {
        return this._outputs[5];
      }
      /**
       * Gets the z component (output)
       */
      get zOut() {
        return this._outputs[6];
      }
      /**
       * Gets the w component (output)
       */
      get wOut() {
        return this._outputs[7];
      }
      _inputRename(name13) {
        if (name13 === "color ") {
          return "colorIn";
        }
        if (name13 === "xyz ") {
          return "xyzIn";
        }
        if (name13 === "xy ") {
          return "xyIn";
        }
        if (name13 === "zw ") {
          return "zwIn";
        }
        if (name13 === "x ") {
          return "xIn";
        }
        if (name13 === "y ") {
          return "yIn";
        }
        if (name13 === "z ") {
          return "zIn";
        }
        if (name13 === "w ") {
          return "wIn";
        }
        return name13;
      }
      _outputRename(name13) {
        switch (name13) {
          case "x":
            return "xOut";
          case "y":
            return "yOut";
          case "z":
            return "zOut";
          case "w":
            return "wOut";
          case "xy":
            return "xyOut";
          case "zw":
            return "zwOut";
          case "xyz":
            return "xyzOut";
          case "color":
            return "colorOut";
          default:
            return name13;
        }
      }
      _build(state) {
        super._build(state);
        const xInput = this.xIn;
        const yInput = this.yIn;
        const zInput = this.zIn;
        const wInput = this.wIn;
        const xyInput = this.xyIn;
        const zwInput = this.zwIn;
        const xyzInput = this.xyzIn;
        const colorInput = this.colorIn;
        const colorOutput = this.colorOut;
        const xyzOutput = this.xyzOut;
        const xyOutput = this.xyOut;
        const zwOutput = this.zwOut;
        const xOutput = this.xOut;
        const yOutput = this.yOut;
        const zOutput = this.zOut;
        const wOutput = this.wOut;
        const getData = (state2) => {
          if (colorInput.isConnected) {
            return colorInput.getConnectedValue(state2);
          }
          let x = 0;
          let y = 0;
          let z = 0;
          let w = 0;
          if (xInput.isConnected) {
            x = xInput.getConnectedValue(state2);
          }
          if (yInput.isConnected) {
            y = yInput.getConnectedValue(state2);
          }
          if (zInput.isConnected) {
            z = zInput.getConnectedValue(state2);
          }
          if (wInput.isConnected) {
            w = wInput.getConnectedValue(state2);
          }
          if (xyInput.isConnected) {
            const temp = xyInput.getConnectedValue(state2);
            if (temp) {
              x = temp.x;
              y = temp.y;
            }
          }
          if (zwInput.isConnected) {
            const temp = zwInput.getConnectedValue(state2);
            if (temp) {
              z = temp.x;
              w = temp.y;
            }
          }
          if (xyzInput.isConnected) {
            const temp = xyzInput.getConnectedValue(state2);
            if (temp) {
              x = temp.x;
              y = temp.y;
              z = temp.z;
            }
          }
          return new Color4(x, y, z, w);
        };
        colorOutput._storedFunction = (state2) => getData(state2);
        xyzOutput._storedFunction = (state2) => {
          const data = getData(state2);
          return new Vector3(data.r, data.g, data.b);
        };
        xyOutput._storedFunction = (state2) => {
          const data = getData(state2);
          return new Vector2(data.r, data.g);
        };
        zwOutput._storedFunction = (state2) => {
          const data = getData(state2);
          return new Vector2(data.b, data.a);
        };
        xOutput._storedFunction = (state2) => getData(state2).r;
        yOutput._storedFunction = (state2) => getData(state2).g;
        zOutput._storedFunction = (state2) => getData(state2).b;
        wOutput._storedFunction = (state2) => getData(state2).a;
      }
    };
    RegisterClass("BABYLON.ParticleConverterBlock", ParticleConverterBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/particleFloatToIntBlock.js
var ParticleFloatToIntBlockOperations, ParticleFloatToIntBlock;
var init_particleFloatToIntBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/particleFloatToIntBlock.js"() {
    init_tslib_es6();
    init_typeStore();
    init_nodeDecorator();
    init_nodeParticleBlock();
    init_nodeParticleBlockConnectionPointTypes();
    (function(ParticleFloatToIntBlockOperations2) {
      ParticleFloatToIntBlockOperations2[ParticleFloatToIntBlockOperations2["Round"] = 0] = "Round";
      ParticleFloatToIntBlockOperations2[ParticleFloatToIntBlockOperations2["Ceil"] = 1] = "Ceil";
      ParticleFloatToIntBlockOperations2[ParticleFloatToIntBlockOperations2["Floor"] = 2] = "Floor";
      ParticleFloatToIntBlockOperations2[ParticleFloatToIntBlockOperations2["Truncate"] = 3] = "Truncate";
    })(ParticleFloatToIntBlockOperations || (ParticleFloatToIntBlockOperations = {}));
    ParticleFloatToIntBlock = class extends NodeParticleBlock {
      /**
       * Creates a new ParticleFloatToIntBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.operation = ParticleFloatToIntBlockOperations.Round;
        this.registerInput("input", NodeParticleBlockConnectionPointTypes.AutoDetect);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Int);
        this._outputs[0]._typeConnectionSource = this._inputs[0];
        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeParticleBlockConnectionPointTypes.Float | NodeParticleBlockConnectionPointTypes.Int);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "ParticleFloatToIntBlock";
      }
      /**
       * Gets the input component
       */
      get input() {
        return this._inputs[0];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      _build(state) {
        super._build(state);
        let func = null;
        const input = this.input;
        switch (this.operation) {
          case ParticleFloatToIntBlockOperations.Round: {
            func = (state2) => {
              return Math.round(input.getConnectedValue(state2));
            };
            break;
          }
          case ParticleFloatToIntBlockOperations.Ceil: {
            func = (state2) => {
              return Math.ceil(input.getConnectedValue(state2));
            };
            break;
          }
          case ParticleFloatToIntBlockOperations.Floor: {
            func = (state2) => {
              return Math.floor(input.getConnectedValue(state2));
            };
            break;
          }
          case ParticleFloatToIntBlockOperations.Truncate: {
            func = (state2) => {
              return Math.trunc(input.getConnectedValue(state2));
            };
            break;
          }
        }
        if (!func) {
          this.output._storedFunction = null;
          this.output._storedValue = null;
          return;
        }
        this.output._storedFunction = (state2) => {
          return func(state2);
        };
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.operation = this.operation;
        return serializationObject;
      }
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        this.operation = serializationObject.operation;
      }
    };
    __decorate([
      editableInPropertyPage("Operation", 5, "ADVANCED", {
        notifiers: { rebuild: true },
        embedded: true,
        options: [
          { label: "Round", value: ParticleFloatToIntBlockOperations.Round },
          { label: "Ceil", value: ParticleFloatToIntBlockOperations.Ceil },
          { label: "Floor", value: ParticleFloatToIntBlockOperations.Floor },
          { label: "Truncate", value: ParticleFloatToIntBlockOperations.Truncate }
        ]
      })
    ], ParticleFloatToIntBlock.prototype, "operation", void 0);
    RegisterClass("BABYLON.ParticleFloatToIntBlock", ParticleFloatToIntBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/particleGradientValueBlock.js
var ParticleGradientValueBlock;
var init_particleGradientValueBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/particleGradientValueBlock.js"() {
    init_tslib_es6();
    init_typeStore();
    init_nodeParticleBlock();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeDecorator();
    ParticleGradientValueBlock = class extends NodeParticleBlock {
      /**
       * Creates a new ParticleGradientEntryBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.reference = 0;
        this.registerInput("value", NodeParticleBlockConnectionPointTypes.AutoDetect);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.BasedOnInput);
        this._outputs[0]._typeConnectionSource = this._inputs[0];
        this._outputs[0]._typeConnectionSourceTranslation = (type) => {
          switch (type) {
            case NodeParticleBlockConnectionPointTypes.Float:
              return NodeParticleBlockConnectionPointTypes.FloatGradient;
            case NodeParticleBlockConnectionPointTypes.Vector2:
              return NodeParticleBlockConnectionPointTypes.Vector2Gradient;
            case NodeParticleBlockConnectionPointTypes.Vector3:
              return NodeParticleBlockConnectionPointTypes.Vector3Gradient;
            case NodeParticleBlockConnectionPointTypes.Color4:
              return NodeParticleBlockConnectionPointTypes.Color4Gradient;
          }
          return type;
        };
        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeParticleBlockConnectionPointTypes.Float | NodeParticleBlockConnectionPointTypes.Vector2 | NodeParticleBlockConnectionPointTypes.Vector3 | NodeParticleBlockConnectionPointTypes.Color4);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "ParticleGradientValueBlock";
      }
      /**
       * Gets the value operand input component
       */
      get value() {
        return this._inputs[0];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      _build() {
        this.output._storedFunction = (state) => {
          return null;
        };
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.reference = this.reference;
        return serializationObject;
      }
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        this.reference = serializationObject.reference;
      }
    };
    __decorate([
      editableInPropertyPage("Reference", 1, "ADVANCED", { embedded: true, notifiers: { rebuild: true }, min: 0, max: 1 })
    ], ParticleGradientValueBlock.prototype, "reference", void 0);
    RegisterClass("BABYLON.ParticleGradientValueBlock", ParticleGradientValueBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/particleRandomBlock.js
var ParticleRandomBlockLocks, ParticleRandomBlock;
var init_particleRandomBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/particleRandomBlock.js"() {
    init_tslib_es6();
    init_nodeDecorator();
    init_typeStore();
    init_math_color();
    init_math_vector();
    init_nodeParticleBlock();
    init_nodeParticleBlockConnectionPointTypes();
    (function(ParticleRandomBlockLocks2) {
      ParticleRandomBlockLocks2[ParticleRandomBlockLocks2["None"] = 0] = "None";
      ParticleRandomBlockLocks2[ParticleRandomBlockLocks2["PerParticle"] = 1] = "PerParticle";
      ParticleRandomBlockLocks2[ParticleRandomBlockLocks2["PerSystem"] = 2] = "PerSystem";
      ParticleRandomBlockLocks2[ParticleRandomBlockLocks2["OncePerParticle"] = 3] = "OncePerParticle";
    })(ParticleRandomBlockLocks || (ParticleRandomBlockLocks = {}));
    ParticleRandomBlock = class extends NodeParticleBlock {
      /**
       * Create a new ParticleRandomBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this._currentLockId = -2;
        this._oncePerParticleMap = /* @__PURE__ */ new Map();
        this.lockMode = ParticleRandomBlockLocks.PerParticle;
        this.registerInput("min", NodeParticleBlockConnectionPointTypes.AutoDetect, true, 0);
        this.registerInput("max", NodeParticleBlockConnectionPointTypes.AutoDetect, true, 1);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.BasedOnInput);
        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeParticleBlockConnectionPointTypes.Float | NodeParticleBlockConnectionPointTypes.Int | NodeParticleBlockConnectionPointTypes.Vector2 | NodeParticleBlockConnectionPointTypes.Vector3 | NodeParticleBlockConnectionPointTypes.Color4);
        this._inputs[1].addExcludedConnectionPointFromAllowedTypes(NodeParticleBlockConnectionPointTypes.Float | NodeParticleBlockConnectionPointTypes.Int | NodeParticleBlockConnectionPointTypes.Vector2 | NodeParticleBlockConnectionPointTypes.Vector3 | NodeParticleBlockConnectionPointTypes.Color4);
        this._outputs[0]._typeConnectionSource = this._inputs[0];
        this._outputs[0]._defaultConnectionPointType = NodeParticleBlockConnectionPointTypes.Float;
        this._linkConnectionTypes(0, 1);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "ParticleRandomBlock";
      }
      /**
       * Gets the min input component
       */
      get min() {
        return this._inputs[0];
      }
      /**
       * Gets the max input component
       */
      get max() {
        return this._inputs[1];
      }
      /**
       * Gets the geometry output component
       */
      get output() {
        return this._outputs[0];
      }
      _build() {
        let func = null;
        this._currentLockId = -2;
        this._oncePerParticleMap.clear();
        switch (this.min.type) {
          case NodeParticleBlockConnectionPointTypes.AutoDetect:
          case NodeParticleBlockConnectionPointTypes.Int:
          case NodeParticleBlockConnectionPointTypes.Float: {
            func = (state) => {
              const min = this.min.getConnectedValue(state) ?? 0;
              const max = this.max.getConnectedValue(state) ?? 1;
              return min + Math.random() * (max - min);
            };
            break;
          }
          case NodeParticleBlockConnectionPointTypes.Vector2: {
            func = (state) => {
              const min = this.min.getConnectedValue(state) ?? Vector2.Zero();
              const max = this.max.getConnectedValue(state) ?? Vector2.One();
              return new Vector2(min.x + Math.random() * (max.x - min.x), min.y + Math.random() * (max.y - min.y));
            };
            break;
          }
          case NodeParticleBlockConnectionPointTypes.Vector3: {
            func = (state) => {
              const min = this.min.getConnectedValue(state) ?? Vector3.Zero();
              const max = this.max.getConnectedValue(state) ?? Vector3.One();
              return new Vector3(min.x + Math.random() * (max.x - min.x), min.y + Math.random() * (max.y - min.y), min.z + Math.random() * (max.z - min.z));
            };
            break;
          }
          case NodeParticleBlockConnectionPointTypes.Color4: {
            func = (state) => {
              const min = this.min.getConnectedValue(state) ?? new Color4(0, 0, 0, 0);
              const max = this.max.getConnectedValue(state) ?? new Color4(1, 1, 1, 1);
              return new Color4(min.r + Math.random() * (max.r - min.r), min.g + Math.random() * (max.g - min.g), min.b + Math.random() * (max.b - min.b), min.a + Math.random() * (max.a - min.a));
            };
            break;
          }
        }
        this.output._storedFunction = (state) => {
          if (this.lockMode === ParticleRandomBlockLocks.OncePerParticle) {
            const particleId = state.particleContext?.id ?? -1;
            let cachedValue = this._oncePerParticleMap.get(particleId);
            if (!cachedValue) {
              cachedValue = func(state);
              this._oncePerParticleMap.set(particleId, cachedValue);
            }
            this.output._storedValue = cachedValue;
          } else {
            let lockId = -2;
            switch (this.lockMode) {
              case ParticleRandomBlockLocks.PerParticle:
                lockId = state.particleContext?.id ?? -1;
                break;
              case ParticleRandomBlockLocks.PerSystem:
                lockId = state.buildId ?? 0;
                break;
              default:
                break;
            }
            if (this.lockMode === ParticleRandomBlockLocks.None || this._currentLockId !== lockId) {
              if (this.lockMode !== ParticleRandomBlockLocks.None) {
                this._currentLockId = lockId;
              }
              this.output._storedValue = func(state);
            }
          }
          return this.output._storedValue;
        };
      }
      /**
       * Serializes this block in a JSON representation
       * @returns the serialized block object
       */
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.lockMode = this.lockMode;
        return serializationObject;
      }
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        this.lockMode = serializationObject.lockMode;
      }
    };
    __decorate([
      editableInPropertyPage("LockMode", 5, "ADVANCED", {
        notifiers: { rebuild: true },
        embedded: true,
        options: [
          { label: "None", value: ParticleRandomBlockLocks.None },
          { label: "Per particle", value: ParticleRandomBlockLocks.PerParticle },
          { label: "Per system", value: ParticleRandomBlockLocks.PerSystem },
          { label: "Once per particle", value: ParticleRandomBlockLocks.OncePerParticle }
        ]
      })
    ], ParticleRandomBlock.prototype, "lockMode", void 0);
    RegisterClass("BABYLON.ParticleRandomBlock", ParticleRandomBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/particleVectorLengthBlock.js
var ParticleVectorLengthBlock;
var init_particleVectorLengthBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/particleVectorLengthBlock.js"() {
    init_typeStore();
    init_nodeParticleBlock();
    init_nodeParticleBlockConnectionPointTypes();
    ParticleVectorLengthBlock = class extends NodeParticleBlock {
      /**
       * Creates a new ParticleVectorLengthBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.registerInput("input", NodeParticleBlockConnectionPointTypes.AutoDetect);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Float);
        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeParticleBlockConnectionPointTypes.Vector2 | NodeParticleBlockConnectionPointTypes.Vector3);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "ParticleVectorLengthBlock";
      }
      /**
       * Gets the input operand input component
       */
      get input() {
        return this._inputs[0];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      _build() {
        if (!this.input.isConnected) {
          this.output._storedFunction = null;
          this.output._storedValue = null;
          return;
        }
        this.output._storedFunction = (state) => {
          const input = this.input.getConnectedValue(state);
          return input.length();
        };
      }
    };
    RegisterClass("BABYLON.ParticleVectorLengthBlock", ParticleVectorLengthBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Conditions/particleConditionBlock.js
var ParticleConditionBlockTests, ParticleConditionBlock;
var init_particleConditionBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Conditions/particleConditionBlock.js"() {
    init_tslib_es6();
    init_typeStore();
    init_math_scalar_functions();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleBlock();
    init_nodeDecorator();
    (function(ParticleConditionBlockTests2) {
      ParticleConditionBlockTests2[ParticleConditionBlockTests2["Equal"] = 0] = "Equal";
      ParticleConditionBlockTests2[ParticleConditionBlockTests2["NotEqual"] = 1] = "NotEqual";
      ParticleConditionBlockTests2[ParticleConditionBlockTests2["LessThan"] = 2] = "LessThan";
      ParticleConditionBlockTests2[ParticleConditionBlockTests2["GreaterThan"] = 3] = "GreaterThan";
      ParticleConditionBlockTests2[ParticleConditionBlockTests2["LessOrEqual"] = 4] = "LessOrEqual";
      ParticleConditionBlockTests2[ParticleConditionBlockTests2["GreaterOrEqual"] = 5] = "GreaterOrEqual";
      ParticleConditionBlockTests2[ParticleConditionBlockTests2["Xor"] = 6] = "Xor";
      ParticleConditionBlockTests2[ParticleConditionBlockTests2["Or"] = 7] = "Or";
      ParticleConditionBlockTests2[ParticleConditionBlockTests2["And"] = 8] = "And";
    })(ParticleConditionBlockTests || (ParticleConditionBlockTests = {}));
    ParticleConditionBlock = class extends NodeParticleBlock {
      /**
       * Create a new ParticleConditionBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.test = ParticleConditionBlockTests.Equal;
        this.epsilon = 0;
        this.registerInput("left", NodeParticleBlockConnectionPointTypes.Float);
        this.registerInput("right", NodeParticleBlockConnectionPointTypes.Float, true, 0);
        this.registerInput("ifTrue", NodeParticleBlockConnectionPointTypes.AutoDetect, true, 1);
        this.registerInput("ifFalse", NodeParticleBlockConnectionPointTypes.AutoDetect, true, 0);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.BasedOnInput);
        this.output._typeConnectionSource = this._inputs[2];
        this.output._defaultConnectionPointType = NodeParticleBlockConnectionPointTypes.Float;
        this._inputs[0].acceptedConnectionPointTypes.push(NodeParticleBlockConnectionPointTypes.Int);
        this._inputs[1].acceptedConnectionPointTypes.push(NodeParticleBlockConnectionPointTypes.Int);
        this._linkConnectionTypes(2, 3);
        this._inputs[2].excludedConnectionPointTypes.push(NodeParticleBlockConnectionPointTypes.Particle);
        this._inputs[3].excludedConnectionPointTypes.push(NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "ParticleConditionBlock";
      }
      /**
       * Gets the left input component
       */
      get left() {
        return this._inputs[0];
      }
      /**
       * Gets the right input component
       */
      get right() {
        return this._inputs[1];
      }
      /**
       * Gets the ifTrue input component
       */
      get ifTrue() {
        return this._inputs[2];
      }
      /**
       * Gets the ifFalse input component
       */
      get ifFalse() {
        return this._inputs[3];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      _build() {
        const func = (state) => {
          const left = this.left.getConnectedValue(state);
          const right = this.right.getConnectedValue(state);
          let condition = false;
          switch (this.test) {
            case ParticleConditionBlockTests.Equal:
              condition = WithinEpsilon(left, right, this.epsilon);
              break;
            case ParticleConditionBlockTests.NotEqual:
              condition = !WithinEpsilon(left, right, this.epsilon);
              break;
            case ParticleConditionBlockTests.LessThan:
              condition = left < right + this.epsilon;
              break;
            case ParticleConditionBlockTests.GreaterThan:
              condition = left > right - this.epsilon;
              break;
            case ParticleConditionBlockTests.LessOrEqual:
              condition = left <= right + this.epsilon;
              break;
            case ParticleConditionBlockTests.GreaterOrEqual:
              condition = left >= right - this.epsilon;
              break;
            case ParticleConditionBlockTests.Xor:
              condition = !!left && !right || !left && !!right;
              break;
            case ParticleConditionBlockTests.Or:
              condition = !!left || !!right;
              break;
            case ParticleConditionBlockTests.And:
              condition = !!left && !!right;
              break;
          }
          return condition;
        };
        this.output._storedFunction = (state) => {
          if (func(state)) {
            return this.ifTrue.getConnectedValue(state);
          }
          return this.ifFalse.getConnectedValue(state);
        };
      }
      /**
       * Serializes this block in a JSON representation
       * @returns the serialized block object
       */
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.test = this.test;
        serializationObject.epsilon = this.epsilon;
        return serializationObject;
      }
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        this.test = serializationObject.test;
        if (serializationObject.epsilon !== void 0) {
          this.epsilon = serializationObject.epsilon;
        }
      }
    };
    __decorate([
      editableInPropertyPage("Test", 5, "ADVANCED", {
        notifiers: { rebuild: true },
        embedded: true,
        options: [
          { label: "Equal", value: ParticleConditionBlockTests.Equal },
          { label: "NotEqual", value: ParticleConditionBlockTests.NotEqual },
          { label: "LessThan", value: ParticleConditionBlockTests.LessThan },
          { label: "GreaterThan", value: ParticleConditionBlockTests.GreaterThan },
          { label: "LessOrEqual", value: ParticleConditionBlockTests.LessOrEqual },
          { label: "GreaterOrEqual", value: ParticleConditionBlockTests.GreaterOrEqual },
          { label: "Xor", value: ParticleConditionBlockTests.Xor },
          { label: "Or", value: ParticleConditionBlockTests.Or },
          { label: "And", value: ParticleConditionBlockTests.And }
        ]
      })
    ], ParticleConditionBlock.prototype, "test", void 0);
    __decorate([
      editableInPropertyPage("Epsilon", 1, "ADVANCED", { embedded: true, notifiers: { rebuild: true } })
    ], ParticleConditionBlock.prototype, "epsilon", void 0);
    RegisterClass("BABYLON.ParticleConditionBlock", ParticleConditionBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/coneShapeBlock.js
var ConeShapeBlock;
var init_coneShapeBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/coneShapeBlock.js"() {
    init_tslib_es6();
    init_typeStore();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleBlock();
    init_math_scalar_functions();
    init_math_vector();
    init_nodeDecorator();
    init_emitters_functions();
    ConeShapeBlock = class extends NodeParticleBlock {
      /**
       * Create a new ConeShapeBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.emitFromSpawnPointOnly = false;
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerInput("radius", NodeParticleBlockConnectionPointTypes.Float, true, 1);
        this.registerInput("angle", NodeParticleBlockConnectionPointTypes.Float, true, Math.PI);
        this.registerInput("radiusRange", NodeParticleBlockConnectionPointTypes.Float, true, 1);
        this.registerInput("heightRange", NodeParticleBlockConnectionPointTypes.Float, true, 1);
        this.registerInput("directionRandomizer", NodeParticleBlockConnectionPointTypes.Float, true, 0);
        this.registerInput("direction1", NodeParticleBlockConnectionPointTypes.Vector3, true);
        this.registerInput("direction2", NodeParticleBlockConnectionPointTypes.Vector3, true);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "ConeShapeBlock";
      }
      /**
       * Gets the particle input component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the radius input component
       */
      get radius() {
        return this._inputs[1];
      }
      /**
       * Gets the angle input component
       */
      get angle() {
        return this._inputs[2];
      }
      /**
       * Gets the radiusRange input component
       */
      get radiusRange() {
        return this._inputs[3];
      }
      /**
       * Gets the heightRange input component
       */
      get heightRange() {
        return this._inputs[4];
      }
      /**
       * Gets the directionRandomizer input component
       */
      get directionRandomizer() {
        return this._inputs[5];
      }
      /**
       * Gets the direction1 input component
       */
      get direction1() {
        return this._inputs[6];
      }
      /**
       * Gets the direction2 input component
       */
      get direction2() {
        return this._inputs[7];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Builds the block
       * @param state defines the build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        system._directionCreation.process = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          if (this.direction1.isConnected === false || this.direction2.isConnected === false) {
            const directionRandomizer = this.directionRandomizer.getConnectedValue(state);
            const direction = particle.position.subtract(state.emitterPosition).normalize();
            const randX = RandomRange(0, directionRandomizer);
            const randY = RandomRange(0, directionRandomizer);
            const randZ = RandomRange(0, directionRandomizer);
            direction.x += randX;
            direction.y += randY;
            direction.z += randZ;
            direction.normalize();
            if (system.isLocal) {
              particle.direction.copyFromFloats(direction.x, direction.y, direction.z);
            } else {
              Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, state.emitterWorldMatrix, particle.direction);
            }
          } else {
            const direction1 = this.direction1.getConnectedValue(state);
            const direction2 = this.direction2.getConnectedValue(state);
            const randX = RandomRange(direction1.x, direction2.x);
            const randY = RandomRange(direction1.y, direction2.y);
            const randZ = RandomRange(direction1.z, direction2.z);
            if (system.isLocal) {
              particle.direction.copyFromFloats(randX, randY, randZ);
            } else {
              Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, state.emitterWorldMatrix, particle.direction);
            }
          }
          particle._initialDirection = particle.direction.clone();
        };
        system._positionCreation.process = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          const radius = this.radius.getConnectedValue(state);
          const angle = this.angle.getConnectedValue(state);
          const radiusRange = this.radiusRange.getConnectedValue(state);
          const heightRange = this.heightRange.getConnectedValue(state);
          let h;
          if (!this.emitFromSpawnPointOnly) {
            h = RandomRange(0, heightRange);
            h = 1 - h * h;
          } else {
            h = 1e-4;
          }
          let newRadius = radius - RandomRange(0, radius * radiusRange);
          newRadius = newRadius * h;
          const s = RandomRange(0, Math.PI * 2);
          const randX = newRadius * Math.sin(s);
          const randZ = newRadius * Math.cos(s);
          const randY = h * this._calculateHeight(angle, radius);
          if (system.isLocal) {
            particle.position.copyFromFloats(randX, randY, randZ);
          } else {
            Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, state.emitterWorldMatrix, particle.position);
          }
          _CreateLocalPositionData(particle);
        };
        this.output._storedValue = system;
      }
      _calculateHeight(angle, radius) {
        if (angle !== 0) {
          return radius / Math.tan(angle / 2);
        } else {
          return 1;
        }
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;
        return serializationObject;
      }
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly;
      }
    };
    __decorate([
      editableInPropertyPage("Emit from spawn point only", 0, "ADVANCED", { embedded: true, notifiers: { rebuild: true } })
    ], ConeShapeBlock.prototype, "emitFromSpawnPointOnly", void 0);
    RegisterClass("BABYLON.ConeShapeBlock", ConeShapeBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/cylinderShapeBlock.js
var CylinderShapeBlock;
var init_cylinderShapeBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/cylinderShapeBlock.js"() {
    init_math_scalar_functions();
    init_typeStore();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleBlock();
    init_math_vector();
    init_emitters_functions();
    CylinderShapeBlock = class extends NodeParticleBlock {
      /**
       * Create a new CylinderShapeBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this._tempVector = Vector3.Zero();
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerInput("radius", NodeParticleBlockConnectionPointTypes.Float, true, 1);
        this.registerInput("height", NodeParticleBlockConnectionPointTypes.Float, true, 1, 0);
        this.registerInput("radiusRange", NodeParticleBlockConnectionPointTypes.Float, true, 1, 0, 1);
        this.registerInput("directionRandomizer", NodeParticleBlockConnectionPointTypes.Float, true, 0, 0, 1);
        this.registerInput("direction1", NodeParticleBlockConnectionPointTypes.Vector3, true);
        this.registerInput("direction2", NodeParticleBlockConnectionPointTypes.Vector3, true);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "CylinderShapeBlock";
      }
      /**
       * Gets the particle component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the radius input component
       */
      get radius() {
        return this._inputs[1];
      }
      /**
       * Gets the height input component
       */
      get height() {
        return this._inputs[2];
      }
      /**
       * Gets the radiusRange input component
       */
      get radiusRange() {
        return this._inputs[3];
      }
      /**
       * Gets the directionRandomizer input component
       */
      get directionRandomizer() {
        return this._inputs[4];
      }
      /**
       * Gets the direction1 input component
       */
      get direction1() {
        return this._inputs[5];
      }
      /**
       * Gets the direction2 input component
       */
      get direction2() {
        return this._inputs[6];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Builds the block
       * @param state defines the build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        system._directionCreation.process = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          if (this.direction1.isConnected === false || this.direction2.isConnected === false) {
            const directionRandomizer = this.directionRandomizer.getConnectedValue(state);
            particle.position.subtractToRef(state.emitterPosition, this._tempVector);
            this._tempVector.normalize();
            if (state.emitterInverseWorldMatrix) {
              Vector3.TransformNormalToRef(this._tempVector, state.emitterInverseWorldMatrix, this._tempVector);
            }
            const randY = RandomRange(-directionRandomizer / 2, directionRandomizer / 2);
            let angle = Math.atan2(this._tempVector.x, this._tempVector.z);
            angle += RandomRange(-Math.PI / 2, Math.PI / 2) * directionRandomizer;
            this._tempVector.y = randY;
            this._tempVector.x = Math.sin(angle);
            this._tempVector.z = Math.cos(angle);
            this._tempVector.normalize();
            if (system.isLocal) {
              particle.direction.copyFrom(this._tempVector);
            } else {
              Vector3.TransformNormalFromFloatsToRef(this._tempVector.x, this._tempVector.y, this._tempVector.z, state.emitterWorldMatrix, particle.direction);
            }
          } else {
            const direction1 = this.direction1.getConnectedValue(state);
            const direction2 = this.direction2.getConnectedValue(state);
            const randX = RandomRange(direction1.x, direction2.x);
            const randY = RandomRange(direction1.y, direction2.y);
            const randZ = RandomRange(direction1.z, direction2.z);
            if (system.isLocal) {
              particle.direction.copyFromFloats(randX, randY, randZ);
            } else {
              Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, state.emitterWorldMatrix, particle.direction);
            }
          }
          particle._initialDirection = particle.direction.clone();
        };
        system._positionCreation.process = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          const height = this.height.getConnectedValue(state);
          const radiusRange = this.radiusRange.getConnectedValue(state);
          const radius = this.radius.getConnectedValue(state);
          const yPos = RandomRange(-height / 2, height / 2);
          const angle = RandomRange(0, 2 * Math.PI);
          const radiusDistribution = RandomRange((1 - radiusRange) * (1 - radiusRange), 1);
          const positionRadius = Math.sqrt(radiusDistribution) * radius;
          const xPos = positionRadius * Math.cos(angle);
          const zPos = positionRadius * Math.sin(angle);
          if (system.isLocal) {
            particle.position.copyFromFloats(xPos, yPos, zPos);
          } else {
            Vector3.TransformCoordinatesFromFloatsToRef(xPos, yPos, zPos, state.emitterWorldMatrix, particle.position);
          }
          _CreateLocalPositionData(particle);
        };
        this.output._storedValue = system;
      }
    };
    RegisterClass("BABYLON.CylinderShapeBlock", CylinderShapeBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/customShapeBlock.js
var CustomShapeBlock;
var init_customShapeBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/customShapeBlock.js"() {
    init_math_vector();
    init_typeStore();
    init_customParticleEmitter();
    init_nodeParticleBlock();
    init_nodeParticleBlockConnectionPointTypes();
    init_emitters_functions();
    CustomShapeBlock = class extends NodeParticleBlock {
      /**
       * Create a new CustomShapeBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.particlePositionGenerator = EmptyGeneratorFunc;
        this.particleDestinationGenerator = EmptyGeneratorFunc;
        this.particleDirectionGenerator = EmptyGeneratorFunc;
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "CustomShapeBlock";
      }
      /**
       * Gets the particle component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Builds the block
       * @param state defines the build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        system._directionCreation.process = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          const tmpVector = TmpVectors.Vector3[0];
          if (this.particleDirectionGenerator && this.particleDirectionGenerator !== EmptyGeneratorFunc) {
            this.particleDirectionGenerator(-1, particle, tmpVector);
          } else if (this.particleDestinationGenerator && this.particleDestinationGenerator !== EmptyGeneratorFunc) {
            this.particleDestinationGenerator(-1, particle, tmpVector);
            const diffVector = TmpVectors.Vector3[1];
            tmpVector.subtractToRef(particle.position, diffVector);
            diffVector.scaleToRef(1 / particle.lifeTime, tmpVector);
          } else {
            tmpVector.set(0, 0, 0);
          }
          if (system.isLocal) {
            particle.direction.copyFrom(tmpVector);
          } else {
            Vector3.TransformNormalToRef(tmpVector, state.emitterWorldMatrix, particle.direction);
          }
          particle._initialDirection = particle.direction.clone();
        };
        system._positionCreation.process = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          const tmpVector = TmpVectors.Vector3[0];
          if (this.particlePositionGenerator && this.particlePositionGenerator !== EmptyGeneratorFunc) {
            this.particlePositionGenerator(-1, particle, tmpVector);
          } else {
            tmpVector.set(0, 0, 0);
          }
          if (system.isLocal) {
            particle.position.copyFrom(tmpVector);
          } else {
            Vector3.TransformCoordinatesToRef(tmpVector, state.emitterWorldMatrix, particle.position);
          }
          _CreateLocalPositionData(particle);
        };
        this.output._storedValue = system;
      }
    };
    RegisterClass("BABYLON.CustomShapeBlock", CustomShapeBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/meshShapeBlock.js
var MeshShapeBlock;
var init_meshShapeBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/meshShapeBlock.js"() {
    init_tslib_es6();
    init_typeStore();
    init_mesh_vertexData();
    init_nodeDecorator();
    init_nodeParticleBlock();
    init_nodeParticleBlockConnectionPointTypes();
    init_math_vector();
    init_math_scalar_functions();
    init_emitters_functions();
    MeshShapeBlock = class extends NodeParticleBlock {
      /**
       * Gets or sets the mesh to use to get vertex data
       */
      get mesh() {
        return this._mesh;
      }
      set mesh(value) {
        this._mesh = value;
      }
      /**
       * Create a new MeshShapeBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this._cachedVertexData = null;
        this._indices = null;
        this._positions = null;
        this._normals = null;
        this._colors = null;
        this._storedNormal = Vector3.Zero();
        this.serializedCachedData = false;
        this.useMeshNormalsForDirection = true;
        this.useMeshColorForColor = false;
        this.worldSpace = false;
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerInput("direction1", NodeParticleBlockConnectionPointTypes.Vector3, true, new Vector3(0, 1, 0));
        this.registerInput("direction2", NodeParticleBlockConnectionPointTypes.Vector3, true, new Vector3(0, 1, 0));
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "MeshShapeBlock";
      }
      /**
       * Gets a boolean indicating if the block is using cached data
       */
      get isUsingCachedData() {
        return !this.mesh && !!this._cachedVertexData;
      }
      /**
       * Gets the particle component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the direction1 input component
       */
      get direction1() {
        return this._inputs[1];
      }
      /**
       * Gets the direction2 input component
       */
      get direction2() {
        return this._inputs[2];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Remove stored data
       */
      cleanData() {
        this._mesh = null;
        this._cachedVertexData = null;
      }
      /**
       * Builds the block
       * @param state defines the build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        if (!this._mesh && !this._cachedVertexData) {
          this.output._storedValue = system;
          return;
        }
        if (this._mesh) {
          this._cachedVertexData = VertexData.ExtractFromMesh(this._mesh, false, true);
        }
        if (!this._cachedVertexData) {
          this.output._storedValue = system;
          return;
        }
        this._indices = this._cachedVertexData.indices;
        this._positions = this._cachedVertexData.positions;
        this._normals = this._cachedVertexData.normals;
        this._colors = this._cachedVertexData.colors;
        if (this.useMeshColorForColor && this._colors) {
          system._colorCreation.process = () => {
          };
        }
        system._directionCreation.process = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          if (this.useMeshNormalsForDirection && this._normals) {
            if (system.isLocal) {
              particle.direction.copyFrom(this._storedNormal);
            } else {
              Vector3.TransformNormalToRef(this._storedNormal, state.emitterWorldMatrix, particle.direction);
            }
            return;
          }
          const direction1 = this.direction1.getConnectedValue(state);
          const direction2 = this.direction2.getConnectedValue(state);
          const randX = RandomRange(direction1.x, direction2.x);
          const randY = RandomRange(direction1.y, direction2.y);
          const randZ = RandomRange(direction1.z, direction2.z);
          if (system.isLocal) {
            particle.direction.copyFromFloats(randX, randY, randZ);
          } else {
            Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, state.emitterWorldMatrix, particle.direction);
          }
          particle._initialDirection = particle.direction.clone();
        };
        system._positionCreation.process = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          if (!this._indices || !this._positions) {
            return;
          }
          const randomFaceIndex = 3 * (Math.random() * (this._indices.length / 3) | 0);
          const bu = Math.random();
          const bv = Math.random() * (1 - bu);
          const bw = 1 - bu - bv;
          const faceIndexA = this._indices[randomFaceIndex];
          const faceIndexB = this._indices[randomFaceIndex + 1];
          const faceIndexC = this._indices[randomFaceIndex + 2];
          const vertexA = TmpVectors.Vector3[0];
          const vertexB = TmpVectors.Vector3[1];
          const vertexC = TmpVectors.Vector3[2];
          const randomVertex = TmpVectors.Vector3[3];
          Vector3.FromArrayToRef(this._positions, faceIndexA * 3, vertexA);
          Vector3.FromArrayToRef(this._positions, faceIndexB * 3, vertexB);
          Vector3.FromArrayToRef(this._positions, faceIndexC * 3, vertexC);
          randomVertex.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;
          randomVertex.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;
          randomVertex.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;
          if (this.worldSpace && this.mesh) {
            Vector3.TransformCoordinatesFromFloatsToRef(randomVertex.x, randomVertex.y, randomVertex.z, this.mesh.getWorldMatrix(), randomVertex);
          }
          if (system.isLocal) {
            particle.position.copyFromFloats(randomVertex.x, randomVertex.y, randomVertex.z);
          } else {
            Vector3.TransformCoordinatesFromFloatsToRef(randomVertex.x, randomVertex.y, randomVertex.z, state.emitterWorldMatrix, particle.position);
          }
          _CreateLocalPositionData(particle);
          if (this.useMeshNormalsForDirection && this._normals) {
            Vector3.FromArrayToRef(this._normals, faceIndexA * 3, vertexA);
            Vector3.FromArrayToRef(this._normals, faceIndexB * 3, vertexB);
            Vector3.FromArrayToRef(this._normals, faceIndexC * 3, vertexC);
            this._storedNormal.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;
            this._storedNormal.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;
            this._storedNormal.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;
          }
          if (this.useMeshColorForColor && this._colors) {
            Vector4.FromArrayToRef(this._colors, faceIndexA * 4, TmpVectors.Vector4[0]);
            Vector4.FromArrayToRef(this._colors, faceIndexB * 4, TmpVectors.Vector4[1]);
            Vector4.FromArrayToRef(this._colors, faceIndexC * 4, TmpVectors.Vector4[2]);
            particle.color.copyFromFloats(bu * TmpVectors.Vector4[0].x + bv * TmpVectors.Vector4[1].x + bw * TmpVectors.Vector4[2].x, bu * TmpVectors.Vector4[0].y + bv * TmpVectors.Vector4[1].y + bw * TmpVectors.Vector4[2].y, bu * TmpVectors.Vector4[0].z + bv * TmpVectors.Vector4[1].z + bw * TmpVectors.Vector4[2].z, bu * TmpVectors.Vector4[0].w + bv * TmpVectors.Vector4[1].w + bw * TmpVectors.Vector4[2].w);
          }
        };
        this.output._storedValue = system;
      }
      /**
       * Serializes this block in a JSON representation
       * @returns the serialized block object
       */
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.serializedCachedData = this.serializedCachedData;
        if (this.serializedCachedData) {
          if (this._mesh) {
            serializationObject.cachedVertexData = VertexData.ExtractFromMesh(this._mesh, false, true).serialize();
          } else if (this._cachedVertexData) {
            serializationObject.cachedVertexData = this._cachedVertexData.serialize();
          }
        }
        serializationObject.useMeshNormalsForDirection = this.useMeshNormalsForDirection;
        serializationObject.useMeshColorForColor = this.useMeshColorForColor;
        serializationObject.worldSpace = this.worldSpace;
        return serializationObject;
      }
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        if (serializationObject.cachedVertexData) {
          this._cachedVertexData = VertexData.Parse(serializationObject.cachedVertexData);
        }
        this.serializedCachedData = !!serializationObject.serializedCachedData;
        this.useMeshNormalsForDirection = !!serializationObject.useMeshNormalsForDirection;
        this.useMeshColorForColor = !!serializationObject.useMeshColorForColor;
        this.worldSpace = !!serializationObject.worldSpace;
      }
    };
    __decorate([
      editableInPropertyPage("Serialize cached data", 0, "ADVANCED", { embedded: true, notifiers: { rebuild: true } })
    ], MeshShapeBlock.prototype, "serializedCachedData", void 0);
    __decorate([
      editableInPropertyPage("Use normals for direction", 0, "ADVANCED", { embedded: true, notifiers: { rebuild: true } })
    ], MeshShapeBlock.prototype, "useMeshNormalsForDirection", void 0);
    __decorate([
      editableInPropertyPage("Use vertex color for color", 0, "ADVANCED", { embedded: true, notifiers: { rebuild: true } })
    ], MeshShapeBlock.prototype, "useMeshColorForColor", void 0);
    __decorate([
      editableInPropertyPage("World space", 0, "ADVANCED", { embedded: true, notifiers: { rebuild: true } })
    ], MeshShapeBlock.prototype, "worldSpace", void 0);
    RegisterClass("BABYLON.MeshShapeBlock", MeshShapeBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/pointShapeBlock.js
var PointShapeBlock;
var init_pointShapeBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/pointShapeBlock.js"() {
    init_typeStore();
    init_nodeParticleBlockConnectionPointTypes();
    init_math_vector();
    init_nodeParticleBlock();
    init_math_scalar_functions();
    init_emitters_functions();
    PointShapeBlock = class extends NodeParticleBlock {
      /**
       * Create a new PointShapeBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerInput("direction1", NodeParticleBlockConnectionPointTypes.Vector3, true, new Vector3(0, 1, 0));
        this.registerInput("direction2", NodeParticleBlockConnectionPointTypes.Vector3, true, new Vector3(0, 1, 0));
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "PointShapeBlock";
      }
      /**
       * Gets the particle component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the direction1 input component
       */
      get direction1() {
        return this._inputs[1];
      }
      /**
       * Gets the direction2 input component
       */
      get direction2() {
        return this._inputs[2];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Builds the block
       * @param state defines the build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        system._directionCreation.process = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          const direction1 = this.direction1.getConnectedValue(state);
          const direction2 = this.direction2.getConnectedValue(state);
          const randX = RandomRange(direction1.x, direction2.x);
          const randY = RandomRange(direction1.y, direction2.y);
          const randZ = RandomRange(direction1.z, direction2.z);
          if (system.isLocal) {
            particle.direction.copyFromFloats(randX, randY, randZ);
          } else {
            Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, state.emitterWorldMatrix, particle.direction);
          }
          particle._initialDirection = particle.direction.clone();
        };
        system._positionCreation.process = (particle) => {
          state.systemContext = system;
          if (system.isLocal) {
            particle.position.copyFromFloats(0, 0, 0);
          } else {
            Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, state.emitterWorldMatrix, particle.position);
          }
          _CreateLocalPositionData(particle);
        };
        this.output._storedValue = system;
      }
    };
    RegisterClass("BABYLON.PointShapeBlock", PointShapeBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/setupSpriteSheetBlock.js
var SetupSpriteSheetBlock;
var init_setupSpriteSheetBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/setupSpriteSheetBlock.js"() {
    init_tslib_es6();
    init_nodeDecorator();
    init_typeStore();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleBlock();
    SetupSpriteSheetBlock = class extends NodeParticleBlock {
      /**
       * Creates a new SetupSpriteSheetBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.start = 0;
        this.end = 8;
        this.width = 64;
        this.height = 64;
        this.spriteCellChangeSpeed = 1;
        this.loop = false;
        this.randomStartCell = false;
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
        this._outputs[0]._typeConnectionSource = this._inputs[0];
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "SetupSpriteSheetBlock";
      }
      /**
       * Gets the particle component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      _build(state) {
        super._build(state);
        const system = this.particle.getConnectedValue(state);
        system._isAnimationSheetEnabled = true;
        system.spriteCellWidth = this.width;
        system.spriteCellHeight = this.height;
        system.startSpriteCellID = this.start;
        system.endSpriteCellID = this.end;
        system.spriteCellLoop = this.loop;
        system.spriteRandomStartCell = this.randomStartCell;
        system.spriteCellChangeSpeed = this.spriteCellChangeSpeed;
        this.output._storedValue = system;
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.width = this.width;
        serializationObject.height = this.height;
        serializationObject.start = this.start;
        serializationObject.end = this.end;
        serializationObject.spriteCellChangeSpeed = this.spriteCellChangeSpeed;
        serializationObject.loop = this.loop;
        serializationObject.randomStartCell = this.randomStartCell;
        return serializationObject;
      }
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        this.width = serializationObject.width;
        this.height = serializationObject.height;
        this.start = serializationObject.start;
        this.end = serializationObject.end;
        this.spriteCellChangeSpeed = serializationObject.spriteCellChangeSpeed;
        this.loop = serializationObject.loop;
        this.randomStartCell = serializationObject.randomStartCell;
      }
    };
    __decorate([
      editableInPropertyPage("Start", 2, "ADVANCED", { embedded: true, notifiers: { rebuild: true }, min: 0 })
    ], SetupSpriteSheetBlock.prototype, "start", void 0);
    __decorate([
      editableInPropertyPage("End", 2, "ADVANCED", { embedded: true, notifiers: { rebuild: true }, min: 0 })
    ], SetupSpriteSheetBlock.prototype, "end", void 0);
    __decorate([
      editableInPropertyPage("Width", 1, "ADVANCED", { embedded: true, notifiers: { rebuild: true }, min: 0 })
    ], SetupSpriteSheetBlock.prototype, "width", void 0);
    __decorate([
      editableInPropertyPage("Height", 1, "ADVANCED", { embedded: true, notifiers: { rebuild: true }, min: 0 })
    ], SetupSpriteSheetBlock.prototype, "height", void 0);
    __decorate([
      editableInPropertyPage("Sprite Cell Change Speed", 1, "ADVANCED", { embedded: true, notifiers: { rebuild: true }, min: 0 })
    ], SetupSpriteSheetBlock.prototype, "spriteCellChangeSpeed", void 0);
    __decorate([
      editableInPropertyPage("Loop", 0, "ADVANCED", { embedded: true, notifiers: { rebuild: true } })
    ], SetupSpriteSheetBlock.prototype, "loop", void 0);
    __decorate([
      editableInPropertyPage("Random start cell", 0, "ADVANCED", { embedded: true, notifiers: { rebuild: true } })
    ], SetupSpriteSheetBlock.prototype, "randomStartCell", void 0);
    RegisterClass("BABYLON.SetupSpriteSheetBlock", SetupSpriteSheetBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/sphereShapeBlock.js
var SphereShapeBlock;
var init_sphereShapeBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Emitters/sphereShapeBlock.js"() {
    init_tslib_es6();
    init_typeStore();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleBlock();
    init_math_vector();
    init_math_scalar_functions();
    init_emitters_functions();
    init_nodeDecorator();
    SphereShapeBlock = class extends NodeParticleBlock {
      /**
       * Create a new SphereShapeBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.isHemispheric = false;
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerInput("radius", NodeParticleBlockConnectionPointTypes.Float, true, 1);
        this.registerInput("radiusRange", NodeParticleBlockConnectionPointTypes.Float, true, 1, 0, 1);
        this.registerInput("directionRandomizer", NodeParticleBlockConnectionPointTypes.Float, true, 0, 0, 1);
        this.registerInput("direction1", NodeParticleBlockConnectionPointTypes.Vector3, true);
        this.registerInput("direction2", NodeParticleBlockConnectionPointTypes.Vector3, true);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "SphereShapeBlock";
      }
      /**
       * Gets the particle component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the radius input component
       */
      get radius() {
        return this._inputs[1];
      }
      /**
       * Gets the radiusRange input component
       */
      get radiusRange() {
        return this._inputs[2];
      }
      /**
       * Gets the directionRandomizer input component
       */
      get directionRandomizer() {
        return this._inputs[3];
      }
      /**
       * Gets the direction1 input component
       */
      get direction1() {
        return this._inputs[4];
      }
      /**
       * Gets the direction2 input component
       */
      get direction2() {
        return this._inputs[5];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Builds the block
       * @param state defines the build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        system._directionCreation.process = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          if (this.direction1.isConnected === false || this.direction2.isConnected === false) {
            const directionRandomizer = this.directionRandomizer.getConnectedValue(state);
            const direction = particle.position.subtract(state.emitterPosition).normalize();
            const randX = RandomRange(0, directionRandomizer);
            const randY = RandomRange(0, directionRandomizer);
            const randZ = RandomRange(0, directionRandomizer);
            direction.x += randX;
            direction.y += randY;
            direction.z += randZ;
            direction.normalize();
            if (system.isLocal) {
              particle.direction.copyFromFloats(direction.x, direction.y, direction.z);
            } else {
              Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, state.emitterWorldMatrix, particle.direction);
            }
          } else {
            const direction1 = this.direction1.getConnectedValue(state);
            const direction2 = this.direction2.getConnectedValue(state);
            const randX = RandomRange(direction1.x, direction2.x);
            const randY = RandomRange(direction1.y, direction2.y);
            const randZ = RandomRange(direction1.z, direction2.z);
            if (system.isLocal) {
              particle.direction.copyFromFloats(randX, randY, randZ);
            } else {
              Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, state.emitterWorldMatrix, particle.direction);
            }
          }
          particle._initialDirection = particle.direction.clone();
        };
        system._positionCreation.process = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          const radius = this.radius.getConnectedValue(state);
          const radiusRange = this.radiusRange.getConnectedValue(state);
          const randRadius = radius - RandomRange(0, radius * radiusRange);
          const v = RandomRange(0, 1);
          const phi = RandomRange(0, 2 * Math.PI);
          const theta = Math.acos(2 * v - 1);
          const randX = randRadius * Math.cos(phi) * Math.sin(theta);
          let randY = randRadius * Math.cos(theta);
          const randZ = randRadius * Math.sin(phi) * Math.sin(theta);
          if (this.isHemispheric) {
            randY = Math.abs(randY);
          }
          if (system.isLocal) {
            particle.position.copyFromFloats(randX, randY, randZ);
          } else {
            Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, state.emitterWorldMatrix, particle.position);
          }
          _CreateLocalPositionData(particle);
        };
        this.output._storedValue = system;
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.isHemispheric = this.isHemispheric;
        return serializationObject;
      }
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        this.isHemispheric = serializationObject.isHemispheric;
      }
    };
    __decorate([
      editableInPropertyPage("Is hemispheric", 0, "ADVANCED", { embedded: true, notifiers: { rebuild: true } })
    ], SphereShapeBlock.prototype, "isHemispheric", void 0);
    RegisterClass("BABYLON.SphereShapeBlock", SphereShapeBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updateAngleBlock.js
var UpdateAngleBlock;
var init_updateAngleBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updateAngleBlock.js"() {
    init_typeStore();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleBlock();
    init_executionQueue();
    UpdateAngleBlock = class extends NodeParticleBlock {
      /**
       * Create a new UpdateAngleBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerInput("angle", NodeParticleBlockConnectionPointTypes.Float);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the particle component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the angle input component
       */
      get angle() {
        return this._inputs[1];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "UpdateAngleBlock";
      }
      /**
       * Builds the block
       * @param state defines the current build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        this.output._storedValue = system;
        if (!this.angle.isConnected) {
          return;
        }
        const processAngle = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          particle.angle = this.angle.getConnectedValue(state);
        };
        const angleProcessing = {
          process: processAngle,
          previousItem: null,
          nextItem: null
        };
        if (system._updateQueueStart) {
          _ConnectAtTheEnd(angleProcessing, system._updateQueueStart);
        } else {
          system._updateQueueStart = angleProcessing;
        }
      }
    };
    RegisterClass("BABYLON.UpdateAngleBlock", UpdateAngleBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Update/basicSpriteUpdateBlock.js
var BasicSpriteUpdateBlock;
var init_basicSpriteUpdateBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Update/basicSpriteUpdateBlock.js"() {
    init_typeStore();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleBlock();
    init_executionQueue();
    BasicSpriteUpdateBlock = class extends NodeParticleBlock {
      /**
       * Create a new BasicSpriteUpdateBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the particle component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "BasicSpriteUpdateBlock";
      }
      /**
       * Builds the block
       * @param state defines the current build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        const processSprite = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          particle.updateCellIndex();
        };
        const spriteProcessing = {
          process: processSprite,
          previousItem: null,
          nextItem: null
        };
        if (system._updateQueueStart) {
          _ConnectAtTheEnd(spriteProcessing, system._updateQueueStart);
        } else {
          system._updateQueueStart = spriteProcessing;
        }
        this.output._storedValue = system;
      }
    };
    RegisterClass("BABYLON.BasicSpriteUpdateBlock", BasicSpriteUpdateBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updateAttractorBlock.js
var ToAttractor2, Force2, ScaledForce2, UpdateAttractorBlock;
var init_updateAttractorBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updateAttractorBlock.js"() {
    init_typeStore();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleBlock();
    init_executionQueue();
    init_math_vector();
    ToAttractor2 = Vector3.Zero();
    Force2 = Vector3.Zero();
    ScaledForce2 = Vector3.Zero();
    UpdateAttractorBlock = class extends NodeParticleBlock {
      /**
       * Create a new UpdateAttractorBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerInput("attractor", NodeParticleBlockConnectionPointTypes.Vector3, true, Vector3.Zero());
        this.registerInput("strength", NodeParticleBlockConnectionPointTypes.Float, true, 1);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the particle component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the attractor input component
       */
      get attractor() {
        return this._inputs[1];
      }
      /**
       * Gets the strength input component
       */
      get strength() {
        return this._inputs[2];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "UpdateAttractorBlock";
      }
      /**
       * Builds the block
       * @param state defines the current build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        const processAttractor = (particle) => {
          const attractorPosition = this.attractor.getConnectedValue(state);
          const strength = this.strength.getConnectedValue(state);
          attractorPosition.subtractToRef(particle.position, ToAttractor2);
          const distanceSquared = ToAttractor2.lengthSquared() + 1;
          ToAttractor2.normalize().scaleToRef(strength / distanceSquared, Force2);
          Force2.scaleToRef(system._tempScaledUpdateSpeed, ScaledForce2);
          particle.direction.addInPlace(ScaledForce2);
        };
        const attractorProcessing = {
          process: processAttractor,
          previousItem: null,
          nextItem: null
        };
        if (system._updateQueueStart) {
          _ConnectAtTheEnd(attractorProcessing, system._updateQueueStart);
        } else {
          system._updateQueueStart = attractorProcessing;
        }
        this.output._storedValue = system;
      }
    };
    RegisterClass("BABYLON.UpdateAttractorBlock", UpdateAttractorBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updateColorBlock.js
var UpdateColorBlock;
var init_updateColorBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updateColorBlock.js"() {
    init_typeStore();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleBlock();
    init_executionQueue();
    UpdateColorBlock = class extends NodeParticleBlock {
      /**
       * Create a new UpdateColorBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerInput("color", NodeParticleBlockConnectionPointTypes.Color4);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the particle component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the color input component
       */
      get color() {
        return this._inputs[1];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "UpdateColorBlock";
      }
      /**
       * Builds the block
       * @param state defines the current build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        this.output._storedValue = system;
        if (!this.color.isConnected) {
          return;
        }
        const processColor = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          particle.color.copyFrom(this.color.getConnectedValue(state));
        };
        const colorProcessing = {
          process: processColor,
          previousItem: null,
          nextItem: null
        };
        if (system._updateQueueStart) {
          _ConnectAtTheEnd(colorProcessing, system._updateQueueStart);
        } else {
          system._updateQueueStart = colorProcessing;
        }
      }
    };
    RegisterClass("BABYLON.UpdateColorBlock", UpdateColorBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updateDirectionBlock.js
var UpdateDirectionBlock;
var init_updateDirectionBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updateDirectionBlock.js"() {
    init_typeStore();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleBlock();
    init_executionQueue();
    UpdateDirectionBlock = class extends NodeParticleBlock {
      /**
       * Create a new UpdateDirectionBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerInput("direction", NodeParticleBlockConnectionPointTypes.Vector3);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the particle component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the direction input component
       */
      get direction() {
        return this._inputs[1];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "UpdateDirectionBlock";
      }
      /**
       * Builds the block
       * @param state defines the current build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        this.output._storedValue = system;
        if (!this.direction.isConnected) {
          return;
        }
        const processDirection = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          particle.direction.copyFrom(this.direction.getConnectedValue(state));
        };
        const directionProcessing = {
          process: processDirection,
          previousItem: null,
          nextItem: null
        };
        if (system._updateQueueStart) {
          _ConnectAtTheEnd(directionProcessing, system._updateQueueStart);
        } else {
          system._updateQueueStart = directionProcessing;
        }
      }
    };
    RegisterClass("BABYLON.UpdateDirectionBlock", UpdateDirectionBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updateFlowMapBlock.js
var UpdateFlowMapBlock;
var init_updateFlowMapBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updateFlowMapBlock.js"() {
    init_typeStore();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleBlock();
    init_executionQueue();
    init_flowMap();
    UpdateFlowMapBlock = class extends NodeParticleBlock {
      /**
       * Create a new UpdateFlowMapBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerInput("flowMap", NodeParticleBlockConnectionPointTypes.Texture);
        this.registerInput("strength", NodeParticleBlockConnectionPointTypes.Float, true, 1);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the particle component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the flowMap input component
       */
      get flowMap() {
        return this._inputs[1];
      }
      /**
       * Gets the strength input component
       */
      get strength() {
        return this._inputs[2];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "UpdateFlowMapBlock";
      }
      /**
       * Builds the block
       * @param state defines the current build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        const scene = state.scene;
        const flowMapTexture = this.flowMap.connectedPoint?.ownerBlock;
        let flowMap;
        void flowMapTexture.extractTextureContentAsync().then((textureContent) => {
          if (!textureContent) {
            return;
          }
          flowMap = new FlowMap(textureContent.width, textureContent.height, textureContent.data);
        });
        const processFlowMap = (particle) => {
          const matrix = scene.getTransformMatrix();
          if (!flowMap) {
            return;
          }
          const strength = this.strength.getConnectedValue(state);
          flowMap._processParticle(particle, strength * system._tempScaledUpdateSpeed, matrix);
        };
        const flowMapProcessing = {
          process: processFlowMap,
          previousItem: null,
          nextItem: null
        };
        if (system._updateQueueStart) {
          _ConnectAtTheEnd(flowMapProcessing, system._updateQueueStart);
        } else {
          system._updateQueueStart = flowMapProcessing;
        }
        this.output._storedValue = system;
      }
    };
    RegisterClass("BABYLON.UpdateFlowMapBlock", UpdateFlowMapBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updateNoiseBlock.js
var UpdateNoiseBlock;
var init_updateNoiseBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updateNoiseBlock.js"() {
    init_math_vector();
    init_typeStore();
    init_nodeParticleBlock();
    init_nodeParticleBlockConnectionPointTypes();
    init_executionQueue();
    UpdateNoiseBlock = class extends NodeParticleBlock {
      /**
       * Create a new UpdateNoiseBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerInput("noiseTexture", NodeParticleBlockConnectionPointTypes.Texture);
        this.registerInput("strength", NodeParticleBlockConnectionPointTypes.Vector3, true, new Vector3(100, 100, 100));
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the particle component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the noiseTexture input component
       */
      get noiseTexture() {
        return this._inputs[1];
      }
      /**
       * Gets the strength input component
       */
      get strength() {
        return this._inputs[2];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "UpdateNoiseBlock";
      }
      /**
       * Builds the block
       * @param state defines the current build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        const strength = this.strength.getConnectedValue(state);
        if (!strength) {
          return;
        }
        const noiseTextureBlock = this.noiseTexture.connectedPoint?.ownerBlock;
        if (!noiseTextureBlock) {
          return;
        }
        let noiseTextureData = null;
        let noiseTextureSize = null;
        let lastFrameId = -1;
        const processNoise = (particle) => {
          const texture = noiseTextureBlock.texture._storedValue;
          if (!texture || !texture.isReady()) {
            return;
          }
          const currentFrameId = texture.getScene()?.getFrameId() ?? -1;
          if (currentFrameId !== lastFrameId) {
            lastFrameId = currentFrameId;
            if (!noiseTextureSize) {
              noiseTextureSize = texture.getSize();
            }
            texture.getContent()?.then((data) => {
              noiseTextureData = data;
            });
          }
          if (!noiseTextureData || !noiseTextureSize) {
            return;
          }
          if (!particle._randomNoiseCoordinates1) {
            particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());
          }
          if (!particle._randomNoiseCoordinates2) {
            particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());
          }
          const fetchedColorR = system._fetchR(particle._randomNoiseCoordinates1.x, particle._randomNoiseCoordinates1.y, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
          const fetchedColorG = system._fetchR(particle._randomNoiseCoordinates1.z, particle._randomNoiseCoordinates2.x, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
          const fetchedColorB = system._fetchR(particle._randomNoiseCoordinates2.y, particle._randomNoiseCoordinates2.z, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
          const force = TmpVectors.Vector3[0];
          const scaledForce = TmpVectors.Vector3[1];
          force.copyFromFloats((2 * fetchedColorR - 1) * strength.x, (2 * fetchedColorG - 1) * strength.y, (2 * fetchedColorB - 1) * strength.z);
          force.scaleToRef(system._tempScaledUpdateSpeed, scaledForce);
          particle.direction.addInPlace(scaledForce);
        };
        const noiseProcessing = {
          process: processNoise,
          previousItem: null,
          nextItem: null
        };
        if (system._updateQueueStart) {
          _ConnectAtTheEnd(noiseProcessing, system._updateQueueStart);
        } else {
          system._updateQueueStart = noiseProcessing;
        }
        this.output._storedValue = system;
      }
    };
    RegisterClass("BABYLON.UpdateNoiseBlock", UpdateNoiseBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updateSizeBlock.js
var UpdateSizeBlock;
var init_updateSizeBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updateSizeBlock.js"() {
    init_typeStore();
    init_nodeParticleBlock();
    init_nodeParticleBlockConnectionPointTypes();
    init_executionQueue();
    UpdateSizeBlock = class extends NodeParticleBlock {
      /**
       * Create a new UpdateSizeBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerInput("size", NodeParticleBlockConnectionPointTypes.Float);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the particle component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the size input component
       */
      get size() {
        return this._inputs[1];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "UpdateSizeBlock";
      }
      /**
       * Builds the block
       * @param state defines the current build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        this.output._storedValue = system;
        if (!this.size.isConnected) {
          return;
        }
        const processSize = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          particle.size = this.size.getConnectedValue(state);
        };
        const sizeProcessing = {
          process: processSize,
          previousItem: null,
          nextItem: null
        };
        if (system._updateQueueStart) {
          _ConnectAtTheEnd(sizeProcessing, system._updateQueueStart);
        } else {
          system._updateQueueStart = sizeProcessing;
        }
      }
    };
    RegisterClass("BABYLON.UpdateSizeBlock", UpdateSizeBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updateRemapBlock.js
var UpdateRemapBlock;
var init_updateRemapBlock = __esm({
  "node_modules/@babylonjs/core/Particles/Node/Blocks/Update/updateRemapBlock.js"() {
    init_math_vector();
    init_typeStore();
    init_nodeParticleBlock();
    init_nodeParticleBlockConnectionPointTypes();
    init_executionQueue();
    UpdateRemapBlock = class extends NodeParticleBlock {
      /**
       * Create a new UpdateRemapBlock
       * @param name defines the block name
       */
      constructor(name13) {
        super(name13);
        this.registerInput("particle", NodeParticleBlockConnectionPointTypes.Particle);
        this.registerInput("remapColor", NodeParticleBlockConnectionPointTypes.Vector2, true);
        this.registerInput("remapAlpha", NodeParticleBlockConnectionPointTypes.Vector2, true);
        this.registerOutput("output", NodeParticleBlockConnectionPointTypes.Particle);
      }
      /**
       * Gets the particle component
       */
      get particle() {
        return this._inputs[0];
      }
      /**
       * Gets the remapColor input component
       */
      get remapColor() {
        return this._inputs[1];
      }
      /**
       * Gets the remapAlpha input component
       */
      get remapAlpha() {
        return this._inputs[2];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "UpdateRemapBlock";
      }
      /**
       * Builds the block
       * @param state defines the current build state
       */
      _build(state) {
        const system = this.particle.getConnectedValue(state);
        this.output._storedValue = system;
        if (!this.remapColor.isConnected && !this.remapAlpha.isConnected) {
          return;
        }
        const processRemap = (particle) => {
          state.particleContext = particle;
          state.systemContext = system;
          const colorRemap = this.remapColor.isConnected ? this.remapColor.getConnectedValue(state) : new Vector2(0, 1);
          const alphaRemap = this.remapAlpha.isConnected ? this.remapAlpha.getConnectedValue(state) : new Vector2(0, 1);
          if (!particle.remapData) {
            particle.remapData = new Vector4(0, 1, 0, 1);
          }
          if (colorRemap) {
            particle.remapData.x = colorRemap.x;
            particle.remapData.y = colorRemap.y;
          }
          if (alphaRemap) {
            particle.remapData.z = alphaRemap.x;
            particle.remapData.w = alphaRemap.y;
          }
        };
        const remapProcessing = {
          process: processRemap,
          previousItem: null,
          nextItem: null
        };
        if (system._updateQueueStart) {
          _ConnectAtTheEnd(remapProcessing, system._updateQueueStart);
        } else {
          system._updateQueueStart = remapProcessing;
        }
      }
    };
    RegisterClass("BABYLON.UpdateRemapBlock", UpdateRemapBlock);
  }
});

// node_modules/@babylonjs/core/Particles/Node/nodeParticleSystemSet.helper.js
async function ConvertToNodeParticleSystemSetAsync(name13, particleSystemsList) {
  if (!particleSystemsList || !particleSystemsList.length) {
    return null;
  }
  const nodeParticleSystemSet = new NodeParticleSystemSet(name13);
  const promises = [];
  for (const particleSystem of particleSystemsList) {
    promises.push(_ExtractDatafromParticleSystemAsync(nodeParticleSystemSet, particleSystem, {}));
  }
  await Promise.all(promises);
  return nodeParticleSystemSet;
}
async function _ExtractDatafromParticleSystemAsync(newSet, oldSystem, context) {
  const createParticleOutput = _CreateParticleBlockGroup(oldSystem, context);
  const updateParticleOutput = _UpdateParticleBlockGroup(createParticleOutput, oldSystem, context);
  const newSystem = _SystemBlockGroup(updateParticleOutput, oldSystem, context);
  newSet.systemBlocks.push(newSystem);
}
function _CreateParticleBlockGroup(oldSystem, context) {
  const createParticleBlock = new CreateParticleBlock("Create Particle");
  let createdParticle = createParticleBlock.particle;
  _CreateParticleLifetimeBlockGroup(oldSystem, context).connectTo(createParticleBlock.lifeTime);
  _CreateParticleEmitPowerBlockGroup(oldSystem).connectTo(createParticleBlock.emitPower);
  _CreateParticleSizeBlockGroup(oldSystem, context).connectTo(createParticleBlock.size);
  _CreateParticleScaleBlockGroup(oldSystem, context).connectTo(createParticleBlock.scale);
  _CreateParticleAngleBlockGroup(oldSystem).connectTo(createParticleBlock.angle);
  _CreateParticleColorBlockGroup(oldSystem, context).connectTo(createParticleBlock.color);
  _CreateAndConnectInput("Dead Color", oldSystem.colorDead.clone(), createParticleBlock.colorDead);
  createdParticle = _EmitterShapeBlock(createdParticle, oldSystem);
  if (oldSystem.isAnimationSheetEnabled) {
    createdParticle = _SpriteSheetBlock(createdParticle, oldSystem);
  }
  return createdParticle;
}
function _CreateParticleLifetimeBlockGroup(oldSystem, context) {
  if (oldSystem.targetStopDuration && oldSystem._lifeTimeGradients && oldSystem._lifeTimeGradients.length > 0) {
    context.timeToStopTimeRatioBlockGroupOutput = _CreateTimeToStopTimeRatioBlockGroup(oldSystem.targetStopDuration, context);
    const gradientBlockGroupOutput = _CreateGradientBlockGroup(context.timeToStopTimeRatioBlockGroupOutput, oldSystem._lifeTimeGradients, ParticleRandomBlockLocks.PerParticle, "Lifetime");
    return gradientBlockGroupOutput;
  } else {
    const randomLifetimeBlock = new ParticleRandomBlock("Random Lifetime");
    _CreateAndConnectInput("Min Lifetime", oldSystem.minLifeTime, randomLifetimeBlock.min);
    _CreateAndConnectInput("Max Lifetime", oldSystem.maxLifeTime, randomLifetimeBlock.max);
    return randomLifetimeBlock.output;
  }
}
function _CreateParticleEmitPowerBlockGroup(oldSystem) {
  const randomEmitPowerBlock = new ParticleRandomBlock("Random Emit Power");
  _CreateAndConnectInput("Min Emit Power", oldSystem.minEmitPower, randomEmitPowerBlock.min);
  _CreateAndConnectInput("Max Emit Power", oldSystem.maxEmitPower, randomEmitPowerBlock.max);
  return randomEmitPowerBlock.output;
}
function _CreateParticleSizeBlockGroup(oldSystem, context) {
  if (oldSystem._sizeGradients && oldSystem._sizeGradients.length > 0) {
    context.sizeGradientValue0Output = _CreateParticleInitialValueFromGradient(oldSystem._sizeGradients);
    return context.sizeGradientValue0Output;
  } else {
    const randomSizeBlock = new ParticleRandomBlock("Random size");
    _CreateAndConnectInput("Min size", oldSystem.minSize, randomSizeBlock.min);
    _CreateAndConnectInput("Max size", oldSystem.maxSize, randomSizeBlock.max);
    return randomSizeBlock.output;
  }
}
function _CreateParticleScaleBlockGroup(oldSystem, context) {
  const randomScaleBlock = new ParticleRandomBlock("Random Scale");
  _CreateAndConnectInput("Min Scale", new Vector2(oldSystem.minScaleX, oldSystem.minScaleY), randomScaleBlock.min);
  _CreateAndConnectInput("Max Scale", new Vector2(oldSystem.maxScaleX, oldSystem.maxScaleY), randomScaleBlock.max);
  if (oldSystem.targetStopDuration && oldSystem._startSizeGradients && oldSystem._startSizeGradients.length > 0) {
    context.timeToStopTimeRatioBlockGroupOutput = _CreateTimeToStopTimeRatioBlockGroup(oldSystem.targetStopDuration, context);
    const gradientBlockGroupOutput = _CreateGradientBlockGroup(context.timeToStopTimeRatioBlockGroupOutput, oldSystem._startSizeGradients, ParticleRandomBlockLocks.PerParticle, "Start Size");
    const multiplyScaleBlock = new ParticleMathBlock("Multiply Scale by Start Size Gradient");
    multiplyScaleBlock.operation = ParticleMathBlockOperations.Multiply;
    randomScaleBlock.output.connectTo(multiplyScaleBlock.left);
    gradientBlockGroupOutput.connectTo(multiplyScaleBlock.right);
    return multiplyScaleBlock.output;
  } else {
    return randomScaleBlock.output;
  }
}
function _CreateParticleAngleBlockGroup(oldSystem) {
  const randomRotationBlock = new ParticleRandomBlock("Random Rotation");
  _CreateAndConnectInput("Min Rotation", oldSystem.minInitialRotation, randomRotationBlock.min);
  _CreateAndConnectInput("Max Rotation", oldSystem.maxInitialRotation, randomRotationBlock.max);
  return randomRotationBlock.output;
}
function _CreateParticleColorBlockGroup(oldSystem, context) {
  if (oldSystem._colorGradients && oldSystem._colorGradients.length > 0) {
    context.colorGradientValue0Output = _CreateParticleInitialValueFromGradient(oldSystem._colorGradients);
    return context.colorGradientValue0Output;
  } else {
    const randomColorBlock = new ParticleRandomBlock("Random color");
    _CreateAndConnectInput("Color 1", oldSystem.color1.clone(), randomColorBlock.min);
    _CreateAndConnectInput("Color 2", oldSystem.color2.clone(), randomColorBlock.max);
    return randomColorBlock.output;
  }
}
function _CreateParticleInitialValueFromGradient(gradients) {
  if (gradients.length === 0) {
    throw new Error("No gradients provided.");
  }
  const gradientStep = gradients[0];
  const value1 = gradientStep.factor1 ?? gradientStep.color1;
  const value2 = gradientStep.factor2 ?? gradientStep.color2;
  if (value2 !== void 0) {
    const randomBlock = new ParticleRandomBlock("Random Value 0");
    randomBlock.lockMode = ParticleRandomBlockLocks.OncePerParticle;
    _CreateAndConnectInput("Value 1", value1, randomBlock.min);
    _CreateAndConnectInput("Value 2", value2, randomBlock.max);
    return randomBlock.output;
  } else {
    const sizeBlock = new ParticleInputBlock("Value");
    sizeBlock.value = value1;
    return sizeBlock.output;
  }
}
function _EmitterShapeBlock(particle, oldSystem) {
  const emitter = oldSystem.particleEmitterType;
  if (!emitter) {
    throw new Error("Particle system has no emitter type.");
  }
  let shapeBlock = null;
  switch (emitter.getClassName()) {
    case "BoxParticleEmitter": {
      const source = emitter;
      shapeBlock = new BoxShapeBlock("Box Shape");
      const target = shapeBlock;
      _CreateAndConnectInput("Direction 1", source.direction1.clone(), target.direction1);
      _CreateAndConnectInput("Direction 2", source.direction2.clone(), target.direction2);
      _CreateAndConnectInput("Min Emit Box", source.minEmitBox.clone(), target.minEmitBox);
      _CreateAndConnectInput("Max Emit Box", source.maxEmitBox.clone(), target.maxEmitBox);
      break;
    }
    case "ConeParticleEmitter": {
      const source = emitter;
      shapeBlock = new ConeShapeBlock("Cone Shape");
      const target = shapeBlock;
      target.emitFromSpawnPointOnly = source.emitFromSpawnPointOnly;
      _CreateAndConnectInput("Radius", source.radius, target.radius);
      _CreateAndConnectInput("Angle", source.angle, target.angle);
      _CreateAndConnectInput("Radius Range", source.radiusRange, target.radiusRange);
      _CreateAndConnectInput("Height Range", source.heightRange, target.heightRange);
      _CreateAndConnectInput("Direction Randomizer", source.directionRandomizer, target.directionRandomizer);
      break;
    }
    case "ConeDirectedParticleEmitter": {
      const source = emitter;
      shapeBlock = new ConeShapeBlock("Cone Shape");
      const target = shapeBlock;
      target.emitFromSpawnPointOnly = source.emitFromSpawnPointOnly;
      _CreateAndConnectInput("Radius", source.radius, target.radius);
      _CreateAndConnectInput("Angle", source.angle, target.angle);
      _CreateAndConnectInput("Radius Range", source.radiusRange, target.radiusRange);
      _CreateAndConnectInput("Height Range", source.heightRange, target.heightRange);
      _CreateAndConnectInput("Direction 1", source.direction1.clone(), target.direction1);
      _CreateAndConnectInput("Direction 2", source.direction2.clone(), target.direction2);
      break;
    }
    case "CustomParticleEmitter": {
      const source = emitter;
      shapeBlock = new CustomShapeBlock("Custom Shape");
      const target = shapeBlock;
      target.particlePositionGenerator = source.particlePositionGenerator;
      target.particleDestinationGenerator = source.particleDestinationGenerator;
      target.particleDirectionGenerator = source.particleDirectionGenerator;
      break;
    }
    case "CylinderParticleEmitter": {
      const source = emitter;
      shapeBlock = new CylinderShapeBlock("Cylinder Shape");
      const target = shapeBlock;
      _CreateAndConnectInput("Height", source.height, target.height);
      _CreateAndConnectInput("Radius", source.radius, target.radius);
      _CreateAndConnectInput("Radius Range", source.radiusRange, target.radiusRange);
      _CreateAndConnectInput("Direction Randomizer", source.directionRandomizer, target.directionRandomizer);
      break;
    }
    case "CylinderDirectedParticleEmitter": {
      const source = emitter;
      shapeBlock = new CylinderShapeBlock("Cylinder Shape");
      const target = shapeBlock;
      _CreateAndConnectInput("Height", source.height, target.height);
      _CreateAndConnectInput("Radius", source.radius, target.radius);
      _CreateAndConnectInput("Radius Range", source.radiusRange, target.radiusRange);
      _CreateAndConnectInput("Direction 1", source.direction1.clone(), target.direction1);
      _CreateAndConnectInput("Direction 2", source.direction2.clone(), target.direction2);
      break;
    }
    case "HemisphericParticleEmitter": {
      const source = emitter;
      shapeBlock = new SphereShapeBlock("Sphere Shape");
      const target = shapeBlock;
      target.isHemispheric = true;
      _CreateAndConnectInput("Radius", source.radius, target.radius);
      _CreateAndConnectInput("Radius Range", source.radiusRange, target.radiusRange);
      _CreateAndConnectInput("Direction Randomizer", source.directionRandomizer, target.directionRandomizer);
      break;
    }
    case "MeshParticleEmitter": {
      const source = emitter;
      shapeBlock = new MeshShapeBlock("Mesh Shape");
      const target = shapeBlock;
      target.useMeshNormalsForDirection = source.useMeshNormalsForDirection;
      _CreateAndConnectInput("Direction 1", source.direction1.clone(), target.direction1);
      _CreateAndConnectInput("Direction 2", source.direction2.clone(), target.direction2);
      target.mesh = source.mesh;
      break;
    }
    case "PointParticleEmitter": {
      const source = emitter;
      shapeBlock = new PointShapeBlock("Point Shape");
      const target = shapeBlock;
      _CreateAndConnectInput("Direction 1", source.direction1.clone(), target.direction1);
      _CreateAndConnectInput("Direction 2", source.direction2.clone(), target.direction2);
      break;
    }
    case "SphereParticleEmitter": {
      const source = emitter;
      shapeBlock = new SphereShapeBlock("Sphere Shape");
      const target = shapeBlock;
      _CreateAndConnectInput("Radius", source.radius, target.radius);
      _CreateAndConnectInput("Radius Range", source.radiusRange, target.radiusRange);
      _CreateAndConnectInput("Direction Randomizer", source.directionRandomizer, target.directionRandomizer);
      break;
    }
    case "SphereDirectedParticleEmitter": {
      const source = emitter;
      shapeBlock = new SphereShapeBlock("Sphere Shape");
      const target = shapeBlock;
      _CreateAndConnectInput("Radius", source.radius, target.radius);
      _CreateAndConnectInput("Radius Range", source.radiusRange, target.radiusRange);
      _CreateAndConnectInput("Direction1", source.direction1.clone(), target.direction1);
      _CreateAndConnectInput("Direction2", source.direction2.clone(), target.direction2);
      break;
    }
  }
  if (!shapeBlock) {
    throw new Error(`Unsupported particle emitter type: ${emitter.getClassName()}`);
  }
  particle.connectTo(shapeBlock.particle);
  return shapeBlock.output;
}
function _SpriteSheetBlock(particle, oldSystem) {
  const spriteSheetBlock = new SetupSpriteSheetBlock("Sprite Sheet Setup");
  particle.connectTo(spriteSheetBlock.particle);
  spriteSheetBlock.start = oldSystem.startSpriteCellID;
  spriteSheetBlock.end = oldSystem.endSpriteCellID;
  spriteSheetBlock.width = oldSystem.spriteCellWidth;
  spriteSheetBlock.height = oldSystem.spriteCellHeight;
  spriteSheetBlock.spriteCellChangeSpeed = oldSystem.spriteCellChangeSpeed;
  spriteSheetBlock.loop = oldSystem.spriteCellLoop;
  spriteSheetBlock.randomStartCell = oldSystem.spriteRandomStartCell;
  return spriteSheetBlock.output;
}
function _UpdateParticleBlockGroup(inputParticle, oldSystem, context) {
  let updatedParticle = inputParticle;
  updatedParticle = _UpdateParticleColorBlockGroup(updatedParticle, oldSystem._colorGradients, context);
  updatedParticle = _UpdateParticleAngleBlockGroup(updatedParticle, oldSystem._angularSpeedGradients, oldSystem.minAngularSpeed, oldSystem.maxAngularSpeed, context);
  if (oldSystem._velocityGradients && oldSystem._velocityGradients.length > 0) {
    context.scaledDirection = _UpdateParticleVelocityGradientBlockGroup(oldSystem._velocityGradients, context);
  }
  if (oldSystem._dragGradients && oldSystem._dragGradients.length > 0) {
    context.scaledDirection = _UpdateParticleDragGradientBlockGroup(oldSystem._dragGradients, context);
  }
  updatedParticle = _UpdateParticlePositionBlockGroup(updatedParticle, oldSystem.isLocal, context);
  if (oldSystem.attractors && oldSystem.attractors.length > 0) {
    updatedParticle = _UpdateParticleAttractorBlockGroup(updatedParticle, oldSystem.attractors);
  }
  if (oldSystem.flowMap) {
    updatedParticle = _UpdateParticleFlowMapBlockGroup(updatedParticle, oldSystem.flowMap, oldSystem.flowMapStrength);
  }
  if (oldSystem._limitVelocityGradients && oldSystem._limitVelocityGradients.length > 0 && oldSystem.limitVelocityDamping !== 0) {
    updatedParticle = _UpdateParticleVelocityLimitGradientBlockGroup(updatedParticle, oldSystem._limitVelocityGradients, oldSystem.limitVelocityDamping, context);
  }
  if (oldSystem.noiseTexture && oldSystem.noiseStrength) {
    updatedParticle = _UpdateParticleNoiseBlockGroup(updatedParticle, oldSystem.noiseTexture.clone(), oldSystem.noiseStrength.clone());
  }
  if (oldSystem._sizeGradients && oldSystem._sizeGradients.length > 0) {
    updatedParticle = _UpdateParticleSizeGradientBlockGroup(updatedParticle, oldSystem._sizeGradients, context);
  }
  if (oldSystem.gravity.equalsToFloats(0, 0, 0) === false) {
    updatedParticle = _UpdateParticleGravityBlockGroup(updatedParticle, oldSystem.gravity);
  }
  if (oldSystem.useRampGradients) {
    updatedParticle = _UpdateParticleRemapGradientBlockGroup(updatedParticle, oldSystem.getColorRemapGradients(), oldSystem.getAlphaRemapGradients(), context);
  }
  if (oldSystem.isAnimationSheetEnabled) {
    updatedParticle = _UpdateParticleSpriteCellBlockGroup(updatedParticle);
  }
  return updatedParticle;
}
function _UpdateParticleColorBlockGroup(inputParticle, colorGradients, context) {
  let colorCalculation = void 0;
  if (colorGradients && colorGradients.length > 0) {
    if (context.colorGradientValue0Output === void 0) {
      throw new Error("Initial color gradient values not found in context.");
    }
    context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);
    colorCalculation = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, colorGradients, ParticleRandomBlockLocks.OncePerParticle, "Color", [
      context.colorGradientValue0Output
    ]);
  } else {
    colorCalculation = _BasicColorUpdateBlockGroup();
  }
  const colorUpdateBlock = new UpdateColorBlock("Color update");
  inputParticle.connectTo(colorUpdateBlock.particle);
  _ClampUpdateColorAlpha(colorCalculation).connectTo(colorUpdateBlock.color);
  return colorUpdateBlock.output;
}
function _UpdateParticleAngleBlockGroup(inputParticle, angularSpeedGradients, minAngularSpeed, maxAngularSpeed, context) {
  let angularSpeedCalculation = null;
  if (angularSpeedGradients && angularSpeedGradients.length > 0) {
    angularSpeedCalculation = _UpdateParticleAngularSpeedGradientBlockGroup(angularSpeedGradients, context);
  } else if (minAngularSpeed !== 0 || maxAngularSpeed !== 0) {
    angularSpeedCalculation = _UpdateParticleAngularSpeedBlockGroup(minAngularSpeed, maxAngularSpeed);
  }
  if (angularSpeedCalculation) {
    const angleSpeedDeltaOutput = _CreateDeltaModifiedInput("Angular Speed", angularSpeedCalculation);
    const addAngle = new ParticleMathBlock("Add Angular Speed to Angle");
    addAngle.operation = ParticleMathBlockOperations.Add;
    _CreateAndConnectContextualSource("Angle", NodeParticleContextualSources.Angle, addAngle.left);
    angleSpeedDeltaOutput.connectTo(addAngle.right);
    const updateAngle = new UpdateAngleBlock("Angle Update with Angular Speed");
    inputParticle.connectTo(updateAngle.particle);
    addAngle.output.connectTo(updateAngle.angle);
    return updateAngle.output;
  } else {
    return inputParticle;
  }
}
function _UpdateParticleVelocityGradientBlockGroup(velocityGradients, context) {
  context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);
  const velocityValueOutput = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, velocityGradients, ParticleRandomBlockLocks.OncePerParticle, "Velocity");
  const multiplyScaleByVelocity = new ParticleMathBlock("Multiply Direction Scale by Velocity");
  multiplyScaleByVelocity.operation = ParticleMathBlockOperations.Multiply;
  velocityValueOutput.connectTo(multiplyScaleByVelocity.left);
  _CreateAndConnectContextualSource("Direction Scale", NodeParticleContextualSources.DirectionScale, multiplyScaleByVelocity.right);
  const multiplyDirection = new ParticleMathBlock("Scaled Direction");
  multiplyDirection.operation = ParticleMathBlockOperations.Multiply;
  multiplyScaleByVelocity.output.connectTo(multiplyDirection.left);
  _CreateAndConnectContextualSource("Direction", NodeParticleContextualSources.Direction, multiplyDirection.right);
  context.scaledDirection = multiplyDirection.output;
  return multiplyDirection.output;
}
function _UpdateParticleVelocityLimitGradientBlockGroup(inputParticle, velocityLimitGradients, limitVelocityDamping, context) {
  context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);
  const currentSpeedBlock = new ParticleVectorLengthBlock("Current Speed");
  _CreateAndConnectContextualSource("Direction", NodeParticleContextualSources.Direction, currentSpeedBlock.input);
  const velocityLimitValueOutput = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, velocityLimitGradients, ParticleRandomBlockLocks.OncePerParticle, "Velocity Limit");
  const damped = new ParticleMathBlock("Damped Speed");
  damped.operation = ParticleMathBlockOperations.Multiply;
  _CreateAndConnectContextualSource("Direction", NodeParticleContextualSources.Direction, damped.left);
  _CreateAndConnectInput("Limit Velocity Damping", limitVelocityDamping, damped.right);
  const compareSpeed = new ParticleConditionBlock("Compare Speed to Limit");
  compareSpeed.test = ParticleConditionBlockTests.GreaterThan;
  currentSpeedBlock.output.connectTo(compareSpeed.left);
  velocityLimitValueOutput.connectTo(compareSpeed.right);
  damped.output.connectTo(compareSpeed.ifTrue);
  _CreateAndConnectContextualSource("Direction", NodeParticleContextualSources.Direction, compareSpeed.ifFalse);
  const updateDirection = new UpdateDirectionBlock("Direction Update");
  inputParticle.connectTo(updateDirection.particle);
  compareSpeed.output.connectTo(updateDirection.direction);
  return updateDirection.output;
}
function _UpdateParticleNoiseBlockGroup(inputParticle, noiseTexture, noiseStrength) {
  const noiseUpdate = new UpdateNoiseBlock("Noise Update");
  inputParticle.connectTo(noiseUpdate.particle);
  _CreateTextureBlock(noiseTexture).connectTo(noiseUpdate.noiseTexture);
  _CreateAndConnectInput("Noise Strength", noiseStrength, noiseUpdate.strength);
  return noiseUpdate.output;
}
function _UpdateParticleDragGradientBlockGroup(dragGradients, context) {
  context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);
  const dragValueOutput = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, dragGradients, ParticleRandomBlockLocks.OncePerParticle, "Drag");
  const oneMinusDragBlock = new ParticleMathBlock("1 - Drag");
  oneMinusDragBlock.operation = ParticleMathBlockOperations.Subtract;
  _CreateAndConnectInput("One", 1, oneMinusDragBlock.left);
  dragValueOutput.connectTo(oneMinusDragBlock.right);
  const multiplyDirection = new ParticleMathBlock("Scaled Direction with Drag");
  multiplyDirection.operation = ParticleMathBlockOperations.Multiply;
  oneMinusDragBlock.output.connectTo(multiplyDirection.left);
  if (context.scaledDirection === void 0) {
    _CreateAndConnectContextualSource("Scaled Direction", NodeParticleContextualSources.ScaledDirection, multiplyDirection.right);
  } else {
    context.scaledDirection.connectTo(multiplyDirection.right);
  }
  context.scaledDirection = multiplyDirection.output;
  return multiplyDirection.output;
}
function _UpdateParticlePositionBlockGroup(inputParticle, isLocal, context) {
  const updatePosition = new UpdatePositionBlock("Position Update");
  inputParticle.connectTo(updatePosition.particle);
  if (isLocal) {
    _CreateAndConnectContextualSource("Local Position Updated", NodeParticleContextualSources.LocalPositionUpdated, updatePosition.position);
  } else {
    const addPositionBlock = new ParticleMathBlock("Add Position");
    addPositionBlock.operation = ParticleMathBlockOperations.Add;
    _CreateAndConnectContextualSource("Position", NodeParticleContextualSources.Position, addPositionBlock.left);
    if (context.scaledDirection === void 0) {
      _CreateAndConnectContextualSource("Scaled Direction", NodeParticleContextualSources.ScaledDirection, addPositionBlock.right);
    } else {
      context.scaledDirection.connectTo(addPositionBlock.right);
    }
    addPositionBlock.output.connectTo(updatePosition.position);
  }
  return updatePosition.output;
}
function _UpdateParticleAttractorBlockGroup(inputParticle, attractors) {
  let outputParticle = inputParticle;
  for (let i = 0; i < attractors.length; i++) {
    const attractor = attractors[i];
    const attractorBlock = new UpdateAttractorBlock(`Attractor Block ${i}`);
    outputParticle.connectTo(attractorBlock.particle);
    _CreateAndConnectInput("Attractor Position", attractor.position.clone(), attractorBlock.attractor);
    _CreateAndConnectInput("Attractor Strength", attractor.strength, attractorBlock.strength);
    outputParticle = attractorBlock.output;
  }
  return outputParticle;
}
function _UpdateParticleFlowMapBlockGroup(inputParticle, flowMap, flowMapStrength) {
  const updateFlowMapBlock = new UpdateFlowMapBlock("Flow Map Update");
  inputParticle.connectTo(updateFlowMapBlock.particle);
  const flowMapTextureBlock = new ParticleTextureSourceBlock("Flow Map Texture");
  flowMapTextureBlock.serializedCachedData = true;
  flowMapTextureBlock.textureDataUrl = GenerateBase64StringFromPixelData(flowMap.data, { width: flowMap.width, height: flowMap.height }, true) ?? "";
  flowMapTextureBlock.texture.connectTo(updateFlowMapBlock.flowMap);
  _CreateAndConnectInput("Flow Map Strength", flowMapStrength, updateFlowMapBlock.strength);
  return updateFlowMapBlock.output;
}
function _UpdateParticleSizeGradientBlockGroup(inputParticle, sizeGradients, context) {
  if (context.sizeGradientValue0Output === void 0) {
    throw new Error("Initial size gradient values not found in context.");
  }
  context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);
  const sizeValueOutput = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, sizeGradients, ParticleRandomBlockLocks.OncePerParticle, "Size", [
    context.sizeGradientValue0Output
  ]);
  const updateSizeBlock = new UpdateSizeBlock("Size Update");
  inputParticle.connectTo(updateSizeBlock.particle);
  sizeValueOutput.connectTo(updateSizeBlock.size);
  return updateSizeBlock.output;
}
function _UpdateParticleGravityBlockGroup(inputParticle, gravity) {
  const gravityDeltaOutput = _CreateDeltaModifiedInput("Gravity", gravity);
  const addDirectionBlock = new ParticleMathBlock("Add Gravity to Direction");
  addDirectionBlock.operation = ParticleMathBlockOperations.Add;
  _CreateAndConnectContextualSource("Direction", NodeParticleContextualSources.Direction, addDirectionBlock.left);
  gravityDeltaOutput.connectTo(addDirectionBlock.right);
  const updateDirection = new UpdateDirectionBlock("Direction Update with Gravity");
  inputParticle.connectTo(updateDirection.particle);
  addDirectionBlock.output.connectTo(updateDirection.direction);
  return updateDirection.output;
}
function _UpdateParticleRemapGradientBlockGroup(inputParticle, colorRemapGradients, alphaRemapGradients, context) {
  let hasUpdate = false;
  const remapUpdateBlock = new UpdateRemapBlock("Remap Update");
  if (colorRemapGradients && colorRemapGradients.length > 0) {
    context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);
    const colorFactor1Gradients = [];
    const colorFactor2Gradients = [];
    for (let i = 0; i < colorRemapGradients.length; i++) {
      const gradientValue = colorRemapGradients[i];
      colorFactor1Gradients.push(new FactorGradient(gradientValue.gradient, gradientValue.factor1));
      colorFactor2Gradients.push(new FactorGradient(gradientValue.gradient, gradientValue.factor2));
    }
    const colorFactor1BlockGroup = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, colorFactor1Gradients, ParticleRandomBlockLocks.OncePerParticle, "Color Min");
    const colorFactor2BlockGroup = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, colorFactor2Gradients, ParticleRandomBlockLocks.OncePerParticle, "Color Max");
    const substractBlock = new ParticleMathBlock("Color Max - Min");
    substractBlock.operation = ParticleMathBlockOperations.Subtract;
    colorFactor2BlockGroup.connectTo(substractBlock.left);
    colorFactor1BlockGroup.connectTo(substractBlock.right);
    const colorConverterBlock = new ParticleConverterBlock("Color Remap Converter");
    colorFactor1BlockGroup.connectTo(colorConverterBlock.xIn);
    substractBlock.output.connectTo(colorConverterBlock.yIn);
    colorConverterBlock.xyOut.connectTo(remapUpdateBlock.remapColor);
    hasUpdate = true;
  }
  if (alphaRemapGradients && alphaRemapGradients.length > 0) {
    context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);
    const alphaFactor1Gradients = [];
    const alphaFactor2Gradients = [];
    for (let i = 0; i < alphaRemapGradients.length; i++) {
      const gradientValue = alphaRemapGradients[i];
      alphaFactor1Gradients.push(new FactorGradient(gradientValue.gradient, gradientValue.factor1));
      alphaFactor2Gradients.push(new FactorGradient(gradientValue.gradient, gradientValue.factor2));
    }
    const alphaFactor1BlockGroup = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, alphaFactor1Gradients, ParticleRandomBlockLocks.OncePerParticle, "Alpha Min");
    const alphaFactor2BlockGroup = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, alphaFactor2Gradients, ParticleRandomBlockLocks.OncePerParticle, "Alpha Max");
    const substractBlock = new ParticleMathBlock("Alpha Max - Min");
    substractBlock.operation = ParticleMathBlockOperations.Subtract;
    alphaFactor2BlockGroup.connectTo(substractBlock.left);
    alphaFactor1BlockGroup.connectTo(substractBlock.right);
    const alphaConverterBlock = new ParticleConverterBlock("Alpha Remap Converter");
    alphaFactor1BlockGroup.connectTo(alphaConverterBlock.xIn);
    substractBlock.output.connectTo(alphaConverterBlock.yIn);
    alphaConverterBlock.xyOut.connectTo(remapUpdateBlock.remapAlpha);
    hasUpdate = true;
  }
  if (hasUpdate) {
    inputParticle.connectTo(remapUpdateBlock.particle);
    return remapUpdateBlock.output;
  }
  return inputParticle;
}
function _UpdateParticleSpriteCellBlockGroup(inputParticle) {
  const updateSpriteCell = new BasicSpriteUpdateBlock("Sprite Cell Update");
  inputParticle.connectTo(updateSpriteCell.particle);
  return updateSpriteCell.output;
}
function _UpdateParticleAngularSpeedGradientBlockGroup(angularSpeedGradients, context) {
  context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);
  const angularSpeedValueOutput = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, angularSpeedGradients, ParticleRandomBlockLocks.OncePerParticle, "Angular Speed");
  return angularSpeedValueOutput;
}
function _UpdateParticleAngularSpeedBlockGroup(minAngularSpeed, maxAngularSpeed) {
  const randomAngularSpeedBlock = new ParticleRandomBlock("Random Angular Speed");
  randomAngularSpeedBlock.lockMode = ParticleRandomBlockLocks.OncePerParticle;
  _CreateAndConnectInput("Min Angular Speed", minAngularSpeed, randomAngularSpeedBlock.min);
  _CreateAndConnectInput("Max Angular Speed", maxAngularSpeed, randomAngularSpeedBlock.max);
  return randomAngularSpeedBlock.output;
}
function _BasicColorUpdateBlockGroup() {
  const addColorBlock = new ParticleMathBlock("Add Color");
  addColorBlock.operation = ParticleMathBlockOperations.Add;
  _CreateAndConnectContextualSource("Color", NodeParticleContextualSources.Color, addColorBlock.left);
  _CreateAndConnectContextualSource("Scaled Color Step", NodeParticleContextualSources.ScaledColorStep, addColorBlock.right);
  return addColorBlock.output;
}
function _ClampUpdateColorAlpha(colorCalculationOutput) {
  const decomposeColorBlock = new ParticleConverterBlock("Decompose Color");
  colorCalculationOutput.connectTo(decomposeColorBlock.colorIn);
  const maxAlphaBlock = new ParticleMathBlock("Alpha >= 0");
  maxAlphaBlock.operation = ParticleMathBlockOperations.Max;
  decomposeColorBlock.wOut.connectTo(maxAlphaBlock.left);
  _CreateAndConnectInput("Zero", 0, maxAlphaBlock.right);
  const composeColorBlock = new ParticleConverterBlock("Compose Color");
  decomposeColorBlock.xyzOut.connectTo(composeColorBlock.xyzIn);
  maxAlphaBlock.output.connectTo(composeColorBlock.wIn);
  return composeColorBlock.colorOut;
}
function _SystemBlockGroup(updateParticleOutput, oldSystem, context) {
  const newSystem = new SystemBlock(oldSystem.name);
  newSystem.translationPivot.value = oldSystem.translationPivot.clone();
  newSystem.textureMask.value = oldSystem.textureMask.clone();
  newSystem.manualEmitCount = oldSystem.manualEmitCount;
  newSystem.blendMode = oldSystem.blendMode;
  newSystem.capacity = oldSystem.getCapacity();
  newSystem.startDelay = oldSystem.startDelay;
  newSystem.updateSpeed = oldSystem.updateSpeed;
  newSystem.preWarmCycles = oldSystem.preWarmCycles;
  newSystem.preWarmStepOffset = oldSystem.preWarmStepOffset;
  newSystem.isBillboardBased = oldSystem.isBillboardBased;
  newSystem.billBoardMode = oldSystem.billboardMode;
  newSystem.isLocal = oldSystem.isLocal;
  newSystem.disposeOnStop = oldSystem.disposeOnStop;
  if (oldSystem.emitter) {
    _SystemEmitterPosition(oldSystem.emitter, newSystem);
  }
  _SystemEmitRateValue(oldSystem.getEmitRateGradients(), oldSystem.targetStopDuration, oldSystem.emitRate, newSystem, context);
  _SystemTargetStopDuration(oldSystem.targetStopDuration, newSystem, context);
  const rampGradients = oldSystem.getRampGradients();
  if (rampGradients && rampGradients.length > 0) {
    _SystemRampGradientsBlockGroup(rampGradients, newSystem);
  }
  const texture = oldSystem.particleTexture;
  if (texture) {
    _CreateTextureBlock(texture).connectTo(newSystem.texture);
  }
  updateParticleOutput.connectTo(newSystem.particle);
  return newSystem;
}
function _SystemEmitterPosition(emitter, newSystem) {
  if (emitter) {
    _CreateAndConnectInput("Emitter Position", emitter instanceof TransformNode ? emitter.position.clone() : emitter.clone(), newSystem.emitterPosition, NodeParticleBlockConnectionPointTypes.Vector3);
  }
}
function _SystemEmitRateValue(emitGradients, targetStopDuration, emitRate, newSystem, context) {
  if (emitGradients && emitGradients.length > 0 && targetStopDuration > 0) {
    context.timeToStopTimeRatioBlockGroupOutput = _CreateTimeToStopTimeRatioBlockGroup(targetStopDuration, context);
    const gradientValue = _CreateGradientBlockGroup(context.timeToStopTimeRatioBlockGroupOutput, emitGradients, ParticleRandomBlockLocks.PerSystem, "Emit Rate");
    const roundBlock = new ParticleFloatToIntBlock("Round to Int");
    roundBlock.operation = ParticleFloatToIntBlockOperations.Round;
    gradientValue.connectTo(roundBlock.input);
    roundBlock.output.connectTo(newSystem.emitRate);
  } else {
    newSystem.emitRate.value = emitRate;
  }
}
function _SystemTargetStopDuration(targetStopDuration, newSystem, context) {
  if (context.targetStopDurationBlockOutput) {
    context.targetStopDurationBlockOutput.connectTo(newSystem.targetStopDuration);
  } else {
    newSystem.targetStopDuration.value = targetStopDuration;
  }
}
function _SystemRampGradientsBlockGroup(rampGradients, newSystem) {
  const gradientBlock = new ParticleGradientBlock("Ramp Gradient Block");
  for (let i = 0; i < rampGradients.length; i++) {
    const rampGradient = rampGradients[i];
    const gradientValueBlock = new ParticleGradientValueBlock(`Ramp Gradient ${i}`);
    gradientValueBlock.reference = rampGradient.gradient;
    _CreateAndConnectInput(`Color ${i}`, new Color4(rampGradient.color.r, rampGradient.color.g, rampGradient.color.b), gradientValueBlock.value, NodeParticleBlockConnectionPointTypes.Color4);
    gradientValueBlock.output.connectTo(gradientBlock.inputs[i + 1]);
  }
  gradientBlock.output.connectTo(newSystem.rampGradient);
}
function _CreateDeltaModifiedInput(name13, value) {
  const multiplyBlock = new ParticleMathBlock("Multiply by Delta");
  multiplyBlock.operation = ParticleMathBlockOperations.Multiply;
  if (value instanceof Vector3) {
    _CreateAndConnectInput(name13, value, multiplyBlock.left);
  } else {
    value.connectTo(multiplyBlock.left);
  }
  _CreateAndConnectSystemSource("Delta", NodeParticleSystemSources.Delta, multiplyBlock.right);
  return multiplyBlock.output;
}
function _CreateAndConnectInput(inputBlockName, value, targetToConnectTo, inputType) {
  const input = new ParticleInputBlock(inputBlockName, inputType);
  input.value = value;
  input.output.connectTo(targetToConnectTo);
}
function _CreateAndConnectContextualSource(contextualBlockName, contextSource, targetToConnectTo) {
  const input = new ParticleInputBlock(contextualBlockName);
  input.contextualValue = contextSource;
  input.output.connectTo(targetToConnectTo);
}
function _CreateAndConnectSystemSource(systemBlockName, systemSource, targetToConnectTo) {
  const input = new ParticleInputBlock(systemBlockName);
  input.systemSource = systemSource;
  input.output.connectTo(targetToConnectTo);
}
function _CreateTargetStopDurationInputBlock(targetStopDuration, context) {
  if (context.targetStopDurationBlockOutput) {
    return context.targetStopDurationBlockOutput;
  }
  const targetStopDurationInputBlock = new ParticleInputBlock("Target Stop Duration");
  targetStopDurationInputBlock.value = targetStopDuration;
  context.targetStopDurationBlockOutput = targetStopDurationInputBlock.output;
  return context.targetStopDurationBlockOutput;
}
function _CreateTimeToStopTimeRatioBlockGroup(targetStopDuration, context) {
  if (context.timeToStopTimeRatioBlockGroupOutput) {
    return context.timeToStopTimeRatioBlockGroupOutput;
  }
  context.targetStopDurationBlockOutput = _CreateTargetStopDurationInputBlock(targetStopDuration, context);
  const ratio = new ParticleMathBlock("Frame/Stop Ratio");
  ratio.operation = ParticleMathBlockOperations.Divide;
  _CreateAndConnectSystemSource("Actual Frame", NodeParticleSystemSources.Time, ratio.left);
  context.targetStopDurationBlockOutput.connectTo(ratio.right);
  const clampMin = new ParticleMathBlock("Clamp Min 0");
  clampMin.operation = ParticleMathBlockOperations.Max;
  _CreateAndConnectInput("Zero", 0, clampMin.left);
  ratio.output.connectTo(clampMin.right);
  const clampMax = new ParticleMathBlock("Clamp Max 1");
  clampMax.operation = ParticleMathBlockOperations.Min;
  _CreateAndConnectInput("One", 1, clampMax.left);
  clampMin.output.connectTo(clampMax.right);
  context.timeToStopTimeRatioBlockGroupOutput = clampMax.output;
  return context.timeToStopTimeRatioBlockGroupOutput;
}
function _CreateAgeToLifeTimeRatioBlockGroup(context) {
  if (context.ageToLifeTimeRatioBlockGroupOutput) {
    return context.ageToLifeTimeRatioBlockGroupOutput;
  }
  const ratio = new ParticleMathBlock("Age/LifeTime Ratio");
  ratio.operation = ParticleMathBlockOperations.Divide;
  _CreateAndConnectContextualSource("Age", NodeParticleContextualSources.Age, ratio.left);
  _CreateAndConnectContextualSource("LifeTime", NodeParticleContextualSources.Lifetime, ratio.right);
  context.ageToLifeTimeRatioBlockGroupOutput = ratio.output;
  return ratio.output;
}
function _CreateGradientBlockGroup(gradientSelector, gradientValues, randomLockMode, prefix, initialValues = []) {
  const gradientBlock = new ParticleGradientBlock(prefix + " Gradient Block");
  gradientSelector.connectTo(gradientBlock.gradient);
  for (let i = 0; i < initialValues.length; i++) {
    const reference = i < gradientValues.length ? gradientValues[i].gradient : 1;
    const gradientValueBlock = new ParticleGradientValueBlock(prefix + " Gradient Value " + i);
    gradientValueBlock.reference = reference;
    initialValues[i].connectTo(gradientValueBlock.value);
    gradientValueBlock.output.connectTo(gradientBlock.inputs[i + 1]);
  }
  for (let i = 0 + initialValues.length; i < gradientValues.length; i++) {
    const gradientValueBlockGroupOutput = _CreateGradientValueBlockGroup(gradientValues[i], randomLockMode, prefix, i);
    gradientValueBlockGroupOutput.connectTo(gradientBlock.inputs[i + 1]);
  }
  return gradientBlock.output;
}
function _CreateGradientValueBlockGroup(gradientStep, randomLockMode, prefix, index) {
  const gradientValueBlock = new ParticleGradientValueBlock(prefix + " Gradient Value " + index);
  gradientValueBlock.reference = gradientStep.gradient;
  const value1 = gradientStep.factor1 ?? gradientStep.color1.clone();
  const value2 = gradientStep.factor2 ?? gradientStep.color2?.clone();
  if (value2 !== void 0) {
    const randomBlock = new ParticleRandomBlock("Random Value " + index);
    randomBlock.lockMode = randomLockMode;
    _CreateAndConnectInput("Value 1", value1, randomBlock.min);
    _CreateAndConnectInput("Value 2", value2, randomBlock.max);
    randomBlock.output.connectTo(gradientValueBlock.value);
  } else {
    _CreateAndConnectInput("Value", value1, gradientValueBlock.value);
  }
  return gradientValueBlock.output;
}
function _CreateTextureBlock(texture) {
  const textureBlock = new ParticleTextureSourceBlock("Texture");
  textureBlock.sourceTexture = texture;
  return textureBlock.texture;
}
var init_nodeParticleSystemSet_helper = __esm({
  "node_modules/@babylonjs/core/Particles/Node/nodeParticleSystemSet.helper.js"() {
    init_math_color();
    init_math_vector();
    init_transformNode();
    init_gradients();
    init_nodeParticleBlockConnectionPointTypes();
    init_nodeParticleSystemSet();
    init_nodeParticleContextualSources();
    init_nodeParticleSystemSources();
    init_particleConverterBlock();
    init_particleFloatToIntBlock();
    init_particleGradientBlock();
    init_particleGradientValueBlock();
    init_particleInputBlock();
    init_particleMathBlock();
    init_particleRandomBlock();
    init_particleSourceTextureBlock();
    init_particleVectorLengthBlock();
    init_systemBlock();
    init_particleConditionBlock();
    init_createParticleBlock();
    init_boxShapeBlock();
    init_coneShapeBlock();
    init_cylinderShapeBlock();
    init_customShapeBlock();
    init_meshShapeBlock();
    init_pointShapeBlock();
    init_setupSpriteSheetBlock();
    init_sphereShapeBlock();
    init_updateAngleBlock();
    init_basicSpriteUpdateBlock();
    init_updateAttractorBlock();
    init_updateColorBlock();
    init_updateDirectionBlock();
    init_updateFlowMapBlock();
    init_updateNoiseBlock();
    init_updatePositionBlock();
    init_updateSizeBlock();
    init_updateRemapBlock();
    init_copyTools();
  }
});

// node_modules/@babylonjs/core/Physics/v2/physicsEngine.js
var PhysicsEngine2;
var init_physicsEngine2 = __esm({
  "node_modules/@babylonjs/core/Physics/v2/physicsEngine.js"() {
    init_math_vector();
    init_physicsRaycastResult();
    init_devTools();
    PhysicsEngine2 = class _PhysicsEngine {
      /**
       *
       * @returns physics plugin version
       */
      getPluginVersion() {
        return this._physicsPlugin.getPluginVersion();
      }
      // eslint-disable-next-line jsdoc/require-returns-check
      /**
       * Factory used to create the default physics plugin.
       * @returns The default physics plugin
       */
      static DefaultPluginFactory() {
        throw _WarnImport("");
      }
      /**
       * Creates a new Physics Engine
       * @param gravity defines the gravity vector used by the simulation
       * @param _physicsPlugin defines the plugin to use (CannonJS by default)
       */
      constructor(gravity, _physicsPlugin = _PhysicsEngine.DefaultPluginFactory()) {
        this._physicsPlugin = _physicsPlugin;
        this._physicsBodies = [];
        this._subTimeStep = 0;
        gravity = gravity || new Vector3(0, -9.807, 0);
        this.setGravity(gravity);
        this.setTimeStep();
      }
      /**
       * Sets the gravity vector used by the simulation
       * @param gravity defines the gravity vector to use
       */
      setGravity(gravity) {
        this.gravity = gravity;
        this._physicsPlugin.setGravity(this.gravity);
      }
      /**
       * Set the time step of the physics engine.
       * Default is 1/60.
       * To slow it down, enter 1/600 for example.
       * To speed it up, 1/30
       * Unit is seconds.
       * @param newTimeStep defines the new timestep to apply to this world.
       */
      setTimeStep(newTimeStep = 1 / 60) {
        this._physicsPlugin.setTimeStep(newTimeStep);
      }
      /**
       * Get the time step of the physics engine.
       * @returns the current time step
       */
      getTimeStep() {
        return this._physicsPlugin.getTimeStep();
      }
      /**
       * Set the sub time step of the physics engine.
       * Default is 0 meaning there is no sub steps
       * To increase physics resolution precision, set a small value (like 1 ms)
       * @param subTimeStep defines the new sub timestep used for physics resolution.
       */
      setSubTimeStep(subTimeStep = 0) {
        this._subTimeStep = subTimeStep;
      }
      /**
       * Get the sub time step of the physics engine.
       * @returns the current sub time step
       */
      getSubTimeStep() {
        return this._subTimeStep;
      }
      /**
       * Release all resources
       */
      dispose() {
        this._physicsPlugin.dispose();
      }
      /**
       * Gets the name of the current physics plugin
       * @returns the name of the plugin
       */
      getPhysicsPluginName() {
        return this._physicsPlugin.name;
      }
      /**
       * Set the maximum allowed linear and angular velocities
       * @param maxLinearVelocity maximum allowed linear velocity
       * @param maxAngularVelocity maximum allowed angular velocity
       */
      setVelocityLimits(maxLinearVelocity, maxAngularVelocity) {
        this._physicsPlugin.setVelocityLimits(maxLinearVelocity, maxAngularVelocity);
      }
      /**
       * @returns maximum allowed linear velocity
       */
      getMaxLinearVelocity() {
        return this._physicsPlugin.getMaxLinearVelocity();
      }
      /**
       * @returns maximum allowed angular velocity
       */
      getMaxAngularVelocity() {
        return this._physicsPlugin.getMaxAngularVelocity();
      }
      /**
       * Adding a new impostor for the impostor tracking.
       * This will be done by the impostor itself.
       * @param impostor the impostor to add
       */
      /**
       * Called by the scene. No need to call it.
       * @param delta defines the timespan between frames
       */
      _step(delta) {
        if (delta > 0.1) {
          delta = 0.1;
        } else if (delta <= 0) {
          delta = 1 / 60;
        }
        this._physicsPlugin.executeStep(delta, this._physicsBodies);
      }
      /**
       * Add a body as an active component of this engine
       * @param physicsBody The body to add
       */
      addBody(physicsBody) {
        this._physicsBodies.push(physicsBody);
      }
      /**
       * Removes a particular body from this engine
       * @param physicsBody The body to remove from the simulation
       */
      removeBody(physicsBody) {
        const index = this._physicsBodies.indexOf(physicsBody);
        if (index > -1) {
          this._physicsBodies.splice(index, 1);
        }
      }
      /**
       * @returns an array of bodies added to this engine
       */
      getBodies() {
        return this._physicsBodies;
      }
      /**
       * Gets the current plugin used to run the simulation
       * @returns current plugin
       */
      getPhysicsPlugin() {
        return this._physicsPlugin;
      }
      /**
       * Does a raycast in the physics world
       * @param from when should the ray start?
       * @param to when should the ray end?
       * @param result resulting PhysicsRaycastResult or array of PhysicsRaycastResults
       * @param query raycast query object
       * If result is an empty array, it will be populated with every detected raycast hit.
       * If result is a populated array, it will only fill the PhysicsRaycastResults present in the array.
       */
      raycastToRef(from, to, result, query) {
        this._physicsPlugin.raycast(from, to, result, query);
      }
      /**
       * Does a raycast in the physics world
       * @param from when should the ray start?
       * @param to when should the ray end?
       * @param query raycast query object
       * @returns PhysicsRaycastResult
       */
      raycast(from, to, query) {
        const result = new PhysicsRaycastResult();
        this._physicsPlugin.raycast(from, to, result, query);
        return result;
      }
      /**
       * Does a raycast through multiple objects in the physics world
       * @param from when should the ray start?
       * @param to when should the ray end?
       * @param query raycast query object
       * @returns array of PhysicsRaycastResult
       */
      raycastMulti(from, to, query) {
        const result = [];
        this._physicsPlugin.raycast(from, to, result, query);
        return result;
      }
    };
  }
});

// node_modules/@babylonjs/core/Physics/joinedPhysicsEngineComponent.js
var PhysicsEngineSceneComponent;
var init_joinedPhysicsEngineComponent = __esm({
  "node_modules/@babylonjs/core/Physics/joinedPhysicsEngineComponent.js"() {
    init_logger();
    init_observable();
    init_sceneComponent();
    init_scene();
    init_physicsEngine();
    init_physicsEngine2();
    Scene.prototype.getPhysicsEngine = function() {
      return this._physicsEngine ?? null;
    };
    Scene.prototype.enablePhysics = function(gravity = null, plugin) {
      if (this._physicsEngine) {
        return true;
      }
      let component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE);
      if (!component) {
        component = new PhysicsEngineSceneComponent(this);
        this._addComponent(component);
      }
      try {
        if (!plugin || plugin?.getPluginVersion() === 1) {
          this._physicsEngine = new PhysicsEngine(gravity, plugin);
        } else if (plugin?.getPluginVersion() === 2) {
          this._physicsEngine = new PhysicsEngine2(gravity, plugin);
        } else {
          throw new Error("Unsupported Physics plugin version.");
        }
        this._physicsTimeAccumulator = 0;
        return true;
      } catch (e) {
        Logger.Error(e.message);
        return false;
      }
    };
    Scene.prototype.disablePhysicsEngine = function() {
      if (!this._physicsEngine) {
        return;
      }
      this._physicsEngine.dispose();
      this._physicsEngine = null;
    };
    Scene.prototype.isPhysicsEnabled = function() {
      return this._physicsEngine !== void 0;
    };
    Scene.prototype.deleteCompoundImpostor = function(compound) {
      const mesh = compound.parts[0].mesh;
      if (mesh.physicsImpostor) {
        mesh.physicsImpostor.dispose(
          /*true*/
        );
        mesh.physicsImpostor = null;
      }
    };
    Scene.prototype._advancePhysicsEngineStep = function(step) {
      if (this._physicsEngine) {
        const subTime = this._physicsEngine.getSubTimeStep();
        if (subTime > 0) {
          this._physicsTimeAccumulator += step;
          while (this._physicsTimeAccumulator > subTime) {
            this.onBeforePhysicsObservable.notifyObservers(this);
            this._physicsEngine._step(subTime / 1e3);
            this.onAfterPhysicsObservable.notifyObservers(this);
            this._physicsTimeAccumulator -= subTime;
          }
        } else {
          this.onBeforePhysicsObservable.notifyObservers(this);
          this._physicsEngine._step(step / 1e3);
          this.onAfterPhysicsObservable.notifyObservers(this);
        }
      }
    };
    PhysicsEngineSceneComponent = class {
      /**
       * Creates a new instance of the component for the given scene
       * @param scene Defines the scene to register the component in
       */
      constructor(scene) {
        this.name = SceneComponentConstants.NAME_PHYSICSENGINE;
        this.scene = scene;
        this.scene.onBeforePhysicsObservable = new Observable();
        this.scene.onAfterPhysicsObservable = new Observable();
        this.scene.getDeterministicFrameTime = () => {
          if (this.scene._physicsEngine) {
            return this.scene._physicsEngine.getTimeStep() * 1e3;
          }
          return 1e3 / 60;
        };
      }
      /**
       * Registers the component in a given scene
       */
      register() {
      }
      /**
       * Rebuilds the elements related to this component in case of
       * context lost for instance.
       */
      rebuild() {
      }
      /**
       * Disposes the component and the associated resources
       */
      dispose() {
        this.scene.onBeforePhysicsObservable.clear();
        this.scene.onAfterPhysicsObservable.clear();
        if (this.scene._physicsEngine) {
          this.scene.disablePhysicsEngine();
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Physics/v2/physicsEngineComponent.js
var init_physicsEngineComponent = __esm({
  "node_modules/@babylonjs/core/Physics/v2/physicsEngineComponent.js"() {
    init_transformNode();
    init_joinedPhysicsEngineComponent();
    Object.defineProperty(TransformNode.prototype, "physicsBody", {
      get: function() {
        return this._physicsBody;
      },
      set: function(value) {
        if (this._physicsBody === value) {
          return;
        }
        if (this._disposePhysicsObserver) {
          this.onDisposeObservable.remove(this._disposePhysicsObserver);
        }
        this._physicsBody = value;
        if (value) {
          this._disposePhysicsObserver = this.onDisposeObservable.add(() => {
            if (this.physicsBody) {
              this.physicsBody.dispose(
                /*!doNotRecurse*/
              );
              this.physicsBody = null;
            }
          });
        }
      },
      enumerable: true,
      configurable: true
    });
    TransformNode.prototype.getPhysicsBody = function() {
      return this.physicsBody;
    };
    TransformNode.prototype.applyImpulse = function(force, contactPoint) {
      if (!this.physicsBody) {
        throw new Error("No Physics Body for TransformNode");
      }
      this.physicsBody.applyImpulse(force, contactPoint);
      return this;
    };
    TransformNode.prototype.applyAngularImpulse = function(angularImpulse) {
      if (!this.physicsBody) {
        throw new Error("No Physics Body for TransformNode");
      }
      this.physicsBody.applyAngularImpulse(angularImpulse);
      return this;
    };
    TransformNode.prototype.applyTorque = function(torque) {
      if (!this.physicsBody) {
        throw new Error("No Physics Body for TransformNode");
      }
      this.physicsBody.applyTorque(torque);
      return this;
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderEffect.js
var PostProcessRenderEffect;
var init_postProcessRenderEffect = __esm({
  "node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderEffect.js"() {
    init_tools();
    PostProcessRenderEffect = class {
      /**
       * Instantiates a post process render effect.
       * A post process can be used to apply a shader to a texture after it is rendered.
       * @param engine The engine the effect is tied to
       * @param name The name of the effect
       * @param getPostProcesses A function that returns a set of post processes which the effect will run in order to be run.
       * @param singleInstance False if this post process can be run on multiple cameras. (default: true)
       */
      constructor(engine, name13, getPostProcesses, singleInstance = true) {
        this._name = name13;
        this._singleInstance = singleInstance;
        this._getPostProcesses = getPostProcesses;
        this._cameras = {};
        this._indicesForCamera = {};
        this._postProcesses = {};
      }
      /**
       * Checks if all the post processes in the effect are supported.
       */
      get isSupported() {
        for (const index in this._postProcesses) {
          if (Object.prototype.hasOwnProperty.call(this._postProcesses, index)) {
            const pps = this._postProcesses[index];
            for (let ppIndex = 0; ppIndex < pps.length; ppIndex++) {
              if (!pps[ppIndex].isSupported) {
                return false;
              }
            }
          }
        }
        return true;
      }
      /**
       * Updates the current state of the effect
       * @internal
       */
      _update() {
      }
      /**
       * Attaches the effect on cameras
       * @param cameras The camera to attach to.
       * @internal
       */
      _attachCameras(cameras) {
        let cameraKey;
        const cams = Tools.MakeArray(cameras || this._cameras);
        if (!cams) {
          return;
        }
        for (let i = 0; i < cams.length; i++) {
          const camera = cams[i];
          if (!camera) {
            continue;
          }
          const cameraName = camera.name;
          if (this._singleInstance) {
            cameraKey = 0;
          } else {
            cameraKey = cameraName;
          }
          if (!this._postProcesses[cameraKey]) {
            const postProcess = this._getPostProcesses();
            if (postProcess) {
              this._postProcesses[cameraKey] = Array.isArray(postProcess) ? postProcess : [postProcess];
            }
          }
          if (!this._indicesForCamera[cameraName]) {
            this._indicesForCamera[cameraName] = [];
          }
          const pps = this._postProcesses[cameraKey];
          for (const postProcess of pps) {
            const index = camera.attachPostProcess(postProcess);
            this._indicesForCamera[cameraName].push(index);
          }
          if (!this._cameras[cameraName]) {
            this._cameras[cameraName] = camera;
          }
        }
      }
      /**
       * Detaches the effect on cameras
       * @param cameras The camera to detach from.
       * @internal
       */
      _detachCameras(cameras) {
        const cams = Tools.MakeArray(cameras || this._cameras);
        if (!cams) {
          return;
        }
        for (let i = 0; i < cams.length; i++) {
          const camera = cams[i];
          const cameraName = camera.name;
          const postProcesses = this._postProcesses[this._singleInstance ? 0 : cameraName];
          if (postProcesses) {
            for (const postProcess of postProcesses) {
              camera.detachPostProcess(postProcess);
            }
          }
          if (this._cameras[cameraName]) {
            this._cameras[cameraName] = null;
          }
          delete this._indicesForCamera[cameraName];
        }
      }
      /**
       * Enables the effect on given cameras
       * @param cameras The camera to enable.
       * @internal
       */
      _enable(cameras) {
        const cams = Tools.MakeArray(cameras || this._cameras);
        if (!cams) {
          return;
        }
        for (let i = 0; i < cams.length; i++) {
          const camera = cams[i];
          const cameraName = camera.name;
          const cameraKey = this._singleInstance ? 0 : cameraName;
          for (let j = 0; j < this._indicesForCamera[cameraName].length; j++) {
            const index = this._indicesForCamera[cameraName][j];
            const postProcess = camera._postProcesses[index];
            if (postProcess === void 0 || postProcess === null) {
              cams[i].attachPostProcess(this._postProcesses[cameraKey][j], index);
            }
          }
        }
      }
      /**
       * Disables the effect on the given cameras
       * @param cameras The camera to disable.
       * @internal
       */
      _disable(cameras) {
        const cams = Tools.MakeArray(cameras || this._cameras);
        if (!cams) {
          return;
        }
        for (let i = 0; i < cams.length; i++) {
          const camera = cams[i];
          const cameraName = camera.name;
          const pps = this._postProcesses[this._singleInstance ? 0 : cameraName];
          for (const postProcess of pps) {
            camera.detachPostProcess(postProcess);
          }
        }
      }
      /**
       * Gets a list of the post processes contained in the effect.
       * @param camera The camera to get the post processes on.
       * @returns The list of the post processes in the effect.
       */
      getPostProcesses(camera) {
        if (this._singleInstance) {
          return this._postProcesses[0];
        } else {
          if (!camera) {
            return null;
          }
          return this._postProcesses[camera.name];
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/extractHighlightsPostProcess.js
var ExtractHighlightsPostProcess;
var init_extractHighlightsPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/extractHighlightsPostProcess.js"() {
    init_tslib_es6();
    init_postProcess();
    init_decorators();
    init_typeStore();
    init_thinExtractHighlightsPostProcess();
    ExtractHighlightsPostProcess = class extends PostProcess {
      /**
       * The luminance threshold, pixels below this value will be set to black.
       */
      get threshold() {
        return this._effectWrapper.threshold;
      }
      set threshold(value) {
        this._effectWrapper.threshold = value;
      }
      /** @internal */
      get _exposure() {
        return this._effectWrapper._exposure;
      }
      /** @internal */
      set _exposure(value) {
        this._effectWrapper._exposure = value;
      }
      /**
       * Gets a string identifying the name of the class
       * @returns "ExtractHighlightsPostProcess" string
       */
      getClassName() {
        return "ExtractHighlightsPostProcess";
      }
      constructor(name13, options, camera = null, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
        const localOptions = {
          uniforms: ThinExtractHighlightsPostProcess.Uniforms,
          size: typeof options === "number" ? options : void 0,
          camera,
          samplingMode,
          engine,
          reusable,
          textureType,
          blockCompilation,
          ...options
        };
        super(name13, ThinExtractHighlightsPostProcess.FragmentUrl, {
          effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinExtractHighlightsPostProcess(name13, engine, localOptions) : void 0,
          ...localOptions
        });
        this._inputPostProcess = null;
        this.onApplyObservable.add((effect) => {
          this.externalTextureSamplerBinding = !!this._inputPostProcess;
          if (this._inputPostProcess) {
            effect.setTextureFromPostProcess("textureSampler", this._inputPostProcess);
          }
        });
      }
    };
    __decorate([
      serialize()
    ], ExtractHighlightsPostProcess.prototype, "threshold", null);
    RegisterClass("BABYLON.ExtractHighlightsPostProcess", ExtractHighlightsPostProcess);
  }
});

// node_modules/@babylonjs/core/PostProcesses/bloomMergePostProcess.js
var BloomMergePostProcess;
var init_bloomMergePostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/bloomMergePostProcess.js"() {
    init_tslib_es6();
    init_postProcess();
    init_typeStore();
    init_decorators();
    init_thinBloomMergePostProcess();
    BloomMergePostProcess = class extends PostProcess {
      /** Weight of the bloom to be added to the original input. */
      get weight() {
        return this._effectWrapper.weight;
      }
      set weight(value) {
        this._effectWrapper.weight = value;
      }
      /**
       * Gets a string identifying the name of the class
       * @returns "BloomMergePostProcess" string
       */
      getClassName() {
        return "BloomMergePostProcess";
      }
      /**
       * Creates a new instance of @see BloomMergePostProcess
       * @param name The name of the effect.
       * @param originalFromInput Post process which's input will be used for the merge.
       * @param blurred Blurred highlights post process which's output will be used.
       * @param weight Weight of the bloom to be added to the original input.
       * @param options The required width/height ratio to downsize to before computing the render pass.
       * @param camera The camera to apply the render pass to.
       * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
       * @param engine The engine which the post process will be applied. (default: current engine)
       * @param reusable If the post process can be reused on the same frame. (default: false)
       * @param textureType Type of textures used when performing the post process. (default: 0)
       * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
       */
      constructor(name13, originalFromInput, blurred, weight, options, camera = null, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
        const blockCompilationFinal = typeof options === "number" ? blockCompilation : !!options.blockCompilation;
        const localOptions = {
          uniforms: ThinBloomMergePostProcess.Uniforms,
          samplers: ThinBloomMergePostProcess.Samplers,
          size: typeof options === "number" ? options : void 0,
          camera,
          samplingMode,
          engine,
          reusable,
          textureType,
          ...options,
          blockCompilation: true
        };
        super(name13, ThinBloomMergePostProcess.FragmentUrl, {
          effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinBloomMergePostProcess(name13, engine, localOptions) : void 0,
          ...localOptions
        });
        this.weight = weight;
        this.externalTextureSamplerBinding = true;
        this.onApplyObservable.add((effect) => {
          effect.setTextureFromPostProcess("textureSampler", originalFromInput);
          effect.setTextureFromPostProcessOutput("bloomBlur", blurred);
        });
        if (!blockCompilationFinal) {
          this.updateEffect();
        }
      }
    };
    __decorate([
      serialize()
    ], BloomMergePostProcess.prototype, "weight", null);
    RegisterClass("BABYLON.BloomMergePostProcess", BloomMergePostProcess);
  }
});

// node_modules/@babylonjs/core/PostProcesses/bloomEffect.js
var BloomEffect;
var init_bloomEffect = __esm({
  "node_modules/@babylonjs/core/PostProcesses/bloomEffect.js"() {
    init_postProcessRenderEffect();
    init_extractHighlightsPostProcess();
    init_blurPostProcess();
    init_bloomMergePostProcess();
    init_texture();
    init_thinBloomEffect();
    BloomEffect = class extends PostProcessRenderEffect {
      /**
       * The luminance threshold to find bright areas of the image to bloom.
       */
      get threshold() {
        return this._thinBloomEffect.threshold;
      }
      set threshold(value) {
        this._thinBloomEffect.threshold = value;
      }
      /**
       * The strength of the bloom.
       */
      get weight() {
        return this._thinBloomEffect.weight;
      }
      set weight(value) {
        this._thinBloomEffect.weight = value;
      }
      /**
       * Specifies the size of the bloom blur kernel, relative to the final output size
       */
      get kernel() {
        return this._thinBloomEffect.kernel;
      }
      set kernel(value) {
        this._thinBloomEffect.kernel = value;
      }
      get bloomScale() {
        return this._thinBloomEffect.scale;
      }
      /**
       * Creates a new instance of @see BloomEffect
       * @param sceneOrEngine The scene or engine the effect belongs to.
       * @param bloomScale The ratio of the blur texture to the input texture that should be used to compute the bloom.
       * @param bloomWeight The strength of bloom.
       * @param bloomKernel The size of the kernel to be used when applying the blur.
       * @param pipelineTextureType The type of texture to be used when performing the post processing.
       * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
       */
      constructor(sceneOrEngine, bloomScale, bloomWeight, bloomKernel, pipelineTextureType = 0, blockCompilation = false) {
        const engine = sceneOrEngine._renderForCamera ? sceneOrEngine.getEngine() : sceneOrEngine;
        super(engine, "bloom", () => {
          return this._effects;
        }, true);
        this._effects = [];
        this._thinBloomEffect = new ThinBloomEffect("bloom", engine, bloomScale, blockCompilation);
        this._downscale = new ExtractHighlightsPostProcess("highlights", {
          size: 1,
          samplingMode: Texture.BILINEAR_SAMPLINGMODE,
          engine,
          textureType: pipelineTextureType,
          blockCompilation,
          effectWrapper: this._thinBloomEffect._downscale
        });
        this._blurX = new BlurPostProcess("horizontal blur", this._thinBloomEffect._blurX.direction, this._thinBloomEffect._blurX.kernel, {
          size: bloomScale,
          samplingMode: Texture.BILINEAR_SAMPLINGMODE,
          engine,
          textureType: pipelineTextureType,
          blockCompilation,
          effectWrapper: this._thinBloomEffect._blurX
        });
        this._blurX.alwaysForcePOT = true;
        this._blurX.autoClear = false;
        this._blurY = new BlurPostProcess("vertical blur", this._thinBloomEffect._blurY.direction, this._thinBloomEffect._blurY.kernel, {
          size: bloomScale,
          samplingMode: Texture.BILINEAR_SAMPLINGMODE,
          engine,
          textureType: pipelineTextureType,
          blockCompilation,
          effectWrapper: this._thinBloomEffect._blurY
        });
        this._blurY.alwaysForcePOT = true;
        this._blurY.autoClear = false;
        this.kernel = bloomKernel;
        this._effects = [this._downscale, this._blurX, this._blurY];
        this._merge = new BloomMergePostProcess("bloomMerge", this._downscale, this._blurY, bloomWeight, {
          size: bloomScale,
          samplingMode: Texture.BILINEAR_SAMPLINGMODE,
          engine,
          textureType: pipelineTextureType,
          blockCompilation,
          effectWrapper: this._thinBloomEffect._merge
        });
        this._merge.autoClear = false;
        this._effects.push(this._merge);
      }
      /**
       * Disposes each of the internal effects for a given camera.
       * @param camera The camera to dispose the effect on.
       */
      disposeEffects(camera) {
        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
          this._effects[effectIndex].dispose(camera);
        }
      }
      /**
       * @internal Internal
       */
      _updateEffects() {
        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
          this._effects[effectIndex].updateEffect();
        }
      }
      /**
       * Internal
       * @returns if all the contained post processes are ready.
       * @internal
       */
      _isReady() {
        return this._thinBloomEffect.isReady();
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/chromaticAberrationPostProcess.js
var ChromaticAberrationPostProcess;
var init_chromaticAberrationPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/chromaticAberrationPostProcess.js"() {
    init_tslib_es6();
    init_postProcess();
    init_typeStore();
    init_decorators();
    init_decorators_serialization();
    init_thinChromaticAberrationPostProcess();
    ChromaticAberrationPostProcess = class _ChromaticAberrationPostProcess extends PostProcess {
      /**
       * The amount of separation of rgb channels (default: 30)
       */
      get aberrationAmount() {
        return this._effectWrapper.aberrationAmount;
      }
      set aberrationAmount(value) {
        this._effectWrapper.aberrationAmount = value;
      }
      /**
       * The amount the effect will increase for pixels closer to the edge of the screen. (default: 0)
       */
      get radialIntensity() {
        return this._effectWrapper.radialIntensity;
      }
      set radialIntensity(value) {
        this._effectWrapper.radialIntensity = value;
      }
      /**
       * The normalized direction in which the rgb channels should be separated. If set to 0,0 radial direction will be used. (default: Vector2(0.707,0.707))
       */
      get direction() {
        return this._effectWrapper.direction;
      }
      set direction(value) {
        this._effectWrapper.direction = value;
      }
      /**
       * The center position where the radialIntensity should be around. [0.5,0.5 is center of screen, 1,1 is top right corner] (default: Vector2(0.5 ,0.5))
       */
      get centerPosition() {
        return this._effectWrapper.centerPosition;
      }
      set centerPosition(value) {
        this._effectWrapper.centerPosition = value;
      }
      /** The width of the screen to apply the effect on */
      get screenWidth() {
        return this._effectWrapper.screenWidth;
      }
      set screenWidth(value) {
        this._effectWrapper.screenWidth = value;
      }
      /** The height of the screen to apply the effect on */
      get screenHeight() {
        return this._effectWrapper.screenHeight;
      }
      set screenHeight(value) {
        this._effectWrapper.screenHeight = value;
      }
      /**
       * Gets a string identifying the name of the class
       * @returns "ChromaticAberrationPostProcess" string
       */
      getClassName() {
        return "ChromaticAberrationPostProcess";
      }
      /**
       * Creates a new instance ChromaticAberrationPostProcess
       * @param name The name of the effect.
       * @param screenWidth The width of the screen to apply the effect on.
       * @param screenHeight The height of the screen to apply the effect on.
       * @param options The required width/height ratio to downsize to before computing the render pass.
       * @param camera The camera to apply the render pass to.
       * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
       * @param engine The engine which the post process will be applied. (default: current engine)
       * @param reusable If the post process can be reused on the same frame. (default: false)
       * @param textureType Type of textures used when performing the post process. (default: 0)
       * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
       */
      constructor(name13, screenWidth, screenHeight, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
        const localOptions = {
          uniforms: ThinChromaticAberrationPostProcess.Uniforms,
          size: typeof options === "number" ? options : void 0,
          camera,
          samplingMode,
          engine,
          reusable,
          textureType,
          blockCompilation,
          ...options
        };
        super(name13, ThinChromaticAberrationPostProcess.FragmentUrl, {
          effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinChromaticAberrationPostProcess(name13, engine, localOptions) : void 0,
          ...localOptions
        });
        this.screenWidth = screenWidth;
        this.screenHeight = screenHeight;
      }
      /**
       * @internal
       */
      static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
        return SerializationHelper.Parse(() => {
          return new _ChromaticAberrationPostProcess(parsedPostProcess.name, parsedPostProcess.screenWidth, parsedPostProcess.screenHeight, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, false);
        }, parsedPostProcess, scene, rootUrl);
      }
    };
    __decorate([
      serialize()
    ], ChromaticAberrationPostProcess.prototype, "aberrationAmount", null);
    __decorate([
      serialize()
    ], ChromaticAberrationPostProcess.prototype, "radialIntensity", null);
    __decorate([
      serialize()
    ], ChromaticAberrationPostProcess.prototype, "direction", null);
    __decorate([
      serialize()
    ], ChromaticAberrationPostProcess.prototype, "centerPosition", null);
    __decorate([
      serialize()
    ], ChromaticAberrationPostProcess.prototype, "screenWidth", null);
    __decorate([
      serialize()
    ], ChromaticAberrationPostProcess.prototype, "screenHeight", null);
    RegisterClass("BABYLON.ChromaticAberrationPostProcess", ChromaticAberrationPostProcess);
  }
});

// node_modules/@babylonjs/core/PostProcesses/circleOfConfusionPostProcess.js
var CircleOfConfusionPostProcess;
var init_circleOfConfusionPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/circleOfConfusionPostProcess.js"() {
    init_tslib_es6();
    init_postProcess();
    init_logger();
    init_typeStore();
    init_decorators();
    init_thinCircleOfConfusionPostProcess();
    CircleOfConfusionPostProcess = class extends PostProcess {
      /**
       * Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diameter of the resulting aperture can be computed by lensSize/fStop.
       */
      get lensSize() {
        return this._effectWrapper.lensSize;
      }
      set lensSize(value) {
        this._effectWrapper.lensSize = value;
      }
      /**
       * F-Stop of the effect's camera. The diameter of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
       */
      get fStop() {
        return this._effectWrapper.fStop;
      }
      set fStop(value) {
        this._effectWrapper.fStop = value;
      }
      /**
       * Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
       */
      get focusDistance() {
        return this._effectWrapper.focusDistance;
      }
      set focusDistance(value) {
        this._effectWrapper.focusDistance = value;
      }
      /**
       * Focal length of the effect's camera in scene units/1000 (eg. millimeter). (default: 50)
       */
      get focalLength() {
        return this._effectWrapper.focalLength;
      }
      set focalLength(value) {
        this._effectWrapper.focalLength = value;
      }
      /**
       * Gets a string identifying the name of the class
       * @returns "CircleOfConfusionPostProcess" string
       */
      getClassName() {
        return "CircleOfConfusionPostProcess";
      }
      /**
       * Creates a new instance CircleOfConfusionPostProcess
       * @param name The name of the effect.
       * @param depthTexture The depth texture of the scene to compute the circle of confusion. This must be set in order for this to function but may be set after initialization if needed.
       * @param options The required width/height ratio to downsize to before computing the render pass.
       * @param camera The camera to apply the render pass to.
       * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
       * @param engine The engine which the post process will be applied. (default: current engine)
       * @param reusable If the post process can be reused on the same frame. (default: false)
       * @param textureType Type of textures used when performing the post process. (default: 0)
       * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
       */
      constructor(name13, depthTexture, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
        const localOptions = {
          uniforms: ThinCircleOfConfusionPostProcess.Uniforms,
          samplers: ThinCircleOfConfusionPostProcess.Samplers,
          defines: typeof options === "object" && options.depthNotNormalized ? ThinCircleOfConfusionPostProcess.DefinesDepthNotNormalized : void 0,
          size: typeof options === "number" ? options : void 0,
          camera,
          samplingMode,
          engine,
          reusable,
          textureType,
          blockCompilation,
          ...options
        };
        super(name13, ThinCircleOfConfusionPostProcess.FragmentUrl, {
          effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinCircleOfConfusionPostProcess(name13, engine, localOptions) : void 0,
          ...localOptions
        });
        this._depthTexture = null;
        this._depthTexture = depthTexture;
        this.onApplyObservable.add((effect) => {
          if (!this._depthTexture) {
            Logger.Warn("No depth texture set on CircleOfConfusionPostProcess");
            return;
          }
          effect.setTexture("depthSampler", this._depthTexture);
          this._effectWrapper.camera = this._depthTexture.activeCamera;
        });
      }
      /**
       * Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.
       */
      set depthTexture(value) {
        this._depthTexture = value;
      }
    };
    __decorate([
      serialize()
    ], CircleOfConfusionPostProcess.prototype, "lensSize", null);
    __decorate([
      serialize()
    ], CircleOfConfusionPostProcess.prototype, "fStop", null);
    __decorate([
      serialize()
    ], CircleOfConfusionPostProcess.prototype, "focusDistance", null);
    __decorate([
      serialize()
    ], CircleOfConfusionPostProcess.prototype, "focalLength", null);
    RegisterClass("BABYLON.CircleOfConfusionPostProcess", CircleOfConfusionPostProcess);
  }
});

// node_modules/@babylonjs/core/PostProcesses/depthOfFieldBlurPostProcess.js
var DepthOfFieldBlurPostProcess;
var init_depthOfFieldBlurPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/depthOfFieldBlurPostProcess.js"() {
    init_texture();
    init_blurPostProcess();
    init_typeStore();
    init_thinDepthOfFieldBlurPostProcess();
    DepthOfFieldBlurPostProcess = class extends BlurPostProcess {
      /**
       * Gets a string identifying the name of the class
       * @returns "DepthOfFieldBlurPostProcess" string
       */
      getClassName() {
        return "DepthOfFieldBlurPostProcess";
      }
      /**
       * Creates a new instance DepthOfFieldBlurPostProcess
       * @param name The name of the effect.
       * @param _scene The scene the effect belongs to (not used, you can pass null)
       * @param direction The direction the blur should be applied.
       * @param kernel The size of the kernel used to blur.
       * @param options The required width/height ratio to downsize to before computing the render pass.
       * @param camera The camera to apply the render pass to.
       * @param circleOfConfusion The circle of confusion + depth map to be used to avoid blurring across edges
       * @param imageToBlur The image to apply the blur to (default: Current rendered frame)
       * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
       * @param engine The engine which the post process will be applied. (default: current engine)
       * @param reusable If the post process can be reused on the same frame. (default: false)
       * @param textureType Type of textures used when performing the post process. (default: 0)
       * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
       * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)
       */
      constructor(name13, _scene, direction, kernel, options, camera, circleOfConfusion, imageToBlur = null, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable, textureType = 0, blockCompilation = false, textureFormat = 5) {
        const localOptions = {
          size: typeof options === "number" ? options : void 0,
          camera,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          samplingMode: samplingMode = 2,
          engine,
          reusable,
          textureType,
          defines: `#define DOF 1
`,
          blockCompilation,
          textureFormat,
          ...options
        };
        super(name13, direction, kernel, {
          effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinDepthOfFieldBlurPostProcess(name13, engine, direction, kernel, localOptions) : void 0,
          ...localOptions
        });
        this.externalTextureSamplerBinding = !!imageToBlur;
        this.onApplyObservable.add((effect) => {
          if (imageToBlur != null) {
            effect.setTextureFromPostProcess("textureSampler", imageToBlur);
          }
          effect.setTextureFromPostProcessOutput("circleOfConfusionSampler", circleOfConfusion);
        });
      }
    };
    RegisterClass("BABYLON.DepthOfFieldBlurPostProcess", DepthOfFieldBlurPostProcess);
  }
});

// node_modules/@babylonjs/core/PostProcesses/depthOfFieldMergePostProcess.js
var DepthOfFieldMergePostProcess;
var init_depthOfFieldMergePostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/depthOfFieldMergePostProcess.js"() {
    init_postProcess();
    init_thinDepthOfFieldMergePostProcess();
    DepthOfFieldMergePostProcess = class extends PostProcess {
      /**
       * Gets a string identifying the name of the class
       * @returns "DepthOfFieldMergePostProcess" string
       */
      getClassName() {
        return "DepthOfFieldMergePostProcess";
      }
      /**
       * Creates a new instance of DepthOfFieldMergePostProcess
       * @param name The name of the effect.
       * @param originalFromInput Post process which's input will be used for the merge.
       * @param circleOfConfusion Circle of confusion post process which's output will be used to blur each pixel.
       * @param _blurSteps Blur post processes from low to high which will be mixed with the original image.
       * @param options The required width/height ratio to downsize to before computing the render pass.
       * @param camera The camera to apply the render pass to.
       * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
       * @param engine The engine which the post process will be applied. (default: current engine)
       * @param reusable If the post process can be reused on the same frame. (default: false)
       * @param textureType Type of textures used when performing the post process. (default: 0)
       * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
       */
      constructor(name13, originalFromInput, circleOfConfusion, _blurSteps, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
        const blockCompilationFinal = typeof options === "number" ? blockCompilation : !!options.blockCompilation;
        const localOptions = {
          samplers: ThinDepthOfFieldMergePostProcess.Samplers,
          size: typeof options === "number" ? options : void 0,
          camera,
          samplingMode,
          engine,
          reusable,
          textureType,
          ...options,
          blockCompilation: true
        };
        super(name13, ThinDepthOfFieldMergePostProcess.FragmentUrl, {
          effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinDepthOfFieldMergePostProcess(name13, engine, localOptions) : void 0,
          ...localOptions
        });
        this._blurSteps = _blurSteps;
        this.externalTextureSamplerBinding = true;
        this.onApplyObservable.add((effect) => {
          effect.setTextureFromPostProcess("textureSampler", originalFromInput);
          effect.setTextureFromPostProcessOutput("circleOfConfusionSampler", circleOfConfusion);
          for (let i = 0; i < _blurSteps.length; i++) {
            const step = _blurSteps[i];
            effect.setTextureFromPostProcessOutput("blurStep" + (_blurSteps.length - i - 1), step);
          }
        });
        if (!blockCompilationFinal) {
          this.updateEffect();
        }
      }
      /**
       * Updates the effect with the current post process compile time values and recompiles the shader.
       * @param defines Define statements that should be added at the beginning of the shader. (default: null)
       * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)
       * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)
       * @param indexParameters The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx
       * @param onCompiled Called when the shader has been compiled.
       * @param onError Called if there is an error when compiling a shader.
       */
      updateEffect(defines = null, uniforms = null, samplers = null, indexParameters, onCompiled, onError) {
        if (!defines) {
          defines = "";
          defines += "#define BLUR_LEVEL " + (this._blurSteps.length - 1) + "\n";
        }
        super.updateEffect(defines, uniforms, samplers, indexParameters, onCompiled, onError);
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/depthOfFieldEffect.js
var DepthOfFieldEffectBlurLevel, DepthOfFieldEffect;
var init_depthOfFieldEffect = __esm({
  "node_modules/@babylonjs/core/PostProcesses/depthOfFieldEffect.js"() {
    init_texture();
    init_postProcessRenderEffect();
    init_circleOfConfusionPostProcess();
    init_depthOfFieldBlurPostProcess();
    init_depthOfFieldMergePostProcess();
    init_thinDepthOfFieldEffect();
    (function(DepthOfFieldEffectBlurLevel2) {
      DepthOfFieldEffectBlurLevel2[DepthOfFieldEffectBlurLevel2["Low"] = 0] = "Low";
      DepthOfFieldEffectBlurLevel2[DepthOfFieldEffectBlurLevel2["Medium"] = 1] = "Medium";
      DepthOfFieldEffectBlurLevel2[DepthOfFieldEffectBlurLevel2["High"] = 2] = "High";
    })(DepthOfFieldEffectBlurLevel || (DepthOfFieldEffectBlurLevel = {}));
    DepthOfFieldEffect = class extends PostProcessRenderEffect {
      /**
       * The focal the length of the camera used in the effect in scene units/1000 (eg. millimeter)
       */
      set focalLength(value) {
        this._thinDepthOfFieldEffect.focalLength = value;
      }
      get focalLength() {
        return this._thinDepthOfFieldEffect.focalLength;
      }
      /**
       * F-Stop of the effect's camera. The diameter of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
       */
      set fStop(value) {
        this._thinDepthOfFieldEffect.fStop = value;
      }
      get fStop() {
        return this._thinDepthOfFieldEffect.fStop;
      }
      /**
       * Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
       */
      set focusDistance(value) {
        this._thinDepthOfFieldEffect.focusDistance = value;
      }
      get focusDistance() {
        return this._thinDepthOfFieldEffect.focusDistance;
      }
      /**
       * Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diameter of the resulting aperture can be computed by lensSize/fStop.
       */
      set lensSize(value) {
        this._thinDepthOfFieldEffect.lensSize = value;
      }
      get lensSize() {
        return this._thinDepthOfFieldEffect.lensSize;
      }
      /**
       * Creates a new instance DepthOfFieldEffect
       * @param sceneOrEngine The scene or engine the effect belongs to.
       * @param depthTexture The depth texture of the scene to compute the circle of confusion.This must be set in order for this to function but may be set after initialization if needed.
       * @param blurLevel
       * @param pipelineTextureType The type of texture to be used when performing the post processing.
       * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
       * @param depthNotNormalized If the depth from the depth texture is already normalized or if the normalization should be done at runtime in the shader (default: false)
       */
      constructor(sceneOrEngine, depthTexture, blurLevel = 0, pipelineTextureType = 0, blockCompilation = false, depthNotNormalized = false) {
        const engine = sceneOrEngine._renderForCamera ? sceneOrEngine.getEngine() : sceneOrEngine;
        super(engine, "depth of field", () => {
          return this._effects;
        }, true);
        this._effects = [];
        this._thinDepthOfFieldEffect = new ThinDepthOfFieldEffect("Depth of Field", engine, blurLevel, false, blockCompilation);
        const circleOfConfusionTextureFormat = engine.isWebGPU || engine.version > 1 ? 6 : 5;
        this._circleOfConfusion = new CircleOfConfusionPostProcess("circleOfConfusion", depthTexture, {
          size: 1,
          samplingMode: Texture.BILINEAR_SAMPLINGMODE,
          engine,
          textureType: pipelineTextureType,
          blockCompilation,
          depthNotNormalized,
          effectWrapper: this._thinDepthOfFieldEffect._circleOfConfusion
        }, null);
        this._depthOfFieldBlurY = [];
        this._depthOfFieldBlurX = [];
        const blurCount = this._thinDepthOfFieldEffect._depthOfFieldBlurX.length;
        for (let i = 0; i < blurCount; i++) {
          const [thinBlurY, ratioY] = this._thinDepthOfFieldEffect._depthOfFieldBlurY[i];
          const blurY = new DepthOfFieldBlurPostProcess("vertical blur", null, thinBlurY.direction, thinBlurY.kernel, {
            size: ratioY,
            samplingMode: Texture.BILINEAR_SAMPLINGMODE,
            engine,
            textureType: pipelineTextureType,
            blockCompilation,
            textureFormat: i == 0 ? circleOfConfusionTextureFormat : 5,
            effectWrapper: thinBlurY
          }, null, this._circleOfConfusion, i == 0 ? this._circleOfConfusion : null);
          blurY.autoClear = false;
          const [thinBlurX, ratioX] = this._thinDepthOfFieldEffect._depthOfFieldBlurX[i];
          const blurX = new DepthOfFieldBlurPostProcess("horizontal blur", null, thinBlurX.direction, thinBlurX.kernel, {
            size: ratioX,
            samplingMode: Texture.BILINEAR_SAMPLINGMODE,
            engine,
            textureType: pipelineTextureType,
            blockCompilation,
            effectWrapper: thinBlurX
          }, null, this._circleOfConfusion, null);
          blurX.autoClear = false;
          this._depthOfFieldBlurY.push(blurY);
          this._depthOfFieldBlurX.push(blurX);
        }
        this._effects = [this._circleOfConfusion];
        for (let i = 0; i < this._depthOfFieldBlurX.length; i++) {
          this._effects.push(this._depthOfFieldBlurY[i]);
          this._effects.push(this._depthOfFieldBlurX[i]);
        }
        this._dofMerge = new DepthOfFieldMergePostProcess("dofMerge", this._circleOfConfusion, this._circleOfConfusion, this._depthOfFieldBlurX, {
          size: this._thinDepthOfFieldEffect._depthOfFieldBlurX[blurCount - 1][1],
          samplingMode: Texture.BILINEAR_SAMPLINGMODE,
          engine,
          textureType: pipelineTextureType,
          blockCompilation,
          effectWrapper: this._thinDepthOfFieldEffect._dofMerge
        }, null);
        this._dofMerge.autoClear = false;
        this._effects.push(this._dofMerge);
      }
      /**
       * Get the current class name of the current effect
       * @returns "DepthOfFieldEffect"
       */
      getClassName() {
        return "DepthOfFieldEffect";
      }
      /**
       * Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.
       */
      set depthTexture(value) {
        this._circleOfConfusion.depthTexture = value;
      }
      /**
       * Disposes each of the internal effects for a given camera.
       * @param camera The camera to dispose the effect on.
       */
      disposeEffects(camera) {
        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
          this._effects[effectIndex].dispose(camera);
        }
      }
      /**
       * @internal Internal
       */
      _updateEffects() {
        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {
          this._effects[effectIndex].updateEffect();
        }
      }
      /**
       * Internal
       * @returns if all the contained post processes are ready.
       * @internal
       */
      _isReady() {
        return this._thinDepthOfFieldEffect.isReady();
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/grainPostProcess.js
var GrainPostProcess;
var init_grainPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/grainPostProcess.js"() {
    init_tslib_es6();
    init_postProcess();
    init_typeStore();
    init_decorators();
    init_decorators_serialization();
    init_thinGrainPostProcess();
    GrainPostProcess = class _GrainPostProcess extends PostProcess {
      /**
       * The intensity of the grain added (default: 30)
       */
      get intensity() {
        return this._effectWrapper.intensity;
      }
      set intensity(value) {
        this._effectWrapper.intensity = value;
      }
      /**
       * If the grain should be randomized on every frame
       */
      get animated() {
        return this._effectWrapper.animated;
      }
      set animated(value) {
        this._effectWrapper.animated = value;
      }
      /**
       * Gets a string identifying the name of the class
       * @returns "GrainPostProcess" string
       */
      getClassName() {
        return "GrainPostProcess";
      }
      /**
       * Creates a new instance of @see GrainPostProcess
       * @param name The name of the effect.
       * @param options The required width/height ratio to downsize to before computing the render pass.
       * @param camera The camera to apply the render pass to.
       * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
       * @param engine The engine which the post process will be applied. (default: current engine)
       * @param reusable If the post process can be reused on the same frame. (default: false)
       * @param textureType Type of textures used when performing the post process. (default: 0)
       * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
       */
      constructor(name13, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
        const localOptions = {
          uniforms: ThinGrainPostProcess.Uniforms,
          size: typeof options === "number" ? options : void 0,
          camera,
          samplingMode,
          engine,
          reusable,
          textureType,
          blockCompilation,
          ...options
        };
        super(name13, ThinGrainPostProcess.FragmentUrl, {
          effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinGrainPostProcess(name13, engine, localOptions) : void 0,
          ...localOptions
        });
      }
      /**
       * @internal
       */
      static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
        return SerializationHelper.Parse(() => {
          return new _GrainPostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable);
        }, parsedPostProcess, scene, rootUrl);
      }
    };
    __decorate([
      serialize()
    ], GrainPostProcess.prototype, "intensity", null);
    __decorate([
      serialize()
    ], GrainPostProcess.prototype, "animated", null);
    RegisterClass("BABYLON.GrainPostProcess", GrainPostProcess);
  }
});

// node_modules/@babylonjs/core/PostProcesses/imageProcessingPostProcess.js
var ImageProcessingPostProcess;
var init_imageProcessingPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/imageProcessingPostProcess.js"() {
    init_tslib_es6();
    init_decorators();
    init_postProcess();
    init_thinImageProcessingPostProcess();
    ImageProcessingPostProcess = class extends PostProcess {
      get _imageProcessingConfiguration() {
        return this._effectWrapper.imageProcessingConfiguration;
      }
      /**
       * Gets the image processing configuration used either in this material.
       */
      get imageProcessingConfiguration() {
        return this._effectWrapper.imageProcessingConfiguration;
      }
      /**
       * Sets the Default image processing configuration used either in the this material.
       *
       * If sets to null, the scene one is in use.
       */
      set imageProcessingConfiguration(value) {
        this._effectWrapper.imageProcessingConfiguration = value;
      }
      /**
       * If the post process is supported.
       */
      get isSupported() {
        const effect = this.getEffect();
        return !effect || effect.isSupported;
      }
      /**
       * Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .
       */
      get colorCurves() {
        return this.imageProcessingConfiguration.colorCurves;
      }
      /**
       * Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .
       */
      set colorCurves(value) {
        this.imageProcessingConfiguration.colorCurves = value;
      }
      /**
       * Gets whether the color curves effect is enabled.
       */
      get colorCurvesEnabled() {
        return this.imageProcessingConfiguration.colorCurvesEnabled;
      }
      /**
       * Sets whether the color curves effect is enabled.
       */
      set colorCurvesEnabled(value) {
        this.imageProcessingConfiguration.colorCurvesEnabled = value;
      }
      /**
       * Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
       */
      get colorGradingTexture() {
        return this.imageProcessingConfiguration.colorGradingTexture;
      }
      /**
       * Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
       */
      set colorGradingTexture(value) {
        this.imageProcessingConfiguration.colorGradingTexture = value;
      }
      /**
       * Gets whether the color grading effect is enabled.
       */
      get colorGradingEnabled() {
        return this.imageProcessingConfiguration.colorGradingEnabled;
      }
      /**
       * Gets whether the color grading effect is enabled.
       */
      set colorGradingEnabled(value) {
        this.imageProcessingConfiguration.colorGradingEnabled = value;
      }
      /**
       * Gets exposure used in the effect.
       */
      get exposure() {
        return this.imageProcessingConfiguration.exposure;
      }
      /**
       * Sets exposure used in the effect.
       */
      set exposure(value) {
        this.imageProcessingConfiguration.exposure = value;
      }
      /**
       * Gets whether tonemapping is enabled or not.
       */
      get toneMappingEnabled() {
        return this._imageProcessingConfiguration.toneMappingEnabled;
      }
      /**
       * Sets whether tonemapping is enabled or not
       */
      set toneMappingEnabled(value) {
        this._imageProcessingConfiguration.toneMappingEnabled = value;
      }
      /**
       * Gets the type of tone mapping effect.
       */
      get toneMappingType() {
        return this._imageProcessingConfiguration.toneMappingType;
      }
      /**
       * Sets the type of tone mapping effect.
       */
      set toneMappingType(value) {
        this._imageProcessingConfiguration.toneMappingType = value;
      }
      /**
       * Gets contrast used in the effect.
       */
      get contrast() {
        return this.imageProcessingConfiguration.contrast;
      }
      /**
       * Sets contrast used in the effect.
       */
      set contrast(value) {
        this.imageProcessingConfiguration.contrast = value;
      }
      /**
       * Gets Vignette stretch size.
       */
      get vignetteStretch() {
        return this.imageProcessingConfiguration.vignetteStretch;
      }
      /**
       * Sets Vignette stretch size.
       */
      set vignetteStretch(value) {
        this.imageProcessingConfiguration.vignetteStretch = value;
      }
      /**
       * Gets Vignette center X Offset.
       * @deprecated use vignetteCenterX instead
       */
      get vignetteCentreX() {
        return this.imageProcessingConfiguration.vignetteCenterX;
      }
      /**
       * Sets Vignette center X Offset.
       * @deprecated use vignetteCenterX instead
       */
      set vignetteCentreX(value) {
        this.imageProcessingConfiguration.vignetteCenterX = value;
      }
      /**
       * Gets Vignette center Y Offset.
       * @deprecated use vignetteCenterY instead
       */
      get vignetteCentreY() {
        return this.imageProcessingConfiguration.vignetteCenterY;
      }
      /**
       * Sets Vignette center Y Offset.
       * @deprecated use vignetteCenterY instead
       */
      set vignetteCentreY(value) {
        this.imageProcessingConfiguration.vignetteCenterY = value;
      }
      /**
       * Vignette center Y Offset.
       */
      get vignetteCenterY() {
        return this.imageProcessingConfiguration.vignetteCenterY;
      }
      set vignetteCenterY(value) {
        this.imageProcessingConfiguration.vignetteCenterY = value;
      }
      /**
       * Vignette center X Offset.
       */
      get vignetteCenterX() {
        return this.imageProcessingConfiguration.vignetteCenterX;
      }
      set vignetteCenterX(value) {
        this.imageProcessingConfiguration.vignetteCenterX = value;
      }
      /**
       * Gets Vignette weight or intensity of the vignette effect.
       */
      get vignetteWeight() {
        return this.imageProcessingConfiguration.vignetteWeight;
      }
      /**
       * Sets Vignette weight or intensity of the vignette effect.
       */
      set vignetteWeight(value) {
        this.imageProcessingConfiguration.vignetteWeight = value;
      }
      /**
       * Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
       * if vignetteEnabled is set to true.
       */
      get vignetteColor() {
        return this.imageProcessingConfiguration.vignetteColor;
      }
      /**
       * Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
       * if vignetteEnabled is set to true.
       */
      set vignetteColor(value) {
        this.imageProcessingConfiguration.vignetteColor = value;
      }
      /**
       * Gets Camera field of view used by the Vignette effect.
       */
      get vignetteCameraFov() {
        return this.imageProcessingConfiguration.vignetteCameraFov;
      }
      /**
       * Sets Camera field of view used by the Vignette effect.
       */
      set vignetteCameraFov(value) {
        this.imageProcessingConfiguration.vignetteCameraFov = value;
      }
      /**
       * Gets the vignette blend mode allowing different kind of effect.
       */
      get vignetteBlendMode() {
        return this.imageProcessingConfiguration.vignetteBlendMode;
      }
      /**
       * Sets the vignette blend mode allowing different kind of effect.
       */
      set vignetteBlendMode(value) {
        this.imageProcessingConfiguration.vignetteBlendMode = value;
      }
      /**
       * Gets whether the vignette effect is enabled.
       */
      get vignetteEnabled() {
        return this.imageProcessingConfiguration.vignetteEnabled;
      }
      /**
       * Sets whether the vignette effect is enabled.
       */
      set vignetteEnabled(value) {
        this.imageProcessingConfiguration.vignetteEnabled = value;
      }
      /**
       * Gets intensity of the dithering effect.
       */
      get ditheringIntensity() {
        return this.imageProcessingConfiguration.ditheringIntensity;
      }
      /**
       * Sets intensity of the dithering effect.
       */
      set ditheringIntensity(value) {
        this.imageProcessingConfiguration.ditheringIntensity = value;
      }
      /**
       * Gets whether the dithering effect is enabled.
       */
      get ditheringEnabled() {
        return this.imageProcessingConfiguration.ditheringEnabled;
      }
      /**
       * Sets whether the dithering effect is enabled.
       */
      set ditheringEnabled(value) {
        this.imageProcessingConfiguration.ditheringEnabled = value;
      }
      /**
       * Gets whether the input of the processing is in Gamma or Linear Space.
       */
      get fromLinearSpace() {
        return this._effectWrapper.fromLinearSpace;
      }
      /**
       * Sets whether the input of the processing is in Gamma or Linear Space.
       */
      set fromLinearSpace(value) {
        this._effectWrapper.fromLinearSpace = value;
      }
      constructor(name13, options, camera = null, samplingMode, engine, reusable, textureType = 0, imageProcessingConfiguration) {
        const localOptions = {
          size: typeof options === "number" ? options : void 0,
          camera,
          samplingMode,
          engine,
          reusable,
          textureType,
          imageProcessingConfiguration,
          scene: camera?.getScene(),
          ...options,
          blockCompilation: true
        };
        super(name13, ThinImageProcessingPostProcess.FragmentUrl, {
          effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinImageProcessingPostProcess(name13, engine, localOptions) : void 0,
          ...localOptions
        });
        this.onApply = () => {
          this._effectWrapper.overrideAspectRatio = this.aspectRatio;
        };
      }
      /**
       *  "ImageProcessingPostProcess"
       * @returns "ImageProcessingPostProcess"
       */
      getClassName() {
        return "ImageProcessingPostProcess";
      }
      /**
       * @internal
       */
      _updateParameters() {
        this._effectWrapper._updateParameters();
      }
      dispose(camera) {
        super.dispose(camera);
        if (this._imageProcessingConfiguration) {
          this.imageProcessingConfiguration.applyByPostProcess = false;
        }
      }
    };
    __decorate([
      serialize()
    ], ImageProcessingPostProcess.prototype, "fromLinearSpace", null);
  }
});

// node_modules/@babylonjs/core/Rendering/geometryBufferRenderer.js
var Uniforms, GeometryBufferRenderer;
var init_geometryBufferRenderer = __esm({
  "node_modules/@babylonjs/core/Rendering/geometryBufferRenderer.js"() {
    init_math_vector();
    init_buffer();
    init_texture();
    init_multiRenderTarget();
    init_math_color();
    init_devTools();
    init_material();
    init_geometry_fragment();
    init_geometry_vertex();
    init_materialFlags();
    init_clipPlaneMaterialHelper();
    init_materialHelper_functions();
    init_engine_multiRender();
    Uniforms = [
      "world",
      "mBones",
      "viewProjection",
      "diffuseMatrix",
      "view",
      "previousWorld",
      "previousViewProjection",
      "mPreviousBones",
      "bumpMatrix",
      "reflectivityMatrix",
      "albedoMatrix",
      "reflectivityColor",
      "albedoColor",
      "metallic",
      "glossiness",
      "vTangentSpaceParams",
      "vBumpInfos",
      "morphTargetInfluences",
      "morphTargetCount",
      "morphTargetTextureInfo",
      "morphTargetTextureIndices",
      "boneTextureWidth"
    ];
    AddClipPlaneUniforms(Uniforms);
    GeometryBufferRenderer = class _GeometryBufferRenderer {
      /**
       * Gets a boolean indicating if normals are encoded in the [0,1] range in the render target. If true, you should do `normal = normal_rt * 2.0 - 1.0` to get the right normal
       */
      get normalsAreUnsigned() {
        return this._normalsAreUnsigned;
      }
      /**
       * @internal
       * Sets up internal structures to share outputs with PrePassRenderer
       * This method should only be called by the PrePassRenderer itself
       */
      _linkPrePassRenderer(prePassRenderer) {
        this._linkedWithPrePass = true;
        this._prePassRenderer = prePassRenderer;
        if (this._multiRenderTarget) {
          this._multiRenderTarget.onClearObservable.clear();
          this._multiRenderTarget.onClearObservable.add(() => {
          });
        }
      }
      /**
       * @internal
       * Separates internal structures from PrePassRenderer so the geometry buffer can now operate by itself.
       * This method should only be called by the PrePassRenderer itself
       */
      _unlinkPrePassRenderer() {
        this._linkedWithPrePass = false;
        this._createRenderTargets();
      }
      /**
       * @internal
       * Resets the geometry buffer layout
       */
      _resetLayout() {
        this._enableDepth = true;
        this._enableNormal = true;
        this._enablePosition = false;
        this._enableReflectivity = false;
        this._enableVelocity = false;
        this._enableVelocityLinear = false;
        this._enableScreenspaceDepth = false;
        this._attachmentsFromPrePass = [];
      }
      /**
       * @internal
       * Replaces a texture in the geometry buffer renderer
       * Useful when linking textures of the prepass renderer
       */
      _forceTextureType(geometryBufferType, index) {
        if (geometryBufferType === _GeometryBufferRenderer.POSITION_TEXTURE_TYPE) {
          this._positionIndex = index;
          this._enablePosition = true;
        } else if (geometryBufferType === _GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE) {
          this._velocityIndex = index;
          this._enableVelocity = true;
        } else if (geometryBufferType === _GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE) {
          this._velocityLinearIndex = index;
          this._enableVelocityLinear = true;
        } else if (geometryBufferType === _GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE) {
          this._reflectivityIndex = index;
          this._enableReflectivity = true;
        } else if (geometryBufferType === _GeometryBufferRenderer.DEPTH_TEXTURE_TYPE) {
          this._depthIndex = index;
          this._enableDepth = true;
        } else if (geometryBufferType === _GeometryBufferRenderer.NORMAL_TEXTURE_TYPE) {
          this._normalIndex = index;
          this._enableNormal = true;
        } else if (geometryBufferType === _GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE) {
          this._screenspaceDepthIndex = index;
          this._enableScreenspaceDepth = true;
        }
      }
      /**
       * @internal
       * Sets texture attachments
       * Useful when linking textures of the prepass renderer
       */
      _setAttachments(attachments) {
        this._attachmentsFromPrePass = attachments;
      }
      /**
       * @internal
       * Replaces the first texture which is hard coded as a depth texture in the geometry buffer
       * Useful when linking textures of the prepass renderer
       */
      _linkInternalTexture(internalTexture) {
        this._multiRenderTarget.setInternalTexture(internalTexture, 0, false);
      }
      /**
       * Gets the render list (meshes to be rendered) used in the G buffer.
       */
      get renderList() {
        return this._multiRenderTarget.renderList;
      }
      /**
       * Set the render list (meshes to be rendered) used in the G buffer.
       */
      set renderList(meshes) {
        this._multiRenderTarget.renderList = meshes;
      }
      /**
       * Gets whether or not G buffer are supported by the running hardware.
       * This requires draw buffer supports
       */
      get isSupported() {
        return this._multiRenderTarget.isSupported;
      }
      /**
       * Returns the index of the given texture type in the G-Buffer textures array
       * @param textureType The texture type constant. For example GeometryBufferRenderer.POSITION_TEXTURE_INDEX
       * @returns the index of the given texture type in the G-Buffer textures array
       */
      getTextureIndex(textureType) {
        switch (textureType) {
          case _GeometryBufferRenderer.POSITION_TEXTURE_TYPE:
            return this._positionIndex;
          case _GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE:
            return this._velocityIndex;
          case _GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE:
            return this._velocityLinearIndex;
          case _GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE:
            return this._reflectivityIndex;
          case _GeometryBufferRenderer.DEPTH_TEXTURE_TYPE:
            return this._depthIndex;
          case _GeometryBufferRenderer.NORMAL_TEXTURE_TYPE:
            return this._normalIndex;
          case _GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE:
            return this._screenspaceDepthIndex;
          default:
            return -1;
        }
      }
      /**
       * @returns a boolean indicating if object's depths are enabled for the G buffer.
       */
      get enableDepth() {
        return this._enableDepth;
      }
      /**
       * Sets whether or not object's depths are enabled for the G buffer.
       */
      set enableDepth(enable) {
        this._enableDepth = enable;
        if (!this._linkedWithPrePass) {
          this.dispose();
          this._createRenderTargets();
        }
      }
      /**
       * @returns a boolean indicating if object's normals are enabled for the G buffer.
       */
      get enableNormal() {
        return this._enableNormal;
      }
      /**
       * Sets whether or not object's normals are enabled for the G buffer.
       */
      set enableNormal(enable) {
        this._enableNormal = enable;
        if (!this._linkedWithPrePass) {
          this.dispose();
          this._createRenderTargets();
        }
      }
      /**
       * @returns a boolean indicating if objects positions are enabled for the G buffer.
       */
      get enablePosition() {
        return this._enablePosition;
      }
      /**
       * Sets whether or not objects positions are enabled for the G buffer.
       */
      set enablePosition(enable) {
        this._enablePosition = enable;
        if (!this._linkedWithPrePass) {
          this.dispose();
          this._createRenderTargets();
        }
      }
      /**
       * @returns a boolean indicating if objects velocities are enabled for the G buffer.
       */
      get enableVelocity() {
        return this._enableVelocity;
      }
      /**
       * Sets whether or not objects velocities are enabled for the G buffer.
       */
      set enableVelocity(enable) {
        this._enableVelocity = enable;
        if (!enable) {
          this._previousTransformationMatrices = {};
        }
        if (!this._linkedWithPrePass) {
          this.dispose();
          this._createRenderTargets();
        }
        this._scene.needsPreviousWorldMatrices = enable;
      }
      /**
       * @returns a boolean indicating if object's linear velocities are enabled for the G buffer.
       */
      get enableVelocityLinear() {
        return this._enableVelocityLinear;
      }
      /**
       * Sets whether or not object's linear velocities are enabled for the G buffer.
       */
      set enableVelocityLinear(enable) {
        this._enableVelocityLinear = enable;
        if (!this._linkedWithPrePass) {
          this.dispose();
          this._createRenderTargets();
        }
      }
      /**
       * Gets a boolean indicating if objects reflectivity are enabled in the G buffer.
       */
      get enableReflectivity() {
        return this._enableReflectivity;
      }
      /**
       * Sets whether or not objects reflectivity are enabled for the G buffer.
       * For Metallic-Roughness workflow with ORM texture, we assume that ORM texture is defined according to the default layout:
       * pbr.useRoughnessFromMetallicTextureAlpha = false;
       * pbr.useRoughnessFromMetallicTextureGreen = true;
       * pbr.useMetallnessFromMetallicTextureBlue = true;
       */
      set enableReflectivity(enable) {
        this._enableReflectivity = enable;
        if (!this._linkedWithPrePass) {
          this.dispose();
          this._createRenderTargets();
        }
      }
      /**
       * Sets whether or not objects screenspace depth are enabled for the G buffer.
       */
      get enableScreenspaceDepth() {
        return this._enableScreenspaceDepth;
      }
      set enableScreenspaceDepth(enable) {
        this._enableScreenspaceDepth = enable;
        if (!this._linkedWithPrePass) {
          this.dispose();
          this._createRenderTargets();
        }
      }
      /**
       * Gets the scene associated with the buffer.
       */
      get scene() {
        return this._scene;
      }
      /**
       * Gets the ratio used by the buffer during its creation.
       * How big is the buffer related to the main canvas.
       */
      get ratio() {
        return typeof this._ratioOrDimensions === "object" ? 1 : this._ratioOrDimensions;
      }
      /**
       * Gets the shader language used in this material.
       */
      get shaderLanguage() {
        return this._shaderLanguage;
      }
      /**
       * Creates a new G Buffer for the scene
       * @param scene The scene the buffer belongs to
       * @param ratioOrDimensions How big is the buffer related to the main canvas (default: 1). You can also directly pass a width and height for the generated textures
       * @param depthFormat Format of the depth texture (default: 15)
       * @param textureTypesAndFormats The types and formats of textures to create as render targets. If not provided, all textures will be RGBA and float or half float, depending on the engine capabilities.
       */
      constructor(scene, ratioOrDimensions = 1, depthFormat = 15, textureTypesAndFormats) {
        this._previousTransformationMatrices = {};
        this._previousBonesTransformationMatrices = {};
        this.excludedSkinnedMeshesFromVelocity = [];
        this.renderTransparentMeshes = true;
        this.generateNormalsInWorldSpace = false;
        this._normalsAreUnsigned = false;
        this._resizeObserver = null;
        this._enableDepth = true;
        this._enableNormal = true;
        this._enablePosition = false;
        this._enableVelocity = false;
        this._enableVelocityLinear = false;
        this._enableReflectivity = false;
        this._enableScreenspaceDepth = false;
        this._clearColor = new Color4(0, 0, 0, 0);
        this._clearDepthColor = new Color4(0, 0, 0, 1);
        this._positionIndex = -1;
        this._velocityIndex = -1;
        this._velocityLinearIndex = -1;
        this._reflectivityIndex = -1;
        this._depthIndex = -1;
        this._normalIndex = -1;
        this._screenspaceDepthIndex = -1;
        this._linkedWithPrePass = false;
        this.useSpecificClearForDepthTexture = false;
        this._shaderLanguage = 0;
        this._shadersLoaded = false;
        this._scene = scene;
        this._ratioOrDimensions = ratioOrDimensions;
        this._useUbo = scene.getEngine().supportsUniformBuffers;
        this._depthFormat = depthFormat;
        this._textureTypesAndFormats = textureTypesAndFormats || {};
        this._initShaderSourceAsync();
        _GeometryBufferRenderer._SceneComponentInitialization(this._scene);
        this._createRenderTargets();
      }
      async _initShaderSourceAsync() {
        const engine = this._scene.getEngine();
        if (engine.isWebGPU && !_GeometryBufferRenderer.ForceGLSL) {
          this._shaderLanguage = 1;
          await Promise.all([import("./geometry.vertex-6R6F7SYJ.js"), import("./geometry.fragment-M65A2Z4I.js")]);
        } else {
          await Promise.all([import("./geometry.vertex-CUQF3JKG.js"), import("./geometry.fragment-OGEPIQFN.js")]);
        }
        this._shadersLoaded = true;
      }
      /**
       * Checks whether everything is ready to render a submesh to the G buffer.
       * @param subMesh the submesh to check readiness for
       * @param useInstances is the mesh drawn using instance or not
       * @returns true if ready otherwise false
       */
      isReady(subMesh, useInstances) {
        if (!this._shadersLoaded) {
          return false;
        }
        const material = subMesh.getMaterial();
        if (material && material.disableDepthWrite) {
          return false;
        }
        const defines = [];
        const attribs = [VertexBuffer.PositionKind];
        const mesh = subMesh.getMesh();
        const hasNormals = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
        if (hasNormals) {
          defines.push("#define HAS_NORMAL_ATTRIBUTE");
          attribs.push(VertexBuffer.NormalKind);
        }
        let uv1 = false;
        let uv2 = false;
        const color = false;
        if (material) {
          let needUv = false;
          if (material.needAlphaTestingForMesh(mesh) && material.getAlphaTestTexture()) {
            defines.push("#define ALPHATEST");
            defines.push(`#define ALPHATEST_UV${material.getAlphaTestTexture().coordinatesIndex + 1}`);
            needUv = true;
          }
          if ((material.bumpTexture || material.normalTexture || material.geometryNormalTexture) && MaterialFlags.BumpTextureEnabled) {
            const texture = material.bumpTexture || material.normalTexture || material.geometryNormalTexture;
            defines.push("#define BUMP");
            defines.push(`#define BUMP_UV${texture.coordinatesIndex + 1}`);
            needUv = true;
          }
          if (this._enableReflectivity) {
            let metallicWorkflow = false;
            if (material.getClassName() === "PBRMetallicRoughnessMaterial") {
              if (material.metallicRoughnessTexture) {
                defines.push("#define ORMTEXTURE");
                defines.push(`#define REFLECTIVITY_UV${material.metallicRoughnessTexture.coordinatesIndex + 1}`);
                defines.push("#define METALLICWORKFLOW");
                needUv = true;
                metallicWorkflow = true;
              }
              if (material.metallic != null) {
                defines.push("#define METALLIC");
                defines.push("#define METALLICWORKFLOW");
                metallicWorkflow = true;
              }
              if (material.roughness != null) {
                defines.push("#define ROUGHNESS");
                defines.push("#define METALLICWORKFLOW");
                metallicWorkflow = true;
              }
              if (metallicWorkflow) {
                if (material.baseTexture) {
                  defines.push("#define ALBEDOTEXTURE");
                  defines.push(`#define ALBEDO_UV${material.baseTexture.coordinatesIndex + 1}`);
                  if (material.baseTexture.gammaSpace) {
                    defines.push("#define GAMMAALBEDO");
                  }
                  needUv = true;
                }
                if (material.baseColor) {
                  defines.push("#define ALBEDOCOLOR");
                }
              }
            } else if (material.getClassName() === "PBRSpecularGlossinessMaterial") {
              if (material.specularGlossinessTexture) {
                defines.push("#define SPECULARGLOSSINESSTEXTURE");
                defines.push(`#define REFLECTIVITY_UV${material.specularGlossinessTexture.coordinatesIndex + 1}`);
                needUv = true;
                if (material.specularGlossinessTexture.gammaSpace) {
                  defines.push("#define GAMMAREFLECTIVITYTEXTURE");
                }
              } else {
                if (material.specularColor) {
                  defines.push("#define REFLECTIVITYCOLOR");
                }
              }
              if (material.glossiness != null) {
                defines.push("#define GLOSSINESS");
              }
            } else if (material.getClassName() === "PBRMaterial") {
              if (material.metallicTexture) {
                defines.push("#define ORMTEXTURE");
                defines.push(`#define REFLECTIVITY_UV${material.metallicTexture.coordinatesIndex + 1}`);
                defines.push("#define METALLICWORKFLOW");
                needUv = true;
                metallicWorkflow = true;
              }
              if (material.metallic != null) {
                defines.push("#define METALLIC");
                defines.push("#define METALLICWORKFLOW");
                metallicWorkflow = true;
              }
              if (material.roughness != null) {
                defines.push("#define ROUGHNESS");
                defines.push("#define METALLICWORKFLOW");
                metallicWorkflow = true;
              }
              if (metallicWorkflow) {
                if (material.albedoTexture) {
                  defines.push("#define ALBEDOTEXTURE");
                  defines.push(`#define ALBEDO_UV${material.albedoTexture.coordinatesIndex + 1}`);
                  if (material.albedoTexture.gammaSpace) {
                    defines.push("#define GAMMAALBEDO");
                  }
                  needUv = true;
                }
                if (material.albedoColor) {
                  defines.push("#define ALBEDOCOLOR");
                }
              } else {
                if (material.reflectivityTexture) {
                  defines.push("#define SPECULARGLOSSINESSTEXTURE");
                  defines.push(`#define REFLECTIVITY_UV${material.reflectivityTexture.coordinatesIndex + 1}`);
                  if (material.reflectivityTexture.gammaSpace) {
                    defines.push("#define GAMMAREFLECTIVITYTEXTURE");
                  }
                  needUv = true;
                } else if (material.reflectivityColor) {
                  defines.push("#define REFLECTIVITYCOLOR");
                }
                if (material.microSurface != null) {
                  defines.push("#define GLOSSINESS");
                }
              }
            } else if (material.getClassName() === "StandardMaterial") {
              if (material.specularTexture) {
                defines.push("#define REFLECTIVITYTEXTURE");
                defines.push(`#define REFLECTIVITY_UV${material.specularTexture.coordinatesIndex + 1}`);
                if (material.specularTexture.gammaSpace) {
                  defines.push("#define GAMMAREFLECTIVITYTEXTURE");
                }
                needUv = true;
              }
              if (material.specularColor) {
                defines.push("#define REFLECTIVITYCOLOR");
              }
            } else if (material.getClassName() === "OpenPBRMaterial") {
              const pbrMaterial = material;
              defines.push("#define METALLICWORKFLOW");
              metallicWorkflow = true;
              defines.push("#define METALLIC");
              defines.push("#define ROUGHNESS");
              if (pbrMaterial._useRoughnessFromMetallicTextureGreen && pbrMaterial.baseMetalnessTexture) {
                defines.push("#define ORMTEXTURE");
                defines.push(`#define REFLECTIVITY_UV${pbrMaterial.baseMetalnessTexture.coordinatesIndex + 1}`);
                needUv = true;
              } else if (pbrMaterial.baseMetalnessTexture) {
                defines.push("#define METALLIC_TEXTURE");
                defines.push(`#define METALLIC_UV${pbrMaterial.baseMetalnessTexture.coordinatesIndex + 1}`);
                needUv = true;
              } else if (pbrMaterial.specularRoughnessTexture) {
                defines.push("#define ROUGHNESS_TEXTURE");
                defines.push(`#define ROUGHNESS_UV${pbrMaterial.specularRoughnessTexture.coordinatesIndex + 1}`);
                needUv = true;
              }
              if (pbrMaterial.baseColorTexture) {
                defines.push("#define ALBEDOTEXTURE");
                defines.push(`#define ALBEDO_UV${pbrMaterial.baseColorTexture.coordinatesIndex + 1}`);
                if (pbrMaterial.baseColorTexture.gammaSpace) {
                  defines.push("#define GAMMAALBEDO");
                }
                needUv = true;
              }
              if (pbrMaterial.baseColor) {
                defines.push("#define ALBEDOCOLOR");
              }
            }
          }
          if (needUv) {
            defines.push("#define NEED_UV");
            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
              attribs.push(VertexBuffer.UVKind);
              defines.push("#define UV1");
              uv1 = true;
            }
            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
              attribs.push(VertexBuffer.UV2Kind);
              defines.push("#define UV2");
              uv2 = true;
            }
          }
        }
        if (this._enableDepth) {
          defines.push("#define DEPTH");
          defines.push("#define DEPTH_INDEX " + this._depthIndex);
        }
        if (this._enableNormal) {
          defines.push("#define NORMAL");
          defines.push("#define NORMAL_INDEX " + this._normalIndex);
        }
        if (this._enablePosition) {
          defines.push("#define POSITION");
          defines.push("#define POSITION_INDEX " + this._positionIndex);
        }
        if (this._enableVelocity) {
          defines.push("#define VELOCITY");
          defines.push("#define VELOCITY_INDEX " + this._velocityIndex);
          if (this.excludedSkinnedMeshesFromVelocity.indexOf(mesh) === -1) {
            defines.push("#define BONES_VELOCITY_ENABLED");
          }
        }
        if (this._enableVelocityLinear) {
          defines.push("#define VELOCITY_LINEAR");
          defines.push("#define VELOCITY_LINEAR_INDEX " + this._velocityLinearIndex);
          if (this.excludedSkinnedMeshesFromVelocity.indexOf(mesh) === -1) {
            defines.push("#define BONES_VELOCITY_ENABLED");
          }
        }
        if (this._enableReflectivity) {
          defines.push("#define REFLECTIVITY");
          defines.push("#define REFLECTIVITY_INDEX " + this._reflectivityIndex);
        }
        if (this._enableScreenspaceDepth) {
          if (this._screenspaceDepthIndex !== -1) {
            defines.push("#define SCREENSPACE_DEPTH_INDEX " + this._screenspaceDepthIndex);
            defines.push("#define SCREENSPACE_DEPTH");
          }
        }
        if (this.generateNormalsInWorldSpace) {
          defines.push("#define NORMAL_WORLDSPACE");
        }
        if (this._normalsAreUnsigned) {
          defines.push("#define ENCODE_NORMAL");
        }
        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
          attribs.push(VertexBuffer.MatricesIndicesKind);
          attribs.push(VertexBuffer.MatricesWeightsKind);
          if (mesh.numBoneInfluencers > 4) {
            attribs.push(VertexBuffer.MatricesIndicesExtraKind);
            attribs.push(VertexBuffer.MatricesWeightsExtraKind);
          }
          defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
          defines.push("#define BONETEXTURE " + mesh.skeleton.isUsingTextureForMatrices);
          defines.push("#define BonesPerMesh " + (mesh.skeleton.bones.length + 1));
        } else {
          defines.push("#define NUM_BONE_INFLUENCERS 0");
          defines.push("#define BONETEXTURE false");
          defines.push("#define BonesPerMesh 0");
        }
        const numMorphInfluencers = mesh.morphTargetManager ? PrepareDefinesAndAttributesForMorphTargets(
          mesh.morphTargetManager,
          defines,
          attribs,
          mesh,
          true,
          // usePositionMorph
          true,
          // useNormalMorph
          false,
          // useTangentMorph
          uv1,
          // useUVMorph
          uv2,
          // useUV2Morph
          color
          // useColorMorph
        ) : 0;
        if (useInstances) {
          defines.push("#define INSTANCES");
          PushAttributesForInstances(attribs, this._enableVelocity || this._enableVelocityLinear);
          if (subMesh.getRenderingMesh().hasThinInstances) {
            defines.push("#define THIN_INSTANCES");
          }
        }
        if (this._linkedWithPrePass) {
          defines.push("#define SCENE_MRT_COUNT " + this._attachmentsFromPrePass.length);
        } else {
          defines.push("#define SCENE_MRT_COUNT " + this._multiRenderTarget.textures.length);
        }
        PrepareStringDefinesForClipPlanes(material, this._scene, defines);
        const engine = this._scene.getEngine();
        const drawWrapper = subMesh._getDrawWrapper(void 0, true);
        const cachedDefines = drawWrapper.defines;
        const join = defines.join("\n");
        if (cachedDefines !== join) {
          drawWrapper.setEffect(engine.createEffect("geometry", {
            attributes: attribs,
            uniformsNames: Uniforms,
            samplers: ["diffuseSampler", "bumpSampler", "reflectivitySampler", "albedoSampler", "morphTargets", "boneSampler"],
            defines: join,
            onCompiled: null,
            fallbacks: null,
            onError: null,
            uniformBuffersNames: ["Scene"],
            indexParameters: { buffersCount: this._multiRenderTarget.textures.length - 1, maxSimultaneousMorphTargets: numMorphInfluencers },
            shaderLanguage: this.shaderLanguage
          }, engine), join);
        }
        return drawWrapper.effect.isReady();
      }
      /**
       * Gets the current underlying G Buffer.
       * @returns the buffer
       */
      getGBuffer() {
        return this._multiRenderTarget;
      }
      /**
       * Gets the number of samples used to render the buffer (anti aliasing).
       */
      get samples() {
        return this._multiRenderTarget.samples;
      }
      /**
       * Sets the number of samples used to render the buffer (anti aliasing).
       */
      set samples(value) {
        this._multiRenderTarget.samples = value;
      }
      /**
       * Disposes the renderer and frees up associated resources.
       */
      dispose() {
        if (this._resizeObserver) {
          const engine = this._scene.getEngine();
          engine.onResizeObservable.remove(this._resizeObserver);
          this._resizeObserver = null;
        }
        this.getGBuffer().dispose();
      }
      _assignRenderTargetIndices() {
        const textureNames = [];
        const textureTypesAndFormats = [];
        let count = 0;
        if (this._enableDepth) {
          this._depthIndex = count;
          count++;
          textureNames.push("gBuffer_Depth");
          textureTypesAndFormats.push(this._textureTypesAndFormats[_GeometryBufferRenderer.DEPTH_TEXTURE_TYPE]);
        }
        if (this._enableNormal) {
          this._normalIndex = count;
          count++;
          textureNames.push("gBuffer_Normal");
          textureTypesAndFormats.push(this._textureTypesAndFormats[_GeometryBufferRenderer.NORMAL_TEXTURE_TYPE]);
        }
        if (this._enablePosition) {
          this._positionIndex = count;
          count++;
          textureNames.push("gBuffer_Position");
          textureTypesAndFormats.push(this._textureTypesAndFormats[_GeometryBufferRenderer.POSITION_TEXTURE_TYPE]);
        }
        if (this._enableVelocity) {
          this._velocityIndex = count;
          count++;
          textureNames.push("gBuffer_Velocity");
          textureTypesAndFormats.push(this._textureTypesAndFormats[_GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE]);
        }
        if (this._enableVelocityLinear) {
          this._velocityLinearIndex = count;
          count++;
          textureNames.push("gBuffer_VelocityLinear");
          textureTypesAndFormats.push(this._textureTypesAndFormats[_GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE]);
        }
        if (this._enableReflectivity) {
          this._reflectivityIndex = count;
          count++;
          textureNames.push("gBuffer_Reflectivity");
          textureTypesAndFormats.push(this._textureTypesAndFormats[_GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE]);
        }
        if (this._enableScreenspaceDepth) {
          this._screenspaceDepthIndex = count;
          count++;
          textureNames.push("gBuffer_ScreenspaceDepth");
          textureTypesAndFormats.push(this._textureTypesAndFormats[_GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE]);
        }
        return [count, textureNames, textureTypesAndFormats];
      }
      _createRenderTargets() {
        const engine = this._scene.getEngine();
        const [count, textureNames, textureTypesAndFormat] = this._assignRenderTargetIndices();
        let type = 0;
        if (engine._caps.textureFloat && engine._caps.textureFloatLinearFiltering) {
          type = 1;
        } else if (engine._caps.textureHalfFloat && engine._caps.textureHalfFloatLinearFiltering) {
          type = 2;
        }
        const dimensions = this._ratioOrDimensions.width !== void 0 ? this._ratioOrDimensions : { width: engine.getRenderWidth() * this._ratioOrDimensions, height: engine.getRenderHeight() * this._ratioOrDimensions };
        const textureTypes = [];
        const textureFormats = [];
        for (const typeAndFormat of textureTypesAndFormat) {
          if (typeAndFormat) {
            textureTypes.push(typeAndFormat.textureType);
            textureFormats.push(typeAndFormat.textureFormat);
          } else {
            textureTypes.push(type);
            textureFormats.push(5);
          }
        }
        this._normalsAreUnsigned = textureTypes[_GeometryBufferRenderer.NORMAL_TEXTURE_TYPE] === 11 || textureTypes[_GeometryBufferRenderer.NORMAL_TEXTURE_TYPE] === 13;
        this._multiRenderTarget = new MultiRenderTarget("gBuffer", dimensions, count, this._scene, { generateMipMaps: false, generateDepthTexture: true, types: textureTypes, formats: textureFormats, depthTextureFormat: this._depthFormat }, textureNames.concat("gBuffer_DepthBuffer"));
        if (!this.isSupported) {
          return;
        }
        this._multiRenderTarget.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._multiRenderTarget.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._multiRenderTarget.refreshRate = 1;
        this._multiRenderTarget.renderParticles = false;
        this._multiRenderTarget.renderList = null;
        const layoutAttachmentsAll = [true];
        const layoutAttachmentsAllButDepth = [false];
        const layoutAttachmentsDepthOnly = [true];
        for (let i = 1; i < count; ++i) {
          layoutAttachmentsAll.push(true);
          layoutAttachmentsDepthOnly.push(false);
          layoutAttachmentsAllButDepth.push(true);
        }
        const attachmentsAll = engine.buildTextureLayout(layoutAttachmentsAll);
        const attachmentsAllButDepth = engine.buildTextureLayout(layoutAttachmentsAllButDepth);
        const attachmentsDepthOnly = engine.buildTextureLayout(layoutAttachmentsDepthOnly);
        this._multiRenderTarget.onClearObservable.add((engine2) => {
          engine2.bindAttachments(this.useSpecificClearForDepthTexture ? attachmentsAllButDepth : attachmentsAll);
          engine2.clear(this._clearColor, true, true, true);
          if (this.useSpecificClearForDepthTexture) {
            engine2.bindAttachments(attachmentsDepthOnly);
            engine2.clear(this._clearDepthColor, true, true, true);
          }
          engine2.bindAttachments(attachmentsAll);
        });
        this._resizeObserver = engine.onResizeObservable.add(() => {
          if (this._multiRenderTarget) {
            const dimensions2 = this._ratioOrDimensions.width !== void 0 ? this._ratioOrDimensions : { width: engine.getRenderWidth() * this._ratioOrDimensions, height: engine.getRenderHeight() * this._ratioOrDimensions };
            this._multiRenderTarget.resize(dimensions2);
          }
        });
        const renderSubMesh = (subMesh) => {
          const renderingMesh = subMesh.getRenderingMesh();
          const effectiveMesh = subMesh.getEffectiveMesh();
          const scene = this._scene;
          const engine2 = scene.getEngine();
          const material = subMesh.getMaterial();
          if (!material) {
            return;
          }
          effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
          if ((this._enableVelocity || this._enableVelocityLinear) && !this._previousTransformationMatrices[effectiveMesh.uniqueId]) {
            this._previousTransformationMatrices[effectiveMesh.uniqueId] = {
              world: Matrix.Identity(),
              viewProjection: scene.getTransformMatrix()
            };
            if (renderingMesh.skeleton) {
              const bonesTransformations = renderingMesh.skeleton.getTransformMatrices(renderingMesh);
              this._previousBonesTransformationMatrices[renderingMesh.uniqueId] = this._copyBonesTransformationMatrices(bonesTransformations, new Float32Array(bonesTransformations.length));
            }
          }
          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
          if (batch.mustReturn) {
            return;
          }
          const hardwareInstancedRendering = engine2.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);
          const world = effectiveMesh.getWorldMatrix();
          if (this.isReady(subMesh, hardwareInstancedRendering)) {
            const drawWrapper = subMesh._getDrawWrapper();
            if (!drawWrapper) {
              return;
            }
            const effect = drawWrapper.effect;
            engine2.enableEffect(drawWrapper);
            if (!hardwareInstancedRendering) {
              renderingMesh._bind(subMesh, effect, material.fillMode);
            }
            if (!this._useUbo) {
              effect.setMatrix("viewProjection", scene.getTransformMatrix());
              effect.setMatrix("view", scene.getViewMatrix());
            } else {
              BindSceneUniformBuffer(effect, this._scene.getSceneUniformBuffer());
              this._scene.finalizeSceneUbo();
            }
            let sideOrientation;
            const instanceDataStorage = renderingMesh._instanceDataStorage;
            if (!instanceDataStorage.isFrozen && (material.backFaceCulling || material.sideOrientation !== null)) {
              const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();
              sideOrientation = material._getEffectiveOrientation(renderingMesh);
              if (mainDeterminant < 0) {
                sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
              }
            } else {
              sideOrientation = renderingMesh._effectiveSideOrientation;
            }
            material._preBind(drawWrapper, sideOrientation);
            if (material.needAlphaTestingForMesh(effectiveMesh)) {
              const alphaTexture = material.getAlphaTestTexture();
              if (alphaTexture) {
                effect.setTexture("diffuseSampler", alphaTexture);
                effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
              }
            }
            if ((material.bumpTexture || material.normalTexture || material.geometryNormalTexture) && scene.getEngine().getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled) {
              const texture = material.bumpTexture || material.normalTexture || material.geometryNormalTexture;
              effect.setFloat3("vBumpInfos", texture.coordinatesIndex, 1 / texture.level, material.parallaxScaleBias);
              effect.setMatrix("bumpMatrix", texture.getTextureMatrix());
              effect.setTexture("bumpSampler", texture);
              effect.setFloat2("vTangentSpaceParams", material.invertNormalMapX ? -1 : 1, material.invertNormalMapY ? -1 : 1);
            }
            if (this._enableReflectivity) {
              if (material.getClassName() === "PBRMetallicRoughnessMaterial") {
                if (material.metallicRoughnessTexture !== null) {
                  effect.setTexture("reflectivitySampler", material.metallicRoughnessTexture);
                  effect.setMatrix("reflectivityMatrix", material.metallicRoughnessTexture.getTextureMatrix());
                }
                if (material.metallic !== null) {
                  effect.setFloat("metallic", material.metallic);
                }
                if (material.roughness !== null) {
                  effect.setFloat("glossiness", 1 - material.roughness);
                }
                if (material.baseTexture !== null) {
                  effect.setTexture("albedoSampler", material.baseTexture);
                  effect.setMatrix("albedoMatrix", material.baseTexture.getTextureMatrix());
                }
                if (material.baseColor !== null) {
                  effect.setColor3("albedoColor", material.baseColor);
                }
              } else if (material.getClassName() === "PBRSpecularGlossinessMaterial") {
                if (material.specularGlossinessTexture !== null) {
                  effect.setTexture("reflectivitySampler", material.specularGlossinessTexture);
                  effect.setMatrix("reflectivityMatrix", material.specularGlossinessTexture.getTextureMatrix());
                } else {
                  if (material.specularColor !== null) {
                    effect.setColor3("reflectivityColor", material.specularColor);
                  }
                }
                if (material.glossiness !== null) {
                  effect.setFloat("glossiness", material.glossiness);
                }
              } else if (material.getClassName() === "PBRMaterial") {
                if (material.metallicTexture !== null) {
                  effect.setTexture("reflectivitySampler", material.metallicTexture);
                  effect.setMatrix("reflectivityMatrix", material.metallicTexture.getTextureMatrix());
                }
                if (material.metallic !== null) {
                  effect.setFloat("metallic", material.metallic);
                }
                if (material.roughness !== null) {
                  effect.setFloat("glossiness", 1 - material.roughness);
                }
                if (material.roughness !== null || material.metallic !== null || material.metallicTexture !== null) {
                  if (material.albedoTexture !== null) {
                    effect.setTexture("albedoSampler", material.albedoTexture);
                    effect.setMatrix("albedoMatrix", material.albedoTexture.getTextureMatrix());
                  }
                  if (material.albedoColor !== null) {
                    effect.setColor3("albedoColor", material.albedoColor);
                  }
                } else {
                  if (material.reflectivityTexture !== null) {
                    effect.setTexture("reflectivitySampler", material.reflectivityTexture);
                    effect.setMatrix("reflectivityMatrix", material.reflectivityTexture.getTextureMatrix());
                  } else if (material.reflectivityColor !== null) {
                    effect.setColor3("reflectivityColor", material.reflectivityColor);
                  }
                  if (material.microSurface !== null) {
                    effect.setFloat("glossiness", material.microSurface);
                  }
                }
              } else if (material.getClassName() === "StandardMaterial") {
                if (material.specularTexture !== null) {
                  effect.setTexture("reflectivitySampler", material.specularTexture);
                  effect.setMatrix("reflectivityMatrix", material.specularTexture.getTextureMatrix());
                }
                if (material.specularColor !== null) {
                  effect.setColor3("reflectivityColor", material.specularColor);
                }
              } else if (material.getClassName() === "OpenPBRMaterial") {
                const openpbrMaterial = material;
                if (openpbrMaterial._useRoughnessFromMetallicTextureGreen && openpbrMaterial.baseMetalnessTexture) {
                  effect.setTexture("reflectivitySampler", openpbrMaterial.baseMetalnessTexture);
                  effect.setMatrix("reflectivityMatrix", openpbrMaterial.baseMetalnessTexture.getTextureMatrix());
                } else if (openpbrMaterial.baseMetalnessTexture) {
                  effect.setTexture("metallicSampler", openpbrMaterial.baseMetalnessTexture);
                  effect.setMatrix("metallicMatrix", openpbrMaterial.baseMetalnessTexture.getTextureMatrix());
                } else if (openpbrMaterial.specularRoughnessTexture) {
                  effect.setTexture("roughnessSampler", openpbrMaterial.specularRoughnessTexture);
                  effect.setMatrix("roughnessMatrix", openpbrMaterial.specularRoughnessTexture.getTextureMatrix());
                }
                effect.setFloat("metallic", openpbrMaterial.baseMetalness);
                effect.setFloat("glossiness", 1 - openpbrMaterial.specularRoughness);
                if (openpbrMaterial.baseColorTexture !== null) {
                  effect.setTexture("albedoSampler", openpbrMaterial.baseColorTexture);
                  effect.setMatrix("albedoMatrix", openpbrMaterial.baseColorTexture.getTextureMatrix());
                }
                if (openpbrMaterial.baseColor !== null) {
                  effect.setColor3("albedoColor", openpbrMaterial.baseColor);
                }
              }
            }
            BindClipPlane(effect, material, this._scene);
            if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
              const skeleton = renderingMesh.skeleton;
              if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex("boneTextureWidth") > -1) {
                const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);
                effect.setTexture("boneSampler", boneTexture);
                effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
              } else {
                effect.setMatrices("mBones", renderingMesh.skeleton.getTransformMatrices(renderingMesh));
              }
              if (this._enableVelocity || this._enableVelocityLinear) {
                effect.setMatrices("mPreviousBones", this._previousBonesTransformationMatrices[renderingMesh.uniqueId]);
              }
            }
            BindMorphTargetParameters(renderingMesh, effect);
            if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
              renderingMesh.morphTargetManager._bind(effect);
            }
            if (this._enableVelocity || this._enableVelocityLinear) {
              effect.setMatrix("previousWorld", this._previousTransformationMatrices[effectiveMesh.uniqueId].world);
              effect.setMatrix("previousViewProjection", this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection);
            }
            if (hardwareInstancedRendering && renderingMesh.hasThinInstances) {
              effect.setMatrix("world", world);
            }
            renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, w) => {
              if (!isInstance) {
                effect.setMatrix("world", w);
              }
            });
          }
          if (this._enableVelocity || this._enableVelocityLinear) {
            this._previousTransformationMatrices[effectiveMesh.uniqueId].world = world.clone();
            this._previousTransformationMatrices[effectiveMesh.uniqueId].viewProjection = this._scene.getTransformMatrix().clone();
            if (renderingMesh.skeleton) {
              this._copyBonesTransformationMatrices(renderingMesh.skeleton.getTransformMatrices(renderingMesh), this._previousBonesTransformationMatrices[effectiveMesh.uniqueId]);
            }
          }
        };
        this._multiRenderTarget.customIsReadyFunction = (mesh, refreshRate, preWarm) => {
          if ((preWarm || refreshRate === 0) && mesh.subMeshes) {
            for (let i = 0; i < mesh.subMeshes.length; ++i) {
              const subMesh = mesh.subMeshes[i];
              const material = subMesh.getMaterial();
              const renderingMesh = subMesh.getRenderingMesh();
              if (!material) {
                continue;
              }
              const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
              const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);
              if (!this.isReady(subMesh, hardwareInstancedRendering)) {
                return false;
              }
            }
          }
          return true;
        };
        this._multiRenderTarget.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {
          let index;
          if (this._linkedWithPrePass) {
            if (!this._prePassRenderer.enabled) {
              return;
            }
            this._scene.getEngine().bindAttachments(this._attachmentsFromPrePass);
          }
          if (depthOnlySubMeshes.length) {
            engine.setColorWrite(false);
            for (index = 0; index < depthOnlySubMeshes.length; index++) {
              renderSubMesh(depthOnlySubMeshes.data[index]);
            }
            engine.setColorWrite(true);
          }
          for (index = 0; index < opaqueSubMeshes.length; index++) {
            renderSubMesh(opaqueSubMeshes.data[index]);
          }
          engine.setDepthWrite(false);
          for (index = 0; index < alphaTestSubMeshes.length; index++) {
            renderSubMesh(alphaTestSubMeshes.data[index]);
          }
          if (this.renderTransparentMeshes) {
            for (index = 0; index < transparentSubMeshes.length; index++) {
              renderSubMesh(transparentSubMeshes.data[index]);
            }
          }
          engine.setDepthWrite(true);
        };
      }
      // Copies the bones transformation matrices into the target array and returns the target's reference
      _copyBonesTransformationMatrices(source, target) {
        for (let i = 0; i < source.length; i++) {
          target[i] = source[i];
        }
        return target;
      }
    };
    GeometryBufferRenderer.ForceGLSL = false;
    GeometryBufferRenderer.DEPTH_TEXTURE_TYPE = 0;
    GeometryBufferRenderer.NORMAL_TEXTURE_TYPE = 1;
    GeometryBufferRenderer.POSITION_TEXTURE_TYPE = 2;
    GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE = 3;
    GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE = 4;
    GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE = 5;
    GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE = 6;
    GeometryBufferRenderer._SceneComponentInitialization = (_) => {
      throw _WarnImport("GeometryBufferRendererSceneComponent");
    };
  }
});

// node_modules/@babylonjs/core/Rendering/geometryBufferRendererSceneComponent.js
var GeometryBufferRendererSceneComponent;
var init_geometryBufferRendererSceneComponent = __esm({
  "node_modules/@babylonjs/core/Rendering/geometryBufferRendererSceneComponent.js"() {
    init_scene();
    init_sceneComponent();
    init_geometryBufferRenderer();
    Object.defineProperty(Scene.prototype, "geometryBufferRenderer", {
      get: function() {
        return this._geometryBufferRenderer;
      },
      set: function(value) {
        if (value && value.isSupported) {
          this._geometryBufferRenderer = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Scene.prototype.enableGeometryBufferRenderer = function(ratio = 1, depthFormat = 15, textureTypesAndFormats) {
      if (this._geometryBufferRenderer) {
        return this._geometryBufferRenderer;
      }
      this._geometryBufferRenderer = new GeometryBufferRenderer(this, ratio, depthFormat, textureTypesAndFormats);
      if (!this._geometryBufferRenderer.isSupported) {
        this._geometryBufferRenderer = null;
      }
      return this._geometryBufferRenderer;
    };
    Scene.prototype.disableGeometryBufferRenderer = function() {
      if (!this._geometryBufferRenderer) {
        return;
      }
      this._geometryBufferRenderer.dispose();
      this._geometryBufferRenderer = null;
    };
    GeometryBufferRendererSceneComponent = class {
      /**
       * Creates a new instance of the component for the given scene
       * @param scene Defines the scene to register the component in
       */
      constructor(scene) {
        this.name = SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER;
        this.scene = scene;
      }
      /**
       * Registers the component in a given scene
       */
      register() {
        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER, this, this._gatherRenderTargets);
      }
      /**
       * Rebuilds the elements related to this component in case of
       * context lost for instance.
       */
      rebuild() {
      }
      /**
       * Disposes the component and the associated resources
       */
      dispose() {
      }
      _gatherRenderTargets(renderTargets) {
        if (this.scene._geometryBufferRenderer) {
          renderTargets.push(this.scene._geometryBufferRenderer.getGBuffer());
        }
      }
    };
    GeometryBufferRenderer._SceneComponentInitialization = (scene) => {
      let component = scene._getComponent(SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER);
      if (!component) {
        component = new GeometryBufferRendererSceneComponent(scene);
        scene._addComponent(component);
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/sharpenPostProcess.js
var SharpenPostProcess;
var init_sharpenPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/sharpenPostProcess.js"() {
    init_tslib_es6();
    init_postProcess();
    init_sharpen_fragment();
    init_typeStore();
    init_decorators();
    init_decorators_serialization();
    init_thinSharpenPostProcess();
    SharpenPostProcess = class _SharpenPostProcess extends PostProcess {
      /**
       * How much of the original color should be applied. Setting this to 0 will display edge detection. (default: 1)
       */
      get colorAmount() {
        return this._effectWrapper.colorAmount;
      }
      set colorAmount(value) {
        this._effectWrapper.colorAmount = value;
      }
      /**
       * How much sharpness should be applied (default: 0.3)
       */
      get edgeAmount() {
        return this._effectWrapper.edgeAmount;
      }
      set edgeAmount(value) {
        this._effectWrapper.edgeAmount = value;
      }
      /**
       * Gets a string identifying the name of the class
       * @returns "SharpenPostProcess" string
       */
      getClassName() {
        return "SharpenPostProcess";
      }
      /**
       * Creates a new instance ConvolutionPostProcess
       * @param name The name of the effect.
       * @param options The required width/height ratio to downsize to before computing the render pass.
       * @param camera The camera to apply the render pass to.
       * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
       * @param engine The engine which the post process will be applied. (default: current engine)
       * @param reusable If the post process can be reused on the same frame. (default: false)
       * @param textureType Type of textures used when performing the post process. (default: 0)
       * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
       */
      constructor(name13, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
        const localOptions = {
          uniforms: ThinSharpenPostProcess.Uniforms,
          size: typeof options === "number" ? options : void 0,
          camera,
          samplingMode,
          engine,
          reusable,
          textureType,
          blockCompilation,
          ...options
        };
        super(name13, ThinSharpenPostProcess.FragmentUrl, {
          effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinSharpenPostProcess(name13, engine, localOptions) : void 0,
          ...localOptions
        });
        this.onApply = (_effect) => {
          this._effectWrapper.textureWidth = this.width;
          this._effectWrapper.textureHeight = this.height;
        };
      }
      /**
       * @internal
       */
      static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
        return SerializationHelper.Parse(() => {
          return new _SharpenPostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.textureType, parsedPostProcess.reusable);
        }, parsedPostProcess, scene, rootUrl);
      }
    };
    __decorate([
      serialize()
    ], SharpenPostProcess.prototype, "colorAmount", null);
    __decorate([
      serialize()
    ], SharpenPostProcess.prototype, "edgeAmount", null);
    RegisterClass("BABYLON.SharpenPostProcess", SharpenPostProcess);
  }
});

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipeline.js
var PostProcessRenderPipeline;
var init_postProcessRenderPipeline = __esm({
  "node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipeline.js"() {
    init_tslib_es6();
    init_tools();
    init_decorators();
    init_uniqueIdGenerator();
    PostProcessRenderPipeline = class {
      /**
       * Gets pipeline name
       */
      get name() {
        return this._name;
      }
      /** Gets the list of attached cameras */
      get cameras() {
        return this._cameras;
      }
      /**
       * Gets the active engine
       */
      get engine() {
        return this._engine;
      }
      /**
       * Initializes a PostProcessRenderPipeline
       * @param _engine engine to add the pipeline to
       * @param name name of the pipeline
       */
      constructor(_engine, name13) {
        this._engine = _engine;
        this.uniqueId = UniqueIdGenerator.UniqueId;
        this._name = name13;
        this._renderEffects = {};
        this._renderEffectsForIsolatedPass = new Array();
        this._cameras = [];
      }
      /**
       * Gets the class name
       * @returns "PostProcessRenderPipeline"
       */
      getClassName() {
        return "PostProcessRenderPipeline";
      }
      /**
       * If all the render effects in the pipeline are supported
       */
      get isSupported() {
        for (const renderEffectName in this._renderEffects) {
          if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {
            if (!this._renderEffects[renderEffectName].isSupported) {
              return false;
            }
          }
        }
        return true;
      }
      /**
       * Adds an effect to the pipeline
       * @param renderEffect the effect to add
       */
      addEffect(renderEffect) {
        this._renderEffects[renderEffect._name] = renderEffect;
      }
      // private
      /** @internal */
      _rebuild() {
      }
      /**
       * @internal
       */
      _enableEffect(renderEffectName, cameras) {
        const renderEffects = this._renderEffects[renderEffectName];
        if (!renderEffects) {
          return;
        }
        renderEffects._enable(Tools.MakeArray(cameras || this._cameras));
      }
      /**
       * @internal
       */
      _disableEffect(renderEffectName, cameras) {
        const renderEffects = this._renderEffects[renderEffectName];
        if (!renderEffects) {
          return;
        }
        renderEffects._disable(Tools.MakeArray(cameras || this._cameras));
      }
      /**
       * @internal
       */
      _attachCameras(cameras, unique) {
        const cams = Tools.MakeArray(cameras || this._cameras);
        if (!cams) {
          return;
        }
        const indicesToDelete = [];
        let i;
        for (i = 0; i < cams.length; i++) {
          const camera = cams[i];
          if (!camera) {
            continue;
          }
          if (this._cameras.indexOf(camera) === -1) {
            this._cameras.push(camera);
          } else if (unique) {
            indicesToDelete.push(i);
          }
        }
        for (i = 0; i < indicesToDelete.length; i++) {
          cams.splice(indicesToDelete[i], 1);
        }
        for (const renderEffectName in this._renderEffects) {
          if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {
            this._renderEffects[renderEffectName]._attachCameras(cams);
          }
        }
      }
      /**
       * @internal
       */
      _detachCameras(cameras) {
        const cams = Tools.MakeArray(cameras || this._cameras);
        if (!cams) {
          return;
        }
        for (const renderEffectName in this._renderEffects) {
          if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {
            this._renderEffects[renderEffectName]._detachCameras(cams);
          }
        }
        for (let i = 0; i < cams.length; i++) {
          this._cameras.splice(this._cameras.indexOf(cams[i]), 1);
        }
      }
      /** @internal */
      _update() {
        for (const renderEffectName in this._renderEffects) {
          if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {
            this._renderEffects[renderEffectName]._update();
          }
        }
        for (let i = 0; i < this._cameras.length; i++) {
          if (!this._cameras[i]) {
            continue;
          }
          const cameraName = this._cameras[i].name;
          if (this._renderEffectsForIsolatedPass[cameraName]) {
            this._renderEffectsForIsolatedPass[cameraName]._update();
          }
        }
      }
      /** @internal */
      _reset() {
        this._renderEffects = {};
        this._renderEffectsForIsolatedPass = new Array();
      }
      _enableMSAAOnFirstPostProcess(sampleCount) {
        if (!this._engine._features.supportMSAA) {
          return false;
        }
        const effectKeys = Object.keys(this._renderEffects);
        if (effectKeys.length > 0) {
          const postProcesses = this._renderEffects[effectKeys[0]].getPostProcesses();
          if (postProcesses) {
            postProcesses[0].samples = sampleCount;
          }
        }
        return true;
      }
      /**
       * Ensures that all post processes in the pipeline are the correct size according to the
       * the viewport's required size
       */
      _adaptPostProcessesToViewPort() {
        const effectKeys = Object.keys(this._renderEffects);
        for (const effectKey of effectKeys) {
          const postProcesses = this._renderEffects[effectKey].getPostProcesses();
          if (postProcesses) {
            for (const postProcess of postProcesses) {
              postProcess.adaptScaleToCurrentViewport = true;
            }
          }
        }
      }
      /**
       * Sets the required values to the prepass renderer.
       * @param prePassRenderer defines the prepass renderer to setup.
       * @returns true if the pre pass is needed.
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      setPrePassRenderer(prePassRenderer) {
        return false;
      }
      /**
       * Disposes of the pipeline
       */
      dispose() {
      }
    };
    __decorate([
      serialize()
    ], PostProcessRenderPipeline.prototype, "_name", void 0);
  }
});

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipelineManager.js
var PostProcessRenderPipelineManager;
var init_postProcessRenderPipelineManager = __esm({
  "node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipelineManager.js"() {
    init_observable();
    PostProcessRenderPipelineManager = class {
      /**
       * Initializes a PostProcessRenderPipelineManager
       * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline
       */
      constructor() {
        this._renderPipelines = {};
        this._onNewPipelineAddedObservable = new Observable();
        this._onPipelineRemovedObservable = new Observable();
      }
      /**
       * An event triggered when a pipeline is added to the manager
       */
      get onNewPipelineAddedObservable() {
        return this._onNewPipelineAddedObservable;
      }
      /**
       * An event triggered when a pipeline is removed from the manager
       */
      get onPipelineRemovedObservable() {
        return this._onPipelineRemovedObservable;
      }
      /**
       * Gets the list of supported render pipelines
       */
      get supportedPipelines() {
        const result = [];
        for (const renderPipelineName in this._renderPipelines) {
          if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {
            const pipeline = this._renderPipelines[renderPipelineName];
            if (pipeline.isSupported) {
              result.push(pipeline);
            }
          }
        }
        return result;
      }
      /**
       * Adds a pipeline to the manager
       * @param renderPipeline The pipeline to add
       */
      addPipeline(renderPipeline) {
        this.removePipeline(renderPipeline._name);
        this._renderPipelines[renderPipeline._name] = renderPipeline;
        this._onNewPipelineAddedObservable.notifyObservers(renderPipeline);
      }
      /**
       * Remove the pipeline from the manager
       * @param renderPipelineName the name of the pipeline to remove
       */
      removePipeline(renderPipelineName) {
        const pipeline = this._renderPipelines[renderPipelineName];
        if (pipeline) {
          this._onPipelineRemovedObservable.notifyObservers(pipeline);
          delete this._renderPipelines[renderPipelineName];
        }
      }
      /**
       * Attaches a camera to the pipeline
       * @param renderPipelineName The name of the pipeline to attach to
       * @param cameras the camera to attach
       * @param unique if the camera can be attached multiple times to the pipeline
       */
      attachCamerasToRenderPipeline(renderPipelineName, cameras, unique = false) {
        const renderPipeline = this._renderPipelines[renderPipelineName];
        if (!renderPipeline) {
          return;
        }
        renderPipeline._attachCameras(cameras, unique);
      }
      /**
       * Detaches a camera from the pipeline
       * @param renderPipelineName The name of the pipeline to detach from
       * @param cameras the camera to detach
       */
      detachCamerasFromRenderPipeline(renderPipelineName, cameras) {
        const renderPipeline = this._renderPipelines[renderPipelineName];
        if (!renderPipeline) {
          return;
        }
        renderPipeline._detachCameras(cameras);
      }
      /**
       * Enables an effect by name on a pipeline
       * @param renderPipelineName the name of the pipeline to enable the effect in
       * @param renderEffectName the name of the effect to enable
       * @param cameras the cameras that the effect should be enabled on
       */
      enableEffectInPipeline(renderPipelineName, renderEffectName, cameras) {
        const renderPipeline = this._renderPipelines[renderPipelineName];
        if (!renderPipeline) {
          return;
        }
        renderPipeline._enableEffect(renderEffectName, cameras);
      }
      /**
       * Disables an effect by name on a pipeline
       * @param renderPipelineName the name of the pipeline to disable the effect in
       * @param renderEffectName the name of the effect to disable
       * @param cameras the cameras that the effect should be disabled on
       */
      disableEffectInPipeline(renderPipelineName, renderEffectName, cameras) {
        const renderPipeline = this._renderPipelines[renderPipelineName];
        if (!renderPipeline) {
          return;
        }
        renderPipeline._disableEffect(renderEffectName, cameras);
      }
      /**
       * Updates the state of all contained render pipelines and disposes of any non supported pipelines
       */
      update() {
        for (const renderPipelineName in this._renderPipelines) {
          if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {
            const pipeline = this._renderPipelines[renderPipelineName];
            if (!pipeline.isSupported) {
              pipeline.dispose();
              delete this._renderPipelines[renderPipelineName];
            } else {
              pipeline._update();
            }
          }
        }
      }
      /** @internal */
      _rebuild() {
        for (const renderPipelineName in this._renderPipelines) {
          if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {
            const pipeline = this._renderPipelines[renderPipelineName];
            pipeline._rebuild();
          }
        }
      }
      /**
       * Disposes of the manager and pipelines
       */
      dispose() {
        for (const renderPipelineName in this._renderPipelines) {
          if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {
            const pipeline = this._renderPipelines[renderPipelineName];
            pipeline.dispose();
          }
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent.js
var PostProcessRenderPipelineManagerSceneComponent;
var init_postProcessRenderPipelineManagerSceneComponent = __esm({
  "node_modules/@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent.js"() {
    init_sceneComponent();
    init_postProcessRenderPipelineManager();
    init_scene();
    Object.defineProperty(Scene.prototype, "postProcessRenderPipelineManager", {
      get: function() {
        if (!this._postProcessRenderPipelineManager) {
          let component = this._getComponent(SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER);
          if (!component) {
            component = new PostProcessRenderPipelineManagerSceneComponent(this);
            this._addComponent(component);
          }
          this._postProcessRenderPipelineManager = new PostProcessRenderPipelineManager();
        }
        return this._postProcessRenderPipelineManager;
      },
      enumerable: true,
      configurable: true
    });
    PostProcessRenderPipelineManagerSceneComponent = class {
      /**
       * Creates a new instance of the component for the given scene
       * @param scene Defines the scene to register the component in
       */
      constructor(scene) {
        this.name = SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER;
        this.scene = scene;
      }
      /**
       * Registers the component in a given scene
       */
      register() {
        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER, this, this._gatherRenderTargets);
      }
      /**
       * Rebuilds the elements related to this component in case of
       * context lost for instance.
       */
      rebuild() {
        if (this.scene._postProcessRenderPipelineManager) {
          this.scene._postProcessRenderPipelineManager._rebuild();
        }
      }
      /**
       * Disposes the component and the associated resources
       */
      dispose() {
        if (this.scene._postProcessRenderPipelineManager) {
          this.scene._postProcessRenderPipelineManager.dispose();
        }
      }
      _gatherRenderTargets() {
        if (this.scene._postProcessRenderPipelineManager) {
          this.scene._postProcessRenderPipelineManager.update();
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/defaultRenderingPipeline.js
var DefaultRenderingPipeline;
var init_defaultRenderingPipeline = __esm({
  "node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/defaultRenderingPipeline.js"() {
    init_tslib_es6();
    init_decorators();
    init_decorators_serialization();
    init_observable();
    init_logger();
    init_texture();
    init_glowLayer();
    init_sharpenPostProcess();
    init_imageProcessingPostProcess();
    init_chromaticAberrationPostProcess();
    init_grainPostProcess();
    init_fxaaPostProcess();
    init_postProcessRenderPipeline();
    init_postProcessRenderEffect();
    init_depthOfFieldEffect();
    init_bloomEffect();
    init_typeStore();
    init_engineStore();
    init_tools();
    init_postProcessRenderPipelineManagerSceneComponent();
    DefaultRenderingPipeline = class _DefaultRenderingPipeline extends PostProcessRenderPipeline {
      /**
       * Enable or disable automatic building of the pipeline when effects are enabled and disabled.
       * If false, you will have to manually call prepare() to update the pipeline.
       */
      get automaticBuild() {
        return this._buildAllowed;
      }
      set automaticBuild(value) {
        this._buildAllowed = value;
      }
      /**
       * Gets active scene
       */
      get scene() {
        return this._scene;
      }
      /**
       * Enable or disable the sharpen process from the pipeline
       */
      set sharpenEnabled(enabled) {
        if (this._sharpenEnabled === enabled) {
          return;
        }
        this._sharpenEnabled = enabled;
        this._buildPipeline();
      }
      get sharpenEnabled() {
        return this._sharpenEnabled;
      }
      /**
       * Specifies the size of the bloom blur kernel, relative to the final output size
       */
      get bloomKernel() {
        return this._bloomKernel;
      }
      set bloomKernel(value) {
        this._bloomKernel = value;
        this.bloom.kernel = value / this._hardwareScaleLevel;
      }
      /**
       * The strength of the bloom.
       */
      set bloomWeight(value) {
        if (this._bloomWeight === value) {
          return;
        }
        this.bloom.weight = value;
        this._bloomWeight = value;
      }
      get bloomWeight() {
        return this._bloomWeight;
      }
      /**
       * The luminance threshold to find bright areas of the image to bloom.
       */
      set bloomThreshold(value) {
        if (this._bloomThreshold === value) {
          return;
        }
        this.bloom.threshold = value;
        this._bloomThreshold = value;
      }
      get bloomThreshold() {
        return this._bloomThreshold;
      }
      /**
       * The scale of the bloom, lower value will provide better performance.
       */
      set bloomScale(value) {
        if (this._bloomScale === value) {
          return;
        }
        this._bloomScale = value;
        this._rebuildBloom();
        this._buildPipeline();
      }
      get bloomScale() {
        return this._bloomScale;
      }
      /**
       * Enable or disable the bloom from the pipeline
       */
      set bloomEnabled(enabled) {
        if (this._bloomEnabled === enabled) {
          return;
        }
        this._bloomEnabled = enabled;
        this._buildPipeline();
      }
      get bloomEnabled() {
        return this._bloomEnabled;
      }
      _rebuildBloom() {
        const oldBloom = this.bloom;
        this.bloom = new BloomEffect(this._scene, this.bloomScale, this._bloomWeight, this.bloomKernel / this._hardwareScaleLevel, this._defaultPipelineTextureType, false);
        this.bloom.threshold = oldBloom.threshold;
        for (let i = 0; i < this._cameras.length; i++) {
          oldBloom.disposeEffects(this._cameras[i]);
        }
      }
      /**
       * If the depth of field is enabled.
       */
      get depthOfFieldEnabled() {
        return this._depthOfFieldEnabled;
      }
      set depthOfFieldEnabled(enabled) {
        if (this._depthOfFieldEnabled === enabled) {
          return;
        }
        this._depthOfFieldEnabled = enabled;
        this._buildPipeline();
      }
      /**
       * Blur level of the depth of field effect. (Higher blur will effect performance)
       */
      get depthOfFieldBlurLevel() {
        return this._depthOfFieldBlurLevel;
      }
      set depthOfFieldBlurLevel(value) {
        if (this._depthOfFieldBlurLevel === value) {
          return;
        }
        this._depthOfFieldBlurLevel = value;
        const oldDof = this.depthOfField;
        this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, false);
        this.depthOfField.focalLength = oldDof.focalLength;
        this.depthOfField.focusDistance = oldDof.focusDistance;
        this.depthOfField.fStop = oldDof.fStop;
        this.depthOfField.lensSize = oldDof.lensSize;
        for (let i = 0; i < this._cameras.length; i++) {
          oldDof.disposeEffects(this._cameras[i]);
        }
        this._buildPipeline();
      }
      /**
       * If the anti aliasing is enabled.
       */
      set fxaaEnabled(enabled) {
        if (this._fxaaEnabled === enabled) {
          return;
        }
        this._fxaaEnabled = enabled;
        this._buildPipeline();
      }
      get fxaaEnabled() {
        return this._fxaaEnabled;
      }
      /**
       * MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)
       */
      set samples(sampleCount) {
        if (this._samples === sampleCount) {
          return;
        }
        this._samples = sampleCount;
        this._buildPipeline();
      }
      get samples() {
        return this._samples;
      }
      /**
       * If image processing is enabled.
       */
      set imageProcessingEnabled(enabled) {
        if (this._imageProcessingEnabled === enabled) {
          return;
        }
        this._scene.imageProcessingConfiguration.isEnabled = enabled;
      }
      get imageProcessingEnabled() {
        return this._imageProcessingEnabled;
      }
      /**
       * If glow layer is enabled. (Adds a glow effect to emmissive materials)
       */
      set glowLayerEnabled(enabled) {
        if (enabled && !this._glowLayer) {
          this._glowLayer = new GlowLayer("", this._scene);
        } else if (!enabled && this._glowLayer) {
          this._glowLayer.dispose();
          this._glowLayer = null;
        }
      }
      get glowLayerEnabled() {
        return this._glowLayer != null;
      }
      /**
       * Gets the glow layer (or null if not defined)
       */
      get glowLayer() {
        return this._glowLayer;
      }
      /**
       * Enable or disable the chromaticAberration process from the pipeline
       */
      set chromaticAberrationEnabled(enabled) {
        if (this._chromaticAberrationEnabled === enabled) {
          return;
        }
        this._chromaticAberrationEnabled = enabled;
        this._buildPipeline();
      }
      get chromaticAberrationEnabled() {
        return this._chromaticAberrationEnabled;
      }
      /**
       * Enable or disable the grain process from the pipeline
       */
      set grainEnabled(enabled) {
        if (this._grainEnabled === enabled) {
          return;
        }
        this._grainEnabled = enabled;
        this._buildPipeline();
      }
      get grainEnabled() {
        return this._grainEnabled;
      }
      /**
       * Instantiates a DefaultRenderingPipeline.
       * @param name The rendering pipeline name (default: "")
       * @param hdr If high dynamic range textures should be used (default: true)
       * @param scene The scene linked to this pipeline (default: the last created scene)
       * @param cameras The array of cameras that the rendering pipeline will be attached to (default: scene.cameras)
       * @param automaticBuild If false, you will have to manually call prepare() to update the pipeline (default: true)
       */
      constructor(name13 = "", hdr = true, scene = EngineStore.LastCreatedScene, cameras, automaticBuild = true) {
        super(scene.getEngine(), name13);
        this._camerasToBeAttached = [];
        this.SharpenPostProcessId = "SharpenPostProcessEffect";
        this.ImageProcessingPostProcessId = "ImageProcessingPostProcessEffect";
        this.FxaaPostProcessId = "FxaaPostProcessEffect";
        this.ChromaticAberrationPostProcessId = "ChromaticAberrationPostProcessEffect";
        this.GrainPostProcessId = "GrainPostProcessEffect";
        this._glowLayer = null;
        this.animations = [];
        this._imageProcessingConfigurationObserver = null;
        this._sharpenEnabled = false;
        this._bloomEnabled = false;
        this._depthOfFieldEnabled = false;
        this._depthOfFieldBlurLevel = 0;
        this._fxaaEnabled = false;
        this._imageProcessingEnabled = true;
        this._bloomScale = 0.5;
        this._chromaticAberrationEnabled = false;
        this._grainEnabled = false;
        this._buildAllowed = true;
        this.onBuildObservable = new Observable();
        this._resizeObserver = null;
        this._hardwareScaleLevel = 1;
        this._bloomKernel = 64;
        this._bloomWeight = 0.15;
        this._bloomThreshold = 0.9;
        this._samples = 1;
        this._hasCleared = false;
        this._prevPostProcess = null;
        this._prevPrevPostProcess = null;
        this._depthOfFieldSceneObserver = null;
        this._activeCameraChangedObserver = null;
        this._activeCamerasChangedObserver = null;
        this._cameras = cameras || scene.cameras;
        this._cameras = this._cameras.slice();
        this._camerasToBeAttached = this._cameras.slice();
        this._buildAllowed = automaticBuild;
        this._scene = scene;
        const caps = this._scene.getEngine().getCaps();
        this._hdr = hdr && (caps.textureHalfFloatRender || caps.textureFloatRender);
        if (this._hdr) {
          if (caps.textureHalfFloatRender) {
            this._defaultPipelineTextureType = 2;
          } else if (caps.textureFloatRender) {
            this._defaultPipelineTextureType = 1;
          }
        } else {
          this._defaultPipelineTextureType = 0;
        }
        scene.postProcessRenderPipelineManager.addPipeline(this);
        const engine = this._scene.getEngine();
        this.sharpen = new SharpenPostProcess("sharpen", 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);
        this._sharpenEffect = new PostProcessRenderEffect(engine, this.SharpenPostProcessId, () => {
          return this.sharpen;
        }, true);
        this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, true);
        this._hardwareScaleLevel = engine.getHardwareScalingLevel();
        this._resizeObserver = engine.onResizeObservable.add(() => {
          this._hardwareScaleLevel = engine.getHardwareScalingLevel();
          this.bloomKernel = this._bloomKernel;
        });
        this.bloom = new BloomEffect(this._scene, this._bloomScale, this._bloomWeight, this.bloomKernel / this._hardwareScaleLevel, this._defaultPipelineTextureType, true);
        this.chromaticAberration = new ChromaticAberrationPostProcess("ChromaticAberration", engine.getRenderWidth(), engine.getRenderHeight(), 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);
        this._chromaticAberrationEffect = new PostProcessRenderEffect(engine, this.ChromaticAberrationPostProcessId, () => {
          return this.chromaticAberration;
        }, true);
        this.grain = new GrainPostProcess("Grain", 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);
        this._grainEffect = new PostProcessRenderEffect(engine, this.GrainPostProcessId, () => {
          return this.grain;
        }, true);
        let avoidReentrancyAtConstructionTime = true;
        this._imageProcessingConfigurationObserver = this._scene.imageProcessingConfiguration.onUpdateParameters.add(() => {
          this.bloom._downscale._exposure = this._scene.imageProcessingConfiguration.exposure;
          if (this.imageProcessingEnabled !== this._scene.imageProcessingConfiguration.isEnabled) {
            this._imageProcessingEnabled = this._scene.imageProcessingConfiguration.isEnabled;
            if (avoidReentrancyAtConstructionTime) {
              Tools.SetImmediate(() => {
                this._buildPipeline();
              });
            } else {
              this._buildPipeline();
            }
          }
        });
        this._buildPipeline();
        avoidReentrancyAtConstructionTime = false;
      }
      /**
       * Get the class name
       * @returns "DefaultRenderingPipeline"
       */
      getClassName() {
        return "DefaultRenderingPipeline";
      }
      /**
       * Force the compilation of the entire pipeline.
       */
      prepare() {
        const previousState = this._buildAllowed;
        this._buildAllowed = true;
        this._buildPipeline();
        this._buildAllowed = previousState;
      }
      _setAutoClearAndTextureSharing(postProcess, skipTextureSharing = false) {
        if (this._hasCleared) {
          postProcess.autoClear = false;
        } else {
          postProcess.autoClear = true;
          this._scene.autoClear = false;
          this._hasCleared = true;
        }
        if (!skipTextureSharing) {
          if (this._prevPrevPostProcess) {
            postProcess.shareOutputWith(this._prevPrevPostProcess);
          } else {
            postProcess.useOwnOutput();
          }
          if (this._prevPostProcess) {
            this._prevPrevPostProcess = this._prevPostProcess;
          }
          this._prevPostProcess = postProcess;
        }
      }
      _buildPipeline() {
        if (!this._buildAllowed) {
          return;
        }
        this._scene.autoClear = true;
        const engine = this._scene.getEngine();
        this._disposePostProcesses();
        if (this._cameras !== null) {
          this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);
          this._cameras = this._camerasToBeAttached.slice();
        }
        this._reset();
        this._prevPostProcess = null;
        this._prevPrevPostProcess = null;
        this._hasCleared = false;
        if (this.depthOfFieldEnabled) {
          if (this._cameras.length > 1) {
            for (const camera of this._cameras) {
              const depthRenderer = this._scene.enableDepthRenderer(camera);
              depthRenderer.useOnlyInActiveCamera = true;
            }
            this._depthOfFieldSceneObserver = this._scene.onAfterRenderTargetsRenderObservable.add((scene) => {
              if (this._cameras.indexOf(scene.activeCamera) > -1) {
                this.depthOfField.depthTexture = scene.enableDepthRenderer(scene.activeCamera).getDepthMap();
              }
            });
          } else {
            this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);
            const depthRenderer = this._scene.enableDepthRenderer(this._cameras[0]);
            this.depthOfField.depthTexture = depthRenderer.getDepthMap();
          }
          if (!this.depthOfField._isReady()) {
            this.depthOfField._updateEffects();
          }
          this.addEffect(this.depthOfField);
          this._setAutoClearAndTextureSharing(this.depthOfField._effects[0], true);
        } else {
          this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);
        }
        if (this.bloomEnabled) {
          if (!this.bloom._isReady()) {
            this.bloom._updateEffects();
          }
          this.addEffect(this.bloom);
          this._setAutoClearAndTextureSharing(this.bloom._effects[0], true);
        }
        if (this._imageProcessingEnabled) {
          this.imageProcessing = new ImageProcessingPostProcess("imageProcessing", 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, this.scene.imageProcessingConfiguration);
          if (this._hdr) {
            this.addEffect(new PostProcessRenderEffect(engine, this.ImageProcessingPostProcessId, () => {
              return this.imageProcessing;
            }, true));
            this._setAutoClearAndTextureSharing(this.imageProcessing);
          } else {
            this._scene.imageProcessingConfiguration.applyByPostProcess = false;
          }
          if (!this._cameras || this._cameras.length === 0) {
            this._scene.imageProcessingConfiguration.applyByPostProcess = false;
          }
          if (!this.imageProcessing.getEffect()) {
            this.imageProcessing._updateParameters();
          }
        }
        if (this.sharpenEnabled) {
          if (!this.sharpen.isReady()) {
            this.sharpen.updateEffect();
          }
          this.addEffect(this._sharpenEffect);
          this._setAutoClearAndTextureSharing(this.sharpen);
        }
        if (this.grainEnabled) {
          if (!this.grain.isReady()) {
            this.grain.updateEffect();
          }
          this.addEffect(this._grainEffect);
          this._setAutoClearAndTextureSharing(this.grain);
        }
        if (this.chromaticAberrationEnabled) {
          if (!this.chromaticAberration.isReady()) {
            this.chromaticAberration.updateEffect();
          }
          this.addEffect(this._chromaticAberrationEffect);
          this._setAutoClearAndTextureSharing(this.chromaticAberration);
        }
        if (this.fxaaEnabled) {
          this.fxaa = new FxaaPostProcess("fxaa", 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);
          this.addEffect(new PostProcessRenderEffect(engine, this.FxaaPostProcessId, () => {
            return this.fxaa;
          }, true));
          this._setAutoClearAndTextureSharing(this.fxaa, true);
        }
        if (this._cameras !== null) {
          this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);
        }
        if (this._scene.activeCameras && this._scene.activeCameras.length > 1 || this._scene.activeCamera && this._cameras.indexOf(this._scene.activeCamera) === -1) {
          this._scene.autoClear = true;
        }
        if (!this._activeCameraChangedObserver) {
          this._activeCameraChangedObserver = this._scene.onActiveCameraChanged.add(() => {
            if (this._scene.activeCamera && this._cameras.indexOf(this._scene.activeCamera) === -1) {
              this._scene.autoClear = true;
            }
          });
        }
        if (!this._activeCamerasChangedObserver) {
          this._activeCamerasChangedObserver = this._scene.onActiveCamerasChanged.add(() => {
            if (this._scene.activeCameras && this._scene.activeCameras.length > 1) {
              this._scene.autoClear = true;
            }
          });
        }
        this._adaptPostProcessesToViewPort();
        if (!this._enableMSAAOnFirstPostProcess(this.samples) && this.samples > 1) {
          Logger.Warn("MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0");
        }
        this.onBuildObservable.notifyObservers(this);
      }
      _disposePostProcesses(disposeNonRecreated = false) {
        for (let i = 0; i < this._cameras.length; i++) {
          const camera = this._cameras[i];
          if (this.imageProcessing) {
            this.imageProcessing.dispose(camera);
          }
          if (this.fxaa) {
            this.fxaa.dispose(camera);
          }
          if (disposeNonRecreated) {
            if (this.sharpen) {
              this.sharpen.dispose(camera);
            }
            if (this.depthOfField) {
              this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);
              this.depthOfField.disposeEffects(camera);
            }
            if (this.bloom) {
              this.bloom.disposeEffects(camera);
            }
            if (this.chromaticAberration) {
              this.chromaticAberration.dispose(camera);
            }
            if (this.grain) {
              this.grain.dispose(camera);
            }
            if (this._glowLayer) {
              this._glowLayer.dispose();
            }
          }
        }
        this.imageProcessing = null;
        this.fxaa = null;
        if (disposeNonRecreated) {
          this.sharpen = null;
          this._sharpenEffect = null;
          this.depthOfField = null;
          this.bloom = null;
          this.chromaticAberration = null;
          this._chromaticAberrationEffect = null;
          this.grain = null;
          this._grainEffect = null;
          this._glowLayer = null;
        }
      }
      /**
       * Adds a camera to the pipeline
       * @param camera the camera to be added
       */
      addCamera(camera) {
        this._camerasToBeAttached.push(camera);
        this._buildPipeline();
      }
      /**
       * Removes a camera from the pipeline
       * @param camera the camera to remove
       */
      removeCamera(camera) {
        const index = this._camerasToBeAttached.indexOf(camera);
        this._camerasToBeAttached.splice(index, 1);
        this._buildPipeline();
      }
      /**
       * Dispose of the pipeline and stop all post processes
       */
      dispose() {
        this._buildAllowed = false;
        this.onBuildObservable.clear();
        this._disposePostProcesses(true);
        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);
        this._scene._postProcessRenderPipelineManager.removePipeline(this.name);
        this._scene.autoClear = true;
        if (this._resizeObserver) {
          this._scene.getEngine().onResizeObservable.remove(this._resizeObserver);
          this._resizeObserver = null;
        }
        this._scene.onActiveCameraChanged.remove(this._activeCameraChangedObserver);
        this._scene.onActiveCamerasChanged.remove(this._activeCamerasChangedObserver);
        this._scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigurationObserver);
        super.dispose();
      }
      /**
       * Serialize the rendering pipeline (Used when exporting)
       * @returns the serialized object
       */
      serialize() {
        const serializationObject = SerializationHelper.Serialize(this);
        serializationObject.customType = "DefaultRenderingPipeline";
        return serializationObject;
      }
      /**
       * Parse the serialized pipeline
       * @param source Source pipeline.
       * @param scene The scene to load the pipeline to.
       * @param rootUrl The URL of the serialized pipeline.
       * @returns An instantiated pipeline from the serialized object.
       */
      static Parse(source, scene, rootUrl) {
        return SerializationHelper.Parse(() => new _DefaultRenderingPipeline(source._name, source._name._hdr, scene), source, scene, rootUrl);
      }
    };
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "sharpenEnabled", null);
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "bloomKernel", null);
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "_bloomWeight", void 0);
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "_bloomThreshold", void 0);
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "_hdr", void 0);
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "bloomWeight", null);
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "bloomThreshold", null);
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "bloomScale", null);
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "bloomEnabled", null);
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "depthOfFieldEnabled", null);
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "depthOfFieldBlurLevel", null);
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "fxaaEnabled", null);
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "samples", null);
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "imageProcessingEnabled", null);
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "glowLayerEnabled", null);
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "chromaticAberrationEnabled", null);
    __decorate([
      serialize()
    ], DefaultRenderingPipeline.prototype, "grainEnabled", null);
    RegisterClass("BABYLON.DefaultRenderingPipeline", DefaultRenderingPipeline);
  }
});

// node_modules/@babylonjs/core/Shaders/lensHighlights.fragment.js
var name10, shader10;
var init_lensHighlights_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/lensHighlights.fragment.js"() {
    init_shaderStore();
    name10 = "lensHighlightsPixelShader";
    shader10 = `uniform sampler2D textureSampler; 
uniform float gain;uniform float threshold;uniform float screen_width;uniform float screen_height;varying vec2 vUV;vec4 highlightColor(vec4 color) {vec4 highlight=color;float luminance=dot(highlight.rgb,vec3(0.2125,0.7154,0.0721));float lum_threshold;if (threshold>1.0) { lum_threshold=0.94+0.01*threshold; }
else { lum_threshold=0.5+0.44*threshold; }
luminance=clamp((luminance-lum_threshold)*(1.0/(1.0-lum_threshold)),0.0,1.0);highlight*=luminance*gain;highlight.a=1.0;return highlight;}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{vec4 original=texture2D(textureSampler,vUV);if (gain==-1.0) {gl_FragColor=vec4(0.0,0.0,0.0,1.0);return;}
float w=2.0/screen_width;float h=2.0/screen_height;float weight=1.0;vec4 blurred=vec4(0.0,0.0,0.0,0.0);
#ifdef PENTAGON
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.84*w,0.43*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.48*w,-1.29*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.61*w,1.51*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.55*w,-0.74*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.71*w,-0.52*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.94*w,1.59*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.40*w,-1.87*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.62*w,1.16*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.09*w,0.25*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.46*w,-1.71*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.08*w,2.42*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.85*w,-1.89*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.89*w,0.16*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.29*w,1.88*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.40*w,-2.81*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.54*w,2.26*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.60*w,-0.61*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.31*w,-1.30*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.83*w,2.53*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.12*w,-2.48*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.60*w,1.11*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.99*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.50*w,-2.81*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.85*w,3.33*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.94*w,-1.92*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.27*w,-0.53*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.95*w,2.48*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.23*w,-3.04*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.17*w,2.05*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.97*w,-0.04*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.25*w,-2.00*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.31*w,3.08*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.94*w,-2.59*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.37*w,0.64*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.13*w,1.93*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.03*w,-3.65*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.60*w,3.17*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.14*w,-1.19*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.00*w,-1.19*h)));
#else
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.85*w,0.36*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.52*w,-1.14*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.46*w,1.42*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.46*w,-0.83*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.79*w,-0.42*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.11*w,1.62*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.29*w,-2.07*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.69*w,1.39*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.28*w,0.12*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.65*w,-1.69*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.08*w,2.44*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.63*w,-1.90*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.55*w,0.31*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.13*w,1.52*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.56*w,-2.61*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.38*w,2.34*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.64*w,-0.81*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.53*w,-1.21*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.06*w,2.63*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.00*w,-2.69*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.59*w,1.32*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.78*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.57*w,-2.50*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.54*w,2.93*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.39*w,-1.81*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,-0.28*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.04*w,2.25*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.02*w,-3.05*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.09*w,2.25*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.07*w,-0.25*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.44*w,-1.90*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.52*w,3.05*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.68*w,-2.61*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,0.79*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.76*w,1.46*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.05*w,-2.94*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.21*w,2.88*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.84*w,-1.30*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.98*w,-0.96*h)));
#endif
blurred/=39.0;gl_FragColor=blurred;}`;
    if (!ShaderStore.ShadersStore[name10]) {
      ShaderStore.ShadersStore[name10] = shader10;
    }
  }
});

// node_modules/@babylonjs/core/Shaders/depthOfField.fragment.js
var name11, shader11;
var init_depthOfField_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/depthOfField.fragment.js"() {
    init_shaderStore();
    name11 = "depthOfFieldPixelShader";
    shader11 = `uniform sampler2D textureSampler;uniform sampler2D highlightsSampler;uniform sampler2D depthSampler;uniform sampler2D grainSampler;uniform float grain_amount;uniform bool blur_noise;uniform float screen_width;uniform float screen_height;uniform float distortion;uniform bool dof_enabled;uniform float screen_distance; 
uniform float aperture;uniform float darken;uniform float edge_blur;uniform bool highlights;uniform float near;uniform float far;varying vec2 vUV;
#define PI 3.14159265
#define TWOPI 6.28318530
#define inverse_focal_length 0.1 
vec2 centered_screen_pos;vec2 distorted_coords;float radius2;float radius;vec2 rand(vec2 co)
{float noise1=(fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453));float noise2=(fract(sin(dot(co,vec2(12.9898,78.233)*2.0))*43758.5453));return clamp(vec2(noise1,noise2),0.0,1.0);}
vec2 getDistortedCoords(vec2 coords) {if (distortion==0.0) { return coords; }
vec2 direction=1.0*normalize(centered_screen_pos);vec2 dist_coords=vec2(0.5,0.5);dist_coords.x=0.5+direction.x*radius2*1.0;dist_coords.y=0.5+direction.y*radius2*1.0;float dist_amount=clamp(distortion*0.23,0.0,1.0);dist_coords=mix(coords,dist_coords,dist_amount);return dist_coords;}
float sampleScreen(inout vec4 color,in vec2 offset,in float weight) {vec2 coords=distorted_coords;float angle=rand(coords*100.0).x*TWOPI;coords+=vec2(offset.x*cos(angle)-offset.y*sin(angle),offset.x*sin(angle)+offset.y*cos(angle));color+=texture2D(textureSampler,coords)*weight;return weight;}
float getBlurLevel(float size) {return min(3.0,ceil(size/1.0));}
vec4 getBlurColor(float size) {vec4 col=texture2D(textureSampler,distorted_coords);float blur_level=getBlurLevel(size);float w=(size/screen_width);float h=(size/screen_height);float total_weight=1.0;vec2 sample_coords;total_weight+=sampleScreen(col,vec2(-0.50*w,0.24*h),0.93);total_weight+=sampleScreen(col,vec2(0.30*w,-0.75*h),0.90);total_weight+=sampleScreen(col,vec2(0.36*w,0.96*h),0.87);total_weight+=sampleScreen(col,vec2(-1.08*w,-0.55*h),0.85);total_weight+=sampleScreen(col,vec2(1.33*w,-0.37*h),0.83);total_weight+=sampleScreen(col,vec2(-0.82*w,1.31*h),0.80);total_weight+=sampleScreen(col,vec2(-0.31*w,-1.67*h),0.78);total_weight+=sampleScreen(col,vec2(1.47*w,1.11*h),0.76);total_weight+=sampleScreen(col,vec2(-1.97*w,0.19*h),0.74);total_weight+=sampleScreen(col,vec2(1.42*w,-1.57*h),0.72);if (blur_level>1.0) {total_weight+=sampleScreen(col,vec2(0.01*w,2.25*h),0.70);total_weight+=sampleScreen(col,vec2(-1.62*w,-1.74*h),0.67);total_weight+=sampleScreen(col,vec2(2.49*w,0.20*h),0.65);total_weight+=sampleScreen(col,vec2(-2.07*w,1.61*h),0.63);total_weight+=sampleScreen(col,vec2(0.46*w,-2.70*h),0.61);total_weight+=sampleScreen(col,vec2(1.55*w,2.40*h),0.59);total_weight+=sampleScreen(col,vec2(-2.88*w,-0.75*h),0.56);total_weight+=sampleScreen(col,vec2(2.73*w,-1.44*h),0.54);total_weight+=sampleScreen(col,vec2(-1.08*w,3.02*h),0.52);total_weight+=sampleScreen(col,vec2(-1.28*w,-3.05*h),0.49);}
if (blur_level>2.0) {total_weight+=sampleScreen(col,vec2(3.11*w,1.43*h),0.46);total_weight+=sampleScreen(col,vec2(-3.36*w,1.08*h),0.44);total_weight+=sampleScreen(col,vec2(1.80*w,-3.16*h),0.41);total_weight+=sampleScreen(col,vec2(0.83*w,3.65*h),0.38);total_weight+=sampleScreen(col,vec2(-3.16*w,-2.19*h),0.34);total_weight+=sampleScreen(col,vec2(3.92*w,-0.53*h),0.31);total_weight+=sampleScreen(col,vec2(-2.59*w,3.12*h),0.26);total_weight+=sampleScreen(col,vec2(-0.20*w,-4.15*h),0.22);total_weight+=sampleScreen(col,vec2(3.02*w,3.00*h),0.15);}
col/=total_weight; 
if (darken>0.0) {col.rgb*=clamp(0.3,1.0,1.05-size*0.5*darken);}
return col;}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{centered_screen_pos=vec2(vUV.x-0.5,vUV.y-0.5);radius2=centered_screen_pos.x*centered_screen_pos.x+centered_screen_pos.y*centered_screen_pos.y;radius=sqrt(radius2);distorted_coords=getDistortedCoords(vUV); 
vec2 texels_coords=vec2(vUV.x*screen_width,vUV.y*screen_height); 
float depth=texture2D(depthSampler,distorted_coords).r; 
float distance=near+(far-near)*depth; 
vec4 color=texture2D(textureSampler,vUV); 
float coc=abs(aperture*(screen_distance*(inverse_focal_length-1.0/distance)-1.0));if (dof_enabled==false || coc<0.07) { coc=0.0; }
float edge_blur_amount=0.0;if (edge_blur>0.0) {edge_blur_amount=clamp((radius*2.0-1.0+0.15*edge_blur)*1.5,0.0,1.0)*1.3;}
float blur_amount=max(edge_blur_amount,coc);if (blur_amount==0.0) {gl_FragColor=texture2D(textureSampler,distorted_coords);}
else {gl_FragColor=getBlurColor(blur_amount*1.7);if (highlights) {gl_FragColor.rgb+=clamp(coc,0.0,1.0)*texture2D(highlightsSampler,distorted_coords).rgb;}
if (blur_noise) {vec2 noise=rand(distorted_coords)*0.01*blur_amount;vec2 blurred_coord=vec2(distorted_coords.x+noise.x,distorted_coords.y+noise.y);gl_FragColor=0.04*texture2D(textureSampler,blurred_coord)+0.96*gl_FragColor;}}
if (grain_amount>0.0) {vec4 grain_color=texture2D(grainSampler,texels_coords*0.003);gl_FragColor.rgb+=(-0.5+grain_color.rgb)*0.30*grain_amount;}}
`;
    if (!ShaderStore.ShadersStore[name11]) {
      ShaderStore.ShadersStore[name11] = shader11;
    }
  }
});

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/lensRenderingPipeline.js
var LensRenderingPipeline;
var init_lensRenderingPipeline = __esm({
  "node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/lensRenderingPipeline.js"() {
    init_texture();
    init_postProcess();
    init_postProcessRenderPipeline();
    init_postProcessRenderEffect();
    init_rawTexture();
    init_postProcessRenderPipelineManagerSceneComponent();
    init_chromaticAberration_fragment();
    init_lensHighlights_fragment();
    init_depthOfField_fragment();
    init_math_scalar_functions();
    LensRenderingPipeline = class extends PostProcessRenderPipeline {
      /**
       * @constructor
       *
       * Effect parameters are as follow:
       * {
       *      chromatic_aberration: number;       // from 0 to x (1 for realism)
       *      edge_blur: number;                  // from 0 to x (1 for realism)
       *      distortion: number;                 // from 0 to x (1 for realism), note that this will effect the pointer position precision
       *      grain_amount: number;               // from 0 to 1
       *      grain_texture: BABYLON.Texture;     // texture to use for grain effect; if unset, use random B&W noise
       *      dof_focus_distance: number;         // depth-of-field: focus distance; unset to disable (disabled by default)
       *      dof_aperture: number;               // depth-of-field: focus blur bias (default: 1)
       *      dof_darken: number;                 // depth-of-field: darken that which is out of focus (from 0 to 1, disabled by default)
       *      dof_pentagon: boolean;              // depth-of-field: makes a pentagon-like "bokeh" effect
       *      dof_gain: number;                   // depth-of-field: highlights gain; unset to disable (disabled by default)
       *      dof_threshold: number;              // depth-of-field: highlights threshold (default: 1)
       *      blur_noise: boolean;                // add a little bit of noise to the blur (default: true)
       * }
       * Note: if an effect parameter is unset, effect is disabled
       *
       * @param name The rendering pipeline name
       * @param parameters - An object containing all parameters (see above)
       * @param scene The scene linked to this pipeline
       * @param ratio The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)
       * @param cameras The array of cameras that the rendering pipeline will be attached to
       */
      constructor(name13, parameters, scene, ratio = 1, cameras) {
        super(scene.getEngine(), name13);
        this.LensChromaticAberrationEffect = "LensChromaticAberrationEffect";
        this.HighlightsEnhancingEffect = "HighlightsEnhancingEffect";
        this.LensDepthOfFieldEffect = "LensDepthOfFieldEffect";
        this._pentagonBokehIsEnabled = false;
        this._scene = scene;
        this._depthTexture = scene.enableDepthRenderer().getDepthMap();
        if (parameters.grain_texture) {
          this._grainTexture = parameters.grain_texture;
        } else {
          this._createGrainTexture();
        }
        this._edgeBlur = parameters.edge_blur ? parameters.edge_blur : 0;
        this._grainAmount = parameters.grain_amount ? parameters.grain_amount : 0;
        this._chromaticAberration = parameters.chromatic_aberration ? parameters.chromatic_aberration : 0;
        this._distortion = parameters.distortion ? parameters.distortion : 0;
        this._highlightsGain = parameters.dof_gain !== void 0 ? parameters.dof_gain : -1;
        this._highlightsThreshold = parameters.dof_threshold ? parameters.dof_threshold : 1;
        this._dofDistance = parameters.dof_focus_distance !== void 0 ? parameters.dof_focus_distance : -1;
        this._dofAperture = parameters.dof_aperture ? parameters.dof_aperture : 1;
        this._dofDarken = parameters.dof_darken ? parameters.dof_darken : 0;
        this._dofPentagon = parameters.dof_pentagon !== void 0 ? parameters.dof_pentagon : true;
        this._blurNoise = parameters.blur_noise !== void 0 ? parameters.blur_noise : true;
        this._createChromaticAberrationPostProcess(ratio);
        this._createHighlightsPostProcess(ratio);
        this._createDepthOfFieldPostProcess(ratio / 4);
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.LensChromaticAberrationEffect, () => {
          return this._chromaticAberrationPostProcess;
        }, true));
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.HighlightsEnhancingEffect, () => {
          return this._highlightsPostProcess;
        }, true));
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.LensDepthOfFieldEffect, () => {
          return this._depthOfFieldPostProcess;
        }, true));
        if (this._highlightsGain === -1) {
          this._disableEffect(this.HighlightsEnhancingEffect, null);
        }
        scene.postProcessRenderPipelineManager.addPipeline(this);
        if (cameras) {
          scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name13, cameras);
        }
      }
      /**
       * Get the class name
       * @returns "LensRenderingPipeline"
       */
      getClassName() {
        return "LensRenderingPipeline";
      }
      // Properties
      /**
       * Gets associated scene
       */
      get scene() {
        return this._scene;
      }
      /**
       * Gets or sets the edge blur
       */
      get edgeBlur() {
        return this._edgeBlur;
      }
      set edgeBlur(value) {
        this.setEdgeBlur(value);
      }
      /**
       * Gets or sets the grain amount
       */
      get grainAmount() {
        return this._grainAmount;
      }
      set grainAmount(value) {
        this.setGrainAmount(value);
      }
      /**
       * Gets or sets the chromatic aberration amount
       */
      get chromaticAberration() {
        return this._chromaticAberration;
      }
      set chromaticAberration(value) {
        this.setChromaticAberration(value);
      }
      /**
       * Gets or sets the depth of field aperture
       */
      get dofAperture() {
        return this._dofAperture;
      }
      set dofAperture(value) {
        this.setAperture(value);
      }
      /**
       * Gets or sets the edge distortion
       */
      get edgeDistortion() {
        return this._distortion;
      }
      set edgeDistortion(value) {
        this.setEdgeDistortion(value);
      }
      /**
       * Gets or sets the depth of field distortion
       */
      get dofDistortion() {
        return this._dofDistance;
      }
      set dofDistortion(value) {
        this.setFocusDistance(value);
      }
      /**
       * Gets or sets the darken out of focus amount
       */
      get darkenOutOfFocus() {
        return this._dofDarken;
      }
      set darkenOutOfFocus(value) {
        this.setDarkenOutOfFocus(value);
      }
      /**
       * Gets or sets a boolean indicating if blur noise is enabled
       */
      get blurNoise() {
        return this._blurNoise;
      }
      set blurNoise(value) {
        this._blurNoise = value;
      }
      /**
       * Gets or sets a boolean indicating if pentagon bokeh is enabled
       */
      get pentagonBokeh() {
        return this._pentagonBokehIsEnabled;
      }
      set pentagonBokeh(value) {
        if (value) {
          this.enablePentagonBokeh();
        } else {
          this.disablePentagonBokeh();
        }
      }
      /**
       * Gets or sets the highlight grain amount
       */
      get highlightsGain() {
        return this._highlightsGain;
      }
      set highlightsGain(value) {
        this.setHighlightsGain(value);
      }
      /**
       * Gets or sets the highlight threshold
       */
      get highlightsThreshold() {
        return this._highlightsThreshold;
      }
      set highlightsThreshold(value) {
        this.setHighlightsThreshold(value);
      }
      // public methods (self explanatory)
      /**
       * Sets the amount of blur at the edges
       * @param amount blur amount
       */
      setEdgeBlur(amount) {
        this._edgeBlur = amount;
      }
      /**
       * Sets edge blur to 0
       */
      disableEdgeBlur() {
        this._edgeBlur = 0;
      }
      /**
       * Sets the amount of grain
       * @param amount Amount of grain
       */
      setGrainAmount(amount) {
        this._grainAmount = amount;
      }
      /**
       * Set grain amount to 0
       */
      disableGrain() {
        this._grainAmount = 0;
      }
      /**
       * Sets the chromatic aberration amount
       * @param amount amount of chromatic aberration
       */
      setChromaticAberration(amount) {
        this._chromaticAberration = amount;
      }
      /**
       * Sets chromatic aberration amount to 0
       */
      disableChromaticAberration() {
        this._chromaticAberration = 0;
      }
      /**
       * Sets the EdgeDistortion amount
       * @param amount amount of EdgeDistortion
       */
      setEdgeDistortion(amount) {
        this._distortion = amount;
      }
      /**
       * Sets edge distortion to 0
       */
      disableEdgeDistortion() {
        this._distortion = 0;
      }
      /**
       * Sets the FocusDistance amount
       * @param amount amount of FocusDistance
       */
      setFocusDistance(amount) {
        this._dofDistance = amount;
      }
      /**
       * Disables depth of field
       */
      disableDepthOfField() {
        this._dofDistance = -1;
      }
      /**
       * Sets the Aperture amount
       * @param amount amount of Aperture
       */
      setAperture(amount) {
        this._dofAperture = amount;
      }
      /**
       * Sets the DarkenOutOfFocus amount
       * @param amount amount of DarkenOutOfFocus
       */
      setDarkenOutOfFocus(amount) {
        this._dofDarken = amount;
      }
      /**
       * Creates a pentagon bokeh effect
       */
      enablePentagonBokeh() {
        this._highlightsPostProcess.updateEffect("#define PENTAGON\n");
        this._pentagonBokehIsEnabled = true;
      }
      /**
       * Disables the pentagon bokeh effect
       */
      disablePentagonBokeh() {
        this._pentagonBokehIsEnabled = false;
        this._highlightsPostProcess.updateEffect();
      }
      /**
       * Enables noise blur
       */
      enableNoiseBlur() {
        this._blurNoise = true;
      }
      /**
       * Disables noise blur
       */
      disableNoiseBlur() {
        this._blurNoise = false;
      }
      /**
       * Sets the HighlightsGain amount
       * @param amount amount of HighlightsGain
       */
      setHighlightsGain(amount) {
        this._highlightsGain = amount;
      }
      /**
       * Sets the HighlightsThreshold amount
       * @param amount amount of HighlightsThreshold
       */
      setHighlightsThreshold(amount) {
        if (this._highlightsGain === -1) {
          this._highlightsGain = 1;
        }
        this._highlightsThreshold = amount;
      }
      /**
       * Disables highlights
       */
      disableHighlights() {
        this._highlightsGain = -1;
      }
      /**
       * Removes the internal pipeline assets and detaches the pipeline from the scene cameras
       * @param disableDepthRender If the scene's depth rendering should be disabled (default: false)
       */
      dispose(disableDepthRender = false) {
        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);
        this._scene.postProcessRenderPipelineManager.removePipeline(this._name);
        this._chromaticAberrationPostProcess = null;
        this._highlightsPostProcess = null;
        this._depthOfFieldPostProcess = null;
        this._grainTexture.dispose();
        if (disableDepthRender) {
          this._scene.disableDepthRenderer();
        }
      }
      // colors shifting and distortion
      _createChromaticAberrationPostProcess(ratio) {
        this._chromaticAberrationPostProcess = new PostProcess(
          "LensChromaticAberration",
          "chromaticAberration",
          ["chromatic_aberration", "screen_width", "screen_height", "direction", "radialIntensity", "centerPosition"],
          // uniforms
          [],
          // samplers
          ratio,
          null,
          Texture.TRILINEAR_SAMPLINGMODE,
          this._scene.getEngine(),
          false
        );
        this._chromaticAberrationPostProcess.onApply = (effect) => {
          effect.setFloat("chromatic_aberration", this._chromaticAberration);
          effect.setFloat("screen_width", this._scene.getEngine().getRenderWidth());
          effect.setFloat("screen_height", this._scene.getEngine().getRenderHeight());
          effect.setFloat("radialIntensity", 1);
          effect.setFloat2("direction", 17, 17);
          effect.setFloat2("centerPosition", 0.5, 0.5);
        };
      }
      // highlights enhancing
      _createHighlightsPostProcess(ratio) {
        this._highlightsPostProcess = new PostProcess(
          "LensHighlights",
          "lensHighlights",
          ["gain", "threshold", "screen_width", "screen_height"],
          // uniforms
          [],
          // samplers
          ratio,
          null,
          Texture.TRILINEAR_SAMPLINGMODE,
          this._scene.getEngine(),
          false,
          this._dofPentagon ? "#define PENTAGON\n" : ""
        );
        this._highlightsPostProcess.externalTextureSamplerBinding = true;
        this._highlightsPostProcess.onApply = (effect) => {
          effect.setFloat("gain", this._highlightsGain);
          effect.setFloat("threshold", this._highlightsThreshold);
          effect.setTextureFromPostProcess("textureSampler", this._chromaticAberrationPostProcess);
          effect.setFloat("screen_width", this._scene.getEngine().getRenderWidth());
          effect.setFloat("screen_height", this._scene.getEngine().getRenderHeight());
        };
      }
      // colors shifting and distortion
      _createDepthOfFieldPostProcess(ratio) {
        this._depthOfFieldPostProcess = new PostProcess("LensDepthOfField", "depthOfField", [
          "grain_amount",
          "blur_noise",
          "screen_width",
          "screen_height",
          "distortion",
          "dof_enabled",
          "screen_distance",
          "aperture",
          "darken",
          "edge_blur",
          "highlights",
          "near",
          "far"
        ], ["depthSampler", "grainSampler", "highlightsSampler"], ratio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);
        this._depthOfFieldPostProcess.externalTextureSamplerBinding = true;
        this._depthOfFieldPostProcess.onApply = (effect) => {
          effect.setTexture("depthSampler", this._depthTexture);
          effect.setTexture("grainSampler", this._grainTexture);
          effect.setTextureFromPostProcess("textureSampler", this._highlightsPostProcess);
          effect.setTextureFromPostProcess("highlightsSampler", this._depthOfFieldPostProcess);
          effect.setFloat("grain_amount", this._grainAmount);
          effect.setBool("blur_noise", this._blurNoise);
          effect.setFloat("screen_width", this._scene.getEngine().getRenderWidth());
          effect.setFloat("screen_height", this._scene.getEngine().getRenderHeight());
          effect.setFloat("distortion", this._distortion);
          effect.setBool("dof_enabled", this._dofDistance !== -1);
          effect.setFloat("screen_distance", 1 / (0.1 - 1 / this._dofDistance));
          effect.setFloat("aperture", this._dofAperture);
          effect.setFloat("darken", this._dofDarken);
          effect.setFloat("edge_blur", this._edgeBlur);
          effect.setBool("highlights", this._highlightsGain !== -1);
          if (this._scene.activeCamera) {
            effect.setFloat("near", this._scene.activeCamera.minZ);
            effect.setFloat("far", this._scene.activeCamera.maxZ);
          }
        };
      }
      // creates a black and white random noise texture, 512x512
      _createGrainTexture() {
        const size = 512;
        const data = new Uint8Array(size * size * 4);
        for (let index = 0; index < data.length; ) {
          const value = Math.floor(RandomRange(0.42, 0.58) * 255);
          data[index++] = value;
          data[index++] = value;
          data[index++] = value;
          data[index++] = 255;
        }
        const texture = RawTexture.CreateRGBATexture(data, size, size, this._scene, false, false, 2);
        texture.name = "LensNoiseTexture";
        texture.wrapU = Texture.WRAP_ADDRESSMODE;
        texture.wrapV = Texture.WRAP_ADDRESSMODE;
        this._grainTexture = texture;
      }
    };
  }
});

// node_modules/@babylonjs/core/Rendering/ssao2Configuration.js
var SSAO2Configuration;
var init_ssao2Configuration = __esm({
  "node_modules/@babylonjs/core/Rendering/ssao2Configuration.js"() {
    SSAO2Configuration = class {
      constructor() {
        this.enabled = false;
        this.name = "ssao2";
        this.texturesRequired = [6, 5];
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinSSAO2PostProcess.js
var ThinSSAO2PostProcess;
var init_thinSSAO2PostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinSSAO2PostProcess.js"() {
    init_effectRenderer();
    init_math_vector();
    init_camera();
    init_rawTexture();
    init_math_scalar_functions();
    init_texture();
    ThinSSAO2PostProcess = class _ThinSSAO2PostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(import("./ssao2.fragment-FAEQE2D5.js"));
        } else {
          list.push(import("./ssao2.fragment-3PUOUD4O.js"));
        }
      }
      get textureWidth() {
        return this._textureWidth;
      }
      set textureWidth(width) {
        if (this._textureWidth === width) {
          return;
        }
        this._textureWidth = width;
      }
      get textureHeight() {
        return this._textureHeight;
      }
      set textureHeight(height) {
        if (this._textureHeight === height) {
          return;
        }
        this._textureHeight = height;
      }
      set samples(n) {
        this._samples = n;
        this.updateEffect();
        this._sampleSphere = this._generateHemisphere();
      }
      get samples() {
        return this._samples;
      }
      set epsilon(n) {
        this._epsilon = n;
        this.updateEffect();
      }
      get epsilon() {
        return this._epsilon;
      }
      updateEffect() {
        super.updateEffect(this._getDefinesForSSAO());
      }
      constructor(name13, scene, options) {
        super({
          ...options,
          name: name13,
          engine: scene.getEngine(),
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinSSAO2PostProcess.FragmentUrl,
          uniforms: _ThinSSAO2PostProcess.Uniforms,
          samplers: _ThinSSAO2PostProcess.Samplers,
          defines: `#define SSAO
#define SAMPLES 8
#define EPSILON 0.0001`,
          shaderLanguage: scene.getEngine().isWebGPU ? 1 : 0
        });
        this.camera = null;
        this._textureWidth = 0;
        this._textureHeight = 0;
        this._samples = 8;
        this.totalStrength = 1;
        this.radius = 2;
        this.maxZ = 100;
        this.minZAspect = 0.2;
        this.base = 0;
        this._epsilon = 0.02;
        this._bits = new Uint32Array(1);
        this._scene = scene;
        this._createRandomTexture();
        this.updateEffect();
        this._sampleSphere = this._generateHemisphere();
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        const effect = this._drawWrapper.effect;
        const camera = this.camera;
        if (!camera) {
          return;
        }
        const projectionMatrix = camera.getProjectionMatrix();
        effect.setArray3("sampleSphere", this._sampleSphere);
        effect.setFloat("randTextureTiles", 32);
        effect.setFloat("samplesFactor", 1 / this.samples);
        effect.setFloat("totalStrength", this.totalStrength);
        effect.setFloat2("texelSize", 1 / this.textureWidth, 1 / this.textureHeight);
        effect.setFloat("radius", this.radius);
        effect.setFloat("maxZ", this.maxZ);
        effect.setFloat("minZAspect", this.minZAspect);
        effect.setFloat("base", this.base);
        effect.setFloat("near", camera.minZ);
        if (camera.mode === Camera.PERSPECTIVE_CAMERA) {
          effect.setMatrix3x3("depthProjection", _ThinSSAO2PostProcess.PERSPECTIVE_DEPTH_PROJECTION);
          const viewportSize = Math.tan(camera.fov / 2);
          if (camera.fovMode === Camera.FOVMODE_VERTICAL_FIXED) {
            effect.setFloat("xViewport", viewportSize * this._scene.getEngine().getAspectRatio(camera, true));
            effect.setFloat("yViewport", viewportSize);
          } else {
            effect.setFloat("xViewport", viewportSize);
            effect.setFloat("yViewport", viewportSize / this._scene.getEngine().getAspectRatio(camera, true));
          }
        } else {
          const halfWidth = this._scene.getEngine().getRenderWidth() / 2;
          const halfHeight = this._scene.getEngine().getRenderHeight() / 2;
          const orthoLeft = camera.orthoLeft ?? -halfWidth;
          const orthoRight = camera.orthoRight ?? halfWidth;
          const orthoBottom = camera.orthoBottom ?? -halfHeight;
          const orthoTop = camera.orthoTop ?? halfHeight;
          effect.setMatrix3x3("depthProjection", _ThinSSAO2PostProcess.ORTHO_DEPTH_PROJECTION);
          effect.setFloat4("viewport", orthoLeft, orthoRight, orthoBottom, orthoTop);
        }
        effect.setMatrix("projection", projectionMatrix);
        effect.setTexture("randomSampler", this._randomTexture);
      }
      dispose() {
        this._randomTexture.dispose();
        super.dispose();
      }
      _createRandomTexture() {
        const size = 128;
        const data = new Uint8Array(size * size * 4);
        const randVector = Vector2.Zero();
        for (let index = 0; index < data.length; ) {
          randVector.set(RandomRange(0, 1), RandomRange(0, 1)).normalize().scaleInPlace(255);
          data[index++] = Math.floor(randVector.x);
          data[index++] = Math.floor(randVector.y);
          data[index++] = 0;
          data[index++] = 255;
        }
        const texture = RawTexture.CreateRGBATexture(data, size, size, this._scene, false, false, 2);
        texture.name = "SSAORandomTexture";
        texture.wrapU = Texture.WRAP_ADDRESSMODE;
        texture.wrapV = Texture.WRAP_ADDRESSMODE;
        this._randomTexture = texture;
      }
      //Van der Corput radical inverse
      _radicalInverseVdC(i) {
        this._bits[0] = i;
        this._bits[0] = (this._bits[0] << 16 | this._bits[0] >> 16) >>> 0;
        this._bits[0] = (this._bits[0] & 1431655765) << 1 | (this._bits[0] & 2863311530) >>> 1 >>> 0;
        this._bits[0] = (this._bits[0] & 858993459) << 2 | (this._bits[0] & 3435973836) >>> 2 >>> 0;
        this._bits[0] = (this._bits[0] & 252645135) << 4 | (this._bits[0] & 4042322160) >>> 4 >>> 0;
        this._bits[0] = (this._bits[0] & 16711935) << 8 | (this._bits[0] & 4278255360) >>> 8 >>> 0;
        return this._bits[0] * 23283064365386963e-26;
      }
      _hammersley(i, n) {
        return [i / n, this._radicalInverseVdC(i)];
      }
      _hemisphereSampleUniform(u, v) {
        const phi = v * 2 * Math.PI;
        const cosTheta = 1 - u * 0.85;
        const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
        return new Vector3(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta);
      }
      _generateHemisphere() {
        const numSamples = this.samples;
        const result = [];
        let vector;
        let i = 0;
        while (i < numSamples) {
          if (numSamples < 16) {
            vector = this._hemisphereSampleUniform(Math.random(), Math.random());
          } else {
            const rand = this._hammersley(i, numSamples);
            vector = this._hemisphereSampleUniform(rand[0], rand[1]);
          }
          result.push(vector.x, vector.y, vector.z);
          i++;
        }
        return result;
      }
      _getDefinesForSSAO() {
        const epsilon = this._epsilon ?? 0.02;
        const samples = this._samples ?? 8;
        let defines = `#define SSAO
#define SAMPLES ${samples}
#define EPSILON ${epsilon.toFixed(4)}`;
        if (this.camera?.mode === Camera.ORTHOGRAPHIC_CAMERA) {
          defines += `
#define ORTHOGRAPHIC_CAMERA`;
        }
        return defines;
      }
    };
    ThinSSAO2PostProcess.ORTHO_DEPTH_PROJECTION = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    ThinSSAO2PostProcess.PERSPECTIVE_DEPTH_PROJECTION = [0, 0, 0, 0, 0, 0, 1, 1, 1];
    ThinSSAO2PostProcess.FragmentUrl = "ssao2";
    ThinSSAO2PostProcess.Uniforms = [
      "sampleSphere",
      "samplesFactor",
      "randTextureTiles",
      "totalStrength",
      "radius",
      "base",
      "range",
      "projection",
      "near",
      "texelSize",
      "xViewport",
      "yViewport",
      "viewport",
      "maxZ",
      "minZAspect",
      "depthProjection"
    ];
    ThinSSAO2PostProcess.Samplers = ["randomSampler", "depthSampler", "normalSampler"];
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinSSAO2BlurPostProcess.js
var ThinSSAO2BlurPostProcess;
var init_thinSSAO2BlurPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinSSAO2BlurPostProcess.js"() {
    init_effectRenderer();
    init_engine();
    ThinSSAO2BlurPostProcess = class _ThinSSAO2BlurPostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(import("./ssao2.fragment-FAEQE2D5.js"));
        } else {
          list.push(import("./ssao2.fragment-3PUOUD4O.js"));
        }
      }
      constructor(name13, engine = null, isHorizontal, options) {
        super({
          ...options,
          name: name13,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinSSAO2BlurPostProcess.FragmentUrl,
          uniforms: _ThinSSAO2BlurPostProcess.Uniforms,
          samplers: _ThinSSAO2BlurPostProcess.Samplers,
          defines: "#define BLUR\n" + (isHorizontal ? "#define BLUR_H\n" : "")
        });
        this._bypassBlur = false;
        this.textureSize = 0;
        this.bilateralSamples = 16;
        this.bilateralSoften = 0;
        this.bilateralTolerance = 0;
        this._expensiveBlur = true;
        this._isHorizontal = isHorizontal;
        const defines = this._getDefinesForBlur(this.expensiveBlur, this.bypassBlur);
        const samplers = this._getSamplersForBlur(this.bypassBlur);
        this.updateEffect(defines, null, samplers);
      }
      set bypassBlur(b) {
        const defines = this._getDefinesForBlur(this.expensiveBlur, b);
        const samplers = this._getSamplersForBlur(b);
        this.updateEffect(defines, null, samplers);
        this._bypassBlur = b;
      }
      get bypassBlur() {
        return this._bypassBlur;
      }
      set expensiveBlur(b) {
        const defines = this._getDefinesForBlur(b, this._bypassBlur);
        this.updateEffect(defines);
        this._expensiveBlur = b;
      }
      get expensiveBlur() {
        return this._expensiveBlur;
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        const effect = this._drawWrapper.effect;
        effect.setFloat("outSize", this.textureSize);
        effect.setInt("samples", this.bilateralSamples);
        effect.setFloat("soften", this.bilateralSoften);
        effect.setFloat("tolerance", this.bilateralTolerance);
      }
      _getSamplersForBlur(disabled) {
        return disabled ? ["textureSampler"] : ["textureSampler", "depthSampler"];
      }
      _getDefinesForBlur(bilateral, disabled) {
        let define = "#define BLUR\n";
        if (disabled) {
          define += "#define BLUR_BYPASS\n";
        }
        if (!bilateral) {
          define += "#define BLUR_LEGACY\n";
        }
        return this._isHorizontal ? define + "#define BLUR_H\n" : define;
      }
    };
    ThinSSAO2BlurPostProcess.FragmentUrl = "ssao2";
    ThinSSAO2BlurPostProcess.Uniforms = ["outSize", "samples", "soften", "tolerance"];
    ThinSSAO2BlurPostProcess.Samplers = ["textureSampler", "depthSampler"];
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinSSAO2CombinePostProcess.js
var ThinSSAO2CombinePostProcess;
var init_thinSSAO2CombinePostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinSSAO2CombinePostProcess.js"() {
    init_effectRenderer();
    init_engine();
    init_math_vector();
    ThinSSAO2CombinePostProcess = class _ThinSSAO2CombinePostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(import("./ssaoCombine.fragment-5CDD7WQP.js"));
        } else {
          list.push(import("./ssaoCombine.fragment-22DRVXNN.js"));
        }
      }
      constructor(name13, engine = null, options) {
        super({
          ...options,
          name: name13,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinSSAO2CombinePostProcess.FragmentUrl,
          uniforms: _ThinSSAO2CombinePostProcess.Uniforms,
          samplers: _ThinSSAO2CombinePostProcess.Samplers
        });
        this.camera = null;
        this.useViewportInCombineStage = true;
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        const effect = this._drawWrapper.effect;
        if (this.camera) {
          const viewport = this.camera.viewport;
          if (this.useViewportInCombineStage) {
            effect.setVector4("viewport", TmpVectors.Vector4[0].copyFromFloats(viewport.x, viewport.y, viewport.width, viewport.height));
          } else {
            effect.setVector4("viewport", TmpVectors.Vector4[0].copyFromFloats(0, 0, 1, 1));
          }
        }
      }
    };
    ThinSSAO2CombinePostProcess.FragmentUrl = "ssaoCombine";
    ThinSSAO2CombinePostProcess.Uniforms = ["viewport"];
    ThinSSAO2CombinePostProcess.Samplers = ["originalColor"];
  }
});

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/thinSSAO2RenderingPipeline.js
var ThinSSAO2RenderingPipeline;
var init_thinSSAO2RenderingPipeline = __esm({
  "node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/thinSSAO2RenderingPipeline.js"() {
    init_thinSSAO2PostProcess();
    init_thinSSAO2BlurPostProcess();
    init_thinSSAO2CombinePostProcess();
    ThinSSAO2RenderingPipeline = class {
      /**
       * The camera to which the rendering pipeline will be applied.
       */
      get camera() {
        return this._ssaoPostProcess.camera;
      }
      set camera(camera) {
        this._ssaoPostProcess.camera = camera;
        this._ssaoCombinePostProcess.camera = camera;
      }
      /**
       * Number of samples used for the SSAO calculations. Default value is 8.
       */
      set samples(n) {
        this._ssaoPostProcess.samples = n;
      }
      get samples() {
        return this._ssaoPostProcess.samples;
      }
      /**
       * The output strength of the SSAO post-process. Default value is 1.0.
       */
      get totalStrength() {
        return this._ssaoPostProcess.totalStrength;
      }
      set totalStrength(value) {
        this._ssaoPostProcess.totalStrength = value;
      }
      /**
       * The radius around the analyzed pixel used by the SSAO post-process. Default value is 2.0
       */
      get radius() {
        return this._ssaoPostProcess.radius;
      }
      set radius(value) {
        this._ssaoPostProcess.radius = value;
      }
      /**
       * Maximum depth value to still render AO. A smooth falloff makes the dimming more natural, so there will be no abrupt shading change.
       */
      get maxZ() {
        return this._ssaoPostProcess.maxZ;
      }
      set maxZ(value) {
        this._ssaoPostProcess.maxZ = value;
      }
      /**
       * In order to save performances, SSAO radius is clamped on close geometry. This ratio changes by how much.
       */
      get minZAspect() {
        return this._ssaoPostProcess.minZAspect;
      }
      set minZAspect(value) {
        this._ssaoPostProcess.minZAspect = value;
      }
      /**
       * The base color of the SSAO post-process
       * The final result is "base + ssao" between [0, 1]
       */
      get base() {
        return this._ssaoPostProcess.base;
      }
      set base(value) {
        this._ssaoPostProcess.base = value;
      }
      /**
       * Used in SSAO calculations to compensate for accuracy issues with depth values. Default 0.02.
       *
       * Normally you do not need to change this value, but you can experiment with it if you get a lot of in false self-occlusion on flat surfaces when using fewer than 16 samples. Useful range is normally [0..0.1] but higher values is allowed.
       */
      get epsilon() {
        return this._ssaoPostProcess.epsilon;
      }
      set epsilon(n) {
        this._ssaoPostProcess.epsilon = n;
      }
      /**
       * Skips the denoising (blur) stage of the SSAO calculations.
       *
       * Useful to temporarily set while experimenting with the other SSAO2 settings.
       */
      set bypassBlur(b) {
        this._ssaoBlurXPostProcess.bypassBlur = b;
        this._ssaoBlurYPostProcess.bypassBlur = b;
      }
      get bypassBlur() {
        return this._ssaoBlurXPostProcess.bypassBlur;
      }
      /**
       * Enables the configurable bilateral denoising (blurring) filter. Default is true.
       * Set to false to instead use a legacy bilateral filter that can't be configured.
       *
       * The denoising filter runs after the SSAO calculations and is a very important step. Both options results in a so called bilateral being used, but the "expensive" one can be
       * configured in several ways to fit your scene.
       */
      set expensiveBlur(b) {
        this._ssaoBlurXPostProcess.expensiveBlur = b;
        this._ssaoBlurYPostProcess.expensiveBlur = b;
      }
      get expensiveBlur() {
        return this._ssaoBlurXPostProcess.expensiveBlur;
      }
      /**
       * The number of samples the bilateral filter uses in both dimensions when denoising the SSAO calculations. Default value is 16.
       *
       * A higher value should result in smoother shadows but will use more processing time in the shaders.
       *
       * A high value can cause the shadows to get to blurry or create visible artifacts (bands) near sharp details in the geometry. The artifacts can sometimes be mitigated by increasing the bilateralSoften setting.
       */
      get bilateralSamples() {
        return this._ssaoBlurXPostProcess.bilateralSamples;
      }
      set bilateralSamples(n) {
        this._ssaoBlurXPostProcess.bilateralSamples = n;
        this._ssaoBlurYPostProcess.bilateralSamples = n;
      }
      /**
       * Controls the shape of the denoising kernel used by the bilateral filter. Default value is 0.
       *
       * By default the bilateral filter acts like a box-filter, treating all samples on the same depth with equal weights. This is effective to maximize the denoising effect given a limited set of samples. However, it also often results in visible ghosting around sharp shadow regions and can spread out lines over large areas so they are no longer visible.
       *
       * Increasing this setting will make the filter pay less attention to samples further away from the center sample, reducing many artifacts but at the same time increasing noise.
       *
       * Useful value range is [0..1].
       */
      get bilateralSoften() {
        return this._ssaoBlurXPostProcess.bilateralSoften;
      }
      set bilateralSoften(n) {
        this._ssaoBlurXPostProcess.bilateralSoften = n;
        this._ssaoBlurYPostProcess.bilateralSoften = n;
      }
      /**
       * How forgiving the bilateral denoiser should be when rejecting samples. Default value is 0.
       *
       * A higher value results in the bilateral filter being more forgiving and thus doing a better job at denoising slanted and curved surfaces, but can lead to shadows spreading out around corners or between objects that are close to each other depth wise.
       *
       * Useful value range is normally [0..1], but higher values are allowed.
       */
      get bilateralTolerance() {
        return this._ssaoBlurXPostProcess.bilateralTolerance;
      }
      set bilateralTolerance(n) {
        this._ssaoBlurXPostProcess.bilateralTolerance = n;
        this._ssaoBlurYPostProcess.bilateralTolerance = n;
      }
      /**
       * Indicates that the combine stage should use the current camera viewport to render the SSAO result on only a portion of the output texture (default: true).
       */
      get useViewportInCombineStage() {
        return this._ssaoCombinePostProcess.useViewportInCombineStage;
      }
      set useViewportInCombineStage(b) {
        this._ssaoCombinePostProcess.useViewportInCombineStage = b;
      }
      /**
       * Checks if all the post processes in the pipeline are ready.
       * @returns true if all the post processes in the pipeline are ready
       */
      isReady() {
        return this._ssaoPostProcess.isReady() && this._ssaoBlurXPostProcess.isReady() && this._ssaoBlurYPostProcess.isReady() && this._ssaoCombinePostProcess.isReady();
      }
      /**
       * Constructor of the SSR rendering pipeline
       * @param name The rendering pipeline name
       * @param scene The scene linked to this pipeline
       */
      constructor(name13, scene) {
        this.name = name13;
        this._scene = scene;
        this._ssaoPostProcess = new ThinSSAO2PostProcess(this.name, this._scene);
        this._ssaoBlurXPostProcess = new ThinSSAO2BlurPostProcess(this.name + " BlurX", this._scene.getEngine(), true);
        this._ssaoBlurYPostProcess = new ThinSSAO2BlurPostProcess(this.name + " BlurY", this._scene.getEngine(), false);
        this._ssaoCombinePostProcess = new ThinSSAO2CombinePostProcess(this.name + " Combiner", this._scene.getEngine());
      }
      /**
       * Disposes of the pipeline
       */
      dispose() {
        this._ssaoPostProcess?.dispose();
        this._ssaoBlurXPostProcess?.dispose();
        this._ssaoBlurYPostProcess?.dispose();
        this._ssaoCombinePostProcess?.dispose();
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/ssao2RenderingPipeline.js
var SSAO2RenderingPipeline;
var init_ssao2RenderingPipeline = __esm({
  "node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/ssao2RenderingPipeline.js"() {
    init_tslib_es6();
    init_logger();
    init_decorators();
    init_decorators_serialization();
    init_texture();
    init_postProcess();
    init_postProcessRenderPipeline();
    init_postProcessRenderEffect();
    init_passPostProcess();
    init_typeStore();
    init_engineStore();
    init_ssao2Configuration();
    init_geometryBufferRenderer();
    init_postProcessRenderPipelineManagerSceneComponent();
    init_thinSSAO2RenderingPipeline();
    init_thinSSAO2PostProcess();
    init_thinSSAO2BlurPostProcess();
    init_thinSSAO2CombinePostProcess();
    SSAO2RenderingPipeline = class _SSAO2RenderingPipeline extends PostProcessRenderPipeline {
      /**
       * The output strength of the SSAO post-process. Default value is 1.0.
       */
      get totalStrength() {
        return this._thinSSAORenderingPipeline.totalStrength;
      }
      set totalStrength(value) {
        this._thinSSAORenderingPipeline.totalStrength = value;
      }
      /**
       * Maximum depth value to still render AO. A smooth falloff makes the dimming more natural, so there will be no abrupt shading change.
       */
      get maxZ() {
        return this._thinSSAORenderingPipeline.maxZ;
      }
      set maxZ(value) {
        this._thinSSAORenderingPipeline.maxZ = value;
      }
      /**
       * In order to save performances, SSAO radius is clamped on close geometry. This ratio changes by how much.
       */
      get minZAspect() {
        return this._thinSSAORenderingPipeline.minZAspect;
      }
      set minZAspect(value) {
        this._thinSSAORenderingPipeline.minZAspect = value;
      }
      /**
       * Used in SSAO calculations to compensate for accuracy issues with depth values. Default 0.02.
       *
       * Normally you do not need to change this value, but you can experiment with it if you get a lot of in false self-occlusion on flat surfaces when using fewer than 16 samples. Useful range is normally [0..0.1] but higher values is allowed.
       */
      set epsilon(n) {
        this._thinSSAORenderingPipeline.epsilon = n;
      }
      get epsilon() {
        return this._thinSSAORenderingPipeline.epsilon;
      }
      /**
       * Number of samples used for the SSAO calculations. Default value is 8.
       */
      set samples(n) {
        this._thinSSAORenderingPipeline.samples = n;
      }
      get samples() {
        return this._thinSSAORenderingPipeline.samples;
      }
      /**
       * Number of samples to use for antialiasing.
       */
      set textureSamples(n) {
        this._textureSamples = n;
        if (this._prePassRenderer) {
          this._prePassRenderer.samples = n;
        } else {
          this._originalColorPostProcess.samples = n;
        }
      }
      get textureSamples() {
        return this._textureSamples;
      }
      get _geometryBufferRenderer() {
        if (!this._forceGeometryBuffer) {
          return null;
        }
        return this._forcedGeometryBuffer ?? this._scene.geometryBufferRenderer;
      }
      get _prePassRenderer() {
        if (this._forceGeometryBuffer) {
          return null;
        }
        return this._scene.prePassRenderer;
      }
      /**
       * The radius around the analyzed pixel used by the SSAO post-process. Default value is 2.0
       */
      get radius() {
        return this._thinSSAORenderingPipeline.radius;
      }
      set radius(value) {
        this._thinSSAORenderingPipeline.radius = value;
      }
      /**
       * The base color of the SSAO post-process
       * The final result is "base + ssao" between [0, 1]
       */
      get base() {
        return this._thinSSAORenderingPipeline.base;
      }
      set base(value) {
        this._thinSSAORenderingPipeline.base = value;
      }
      /**
       * Skips the denoising (blur) stage of the SSAO calculations.
       *
       * Useful to temporarily set while experimenting with the other SSAO2 settings.
       */
      set bypassBlur(b) {
        this._thinSSAORenderingPipeline.bypassBlur = b;
      }
      get bypassBlur() {
        return this._thinSSAORenderingPipeline.bypassBlur;
      }
      /**
       * Enables the configurable bilateral denoising (blurring) filter. Default is true.
       * Set to false to instead use a legacy bilateral filter that can't be configured.
       *
       * The denoising filter runs after the SSAO calculations and is a very important step. Both options results in a so called bilateral being used, but the "expensive" one can be
       * configured in several ways to fit your scene.
       */
      set expensiveBlur(b) {
        this._thinSSAORenderingPipeline.expensiveBlur = b;
      }
      get expensiveBlur() {
        return this._thinSSAORenderingPipeline.expensiveBlur;
      }
      /**
       * The number of samples the bilateral filter uses in both dimensions when denoising the SSAO calculations. Default value is 16.
       *
       * A higher value should result in smoother shadows but will use more processing time in the shaders.
       *
       * A high value can cause the shadows to get to blurry or create visible artifacts (bands) near sharp details in the geometry. The artifacts can sometimes be mitigated by increasing the bilateralSoften setting.
       */
      get bilateralSamples() {
        return this._thinSSAORenderingPipeline.bilateralSamples;
      }
      set bilateralSamples(n) {
        this._thinSSAORenderingPipeline.bilateralSamples = n;
      }
      /**
       * Controls the shape of the denoising kernel used by the bilateral filter. Default value is 0.
       *
       * By default the bilateral filter acts like a box-filter, treating all samples on the same depth with equal weights. This is effective to maximize the denoising effect given a limited set of samples. However, it also often results in visible ghosting around sharp shadow regions and can spread out lines over large areas so they are no longer visible.
       *
       * Increasing this setting will make the filter pay less attention to samples further away from the center sample, reducing many artifacts but at the same time increasing noise.
       *
       * Useful value range is [0..1].
       */
      get bilateralSoften() {
        return this._thinSSAORenderingPipeline.bilateralSoften;
      }
      set bilateralSoften(n) {
        this._thinSSAORenderingPipeline.bilateralSoften = n;
      }
      /**
       * How forgiving the bilateral denoiser should be when rejecting samples. Default value is 0.
       *
       * A higher value results in the bilateral filter being more forgiving and thus doing a better job at denoising slanted and curved surfaces, but can lead to shadows spreading out around corners or between objects that are close to each other depth wise.
       *
       * Useful value range is normally [0..1], but higher values are allowed.
       */
      get bilateralTolerance() {
        return this._thinSSAORenderingPipeline.bilateralTolerance;
      }
      set bilateralTolerance(n) {
        this._thinSSAORenderingPipeline.bilateralTolerance = n;
      }
      /**
       *  Support test.
       */
      static get IsSupported() {
        const engine = EngineStore.LastCreatedEngine;
        if (!engine) {
          return false;
        }
        return engine._features.supportSSAO2;
      }
      /**
       * Indicates that the combine stage should use the current camera viewport to render the SSAO result on only a portion of the output texture (default: true).
       */
      get useViewportInCombineStage() {
        return this._thinSSAORenderingPipeline.useViewportInCombineStage;
      }
      set useViewportInCombineStage(b) {
        this._thinSSAORenderingPipeline.useViewportInCombineStage = b;
      }
      /**
       * Gets active scene
       */
      get scene() {
        return this._scene;
      }
      /**
       * Creates the SSAO2 rendering pipeline.
       * @param name The rendering pipeline name
       * @param scene The scene linked to this pipeline
       * @param ratio The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, blurRatio: 1.0 }
       * @param cameras The array of cameras that the rendering pipeline will be attached to
       * @param forceGeometryBuffer Set to true if you want to use the legacy geometry buffer renderer. You can also pass an existing instance of GeometryBufferRenderer if you want to use your own geometry buffer renderer.
       * @param textureType The texture type used by the different post processes created by SSAO (default: 0)
       */
      constructor(name13, scene, ratio, cameras, forceGeometryBuffer = false, textureType = 0) {
        super(scene.getEngine(), name13);
        this.SSAOOriginalSceneColorEffect = "SSAOOriginalSceneColorEffect";
        this.SSAORenderEffect = "SSAORenderEffect";
        this.SSAOBlurHRenderEffect = "SSAOBlurHRenderEffect";
        this.SSAOBlurVRenderEffect = "SSAOBlurVRenderEffect";
        this.SSAOCombineRenderEffect = "SSAOCombineRenderEffect";
        this._textureSamples = 1;
        this._forcedGeometryBuffer = null;
        this._forceGeometryBuffer = false;
        this._currentCameraMode = -1;
        this._thinSSAORenderingPipeline = new ThinSSAO2RenderingPipeline(name13, scene);
        this._scene = scene;
        this._ratio = ratio;
        this._textureType = textureType;
        if (forceGeometryBuffer instanceof GeometryBufferRenderer) {
          this._forceGeometryBuffer = true;
          this._forcedGeometryBuffer = forceGeometryBuffer;
        } else {
          this._forceGeometryBuffer = forceGeometryBuffer;
        }
        if (!this.isSupported) {
          Logger.Error("The current engine does not support SSAO 2.");
          return;
        }
        const ssaoRatio = this._ratio.ssaoRatio || ratio;
        const blurRatio = this._ratio.blurRatio || ratio;
        if (this._forceGeometryBuffer) {
          if (!this._forcedGeometryBuffer) {
            scene.enableGeometryBufferRenderer();
          }
          if (scene.geometryBufferRenderer?.generateNormalsInWorldSpace) {
            Logger.Error("SSAO2RenderingPipeline does not support generateNormalsInWorldSpace=true for the geometry buffer renderer!");
          }
        } else {
          scene.enablePrePassRenderer();
          if (scene.prePassRenderer?.generateNormalsInWorldSpace) {
            Logger.Error("SSAO2RenderingPipeline does not support generateNormalsInWorldSpace=true for the prepass renderer!");
          }
        }
        this._originalColorPostProcess = new PassPostProcess("SSAOOriginalSceneColor", 1, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), void 0, this._textureType);
        this._originalColorPostProcess.onBeforeRenderObservable.add(() => {
          const camera = this._scene.activeCamera;
          this._thinSSAORenderingPipeline._ssaoPostProcess.camera = camera;
          if (camera && this._currentCameraMode !== camera.mode) {
            this._currentCameraMode = camera.mode;
            this._thinSSAORenderingPipeline._ssaoPostProcess.updateEffect();
          }
        });
        this._originalColorPostProcess.samples = this.textureSamples;
        this._createSSAOPostProcess(1, textureType);
        this._createBlurPostProcess(ssaoRatio, blurRatio, this._textureType);
        this._createSSAOCombinePostProcess(blurRatio, this._textureType);
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOOriginalSceneColorEffect, () => {
          return this._originalColorPostProcess;
        }, true));
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAORenderEffect, () => {
          return this._ssaoPostProcess;
        }, true));
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOBlurHRenderEffect, () => {
          return this._blurHPostProcess;
        }, true));
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOBlurVRenderEffect, () => {
          return this._blurVPostProcess;
        }, true));
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOCombineRenderEffect, () => {
          return this._ssaoCombinePostProcess;
        }, true));
        scene.postProcessRenderPipelineManager.addPipeline(this);
        if (cameras) {
          scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name13, cameras);
        }
      }
      // Public Methods
      /**
       * Get the class name
       * @returns "SSAO2RenderingPipeline"
       */
      getClassName() {
        return "SSAO2RenderingPipeline";
      }
      /**
       * Removes the internal pipeline assets and detaches the pipeline from the scene cameras
       * @param disableGeometryBufferRenderer Set to true if you want to disable the Geometry Buffer renderer
       */
      dispose(disableGeometryBufferRenderer = false) {
        for (let i = 0; i < this._scene.cameras.length; i++) {
          const camera = this._scene.cameras[i];
          this._originalColorPostProcess.dispose(camera);
          this._ssaoPostProcess.dispose(camera);
          this._blurHPostProcess.dispose(camera);
          this._blurVPostProcess.dispose(camera);
          this._ssaoCombinePostProcess.dispose(camera);
        }
        if (disableGeometryBufferRenderer && !this._forcedGeometryBuffer) {
          this._scene.disableGeometryBufferRenderer();
        }
        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);
        this._scene.postProcessRenderPipelineManager.removePipeline(this._name);
        this._thinSSAORenderingPipeline.dispose();
        super.dispose();
      }
      // Private Methods
      /** @internal */
      _rebuild() {
        super._rebuild();
      }
      _createBlurPostProcess(ssaoRatio, blurRatio, textureType) {
        this._blurHPostProcess = this._createBlurFilter("BlurH", ssaoRatio, textureType, true);
        this._blurVPostProcess = this._createBlurFilter("BlurV", blurRatio, textureType, false);
      }
      _createBlurFilter(name13, ratio, textureType, horizontal) {
        const blurFilter = new PostProcess(name13, ThinSSAO2BlurPostProcess.FragmentUrl, {
          size: ratio,
          samplingMode: 2,
          engine: this._scene.getEngine(),
          textureType: this._textureType,
          effectWrapper: horizontal ? this._thinSSAORenderingPipeline._ssaoBlurXPostProcess : this._thinSSAORenderingPipeline._ssaoBlurYPostProcess
        });
        blurFilter.onApply = (effect) => {
          const ratio2 = this._ratio.blurRatio || this._ratio;
          const ssaoCombineSize = horizontal ? this._originalColorPostProcess.width * ratio2 : this._originalColorPostProcess.height * ratio2;
          const originalColorSize = horizontal ? this._originalColorPostProcess.width : this._originalColorPostProcess.height;
          this._thinSSAORenderingPipeline._ssaoBlurXPostProcess.textureSize = ssaoCombineSize > 0 ? ssaoCombineSize : originalColorSize;
          this._thinSSAORenderingPipeline._ssaoBlurYPostProcess.textureSize = ssaoCombineSize > 0 ? ssaoCombineSize : originalColorSize;
          if (this._geometryBufferRenderer) {
            effect.setTexture("depthSampler", this._geometryBufferRenderer.getGBuffer().textures[0]);
          } else if (this._prePassRenderer) {
            effect.setTexture("depthSampler", this._prePassRenderer.getRenderTarget().textures[this._prePassRenderer.getIndex(5)]);
          }
        };
        blurFilter.samples = this.textureSamples;
        blurFilter.autoClear = false;
        return blurFilter;
      }
      _getTextureSize() {
        const engine = this._scene.getEngine();
        const prePassRenderer = this._prePassRenderer;
        let textureSize = { width: engine.getRenderWidth(), height: engine.getRenderHeight() };
        if (prePassRenderer && this._scene.activeCamera?._getFirstPostProcess() === this._ssaoPostProcess) {
          const renderTarget = prePassRenderer.getRenderTarget();
          if (renderTarget && renderTarget.textures) {
            textureSize = renderTarget.textures[prePassRenderer.getIndex(4)].getSize();
          }
        } else if (this._ssaoPostProcess.inputTexture) {
          textureSize.width = this._ssaoPostProcess.inputTexture.width;
          textureSize.height = this._ssaoPostProcess.inputTexture.height;
        }
        return textureSize;
      }
      _createSSAOPostProcess(ratio, textureType) {
        this._ssaoPostProcess = new PostProcess("ssao", ThinSSAO2PostProcess.FragmentUrl, {
          size: ratio,
          samplingMode: 2,
          engine: this._scene.getEngine(),
          textureType,
          effectWrapper: this._thinSSAORenderingPipeline._ssaoPostProcess
        });
        this._ssaoPostProcess.autoClear = false;
        this._ssaoPostProcess.onApply = (effect) => {
          if (this._geometryBufferRenderer) {
            effect.setTexture("depthSampler", this._geometryBufferRenderer.getGBuffer().textures[0]);
            effect.setTexture("normalSampler", this._geometryBufferRenderer.getGBuffer().textures[1]);
          } else if (this._prePassRenderer) {
            effect.setTexture("depthSampler", this._prePassRenderer.getRenderTarget().textures[this._prePassRenderer.getIndex(5)]);
            effect.setTexture("normalSampler", this._prePassRenderer.getRenderTarget().textures[this._prePassRenderer.getIndex(6)]);
          }
          const textureSize = this._getTextureSize();
          this._thinSSAORenderingPipeline._ssaoPostProcess.textureWidth = textureSize.width;
          this._thinSSAORenderingPipeline._ssaoPostProcess.textureHeight = textureSize.height;
        };
        this._ssaoPostProcess.samples = this.textureSamples;
        if (!this._forceGeometryBuffer) {
          this._ssaoPostProcess._prePassEffectConfiguration = new SSAO2Configuration();
        }
      }
      _createSSAOCombinePostProcess(ratio, textureType) {
        this._ssaoCombinePostProcess = new PostProcess("ssaoCombine", ThinSSAO2CombinePostProcess.FragmentUrl, {
          size: ratio,
          samplingMode: 2,
          engine: this._scene.getEngine(),
          textureType,
          effectWrapper: this._thinSSAORenderingPipeline._ssaoCombinePostProcess
        });
        this._ssaoCombinePostProcess.onApply = (effect) => {
          this._thinSSAORenderingPipeline._ssaoCombinePostProcess.camera = this._scene.activeCamera;
          effect.setTextureFromPostProcessOutput("originalColor", this._originalColorPostProcess);
        };
        this._ssaoCombinePostProcess.autoClear = false;
        this._ssaoCombinePostProcess.samples = this.textureSamples;
      }
      /**
       * Serialize the rendering pipeline (Used when exporting)
       * @returns the serialized object
       */
      serialize() {
        const serializationObject = SerializationHelper.Serialize(this);
        serializationObject.customType = "SSAO2RenderingPipeline";
        return serializationObject;
      }
      /**
       * Parse the serialized pipeline
       * @param source Source pipeline.
       * @param scene The scene to load the pipeline to.
       * @param rootUrl The URL of the serialized pipeline.
       * @returns An instantiated pipeline from the serialized object.
       */
      static Parse(source, scene, rootUrl) {
        return SerializationHelper.Parse(() => new _SSAO2RenderingPipeline(source._name, scene, source._ratio, void 0, source._forceGeometryBuffer, source._textureType), source, scene, rootUrl);
      }
    };
    __decorate([
      serialize()
    ], SSAO2RenderingPipeline.prototype, "totalStrength", null);
    __decorate([
      serialize()
    ], SSAO2RenderingPipeline.prototype, "maxZ", null);
    __decorate([
      serialize()
    ], SSAO2RenderingPipeline.prototype, "minZAspect", null);
    __decorate([
      serialize("epsilon")
    ], SSAO2RenderingPipeline.prototype, "epsilon", null);
    __decorate([
      serialize("samples")
    ], SSAO2RenderingPipeline.prototype, "samples", null);
    __decorate([
      serialize("textureSamples")
    ], SSAO2RenderingPipeline.prototype, "_textureSamples", void 0);
    __decorate([
      serialize()
    ], SSAO2RenderingPipeline.prototype, "_forceGeometryBuffer", void 0);
    __decorate([
      serialize()
    ], SSAO2RenderingPipeline.prototype, "_ratio", void 0);
    __decorate([
      serialize()
    ], SSAO2RenderingPipeline.prototype, "_textureType", void 0);
    __decorate([
      serialize()
    ], SSAO2RenderingPipeline.prototype, "radius", null);
    __decorate([
      serialize()
    ], SSAO2RenderingPipeline.prototype, "base", null);
    __decorate([
      serialize("bypassBlur")
    ], SSAO2RenderingPipeline.prototype, "bypassBlur", null);
    __decorate([
      serialize("expensiveBlur")
    ], SSAO2RenderingPipeline.prototype, "expensiveBlur", null);
    __decorate([
      serialize()
    ], SSAO2RenderingPipeline.prototype, "bilateralSamples", null);
    __decorate([
      serialize()
    ], SSAO2RenderingPipeline.prototype, "bilateralSoften", null);
    __decorate([
      serialize()
    ], SSAO2RenderingPipeline.prototype, "bilateralTolerance", null);
    RegisterClass("BABYLON.SSAO2RenderingPipeline", SSAO2RenderingPipeline);
  }
});

// node_modules/@babylonjs/core/Shaders/ssao.fragment.js
var name12, shader12;
var init_ssao_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/ssao.fragment.js"() {
    init_shaderStore();
    name12 = "ssaoPixelShader";
    shader12 = `uniform sampler2D textureSampler;varying vec2 vUV;
#ifdef SSAO
uniform sampler2D randomSampler;uniform float randTextureTiles;uniform float samplesFactor;uniform vec3 sampleSphere[SAMPLES];uniform float totalStrength;uniform float radius;uniform float area;uniform float fallOff;uniform float base;vec3 normalFromDepth(float depth,vec2 coords)
{vec2 offset1=vec2(0.0,radius);vec2 offset2=vec2(radius,0.0);float depth1=texture2D(textureSampler,coords+offset1).r;float depth2=texture2D(textureSampler,coords+offset2).r;vec3 p1=vec3(offset1,depth1-depth);vec3 p2=vec3(offset2,depth2-depth);vec3 normal=cross(p1,p2);normal.z=-normal.z;return normalize(normal);}
void main()
{vec3 random=normalize(texture2D(randomSampler,vUV*randTextureTiles).rgb);float depth=texture2D(textureSampler,vUV).r;vec3 position=vec3(vUV,depth);vec3 normal=normalFromDepth(depth,vUV);float radiusDepth=radius/depth;float occlusion=0.0;vec3 ray;vec3 hemiRay;float occlusionDepth;float difference;for (int i=0; i<SAMPLES; i++)
{ray=radiusDepth*reflect(sampleSphere[i],random);hemiRay=position+sign(dot(ray,normal))*ray;occlusionDepth=texture2D(textureSampler,clamp(hemiRay.xy,vec2(0.001,0.001),vec2(0.999,0.999))).r;difference=depth-occlusionDepth;occlusion+=step(fallOff,difference)*(1.0-smoothstep(fallOff,area,difference));}
float ao=1.0-totalStrength*occlusion*samplesFactor;float result=clamp(ao+base,0.0,1.0);gl_FragColor.r=result;gl_FragColor.g=result;gl_FragColor.b=result;gl_FragColor.a=1.0;}
#endif
`;
    if (!ShaderStore.ShadersStore[name12]) {
      ShaderStore.ShadersStore[name12] = shader12;
    }
  }
});

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/ssaoRenderingPipeline.js
var SSAORenderingPipeline;
var init_ssaoRenderingPipeline = __esm({
  "node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/ssaoRenderingPipeline.js"() {
    init_tslib_es6();
    init_math_vector();
    init_texture();
    init_postProcess();
    init_postProcessRenderPipeline();
    init_postProcessRenderEffect();
    init_passPostProcess();
    init_blurPostProcess();
    init_decorators();
    init_rawTexture();
    init_math_scalar_functions();
    init_postProcessRenderPipelineManagerSceneComponent();
    init_ssao_fragment();
    init_ssaoCombine_fragment();
    SSAORenderingPipeline = class extends PostProcessRenderPipeline {
      /**
       * Gets active scene
       */
      get scene() {
        return this._scene;
      }
      /**
       * @constructor
       * @param name - The rendering pipeline name
       * @param scene - The scene linked to this pipeline
       * @param ratio - The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, combineRatio: 1.0 }
       * @param cameras - The array of cameras that the rendering pipeline will be attached to
       */
      constructor(name13, scene, ratio, cameras) {
        super(scene.getEngine(), name13);
        this.SSAOOriginalSceneColorEffect = "SSAOOriginalSceneColorEffect";
        this.SSAORenderEffect = "SSAORenderEffect";
        this.SSAOBlurHRenderEffect = "SSAOBlurHRenderEffect";
        this.SSAOBlurVRenderEffect = "SSAOBlurVRenderEffect";
        this.SSAOCombineRenderEffect = "SSAOCombineRenderEffect";
        this.totalStrength = 1;
        this.radius = 1e-4;
        this.area = 75e-4;
        this.fallOff = 1e-6;
        this.base = 0.5;
        this._firstUpdate = true;
        this._scene = scene;
        this._createRandomTexture();
        const ssaoRatio = ratio.ssaoRatio || ratio;
        const combineRatio = ratio.combineRatio || ratio;
        this._originalColorPostProcess = new PassPostProcess("SSAOOriginalSceneColor", combineRatio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false);
        this._createSSAOPostProcess(ssaoRatio);
        this._createBlurPostProcess(ssaoRatio);
        this._createSSAOCombinePostProcess(combineRatio);
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOOriginalSceneColorEffect, () => {
          return this._originalColorPostProcess;
        }, true));
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAORenderEffect, () => {
          return this._ssaoPostProcess;
        }, true));
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOBlurHRenderEffect, () => {
          return this._blurHPostProcess;
        }, true));
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOBlurVRenderEffect, () => {
          return this._blurVPostProcess;
        }, true));
        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.SSAOCombineRenderEffect, () => {
          return this._ssaoCombinePostProcess;
        }, true));
        scene.postProcessRenderPipelineManager.addPipeline(this);
        if (cameras) {
          scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name13, cameras);
        }
      }
      /**
       * @internal
       */
      _attachCameras(cameras, unique) {
        super._attachCameras(cameras, unique);
        for (const camera of this._cameras) {
          this._scene.enableDepthRenderer(camera).getDepthMap();
        }
      }
      // Public Methods
      /**
       * Get the class name
       * @returns "SSAORenderingPipeline"
       */
      getClassName() {
        return "SSAORenderingPipeline";
      }
      /**
       * Removes the internal pipeline assets and detaches the pipeline from the scene cameras
       * @param disableDepthRender - If the depth renderer should be disabled on the scene
       */
      dispose(disableDepthRender = false) {
        for (let i = 0; i < this._scene.cameras.length; i++) {
          const camera = this._scene.cameras[i];
          this._originalColorPostProcess.dispose(camera);
          this._ssaoPostProcess.dispose(camera);
          this._blurHPostProcess.dispose(camera);
          this._blurVPostProcess.dispose(camera);
          this._ssaoCombinePostProcess.dispose(camera);
        }
        this._randomTexture.dispose();
        if (disableDepthRender) {
          this._scene.disableDepthRenderer();
        }
        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);
        this._scene.postProcessRenderPipelineManager.removePipeline(this._name);
        super.dispose();
      }
      // Private Methods
      _createBlurPostProcess(ratio) {
        const size = 16;
        this._blurHPostProcess = new BlurPostProcess("BlurH", new Vector2(1, 0), size, ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, 0);
        this._blurVPostProcess = new BlurPostProcess("BlurV", new Vector2(0, 1), size, ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, 0);
        this._blurHPostProcess.onActivateObservable.add(() => {
          const dw = this._blurHPostProcess.width / this._scene.getEngine().getRenderWidth();
          this._blurHPostProcess.kernel = size * dw;
        });
        this._blurVPostProcess.onActivateObservable.add(() => {
          const dw = this._blurVPostProcess.height / this._scene.getEngine().getRenderHeight();
          this._blurVPostProcess.kernel = size * dw;
        });
      }
      /** @internal */
      _rebuild() {
        this._firstUpdate = true;
        super._rebuild();
      }
      _createSSAOPostProcess(ratio) {
        const numSamples = 16;
        const sampleSphere = [
          0.5381,
          0.1856,
          -0.4319,
          0.1379,
          0.2486,
          0.443,
          0.3371,
          0.5679,
          -57e-4,
          -0.6999,
          -0.0451,
          -19e-4,
          0.0689,
          -0.1598,
          -0.8547,
          0.056,
          69e-4,
          -0.1843,
          -0.0146,
          0.1402,
          0.0762,
          0.01,
          -0.1924,
          -0.0344,
          -0.3577,
          -0.5301,
          -0.4358,
          -0.3169,
          0.1063,
          0.0158,
          0.0103,
          -0.5869,
          46e-4,
          -0.0897,
          -0.494,
          0.3287,
          0.7119,
          -0.0154,
          -0.0918,
          -0.0533,
          0.0596,
          -0.5411,
          0.0352,
          -0.0631,
          0.546,
          -0.4776,
          0.2847,
          -0.0271
        ];
        const samplesFactor = 1 / numSamples;
        this._ssaoPostProcess = new PostProcess("ssao", "ssao", ["sampleSphere", "samplesFactor", "randTextureTiles", "totalStrength", "radius", "area", "fallOff", "base", "range", "viewport"], ["randomSampler"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, "#define SAMPLES " + numSamples + "\n#define SSAO");
        this._ssaoPostProcess.externalTextureSamplerBinding = true;
        this._ssaoPostProcess.onApply = (effect) => {
          if (this._firstUpdate) {
            effect.setArray3("sampleSphere", sampleSphere);
            effect.setFloat("samplesFactor", samplesFactor);
            effect.setFloat("randTextureTiles", 4);
          }
          effect.setFloat("totalStrength", this.totalStrength);
          effect.setFloat("radius", this.radius);
          effect.setFloat("area", this.area);
          effect.setFloat("fallOff", this.fallOff);
          effect.setFloat("base", this.base);
          effect.setTexture("textureSampler", this._scene.enableDepthRenderer(this._scene.activeCamera).getDepthMap());
          effect.setTexture("randomSampler", this._randomTexture);
        };
      }
      _createSSAOCombinePostProcess(ratio) {
        this._ssaoCombinePostProcess = new PostProcess("ssaoCombine", "ssaoCombine", [], ["originalColor", "viewport"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);
        this._ssaoCombinePostProcess.onApply = (effect) => {
          effect.setVector4("viewport", TmpVectors.Vector4[0].copyFromFloats(0, 0, 1, 1));
          effect.setTextureFromPostProcess("originalColor", this._originalColorPostProcess);
        };
      }
      _createRandomTexture() {
        const size = 512;
        const data = new Uint8Array(size * size * 4);
        for (let index = 0; index < data.length; ) {
          data[index++] = Math.floor(Math.max(0, RandomRange(-1, 1)) * 255);
          data[index++] = Math.floor(Math.max(0, RandomRange(-1, 1)) * 255);
          data[index++] = Math.floor(Math.max(0, RandomRange(-1, 1)) * 255);
          data[index++] = 255;
        }
        const texture = RawTexture.CreateRGBATexture(data, size, size, this._scene, false, false, 2);
        texture.name = "SSAORandomTexture";
        texture.wrapU = Texture.WRAP_ADDRESSMODE;
        texture.wrapV = Texture.WRAP_ADDRESSMODE;
        this._randomTexture = texture;
      }
    };
    __decorate([
      serialize()
    ], SSAORenderingPipeline.prototype, "totalStrength", void 0);
    __decorate([
      serialize()
    ], SSAORenderingPipeline.prototype, "radius", void 0);
    __decorate([
      serialize()
    ], SSAORenderingPipeline.prototype, "area", void 0);
    __decorate([
      serialize()
    ], SSAORenderingPipeline.prototype, "fallOff", void 0);
    __decorate([
      serialize()
    ], SSAORenderingPipeline.prototype, "base", void 0);
  }
});

// node_modules/@babylonjs/core/Rendering/screenSpaceReflections2Configuration.js
var ScreenSpaceReflections2Configuration;
var init_screenSpaceReflections2Configuration = __esm({
  "node_modules/@babylonjs/core/Rendering/screenSpaceReflections2Configuration.js"() {
    ScreenSpaceReflections2Configuration = class {
      /**
       * @param useScreenspaceDepth If the effect should use the screenspace depth texture instead of a linear one
       */
      constructor(useScreenspaceDepth = false) {
        this.enabled = false;
        this.name = "screenSpaceReflections2";
        this.texturesRequired = [6, 3];
        this.texturesRequired.push(useScreenspaceDepth ? 10 : 5);
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinSSRPostProcess.js
var Trs, TrsWebGPU, ThinSSRPostProcess;
var init_thinSSRPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinSSRPostProcess.js"() {
    init_effectRenderer();
    init_math_vector();
    Trs = Matrix.Compose(new Vector3(0.5, 0.5, 0.5), Quaternion.Identity(), new Vector3(0.5, 0.5, 0.5));
    TrsWebGPU = Matrix.Compose(new Vector3(0.5, 0.5, 1), Quaternion.Identity(), new Vector3(0.5, 0.5, 0));
    ThinSSRPostProcess = class _ThinSSRPostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(import("./screenSpaceReflection2.fragment-NOECSRFX.js"));
        } else {
          list.push(import("./screenSpaceReflection2.fragment-6JWAIBC4.js"));
        }
      }
      get reflectivityThreshold() {
        return this._reflectivityThreshold;
      }
      set reflectivityThreshold(threshold) {
        if (threshold === this._reflectivityThreshold) {
          return;
        }
        if (threshold === 0 && this._reflectivityThreshold !== 0 || threshold !== 0 && this._reflectivityThreshold === 0) {
          this._reflectivityThreshold = threshold;
          this._updateEffectDefines();
        } else {
          this._reflectivityThreshold = threshold;
        }
      }
      get useBlur() {
        return this._useBlur;
      }
      set useBlur(blur) {
        if (this._useBlur === blur) {
          return;
        }
        this._useBlur = blur;
        this._updateEffectDefines();
      }
      get enableSmoothReflections() {
        return this._enableSmoothReflections;
      }
      set enableSmoothReflections(enabled) {
        if (enabled === this._enableSmoothReflections) {
          return;
        }
        this._enableSmoothReflections = enabled;
        this._updateEffectDefines();
      }
      get environmentTexture() {
        return this._environmentTexture;
      }
      set environmentTexture(texture) {
        this._environmentTexture = texture;
        this._updateEffectDefines();
      }
      get environmentTextureIsProbe() {
        return this._environmentTextureIsProbe;
      }
      set environmentTextureIsProbe(isProbe) {
        this._environmentTextureIsProbe = isProbe;
        this._updateEffectDefines();
      }
      get attenuateScreenBorders() {
        return this._attenuateScreenBorders;
      }
      set attenuateScreenBorders(attenuate) {
        if (this._attenuateScreenBorders === attenuate) {
          return;
        }
        this._attenuateScreenBorders = attenuate;
        this._updateEffectDefines();
      }
      get attenuateIntersectionDistance() {
        return this._attenuateIntersectionDistance;
      }
      set attenuateIntersectionDistance(attenuate) {
        if (this._attenuateIntersectionDistance === attenuate) {
          return;
        }
        this._attenuateIntersectionDistance = attenuate;
        this._updateEffectDefines();
      }
      get attenuateIntersectionIterations() {
        return this._attenuateIntersectionIterations;
      }
      set attenuateIntersectionIterations(attenuate) {
        if (this._attenuateIntersectionIterations === attenuate) {
          return;
        }
        this._attenuateIntersectionIterations = attenuate;
        this._updateEffectDefines();
      }
      get attenuateFacingCamera() {
        return this._attenuateFacingCamera;
      }
      set attenuateFacingCamera(attenuate) {
        if (this._attenuateFacingCamera === attenuate) {
          return;
        }
        this._attenuateFacingCamera = attenuate;
        this._updateEffectDefines();
      }
      get attenuateBackfaceReflection() {
        return this._attenuateBackfaceReflection;
      }
      set attenuateBackfaceReflection(attenuate) {
        if (this._attenuateBackfaceReflection === attenuate) {
          return;
        }
        this._attenuateBackfaceReflection = attenuate;
        this._updateEffectDefines();
      }
      get clipToFrustum() {
        return this._clipToFrustum;
      }
      set clipToFrustum(clip) {
        if (this._clipToFrustum === clip) {
          return;
        }
        this._clipToFrustum = clip;
        this._updateEffectDefines();
      }
      get useFresnel() {
        return this._useFresnel;
      }
      set useFresnel(fresnel) {
        if (this._useFresnel === fresnel) {
          return;
        }
        this._useFresnel = fresnel;
        this._updateEffectDefines();
      }
      get enableAutomaticThicknessComputation() {
        return this._enableAutomaticThicknessComputation;
      }
      set enableAutomaticThicknessComputation(automatic) {
        if (this._enableAutomaticThicknessComputation === automatic) {
          return;
        }
        this._enableAutomaticThicknessComputation = automatic;
        this._updateEffectDefines();
      }
      get inputTextureColorIsInGammaSpace() {
        return this._inputTextureColorIsInGammaSpace;
      }
      set inputTextureColorIsInGammaSpace(gammaSpace) {
        if (this._inputTextureColorIsInGammaSpace === gammaSpace) {
          return;
        }
        this._inputTextureColorIsInGammaSpace = gammaSpace;
        this._updateEffectDefines();
      }
      get generateOutputInGammaSpace() {
        return this._generateOutputInGammaSpace;
      }
      set generateOutputInGammaSpace(gammaSpace) {
        if (this._generateOutputInGammaSpace === gammaSpace) {
          return;
        }
        this._generateOutputInGammaSpace = gammaSpace;
        this._updateEffectDefines();
      }
      get debug() {
        return this._debug;
      }
      set debug(value) {
        if (this._debug === value) {
          return;
        }
        this._debug = value;
        this._updateEffectDefines();
      }
      get textureWidth() {
        return this._textureWidth;
      }
      set textureWidth(width) {
        if (this._textureWidth === width) {
          return;
        }
        this._textureWidth = width;
      }
      get textureHeight() {
        return this._textureHeight;
      }
      set textureHeight(height) {
        if (this._textureHeight === height) {
          return;
        }
        this._textureHeight = height;
      }
      get useScreenspaceDepth() {
        return this._useScreenspaceDepth;
      }
      set useScreenspaceDepth(value) {
        if (this._useScreenspaceDepth === value) {
          return;
        }
        this._useScreenspaceDepth = value;
        this._updateEffectDefines();
      }
      get normalsAreInWorldSpace() {
        return this._normalsAreInWorldSpace;
      }
      set normalsAreInWorldSpace(value) {
        if (this._normalsAreInWorldSpace === value) {
          return;
        }
        this._normalsAreInWorldSpace = value;
        this._updateEffectDefines();
      }
      get normalsAreUnsigned() {
        return this._normalsAreUnsigned;
      }
      set normalsAreUnsigned(value) {
        if (this._normalsAreUnsigned === value) {
          return;
        }
        this._normalsAreUnsigned = value;
        this._updateEffectDefines();
      }
      constructor(name13, scene, options) {
        super({
          ...options,
          name: name13,
          engine: scene.getEngine(),
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinSSRPostProcess.FragmentUrl,
          uniforms: _ThinSSRPostProcess.Uniforms,
          samplers: _ThinSSRPostProcess.Samplers,
          shaderLanguage: scene.getEngine().isWebGPU ? 1 : 0
        });
        this.isSSRSupported = true;
        this.maxDistance = 1e3;
        this.step = 1;
        this.thickness = 0.5;
        this.strength = 1;
        this.reflectionSpecularFalloffExponent = 1;
        this.maxSteps = 1e3;
        this.roughnessFactor = 0.2;
        this.selfCollisionNumSkip = 1;
        this._reflectivityThreshold = 0.04;
        this._useBlur = false;
        this._enableSmoothReflections = false;
        this._environmentTextureIsProbe = false;
        this._attenuateScreenBorders = true;
        this._attenuateIntersectionDistance = true;
        this._attenuateIntersectionIterations = true;
        this._attenuateFacingCamera = false;
        this._attenuateBackfaceReflection = false;
        this._clipToFrustum = true;
        this._useFresnel = false;
        this._enableAutomaticThicknessComputation = false;
        this._inputTextureColorIsInGammaSpace = true;
        this._generateOutputInGammaSpace = true;
        this._debug = false;
        this._textureWidth = 0;
        this._textureHeight = 0;
        this.camera = null;
        this._useScreenspaceDepth = false;
        this._normalsAreInWorldSpace = false;
        this._normalsAreUnsigned = false;
        this._scene = scene;
        this._updateEffectDefines();
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        const effect = this._drawWrapper.effect;
        const camera = this.camera;
        if (!camera) {
          return;
        }
        const viewMatrix = camera.getViewMatrix();
        const projectionMatrix = camera.getProjectionMatrix();
        projectionMatrix.invertToRef(TmpVectors.Matrix[0]);
        viewMatrix.invertToRef(TmpVectors.Matrix[1]);
        effect.setMatrix("projection", projectionMatrix);
        effect.setMatrix("view", viewMatrix);
        effect.setMatrix("invView", TmpVectors.Matrix[1]);
        effect.setMatrix("invProjectionMatrix", TmpVectors.Matrix[0]);
        effect.setFloat("thickness", this.thickness);
        effect.setFloat("reflectionSpecularFalloffExponent", this.reflectionSpecularFalloffExponent);
        effect.setFloat("strength", this.strength);
        effect.setFloat("stepSize", this.step);
        effect.setFloat("maxSteps", this.maxSteps);
        effect.setFloat("roughnessFactor", this.roughnessFactor);
        effect.setFloat("nearPlaneZ", camera.minZ);
        effect.setFloat("farPlaneZ", camera.maxZ);
        effect.setFloat("maxDistance", this.maxDistance);
        effect.setFloat("selfCollisionNumSkip", this.selfCollisionNumSkip);
        effect.setFloat("reflectivityThreshold", this._reflectivityThreshold);
        Matrix.ScalingToRef(this.textureWidth, this.textureHeight, 1, TmpVectors.Matrix[2]);
        projectionMatrix.multiplyToRef(this._scene.getEngine().isWebGPU ? TrsWebGPU : Trs, TmpVectors.Matrix[3]);
        TmpVectors.Matrix[3].multiplyToRef(TmpVectors.Matrix[2], TmpVectors.Matrix[4]);
        effect.setMatrix("projectionPixel", TmpVectors.Matrix[4]);
        if (this._environmentTexture) {
          effect.setTexture("envCubeSampler", this._environmentTexture);
          if (this._environmentTexture.boundingBoxSize) {
            effect.setVector3("vReflectionPosition", this._environmentTexture.boundingBoxPosition);
            effect.setVector3("vReflectionSize", this._environmentTexture.boundingBoxSize);
          }
        }
      }
      _updateEffectDefines() {
        const defines = [];
        if (this.isSSRSupported) {
          defines.push("#define SSR_SUPPORTED");
        }
        if (this._enableSmoothReflections) {
          defines.push("#define SSRAYTRACE_ENABLE_REFINEMENT");
        }
        if (this._scene.useRightHandedSystem) {
          defines.push("#define SSRAYTRACE_RIGHT_HANDED_SCENE");
        }
        if (this._useScreenspaceDepth) {
          defines.push("#define SSRAYTRACE_SCREENSPACE_DEPTH");
        }
        if (this._environmentTexture) {
          defines.push("#define SSR_USE_ENVIRONMENT_CUBE");
          if (this._environmentTexture.boundingBoxSize) {
            defines.push("#define SSR_USE_LOCAL_REFLECTIONMAP_CUBIC");
          }
          if (this._environmentTexture.gammaSpace) {
            defines.push("#define SSR_ENVIRONMENT_CUBE_IS_GAMMASPACE");
          }
        }
        if (this._environmentTextureIsProbe) {
          defines.push("#define SSR_INVERTCUBICMAP");
        }
        if (this._enableAutomaticThicknessComputation) {
          defines.push("#define SSRAYTRACE_USE_BACK_DEPTHBUFFER");
        }
        if (this._attenuateScreenBorders) {
          defines.push("#define SSR_ATTENUATE_SCREEN_BORDERS");
        }
        if (this._attenuateIntersectionDistance) {
          defines.push("#define SSR_ATTENUATE_INTERSECTION_DISTANCE");
        }
        if (this._attenuateIntersectionIterations) {
          defines.push("#define SSR_ATTENUATE_INTERSECTION_NUMITERATIONS");
        }
        if (this._attenuateFacingCamera) {
          defines.push("#define SSR_ATTENUATE_FACING_CAMERA");
        }
        if (this._attenuateBackfaceReflection) {
          defines.push("#define SSR_ATTENUATE_BACKFACE_REFLECTION");
        }
        if (this._clipToFrustum) {
          defines.push("#define SSRAYTRACE_CLIP_TO_FRUSTUM");
        }
        if (this.useBlur) {
          defines.push("#define SSR_USE_BLUR");
        }
        if (this._debug) {
          defines.push("#define SSRAYTRACE_DEBUG");
        }
        if (this._inputTextureColorIsInGammaSpace) {
          defines.push("#define SSR_INPUT_IS_GAMMA_SPACE");
        }
        if (this._generateOutputInGammaSpace) {
          defines.push("#define SSR_OUTPUT_IS_GAMMA_SPACE");
        }
        if (this._useFresnel) {
          defines.push("#define SSR_BLEND_WITH_FRESNEL");
        }
        if (this._reflectivityThreshold === 0) {
          defines.push("#define SSR_DISABLE_REFLECTIVITY_TEST");
        }
        if (this._normalsAreInWorldSpace) {
          defines.push("#define SSR_NORMAL_IS_IN_WORLDSPACE");
        }
        if (this._normalsAreUnsigned) {
          defines.push("#define SSR_DECODE_NORMAL");
        }
        if (this.camera && this.camera.mode === 1) {
          defines.push("#define ORTHOGRAPHIC_CAMERA");
        }
        this.updateEffect(defines.join("\n"));
      }
    };
    ThinSSRPostProcess.FragmentUrl = "screenSpaceReflection2";
    ThinSSRPostProcess.Uniforms = [
      "projection",
      "invProjectionMatrix",
      "view",
      "invView",
      "thickness",
      "reflectionSpecularFalloffExponent",
      "strength",
      "stepSize",
      "maxSteps",
      "roughnessFactor",
      "projectionPixel",
      "nearPlaneZ",
      "farPlaneZ",
      "maxDistance",
      "selfCollisionNumSkip",
      "vReflectionPosition",
      "vReflectionSize",
      "backSizeFactor",
      "reflectivityThreshold"
    ];
    ThinSSRPostProcess.Samplers = ["textureSampler", "normalSampler", "reflectivitySampler", "depthSampler", "envCubeSampler", "backDepthSampler"];
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinSSRBlurPostProcess.js
var ThinSSRBlurPostProcess;
var init_thinSSRBlurPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinSSRBlurPostProcess.js"() {
    init_effectRenderer();
    init_engine();
    init_math_vector();
    ThinSSRBlurPostProcess = class _ThinSSRBlurPostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(import("./screenSpaceReflection2Blur.fragment-WPUXCZFU.js"));
        } else {
          list.push(import("./screenSpaceReflection2Blur.fragment-G44VPEOQ.js"));
        }
      }
      constructor(name13, engine = null, direction, blurStrength, options) {
        super({
          ...options,
          name: name13,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinSSRBlurPostProcess.FragmentUrl,
          uniforms: _ThinSSRBlurPostProcess.Uniforms,
          samplers: _ThinSSRBlurPostProcess.Samplers
        });
        this.textureWidth = 0;
        this.textureHeight = 0;
        this.direction = new Vector2(1, 0);
        this.blurStrength = 0.03;
        if (direction !== void 0) {
          this.direction = direction;
        }
        if (blurStrength !== void 0) {
          this.blurStrength = blurStrength;
        }
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        this._drawWrapper.effect.setFloat2("texelOffsetScale", 1 / this.textureWidth * this.direction.x * this.blurStrength, 1 / this.textureHeight * this.direction.y * this.blurStrength);
      }
    };
    ThinSSRBlurPostProcess.FragmentUrl = "screenSpaceReflection2Blur";
    ThinSSRBlurPostProcess.Uniforms = ["texelOffsetScale"];
    ThinSSRBlurPostProcess.Samplers = ["textureSampler"];
  }
});

// node_modules/@babylonjs/core/PostProcesses/thinSSRBlurCombinerPostProcess.js
var ThinSSRBlurCombinerPostProcess;
var init_thinSSRBlurCombinerPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/thinSSRBlurCombinerPostProcess.js"() {
    init_effectRenderer();
    init_engine();
    init_math_vector();
    ThinSSRBlurCombinerPostProcess = class _ThinSSRBlurCombinerPostProcess extends EffectWrapper {
      _gatherImports(useWebGPU, list) {
        if (useWebGPU) {
          this._webGPUReady = true;
          list.push(import("./screenSpaceReflection2BlurCombiner.fragment-45BAQ6YT.js"));
        } else {
          list.push(import("./screenSpaceReflection2BlurCombiner.fragment-UHEXGVU5.js"));
        }
      }
      constructor(name13, engine = null, options) {
        super({
          ...options,
          name: name13,
          engine: engine || Engine.LastCreatedEngine,
          useShaderStore: true,
          useAsPostProcess: true,
          fragmentShader: _ThinSSRBlurCombinerPostProcess.FragmentUrl,
          uniforms: _ThinSSRBlurCombinerPostProcess.Uniforms,
          samplers: _ThinSSRBlurCombinerPostProcess.Samplers
        });
        this.strength = 1;
        this.reflectionSpecularFalloffExponent = 1;
        this.camera = null;
        this._useFresnel = false;
        this._useScreenspaceDepth = false;
        this._inputTextureColorIsInGammaSpace = true;
        this._generateOutputInGammaSpace = true;
        this._debug = false;
        this._reflectivityThreshold = 0.04;
        this._normalsAreInWorldSpace = false;
        this._normalsAreUnsigned = false;
        this._updateEffectDefines();
      }
      get useFresnel() {
        return this._useFresnel;
      }
      set useFresnel(fresnel) {
        if (this._useFresnel === fresnel) {
          return;
        }
        this._useFresnel = fresnel;
        this._updateEffectDefines();
      }
      get useScreenspaceDepth() {
        return this._useScreenspaceDepth;
      }
      set useScreenspaceDepth(value) {
        if (this._useScreenspaceDepth === value) {
          return;
        }
        this._useScreenspaceDepth = value;
        this._updateEffectDefines();
      }
      get inputTextureColorIsInGammaSpace() {
        return this._inputTextureColorIsInGammaSpace;
      }
      set inputTextureColorIsInGammaSpace(gammaSpace) {
        if (this._inputTextureColorIsInGammaSpace === gammaSpace) {
          return;
        }
        this._inputTextureColorIsInGammaSpace = gammaSpace;
        this._updateEffectDefines();
      }
      get generateOutputInGammaSpace() {
        return this._generateOutputInGammaSpace;
      }
      set generateOutputInGammaSpace(gammaSpace) {
        if (this._generateOutputInGammaSpace === gammaSpace) {
          return;
        }
        this._generateOutputInGammaSpace = gammaSpace;
        this._updateEffectDefines();
      }
      get debug() {
        return this._debug;
      }
      set debug(value) {
        if (this._debug === value) {
          return;
        }
        this._debug = value;
        this._updateEffectDefines();
      }
      get reflectivityThreshold() {
        return this._reflectivityThreshold;
      }
      set reflectivityThreshold(threshold) {
        if (threshold === this._reflectivityThreshold) {
          return;
        }
        if (threshold === 0 && this._reflectivityThreshold !== 0 || threshold !== 0 && this._reflectivityThreshold === 0) {
          this._reflectivityThreshold = threshold;
          this._updateEffectDefines();
        } else {
          this._reflectivityThreshold = threshold;
        }
      }
      get normalsAreInWorldSpace() {
        return this._normalsAreInWorldSpace;
      }
      set normalsAreInWorldSpace(value) {
        if (this._normalsAreInWorldSpace === value) {
          return;
        }
        this._normalsAreInWorldSpace = value;
        this._updateEffectDefines();
      }
      get normalsAreUnsigned() {
        return this._normalsAreUnsigned;
      }
      set normalsAreUnsigned(value) {
        if (this._normalsAreUnsigned === value) {
          return;
        }
        this._normalsAreUnsigned = value;
        this._updateEffectDefines();
      }
      bind(noDefaultBindings = false) {
        super.bind(noDefaultBindings);
        const effect = this._drawWrapper.effect;
        effect.setFloat("strength", this.strength);
        effect.setFloat("reflectionSpecularFalloffExponent", this.reflectionSpecularFalloffExponent);
        effect.setFloat("reflectivityThreshold", this.reflectivityThreshold);
        if (this.useFresnel && this.camera) {
          const projectionMatrix = this.camera.getProjectionMatrix();
          projectionMatrix.invertToRef(TmpVectors.Matrix[0]);
          effect.setMatrix("projection", projectionMatrix);
          effect.setMatrix("invProjectionMatrix", TmpVectors.Matrix[0]);
          effect.setMatrix("view", this.camera.getViewMatrix());
          if (this.useScreenspaceDepth) {
            effect.setFloat("nearPlaneZ", this.camera.minZ);
            effect.setFloat("farPlaneZ", this.camera.maxZ);
          }
        }
      }
      _updateEffectDefines() {
        let defines = "";
        if (this._debug) {
          defines += "#define SSRAYTRACE_DEBUG\n";
        }
        if (this._inputTextureColorIsInGammaSpace) {
          defines += "#define SSR_INPUT_IS_GAMMA_SPACE\n";
        }
        if (this._generateOutputInGammaSpace) {
          defines += "#define SSR_OUTPUT_IS_GAMMA_SPACE\n";
        }
        if (this._useFresnel) {
          defines += "#define SSR_BLEND_WITH_FRESNEL\n";
        }
        if (this._useScreenspaceDepth) {
          defines += "#define SSRAYTRACE_SCREENSPACE_DEPTH\n";
        }
        if (this._reflectivityThreshold === 0) {
          defines += "#define SSR_DISABLE_REFLECTIVITY_TEST\n";
        }
        if (this._normalsAreInWorldSpace) {
          defines += "#define SSR_NORMAL_IS_IN_WORLDSPACE\n";
        }
        if (this._normalsAreUnsigned) {
          defines += "#define SSR_DECODE_NORMAL\n";
        }
        this.updateEffect(defines);
      }
    };
    ThinSSRBlurCombinerPostProcess.FragmentUrl = "screenSpaceReflection2BlurCombiner";
    ThinSSRBlurCombinerPostProcess.Uniforms = [
      "strength",
      "reflectionSpecularFalloffExponent",
      "reflectivityThreshold",
      "projection",
      "invProjectionMatrix",
      "nearPlaneZ",
      "farPlaneZ",
      "view"
    ];
    ThinSSRBlurCombinerPostProcess.Samplers = ["textureSampler", "depthSampler", "normalSampler", "mainSampler", "reflectivitySampler"];
  }
});

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/thinSSRRenderingPipeline.js
var ThinSSRRenderingPipeline;
var init_thinSSRRenderingPipeline = __esm({
  "node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/thinSSRRenderingPipeline.js"() {
    init_math_vector();
    init_thinSSRPostProcess();
    init_thinSSRBlurPostProcess();
    init_thinSSRBlurCombinerPostProcess();
    ThinSSRRenderingPipeline = class {
      /**
       * Gets or sets a boolean indicating if the SSR rendering pipeline is supported
       */
      get isSSRSupported() {
        return this._ssrPostProcess.isSSRSupported;
      }
      set isSSRSupported(supported) {
        this._ssrPostProcess.isSSRSupported = supported;
      }
      /**
       * Gets or sets the maxDistance used to define how far we look for reflection during the ray-marching on the reflected ray (default: 1000).
       * Note that this value is a view (camera) space distance (not pixels!).
       */
      get maxDistance() {
        return this._ssrPostProcess.maxDistance;
      }
      set maxDistance(distance) {
        this._ssrPostProcess.maxDistance = distance;
      }
      /**
       * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Should be an integer \>= 1 as it is the number of pixels we advance at each step (default: 1).
       * Use higher values to improve performances (but at the expense of quality).
       */
      get step() {
        return this._ssrPostProcess.step;
      }
      set step(step) {
        this._ssrPostProcess.step = step;
      }
      /**
       * Gets or sets the thickness value used as tolerance when computing the intersection between the reflected ray and the scene (default: 0.5).
       * If setting "enableAutomaticThicknessComputation" to true, you can use lower values for "thickness" (even 0), as the geometry thickness
       * is automatically computed thank to the regular depth buffer + the backface depth buffer
       */
      get thickness() {
        return this._ssrPostProcess.thickness;
      }
      set thickness(thickness) {
        this._ssrPostProcess.thickness = thickness;
      }
      /**
       * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results (default: 1).
       */
      get strength() {
        return this._ssrPostProcess.strength;
      }
      set strength(strength) {
        this._ssrPostProcess.strength = strength;
        this._ssrBlurCombinerPostProcess.strength = strength;
      }
      /**
       * Gets or sets the falloff exponent used to compute the reflection strength. Higher values lead to fainter reflections (default: 1).
       */
      get reflectionSpecularFalloffExponent() {
        return this._ssrPostProcess.reflectionSpecularFalloffExponent;
      }
      set reflectionSpecularFalloffExponent(exponent) {
        this._ssrPostProcess.reflectionSpecularFalloffExponent = exponent;
        this._ssrBlurCombinerPostProcess.reflectionSpecularFalloffExponent = exponent;
      }
      /**
       * Maximum number of steps during the ray marching process after which we consider an intersection could not be found (default: 1000).
       * Should be an integer value.
       */
      get maxSteps() {
        return this._ssrPostProcess.maxSteps;
      }
      set maxSteps(steps) {
        this._ssrPostProcess.maxSteps = steps;
      }
      /**
       * Gets or sets the factor applied when computing roughness. Default value is 0.2.
       * When blurring based on roughness is enabled (meaning blurDispersionStrength \> 0), roughnessFactor is used as a global roughness factor applied on all objects.
       * If you want to disable this global roughness set it to 0.
       */
      get roughnessFactor() {
        return this._ssrPostProcess.roughnessFactor;
      }
      set roughnessFactor(factor) {
        this._ssrPostProcess.roughnessFactor = factor;
      }
      /**
       * Number of steps to skip at start when marching the ray to avoid self collisions (default: 1)
       * 1 should normally be a good value, depending on the scene you may need to use a higher value (2 or 3)
       */
      get selfCollisionNumSkip() {
        return this._ssrPostProcess.selfCollisionNumSkip;
      }
      set selfCollisionNumSkip(skip) {
        this._ssrPostProcess.selfCollisionNumSkip = skip;
      }
      /**
       * Gets or sets the minimum value for one of the reflectivity component of the material to consider it for SSR (default: 0.04).
       * If all r/g/b components of the reflectivity is below or equal this value, the pixel will not be considered reflective and SSR won't be applied.
       */
      get reflectivityThreshold() {
        return this._ssrPostProcess.reflectivityThreshold;
      }
      set reflectivityThreshold(threshold) {
        const currentThreshold = this._ssrPostProcess.reflectivityThreshold;
        if (threshold === currentThreshold) {
          return;
        }
        this._ssrPostProcess.reflectivityThreshold = threshold;
        this._ssrBlurCombinerPostProcess.reflectivityThreshold = threshold;
      }
      /**
       * Gets or sets the blur dispersion strength. Set this value to 0 to disable blurring (default: 0.03)
       * The reflections are blurred based on the roughness of the surface and the distance between the pixel shaded and the reflected pixel: the higher the distance the more blurry the reflection is.
       * blurDispersionStrength allows to increase or decrease this effect.
       */
      get blurDispersionStrength() {
        return this._ssrBlurXPostProcess.blurStrength;
      }
      set blurDispersionStrength(strength) {
        if (strength === this._ssrBlurXPostProcess.blurStrength) {
          return;
        }
        this._ssrPostProcess.useBlur = strength > 0;
        this._ssrBlurXPostProcess.blurStrength = strength;
        this._ssrBlurYPostProcess.blurStrength = strength;
      }
      /**
       * Gets or sets whether or not smoothing reflections is enabled (default: false)
       * Enabling smoothing will require more GPU power.
       * Note that this setting has no effect if step = 1: it's only used if step \> 1.
       */
      get enableSmoothReflections() {
        return this._ssrPostProcess.enableSmoothReflections;
      }
      set enableSmoothReflections(enabled) {
        this._ssrPostProcess.enableSmoothReflections = enabled;
      }
      /**
       * Gets or sets the environment cube texture used to define the reflection when the reflected rays of SSR leave the view space or when the maxDistance/maxSteps is reached.
       */
      get environmentTexture() {
        return this._ssrPostProcess.environmentTexture;
      }
      set environmentTexture(texture) {
        this._ssrPostProcess.environmentTexture = texture;
      }
      /**
       * Gets or sets the boolean defining if the environment texture is a standard cubemap (false) or a probe (true). Default value is false.
       * Note: a probe cube texture is treated differently than an ordinary cube texture because the Y axis is reversed.
       */
      get environmentTextureIsProbe() {
        return this._ssrPostProcess.environmentTextureIsProbe;
      }
      set environmentTextureIsProbe(isProbe) {
        this._ssrPostProcess.environmentTextureIsProbe = isProbe;
      }
      /**
       * Gets or sets a boolean indicating if the reflections should be attenuated at the screen borders (default: true).
       */
      get attenuateScreenBorders() {
        return this._ssrPostProcess.attenuateScreenBorders;
      }
      set attenuateScreenBorders(attenuate) {
        this._ssrPostProcess.attenuateScreenBorders = attenuate;
      }
      /**
       * Gets or sets a boolean indicating if the reflections should be attenuated according to the distance of the intersection (default: true).
       */
      get attenuateIntersectionDistance() {
        return this._ssrPostProcess.attenuateIntersectionDistance;
      }
      set attenuateIntersectionDistance(attenuate) {
        this._ssrPostProcess.attenuateIntersectionDistance = attenuate;
      }
      /**
       * Gets or sets a boolean indicating if the reflections should be attenuated according to the number of iterations performed to find the intersection (default: true).
       */
      get attenuateIntersectionIterations() {
        return this._ssrPostProcess.attenuateIntersectionIterations;
      }
      set attenuateIntersectionIterations(attenuate) {
        this._ssrPostProcess.attenuateIntersectionIterations = attenuate;
      }
      /**
       * Gets or sets a boolean indicating if the reflections should be attenuated when the reflection ray is facing the camera (the view direction) (default: false).
       */
      get attenuateFacingCamera() {
        return this._ssrPostProcess.attenuateFacingCamera;
      }
      set attenuateFacingCamera(attenuate) {
        this._ssrPostProcess.attenuateFacingCamera = attenuate;
      }
      /**
       * Gets or sets a boolean indicating if the backface reflections should be attenuated (default: false).
       */
      get attenuateBackfaceReflection() {
        return this._ssrPostProcess.attenuateBackfaceReflection;
      }
      set attenuateBackfaceReflection(attenuate) {
        this._ssrPostProcess.attenuateBackfaceReflection = attenuate;
      }
      /**
       * Gets or sets a boolean indicating if the ray should be clipped to the frustum (default: true).
       * You can try to set this parameter to false to save some performances: it may produce some artefacts in some cases, but generally they won't really be visible
       */
      get clipToFrustum() {
        return this._ssrPostProcess.clipToFrustum;
      }
      set clipToFrustum(clip) {
        this._ssrPostProcess.clipToFrustum = clip;
      }
      /**
       * Gets or sets a boolean indicating whether the blending between the current color pixel and the reflection color should be done with a Fresnel coefficient (default: false).
       * It is more physically accurate to use the Fresnel coefficient (otherwise it uses the reflectivity of the material for blending), but it is also more expensive when you use blur (when blurDispersionStrength \> 0).
       */
      get useFresnel() {
        return this._ssrPostProcess.useFresnel;
      }
      set useFresnel(fresnel) {
        this._ssrPostProcess.useFresnel = fresnel;
        this._ssrBlurCombinerPostProcess.useFresnel = fresnel;
      }
      /**
       * Gets or sets a boolean defining if geometry thickness should be computed automatically (default: false).
       * When enabled, a depth renderer is created which will render the back faces of the scene to a depth texture (meaning additional work for the GPU).
       * In that mode, the "thickness" property is still used as an offset to compute the ray intersection, but you can typically use a much lower
       * value than when enableAutomaticThicknessComputation is false (it's even possible to use a value of 0 when using low values for "step")
       * Note that for performance reasons, this option will only apply to the first camera to which the rendering pipeline is attached!
       */
      get enableAutomaticThicknessComputation() {
        return this._ssrPostProcess.enableAutomaticThicknessComputation;
      }
      set enableAutomaticThicknessComputation(automatic) {
        if (this._ssrPostProcess.enableAutomaticThicknessComputation === automatic) {
          return;
        }
        this._ssrPostProcess.enableAutomaticThicknessComputation = automatic;
      }
      /**
       * Gets or sets a boolean defining if the input color texture is in gamma space (default: true)
       * The SSR effect works in linear space, so if the input texture is in gamma space, we must convert the texture to linear space before applying the effect
       */
      get inputTextureColorIsInGammaSpace() {
        return this._ssrPostProcess.inputTextureColorIsInGammaSpace;
      }
      set inputTextureColorIsInGammaSpace(gammaSpace) {
        if (this._ssrPostProcess.inputTextureColorIsInGammaSpace === gammaSpace) {
          return;
        }
        this._ssrPostProcess.inputTextureColorIsInGammaSpace = gammaSpace;
        this._ssrBlurCombinerPostProcess.inputTextureColorIsInGammaSpace = gammaSpace;
      }
      /**
       * Gets or sets a boolean defining if the output color texture generated by the SSR pipeline should be in gamma space (default: true)
       * If you have a post-process that comes after the SSR and that post-process needs the input to be in a linear space, you must disable generateOutputInGammaSpace
       */
      get generateOutputInGammaSpace() {
        return this._ssrPostProcess.generateOutputInGammaSpace;
      }
      set generateOutputInGammaSpace(gammaSpace) {
        if (this._ssrPostProcess.generateOutputInGammaSpace === gammaSpace) {
          return;
        }
        this._ssrPostProcess.generateOutputInGammaSpace = gammaSpace;
        this._ssrBlurCombinerPostProcess.generateOutputInGammaSpace = gammaSpace;
      }
      /**
       * Gets or sets a boolean indicating if the effect should be rendered in debug mode (default: false).
       * In this mode, colors have this meaning:
       *   - blue: the ray hit the max distance (we reached maxDistance)
       *   - red: the ray ran out of steps (we reached maxSteps)
       *   - yellow: the ray went off screen
       *   - green: the ray hit a surface. The brightness of the green color is proportional to the distance between the ray origin and the intersection point: A brighter green means more computation than a darker green.
       * In the first 3 cases, the final color is calculated by mixing the skybox color with the pixel color (if environmentTexture is defined), otherwise the pixel color is not modified
       * You should try to get as few blue/red/yellow pixels as possible, as this means that the ray has gone further than if it had hit a surface.
       */
      get debug() {
        return this._ssrPostProcess.debug;
      }
      set debug(value) {
        if (this._ssrPostProcess.debug === value) {
          return;
        }
        this._ssrPostProcess.debug = value;
        this._ssrBlurCombinerPostProcess.debug = value;
      }
      /**
       * Gets or sets the camera to use to render the reflection
       */
      get camera() {
        return this._ssrPostProcess.camera;
      }
      set camera(camera) {
        this._ssrPostProcess.camera = camera;
        this._ssrBlurCombinerPostProcess.camera = camera;
      }
      /**
       * Gets or sets a boolean indicating if the depth buffer stores screen space depth instead of camera view space depth.
       */
      get useScreenspaceDepth() {
        return this._ssrPostProcess.useScreenspaceDepth;
      }
      set useScreenspaceDepth(use) {
        this._ssrPostProcess.useScreenspaceDepth = use;
        this._ssrBlurCombinerPostProcess.useScreenspaceDepth = use;
      }
      /**
       * Gets or sets a boolean indicating if the normals are in world space (false by default, meaning normals are in camera view space).
       */
      get normalsAreInWorldSpace() {
        return this._ssrPostProcess.normalsAreInWorldSpace;
      }
      set normalsAreInWorldSpace(normalsAreInWorldSpace) {
        this._ssrPostProcess.normalsAreInWorldSpace = normalsAreInWorldSpace;
        this._ssrBlurCombinerPostProcess.normalsAreInWorldSpace = normalsAreInWorldSpace;
      }
      /**
       * Gets or sets a boolean indicating if the normals are encoded as unsigned, that is normalUnsigned = normal*0.5+0.5 (false by default).
       */
      get normalsAreUnsigned() {
        return this._ssrPostProcess.normalsAreUnsigned;
      }
      set normalsAreUnsigned(normalsAreUnsigned) {
        this._ssrPostProcess.normalsAreUnsigned = normalsAreUnsigned;
        this._ssrBlurCombinerPostProcess.normalsAreUnsigned = normalsAreUnsigned;
      }
      /**
       * Checks if all the post processes in the pipeline are ready.
       * @returns true if all the post processes in the pipeline are ready
       */
      isReady() {
        return this._ssrPostProcess.isReady() && this._ssrBlurXPostProcess.isReady() && this._ssrBlurYPostProcess.isReady() && this._ssrBlurCombinerPostProcess.isReady();
      }
      /**
       * Constructor of the SSR rendering pipeline
       * @param name The rendering pipeline name
       * @param scene The scene linked to this pipeline
       */
      constructor(name13, scene) {
        this.ssrDownsample = 0;
        this.blurDownsample = 0;
        this.name = name13;
        this._scene = scene;
        this._ssrPostProcess = new ThinSSRPostProcess(this.name, this._scene);
        this._ssrBlurXPostProcess = new ThinSSRBlurPostProcess(this.name + " BlurX", this._scene.getEngine(), new Vector2(1, 0));
        this._ssrBlurYPostProcess = new ThinSSRBlurPostProcess(this.name + " BlurY", this._scene.getEngine(), new Vector2(0, 1));
        this._ssrBlurCombinerPostProcess = new ThinSSRBlurCombinerPostProcess(this.name + " BlurCombiner", this._scene.getEngine());
        this._ssrPostProcess.useBlur = this._ssrBlurXPostProcess.blurStrength > 0;
      }
      /**
       * Disposes of the pipeline
       */
      dispose() {
        this._ssrPostProcess?.dispose();
        this._ssrBlurXPostProcess?.dispose();
        this._ssrBlurYPostProcess?.dispose();
        this._ssrBlurCombinerPostProcess?.dispose();
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/ssrRenderingPipeline.js
var SSRRenderingPipeline;
var init_ssrRenderingPipeline = __esm({
  "node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/ssrRenderingPipeline.js"() {
    init_tslib_es6();
    init_decorators();
    init_decorators_serialization();
    init_postProcess();
    init_postProcessRenderPipeline();
    init_postProcessRenderEffect();
    init_typeStore();
    init_screenSpaceReflections2Configuration();
    init_geometryBufferRenderer();
    init_depthRenderer();
    init_thinSSRRenderingPipeline();
    init_thinSSRPostProcess();
    init_thinSSRBlurPostProcess();
    init_thinSSRBlurCombinerPostProcess();
    init_postProcessRenderPipelineManagerSceneComponent();
    SSRRenderingPipeline = class _SSRRenderingPipeline extends PostProcessRenderPipeline {
      /**
       * MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)
       */
      set samples(sampleCount) {
        if (this._samples === sampleCount) {
          return;
        }
        this._samples = sampleCount;
        if (this._ssrPostProcess) {
          this._ssrPostProcess.samples = this.samples;
        }
      }
      get samples() {
        return this._samples;
      }
      /**
       * Gets or sets the maxDistance used to define how far we look for reflection during the ray-marching on the reflected ray (default: 1000).
       * Note that this value is a view (camera) space distance (not pixels!).
       */
      get maxDistance() {
        return this._thinSSRRenderingPipeline.maxDistance;
      }
      set maxDistance(distance) {
        this._thinSSRRenderingPipeline.maxDistance = distance;
      }
      /**
       * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Should be an integer \>= 1 as it is the number of pixels we advance at each step (default: 1).
       * Use higher values to improve performances (but at the expense of quality).
       */
      get step() {
        return this._thinSSRRenderingPipeline.step;
      }
      set step(step) {
        this._thinSSRRenderingPipeline.step = step;
      }
      /**
       * Gets or sets the thickness value used as tolerance when computing the intersection between the reflected ray and the scene (default: 0.5).
       * If setting "enableAutomaticThicknessComputation" to true, you can use lower values for "thickness" (even 0), as the geometry thickness
       * is automatically computed thank to the regular depth buffer + the backface depth buffer
       */
      get thickness() {
        return this._thinSSRRenderingPipeline.thickness;
      }
      set thickness(thickness) {
        this._thinSSRRenderingPipeline.thickness = thickness;
      }
      /**
       * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results (default: 1).
       */
      get strength() {
        return this._thinSSRRenderingPipeline.strength;
      }
      set strength(strength) {
        this._thinSSRRenderingPipeline.strength = strength;
      }
      /**
       * Gets or sets the falloff exponent used to compute the reflection strength. Higher values lead to fainter reflections (default: 1).
       */
      get reflectionSpecularFalloffExponent() {
        return this._thinSSRRenderingPipeline.reflectionSpecularFalloffExponent;
      }
      set reflectionSpecularFalloffExponent(exponent) {
        this._thinSSRRenderingPipeline.reflectionSpecularFalloffExponent = exponent;
      }
      /**
       * Maximum number of steps during the ray marching process after which we consider an intersection could not be found (default: 1000).
       * Should be an integer value.
       */
      get maxSteps() {
        return this._thinSSRRenderingPipeline.maxSteps;
      }
      set maxSteps(steps) {
        this._thinSSRRenderingPipeline.maxSteps = steps;
      }
      /**
       * Gets or sets the factor applied when computing roughness. Default value is 0.2.
       * When blurring based on roughness is enabled (meaning blurDispersionStrength \> 0), roughnessFactor is used as a global roughness factor applied on all objects.
       * If you want to disable this global roughness set it to 0.
       */
      get roughnessFactor() {
        return this._thinSSRRenderingPipeline.roughnessFactor;
      }
      set roughnessFactor(factor) {
        this._thinSSRRenderingPipeline.roughnessFactor = factor;
      }
      /**
       * Number of steps to skip at start when marching the ray to avoid self collisions (default: 1)
       * 1 should normally be a good value, depending on the scene you may need to use a higher value (2 or 3)
       */
      get selfCollisionNumSkip() {
        return this._thinSSRRenderingPipeline.selfCollisionNumSkip;
      }
      set selfCollisionNumSkip(skip) {
        this._thinSSRRenderingPipeline.selfCollisionNumSkip = skip;
      }
      /**
       * Gets or sets the minimum value for one of the reflectivity component of the material to consider it for SSR (default: 0.04).
       * If all r/g/b components of the reflectivity is below or equal this value, the pixel will not be considered reflective and SSR won't be applied.
       */
      get reflectivityThreshold() {
        return this._thinSSRRenderingPipeline.reflectivityThreshold;
      }
      set reflectivityThreshold(threshold) {
        const currentThreshold = this.reflectivityThreshold;
        if (threshold === currentThreshold) {
          return;
        }
        this._thinSSRRenderingPipeline.reflectivityThreshold = threshold;
        if (threshold === 0 && currentThreshold !== 0 || threshold !== 0 && currentThreshold === 0) {
          this._buildPipeline();
        }
      }
      /**
       * Gets or sets the downsample factor used to reduce the size of the texture used to compute the SSR contribution (default: 0).
       * Use 0 to render the SSR contribution at full resolution, 1 to render at half resolution, 2 to render at 1/3 resolution, etc.
       * Note that it is used only when blurring is enabled (blurDispersionStrength \> 0), because in that mode the SSR contribution is generated in a separate texture.
       */
      get ssrDownsample() {
        return this._thinSSRRenderingPipeline.ssrDownsample;
      }
      set ssrDownsample(downsample) {
        this._thinSSRRenderingPipeline.ssrDownsample = downsample;
        this._buildPipeline();
      }
      /**
       * Gets or sets the blur dispersion strength. Set this value to 0 to disable blurring (default: 0.03)
       * The reflections are blurred based on the roughness of the surface and the distance between the pixel shaded and the reflected pixel: the higher the distance the more blurry the reflection is.
       * blurDispersionStrength allows to increase or decrease this effect.
       */
      get blurDispersionStrength() {
        return this._thinSSRRenderingPipeline.blurDispersionStrength;
      }
      set blurDispersionStrength(strength) {
        const currentStrength = this.blurDispersionStrength;
        if (strength === currentStrength) {
          return;
        }
        this._thinSSRRenderingPipeline.blurDispersionStrength = strength;
        if (strength === 0 && currentStrength !== 0 || strength !== 0 && currentStrength === 0) {
          this._buildPipeline();
        }
      }
      _useBlur() {
        return this.blurDispersionStrength > 0;
      }
      /**
       * Gets or sets the downsample factor used to reduce the size of the textures used to blur the reflection effect (default: 0).
       * Use 0 to blur at full resolution, 1 to render at half resolution, 2 to render at 1/3 resolution, etc.
       */
      get blurDownsample() {
        return this._thinSSRRenderingPipeline.blurDownsample;
      }
      set blurDownsample(downsample) {
        this._thinSSRRenderingPipeline.blurDownsample = downsample;
        this._buildPipeline();
      }
      /**
       * Gets or sets whether or not smoothing reflections is enabled (default: false)
       * Enabling smoothing will require more GPU power.
       * Note that this setting has no effect if step = 1: it's only used if step \> 1.
       */
      get enableSmoothReflections() {
        return this._thinSSRRenderingPipeline.enableSmoothReflections;
      }
      set enableSmoothReflections(enabled) {
        this._thinSSRRenderingPipeline.enableSmoothReflections = enabled;
      }
      get _useScreenspaceDepth() {
        return this._thinSSRRenderingPipeline.useScreenspaceDepth;
      }
      /**
       * Gets or sets the environment cube texture used to define the reflection when the reflected rays of SSR leave the view space or when the maxDistance/maxSteps is reached.
       */
      get environmentTexture() {
        return this._thinSSRRenderingPipeline.environmentTexture;
      }
      set environmentTexture(texture) {
        this._thinSSRRenderingPipeline.environmentTexture = texture;
      }
      /**
       * Gets or sets the boolean defining if the environment texture is a standard cubemap (false) or a probe (true). Default value is false.
       * Note: a probe cube texture is treated differently than an ordinary cube texture because the Y axis is reversed.
       */
      get environmentTextureIsProbe() {
        return this._thinSSRRenderingPipeline.environmentTextureIsProbe;
      }
      set environmentTextureIsProbe(isProbe) {
        this._thinSSRRenderingPipeline.environmentTextureIsProbe = isProbe;
      }
      /**
       * Gets or sets a boolean indicating if the reflections should be attenuated at the screen borders (default: true).
       */
      get attenuateScreenBorders() {
        return this._thinSSRRenderingPipeline.attenuateScreenBorders;
      }
      set attenuateScreenBorders(attenuate) {
        this._thinSSRRenderingPipeline.attenuateScreenBorders = attenuate;
      }
      /**
       * Gets or sets a boolean indicating if the reflections should be attenuated according to the distance of the intersection (default: true).
       */
      get attenuateIntersectionDistance() {
        return this._thinSSRRenderingPipeline.attenuateIntersectionDistance;
      }
      set attenuateIntersectionDistance(attenuate) {
        this._thinSSRRenderingPipeline.attenuateIntersectionDistance = attenuate;
      }
      /**
       * Gets or sets a boolean indicating if the reflections should be attenuated according to the number of iterations performed to find the intersection (default: true).
       */
      get attenuateIntersectionIterations() {
        return this._thinSSRRenderingPipeline.attenuateIntersectionIterations;
      }
      set attenuateIntersectionIterations(attenuate) {
        this._thinSSRRenderingPipeline.attenuateIntersectionIterations = attenuate;
      }
      /**
       * Gets or sets a boolean indicating if the reflections should be attenuated when the reflection ray is facing the camera (the view direction) (default: false).
       */
      get attenuateFacingCamera() {
        return this._thinSSRRenderingPipeline.attenuateFacingCamera;
      }
      set attenuateFacingCamera(attenuate) {
        this._thinSSRRenderingPipeline.attenuateFacingCamera = attenuate;
      }
      /**
       * Gets or sets a boolean indicating if the backface reflections should be attenuated (default: false).
       */
      get attenuateBackfaceReflection() {
        return this._thinSSRRenderingPipeline.attenuateBackfaceReflection;
      }
      set attenuateBackfaceReflection(attenuate) {
        this._thinSSRRenderingPipeline.attenuateBackfaceReflection = attenuate;
      }
      /**
       * Gets or sets a boolean indicating if the ray should be clipped to the frustum (default: true).
       * You can try to set this parameter to false to save some performances: it may produce some artefacts in some cases, but generally they won't really be visible
       */
      get clipToFrustum() {
        return this._thinSSRRenderingPipeline.clipToFrustum;
      }
      set clipToFrustum(clip) {
        this._thinSSRRenderingPipeline.clipToFrustum = clip;
      }
      /**
       * Gets or sets a boolean indicating whether the blending between the current color pixel and the reflection color should be done with a Fresnel coefficient (default: false).
       * It is more physically accurate to use the Fresnel coefficient (otherwise it uses the reflectivity of the material for blending), but it is also more expensive when you use blur (when blurDispersionStrength \> 0).
       */
      get useFresnel() {
        return this._thinSSRRenderingPipeline.useFresnel;
      }
      set useFresnel(fresnel) {
        this._thinSSRRenderingPipeline.useFresnel = fresnel;
        this._buildPipeline();
      }
      /**
       * Gets or sets a boolean defining if geometry thickness should be computed automatically (default: false).
       * When enabled, a depth renderer is created which will render the back faces of the scene to a depth texture (meaning additional work for the GPU).
       * In that mode, the "thickness" property is still used as an offset to compute the ray intersection, but you can typically use a much lower
       * value than when enableAutomaticThicknessComputation is false (it's even possible to use a value of 0 when using low values for "step")
       * Note that for performance reasons, this option will only apply to the first camera to which the rendering pipeline is attached!
       */
      get enableAutomaticThicknessComputation() {
        return this._thinSSRRenderingPipeline.enableAutomaticThicknessComputation;
      }
      set enableAutomaticThicknessComputation(automatic) {
        this._thinSSRRenderingPipeline.enableAutomaticThicknessComputation = automatic;
        this._buildPipeline();
      }
      /**
       * Gets the depth renderer used to render the back faces of the scene to a depth texture.
       */
      get backfaceDepthRenderer() {
        return this._depthRenderer;
      }
      /**
       * Gets or sets the downsample factor (default: 0) used to create the backface depth texture - used only if enableAutomaticThicknessComputation = true.
       * Use 0 to render the depth at full resolution, 1 to render at half resolution, 2 to render at 1/4 resolution, etc.
       * Note that you will get rendering artefacts when using a value different from 0: it's a tradeoff between image quality and performances.
       */
      get backfaceDepthTextureDownsample() {
        return this._backfaceDepthTextureDownsample;
      }
      set backfaceDepthTextureDownsample(factor) {
        if (this._backfaceDepthTextureDownsample === factor) {
          return;
        }
        this._backfaceDepthTextureDownsample = factor;
        this._resizeDepthRenderer();
      }
      /**
       * Gets or sets a boolean (default: true) indicating if the depth of transparent meshes should be written to the backface depth texture (when automatic thickness computation is enabled).
       */
      get backfaceForceDepthWriteTransparentMeshes() {
        return this._backfaceForceDepthWriteTransparentMeshes;
      }
      set backfaceForceDepthWriteTransparentMeshes(force) {
        if (this._backfaceForceDepthWriteTransparentMeshes === force) {
          return;
        }
        this._backfaceForceDepthWriteTransparentMeshes = force;
        if (this._depthRenderer) {
          this._depthRenderer.forceDepthWriteTransparentMeshes = force;
        }
      }
      /**
       * Gets or sets a boolean indicating if the effect is enabled (default: true).
       */
      get isEnabled() {
        return this._isEnabled;
      }
      set isEnabled(value) {
        if (this._isEnabled === value) {
          return;
        }
        this._isEnabled = value;
        if (!value) {
          if (this._cameras !== null) {
            this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);
            this._cameras = this._camerasToBeAttached.slice();
          }
        } else if (value) {
          if (!this._isDirty) {
            if (this._cameras !== null) {
              this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);
            }
          } else {
            this._buildPipeline();
          }
        }
      }
      /**
       * Gets or sets a boolean defining if the input color texture is in gamma space (default: true)
       * The SSR effect works in linear space, so if the input texture is in gamma space, we must convert the texture to linear space before applying the effect
       */
      get inputTextureColorIsInGammaSpace() {
        return this._thinSSRRenderingPipeline.inputTextureColorIsInGammaSpace;
      }
      set inputTextureColorIsInGammaSpace(gammaSpace) {
        this._thinSSRRenderingPipeline.inputTextureColorIsInGammaSpace = gammaSpace;
        this._buildPipeline();
      }
      /**
       * Gets or sets a boolean defining if the output color texture generated by the SSR pipeline should be in gamma space (default: true)
       * If you have a post-process that comes after the SSR and that post-process needs the input to be in a linear space, you must disable generateOutputInGammaSpace
       */
      get generateOutputInGammaSpace() {
        return this._thinSSRRenderingPipeline.generateOutputInGammaSpace;
      }
      set generateOutputInGammaSpace(gammaSpace) {
        this._thinSSRRenderingPipeline.generateOutputInGammaSpace = gammaSpace;
        this._buildPipeline();
      }
      /**
       * Gets or sets a boolean indicating if the effect should be rendered in debug mode (default: false).
       * In this mode, colors have this meaning:
       *   - blue: the ray hit the max distance (we reached maxDistance)
       *   - red: the ray ran out of steps (we reached maxSteps)
       *   - yellow: the ray went off screen
       *   - green: the ray hit a surface. The brightness of the green color is proportional to the distance between the ray origin and the intersection point: A brighter green means more computation than a darker green.
       * In the first 3 cases, the final color is calculated by mixing the skybox color with the pixel color (if environmentTexture is defined), otherwise the pixel color is not modified
       * You should try to get as few blue/red/yellow pixels as possible, as this means that the ray has gone further than if it had hit a surface.
       */
      get debug() {
        return this._thinSSRRenderingPipeline.debug;
      }
      set debug(value) {
        this._thinSSRRenderingPipeline.debug = value;
        this._buildPipeline();
      }
      /**
       * Gets the scene the effect belongs to.
       * @returns the scene the effect belongs to.
       */
      getScene() {
        return this._scene;
      }
      get _geometryBufferRenderer() {
        if (!this._forceGeometryBuffer) {
          return null;
        }
        return this._scene.geometryBufferRenderer;
      }
      get _prePassRenderer() {
        if (this._forceGeometryBuffer) {
          return null;
        }
        return this._scene.prePassRenderer;
      }
      /**
       * Gets active scene
       */
      get scene() {
        return this._scene;
      }
      /**
       * Returns true if SSR is supported by the running hardware
       */
      get isSupported() {
        const caps = this._scene.getEngine().getCaps();
        return caps.drawBuffersExtension && caps.texelFetch;
      }
      /**
       * Constructor of the SSR rendering pipeline
       * @param name The rendering pipeline name
       * @param scene The scene linked to this pipeline
       * @param cameras The array of cameras that the rendering pipeline will be attached to (default: scene.cameras)
       * @param forceGeometryBuffer Set to true if you want to use the legacy geometry buffer renderer (default: false)
       * @param textureType The texture type used by the different post processes created by SSR (default: 0)
       * @param useScreenspaceDepth Indicates if the depth buffer should be linear or screenspace (default: false). This allows sharing the buffer with other effect pipelines that may require the depth to be in screenspace.
       */
      constructor(name13, scene, cameras, forceGeometryBuffer = false, textureType = 0, useScreenspaceDepth = false) {
        super(scene.getEngine(), name13);
        this.SSRRenderEffect = "SSRRenderEffect";
        this.SSRBlurRenderEffect = "SSRBlurRenderEffect";
        this.SSRCombineRenderEffect = "SSRCombineRenderEffect";
        this._samples = 1;
        this._backfaceDepthTextureDownsample = 0;
        this._backfaceForceDepthWriteTransparentMeshes = true;
        this._isEnabled = true;
        this._forceGeometryBuffer = false;
        this._isDirty = false;
        this._camerasToBeAttached = [];
        this._thinSSRRenderingPipeline = new ThinSSRRenderingPipeline(name13, scene);
        this._thinSSRRenderingPipeline.isSSRSupported = false;
        this._thinSSRRenderingPipeline.useScreenspaceDepth = useScreenspaceDepth;
        this._cameras = cameras || scene.cameras;
        this._cameras = this._cameras.slice();
        this._camerasToBeAttached = this._cameras.slice();
        this._scene = scene;
        this._textureType = textureType;
        this._forceGeometryBuffer = forceGeometryBuffer;
        if (this.isSupported) {
          this._createSSRPostProcess();
          scene.postProcessRenderPipelineManager.addPipeline(this);
          if (this._forceGeometryBuffer) {
            const geometryBufferRenderer = scene.enableGeometryBufferRenderer();
            if (geometryBufferRenderer) {
              geometryBufferRenderer.enableReflectivity = true;
              geometryBufferRenderer.useSpecificClearForDepthTexture = true;
              geometryBufferRenderer.enableScreenspaceDepth = this._useScreenspaceDepth;
              geometryBufferRenderer.enableDepth = !this._useScreenspaceDepth;
            }
          } else {
            const prePassRenderer = scene.enablePrePassRenderer();
            if (prePassRenderer) {
              prePassRenderer.useSpecificClearForDepthTexture = true;
              prePassRenderer.markAsDirty();
            }
          }
          this._thinSSRRenderingPipeline.isSSRSupported = !!this._geometryBufferRenderer || !!this._prePassRenderer;
          this._buildPipeline();
        }
      }
      /**
       * Get the class name
       * @returns "SSRRenderingPipeline"
       */
      getClassName() {
        return "SSRRenderingPipeline";
      }
      /**
       * Adds a camera to the pipeline
       * @param camera the camera to be added
       */
      addCamera(camera) {
        this._camerasToBeAttached.push(camera);
        this._buildPipeline();
      }
      /**
       * Removes a camera from the pipeline
       * @param camera the camera to remove
       */
      removeCamera(camera) {
        const index = this._camerasToBeAttached.indexOf(camera);
        this._camerasToBeAttached.splice(index, 1);
        this._buildPipeline();
      }
      /**
       * Removes the internal pipeline assets and detaches the pipeline from the scene cameras
       * @param disableGeometryBufferRenderer if the geometry buffer renderer should be disabled
       */
      dispose(disableGeometryBufferRenderer = false) {
        this._disposeDepthRenderer();
        this._disposeSSRPostProcess();
        this._disposeBlurPostProcesses();
        if (disableGeometryBufferRenderer) {
          this._scene.disableGeometryBufferRenderer();
        }
        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);
        this._scene.postProcessRenderPipelineManager.removePipeline(this._name);
        this._thinSSRRenderingPipeline.dispose();
        super.dispose();
      }
      _getTextureSize() {
        const engine = this._scene.getEngine();
        const prePassRenderer = this._prePassRenderer;
        let textureSize = { width: engine.getRenderWidth(), height: engine.getRenderHeight() };
        if (prePassRenderer && this._scene.activeCamera?._getFirstPostProcess() === this._ssrPostProcess) {
          const renderTarget = prePassRenderer.getRenderTarget();
          if (renderTarget && renderTarget.textures) {
            textureSize = renderTarget.textures[prePassRenderer.getIndex(4)].getSize();
          }
        } else if (this._ssrPostProcess?.inputTexture) {
          textureSize.width = this._ssrPostProcess.inputTexture.width;
          textureSize.height = this._ssrPostProcess.inputTexture.height;
        }
        return textureSize;
      }
      _buildPipeline() {
        if (!this.isSupported) {
          return;
        }
        if (!this._isEnabled) {
          this._isDirty = true;
          return;
        }
        this._isDirty = false;
        const engine = this._scene.getEngine();
        this._disposeDepthRenderer();
        if (this._cameras !== null) {
          this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);
          this._cameras = this._camerasToBeAttached.slice();
          if (this._cameras.length > 0) {
            this._thinSSRRenderingPipeline.camera = this._cameras[0];
          }
        }
        this._reset();
        this._thinSSRRenderingPipeline.normalsAreInWorldSpace = !!(this._geometryBufferRenderer?.generateNormalsInWorldSpace ?? this._prePassRenderer?.generateNormalsInWorldSpace);
        if (this.enableAutomaticThicknessComputation) {
          const camera = this._cameras?.[0];
          if (camera) {
            this._depthRendererCamera = camera;
            this._depthRenderer = new DepthRenderer(this._scene, void 0, void 0, this._useScreenspaceDepth, 1, !this._useScreenspaceDepth, "SSRBackDepth");
            this._depthRenderer.reverseCulling = true;
            this._depthRenderer.forceDepthWriteTransparentMeshes = this.backfaceForceDepthWriteTransparentMeshes;
            this._resizeDepthRenderer();
            camera.customRenderTargets.push(this._depthRenderer.getDepthMap());
          }
        }
        this.addEffect(new PostProcessRenderEffect(engine, this.SSRRenderEffect, () => {
          return this._ssrPostProcess;
        }, true));
        this._disposeBlurPostProcesses();
        if (this._useBlur()) {
          this._createBlurAndCombinerPostProcesses();
          this.addEffect(new PostProcessRenderEffect(engine, this.SSRBlurRenderEffect, () => {
            return [this._blurPostProcessX, this._blurPostProcessY];
          }, true));
          this.addEffect(new PostProcessRenderEffect(engine, this.SSRCombineRenderEffect, () => {
            return this._blurCombinerPostProcess;
          }, true));
        }
        if (this._cameras !== null) {
          this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);
        }
      }
      _resizeDepthRenderer() {
        if (!this._depthRenderer) {
          return;
        }
        const textureSize = this._getTextureSize();
        const depthRendererSize = this._depthRenderer.getDepthMap().getSize();
        const width = Math.floor(textureSize.width / (this.backfaceDepthTextureDownsample + 1));
        const height = Math.floor(textureSize.height / (this.backfaceDepthTextureDownsample + 1));
        if (depthRendererSize.width !== width || depthRendererSize.height !== height) {
          this._depthRenderer.getDepthMap().resize({ width, height });
        }
      }
      _disposeDepthRenderer() {
        if (this._depthRenderer) {
          if (this._depthRendererCamera) {
            const idx = this._depthRendererCamera.customRenderTargets.indexOf(this._depthRenderer.getDepthMap()) ?? -1;
            if (idx !== -1) {
              this._depthRendererCamera.customRenderTargets.splice(idx, 1);
            }
          }
          this._depthRendererCamera = null;
          this._depthRenderer.getDepthMap().dispose();
        }
        this._depthRenderer = null;
      }
      _disposeBlurPostProcesses() {
        for (let i = 0; i < this._cameras.length; i++) {
          const camera = this._cameras[i];
          this._blurPostProcessX?.dispose(camera);
          this._blurPostProcessY?.dispose(camera);
          this._blurCombinerPostProcess?.dispose(camera);
        }
        this._blurPostProcessX = null;
        this._blurPostProcessY = null;
        this._blurCombinerPostProcess = null;
      }
      _disposeSSRPostProcess() {
        for (let i = 0; i < this._cameras.length; i++) {
          const camera = this._cameras[i];
          this._ssrPostProcess?.dispose(camera);
        }
        this._ssrPostProcess = null;
      }
      _createSSRPostProcess() {
        this._ssrPostProcess = new PostProcess("ssr", ThinSSRPostProcess.FragmentUrl, {
          uniformNames: ThinSSRPostProcess.Uniforms,
          samplerNames: ThinSSRPostProcess.Samplers,
          size: 1,
          samplingMode: 2,
          engine: this._scene.getEngine(),
          textureType: this._textureType,
          effectWrapper: this._thinSSRRenderingPipeline._ssrPostProcess
        });
        this._ssrPostProcess.onApply = (effect) => {
          this._resizeDepthRenderer();
          const geometryBufferRenderer = this._geometryBufferRenderer;
          const prePassRenderer = this._prePassRenderer;
          if (!prePassRenderer && !geometryBufferRenderer) {
            return;
          }
          if (geometryBufferRenderer) {
            const roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);
            const normalIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.NORMAL_TEXTURE_TYPE);
            effect.setTexture("normalSampler", geometryBufferRenderer.getGBuffer().textures[normalIndex]);
            effect.setTexture("reflectivitySampler", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);
            if (this._useScreenspaceDepth) {
              const depthIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE);
              effect.setTexture("depthSampler", geometryBufferRenderer.getGBuffer().textures[depthIndex]);
            } else {
              const depthIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.DEPTH_TEXTURE_TYPE);
              effect.setTexture("depthSampler", geometryBufferRenderer.getGBuffer().textures[depthIndex]);
            }
          } else if (prePassRenderer) {
            const depthIndex = prePassRenderer.getIndex(this._useScreenspaceDepth ? 10 : 5);
            const roughnessIndex = prePassRenderer.getIndex(3);
            const normalIndex = prePassRenderer.getIndex(6);
            effect.setTexture("normalSampler", prePassRenderer.getRenderTarget().textures[normalIndex]);
            effect.setTexture("depthSampler", prePassRenderer.getRenderTarget().textures[depthIndex]);
            effect.setTexture("reflectivitySampler", prePassRenderer.getRenderTarget().textures[roughnessIndex]);
          }
          if (this.enableAutomaticThicknessComputation && this._depthRenderer) {
            effect.setTexture("backDepthSampler", this._depthRenderer.getDepthMap());
            effect.setFloat("backSizeFactor", this.backfaceDepthTextureDownsample + 1);
          }
          const textureSize = this._getTextureSize();
          this._thinSSRRenderingPipeline._ssrPostProcess.textureWidth = textureSize.width;
          this._thinSSRRenderingPipeline._ssrPostProcess.textureHeight = textureSize.height;
        };
        this._ssrPostProcess.samples = this.samples;
        if (!this._forceGeometryBuffer) {
          this._ssrPostProcess._prePassEffectConfiguration = new ScreenSpaceReflections2Configuration(this._useScreenspaceDepth);
        }
      }
      _createBlurAndCombinerPostProcesses() {
        const engine = this._scene.getEngine();
        this._blurPostProcessX = new PostProcess("SSRblurX", ThinSSRBlurPostProcess.FragmentUrl, {
          uniformNames: ThinSSRBlurPostProcess.Uniforms,
          samplerNames: ThinSSRBlurPostProcess.Samplers,
          size: 1 / (this.ssrDownsample + 1),
          samplingMode: 2,
          engine,
          textureType: this._textureType,
          effectWrapper: this._thinSSRRenderingPipeline._ssrBlurXPostProcess
        });
        this._blurPostProcessX.autoClear = false;
        this._blurPostProcessX.onApplyObservable.add(() => {
          this._thinSSRRenderingPipeline._ssrBlurXPostProcess.textureWidth = this._blurPostProcessX?.inputTexture.width ?? this._scene.getEngine().getRenderWidth();
          this._thinSSRRenderingPipeline._ssrBlurXPostProcess.textureHeight = 1;
        });
        this._blurPostProcessY = new PostProcess("SSRblurY", ThinSSRBlurPostProcess.FragmentUrl, {
          uniformNames: ThinSSRBlurPostProcess.Uniforms,
          samplerNames: ThinSSRBlurPostProcess.Samplers,
          size: 1 / (this.blurDownsample + 1),
          samplingMode: 2,
          engine,
          textureType: this._textureType,
          effectWrapper: this._thinSSRRenderingPipeline._ssrBlurYPostProcess
        });
        this._blurPostProcessY.autoClear = false;
        this._blurPostProcessY.onApplyObservable.add(() => {
          this._thinSSRRenderingPipeline._ssrBlurYPostProcess.textureWidth = 1;
          this._thinSSRRenderingPipeline._ssrBlurYPostProcess.textureHeight = this._blurPostProcessY?.inputTexture.height ?? this._scene.getEngine().getRenderHeight();
        });
        this._blurCombinerPostProcess = new PostProcess("SSRblurCombiner", ThinSSRBlurCombinerPostProcess.FragmentUrl, {
          uniformNames: ThinSSRBlurCombinerPostProcess.Uniforms,
          samplerNames: ThinSSRBlurCombinerPostProcess.Samplers,
          size: 1 / (this.blurDownsample + 1),
          samplingMode: 1,
          engine,
          textureType: this._textureType,
          effectWrapper: this._thinSSRRenderingPipeline._ssrBlurCombinerPostProcess
        });
        this._blurCombinerPostProcess.autoClear = false;
        this._blurCombinerPostProcess.onApplyObservable.add((effect) => {
          const geometryBufferRenderer = this._geometryBufferRenderer;
          const prePassRenderer = this._prePassRenderer;
          if (!prePassRenderer && !geometryBufferRenderer) {
            return;
          }
          if (prePassRenderer && this._scene.activeCamera?._getFirstPostProcess() === this._ssrPostProcess) {
            const renderTarget = prePassRenderer.getRenderTarget();
            if (renderTarget && renderTarget.textures) {
              effect.setTexture("mainSampler", renderTarget.textures[prePassRenderer.getIndex(4)]);
            }
          } else {
            effect.setTextureFromPostProcess("mainSampler", this._ssrPostProcess);
          }
          if (geometryBufferRenderer) {
            const roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);
            effect.setTexture("reflectivitySampler", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);
            if (this.useFresnel) {
              effect.setTexture("normalSampler", geometryBufferRenderer.getGBuffer().textures[1]);
              if (this._useScreenspaceDepth) {
                const depthIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE);
                effect.setTexture("depthSampler", geometryBufferRenderer.getGBuffer().textures[depthIndex]);
              } else {
                effect.setTexture("depthSampler", geometryBufferRenderer.getGBuffer().textures[0]);
              }
            }
          } else if (prePassRenderer) {
            const roughnessIndex = prePassRenderer.getIndex(3);
            effect.setTexture("reflectivitySampler", prePassRenderer.getRenderTarget().textures[roughnessIndex]);
            if (this.useFresnel) {
              const depthIndex = prePassRenderer.getIndex(this._useScreenspaceDepth ? 10 : 5);
              const normalIndex = prePassRenderer.getIndex(6);
              effect.setTexture("normalSampler", prePassRenderer.getRenderTarget().textures[normalIndex]);
              effect.setTexture("depthSampler", prePassRenderer.getRenderTarget().textures[depthIndex]);
            }
          }
        });
      }
      /**
       * Serializes the rendering pipeline (Used when exporting)
       * @returns the serialized object
       */
      serialize() {
        const serializationObject = SerializationHelper.Serialize(this);
        serializationObject.customType = "SSRRenderingPipeline";
        return serializationObject;
      }
      /**
       * Parse the serialized pipeline
       * @param source Source pipeline.
       * @param scene The scene to load the pipeline to.
       * @param rootUrl The URL of the serialized pipeline.
       * @returns An instantiated pipeline from the serialized object.
       */
      static Parse(source, scene, rootUrl) {
        return SerializationHelper.Parse(() => new _SSRRenderingPipeline(source._name, scene, source._ratio), source, scene, rootUrl);
      }
    };
    __decorate([
      serialize()
    ], SSRRenderingPipeline.prototype, "samples", null);
    __decorate([
      serialize()
    ], SSRRenderingPipeline.prototype, "maxDistance", null);
    __decorate([
      serialize()
    ], SSRRenderingPipeline.prototype, "step", null);
    __decorate([
      serialize()
    ], SSRRenderingPipeline.prototype, "thickness", null);
    __decorate([
      serialize()
    ], SSRRenderingPipeline.prototype, "strength", null);
    __decorate([
      serialize()
    ], SSRRenderingPipeline.prototype, "reflectionSpecularFalloffExponent", null);
    __decorate([
      serialize()
    ], SSRRenderingPipeline.prototype, "maxSteps", null);
    __decorate([
      serialize()
    ], SSRRenderingPipeline.prototype, "roughnessFactor", null);
    __decorate([
      serialize()
    ], SSRRenderingPipeline.prototype, "selfCollisionNumSkip", null);
    __decorate([
      serialize()
    ], SSRRenderingPipeline.prototype, "reflectivityThreshold", null);
    __decorate([
      serialize()
    ], SSRRenderingPipeline.prototype, "ssrDownsample", null);
    __decorate([
      serialize("blurDispersionStrength")
    ], SSRRenderingPipeline.prototype, "blurDispersionStrength", null);
    __decorate([
      serialize("blurDownsample")
    ], SSRRenderingPipeline.prototype, "blurDownsample", null);
    __decorate([
      serialize("enableSmoothReflections")
    ], SSRRenderingPipeline.prototype, "enableSmoothReflections", null);
    __decorate([
      serialize("environmentTexture")
    ], SSRRenderingPipeline.prototype, "environmentTexture", null);
    __decorate([
      serialize("environmentTextureIsProbe")
    ], SSRRenderingPipeline.prototype, "environmentTextureIsProbe", null);
    __decorate([
      serialize("attenuateScreenBorders")
    ], SSRRenderingPipeline.prototype, "attenuateScreenBorders", null);
    __decorate([
      serialize("attenuateIntersectionDistance")
    ], SSRRenderingPipeline.prototype, "attenuateIntersectionDistance", null);
    __decorate([
      serialize("attenuateIntersectionIterations")
    ], SSRRenderingPipeline.prototype, "attenuateIntersectionIterations", null);
    __decorate([
      serialize("attenuateFacingCamera")
    ], SSRRenderingPipeline.prototype, "attenuateFacingCamera", null);
    __decorate([
      serialize("attenuateBackfaceReflection")
    ], SSRRenderingPipeline.prototype, "attenuateBackfaceReflection", null);
    __decorate([
      serialize("clipToFrustum")
    ], SSRRenderingPipeline.prototype, "clipToFrustum", null);
    __decorate([
      serialize("useFresnel")
    ], SSRRenderingPipeline.prototype, "useFresnel", null);
    __decorate([
      serialize("enableAutomaticThicknessComputation")
    ], SSRRenderingPipeline.prototype, "enableAutomaticThicknessComputation", null);
    __decorate([
      serialize("backfaceDepthTextureDownsample")
    ], SSRRenderingPipeline.prototype, "_backfaceDepthTextureDownsample", void 0);
    __decorate([
      serialize("backfaceForceDepthWriteTransparentMeshes")
    ], SSRRenderingPipeline.prototype, "_backfaceForceDepthWriteTransparentMeshes", void 0);
    __decorate([
      serialize("isEnabled")
    ], SSRRenderingPipeline.prototype, "_isEnabled", void 0);
    __decorate([
      serialize("inputTextureColorIsInGammaSpace")
    ], SSRRenderingPipeline.prototype, "inputTextureColorIsInGammaSpace", null);
    __decorate([
      serialize("generateOutputInGammaSpace")
    ], SSRRenderingPipeline.prototype, "generateOutputInGammaSpace", null);
    __decorate([
      serialize("debug")
    ], SSRRenderingPipeline.prototype, "debug", null);
    RegisterClass("BABYLON.SSRRenderingPipeline", SSRRenderingPipeline);
  }
});

// node_modules/@babylonjs/core/Rendering/boundingBoxRenderer.js
var TempMatrix, TempVec1, TempVec2, TempMatrixArray, DummyBoundingBox, BoundingBoxRenderer;
var init_boundingBoxRenderer = __esm({
  "node_modules/@babylonjs/core/Rendering/boundingBoxRenderer.js"() {
    init_scene();
    init_buffer();
    init_abstractMesh();
    init_math_vector();
    init_smartArray();
    init_sceneComponent();
    init_boundingBox();
    init_material();
    init_shaderMaterial();
    init_math_color();
    init_observable();
    init_drawWrapper();
    init_uniformBuffer();
    init_boxBuilder();
    init_timingTools();
    init_logger();
    Object.defineProperty(Scene.prototype, "forceShowBoundingBoxes", {
      get: function() {
        return this._forceShowBoundingBoxes || false;
      },
      set: function(value) {
        this._forceShowBoundingBoxes = value;
        if (value) {
          this.getBoundingBoxRenderer();
        }
      },
      enumerable: true,
      configurable: true
    });
    Scene.prototype.getBoundingBoxRenderer = function() {
      if (!this._boundingBoxRenderer) {
        this._boundingBoxRenderer = new BoundingBoxRenderer(this);
      }
      return this._boundingBoxRenderer;
    };
    Object.defineProperty(AbstractMesh.prototype, "showBoundingBox", {
      get: function() {
        return this._showBoundingBox || false;
      },
      set: function(value) {
        this._showBoundingBox = value;
        if (value) {
          this.getScene().getBoundingBoxRenderer();
        }
      },
      enumerable: true,
      configurable: true
    });
    TempMatrix = Matrix.Identity();
    TempVec1 = new Vector3();
    TempVec2 = new Vector3();
    TempMatrixArray = TempMatrix.asArray();
    DummyBoundingBox = new BoundingBox(TempVec1, TempVec1);
    BoundingBoxRenderer = class {
      /**
       * Gets the shader language used in this renderer.
       */
      get shaderLanguage() {
        return this._shaderLanguage;
      }
      /**
       * Instantiates a new bounding box renderer in a scene.
       * @param scene the scene the  renderer renders in
       */
      constructor(scene) {
        this.name = SceneComponentConstants.NAME_BOUNDINGBOXRENDERER;
        this.frontColor = new Color3(1, 1, 1);
        this.backColor = new Color3(0.1, 0.1, 0.1);
        this.showBackLines = true;
        this.onBeforeBoxRenderingObservable = new Observable();
        this.onAfterBoxRenderingObservable = new Observable();
        this.onResourcesReadyObservable = new Observable();
        this.enabled = true;
        this._shaderLanguage = 0;
        this.renderList = new SmartArray(32);
        this._vertexBuffers = {};
        this._fillIndexBuffer = null;
        this._fillIndexData = null;
        this._matrixBuffer = null;
        this._matrices = null;
        this._useInstances = false;
        this._drawWrapperFront = null;
        this._drawWrapperBack = null;
        this.scene = scene;
        const engine = this.scene.getEngine();
        if (engine.isWebGPU) {
          this._shaderLanguage = 1;
        }
        scene._addComponent(this);
        this._uniformBufferFront = new UniformBuffer(this.scene.getEngine(), void 0, void 0, "BoundingBoxRendererFront", true);
        this._buildUniformLayout(this._uniformBufferFront);
        this._uniformBufferBack = new UniformBuffer(this.scene.getEngine(), void 0, void 0, "BoundingBoxRendererBack", true);
        this._buildUniformLayout(this._uniformBufferBack);
      }
      _buildUniformLayout(ubo) {
        ubo.addUniform("color", 4);
        ubo.addUniform("world", 16);
        ubo.addUniform("viewProjection", 16);
        ubo.addUniform("viewProjectionR", 16);
        ubo.create();
      }
      /**
       * Registers the component in a given scene
       */
      register() {
        this.scene._beforeEvaluateActiveMeshStage.registerStep(SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER, this, this.reset);
        this.scene._preActiveMeshStage.registerStep(SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER, this, this._preActiveMesh);
        this.scene._evaluateSubMeshStage.registerStep(SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER, this, this._evaluateSubMesh);
        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER, this, this.render);
      }
      /**
       * Checks if the renderer is ready asynchronously.
       * @param timeStep Time step in ms between retries (default is 16)
       * @param maxTimeout Maximum time in ms to wait for the graph to be ready (default is 30000)
       * @returns The promise that resolves when the renderer is ready
       */
      async whenReadyAsync(timeStep = 16, maxTimeout = 3e4) {
        this._prepareResources();
        return await new Promise((resolve) => {
          _RetryWithInterval(() => {
            return this._colorShader.isReady();
          }, () => {
            resolve();
          }, (err, isTimeout) => {
            if (!isTimeout) {
              Logger.Error("BoundingBoxRenderer: An unexpected error occurred while waiting for the renderer to be ready.");
              if (err) {
                Logger.Error(err);
                if (err.stack) {
                  Logger.Error(err.stack);
                }
              }
            } else {
              Logger.Error(`BoundingBoxRenderer: Timeout while waiting for the renderer to be ready.`);
              if (err) {
                Logger.Error(err);
              }
            }
          }, timeStep, maxTimeout);
        });
      }
      /** @internal */
      _evaluateSubMesh(mesh, subMesh) {
        if (mesh.showSubMeshesBoundingBox) {
          const boundingInfo = subMesh.getBoundingInfo();
          if (boundingInfo !== null && boundingInfo !== void 0) {
            boundingInfo.boundingBox._tag = mesh.renderingGroupId;
            this.renderList.push(boundingInfo.boundingBox);
          }
        }
      }
      /** @internal */
      _preActiveMesh(mesh) {
        if (mesh.showBoundingBox || this.scene.forceShowBoundingBoxes) {
          const boundingInfo = mesh.getBoundingInfo();
          boundingInfo.boundingBox._tag = mesh.renderingGroupId;
          this.renderList.push(boundingInfo.boundingBox);
        }
      }
      _prepareResources() {
        if (this._colorShader) {
          return;
        }
        this._colorShader = new ShaderMaterial("colorShader", this.scene, "boundingBoxRenderer", {
          attributes: [VertexBuffer.PositionKind, "world0", "world1", "world2", "world3"],
          uniforms: ["world", "viewProjection", "viewProjectionR", "color"],
          uniformBuffers: ["BoundingBoxRenderer"],
          shaderLanguage: this._shaderLanguage,
          extraInitializationsAsync: async () => {
            if (this._shaderLanguage === 1) {
              await Promise.all([import("./boundingBoxRenderer.vertex-T3IWGRNK.js"), import("./boundingBoxRenderer.fragment-VVOQTCND.js")]);
            } else {
              await Promise.all([import("./boundingBoxRenderer.vertex-ZXIOHHHW.js"), import("./boundingBoxRenderer.fragment-GYZSXCYY.js")]);
            }
          }
        }, false);
        this._colorShader.setDefine("INSTANCES", this._useInstances);
        this._colorShader.doNotSerialize = true;
        this._colorShader.reservedDataStore = {
          hidden: true
        };
        this._colorShaderForOcclusionQuery = new ShaderMaterial("colorShaderOccQuery", this.scene, "boundingBoxRenderer", {
          attributes: [VertexBuffer.PositionKind],
          uniforms: ["world", "viewProjection", "viewProjectionR", "color"],
          uniformBuffers: ["BoundingBoxRenderer"],
          shaderLanguage: this._shaderLanguage,
          extraInitializationsAsync: async () => {
            if (this._shaderLanguage === 1) {
              await Promise.all([import("./boundingBoxRenderer.vertex-T3IWGRNK.js"), import("./boundingBoxRenderer.fragment-VVOQTCND.js")]);
            } else {
              await Promise.all([import("./boundingBoxRenderer.vertex-ZXIOHHHW.js"), import("./boundingBoxRenderer.fragment-GYZSXCYY.js")]);
            }
          }
        }, true);
        this._colorShaderForOcclusionQuery.doNotSerialize = true;
        this._colorShaderForOcclusionQuery.reservedDataStore = {
          hidden: true
        };
        const engine = this.scene.getEngine();
        const boxdata = CreateBoxVertexData({ size: 1 });
        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, boxdata.positions, VertexBuffer.PositionKind, false);
        this._createIndexBuffer();
        this._fillIndexData = boxdata.indices;
        this.onResourcesReadyObservable.notifyObservers(this);
      }
      _createIndexBuffer() {
        const engine = this.scene.getEngine();
        this._indexBuffer = engine.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);
      }
      /**
       * Rebuilds the elements related to this component in case of
       * context lost for instance.
       */
      rebuild() {
        const vb = this._vertexBuffers[VertexBuffer.PositionKind];
        if (vb) {
          vb._rebuild();
        }
        this._createIndexBuffer();
        if (this._matrixBuffer) {
          this._matrixBuffer._rebuild();
        }
      }
      /**
       * @internal
       */
      reset() {
        this.renderList.reset();
      }
      /**
       * Render the bounding boxes of a specific rendering group
       * @param renderingGroupId defines the rendering group to render
       */
      render(renderingGroupId) {
        if (this.renderList.length === 0 || !this.enabled) {
          return;
        }
        if (this._useInstances) {
          this._renderInstanced(renderingGroupId);
          return;
        }
        this._prepareResources();
        if (!this._colorShader.isReady()) {
          return;
        }
        const engine = this.scene.getEngine();
        engine.setDepthWrite(false);
        const transformMatrix = this.scene.getTransformMatrix();
        for (let boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {
          const boundingBox = this.renderList.data[boundingBoxIndex];
          if (boundingBox._tag !== renderingGroupId) {
            continue;
          }
          this._createWrappersForBoundingBox(boundingBox);
          this.onBeforeBoxRenderingObservable.notifyObservers(boundingBox);
          const min = boundingBox.minimum;
          const max = boundingBox.maximum;
          const diff = max.subtract(min);
          const median = min.add(diff.scale(0.5));
          const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());
          const useReverseDepthBuffer = engine.useReverseDepthBuffer;
          if (this.showBackLines) {
            const drawWrapperBack = boundingBox._drawWrapperBack ?? this._colorShader._getDrawWrapper();
            this._colorShader._preBind(drawWrapperBack);
            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());
            if (useReverseDepthBuffer) {
              engine.setDepthFunctionToLessOrEqual();
            } else {
              engine.setDepthFunctionToGreaterOrEqual();
            }
            this._uniformBufferBack.bindToEffect(drawWrapperBack.effect, "BoundingBoxRenderer");
            this._uniformBufferBack.updateColor4("color", this.backColor, 1);
            this._uniformBufferBack.updateMatrix("world", worldMatrix);
            this._uniformBufferBack.updateMatrix("viewProjection", transformMatrix);
            this._uniformBufferBack.update();
            engine.drawElementsType(Material.LineListDrawMode, 0, 24);
          }
          const drawWrapperFront = boundingBox._drawWrapperFront ?? this._colorShader._getDrawWrapper();
          this._colorShader._preBind(drawWrapperFront);
          engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());
          if (useReverseDepthBuffer) {
            engine.setDepthFunctionToGreater();
          } else {
            engine.setDepthFunctionToLess();
          }
          this._uniformBufferFront.bindToEffect(drawWrapperFront.effect, "BoundingBoxRenderer");
          this._uniformBufferFront.updateColor4("color", this.frontColor, 1);
          this._uniformBufferFront.updateMatrix("world", worldMatrix);
          this._uniformBufferFront.updateMatrix("viewProjection", transformMatrix);
          this._uniformBufferFront.update();
          engine.drawElementsType(Material.LineListDrawMode, 0, 24);
          this.onAfterBoxRenderingObservable.notifyObservers(boundingBox);
        }
        this._colorShader.unbind();
        engine.setDepthFunctionToLessOrEqual();
        engine.setDepthWrite(true);
      }
      _createWrappersForBoundingBox(boundingBox) {
        if (!boundingBox._drawWrapperFront) {
          const engine = this.scene.getEngine();
          boundingBox._drawWrapperFront = new DrawWrapper(engine);
          boundingBox._drawWrapperBack = new DrawWrapper(engine);
          boundingBox._drawWrapperFront.setEffect(this._colorShader.getEffect());
          boundingBox._drawWrapperBack.setEffect(this._colorShader.getEffect());
        }
      }
      /**
       * In case of occlusion queries, we can render the occlusion bounding box through this method
       * @param mesh Define the mesh to render the occlusion bounding box for
       */
      renderOcclusionBoundingBox(mesh) {
        const engine = this.scene.getEngine();
        if (this._renderPassIdForOcclusionQuery === void 0) {
          this._renderPassIdForOcclusionQuery = engine.createRenderPassId(`Render pass for occlusion query`);
        }
        const currentRenderPassId = engine.currentRenderPassId;
        engine.currentRenderPassId = this._renderPassIdForOcclusionQuery;
        this._prepareResources();
        const subMesh = mesh.subMeshes[0];
        if (!this._colorShaderForOcclusionQuery.isReady(mesh, void 0, subMesh) || !mesh.hasBoundingInfo) {
          engine.currentRenderPassId = currentRenderPassId;
          return;
        }
        if (!this._fillIndexBuffer) {
          this._fillIndexBuffer = engine.createIndexBuffer(this._fillIndexData);
        }
        const useReverseDepthBuffer = engine.useReverseDepthBuffer;
        engine.setDepthWrite(false);
        engine.setColorWrite(false);
        const boundingBox = mesh.getBoundingInfo().boundingBox;
        const min = boundingBox.minimum;
        const max = boundingBox.maximum;
        const diff = max.subtract(min);
        const median = min.add(diff.scale(0.5));
        const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());
        const drawWrapper = subMesh._drawWrapper;
        this._colorShaderForOcclusionQuery._preBind(drawWrapper);
        engine.bindBuffers(this._vertexBuffers, this._fillIndexBuffer, drawWrapper.effect);
        if (useReverseDepthBuffer) {
          engine.setDepthFunctionToGreater();
        } else {
          engine.setDepthFunctionToLess();
        }
        this.scene.resetCachedMaterial();
        this._uniformBufferFront.bindToEffect(drawWrapper.effect, "BoundingBoxRenderer");
        this._uniformBufferFront.updateMatrix("world", worldMatrix);
        this._uniformBufferFront.updateMatrix("viewProjection", this.scene.getTransformMatrix());
        this._uniformBufferFront.update();
        engine.drawElementsType(Material.TriangleFillMode, 0, 36);
        this._colorShaderForOcclusionQuery.unbind();
        engine.setDepthFunctionToLessOrEqual();
        engine.setDepthWrite(true);
        engine.setColorWrite(true);
        engine.currentRenderPassId = currentRenderPassId;
      }
      /**
       * Sets whether to use instanced rendering.
       * When not enabled, BoundingBoxRenderer renders in a loop,
       * calling engine.drawElementsType for each bounding box in renderList,
       * making every bounding box 1 or 2 draw call.
       * When enabled, it collects bounding boxes to render,
       * and render all boxes in 1 or 2 draw call.
       * This could make the rendering with many bounding boxes much faster than not enabled,
       * but could result in a difference in rendering result if
       * {@link BoundingBoxRenderer.showBackLines} enabled,
       * because drawing the black/white part of each box one after the other
       * can be different from drawing the black part of all boxes and then the white part.
       * Also, when enabled, events of {@link BoundingBoxRenderer.onBeforeBoxRenderingObservable}
       * and {@link BoundingBoxRenderer.onAfterBoxRenderingObservable} would only be triggered once
       * for one rendering, instead of once every bounding box.
       * Events would be triggered with a dummy box to keep backwards compatibility,
       * the passed bounding box has no meaning and should be ignored.
       * @param val whether to use instanced rendering
       */
      set useInstances(val) {
        this._useInstances = val;
        if (this._colorShader) {
          this._colorShader.setDefine("INSTANCES", val);
        }
        if (!val) {
          this._cleanupInstances();
        }
      }
      get useInstances() {
        return this._useInstances;
      }
      /**
       * Instanced render the bounding boxes of a specific rendering group
       * @param renderingGroupId defines the rendering group to render
       */
      _renderInstanced(renderingGroupId) {
        if (this.renderList.length === 0 || !this.enabled) {
          return;
        }
        this._prepareResources();
        if (!this._colorShader.isReady()) {
          return;
        }
        const colorShader = this._colorShader;
        let matrices = this._matrices;
        const expectedLength = this.renderList.length * 16;
        if (!matrices || matrices.length < expectedLength || matrices.length > expectedLength * 2) {
          matrices = new Float32Array(expectedLength);
          this._matrices = matrices;
        }
        this.onBeforeBoxRenderingObservable.notifyObservers(DummyBoundingBox);
        let instancesCount = 0;
        const floatingOriginOffset = this.scene.floatingOriginOffset;
        for (let boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {
          const boundingBox = this.renderList.data[boundingBoxIndex];
          if (boundingBox._tag !== renderingGroupId) {
            continue;
          }
          const min = boundingBox.minimum;
          const max = boundingBox.maximum;
          const diff = max.subtractToRef(min, TempVec2);
          const median = min.addToRef(diff.scaleToRef(0.5, TempVec1), TempVec1);
          const m = TempMatrixArray;
          m[0] = diff._x;
          m[3] = median._x;
          m[5] = diff._y;
          m[7] = median._y;
          m[10] = diff._z;
          m[11] = median._z;
          const offset = instancesCount * 16;
          TempMatrix.multiplyToArray(boundingBox.getWorldMatrix(), matrices, offset);
          matrices[offset + 12] -= floatingOriginOffset.x;
          matrices[offset + 13] -= floatingOriginOffset.y;
          matrices[offset + 14] -= floatingOriginOffset.z;
          instancesCount++;
        }
        const engine = this.scene.getEngine();
        const depthFunction = engine.getDepthFunction() ?? 515;
        const depthWrite = engine.getDepthWrite();
        engine.setDepthWrite(false);
        const matrixBuffer = this._matrixBuffer;
        if (matrixBuffer?.isUpdatable() && matrixBuffer.getData() === matrices) {
          matrixBuffer.update(matrices);
        } else {
          this._createInstanceBuffer(matrices);
        }
        this._createWrappersForBoundingBox(this);
        const useReverseDepthBuffer = engine.useReverseDepthBuffer;
        const transformMatrix = this.scene.getTransformMatrix();
        if (this.showBackLines) {
          const drawWrapperBack = this._drawWrapperBack ?? colorShader._getDrawWrapper();
          colorShader._preBind(drawWrapperBack);
          engine.bindBuffers(this._vertexBuffers, this._indexBuffer, colorShader.getEffect());
          if (useReverseDepthBuffer) {
            engine.setDepthFunctionToLessOrEqual();
          } else {
            engine.setDepthFunctionToGreaterOrEqual();
          }
          const _uniformBufferBack = this._uniformBufferBack;
          _uniformBufferBack.bindToEffect(drawWrapperBack.effect, "BoundingBoxRenderer");
          _uniformBufferBack.updateColor4("color", this.backColor, 1);
          _uniformBufferBack.updateMatrix("viewProjection", transformMatrix);
          _uniformBufferBack.update();
          engine.drawElementsType(Material.LineListDrawMode, 0, 24, instancesCount);
        }
        const drawWrapperFront = colorShader._getDrawWrapper();
        colorShader._preBind(drawWrapperFront);
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, colorShader.getEffect());
        if (useReverseDepthBuffer) {
          engine.setDepthFunctionToGreater();
        } else {
          engine.setDepthFunctionToLess();
        }
        const _uniformBufferFront = this._uniformBufferFront;
        _uniformBufferFront.bindToEffect(drawWrapperFront.effect, "BoundingBoxRenderer");
        _uniformBufferFront.updateColor4("color", this.frontColor, 1);
        _uniformBufferFront.updateMatrix("viewProjection", transformMatrix);
        _uniformBufferFront.update();
        engine.drawElementsType(Material.LineListDrawMode, 0, 24, instancesCount);
        this.onAfterBoxRenderingObservable.notifyObservers(DummyBoundingBox);
        colorShader.unbind();
        engine.setDepthFunction(depthFunction);
        engine.setDepthWrite(depthWrite);
      }
      /**
       * Creates buffer for instanced rendering
       * @param buffer buffer to set
       */
      _createInstanceBuffer(buffer) {
        const vertexBuffers = this._vertexBuffers;
        this._cleanupInstanceBuffer();
        const matrixBuffer = new Buffer(this.scene.getEngine(), buffer, true, 16, false, true);
        vertexBuffers.world0 = matrixBuffer.createVertexBuffer("world0", 0, 4);
        vertexBuffers.world1 = matrixBuffer.createVertexBuffer("world1", 4, 4);
        vertexBuffers.world2 = matrixBuffer.createVertexBuffer("world2", 8, 4);
        vertexBuffers.world3 = matrixBuffer.createVertexBuffer("world3", 12, 4);
        this._matrixBuffer = matrixBuffer;
      }
      /**
       * Clean up buffers for instanced rendering
       */
      _cleanupInstanceBuffer() {
        const vertexBuffers = this._vertexBuffers;
        if (vertexBuffers.world0) {
          vertexBuffers.world0.dispose();
          delete vertexBuffers.world0;
        }
        if (vertexBuffers.world1) {
          vertexBuffers.world1.dispose();
          delete vertexBuffers.world1;
        }
        if (vertexBuffers.world2) {
          vertexBuffers.world2.dispose();
          delete vertexBuffers.world2;
        }
        if (vertexBuffers.world3) {
          vertexBuffers.world3.dispose();
          delete vertexBuffers.world3;
        }
        this._matrices = null;
        if (this._matrixBuffer) {
          this._matrixBuffer.dispose();
          this._matrixBuffer = null;
        }
      }
      /**
       * Clean up resources for instanced rendering
       */
      _cleanupInstances() {
        this._cleanupInstanceBuffer();
        if (this._drawWrapperFront) {
          this._drawWrapperFront.dispose();
          this._drawWrapperFront = null;
        }
        if (this._drawWrapperBack) {
          this._drawWrapperBack.dispose();
          this._drawWrapperBack = null;
        }
      }
      /**
       * Dispose and release the resources attached to this renderer.
       */
      dispose() {
        if (this._renderPassIdForOcclusionQuery !== void 0) {
          this.scene.getEngine().releaseRenderPassId(this._renderPassIdForOcclusionQuery);
          this._renderPassIdForOcclusionQuery = void 0;
        }
        if (!this._colorShader) {
          return;
        }
        this.onBeforeBoxRenderingObservable.clear();
        this.onAfterBoxRenderingObservable.clear();
        this.onResourcesReadyObservable.clear();
        this.renderList.dispose();
        this._colorShader.dispose();
        this._colorShaderForOcclusionQuery.dispose();
        this._uniformBufferFront.dispose();
        this._uniformBufferBack.dispose();
        const buffer = this._vertexBuffers[VertexBuffer.PositionKind];
        if (buffer) {
          buffer.dispose();
          this._vertexBuffers[VertexBuffer.PositionKind] = null;
        }
        this.scene.getEngine()._releaseBuffer(this._indexBuffer);
        if (this._fillIndexBuffer) {
          this.scene.getEngine()._releaseBuffer(this._fillIndexBuffer);
          this._fillIndexBuffer = null;
        }
        this._cleanupInstances();
      }
    };
  }
});

// node_modules/@babylonjs/core/Rendering/edgesRenderer.js
var FaceAdjacencies, EdgesRenderer, LineEdgesRenderer;
var init_edgesRenderer = __esm({
  "node_modules/@babylonjs/core/Rendering/edgesRenderer.js"() {
    init_buffer();
    init_abstractMesh();
    init_linesMesh();
    init_math_vector();
    init_material();
    init_shaderMaterial();
    init_camera();
    init_smartArray();
    init_drawWrapper();
    AbstractMesh.prototype.disableEdgesRendering = function() {
      if (this._edgesRenderer) {
        this._edgesRenderer.dispose();
        this._edgesRenderer = null;
      }
      return this;
    };
    AbstractMesh.prototype.enableEdgesRendering = function(epsilon = 0.95, checkVerticesInsteadOfIndices = false, options) {
      this.disableEdgesRendering();
      this._edgesRenderer = new EdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices, true, options);
      return this;
    };
    Object.defineProperty(AbstractMesh.prototype, "edgesRenderer", {
      get: function() {
        return this._edgesRenderer;
      },
      enumerable: true,
      configurable: true
    });
    LinesMesh.prototype.enableEdgesRendering = function(epsilon = 0.95, checkVerticesInsteadOfIndices = false) {
      this.disableEdgesRendering();
      this._edgesRenderer = new LineEdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices);
      return this;
    };
    InstancedLinesMesh.prototype.enableEdgesRendering = function(epsilon = 0.95, checkVerticesInsteadOfIndices = false) {
      LinesMesh.prototype.enableEdgesRendering.apply(this, arguments);
      return this;
    };
    FaceAdjacencies = class {
      constructor() {
        this.edges = [];
        this.edgesConnectedCount = 0;
      }
    };
    EdgesRenderer = class _EdgesRenderer {
      /** Gets the vertices generated by the edge renderer */
      get linesPositions() {
        return this._linesPositions;
      }
      /** Gets the normals generated by the edge renderer */
      get linesNormals() {
        return this._linesNormals;
      }
      /** Gets the indices generated by the edge renderer */
      get linesIndices() {
        return this._linesIndices;
      }
      /**
       * Gets or sets the shader used to draw the lines
       */
      get lineShader() {
        return this._lineShader;
      }
      set lineShader(shader13) {
        this._lineShader = shader13;
      }
      static _GetShader(scene, shaderLanguage) {
        if (!scene._edgeRenderLineShader) {
          const shader13 = new ShaderMaterial("lineShader", scene, "line", {
            attributes: ["position", "normal"],
            uniforms: ["world", "viewProjection", "color", "width", "aspectRatio"],
            uniformBuffers: ["Scene", "Mesh"],
            shaderLanguage,
            extraInitializationsAsync: async () => {
              if (shaderLanguage === 1) {
                await Promise.all([import("./line.vertex-73MUCA5M.js"), import("./line.fragment-6ZOZGIZB.js")]);
              } else {
                await Promise.all([import("./line.vertex-B5REKIMI.js"), import("./line.fragment-CCGYAAKI.js")]);
              }
            }
          }, false);
          shader13.disableDepthWrite = true;
          shader13.backFaceCulling = false;
          shader13.checkReadyOnEveryCall = scene.getEngine().isWebGPU;
          scene._edgeRenderLineShader = shader13;
          scene.onDisposeObservable.add(() => {
            scene._edgeRenderLineShader.dispose();
            scene._edgeRenderLineShader = null;
          });
        }
        return scene._edgeRenderLineShader;
      }
      /**
       * Gets the shader language used.
       */
      get shaderLanguage() {
        return this._shaderLanguage;
      }
      /**
       * Creates an instance of the EdgesRenderer. It is primarily use to display edges of a mesh.
       * Beware when you use this class with complex objects as the adjacencies computation can be really long
       * @param  source Mesh used to create edges
       * @param  epsilon sum of angles in adjacency to check for edge
       * @param  checkVerticesInsteadOfIndices bases the edges detection on vertices vs indices. Note that this parameter is not used if options.useAlternateEdgeFinder = true
       * @param  generateEdgesLines - should generate Lines or only prepare resources.
       * @param  options The options to apply when generating the edges
       */
      constructor(source, epsilon = 0.95, checkVerticesInsteadOfIndices = false, generateEdgesLines = true, options) {
        this.edgesWidthScalerForOrthographic = 1e3;
        this.edgesWidthScalerForPerspective = 50;
        this._linesPositions = new Array();
        this._linesNormals = new Array();
        this._linesIndices = new Array();
        this._buffers = {};
        this._buffersForInstances = {};
        this._checkVerticesInsteadOfIndices = false;
        this.isEnabled = true;
        this.customInstances = new SmartArray(32);
        this._shaderLanguage = 0;
        this._source = source;
        this._checkVerticesInsteadOfIndices = checkVerticesInsteadOfIndices;
        this._options = options ?? null;
        this._epsilon = epsilon;
        const engine = this._source.getScene().getEngine();
        if (engine.isWebGPU) {
          this._drawWrapper = new DrawWrapper(engine);
          this._shaderLanguage = 1;
        }
        this._prepareResources();
        if (generateEdgesLines) {
          if (options?.useAlternateEdgeFinder ?? true) {
            this._generateEdgesLinesAlternate();
          } else {
            this._generateEdgesLines();
          }
        }
        this._meshRebuildObserver = this._source.onRebuildObservable.add(() => {
          this._rebuild();
        });
        this._meshDisposeObserver = this._source.onDisposeObservable.add(() => {
          this.dispose();
        });
      }
      _prepareResources() {
        if (this._lineShader) {
          return;
        }
        this._lineShader = _EdgesRenderer._GetShader(this._source.getScene(), this._shaderLanguage);
      }
      /** @internal */
      _rebuild() {
        let buffer = this._buffers[VertexBuffer.PositionKind];
        if (buffer) {
          buffer._rebuild();
        }
        buffer = this._buffers[VertexBuffer.NormalKind];
        if (buffer) {
          buffer._rebuild();
        }
        const scene = this._source.getScene();
        const engine = scene.getEngine();
        this._ib = engine.createIndexBuffer(this._linesIndices);
      }
      /**
       * Releases the required resources for the edges renderer
       */
      dispose() {
        this._source.onRebuildObservable.remove(this._meshRebuildObserver);
        this._source.onDisposeObservable.remove(this._meshDisposeObserver);
        let buffer = this._buffers[VertexBuffer.PositionKind];
        if (buffer) {
          buffer.dispose();
          this._buffers[VertexBuffer.PositionKind] = null;
        }
        buffer = this._buffers[VertexBuffer.NormalKind];
        if (buffer) {
          buffer.dispose();
          this._buffers[VertexBuffer.NormalKind] = null;
        }
        if (this._ib) {
          this._source.getScene().getEngine()._releaseBuffer(this._ib);
        }
        this._drawWrapper?.dispose();
      }
      _processEdgeForAdjacencies(pa, pb, p0, p1, p2) {
        if (pa === p0 && pb === p1 || pa === p1 && pb === p0) {
          return 0;
        }
        if (pa === p1 && pb === p2 || pa === p2 && pb === p1) {
          return 1;
        }
        if (pa === p2 && pb === p0 || pa === p0 && pb === p2) {
          return 2;
        }
        return -1;
      }
      _processEdgeForAdjacenciesWithVertices(pa, pb, p0, p1, p2) {
        const eps = 1e-10;
        if (pa.equalsWithEpsilon(p0, eps) && pb.equalsWithEpsilon(p1, eps) || pa.equalsWithEpsilon(p1, eps) && pb.equalsWithEpsilon(p0, eps)) {
          return 0;
        }
        if (pa.equalsWithEpsilon(p1, eps) && pb.equalsWithEpsilon(p2, eps) || pa.equalsWithEpsilon(p2, eps) && pb.equalsWithEpsilon(p1, eps)) {
          return 1;
        }
        if (pa.equalsWithEpsilon(p2, eps) && pb.equalsWithEpsilon(p0, eps) || pa.equalsWithEpsilon(p0, eps) && pb.equalsWithEpsilon(p2, eps)) {
          return 2;
        }
        return -1;
      }
      /**
       * Checks if the pair of p0 and p1 is en edge
       * @param faceIndex
       * @param edge
       * @param faceNormals
       * @param  p0
       * @param  p1
       * @private
       */
      _checkEdge(faceIndex, edge, faceNormals, p0, p1) {
        let needToCreateLine;
        if (edge === void 0) {
          needToCreateLine = true;
        } else {
          const dotProduct = Vector3.Dot(faceNormals[faceIndex], faceNormals[edge]);
          needToCreateLine = dotProduct < this._epsilon;
        }
        if (needToCreateLine) {
          this.createLine(p0, p1, this._linesPositions.length / 3);
        }
      }
      /**
       * push line into the position, normal and index buffer
       * @param p0
       * @param p1
       * @param offset
       * @protected
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      createLine(p0, p1, offset) {
        this._linesPositions.push(p0.x, p0.y, p0.z, p0.x, p0.y, p0.z, p1.x, p1.y, p1.z, p1.x, p1.y, p1.z);
        this._linesNormals.push(p1.x, p1.y, p1.z, -1, p1.x, p1.y, p1.z, 1, p0.x, p0.y, p0.z, -1, p0.x, p0.y, p0.z, 1);
        this._linesIndices.push(offset, offset + 1, offset + 2, offset, offset + 2, offset + 3);
      }
      /**
       * See https://playground.babylonjs.com/#R3JR6V#1 for a visual display of the algorithm
       * @param edgePoints
       * @param indexTriangle
       * @param indices
       * @param remapVertexIndices
       */
      _tessellateTriangle(edgePoints, indexTriangle, indices, remapVertexIndices) {
        const makePointList = (edgePoints2, pointIndices, firstIndex) => {
          if (firstIndex >= 0) {
            pointIndices.push(firstIndex);
          }
          for (let i = 0; i < edgePoints2.length; ++i) {
            pointIndices.push(edgePoints2[i][0]);
          }
        };
        let startEdge = 0;
        if (edgePoints[1].length >= edgePoints[0].length && edgePoints[1].length >= edgePoints[2].length) {
          startEdge = 1;
        } else if (edgePoints[2].length >= edgePoints[0].length && edgePoints[2].length >= edgePoints[1].length) {
          startEdge = 2;
        }
        for (let e = 0; e < 3; ++e) {
          if (e === startEdge) {
            edgePoints[e].sort((a, b) => a[1] < b[1] ? -1 : a[1] > b[1] ? 1 : 0);
          } else {
            edgePoints[e].sort((a, b) => a[1] > b[1] ? -1 : a[1] < b[1] ? 1 : 0);
          }
        }
        const mainPointIndices = [], otherPointIndices = [];
        makePointList(edgePoints[startEdge], mainPointIndices, -1);
        const numMainPoints = mainPointIndices.length;
        for (let i = startEdge + 2; i >= startEdge + 1; --i) {
          makePointList(edgePoints[i % 3], otherPointIndices, i !== startEdge + 2 ? remapVertexIndices[indices[indexTriangle + (i + 1) % 3]] : -1);
        }
        const numOtherPoints = otherPointIndices.length;
        const idxMain = 0;
        const idxOther = 0;
        indices.push(remapVertexIndices[indices[indexTriangle + startEdge]], mainPointIndices[0], otherPointIndices[0]);
        indices.push(remapVertexIndices[indices[indexTriangle + (startEdge + 1) % 3]], otherPointIndices[numOtherPoints - 1], mainPointIndices[numMainPoints - 1]);
        const bucketIsMain = numMainPoints <= numOtherPoints;
        const bucketStep = bucketIsMain ? numMainPoints : numOtherPoints;
        const bucketLimit = bucketIsMain ? numOtherPoints : numMainPoints;
        const bucketIdxLimit = bucketIsMain ? numMainPoints - 1 : numOtherPoints - 1;
        const winding = bucketIsMain ? 0 : 1;
        let numTris = numMainPoints + numOtherPoints - 2;
        let bucketIdx = bucketIsMain ? idxMain : idxOther;
        let nbucketIdx = bucketIsMain ? idxOther : idxMain;
        const bucketPoints = bucketIsMain ? mainPointIndices : otherPointIndices;
        const nbucketPoints = bucketIsMain ? otherPointIndices : mainPointIndices;
        let bucket = 0;
        while (numTris-- > 0) {
          if (winding) {
            indices.push(bucketPoints[bucketIdx], nbucketPoints[nbucketIdx]);
          } else {
            indices.push(nbucketPoints[nbucketIdx], bucketPoints[bucketIdx]);
          }
          bucket += bucketStep;
          let lastIdx;
          if (bucket >= bucketLimit && bucketIdx < bucketIdxLimit) {
            lastIdx = bucketPoints[++bucketIdx];
            bucket -= bucketLimit;
          } else {
            lastIdx = nbucketPoints[++nbucketIdx];
          }
          indices.push(lastIdx);
        }
        indices[indexTriangle + 0] = indices[indices.length - 3];
        indices[indexTriangle + 1] = indices[indices.length - 2];
        indices[indexTriangle + 2] = indices[indices.length - 1];
        indices.length = indices.length - 3;
      }
      _generateEdgesLinesAlternate() {
        const positions = this._source.getVerticesData(VertexBuffer.PositionKind);
        let indices = this._source.getIndices();
        if (!indices || !positions) {
          return;
        }
        if (!Array.isArray(indices)) {
          indices = Array.from(indices);
        }
        const useFastVertexMerger = this._options?.useFastVertexMerger ?? true;
        const epsVertexMerge = useFastVertexMerger ? Math.round(-Math.log(this._options?.epsilonVertexMerge ?? 1e-6) / Math.log(10)) : this._options?.epsilonVertexMerge ?? 1e-6;
        const remapVertexIndices = [];
        const uniquePositions = [];
        if (useFastVertexMerger) {
          const mapVertices = {};
          for (let v1 = 0; v1 < positions.length; v1 += 3) {
            const x1 = positions[v1 + 0], y1 = positions[v1 + 1], z1 = positions[v1 + 2];
            const key = x1.toFixed(epsVertexMerge) + "|" + y1.toFixed(epsVertexMerge) + "|" + z1.toFixed(epsVertexMerge);
            if (mapVertices[key] !== void 0) {
              remapVertexIndices.push(mapVertices[key]);
            } else {
              const idx = v1 / 3;
              mapVertices[key] = idx;
              remapVertexIndices.push(idx);
              uniquePositions.push(idx);
            }
          }
        } else {
          for (let v1 = 0; v1 < positions.length; v1 += 3) {
            const x1 = positions[v1 + 0], y1 = positions[v1 + 1], z1 = positions[v1 + 2];
            let found = false;
            for (let v2 = 0; v2 < v1 && !found; v2 += 3) {
              const x2 = positions[v2 + 0], y2 = positions[v2 + 1], z2 = positions[v2 + 2];
              if (Math.abs(x1 - x2) < epsVertexMerge && Math.abs(y1 - y2) < epsVertexMerge && Math.abs(z1 - z2) < epsVertexMerge) {
                remapVertexIndices.push(v2 / 3);
                found = true;
                break;
              }
            }
            if (!found) {
              remapVertexIndices.push(v1 / 3);
              uniquePositions.push(v1 / 3);
            }
          }
        }
        if (this._options?.applyTessellation) {
          const epsVertexAligned = this._options?.epsilonVertexAligned ?? 1e-6;
          const mustTesselate = [];
          for (let index = 0; index < indices.length; index += 3) {
            let triangleToTessellate;
            for (let i = 0; i < 3; ++i) {
              const p0Index = remapVertexIndices[indices[index + i]];
              const p1Index = remapVertexIndices[indices[index + (i + 1) % 3]];
              const p2Index = remapVertexIndices[indices[index + (i + 2) % 3]];
              if (p0Index === p1Index) {
                continue;
              }
              const p0x = positions[p0Index * 3 + 0], p0y = positions[p0Index * 3 + 1], p0z = positions[p0Index * 3 + 2];
              const p1x = positions[p1Index * 3 + 0], p1y = positions[p1Index * 3 + 1], p1z = positions[p1Index * 3 + 2];
              const p0p1 = Math.sqrt((p1x - p0x) * (p1x - p0x) + (p1y - p0y) * (p1y - p0y) + (p1z - p0z) * (p1z - p0z));
              for (let v = 0; v < uniquePositions.length - 1; v++) {
                const vIndex = uniquePositions[v];
                if (vIndex === p0Index || vIndex === p1Index || vIndex === p2Index) {
                  continue;
                }
                const x = positions[vIndex * 3 + 0], y = positions[vIndex * 3 + 1], z = positions[vIndex * 3 + 2];
                const p0p = Math.sqrt((x - p0x) * (x - p0x) + (y - p0y) * (y - p0y) + (z - p0z) * (z - p0z));
                const pp1 = Math.sqrt((x - p1x) * (x - p1x) + (y - p1y) * (y - p1y) + (z - p1z) * (z - p1z));
                if (Math.abs(p0p + pp1 - p0p1) < epsVertexAligned) {
                  if (!triangleToTessellate) {
                    triangleToTessellate = {
                      index,
                      edgesPoints: [[], [], []]
                    };
                    mustTesselate.push(triangleToTessellate);
                  }
                  triangleToTessellate.edgesPoints[i].push([vIndex, p0p]);
                }
              }
            }
          }
          for (let t = 0; t < mustTesselate.length; ++t) {
            const triangle = mustTesselate[t];
            this._tessellateTriangle(triangle.edgesPoints, triangle.index, indices, remapVertexIndices);
          }
          mustTesselate.length = 0;
        }
        const edges = {};
        for (let index = 0; index < indices.length; index += 3) {
          let faceNormal;
          for (let i = 0; i < 3; ++i) {
            let p0Index = remapVertexIndices[indices[index + i]];
            let p1Index = remapVertexIndices[indices[index + (i + 1) % 3]];
            const p2Index = remapVertexIndices[indices[index + (i + 2) % 3]];
            if (p0Index === p1Index || (p0Index === p2Index || p1Index === p2Index) && this._options?.removeDegeneratedTriangles) {
              continue;
            }
            TmpVectors.Vector3[0].copyFromFloats(positions[p0Index * 3 + 0], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);
            TmpVectors.Vector3[1].copyFromFloats(positions[p1Index * 3 + 0], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);
            TmpVectors.Vector3[2].copyFromFloats(positions[p2Index * 3 + 0], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);
            if (!faceNormal) {
              TmpVectors.Vector3[1].subtractToRef(TmpVectors.Vector3[0], TmpVectors.Vector3[3]);
              TmpVectors.Vector3[2].subtractToRef(TmpVectors.Vector3[1], TmpVectors.Vector3[4]);
              faceNormal = Vector3.Cross(TmpVectors.Vector3[3], TmpVectors.Vector3[4]);
              faceNormal.normalize();
            }
            if (p0Index > p1Index) {
              const tmp = p0Index;
              p0Index = p1Index;
              p1Index = tmp;
            }
            const key = p0Index + "_" + p1Index;
            const ei = edges[key];
            if (ei) {
              if (!ei.done) {
                const dotProduct = Vector3.Dot(faceNormal, ei.normal);
                if (dotProduct < this._epsilon) {
                  this.createLine(TmpVectors.Vector3[0], TmpVectors.Vector3[1], this._linesPositions.length / 3);
                }
                ei.done = true;
              }
            } else {
              edges[key] = { normal: faceNormal, done: false, index, i };
            }
          }
        }
        for (const key in edges) {
          const ei = edges[key];
          if (!ei.done) {
            const p0Index = remapVertexIndices[indices[ei.index + ei.i]];
            const p1Index = remapVertexIndices[indices[ei.index + (ei.i + 1) % 3]];
            TmpVectors.Vector3[0].copyFromFloats(positions[p0Index * 3 + 0], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);
            TmpVectors.Vector3[1].copyFromFloats(positions[p1Index * 3 + 0], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);
            this.createLine(TmpVectors.Vector3[0], TmpVectors.Vector3[1], this._linesPositions.length / 3);
          }
        }
        const engine = this._source.getScene().getEngine();
        this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);
        this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);
        this._buffersForInstances[VertexBuffer.PositionKind] = this._buffers[VertexBuffer.PositionKind];
        this._buffersForInstances[VertexBuffer.NormalKind] = this._buffers[VertexBuffer.NormalKind];
        this._ib = engine.createIndexBuffer(this._linesIndices);
        this._indicesCount = this._linesIndices.length;
      }
      /**
       * Generates lines edges from adjacencjes
       * @private
       */
      _generateEdgesLines() {
        const positions = this._source.getVerticesData(VertexBuffer.PositionKind);
        const indices = this._source.getIndices();
        if (!indices || !positions) {
          return;
        }
        const adjacencies = [];
        const faceNormals = [];
        let index;
        let faceAdjacencies;
        for (index = 0; index < indices.length; index += 3) {
          faceAdjacencies = new FaceAdjacencies();
          const p0Index = indices[index];
          const p1Index = indices[index + 1];
          const p2Index = indices[index + 2];
          faceAdjacencies.p0 = new Vector3(positions[p0Index * 3], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);
          faceAdjacencies.p1 = new Vector3(positions[p1Index * 3], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);
          faceAdjacencies.p2 = new Vector3(positions[p2Index * 3], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);
          const faceNormal = Vector3.Cross(faceAdjacencies.p1.subtract(faceAdjacencies.p0), faceAdjacencies.p2.subtract(faceAdjacencies.p1));
          faceNormal.normalize();
          faceNormals.push(faceNormal);
          adjacencies.push(faceAdjacencies);
        }
        for (index = 0; index < adjacencies.length; index++) {
          faceAdjacencies = adjacencies[index];
          for (let otherIndex = index + 1; otherIndex < adjacencies.length; otherIndex++) {
            const otherFaceAdjacencies = adjacencies[otherIndex];
            if (faceAdjacencies.edgesConnectedCount === 3) {
              break;
            }
            if (otherFaceAdjacencies.edgesConnectedCount === 3) {
              continue;
            }
            const otherP0 = indices[otherIndex * 3];
            const otherP1 = indices[otherIndex * 3 + 1];
            const otherP2 = indices[otherIndex * 3 + 2];
            for (let edgeIndex = 0; edgeIndex < 3; edgeIndex++) {
              let otherEdgeIndex = 0;
              if (faceAdjacencies.edges[edgeIndex] !== void 0) {
                continue;
              }
              switch (edgeIndex) {
                case 0:
                  if (this._checkVerticesInsteadOfIndices) {
                    otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p0, faceAdjacencies.p1, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);
                  } else {
                    otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3], indices[index * 3 + 1], otherP0, otherP1, otherP2);
                  }
                  break;
                case 1:
                  if (this._checkVerticesInsteadOfIndices) {
                    otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p1, faceAdjacencies.p2, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);
                  } else {
                    otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 1], indices[index * 3 + 2], otherP0, otherP1, otherP2);
                  }
                  break;
                case 2:
                  if (this._checkVerticesInsteadOfIndices) {
                    otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p2, faceAdjacencies.p0, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);
                  } else {
                    otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 2], indices[index * 3], otherP0, otherP1, otherP2);
                  }
                  break;
              }
              if (otherEdgeIndex === -1) {
                continue;
              }
              faceAdjacencies.edges[edgeIndex] = otherIndex;
              otherFaceAdjacencies.edges[otherEdgeIndex] = index;
              faceAdjacencies.edgesConnectedCount++;
              otherFaceAdjacencies.edgesConnectedCount++;
              if (faceAdjacencies.edgesConnectedCount === 3) {
                break;
              }
            }
          }
        }
        for (index = 0; index < adjacencies.length; index++) {
          const current = adjacencies[index];
          this._checkEdge(index, current.edges[0], faceNormals, current.p0, current.p1);
          this._checkEdge(index, current.edges[1], faceNormals, current.p1, current.p2);
          this._checkEdge(index, current.edges[2], faceNormals, current.p2, current.p0);
        }
        const engine = this._source.getScene().getEngine();
        this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);
        this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);
        this._buffersForInstances[VertexBuffer.PositionKind] = this._buffers[VertexBuffer.PositionKind];
        this._buffersForInstances[VertexBuffer.NormalKind] = this._buffers[VertexBuffer.NormalKind];
        this._ib = engine.createIndexBuffer(this._linesIndices);
        this._indicesCount = this._linesIndices.length;
      }
      /**
       * Checks whether or not the edges renderer is ready to render.
       * @returns true if ready, otherwise false.
       */
      isReady() {
        return this._lineShader.isReady(this._source, this._source.hasInstances && this.customInstances.length > 0 || this._source.hasThinInstances);
      }
      /**
       * Renders the edges of the attached mesh,
       */
      render() {
        const scene = this._source.getScene();
        const floatingOriginOffset = scene.floatingOriginOffset;
        const currentDrawWrapper = this._lineShader._getDrawWrapper();
        if (this._drawWrapper) {
          this._lineShader._setDrawWrapper(this._drawWrapper);
        }
        if (!this.isReady() || !scene.activeCamera) {
          this._lineShader._setDrawWrapper(currentDrawWrapper);
          return;
        }
        const hasInstances = this._source.hasInstances && this.customInstances.length > 0;
        const useBuffersWithInstances = hasInstances || this._source.hasThinInstances;
        let instanceCount = 0;
        if (useBuffersWithInstances) {
          this._buffersForInstances["world0"] = this._source.getVertexBuffer("world0");
          this._buffersForInstances["world1"] = this._source.getVertexBuffer("world1");
          this._buffersForInstances["world2"] = this._source.getVertexBuffer("world2");
          this._buffersForInstances["world3"] = this._source.getVertexBuffer("world3");
          if (hasInstances) {
            const instanceStorage = this._source._getInstanceDataStorage();
            const isFrozen = this._source._instanceDataStorage.isFrozen;
            instanceCount = this.customInstances.length;
            if (!instanceStorage.instancesData) {
              if (!this._source.getScene()._activeMeshesFrozen) {
                this.customInstances.reset();
              }
              return;
            }
            if (!isFrozen) {
              let offset = 0;
              for (let i = 0; i < instanceCount; ++i) {
                this.customInstances.data[i].copyToArray(instanceStorage.instancesData, offset);
                instanceStorage.instancesData[offset + 12] -= floatingOriginOffset.x;
                instanceStorage.instancesData[offset + 13] -= floatingOriginOffset.y;
                instanceStorage.instancesData[offset + 14] -= floatingOriginOffset.z;
                offset += 16;
              }
              instanceStorage.instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instanceCount);
            }
          } else {
            instanceCount = this._source.thinInstanceCount;
          }
        }
        const engine = scene.getEngine();
        this._lineShader._preBind();
        if (this._source.edgesColor.a !== 1) {
          engine.setAlphaMode(2);
        } else {
          engine.setAlphaMode(0);
        }
        engine.bindBuffers(useBuffersWithInstances ? this._buffersForInstances : this._buffers, this._ib, this._lineShader.getEffect());
        scene.resetCachedMaterial();
        this._lineShader.setColor4("color", this._source.edgesColor);
        if (scene.activeCamera.mode === Camera.ORTHOGRAPHIC_CAMERA) {
          this._lineShader.setFloat("width", this._source.edgesWidth / this.edgesWidthScalerForOrthographic);
        } else {
          this._lineShader.setFloat("width", this._source.edgesWidth / this.edgesWidthScalerForPerspective);
        }
        this._lineShader.setFloat("aspectRatio", engine.getAspectRatio(scene.activeCamera));
        this._lineShader.bind(this._source.getWorldMatrix(), this._source);
        engine.drawElementsType(Material.TriangleFillMode, 0, this._indicesCount, instanceCount);
        this._lineShader.unbind();
        if (useBuffersWithInstances) {
          engine.unbindInstanceAttributes();
        }
        if (!this._source.getScene()._activeMeshesFrozen) {
          this.customInstances.reset();
        }
        this._lineShader._setDrawWrapper(currentDrawWrapper);
      }
    };
    LineEdgesRenderer = class extends EdgesRenderer {
      /**
       * This constructor turns off auto generating edges line in Edges Renderer to make it here.
       * @param  source LineMesh used to generate edges
       * @param  epsilon not important (specified angle for edge detection)
       * @param  checkVerticesInsteadOfIndices not important for LineMesh
       */
      constructor(source, epsilon = 0.95, checkVerticesInsteadOfIndices = false) {
        super(source, epsilon, checkVerticesInsteadOfIndices, false);
        this._generateEdgesLines();
      }
      /**
       * Generate edges for each line in LinesMesh. Every Line should be rendered as edge.
       */
      _generateEdgesLines() {
        const positions = this._source.getVerticesData(VertexBuffer.PositionKind);
        const indices = this._source.getIndices();
        if (!indices || !positions) {
          return;
        }
        const p0 = TmpVectors.Vector3[0];
        const p1 = TmpVectors.Vector3[1];
        const len = indices.length - 1;
        for (let i = 0, offset = 0; i < len; i += 2, offset += 4) {
          Vector3.FromArrayToRef(positions, 3 * indices[i], p0);
          Vector3.FromArrayToRef(positions, 3 * indices[i + 1], p1);
          this.createLine(p0, p1, offset);
        }
        const engine = this._source.getScene().getEngine();
        this._buffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, this._linesPositions, VertexBuffer.PositionKind, false);
        this._buffers[VertexBuffer.NormalKind] = new VertexBuffer(engine, this._linesNormals, VertexBuffer.NormalKind, false, false, 4);
        this._ib = engine.createIndexBuffer(this._linesIndices);
        this._indicesCount = this._linesIndices.length;
      }
    };
  }
});

// node_modules/@babylonjs/core/Rendering/iblCdfGeneratorSceneComponent.js
var IblCdfGeneratorSceneComponent;
var init_iblCdfGeneratorSceneComponent = __esm({
  "node_modules/@babylonjs/core/Rendering/iblCdfGeneratorSceneComponent.js"() {
    init_scene();
    init_sceneComponent();
    init_iblCdfGenerator();
    Object.defineProperty(Scene.prototype, "iblCdfGenerator", {
      get: function() {
        return this._iblCdfGenerator;
      },
      set: function(value) {
        if (value) {
          this._iblCdfGenerator = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Scene.prototype.enableIblCdfGenerator = function() {
      if (this._iblCdfGenerator) {
        return this._iblCdfGenerator;
      }
      this._iblCdfGenerator = new IblCdfGenerator(this);
      if (!this._iblCdfGenerator.isSupported) {
        this._iblCdfGenerator = null;
        return null;
      }
      if (this.environmentTexture) {
        this._iblCdfGenerator.iblSource = this.environmentTexture;
      }
      return this._iblCdfGenerator;
    };
    Scene.prototype.disableIblCdfGenerator = function() {
      if (!this._iblCdfGenerator) {
        return;
      }
      this._iblCdfGenerator.dispose();
      this._iblCdfGenerator = null;
    };
    IblCdfGeneratorSceneComponent = class {
      /**
       * Creates a new instance of the component for the given scene
       * @param scene Defines the scene to register the component in
       */
      constructor(scene) {
        this.name = SceneComponentConstants.NAME_IBLCDFGENERATOR;
        this._newIblObserver = null;
        this.scene = scene;
      }
      /**
       * Registers the component in a given scene
       */
      register() {
        this._updateIblSource();
        this._newIblObserver = this.scene.onEnvironmentTextureChangedObservable.add(this._updateIblSource.bind(this));
      }
      /**
       * Rebuilds the elements related to this component in case of
       * context lost for instance.
       */
      rebuild() {
      }
      /**
       * Disposes the component and the associated resources
       */
      dispose() {
        this.scene.onEnvironmentTextureChangedObservable.remove(this._newIblObserver);
      }
      _updateIblSource() {
        if (this.scene.iblCdfGenerator && this.scene.environmentTexture) {
          this.scene.iblCdfGenerator.iblSource = this.scene.environmentTexture;
        }
      }
    };
    IblCdfGenerator._SceneComponentInitialization = (scene) => {
      let component = scene._getComponent(SceneComponentConstants.NAME_IBLCDFGENERATOR);
      if (!component) {
        component = new IblCdfGeneratorSceneComponent(scene);
        scene._addComponent(component);
      }
    };
  }
});

// node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsVoxelRenderer.js
var _IblShadowsVoxelRenderer;
var init_iblShadowsVoxelRenderer = __esm({
  "node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsVoxelRenderer.js"() {
    init_engine();
    init_shaderMaterial();
    init_multiRenderTarget();
    init_renderTargetTexture();
    init_math_color();
    init_math_vector();
    init_texture();
    init_logger();
    init_observable();
    init_postProcess();
    init_proceduralTexture();
    init_effectRenderer();
    _IblShadowsVoxelRenderer = class {
      /**
       * Return the voxel grid texture.
       * @returns The voxel grid texture.
       */
      getVoxelGrid() {
        if (this._engine.isWebGPU) {
          return this._voxelGrid;
        } else if (this._triPlanarVoxelization) {
          return this._combinedVoxelGridPT;
        } else {
          return this._voxelGridZaxis;
        }
      }
      /**
       * The debug pass post process
       * @returns The debug pass post process
       */
      getDebugPassPP() {
        if (!this._voxelDebugPass) {
          this._createDebugPass();
        }
        return this._voxelDebugPass;
      }
      /**
       * Whether to use tri-planar voxelization. More expensive, but can help with artifacts.
       */
      get triPlanarVoxelization() {
        return this._triPlanarVoxelization;
      }
      /**
       * Whether to use tri-planar voxelization. More expensive, but can help with artifacts.
       */
      set triPlanarVoxelization(enabled) {
        if (this._engine.isWebGPU) {
          this._triPlanarVoxelization = true;
          return;
        }
        if (this._triPlanarVoxelization === enabled) {
          return;
        }
        this._triPlanarVoxelization = enabled;
        this._disposeVoxelTextures();
        this._createTextures();
      }
      /**
       * Set the matrix to use for scaling the world space to voxel space
       * @param matrix The matrix to use for scaling the world space to voxel space
       */
      setWorldScaleMatrix(matrix) {
        this._invWorldScaleMatrix = matrix;
      }
      /**
       * @returns Whether voxelization is currently happening.
       */
      isVoxelizationInProgress() {
        return this._voxelizationInProgress;
      }
      /**
       * Resolution of the voxel grid. The final resolution will be 2^resolutionExp.
       */
      get voxelResolutionExp() {
        return this._voxelResolutionExp;
      }
      /**
       * Resolution of the voxel grid. The final resolution will be 2^resolutionExp.
       */
      set voxelResolutionExp(resolutionExp) {
        if (this._voxelResolutionExp === resolutionExp && this._voxelGridZaxis) {
          return;
        }
        this._voxelResolutionExp = Math.round(Math.min(Math.max(resolutionExp, 3), 9));
        this._voxelResolution = Math.pow(2, this._voxelResolutionExp);
        this._disposeVoxelTextures();
        this._createTextures();
      }
      /**
       * Shows only the voxels that were rendered along a particular axis (while using triPlanarVoxelization).
       * If not set, the combined voxel grid will be shown.
       * Note: This only works when the debugMipNumber is set to 0 because we don't generate mips for each axis.
       * @param axis The axis to show (0 = x, 1 = y, 2 = z)
       */
      set voxelDebugAxis(axis) {
        this._voxelDebugAxis = axis;
      }
      get voxelDebugAxis() {
        return this._voxelDebugAxis;
      }
      /**
       * Sets params that control the position and scaling of the debug display on the screen.
       * @param x Screen X offset of the debug display (0-1)
       * @param y Screen Y offset of the debug display (0-1)
       * @param widthScale X scale of the debug display (0-1)
       * @param heightScale Y scale of the debug display (0-1)
       */
      setDebugDisplayParams(x, y, widthScale, heightScale) {
        this._debugSizeParams.set(x, y, widthScale, heightScale);
      }
      /**
       * The mip level to show in the debug display
       * @param mipNum The mip level to show in the debug display
       */
      setDebugMipNumber(mipNum) {
        this._debugMipNumber = mipNum;
      }
      /**
       * Sets the name of the debug pass
       */
      get debugPassName() {
        return this._debugPassName;
      }
      /**
       * Enable or disable the debug view for this pass
       */
      get voxelDebugEnabled() {
        return this._voxelDebugEnabled;
      }
      set voxelDebugEnabled(enabled) {
        if (this._voxelDebugEnabled === enabled) {
          return;
        }
        this._voxelDebugEnabled = enabled;
        if (enabled) {
          this._voxelSlabDebugRT = new RenderTargetTexture("voxelSlabDebug", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, this._scene, {
            generateDepthBuffer: true,
            generateMipMaps: false,
            type: 0,
            format: 5,
            samplingMode: 1
          });
          this._voxelSlabDebugRT.noPrePassRenderer = true;
        }
        if (this._voxelSlabDebugRT) {
          this._removeVoxelRTs([this._voxelSlabDebugRT]);
        }
        if (this._voxelDebugEnabled) {
          this._addRTsForRender([this._voxelSlabDebugRT], this._includedMeshes, this._voxelDebugAxis, 1, true);
          this._setDebugBindingsBound = this._setDebugBindings.bind(this);
          this._scene.onBeforeRenderObservable.add(this._setDebugBindingsBound);
        } else {
          this._scene.onBeforeRenderObservable.removeCallback(this._setDebugBindingsBound);
        }
      }
      /**
       * Creates the debug post process effect for this pass
       */
      _createDebugPass() {
        const isWebGPU = this._engine.isWebGPU;
        if (!this._voxelDebugPass) {
          const debugOptions = {
            width: this._engine.getRenderWidth(),
            height: this._engine.getRenderHeight(),
            textureFormat: 5,
            textureType: 0,
            samplingMode: 1,
            uniforms: ["sizeParams", "mipNumber"],
            samplers: ["voxelTexture", "voxelSlabTexture"],
            engine: this._engine,
            reusable: false,
            shaderLanguage: isWebGPU ? 1 : 0,
            extraInitializations: (useWebGPU, list) => {
              if (useWebGPU) {
                list.push(import("./iblVoxelGrid3dDebug.fragment-WTWJR523.js"));
              } else {
                list.push(import("./iblVoxelGrid3dDebug.fragment-TCRRVHUR.js"));
              }
            }
          };
          this._voxelDebugPass = new PostProcess(this.debugPassName, "iblVoxelGrid3dDebug", debugOptions);
          this._voxelDebugPass.onApplyObservable.add((effect) => {
            if (this._voxelDebugAxis === 0) {
              effect.setTexture("voxelTexture", this._voxelGridXaxis);
            } else if (this._voxelDebugAxis === 1) {
              effect.setTexture("voxelTexture", this._voxelGridYaxis);
            } else if (this._voxelDebugAxis === 2) {
              effect.setTexture("voxelTexture", this._voxelGridZaxis);
            } else {
              effect.setTexture("voxelTexture", this.getVoxelGrid());
            }
            effect.setTexture("voxelSlabTexture", this._voxelSlabDebugRT);
            effect.setVector4("sizeParams", this._debugSizeParams);
            effect.setFloat("mipNumber", this._debugMipNumber);
          });
        }
      }
      /**
       * Instanciates the voxel renderer
       * @param scene Scene to attach to
       * @param iblShadowsRenderPipeline The render pipeline this pass is associated with
       * @param resolutionExp Resolution of the voxel grid. The final resolution will be 2^resolutionExp.
       * @param triPlanarVoxelization Whether to use tri-planar voxelization. Only applies to WebGL. Voxelization will take longer but will reduce missing geometry.
       * @returns The voxel renderer
       */
      constructor(scene, iblShadowsRenderPipeline, resolutionExp = 6, triPlanarVoxelization = true) {
        this._voxelMrtsXaxis = [];
        this._voxelMrtsYaxis = [];
        this._voxelMrtsZaxis = [];
        this._voxelClearColor = new Color4(0, 0, 0, 1);
        this.onVoxelizationCompleteObservable = new Observable();
        this._renderTargets = [];
        this._triPlanarVoxelization = true;
        this._voxelizationInProgress = false;
        this._invWorldScaleMatrix = Matrix.Identity();
        this._voxelResolution = 64;
        this._voxelResolutionExp = 6;
        this._mipArray = [];
        this._voxelDebugEnabled = false;
        this._voxelDebugAxis = -1;
        this._debugSizeParams = new Vector4(0, 0, 0, 0);
        this._includedMeshes = [];
        this._debugMipNumber = 0;
        this._debugPassName = "Voxelization Debug Pass";
        this._scene = scene;
        this._engine = scene.getEngine();
        this._triPlanarVoxelization = this._engine.isWebGPU || triPlanarVoxelization;
        if (!this._engine.getCaps().drawBuffersExtension) {
          Logger.Error("Can't do voxel rendering without the draw buffers extension.");
        }
        const isWebGPU = this._engine.isWebGPU;
        this._maxDrawBuffers = this._engine.getCaps().maxDrawBuffers || 0;
        this._copyMipEffectRenderer = new EffectRenderer(this._engine);
        this._copyMipEffectWrapper = new EffectWrapper({
          engine: this._engine,
          fragmentShader: "copyTexture3DLayerToTexture",
          useShaderStore: true,
          uniformNames: ["layerNum"],
          samplerNames: ["textureSampler"],
          shaderLanguage: isWebGPU ? 1 : 0,
          extraInitializationsAsync: async () => {
            if (isWebGPU) {
              await import("./copyTexture3DLayerToTexture.fragment-WM4UQN7I.js");
            } else {
              await import("./copyTexture3DLayerToTexture.fragment-GFEUDOR2.js");
            }
          }
        });
        this.voxelResolutionExp = resolutionExp;
      }
      _generateMipMaps() {
        const iterations = Math.ceil(Math.log2(this._voxelResolution));
        for (let i = 1; i < iterations + 1; i++) {
          this._generateMipMap(i);
        }
      }
      _generateMipMap(lodLevel) {
        const mipTarget = this._mipArray[lodLevel - 1];
        if (!mipTarget) {
          return;
        }
        mipTarget.setTexture("srcMip", lodLevel === 1 ? this.getVoxelGrid() : this._mipArray[lodLevel - 2]);
        mipTarget.render();
      }
      _copyMipMaps() {
        const iterations = Math.ceil(Math.log2(this._voxelResolution));
        for (let i = 1; i < iterations + 1; i++) {
          this._copyMipMap(i);
        }
      }
      _copyMipMap(lodLevel) {
        const mipTarget = this._mipArray[lodLevel - 1];
        if (!mipTarget) {
          return;
        }
        const voxelGrid = this.getVoxelGrid();
        let rt;
        if (voxelGrid instanceof RenderTargetTexture && voxelGrid.renderTarget) {
          rt = voxelGrid.renderTarget;
        } else {
          rt = voxelGrid._rtWrapper;
        }
        if (rt) {
          this._copyMipEffectRenderer.saveStates();
          const bindSize = mipTarget.getSize().width;
          for (let layer = 0; layer < bindSize; layer++) {
            this._engine.bindFramebuffer(rt, 0, bindSize, bindSize, true, lodLevel, layer);
            this._copyMipEffectRenderer.applyEffectWrapper(this._copyMipEffectWrapper);
            this._copyMipEffectWrapper.effect.setTexture("textureSampler", mipTarget);
            this._copyMipEffectWrapper.effect.setInt("layerNum", layer);
            this._copyMipEffectRenderer.draw();
            this._engine.unBindFramebuffer(rt, true);
          }
          this._copyMipEffectRenderer.restoreStates();
        }
      }
      _computeNumberOfSlabs() {
        return Math.ceil(this._voxelResolution / this._maxDrawBuffers);
      }
      _createTextures() {
        const isWebGPU = this._engine.isWebGPU;
        const size = {
          width: this._voxelResolution,
          height: this._voxelResolution,
          depth: this._voxelResolution
        };
        const voxelAxisOptions = {
          generateDepthBuffer: false,
          generateMipMaps: false,
          type: 0,
          format: 5,
          samplingMode: 1
        };
        const numSlabs = this._computeNumberOfSlabs();
        const voxelCombinedOptions = {
          generateDepthBuffer: false,
          generateMipMaps: true,
          type: 0,
          format: 6,
          samplingMode: 4,
          shaderLanguage: isWebGPU ? 1 : 0,
          extraInitializationsAsync: async () => {
            if (isWebGPU) {
              await import("./iblCombineVoxelGrids.fragment-RVFVVZMN.js");
            } else {
              await import("./iblCombineVoxelGrids.fragment-K5GLRDMX.js");
            }
          }
        };
        if (this._engine.isWebGPU) {
          this._voxelGrid = new RenderTargetTexture("voxelGrid", size, this._scene, {
            ...voxelCombinedOptions,
            format: 5,
            creationFlags: 1
          });
          this._voxelGridRT = new RenderTargetTexture("voxelGridRT", { width: Math.min(size.width * 2, 2048), height: Math.min(size.height * 2, 2048) }, this._scene, voxelAxisOptions);
        } else if (this._triPlanarVoxelization) {
          this._voxelGridXaxis = new RenderTargetTexture("voxelGridXaxis", size, this._scene, voxelAxisOptions);
          this._voxelGridYaxis = new RenderTargetTexture("voxelGridYaxis", size, this._scene, voxelAxisOptions);
          this._voxelGridZaxis = new RenderTargetTexture("voxelGridZaxis", size, this._scene, voxelAxisOptions);
          this._voxelMrtsXaxis = this._createVoxelMRTs("x_axis_", this._voxelGridXaxis, numSlabs);
          this._voxelMrtsYaxis = this._createVoxelMRTs("y_axis_", this._voxelGridYaxis, numSlabs);
          this._voxelMrtsZaxis = this._createVoxelMRTs("z_axis_", this._voxelGridZaxis, numSlabs);
          this._combinedVoxelGridPT = new ProceduralTexture("combinedVoxelGrid", size, "iblCombineVoxelGrids", this._scene, voxelCombinedOptions, false);
          this._scene.proceduralTextures.splice(this._scene.proceduralTextures.indexOf(this._combinedVoxelGridPT), 1);
          this._combinedVoxelGridPT.setFloat("layer", 0);
          this._combinedVoxelGridPT.setTexture("voxelXaxisSampler", this._voxelGridXaxis);
          this._combinedVoxelGridPT.setTexture("voxelYaxisSampler", this._voxelGridYaxis);
          this._combinedVoxelGridPT.setTexture("voxelZaxisSampler", this._voxelGridZaxis);
          this._combinedVoxelGridPT.autoClear = false;
          this._combinedVoxelGridPT.wrapU = Texture.CLAMP_ADDRESSMODE;
          this._combinedVoxelGridPT.wrapV = Texture.CLAMP_ADDRESSMODE;
        } else {
          this._voxelGridZaxis = new RenderTargetTexture("voxelGridZaxis", size, this._scene, voxelCombinedOptions);
          this._voxelMrtsZaxis = this._createVoxelMRTs("z_axis_", this._voxelGridZaxis, numSlabs);
        }
        const generateVoxelMipOptions = {
          generateDepthBuffer: false,
          generateMipMaps: false,
          type: 0,
          format: 6,
          samplingMode: 1,
          shaderLanguage: isWebGPU ? 1 : 0,
          extraInitializationsAsync: async () => {
            if (isWebGPU) {
              await import("./iblGenerateVoxelMip.fragment-62WEK5IL.js");
            } else {
              await import("./iblGenerateVoxelMip.fragment-UZTYGIPR.js");
            }
          }
        };
        this._mipArray = new Array(Math.ceil(Math.log2(this._voxelResolution)));
        for (let mipIdx = 1; mipIdx <= this._mipArray.length; mipIdx++) {
          const mipDim = this._voxelResolution >> mipIdx;
          const mipSize = { width: mipDim, height: mipDim, depth: mipDim };
          this._mipArray[mipIdx - 1] = new ProceduralTexture("voxelMip" + mipIdx, mipSize, "iblGenerateVoxelMip", this._scene, generateVoxelMipOptions, false);
          this._scene.proceduralTextures.splice(this._scene.proceduralTextures.indexOf(this._mipArray[mipIdx - 1]), 1);
          const mipTarget = this._mipArray[mipIdx - 1];
          mipTarget.autoClear = false;
          mipTarget.wrapU = Texture.CLAMP_ADDRESSMODE;
          mipTarget.wrapV = Texture.CLAMP_ADDRESSMODE;
          mipTarget.setTexture("srcMip", mipIdx > 1 ? this._mipArray[mipIdx - 2] : this.getVoxelGrid());
          mipTarget.setInt("layerNum", 0);
        }
        this._createVoxelMaterials();
      }
      _createVoxelMRTs(name13, voxelRT, numSlabs) {
        voxelRT.wrapU = Texture.CLAMP_ADDRESSMODE;
        voxelRT.wrapV = Texture.CLAMP_ADDRESSMODE;
        voxelRT.noPrePassRenderer = true;
        const mrtArray = [];
        const targetTypes = new Array(this._maxDrawBuffers).fill(32879);
        for (let mrtIndex = 0; mrtIndex < numSlabs; mrtIndex++) {
          let layerIndices = new Array(this._maxDrawBuffers).fill(0);
          layerIndices = layerIndices.map((value, index) => mrtIndex * this._maxDrawBuffers + index);
          let textureNames = new Array(this._maxDrawBuffers).fill("");
          textureNames = textureNames.map((value, index) => "voxel_grid_" + name13 + (mrtIndex * this._maxDrawBuffers + index));
          const mrt = new MultiRenderTarget(
            "mrt_" + name13 + mrtIndex,
            { width: this._voxelResolution, height: this._voxelResolution, depth: this._voxelResolution },
            this._maxDrawBuffers,
            // number of draw buffers
            this._scene,
            {
              types: new Array(this._maxDrawBuffers).fill(0),
              samplingModes: new Array(this._maxDrawBuffers).fill(3),
              generateMipMaps: false,
              targetTypes,
              formats: new Array(this._maxDrawBuffers).fill(6),
              faceIndex: new Array(this._maxDrawBuffers).fill(0),
              layerIndex: layerIndices,
              layerCounts: new Array(this._maxDrawBuffers).fill(this._voxelResolution),
              generateDepthBuffer: false,
              generateStencilBuffer: false
            },
            textureNames
          );
          mrt.clearColor = new Color4(0, 0, 0, 1);
          mrt.noPrePassRenderer = true;
          for (let i = 0; i < this._maxDrawBuffers; i++) {
            mrt.setInternalTexture(voxelRT.getInternalTexture(), i);
          }
          mrtArray.push(mrt);
        }
        return mrtArray;
      }
      _disposeVoxelTextures() {
        this._stopVoxelization();
        for (let i = 0; i < this._voxelMrtsZaxis.length; i++) {
          if (this._triPlanarVoxelization) {
            this._voxelMrtsXaxis[i].dispose(true);
            this._voxelMrtsYaxis[i].dispose(true);
          }
          this._voxelMrtsZaxis[i].dispose(true);
        }
        if (this._triPlanarVoxelization) {
          this._voxelGridXaxis?.dispose();
          this._voxelGridYaxis?.dispose();
          this._combinedVoxelGridPT?.dispose();
        }
        this._voxelGridZaxis?.dispose();
        for (const mip of this._mipArray) {
          mip.dispose();
        }
        this._voxelMaterial?.dispose();
        this._voxelSlabDebugMaterial?.dispose();
        this._mipArray = [];
        this._voxelMrtsXaxis = [];
        this._voxelMrtsYaxis = [];
        this._voxelMrtsZaxis = [];
      }
      _createVoxelMaterials() {
        const isWebGPU = this._engine.isWebGPU;
        this._voxelMaterial = new ShaderMaterial("voxelization", this._scene, "iblVoxelGrid", {
          uniforms: ["world", "viewMatrix", "invTransWorld", "invWorldScale", "nearPlane", "farPlane", "stepSize"],
          defines: ["MAX_DRAW_BUFFERS " + this._maxDrawBuffers],
          shaderLanguage: isWebGPU ? 1 : 0,
          extraInitializationsAsync: async () => {
            if (isWebGPU) {
              await Promise.all([import("./iblVoxelGrid.fragment-XPU55COA.js"), import("./iblVoxelGrid.vertex-QOBXLYK6.js")]);
            } else {
              await Promise.all([import("./iblVoxelGrid.fragment-HQY6E377.js"), import("./iblVoxelGrid.vertex-6BTK3NAG.js")]);
            }
          }
        });
        this._voxelMaterial.cullBackFaces = false;
        this._voxelMaterial.backFaceCulling = false;
        this._voxelMaterial.depthFunction = Engine.ALWAYS;
        this._voxelSlabDebugMaterial = new ShaderMaterial("voxelSlabDebug", this._scene, "iblVoxelSlabDebug", {
          uniforms: ["world", "viewMatrix", "cameraViewMatrix", "projection", "invWorldScale", "nearPlane", "farPlane", "stepSize"],
          defines: ["MAX_DRAW_BUFFERS " + this._maxDrawBuffers],
          shaderLanguage: isWebGPU ? 1 : 0,
          extraInitializationsAsync: async () => {
            if (isWebGPU) {
              await Promise.all([import("./iblVoxelSlabDebug.fragment-IVJZOAMN.js"), import("./iblVoxelSlabDebug.vertex-OXFQ7OK4.js")]);
            } else {
              await Promise.all([import("./iblVoxelSlabDebug.fragment-CQCWKY7L.js"), import("./iblVoxelSlabDebug.vertex-EXHSY5XR.js")]);
            }
          }
        });
      }
      _setDebugBindings() {
        this._voxelSlabDebugMaterial.setMatrix("projection", this._scene.activeCamera.getProjectionMatrix());
        this._voxelSlabDebugMaterial.setMatrix("cameraViewMatrix", this._scene.activeCamera.getViewMatrix());
      }
      /**
       * Checks if the voxel renderer is ready to voxelize scene
       * @returns true if the voxel renderer is ready to voxelize scene
       */
      isReady() {
        let allReady = this.getVoxelGrid().isReady();
        for (let i = 0; i < this._mipArray.length; i++) {
          const mipReady = this._mipArray[i].isReady();
          allReady && (allReady = mipReady);
        }
        if (!allReady || this._voxelizationInProgress) {
          return false;
        }
        return true;
      }
      /**
       * If the MRT's are already in the list of render targets, this will
       * remove them so that they don't get rendered again.
       */
      _stopVoxelization() {
        this._removeVoxelRTs(this._voxelMrtsXaxis);
        this._removeVoxelRTs(this._voxelMrtsYaxis);
        this._removeVoxelRTs(this._voxelMrtsZaxis);
        this._removeVoxelRTs([this._voxelGridRT]);
      }
      _removeVoxelRTs(rts) {
        const rtIdx = this._renderTargets.findIndex((rt) => {
          if (rt === rts[0]) {
            return true;
          }
          return false;
        });
        if (rtIdx >= 0) {
          this._renderTargets.splice(rtIdx, rts.length);
        } else {
          const rtIdx2 = this._scene.customRenderTargets.findIndex((rt) => {
            if (rt === rts[0]) {
              return true;
            }
            return false;
          });
          if (rtIdx2 >= 0) {
            this._scene.customRenderTargets.splice(rtIdx2, rts.length);
          }
        }
      }
      /**
       * Renders voxel grid of scene for IBL shadows
       * @param includedMeshes
       */
      updateVoxelGrid(includedMeshes) {
        if (this._voxelizationInProgress) {
          return;
        }
        this._stopVoxelization();
        this._includedMeshes = includedMeshes;
        this._voxelizationInProgress = true;
        if (this._engine.isWebGPU) {
          this._voxelGridRT.renderList = includedMeshes;
          this._addRTsForRender([this._voxelGridRT], includedMeshes, 0);
        } else if (this._triPlanarVoxelization) {
          this._addRTsForRender(this._voxelMrtsXaxis, includedMeshes, 0);
          this._addRTsForRender(this._voxelMrtsYaxis, includedMeshes, 1);
          this._addRTsForRender(this._voxelMrtsZaxis, includedMeshes, 2);
        } else {
          this._addRTsForRender(this._voxelMrtsZaxis, includedMeshes, 2);
        }
        if (this._voxelDebugEnabled) {
          this._addRTsForRender([this._voxelSlabDebugRT], includedMeshes, this._voxelDebugAxis, 1, true);
        }
        this._renderVoxelGridBound = this._renderVoxelGrid.bind(this);
        this._scene.onAfterRenderObservable.add(this._renderVoxelGridBound);
      }
      _renderVoxelGrid() {
        if (this._voxelizationInProgress) {
          let allReady = this.getVoxelGrid().isReady();
          for (let i = 0; i < this._mipArray.length; i++) {
            const mipReady = this._mipArray[i].isReady();
            allReady && (allReady = mipReady);
          }
          for (let i = 0; i < this._renderTargets.length; i++) {
            const rttReady = this._renderTargets[i].isReadyForRendering();
            allReady && (allReady = rttReady);
          }
          if (allReady) {
            if (this._engine.isWebGPU) {
              if (this._voxelGrid && this._voxelGrid.renderTarget) {
                for (let layer = 0; layer < this._voxelResolution; layer++) {
                  this._engine.bindFramebuffer(this._voxelGrid.renderTarget, 0, void 0, void 0, true, 0, layer);
                  this._engine.clear(this._voxelClearColor, true, false, false);
                  this._engine.unBindFramebuffer(this._voxelGrid.renderTarget, true);
                }
              }
            }
            for (const rt of this._renderTargets) {
              rt.render();
            }
            this._stopVoxelization();
            if (this._triPlanarVoxelization && !this._engine.isWebGPU) {
              this._combinedVoxelGridPT.render();
            }
            this._generateMipMaps();
            this._copyMipEffectWrapper.effect.whenCompiledAsync().then(() => {
              this._copyMipMaps();
              this._scene.onAfterRenderObservable.removeCallback(this._renderVoxelGridBound);
              this._voxelizationInProgress = false;
              this.onVoxelizationCompleteObservable.notifyObservers();
            });
          }
        }
      }
      _addRTsForRender(mrts, includedMeshes, axis, shaderType = 0, continuousRender = false) {
        const slabSize = 1 / this._computeNumberOfSlabs();
        let voxelMaterial;
        if (shaderType === 0) {
          voxelMaterial = this._voxelMaterial;
        } else {
          voxelMaterial = this._voxelSlabDebugMaterial;
        }
        for (let mrtIndex = 0; mrtIndex < mrts.length; mrtIndex++) {
          const mrt = mrts[mrtIndex];
          mrt.renderList = [];
          const nearPlane = mrtIndex * slabSize;
          const farPlane = (mrtIndex + 1) * slabSize;
          const stepSize = slabSize / this._maxDrawBuffers;
          const cameraPosition = new Vector3(0, 0, 0);
          let targetPosition = new Vector3(0, 0, 1);
          if (axis === 0) {
            targetPosition = new Vector3(1, 0, 0);
          } else if (axis === 1) {
            targetPosition = new Vector3(0, 1, 0);
          }
          let upDirection = new Vector3(0, 1, 0);
          if (axis === 1) {
            upDirection = new Vector3(1, 0, 0);
          }
          mrt.onBeforeRenderObservable.clear();
          mrt.onBeforeRenderObservable.add(() => {
            voxelMaterial.setMatrix("viewMatrix", Matrix.LookAtLH(cameraPosition, targetPosition, upDirection));
            voxelMaterial.setMatrix("invWorldScale", this._invWorldScaleMatrix);
            voxelMaterial.setFloat("nearPlane", nearPlane);
            voxelMaterial.setFloat("farPlane", farPlane);
            voxelMaterial.setFloat("stepSize", stepSize);
            if (this._engine.isWebGPU) {
              this._voxelMaterial.useVertexPulling = true;
              this._voxelMaterial.setTexture("voxel_storage", this.getVoxelGrid());
            }
          });
          if (includedMeshes.length === 0) {
            return;
          }
          for (const mesh of includedMeshes) {
            if (mesh) {
              if (mesh.subMeshes && mesh.subMeshes.length > 0) {
                mrt.renderList?.push(mesh);
                mrt.setMaterialForRendering(mesh, voxelMaterial);
              }
              const meshes = mesh.getChildMeshes();
              for (const childMesh of meshes) {
                if (childMesh.subMeshes && childMesh.subMeshes.length > 0) {
                  mrt.renderList?.push(childMesh);
                  mrt.setMaterialForRendering(childMesh, voxelMaterial);
                }
              }
            }
          }
        }
        if (continuousRender) {
          for (const mrt of mrts) {
            if (this._scene.customRenderTargets.indexOf(mrt) === -1) {
              this._scene.customRenderTargets.push(mrt);
            }
          }
        } else {
          this._renderTargets = this._renderTargets.concat(mrts);
        }
      }
      /**
       * Called by the pipeline to resize resources.
       */
      resize() {
        this._voxelSlabDebugRT?.resize({ width: this._scene.getEngine().getRenderWidth(), height: this._scene.getEngine().getRenderHeight() });
      }
      /**
       * Disposes the voxel renderer and associated resources
       */
      dispose() {
        this._disposeVoxelTextures();
        if (this._voxelSlabDebugRT) {
          this._removeVoxelRTs([this._voxelSlabDebugRT]);
          this._voxelSlabDebugRT.dispose();
        }
        if (this._voxelDebugPass) {
          this._voxelDebugPass.dispose();
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsVoxelTracingPass.js
var _IblShadowsVoxelTracingPass;
var init_iblShadowsVoxelTracingPass = __esm({
  "node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsVoxelTracingPass.js"() {
    init_math_vector();
    init_postProcess();
    init_geometryBufferRenderer();
    init_proceduralTexture();
    init_logger();
    _IblShadowsVoxelTracingPass = class {
      /**
       * The opacity of the shadow cast from the voxel grid
       */
      get voxelShadowOpacity() {
        return this._voxelShadowOpacity;
      }
      /**
       * The opacity of the shadow cast from the voxel grid
       */
      set voxelShadowOpacity(value) {
        this._voxelShadowOpacity = value;
      }
      /**
       * The opacity of the screen-space shadow
       */
      get ssShadowOpacity() {
        return this._ssShadowOpacity;
      }
      /**
       * The opacity of the screen-space shadow
       */
      set ssShadowOpacity(value) {
        this._ssShadowOpacity = value;
      }
      /**
       * The number of samples used in the screen space shadow pass.
       */
      get sssSamples() {
        return this._sssSamples;
      }
      /**
       * The number of samples used in the screen space shadow pass.
       */
      set sssSamples(value) {
        this._sssSamples = value;
      }
      /**
       * The stride used in the screen space shadow pass. This controls the distance between samples.
       */
      get sssStride() {
        return this._sssStride;
      }
      /**
       * The stride used in the screen space shadow pass. This controls the distance between samples.
       */
      set sssStride(value) {
        this._sssStride = value;
      }
      /**
       * The maximum distance that the screen-space shadow will be able to occlude.
       */
      get sssMaxDist() {
        return this._sssMaxDist;
      }
      /**
       * The maximum distance that the screen-space shadow will be able to occlude.
       */
      set sssMaxDist(value) {
        this._sssMaxDist = value;
      }
      /**
       * The thickness of the screen-space shadow
       */
      get sssThickness() {
        return this._sssThickness;
      }
      /**
       * The thickness of the screen-space shadow
       */
      set sssThickness(value) {
        this._sssThickness = value;
      }
      /**
       * The bias to apply to the voxel sampling in the direction of the surface normal of the geometry.
       */
      get voxelNormalBias() {
        return this._voxelNormalBias;
      }
      set voxelNormalBias(value) {
        this._voxelNormalBias = value;
      }
      /**
       * The bias to apply to the voxel sampling in the direction of the light.
       */
      get voxelDirectionBias() {
        return this._voxelDirectionBias;
      }
      set voxelDirectionBias(value) {
        this._voxelDirectionBias = value;
      }
      /**
       * The number of directions to sample for the voxel tracing.
       */
      get sampleDirections() {
        return this._sampleDirections;
      }
      /**
       * The number of directions to sample for the voxel tracing.
       */
      set sampleDirections(value) {
        this._sampleDirections = value;
      }
      /**
       * The current rotation of the environment map, in radians.
       */
      get envRotation() {
        return this._envRotation;
      }
      /**
       * The current rotation of the environment map, in radians.
       */
      set envRotation(value) {
        this._envRotation = value;
      }
      /**
       * Returns the output texture of the pass.
       * @returns The output texture.
       */
      getOutputTexture() {
        return this._outputTexture;
      }
      /**
       * Gets the debug pass post process. This will create the resources for the pass
       * if they don't already exist.
       * @returns The post process
       */
      getDebugPassPP() {
        if (!this._debugPassPP) {
          this._createDebugPass();
        }
        return this._debugPassPP;
      }
      /**
       * The name of the debug pass
       */
      get debugPassName() {
        return this._debugPassName;
      }
      /**
       * Set the matrix to use for scaling the world space to voxel space
       * @param matrix The matrix to use for scaling the world space to voxel space
       */
      setWorldScaleMatrix(matrix) {
        this._invWorldScaleMatrix = matrix;
      }
      /**
       * Render the shadows in color rather than black and white.
       * This is slightly more expensive than black and white shadows but can be much
       * more accurate when the strongest lights in the IBL are non-white.
       */
      set coloredShadows(value) {
        this._coloredShadows = value;
      }
      get coloredShadows() {
        return this._coloredShadows;
      }
      /**
       * Sets params that control the position and scaling of the debug display on the screen.
       * @param x Screen X offset of the debug display (0-1)
       * @param y Screen Y offset of the debug display (0-1)
       * @param widthScale X scale of the debug display (0-1)
       * @param heightScale Y scale of the debug display (0-1)
       */
      setDebugDisplayParams(x, y, widthScale, heightScale) {
        this._debugSizeParams.set(x, y, widthScale, heightScale);
      }
      /**
       * Creates the debug post process effect for this pass
       */
      _createDebugPass() {
        const isWebGPU = this._engine.isWebGPU;
        if (!this._debugPassPP) {
          const debugOptions = {
            width: this._engine.getRenderWidth(),
            height: this._engine.getRenderHeight(),
            uniforms: ["sizeParams"],
            samplers: ["debugSampler"],
            engine: this._engine,
            reusable: true,
            shaderLanguage: isWebGPU ? 1 : 0,
            extraInitializations: (useWebGPU, list) => {
              if (useWebGPU) {
                list.push(import("./iblShadowDebug.fragment-P5BRZRRN.js"));
              } else {
                list.push(import("./iblShadowDebug.fragment-OO6CPZYT.js"));
              }
            }
          };
          this._debugPassPP = new PostProcess(this.debugPassName, "iblShadowDebug", debugOptions);
          this._debugPassPP.autoClear = false;
          this._debugPassPP.onApplyObservable.add((effect) => {
            effect.setTexture("debugSampler", this._outputTexture);
            effect.setVector4("sizeParams", this._debugSizeParams);
          });
        }
      }
      /**
       * Instantiates the shadow voxel-tracing pass
       * @param scene Scene to attach to
       * @param iblShadowsRenderPipeline The IBL shadows render pipeline
       * @returns The shadow voxel-tracing pass
       */
      constructor(scene, iblShadowsRenderPipeline) {
        this._voxelShadowOpacity = 1;
        this._sssSamples = 16;
        this._sssStride = 8;
        this._sssMaxDist = 0.05;
        this._sssThickness = 0.5;
        this._ssShadowOpacity = 1;
        this._cameraInvView = Matrix.Identity();
        this._cameraInvProj = Matrix.Identity();
        this._invWorldScaleMatrix = Matrix.Identity();
        this._frameId = 0;
        this._sampleDirections = 4;
        this._shadowParameters = new Vector4(0, 0, 0, 0);
        this._sssParameters = new Vector4(0, 0, 0, 0);
        this._opacityParameters = new Vector4(0, 0, 0, 0);
        this._voxelBiasParameters = new Vector4(0, 0, 0, 0);
        this._voxelNormalBias = 1.4;
        this._voxelDirectionBias = 1.75;
        this.enabled = true;
        this.debugEnabled = false;
        this._debugPassName = "Voxel Tracing Debug Pass";
        this._envRotation = 0;
        this._coloredShadows = false;
        this._debugVoxelMarchEnabled = false;
        this._debugSizeParams = new Vector4(0, 0, 0, 0);
        this._renderWhenGBufferReady = null;
        this._scene = scene;
        this._engine = scene.getEngine();
        this._renderPipeline = iblShadowsRenderPipeline;
        this._createTextures();
      }
      _createTextures() {
        const defines = this._createDefines();
        const isWebGPU = this._engine.isWebGPU;
        const textureOptions = {
          type: 0,
          format: 5,
          samplingMode: 1,
          generateDepthBuffer: false,
          shaderLanguage: isWebGPU ? 1 : 0,
          extraInitializationsAsync: async () => {
            if (isWebGPU) {
              await Promise.all([import("./iblShadowVoxelTracing.fragment-AFWIQB5J.js")]);
            } else {
              await Promise.all([import("./iblShadowVoxelTracing.fragment-UQSCD4IZ.js")]);
            }
          }
        };
        this._outputTexture = new ProceduralTexture("voxelTracingPass", {
          width: this._engine.getRenderWidth(),
          height: this._engine.getRenderHeight()
        }, "iblShadowVoxelTracing", this._scene, textureOptions);
        this._outputTexture.refreshRate = -1;
        this._outputTexture.autoClear = false;
        this._outputTexture.defines = defines;
        this._setBindings(this._scene.activeCamera);
        this._renderWhenGBufferReady = this._render.bind(this);
        this._renderPipeline.onVoxelizationCompleteObservable.addOnce(() => {
          this._scene.geometryBufferRenderer.getGBuffer().onAfterRenderObservable.add(this._renderWhenGBufferReady);
        });
      }
      _createDefines() {
        let defines = "";
        if (this._scene.useRightHandedSystem) {
          defines += "#define RIGHT_HANDED\n";
        }
        if (this._debugVoxelMarchEnabled) {
          defines += "#define VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION 1u\n";
        }
        if (this._coloredShadows) {
          defines += "#define COLOR_SHADOWS 1u\n";
        }
        return defines;
      }
      _setBindings(camera) {
        this._outputTexture.defines = this._createDefines();
        this._outputTexture.setMatrix("viewMtx", camera.getViewMatrix());
        this._outputTexture.setMatrix("projMtx", camera.getProjectionMatrix());
        camera.getProjectionMatrix().invertToRef(this._cameraInvProj);
        camera.getViewMatrix().invertToRef(this._cameraInvView);
        this._outputTexture.setMatrix("invProjMtx", this._cameraInvProj);
        this._outputTexture.setMatrix("invViewMtx", this._cameraInvView);
        this._outputTexture.setMatrix("wsNormalizationMtx", this._invWorldScaleMatrix);
        this._frameId++;
        let rotation = 0;
        if (this._scene.environmentTexture) {
          rotation = this._scene.environmentTexture.rotationY ?? 0;
        }
        rotation = this._scene.useRightHandedSystem ? -(rotation + 0.5 * Math.PI) : rotation - 0.5 * Math.PI;
        rotation = rotation % (2 * Math.PI);
        this._shadowParameters.set(this._sampleDirections, this._frameId, 1, rotation);
        this._outputTexture.setVector4("shadowParameters", this._shadowParameters);
        const voxelGrid = this._renderPipeline._getVoxelGridTexture();
        const highestMip = Math.floor(Math.log2(voxelGrid.getSize().width));
        this._voxelBiasParameters.set(this._voxelNormalBias, this._voxelDirectionBias, highestMip, 0);
        this._outputTexture.setVector4("voxelBiasParameters", this._voxelBiasParameters);
        this._sssParameters.set(this._sssSamples, this._sssStride, this._sssMaxDist, this._sssThickness);
        this._outputTexture.setVector4("sssParameters", this._sssParameters);
        this._opacityParameters.set(this._voxelShadowOpacity, this._ssShadowOpacity, 0, 0);
        this._outputTexture.setVector4("shadowOpacity", this._opacityParameters);
        this._outputTexture.setTexture("voxelGridSampler", voxelGrid);
        this._outputTexture.setTexture("blueNoiseSampler", this._renderPipeline._getNoiseTexture());
        const cdfGenerator = this._scene.iblCdfGenerator;
        if (!cdfGenerator) {
          Logger.Warn("IBLShadowsVoxelTracingPass: Can't bind for render because iblCdfGenerator is not enabled.");
          return false;
        }
        this._outputTexture.setTexture("icdfSampler", cdfGenerator.getIcdfTexture());
        if (this._coloredShadows && this._scene.environmentTexture) {
          this._outputTexture.setTexture("iblSampler", this._scene.environmentTexture);
        }
        const geometryBufferRenderer = this._scene.geometryBufferRenderer;
        if (!geometryBufferRenderer) {
          Logger.Warn("IBLShadowsVoxelTracingPass: Can't bind for render because GeometryBufferRenderer is not enabled.");
          return false;
        }
        const depthIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE);
        this._outputTexture.setTexture("depthSampler", geometryBufferRenderer.getGBuffer().textures[depthIndex]);
        const wnormalIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.NORMAL_TEXTURE_TYPE);
        this._outputTexture.setTexture("worldNormalSampler", geometryBufferRenderer.getGBuffer().textures[wnormalIndex]);
        return true;
      }
      _render() {
        if (this.enabled && this._outputTexture.isReady() && this._outputTexture.getEffect()?.isReady()) {
          if (this._setBindings(this._scene.activeCamera)) {
            this._outputTexture.render();
          }
        }
      }
      /**
       * Called by render pipeline when canvas resized.
       * @param scaleFactor The factor by which to scale the canvas size.
       */
      resize(scaleFactor = 1) {
        const newSize = {
          width: Math.max(1, Math.floor(this._engine.getRenderWidth() * scaleFactor)),
          height: Math.max(1, Math.floor(this._engine.getRenderHeight() * scaleFactor))
        };
        if (this._outputTexture.getSize().width === newSize.width && this._outputTexture.getSize().height === newSize.height) {
          return;
        }
        this._outputTexture.resize(newSize, false);
      }
      /**
       * Checks if the pass is ready
       * @returns true if the pass is ready
       */
      isReady() {
        return this._outputTexture.isReady() && !(this._debugPassPP && !this._debugPassPP.isReady()) && this._scene.iblCdfGenerator && this._scene.iblCdfGenerator.getIcdfTexture().isReady() && this._renderPipeline._getVoxelGridTexture().isReady();
      }
      /**
       * Disposes the associated resources
       */
      dispose() {
        if (this._scene.geometryBufferRenderer && this._renderWhenGBufferReady) {
          const gBuffer = this._scene.geometryBufferRenderer.getGBuffer();
          gBuffer.onAfterRenderObservable.removeCallback(this._renderWhenGBufferReady);
        }
        this._outputTexture.dispose();
        if (this._debugPassPP) {
          this._debugPassPP.dispose();
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsSpatialBlurPass.js
var _IblShadowsSpatialBlurPass;
var init_iblShadowsSpatialBlurPass = __esm({
  "node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsSpatialBlurPass.js"() {
    init_math_vector();
    init_postProcess();
    init_geometryBufferRenderer();
    init_proceduralTexture();
    _IblShadowsSpatialBlurPass = class {
      /**
       * Returns the output texture of the pass.
       * @returns The output texture.
       */
      getOutputTexture() {
        return this._outputTexture;
      }
      /**
       * Gets the debug pass post process
       * @returns The post process
       */
      getDebugPassPP() {
        if (!this._debugPassPP) {
          this._createDebugPass();
        }
        return this._debugPassPP;
      }
      /**
       * Sets the name of the debug pass
       */
      get debugPassName() {
        return this._debugPassName;
      }
      /**
       * The scale of the voxel grid in world space. This is used to scale the blur radius in world space.
       * @param scale The scale of the voxel grid in world space.
       */
      setWorldScale(scale) {
        this._worldScale = scale;
      }
      /**
       * Sets params that control the position and scaling of the debug display on the screen.
       * @param x Screen X offset of the debug display (0-1)
       * @param y Screen Y offset of the debug display (0-1)
       * @param widthScale X scale of the debug display (0-1)
       * @param heightScale Y scale of the debug display (0-1)
       */
      setDebugDisplayParams(x, y, widthScale, heightScale) {
        this._debugSizeParams.set(x, y, widthScale, heightScale);
      }
      /**
       * Creates the debug post process effect for this pass
       */
      _createDebugPass() {
        if (!this._debugPassPP) {
          const isWebGPU = this._engine.isWebGPU;
          const debugOptions = {
            width: this._engine.getRenderWidth(),
            height: this._engine.getRenderHeight(),
            textureFormat: 5,
            textureType: 0,
            samplingMode: 1,
            uniforms: ["sizeParams"],
            samplers: ["debugSampler"],
            engine: this._engine,
            reusable: false,
            shaderLanguage: isWebGPU ? 1 : 0,
            extraInitializations: (useWebGPU, list) => {
              if (useWebGPU) {
                list.push(import("./iblShadowDebug.fragment-P5BRZRRN.js"));
              } else {
                list.push(import("./iblShadowDebug.fragment-OO6CPZYT.js"));
              }
            }
          };
          this._debugPassPP = new PostProcess(this.debugPassName, "iblShadowDebug", debugOptions);
          this._debugPassPP.autoClear = false;
          this._debugPassPP.onApplyObservable.add((effect) => {
            effect.setTexture("debugSampler", this._outputTexture);
            effect.setVector4("sizeParams", this._debugSizeParams);
          });
        }
      }
      /**
       * Instanciates the importance sampling renderer
       * @param scene Scene to attach to
       * @param iblShadowsRenderPipeline The IBL shadows render pipeline
       * @returns The importance sampling renderer
       */
      constructor(scene, iblShadowsRenderPipeline) {
        this._worldScale = 1;
        this._blurParameters = new Vector4(0, 0, 0, 0);
        this.enabled = true;
        this._debugPassName = "Spatial Blur Debug Pass";
        this.debugEnabled = false;
        this._debugSizeParams = new Vector4(0, 0, 0, 0);
        this._renderWhenGBufferReady = null;
        this._scene = scene;
        this._engine = scene.getEngine();
        this._renderPipeline = iblShadowsRenderPipeline;
        this._createTextures();
      }
      _createTextures() {
        const isWebGPU = this._engine.isWebGPU;
        const textureOptions = {
          type: 0,
          format: 5,
          samplingMode: 1,
          generateDepthBuffer: false,
          generateMipMaps: false,
          shaderLanguage: isWebGPU ? 1 : 0,
          extraInitializationsAsync: async () => {
            if (isWebGPU) {
              await Promise.all([import("./iblShadowSpatialBlur.fragment-7TID72TA.js")]);
            } else {
              await Promise.all([import("./iblShadowSpatialBlur.fragment-M22JQP3O.js")]);
            }
          }
        };
        this._outputTexture = new ProceduralTexture("spatialBlurPass", {
          width: this._engine.getRenderWidth(),
          height: this._engine.getRenderHeight()
        }, "iblShadowSpatialBlur", this._scene, textureOptions, false, false, 0);
        this._outputTexture.refreshRate = -1;
        this._outputTexture.autoClear = false;
        this._setBindings();
        this._renderWhenGBufferReady = this._render.bind(this);
        this._renderPipeline.onVoxelizationCompleteObservable.addOnce(() => {
          this._scene.geometryBufferRenderer.getGBuffer().onAfterRenderObservable.add(this._renderWhenGBufferReady);
        });
      }
      _setBindings() {
        this._outputTexture.setTexture("voxelTracingSampler", this._renderPipeline._getVoxelTracingTexture());
        const iterationCount = 1;
        this._blurParameters.set(iterationCount, this._worldScale, 0, 0);
        this._outputTexture.setVector4("blurParameters", this._blurParameters);
        const geometryBufferRenderer = this._scene.geometryBufferRenderer;
        if (!geometryBufferRenderer) {
          return false;
        }
        const depthIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE);
        this._outputTexture.setTexture("depthSampler", geometryBufferRenderer.getGBuffer().textures[depthIndex]);
        const wnormalIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.NORMAL_TEXTURE_TYPE);
        this._outputTexture.setTexture("worldNormalSampler", geometryBufferRenderer.getGBuffer().textures[wnormalIndex]);
        return true;
      }
      _render() {
        if (this.enabled && this._outputTexture.isReady() && this._outputTexture.getEffect()?.isReady()) {
          if (this._setBindings()) {
            this._outputTexture.render();
          }
        }
      }
      /**
       * Called by render pipeline when canvas resized.
       * @param scaleFactor The factor by which to scale the canvas size.
       */
      resize(scaleFactor = 1) {
        const newSize = {
          width: Math.max(1, Math.floor(this._engine.getRenderWidth() * scaleFactor)),
          height: Math.max(1, Math.floor(this._engine.getRenderHeight() * scaleFactor))
        };
        if (this._outputTexture.getSize().width === newSize.width && this._outputTexture.getSize().height === newSize.height) {
          return;
        }
        this._outputTexture.resize(newSize, false);
      }
      /**
       * Checks if the pass is ready
       * @returns true if the pass is ready
       */
      isReady() {
        return this._outputTexture.isReady() && !(this._debugPassPP && !this._debugPassPP.isReady());
      }
      /**
       * Disposes the associated resources
       */
      dispose() {
        if (this._scene.geometryBufferRenderer && this._renderWhenGBufferReady) {
          const gBuffer = this._scene.geometryBufferRenderer.getGBuffer();
          gBuffer.onAfterRenderObservable.removeCallback(this._renderWhenGBufferReady);
        }
        this._outputTexture.dispose();
        if (this._debugPassPP) {
          this._debugPassPP.dispose();
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsAccumulationPass.js
var _IblShadowsAccumulationPass;
var init_iblShadowsAccumulationPass = __esm({
  "node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsAccumulationPass.js"() {
    init_math_vector();
    init_postProcess();
    init_geometryBufferRenderer();
    init_proceduralTexture();
    init_observable();
    _IblShadowsAccumulationPass = class {
      /**
       * Returns the output texture of the pass.
       * @returns The output texture.
       */
      getOutputTexture() {
        return this._outputTexture;
      }
      /**
       * Gets the debug pass post process
       * @returns The post process
       */
      getDebugPassPP() {
        if (!this._debugPassPP) {
          this._createDebugPass();
        }
        return this._debugPassPP;
      }
      /**
       * Gets the name of the debug pass
       * @returns The name of the debug pass
       */
      get debugPassName() {
        return this._debugPassName;
      }
      /**
       * A value that controls how much of the previous frame's accumulation to keep.
       * The higher the value, the faster the shadows accumulate but the more potential ghosting you'll see.
       */
      get remanence() {
        return this._remanence;
      }
      /**
       * A value that controls how much of the previous frame's accumulation to keep.
       * The higher the value, the faster the shadows accumulate but the more potential ghosting you'll see.
       */
      set remanence(value) {
        this._remanence = value;
      }
      /**
       * Reset the accumulation.
       */
      get reset() {
        return this._reset;
      }
      /**
       * Reset the accumulation.
       */
      set reset(value) {
        this._reset = value;
      }
      /**
       * Tell the pass that the camera is moving. This will cause the accumulation
       * rate to change.
       */
      set isMoving(value) {
        this._isMoving = value;
      }
      /**
       * Sets params that control the position and scaling of the debug display on the screen.
       * @param x Screen X offset of the debug display (0-1)
       * @param y Screen Y offset of the debug display (0-1)
       * @param widthScale X scale of the debug display (0-1)
       * @param heightScale Y scale of the debug display (0-1)
       */
      setDebugDisplayParams(x, y, widthScale, heightScale) {
        this._debugSizeParams.set(x, y, widthScale, heightScale);
      }
      /**
       * Creates the debug post process effect for this pass
       */
      _createDebugPass() {
        if (!this._debugPassPP) {
          const isWebGPU = this._engine.isWebGPU;
          const debugOptions = {
            width: this._engine.getRenderWidth(),
            height: this._engine.getRenderHeight(),
            textureFormat: 5,
            textureType: 0,
            samplingMode: 1,
            uniforms: ["sizeParams"],
            samplers: ["debugSampler"],
            engine: this._engine,
            reusable: false,
            shaderLanguage: isWebGPU ? 1 : 0,
            extraInitializations: (useWebGPU, list) => {
              if (useWebGPU) {
                list.push(import("./iblShadowDebug.fragment-P5BRZRRN.js"));
              } else {
                list.push(import("./iblShadowDebug.fragment-OO6CPZYT.js"));
              }
            }
          };
          this._debugPassPP = new PostProcess(this.debugPassName, "iblShadowDebug", debugOptions);
          this._debugPassPP.autoClear = false;
          this._debugPassPP.onApplyObservable.add((effect) => {
            effect.setTexture("debugSampler", this._outputTexture);
            effect.setVector4("sizeParams", this._debugSizeParams);
          });
        }
      }
      /**
       * Instantiates the accumulation pass
       * @param scene Scene to attach to
       * @param iblShadowsRenderPipeline The IBL shadows render pipeline
       * @returns The accumulation pass
       */
      constructor(scene, iblShadowsRenderPipeline) {
        this._accumulationParams = new Vector4(0, 0, 0, 0);
        this.debugEnabled = false;
        this.enabled = true;
        this.onReadyObservable = new Observable();
        this._debugPassName = "Shadow Accumulation Debug Pass";
        this._remanence = 0.9;
        this._reset = true;
        this._isMoving = false;
        this._debugSizeParams = new Vector4(0, 0, 0, 0);
        this._renderWhenGBufferReady = null;
        this._scene = scene;
        this._engine = scene.getEngine();
        this._renderPipeline = iblShadowsRenderPipeline;
        this._createTextures();
      }
      _createTextures() {
        const isWebGPU = this._engine.isWebGPU;
        const outputTextureOptions = {
          type: 2,
          format: 5,
          samplingMode: 1,
          generateDepthBuffer: false,
          generateMipMaps: false,
          shaderLanguage: isWebGPU ? 1 : 0,
          extraInitializationsAsync: async () => {
            if (isWebGPU) {
              await Promise.all([import("./iblShadowAccumulation.fragment-MDTNOKLQ.js")]);
            } else {
              await Promise.all([import("./iblShadowAccumulation.fragment-JHUWPFKQ.js")]);
            }
          }
        };
        this._outputTexture = new ProceduralTexture("shadowAccumulationPass", {
          width: this._engine.getRenderWidth(),
          height: this._engine.getRenderHeight()
        }, "iblShadowAccumulation", this._scene, outputTextureOptions);
        this._outputTexture.refreshRate = 1;
        this._outputTexture.autoClear = false;
        this._outputTexture.onGeneratedObservable.addOnce(() => {
          this.onReadyObservable.notifyObservers();
        });
        this._setOutputTextureBindings();
        this._renderWhenGBufferReady = this._render.bind(this);
        this._renderPipeline.onVoxelizationCompleteObservable.addOnce(() => {
          this._scene.geometryBufferRenderer.getGBuffer().onAfterRenderObservable.add(this._renderWhenGBufferReady);
        });
        const accumulationOptions = {
          type: 2,
          format: 5,
          samplingMode: 1,
          generateDepthBuffer: false,
          generateMipMaps: false,
          shaderLanguage: isWebGPU ? 1 : 0,
          extraInitializationsAsync: async () => {
            if (isWebGPU) {
              await Promise.all([import("./pass.fragment-UECRJZSP.js")]);
            } else {
              await Promise.all([import("./pass.fragment-GQ4PNZOK.js")]);
            }
          }
        };
        this._oldAccumulationCopy = new ProceduralTexture("oldAccumulationRT", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, "pass", this._scene, accumulationOptions, false);
        this._oldAccumulationCopy.autoClear = false;
        this._oldAccumulationCopy.refreshRate = 1;
        this._oldAccumulationCopy.onBeforeGenerationObservable.add(this._setAccumulationCopyBindings.bind(this));
        this._setAccumulationCopyBindings();
        const localPositionOptions = {
          type: 2,
          format: 5,
          samplingMode: 1,
          generateDepthBuffer: false,
          generateMipMaps: false,
          shaderLanguage: isWebGPU ? 1 : 0,
          extraInitializationsAsync: async () => {
            if (isWebGPU) {
              await Promise.all([import("./pass.fragment-UECRJZSP.js")]);
            } else {
              await Promise.all([import("./pass.fragment-GQ4PNZOK.js")]);
            }
          }
        };
        this._oldPositionCopy = new ProceduralTexture("oldLocalPositionRT", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, "pass", this._scene, localPositionOptions, false);
        this._updatePositionCopy();
        this._oldPositionCopy.autoClear = false;
        this._oldPositionCopy.refreshRate = 1;
        this._oldPositionCopy.onBeforeGenerationObservable.add(this._updatePositionCopy.bind(this));
      }
      _setOutputTextureBindings() {
        const remanence = this._isMoving ? this.remanence : 0.99;
        this._accumulationParams.set(remanence, this.reset ? 1 : 0, this._renderPipeline.voxelGridSize, 0);
        this._outputTexture.setTexture("spatialBlurSampler", this._renderPipeline._getSpatialBlurTexture());
        this._outputTexture.setVector4("accumulationParameters", this._accumulationParams);
        this._outputTexture.setTexture("oldAccumulationSampler", this._oldAccumulationCopy ? this._oldAccumulationCopy : this._renderPipeline._dummyTexture2d);
        this._outputTexture.setTexture("prevPositionSampler", this._oldPositionCopy ? this._oldPositionCopy : this._renderPipeline._dummyTexture2d);
        const geometryBufferRenderer = this._scene.geometryBufferRenderer;
        if (!geometryBufferRenderer) {
          return false;
        }
        const velocityIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE);
        this._outputTexture.setTexture("motionSampler", geometryBufferRenderer.getGBuffer().textures[velocityIndex]);
        const wPositionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);
        this._outputTexture.setTexture("positionSampler", geometryBufferRenderer.getGBuffer().textures[wPositionIndex]);
        this.reset = false;
        this._isMoving = false;
        return true;
      }
      _updatePositionCopy() {
        const geometryBufferRenderer = this._scene.geometryBufferRenderer;
        const index = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);
        this._oldPositionCopy.setTexture("textureSampler", geometryBufferRenderer.getGBuffer().textures[index]);
      }
      _setAccumulationCopyBindings() {
        this._oldAccumulationCopy.setTexture("textureSampler", this._outputTexture);
      }
      _render() {
        if (this.enabled && this._outputTexture.isReady() && this._outputTexture.getEffect()?.isReady()) {
          if (this._setOutputTextureBindings()) {
            this._outputTexture.render();
          }
        }
      }
      /**
       * Called by render pipeline when canvas resized.
       * @param scaleFactor The factor by which to scale the canvas size.
       */
      resize(scaleFactor = 1) {
        const newSize = {
          width: Math.max(1, Math.floor(this._engine.getRenderWidth() * scaleFactor)),
          height: Math.max(1, Math.floor(this._engine.getRenderHeight() * scaleFactor))
        };
        if (this._outputTexture.getSize().width === newSize.width && this._outputTexture.getSize().height === newSize.height) {
          return;
        }
        this._outputTexture.resize(newSize, false);
        this._oldAccumulationCopy.resize(newSize, false);
        this._oldPositionCopy.resize({ width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, false);
        this.reset = true;
      }
      _disposeTextures() {
        this._oldAccumulationCopy.dispose();
        this._oldPositionCopy.dispose();
        this._outputTexture.dispose();
      }
      /**
       * Checks if the pass is ready
       * @returns true if the pass is ready
       */
      isReady() {
        return this._oldAccumulationCopy && this._oldAccumulationCopy.isReady() && this._oldPositionCopy && this._oldPositionCopy.isReady() && this._outputTexture.isReady() && !(this._debugPassPP && !this._debugPassPP.isReady());
      }
      /**
       * Disposes the associated resources
       */
      dispose() {
        if (this._scene.geometryBufferRenderer && this._renderWhenGBufferReady) {
          const gBuffer = this._scene.geometryBufferRenderer.getGBuffer();
          gBuffer.onAfterRenderObservable.removeCallback(this._renderWhenGBufferReady);
        }
        this._disposeTextures();
        if (this._debugPassPP) {
          this._debugPassPP.dispose();
        }
        this.onReadyObservable.clear();
      }
    };
  }
});

// node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsPluginMaterial.js
var MaterialIBLShadowsRenderDefines, IBLShadowsPluginMaterial;
var init_iblShadowsPluginMaterial = __esm({
  "node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsPluginMaterial.js"() {
    init_tslib_es6();
    init_materialDefines();
    init_materialPluginBase();
    init_pbrBaseMaterial();
    init_decorators();
    init_typeStore();
    init_openpbrMaterial();
    MaterialIBLShadowsRenderDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.RENDER_WITH_IBL_SHADOWS = false;
        this.COLORED_IBL_SHADOWS = false;
      }
    };
    IBLShadowsPluginMaterial = class _IBLShadowsPluginMaterial extends MaterialPluginBase {
      get isColored() {
        return this._isColored;
      }
      set isColored(value) {
        if (this._isColored === value) {
          return;
        }
        this._isColored = value;
        this._markAllSubMeshesAsTexturesDirty();
      }
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      /**
       * Gets a boolean indicating that the plugin is compatible with a give shader language.
       * @returns true if the plugin is compatible with the shader language
       */
      isCompatible() {
        return true;
      }
      constructor(material) {
        super(material, _IBLShadowsPluginMaterial.Name, 310, new MaterialIBLShadowsRenderDefines());
        this.shadowOpacity = 1;
        this._isEnabled = false;
        this._isColored = false;
        this.isEnabled = false;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
      }
      prepareDefines(defines) {
        defines.RENDER_WITH_IBL_SHADOWS = this._isEnabled;
        defines.COLORED_IBL_SHADOWS = this.isColored;
      }
      getClassName() {
        return "IBLShadowsPluginMaterial";
      }
      getUniforms() {
        return {
          ubo: [
            { name: "renderTargetSize", size: 2, type: "vec2" },
            { name: "shadowOpacity", size: 1, type: "float" }
          ],
          fragment: `#ifdef RENDER_WITH_IBL_SHADOWS
                    uniform vec2 renderTargetSize;
                    uniform float shadowOpacity;
                #endif`
        };
      }
      getSamplers(samplers) {
        samplers.push("iblShadowsTexture");
      }
      bindForSubMesh(uniformBuffer) {
        if (this._isEnabled) {
          uniformBuffer.bindTexture("iblShadowsTexture", this.iblShadowsTexture);
          uniformBuffer.updateFloat2("renderTargetSize", this._material.getScene().getEngine().getRenderWidth(), this._material.getScene().getEngine().getRenderHeight());
          uniformBuffer.updateFloat("shadowOpacity", this.shadowOpacity);
        }
      }
      getCustomCode(shaderType, shaderLanguage) {
        let frag;
        if (shaderLanguage === 1) {
          frag = {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            CUSTOM_FRAGMENT_DEFINITIONS: `
                #ifdef RENDER_WITH_IBL_SHADOWS
                    var iblShadowsTextureSampler: sampler;
                    var iblShadowsTexture: texture_2d<f32>;

                    #ifdef COLORED_IBL_SHADOWS
                        fn computeIndirectShadow() -> vec3f {
                            var uv = fragmentInputs.position.xy / uniforms.renderTargetSize;
                            var shadowValue: vec3f = textureSample(iblShadowsTexture, iblShadowsTextureSampler, uv).rgb;
                            return mix(shadowValue, vec3f(1.0), 1.0 - uniforms.shadowOpacity);
                        }
                    #else
                        fn computeIndirectShadow() -> vec2f {
                            var uv = fragmentInputs.position.xy / uniforms.renderTargetSize;
                            var shadowValue: vec2f = textureSample(iblShadowsTexture, iblShadowsTextureSampler, uv).rg;
                            return mix(shadowValue, vec2f(1.0), 1.0 - uniforms.shadowOpacity);
                        }
                    #endif
                #endif
            `
          };
          if (this._material instanceof PBRBaseMaterial) {
            frag["CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION"] = `
                #ifdef RENDER_WITH_IBL_SHADOWS
                    #ifndef UNLIT
                        #ifdef REFLECTION
                            #ifdef COLORED_IBL_SHADOWS
                                var shadowValue: vec3f = computeIndirectShadow();
                                finalIrradiance *= shadowValue;
                                finalRadianceScaled *= mix(vec3f(1.0), shadowValue, roughness);
                            #else
                                var shadowValue: vec2f = computeIndirectShadow();
                                finalIrradiance *= vec3f(shadowValue.x);
                                finalRadianceScaled *= vec3f(mix(pow(shadowValue.y, 4.0), shadowValue.x, roughness));
                            #endif
                        #endif
                    #else
                        finalDiffuse *= computeIndirectShadow().x;
                    #endif
                #endif
            `;
          } else if (this._material instanceof OpenPBRMaterial) {
            frag["CUSTOM_FRAGMENT_BEFORE_IBLLAYERCOMPOSITION"] = `
                #ifdef RENDER_WITH_IBL_SHADOWS
                    #ifndef UNLIT
                        #ifdef REFLECTION
                            #ifdef COLORED_IBL_SHADOWS
                                var shadowValue: vec3f = computeIndirectShadow();
                                ambient_occlusion = min(ambient_occlusion, shadowValue);
                            #else
                                var shadowValue: vec2f = computeIndirectShadow();
                                ambient_occlusion = min(ambient_occlusion, vec3f(shadowValue.x));
                                specular_ambient_occlusion = min(specular_ambient_occlusion, pow(shadowValue.y, 4.0));
                            #endif
                        #endif
                    #else
                        ambient_occlusion = min(ambient_occlusion, vec3f(computeIndirectShadow().x));
                    #endif
                #endif
            `;
          } else {
            frag["CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR"] = `
                #ifdef RENDER_WITH_IBL_SHADOWS
                    #ifdef COLORED_IBL_SHADOWS
                        var shadowValue: vec3f = computeIndirectShadow();
                        color *= toGammaSpace(vec4f(shadowValue, 1.0f));
                    #else
                        var shadowValue: vec2f = computeIndirectShadow();
                        color *= toGammaSpace(vec4f(shadowValue.x, shadowValue.x, shadowValue.x, 1.0f));
                    #endif
                #endif
            `;
          }
        } else {
          frag = {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            CUSTOM_FRAGMENT_DEFINITIONS: `
                #ifdef RENDER_WITH_IBL_SHADOWS
                    uniform sampler2D iblShadowsTexture;
                #ifdef COLORED_IBL_SHADOWS
                    vec3 computeIndirectShadow() {
                        vec2 uv = gl_FragCoord.xy / renderTargetSize;
                        vec3 shadowValue = texture2D(iblShadowsTexture, uv).rgb;
                        return mix(shadowValue.rgb, vec3(1.0), 1.0 - shadowOpacity);
                    }
                #else
                    vec2 computeIndirectShadow() {
                        vec2 uv = gl_FragCoord.xy / renderTargetSize;
                        vec2 shadowValue = texture2D(iblShadowsTexture, uv).rg;
                        return mix(shadowValue.rg, vec2(1.0), 1.0 - shadowOpacity);
                    }
                #endif
                #endif
            `
          };
          if (this._material instanceof PBRBaseMaterial) {
            frag["CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION"] = `
                #ifdef RENDER_WITH_IBL_SHADOWS
                    #ifndef UNLIT
                        #ifdef REFLECTION
                            #ifdef COLORED_IBL_SHADOWS
                                vec3 shadowValue = computeIndirectShadow();
                                finalIrradiance.rgb *= shadowValue.rgb;
                                finalRadianceScaled *= mix(vec3(1.0), shadowValue.rgb, roughness);
                            #else
                                vec2 shadowValue = computeIndirectShadow();
                                finalIrradiance *= shadowValue.x;
                                finalRadianceScaled *= mix(pow(shadowValue.y, 4.0), shadowValue.x, roughness);
                            #endif
                        #endif
                    #else
                        finalDiffuse *= computeIndirectShadow().x;
                    #endif
                #endif
            `;
          } else if (this._material instanceof OpenPBRMaterial) {
            frag["CUSTOM_FRAGMENT_BEFORE_IBLLAYERCOMPOSITION"] = `
                #ifdef RENDER_WITH_IBL_SHADOWS
                    #ifndef UNLIT
                        #ifdef REFLECTION
                            #ifdef COLORED_IBL_SHADOWS
                                vec3 shadowValue = computeIndirectShadow();
                                ambient_occlusion = min(ambient_occlusion, shadowValue);
                            #else
                                vec2 shadowValue = computeIndirectShadow();
                                ambient_occlusion = min(ambient_occlusion, vec3(shadowValue.x));
                                specular_ambient_occlusion = min(specular_ambient_occlusion, pow(shadowValue.y, 4.0));
                            #endif
                        #endif
                    #else
                        ambient_occlusion = min(ambient_occlusion, vec3(computeIndirectShadow().x));
                    #endif
                #endif
            `;
          } else {
            frag["CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR"] = `
                #ifdef RENDER_WITH_IBL_SHADOWS
                    #ifdef COLORED_IBL_SHADOWS
                        vec3 shadowValue = computeIndirectShadow();
                        color.rgb *= toGammaSpace(shadowValue.rgb);
                    #else
                        vec2 shadowValue = computeIndirectShadow();
                        color.rgb *= toGammaSpace(shadowValue.x);
                    #endif
                #endif
            `;
          }
        }
        return shaderType === "vertex" ? null : frag;
      }
    };
    IBLShadowsPluginMaterial.Name = "IBLShadowsPluginMaterial";
    __decorate([
      serialize()
    ], IBLShadowsPluginMaterial.prototype, "shadowOpacity", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], IBLShadowsPluginMaterial.prototype, "isEnabled", void 0);
    RegisterClass(`BABYLON.IBLShadowsPluginMaterial`, IBLShadowsPluginMaterial);
  }
});

// node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsRenderPipeline.js
var IblShadowsRenderPipeline;
var init_iblShadowsRenderPipeline = __esm({
  "node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsRenderPipeline.js"() {
    init_engineStore();
    init_math_vector();
    init_texture();
    init_logger();
    init_iblShadowsVoxelRenderer();
    init_iblShadowsVoxelTracingPass();
    init_postProcess();
    init_iblShadowsSpatialBlurPass();
    init_iblShadowsAccumulationPass();
    init_postProcessRenderPipeline();
    init_postProcessRenderEffect();
    init_geometryBufferRenderer();
    init_rawTexture();
    init_rawTexture3D();
    init_engine();
    init_iblShadowsPluginMaterial();
    init_pbrBaseMaterial();
    init_standardMaterial();
    init_observable();
    init_geometryBufferRendererSceneComponent();
    init_iblCdfGeneratorSceneComponent();
    init_openpbrMaterial();
    init_tools();
    IblShadowsRenderPipeline = class extends PostProcessRenderPipeline {
      /**
       * Reset the shadow accumulation. This has a similar affect to lowering the remanence for a single frame.
       * This is useful when making a sudden change to the IBL.
       */
      resetAccumulation() {
        this._accumulationPass.reset = true;
      }
      /**
       * How dark the shadows appear. 1.0 is full opacity, 0.0 is no shadows.
       */
      get shadowOpacity() {
        return this._shadowOpacity;
      }
      set shadowOpacity(value) {
        this._shadowOpacity = value;
        this._setPluginParameters();
      }
      /**
       * Render the shadows in color rather than black and white.
       * This is slightly more expensive than black and white shadows but can be much
       * more accurate when the strongest lights in the IBL are non-white.
       */
      get coloredShadows() {
        return this._coloredShadows;
      }
      set coloredShadows(value) {
        this._coloredShadows = value;
        this._voxelTracingPass.coloredShadows = value;
        this._setPluginParameters();
      }
      /**
       * A multiplier for the render size of the shadows. Used for rendering lower-resolution shadows.
       */
      get shadowRenderSizeFactor() {
        return this._renderSizeFactor;
      }
      set shadowRenderSizeFactor(value) {
        this._renderSizeFactor = Math.max(Math.min(value, 1), 0);
        this._voxelTracingPass.resize(value);
        this._spatialBlurPass.resize(value);
        this._accumulationPass.resize(value);
        this._setPluginParameters();
      }
      /**
       * How dark the voxel shadows appear. 1.0 is full opacity, 0.0 is no shadows.
       */
      get voxelShadowOpacity() {
        return this._voxelTracingPass?.voxelShadowOpacity;
      }
      set voxelShadowOpacity(value) {
        if (!this._voxelTracingPass) {
          return;
        }
        this._voxelTracingPass.voxelShadowOpacity = value;
      }
      /**
       * How dark the screen-space shadows appear. 1.0 is full opacity, 0.0 is no shadows.
       */
      get ssShadowOpacity() {
        return this._voxelTracingPass?.ssShadowOpacity;
      }
      set ssShadowOpacity(value) {
        if (!this._voxelTracingPass) {
          return;
        }
        this._voxelTracingPass.ssShadowOpacity = value;
      }
      /**
       * The number of samples used in the screen space shadow pass.
       */
      get ssShadowSampleCount() {
        return this._voxelTracingPass?.sssSamples;
      }
      set ssShadowSampleCount(value) {
        if (!this._voxelTracingPass) {
          return;
        }
        this._voxelTracingPass.sssSamples = value;
      }
      /**
       * The stride of the screen-space shadow pass. This controls the distance between samples
       * in pixels.
       */
      get ssShadowStride() {
        return this._voxelTracingPass?.sssStride;
      }
      set ssShadowStride(value) {
        if (!this._voxelTracingPass) {
          return;
        }
        this._voxelTracingPass.sssStride = value;
      }
      /**
       * A scale for the maximum distance a screen-space shadow can be cast in world-space.
       * The maximum distance that screen-space shadows cast is derived from the voxel size
       * and this value so shouldn't need to change if you scale your scene
       */
      get ssShadowDistanceScale() {
        return this._sssMaxDistScale;
      }
      set ssShadowDistanceScale(value) {
        this._sssMaxDistScale = value;
        this._updateSsShadowParams();
      }
      /**
       * Screen-space shadow thickness scale. This value controls the assumed thickness of
       * on-screen surfaces in world-space. It scales with the size of the shadow-casting
       * region so shouldn't need to change if you scale your scene.
       */
      get ssShadowThicknessScale() {
        return this._sssThicknessScale;
      }
      set ssShadowThicknessScale(value) {
        this._sssThicknessScale = value;
        this._updateSsShadowParams();
      }
      /**
       * Returns the texture containing the voxel grid data
       * @returns The texture containing the voxel grid data
       * @internal
       */
      _getVoxelGridTexture() {
        const tex = this._voxelRenderer?.getVoxelGrid();
        if (tex && tex.isReady()) {
          return tex;
        }
        return this._dummyTexture3d;
      }
      /**
       * Returns the noise texture.
       * @returns The noise texture.
       * @internal
       */
      _getNoiseTexture() {
        const tex = this._noiseTexture;
        if (tex && tex.isReady()) {
          return tex;
        }
        return this._dummyTexture2d;
      }
      /**
       * Returns the voxel-tracing texture.
       * @returns The voxel-tracing texture.
       * @internal
       */
      _getVoxelTracingTexture() {
        const tex = this._voxelTracingPass?.getOutputTexture();
        if (tex && tex.isReady()) {
          return tex;
        }
        return this._dummyTexture2d;
      }
      /**
       * Returns the spatial blur texture.
       * @returns The spatial blur texture.
       * @internal
       */
      _getSpatialBlurTexture() {
        const tex = this._spatialBlurPass.getOutputTexture();
        if (tex && tex.isReady()) {
          return tex;
        }
        return this._dummyTexture2d;
      }
      /**
       * Returns the accumulated shadow texture.
       * @returns The accumulated shadow texture.
       * @internal
       */
      _getAccumulatedTexture() {
        const tex = this._accumulationPass?.getOutputTexture();
        if (tex && tex.isReady()) {
          return tex;
        }
        return this._dummyTexture2d;
      }
      /**
       * Turn on or off the debug view of the G-Buffer. This will display only the targets
       * of the g-buffer that are used by the shadow pipeline.
       */
      get gbufferDebugEnabled() {
        return this._gbufferDebugEnabled;
      }
      set gbufferDebugEnabled(enabled) {
        if (enabled && !this.allowDebugPasses) {
          Logger.Warn("Can't enable G-Buffer debug view without setting allowDebugPasses to true.");
          return;
        }
        this._gbufferDebugEnabled = enabled;
        if (enabled) {
          this._enableEffect(this._getGBufferDebugPass().name, this.cameras);
        } else {
          this._disableEffect(this._getGBufferDebugPass().name, this.cameras);
        }
      }
      /**
       * Turn on or off the debug view of the CDF importance sampling data
       */
      get cdfDebugEnabled() {
        return this.scene.iblCdfGenerator ? this.scene.iblCdfGenerator.debugEnabled : false;
      }
      /**
       * Turn on or off the debug view of the CDF importance sampling data
       */
      set cdfDebugEnabled(enabled) {
        if (!this.scene.iblCdfGenerator) {
          return;
        }
        if (enabled && !this.allowDebugPasses) {
          Logger.Warn("Can't enable importance sampling debug view without setting allowDebugPasses to true.");
          return;
        }
        if (enabled === this.scene.iblCdfGenerator.debugEnabled) {
          return;
        }
        this.scene.iblCdfGenerator.debugEnabled = enabled;
        if (enabled) {
          this._enableEffect(this.scene.iblCdfGenerator.debugPassName, this.cameras);
        } else {
          this._disableEffect(this.scene.iblCdfGenerator.debugPassName, this.cameras);
        }
      }
      /**
       * This displays the voxel grid in slices spread across the screen.
       * It also displays what slices of the model are stored in each layer
       * of the voxel grid. Each red stripe represents one layer while each gradient
       * (from bright red to black) represents the layers rendered in a single draw call.
       */
      get voxelDebugEnabled() {
        return this._voxelRenderer?.voxelDebugEnabled;
      }
      set voxelDebugEnabled(enabled) {
        if (!this._voxelRenderer) {
          return;
        }
        if (enabled && !this.allowDebugPasses) {
          Logger.Warn("Can't enable voxel debug view without setting allowDebugPasses to true.");
          return;
        }
        this._voxelRenderer.voxelDebugEnabled = enabled;
        if (enabled) {
          this._enableEffect(this._voxelRenderer.debugPassName, this.cameras);
        } else {
          this._disableEffect(this._voxelRenderer.debugPassName, this.cameras);
        }
      }
      /**
       * When using tri-planar voxelization (the default), this value can be used to
       * display only the voxelization result for that axis. z-axis = 0, y-axis = 1, x-axis = 2
       */
      get voxelDebugAxis() {
        return this._voxelRenderer?.voxelDebugAxis;
      }
      set voxelDebugAxis(axisNum) {
        if (!this._voxelRenderer) {
          return;
        }
        this._voxelRenderer.voxelDebugAxis = axisNum;
      }
      /**
       * Displays a given mip of the voxel grid. `voxelDebugAxis` must be undefined in this
       * case because we only generate mips for the combined voxel grid.
       */
      set voxelDebugDisplayMip(mipNum) {
        if (!this._voxelRenderer) {
          return;
        }
        this._voxelRenderer.setDebugMipNumber(mipNum);
      }
      /**
       * Display the debug view for just the shadow samples taken this frame.
       */
      get voxelTracingDebugEnabled() {
        return this._voxelTracingPass?.debugEnabled;
      }
      set voxelTracingDebugEnabled(enabled) {
        if (!this._voxelTracingPass) {
          return;
        }
        if (enabled && !this.allowDebugPasses) {
          Logger.Warn("Can't enable voxel tracing debug view without setting allowDebugPasses to true.");
          return;
        }
        if (enabled === this._voxelTracingPass.debugEnabled) {
          return;
        }
        this._voxelTracingPass.debugEnabled = enabled;
        if (enabled) {
          this._enableEffect(this._voxelTracingPass.debugPassName, this.cameras);
        } else {
          this._disableEffect(this._voxelTracingPass.debugPassName, this.cameras);
        }
      }
      /**
       * Display the debug view for the spatial blur pass
       */
      get spatialBlurPassDebugEnabled() {
        return this._spatialBlurPass.debugEnabled;
      }
      set spatialBlurPassDebugEnabled(enabled) {
        if (!this._spatialBlurPass) {
          return;
        }
        if (enabled && !this.allowDebugPasses) {
          Logger.Warn("Can't enable spatial blur debug view without setting allowDebugPasses to true.");
          return;
        }
        if (enabled === this._spatialBlurPass.debugEnabled) {
          return;
        }
        this._spatialBlurPass.debugEnabled = enabled;
        if (enabled) {
          this._enableEffect(this._spatialBlurPass.debugPassName, this.cameras);
        } else {
          this._disableEffect(this._spatialBlurPass.debugPassName, this.cameras);
        }
      }
      /**
       * Display the debug view for the shadows accumulated over time.
       */
      get accumulationPassDebugEnabled() {
        return this._accumulationPass?.debugEnabled;
      }
      set accumulationPassDebugEnabled(enabled) {
        if (!this._accumulationPass) {
          return;
        }
        if (enabled && !this.allowDebugPasses) {
          Logger.Warn("Can't enable accumulation pass debug view without setting allowDebugPasses to true.");
          return;
        }
        if (enabled === this._accumulationPass.debugEnabled) {
          return;
        }
        this._accumulationPass.debugEnabled = enabled;
        if (enabled) {
          this._enableEffect(this._accumulationPass.debugPassName, this.cameras);
        } else {
          this._disableEffect(this._accumulationPass.debugPassName, this.cameras);
        }
      }
      /**
       * Add a mesh to be used for shadow-casting in the IBL shadow pipeline.
       * These meshes will be written to the voxel grid.
       * @param mesh A mesh or list of meshes that you want to cast shadows
       */
      addShadowCastingMesh(mesh) {
        if (Array.isArray(mesh)) {
          for (const m of mesh) {
            if (m && this._shadowCastingMeshes.indexOf(m) === -1) {
              this._shadowCastingMeshes.push(m);
            }
          }
        } else {
          if (mesh && this._shadowCastingMeshes.indexOf(mesh) === -1) {
            this._shadowCastingMeshes.push(mesh);
          }
        }
      }
      /**
       * Remove a mesh from the shadow-casting list. The mesh will no longer be written
       * to the voxel grid and will not cast shadows.
       * @param mesh The mesh or list of meshes that you don't want to cast shadows.
       */
      removeShadowCastingMesh(mesh) {
        if (Array.isArray(mesh)) {
          for (const m of mesh) {
            const index = this._shadowCastingMeshes.indexOf(m);
            if (index !== -1) {
              this._shadowCastingMeshes.splice(index, 1);
            }
          }
        } else {
          const index = this._shadowCastingMeshes.indexOf(mesh);
          if (index !== -1) {
            this._shadowCastingMeshes.splice(index, 1);
          }
        }
      }
      /**
       * Clear the list of shadow-casting meshes. This will remove all meshes from the list
       */
      clearShadowCastingMeshes() {
        this._shadowCastingMeshes.length = 0;
      }
      /**
       * The exponent of the resolution of the voxel shadow grid. Higher resolutions will result in sharper
       * shadows but are more expensive to compute and require more memory.
       * The resolution is calculated as 2 to the power of this number.
       */
      get resolutionExp() {
        return this._voxelRenderer.voxelResolutionExp;
      }
      set resolutionExp(newResolution) {
        if (newResolution === this._voxelRenderer.voxelResolutionExp) {
          return;
        }
        if (this._voxelRenderer.isVoxelizationInProgress()) {
          Logger.Warn("Can't change the resolution of the voxel grid while voxelization is in progress.");
          return;
        }
        this._voxelRenderer.voxelResolutionExp = Math.max(1, Math.min(newResolution, 8));
        this._accumulationPass.reset = true;
      }
      /**
       * The number of different directions to sample during the voxel tracing pass
       */
      get sampleDirections() {
        return this._voxelTracingPass?.sampleDirections;
      }
      /**
       * The number of different directions to sample during the voxel tracing pass
       */
      set sampleDirections(value) {
        if (!this._voxelTracingPass) {
          return;
        }
        this._voxelTracingPass.sampleDirections = value;
      }
      /**
       * The decree to which the shadows persist between frames. 0.0 is no persistence, 1.0 is full persistence.
       **/
      get shadowRemanence() {
        return this._accumulationPass?.remanence;
      }
      /**
       * The decree to which the shadows persist between frames. 0.0 is no persistence, 1.0 is full persistence.
       **/
      set shadowRemanence(value) {
        if (!this._accumulationPass) {
          return;
        }
        this._accumulationPass.remanence = value;
      }
      /**
       * The global Y-axis rotation of the IBL for shadows. This should match the Y-rotation of the environment map applied to materials, skybox, etc.
       */
      get envRotation() {
        return this._voxelTracingPass?.envRotation;
      }
      /**
       * The global Y-axis rotation of the IBL for shadows. This should match the Y-rotation of the environment map applied to materials, skybox, etc.
       */
      set envRotation(value) {
        if (!this._voxelTracingPass) {
          return;
        }
        this._voxelTracingPass.envRotation = value;
        this._accumulationPass.reset = true;
      }
      /**
       * Allow debug passes to be enabled. Default is false.
       */
      get allowDebugPasses() {
        return this._allowDebugPasses;
      }
      /**
       * Allow debug passes to be enabled. Default is false.
       */
      set allowDebugPasses(value) {
        if (this._allowDebugPasses === value) {
          return;
        }
        this._allowDebugPasses = value;
        if (value && this.scene.iblCdfGenerator) {
          if (this.scene.iblCdfGenerator.isReady()) {
            this._createDebugPasses();
          } else {
            this.scene.iblCdfGenerator.onGeneratedObservable.addOnce(() => {
              this._createDebugPasses();
            });
          }
        } else {
          this._disposeDebugPasses();
        }
      }
      /**
       *  Support test.
       */
      static get IsSupported() {
        const engine = EngineStore.LastCreatedEngine;
        if (!engine) {
          return false;
        }
        return engine._features.supportIBLShadows;
      }
      /**
       * Toggle the shadow tracing on or off
       * @param enabled Toggle the shadow tracing on or off
       */
      toggleShadow(enabled) {
        this._enabled = enabled;
        this._voxelTracingPass.enabled = enabled;
        this._spatialBlurPass.enabled = enabled;
        this._accumulationPass.enabled = enabled;
        for (const mat of this._materialsWithRenderPlugin) {
          if (mat.pluginManager) {
            const plugin = mat.pluginManager.getPlugin(IBLShadowsPluginMaterial.Name);
            plugin.isEnabled = enabled;
          }
        }
        this._setPluginParameters();
      }
      /**
       * Trigger the scene to be re-voxelized. This should be run when any shadow-casters have been added, removed or moved.
       */
      updateVoxelization() {
        if (this._shadowCastingMeshes.length === 0) {
          Logger.Warn("IBL Shadows: updateVoxelization called with no shadow-casting meshes to voxelize.");
          return;
        }
        this._voxelRenderer.updateVoxelGrid(this._shadowCastingMeshes);
        this._voxelRenderer.onVoxelizationCompleteObservable.addOnce(() => {
          this.onVoxelizationCompleteObservable.notifyObservers();
        });
        this._updateSsShadowParams();
      }
      /**
       * Trigger the scene bounds of shadow-casters to be calculated. This is the world size that the voxel grid will cover and will always be a cube.
       */
      updateSceneBounds() {
        const bounds = {
          min: new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),
          max: new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE)
        };
        for (const mesh of this._shadowCastingMeshes) {
          const localBounds = mesh.getHierarchyBoundingVectors(true);
          bounds.min = Vector3.Minimize(bounds.min, localBounds.min);
          bounds.max = Vector3.Maximize(bounds.max, localBounds.max);
        }
        const size = bounds.max.subtract(bounds.min);
        this.voxelGridSize = Math.max(size.x, size.y, size.z);
        if (this._shadowCastingMeshes.length === 0 || !isFinite(this.voxelGridSize) || this.voxelGridSize === 0) {
          Logger.Warn("IBL Shadows: Scene size is invalid. Can't update bounds.");
          this.voxelGridSize = 1;
          return;
        }
        const halfSize = this.voxelGridSize / 2;
        const centre = bounds.max.add(bounds.min).multiplyByFloats(-0.5, -0.5, -0.5);
        const invWorldScaleMatrix = Matrix.Compose(new Vector3(1 / halfSize, 1 / halfSize, 1 / halfSize), new Quaternion(), new Vector3(0, 0, 0));
        const invTranslationMatrix = Matrix.Compose(new Vector3(1, 1, 1), new Quaternion(), centre);
        invTranslationMatrix.multiplyToRef(invWorldScaleMatrix, invWorldScaleMatrix);
        this._voxelTracingPass.setWorldScaleMatrix(invWorldScaleMatrix);
        this._voxelRenderer.setWorldScaleMatrix(invWorldScaleMatrix);
        this._spatialBlurPass.setWorldScale(halfSize * 2);
        this._updateSsShadowParams();
      }
      /**
       * @param name The rendering pipeline name
       * @param scene The scene linked to this pipeline
       * @param options Options to configure the pipeline
       * @param cameras Cameras to apply the pipeline to.
       */
      constructor(name13, scene, options = {}, cameras) {
        super(scene.getEngine(), name13);
        this._allowDebugPasses = false;
        this._debugPasses = [];
        this._shadowCastingMeshes = [];
        this._shadowOpacity = 0.8;
        this._enabled = true;
        this._coloredShadows = false;
        this._materialsWithRenderPlugin = [];
        this.onShadowTextureReadyObservable = new Observable();
        this.onNewIblReadyObservable = new Observable();
        this.onVoxelizationCompleteObservable = new Observable();
        this.voxelGridSize = 1;
        this._renderSizeFactor = 1;
        this._gbufferDebugEnabled = false;
        this._gBufferDebugSizeParams = new Vector4(0, 0, 0, 0);
        this.scene = scene;
        this._cameras = cameras || [scene.activeCamera];
        const blackPixels = new Uint8Array([0, 0, 0, 255]);
        this._dummyTexture2d = new RawTexture(blackPixels, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false);
        this._dummyTexture3d = new RawTexture3D(blackPixels, 1, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false);
        const textureTypesAndFormats = {};
        textureTypesAndFormats[GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE] = { textureFormat: 6, textureType: 1 };
        textureTypesAndFormats[GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE] = { textureFormat: 7, textureType: 2 };
        textureTypesAndFormats[GeometryBufferRenderer.POSITION_TEXTURE_TYPE] = { textureFormat: 5, textureType: 2 };
        textureTypesAndFormats[GeometryBufferRenderer.NORMAL_TEXTURE_TYPE] = { textureFormat: 5, textureType: 2 };
        const geometryBufferRenderer = scene.enableGeometryBufferRenderer(void 0, 14, textureTypesAndFormats);
        if (!geometryBufferRenderer) {
          Logger.Error("Geometry buffer renderer is required for IBL shadows to work.");
          return;
        }
        this._geometryBufferRenderer = geometryBufferRenderer;
        this._geometryBufferRenderer.enableScreenspaceDepth = true;
        this._geometryBufferRenderer.enableVelocityLinear = true;
        this._geometryBufferRenderer.enablePosition = true;
        this._geometryBufferRenderer.enableNormal = true;
        this._geometryBufferRenderer.generateNormalsInWorldSpace = true;
        this.scene.enableIblCdfGenerator();
        this.shadowOpacity = options.shadowOpacity || 0.8;
        this._voxelRenderer = new _IblShadowsVoxelRenderer(this.scene, this, options ? options.resolutionExp : 6, options.triPlanarVoxelization !== void 0 ? options.triPlanarVoxelization : true);
        this._voxelTracingPass = new _IblShadowsVoxelTracingPass(this.scene, this);
        this._spatialBlurPass = new _IblShadowsSpatialBlurPass(this.scene, this);
        this._accumulationPass = new _IblShadowsAccumulationPass(this.scene, this);
        this._accumulationPass.onReadyObservable.addOnce(() => {
          this.onShadowTextureReadyObservable.notifyObservers();
        });
        this.sampleDirections = options.sampleDirections || 2;
        this.voxelShadowOpacity = options.voxelShadowOpacity ?? 1;
        this.envRotation = options.envRotation ?? 0;
        this.shadowRenderSizeFactor = options.shadowRenderSizeFactor || 1;
        this.ssShadowOpacity = options.ssShadowsEnabled === void 0 || options.ssShadowsEnabled ? 1 : 0;
        this.ssShadowDistanceScale = options.ssShadowDistanceScale || 1.25;
        this.ssShadowSampleCount = options.ssShadowSampleCount || 16;
        this.ssShadowStride = options.ssShadowStride || 8;
        this.ssShadowThicknessScale = options.ssShadowThicknessScale || 1;
        this.shadowRemanence = options.shadowRemanence ?? 0.75;
        this._noiseTexture = new Texture(Tools.GetAssetUrl("https://assets.babylonjs.com/core/blue_noise/blue_noise_rgb.png"), this.scene, false, true, 1);
        scene.postProcessRenderPipelineManager.addPipeline(this);
        this.scene.onActiveCameraChanged.add(this._listenForCameraChanges.bind(this));
        this.scene.onBeforeRenderObservable.add(this._updateBeforeRender.bind(this));
        this._listenForCameraChanges();
        this.scene.getEngine().onResizeObservable.add(this._handleResize.bind(this));
        if (this.scene.iblCdfGenerator) {
          this.scene.iblCdfGenerator.onGeneratedObservable.add(() => {
            this._setPluginParameters();
            this.onNewIblReadyObservable.notifyObservers();
          });
        }
      }
      _handleResize() {
        this._voxelRenderer.resize();
        this._voxelTracingPass.resize(this.shadowRenderSizeFactor);
        this._spatialBlurPass.resize(this.shadowRenderSizeFactor);
        this._accumulationPass.resize(this.shadowRenderSizeFactor);
        this._setPluginParameters();
      }
      _getGBufferDebugPass() {
        if (this._gbufferDebugPass) {
          return this._gbufferDebugPass;
        }
        const isWebGPU = this.engine.isWebGPU;
        const textureNames = ["depthSampler", "normalSampler", "positionSampler", "velocitySampler"];
        const options = {
          width: this.scene.getEngine().getRenderWidth(),
          height: this.scene.getEngine().getRenderHeight(),
          samplingMode: 1,
          engine: this.scene.getEngine(),
          textureType: 0,
          textureFormat: 5,
          uniforms: ["sizeParams"],
          samplers: textureNames,
          reusable: false,
          shaderLanguage: isWebGPU ? 1 : 0,
          extraInitializations: (useWebGPU, list) => {
            if (useWebGPU) {
              list.push(import("./iblShadowGBufferDebug.fragment-UO7YCC43.js"));
            } else {
              list.push(import("./iblShadowGBufferDebug.fragment-YX5RRNTM.js"));
            }
          }
        };
        this._gbufferDebugPass = new PostProcess("iblShadowGBufferDebug", "iblShadowGBufferDebug", options);
        if (this.engine.isWebGPU) {
          this._gbufferDebugPass.samples = this.engine.currentSampleCount ?? 1;
        }
        this._gbufferDebugPass.autoClear = false;
        this._gbufferDebugPass.onApplyObservable.add((effect) => {
          const depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE);
          effect.setTexture("depthSampler", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);
          const normalIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.NORMAL_TEXTURE_TYPE);
          effect.setTexture("normalSampler", this._geometryBufferRenderer.getGBuffer().textures[normalIndex]);
          const positionIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);
          effect.setTexture("positionSampler", this._geometryBufferRenderer.getGBuffer().textures[positionIndex]);
          const velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE);
          effect.setTexture("velocitySampler", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);
          effect.setVector4("sizeParams", this._gBufferDebugSizeParams);
          if (this.scene.activeCamera) {
            effect.setFloat("maxDepth", this.scene.activeCamera.maxZ);
          }
        });
        return this._gbufferDebugPass;
      }
      _createDebugPasses() {
        if (this.scene.iblCdfGenerator) {
          this._debugPasses = [{ pass: this.scene.iblCdfGenerator.getDebugPassPP(), enabled: this.cdfDebugEnabled }];
        } else {
          this._debugPasses = [];
        }
        this._debugPasses.push({ pass: this._voxelRenderer.getDebugPassPP(), enabled: this.voxelDebugEnabled }, { pass: this._voxelTracingPass.getDebugPassPP(), enabled: this.voxelTracingDebugEnabled }, { pass: this._spatialBlurPass.getDebugPassPP(), enabled: this.spatialBlurPassDebugEnabled }, { pass: this._accumulationPass.getDebugPassPP(), enabled: this.accumulationPassDebugEnabled }, { pass: this._getGBufferDebugPass(), enabled: this.gbufferDebugEnabled });
        for (let i = 0; i < this._debugPasses.length; i++) {
          if (!this._debugPasses[i].pass) {
            continue;
          }
          this.addEffect(new PostProcessRenderEffect(this.scene.getEngine(), this._debugPasses[i].pass.name, () => {
            return this._debugPasses[i].pass;
          }, true));
        }
        const cameras = this.cameras.slice();
        this.scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this.name, this.cameras);
        this.scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this.name, cameras);
        for (let i = 0; i < this._debugPasses.length; i++) {
          if (!this._debugPasses[i].pass) {
            continue;
          }
          if (this._debugPasses[i].enabled) {
            this._enableEffect(this._debugPasses[i].pass.name, this.cameras);
          } else {
            this._disableEffect(this._debugPasses[i].pass.name, this.cameras);
          }
        }
      }
      _disposeEffectPasses() {
        this.scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this.name, this.cameras);
        this._disposeDebugPasses();
        this._reset();
      }
      _disposeDebugPasses() {
        for (let i = 0; i < this._debugPasses.length; i++) {
          this._disableEffect(this._debugPasses[i].pass.name, this.cameras);
          this._debugPasses[i].pass.dispose();
        }
        this._debugPasses = [];
      }
      _updateDebugPasses() {
        let count = 0;
        if (this._gbufferDebugEnabled) {
          count++;
        }
        if (this.cdfDebugEnabled) {
          count++;
        }
        if (this.voxelDebugEnabled) {
          count++;
        }
        if (this.voxelTracingDebugEnabled) {
          count++;
        }
        if (this.spatialBlurPassDebugEnabled) {
          count++;
        }
        if (this.accumulationPassDebugEnabled) {
          count++;
        }
        const rows = Math.ceil(Math.sqrt(count));
        const cols = Math.ceil(count / rows);
        const width = 1 / cols;
        const height = 1 / rows;
        let x = 0;
        let y = 0;
        if (this.gbufferDebugEnabled) {
          this._gBufferDebugSizeParams.set(x, y, cols, rows);
          x -= width;
          if (x <= -1) {
            x = 0;
            y -= height;
          }
        }
        if (this.cdfDebugEnabled && this.scene.iblCdfGenerator) {
          this.scene.iblCdfGenerator.setDebugDisplayParams(x, y, cols, rows);
          x -= width;
          if (x <= -1) {
            x = 0;
            y -= height;
          }
        }
        if (this.voxelDebugEnabled) {
          this._voxelRenderer.setDebugDisplayParams(x, y, cols, rows);
          x -= width;
          if (x <= -1) {
            x = 0;
            y -= height;
          }
        }
        if (this.voxelTracingDebugEnabled) {
          this._voxelTracingPass.setDebugDisplayParams(x, y, cols, rows);
          x -= width;
          if (x <= -1) {
            x = 0;
            y -= height;
          }
        }
        if (this.spatialBlurPassDebugEnabled) {
          this._spatialBlurPass.setDebugDisplayParams(x, y, cols, rows);
          x -= width;
          if (x <= -1) {
            x = 0;
            y -= height;
          }
        }
        if (this.accumulationPassDebugEnabled) {
          this._accumulationPass.setDebugDisplayParams(x, y, cols, rows);
          x -= width;
          if (x <= -1) {
            x = 0;
            y -= height;
          }
        }
      }
      /**
       * Update the SS shadow max distance and thickness based on the voxel grid size and resolution.
       * The max distance should be just a little larger than the world size of a single voxel.
       */
      _updateSsShadowParams() {
        this._voxelTracingPass.sssMaxDist = this._sssMaxDistScale * this.voxelGridSize / (1 << this.resolutionExp);
        this._voxelTracingPass.sssThickness = this._sssThicknessScale * 5e-3 * this.voxelGridSize;
      }
      /**
       * Apply the shadows to a material or array of materials. If no material is provided, all
       * materials in the scene will be added.
       * @param material Material that will be affected by the shadows. If not provided, all materials of the scene will be affected.
       */
      addShadowReceivingMaterial(material) {
        if (material) {
          if (Array.isArray(material)) {
            for (const m of material) {
              this._addShadowSupportToMaterial(m);
            }
          } else {
            this._addShadowSupportToMaterial(material);
          }
        } else {
          for (const mat of this.scene.materials) {
            this._addShadowSupportToMaterial(mat);
          }
        }
      }
      /**
       * Remove a material from the list of materials that receive shadows. If no material
       * is provided, all materials in the scene will be removed.
       * @param material The material or array of materials that will no longer receive shadows
       */
      removeShadowReceivingMaterial(material) {
        if (Array.isArray(material)) {
          for (const m of material) {
            const matIndex = this._materialsWithRenderPlugin.indexOf(m);
            if (matIndex !== -1) {
              this._materialsWithRenderPlugin.splice(matIndex, 1);
              const plugin = m.pluginManager?.getPlugin(IBLShadowsPluginMaterial.Name);
              plugin.isEnabled = false;
            }
          }
        } else {
          const matIndex = this._materialsWithRenderPlugin.indexOf(material);
          if (matIndex !== -1) {
            this._materialsWithRenderPlugin.splice(matIndex, 1);
            const plugin = material.pluginManager.getPlugin(IBLShadowsPluginMaterial.Name);
            plugin.isEnabled = false;
          }
        }
      }
      /**
       * Clear the list of materials that receive shadows. This will remove all materials from the list
       */
      clearShadowReceivingMaterials() {
        for (const mat of this._materialsWithRenderPlugin) {
          const plugin = mat.pluginManager?.getPlugin(IBLShadowsPluginMaterial.Name);
          if (plugin) {
            plugin.isEnabled = false;
          }
        }
        this._materialsWithRenderPlugin.length = 0;
      }
      _addShadowSupportToMaterial(material) {
        if (!(material instanceof PBRBaseMaterial) && !(material instanceof StandardMaterial) && !(material instanceof OpenPBRMaterial)) {
          return;
        }
        let plugin = material.pluginManager?.getPlugin(IBLShadowsPluginMaterial.Name);
        if (!plugin) {
          plugin = new IBLShadowsPluginMaterial(material);
        }
        if (this._materialsWithRenderPlugin.indexOf(material) !== -1) {
          return;
        }
        if (this._enabled) {
          plugin.iblShadowsTexture = this._getAccumulatedTexture().getInternalTexture();
          plugin.shadowOpacity = this.shadowOpacity;
        }
        plugin.isEnabled = this._enabled;
        plugin.isColored = this._coloredShadows;
        this._materialsWithRenderPlugin.push(material);
      }
      _setPluginParameters() {
        if (!this._enabled) {
          return;
        }
        for (const mat of this._materialsWithRenderPlugin) {
          if (mat.pluginManager) {
            const plugin = mat.pluginManager.getPlugin(IBLShadowsPluginMaterial.Name);
            plugin.iblShadowsTexture = this._getAccumulatedTexture().getInternalTexture();
            plugin.shadowOpacity = this.shadowOpacity;
            plugin.isColored = this._coloredShadows;
          }
        }
      }
      _updateBeforeRender() {
        this._updateDebugPasses();
      }
      _listenForCameraChanges() {
        this.scene.activeCamera?.onViewMatrixChangedObservable.add(() => {
          this._accumulationPass.isMoving = true;
        });
      }
      /**
       * Checks if the IBL shadow pipeline is ready to render shadows
       * @returns true if the IBL shadow pipeline is ready to render the shadows
       */
      isReady() {
        return this._noiseTexture.isReady() && this._voxelRenderer.isReady() && this.scene.iblCdfGenerator && this.scene.iblCdfGenerator.isReady() && (!this._voxelTracingPass || this._voxelTracingPass.isReady()) && (!this._spatialBlurPass || this._spatialBlurPass.isReady()) && (!this._accumulationPass || this._accumulationPass.isReady());
      }
      /**
       * Get the class name
       * @returns "IBLShadowsRenderPipeline"
       */
      getClassName() {
        return "IBLShadowsRenderPipeline";
      }
      /**
       * Disposes the IBL shadow pipeline and associated resources
       */
      dispose() {
        const materials = this._materialsWithRenderPlugin.splice(0);
        for (const mat of materials) {
          this.removeShadowReceivingMaterial(mat);
        }
        this._disposeEffectPasses();
        this._noiseTexture.dispose();
        this._voxelRenderer.dispose();
        this._voxelTracingPass.dispose();
        this._spatialBlurPass.dispose();
        this._accumulationPass.dispose();
        this._dummyTexture2d.dispose();
        this._dummyTexture3d.dispose();
        this.onNewIblReadyObservable.clear();
        this.onShadowTextureReadyObservable.clear();
        this.onVoxelizationCompleteObservable.clear();
        super.dispose();
      }
    };
  }
});

// node_modules/@babylonjs/core/Rendering/outlineRenderer.js
var OutlineRenderer;
var init_outlineRenderer = __esm({
  "node_modules/@babylonjs/core/Rendering/outlineRenderer.js"() {
    init_buffer();
    init_mesh();
    init_scene();
    init_sceneComponent();
    init_drawWrapper();
    init_clipPlaneMaterialHelper();
    init_materialHelper_functions();
    init_effectFallbacks();
    Scene.prototype.getOutlineRenderer = function() {
      if (!this._outlineRenderer) {
        this._outlineRenderer = new OutlineRenderer(this);
      }
      return this._outlineRenderer;
    };
    Object.defineProperty(Mesh.prototype, "renderOutline", {
      get: function() {
        return this._renderOutline;
      },
      set: function(value) {
        if (value) {
          this.getScene().getOutlineRenderer();
        }
        this._renderOutline = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(Mesh.prototype, "renderOverlay", {
      get: function() {
        return this._renderOverlay;
      },
      set: function(value) {
        if (value) {
          this.getScene().getOutlineRenderer();
        }
        this._renderOverlay = value;
      },
      enumerable: true,
      configurable: true
    });
    OutlineRenderer = class _OutlineRenderer {
      /**
       * Gets the shader language used in the Outline renderer.
       */
      get shaderLanguage() {
        return this._shaderLanguage;
      }
      /**
       * Instantiates a new outline renderer. (There could be only one per scene).
       * @param scene Defines the scene it belongs to
       */
      constructor(scene) {
        this.name = SceneComponentConstants.NAME_OUTLINERENDERER;
        this.zOffset = 1;
        this.zOffsetUnits = 4;
        this.enabled = true;
        this._shaderLanguage = 0;
        this.scene = scene;
        this._engine = scene.getEngine();
        this.scene._addComponent(this);
        this._passIdForDrawWrapper = [];
        for (let i = 0; i < 4; ++i) {
          this._passIdForDrawWrapper[i] = this._engine.createRenderPassId(`Outline Renderer (${i})`);
        }
        const engine = this._engine;
        if (engine.isWebGPU) {
          this._shaderLanguage = 1;
        }
      }
      /**
       * Register the component to one instance of a scene.
       */
      register() {
        this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh);
        this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh);
      }
      /**
       * Rebuilds the elements related to this component in case of
       * context lost for instance.
       */
      rebuild() {
      }
      /**
       * Disposes the component and the associated resources.
       */
      dispose() {
        for (let i = 0; i < this._passIdForDrawWrapper.length; ++i) {
          this._engine.releaseRenderPassId(this._passIdForDrawWrapper[i]);
        }
      }
      /**
       * Renders the outline in the canvas.
       * @param subMesh Defines the sumesh to render
       * @param batch Defines the batch of meshes in case of instances
       * @param useOverlay Defines if the rendering is for the overlay or the outline
       * @param renderPassId Render pass id to use to render the mesh
       */
      render(subMesh, batch, useOverlay = false, renderPassId) {
        renderPassId = renderPassId ?? this._passIdForDrawWrapper[0];
        const scene = this.scene;
        const engine = scene.getEngine();
        const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || subMesh.getRenderingMesh().hasThinInstances);
        if (!this.isReady(subMesh, hardwareInstancedRendering, renderPassId)) {
          return;
        }
        const ownerMesh = subMesh.getMesh();
        const replacementMesh = ownerMesh._internalAbstractMeshDataInfo._actAsRegularMesh ? ownerMesh : null;
        const renderingMesh = subMesh.getRenderingMesh();
        const effectiveMesh = replacementMesh ? replacementMesh : renderingMesh;
        const material = subMesh.getMaterial();
        if (!material || !scene.activeCamera) {
          return;
        }
        const drawWrapper = subMesh._getDrawWrapper(renderPassId);
        const effect = DrawWrapper.GetEffect(drawWrapper);
        engine.enableEffect(drawWrapper);
        if (material.useLogarithmicDepth) {
          effect.setFloat("logarithmicDepthConstant", 2 / (Math.log(scene.activeCamera.maxZ + 1) / Math.LN2));
        }
        effect.setFloat("offset", useOverlay ? 0 : renderingMesh.outlineWidth);
        effect.setColor4("color", useOverlay ? renderingMesh.overlayColor : renderingMesh.outlineColor, useOverlay ? renderingMesh.overlayAlpha : material.alpha);
        effect.setMatrix("viewProjection", scene.getTransformMatrix());
        effect.setMatrix("world", effectiveMesh.getWorldMatrix());
        BindBonesParameters(renderingMesh, effect);
        BindMorphTargetParameters(renderingMesh, effect);
        if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
          renderingMesh.morphTargetManager._bind(effect);
        }
        if (!hardwareInstancedRendering) {
          renderingMesh._bind(subMesh, effect, material.fillMode);
        }
        const bvaManager = subMesh.getMesh().bakedVertexAnimationManager;
        if (bvaManager && bvaManager.isEnabled) {
          bvaManager.bind(effect, hardwareInstancedRendering);
        }
        if (material && material.needAlphaTestingForMesh(effectiveMesh)) {
          const alphaTexture = material.getAlphaTestTexture();
          if (alphaTexture) {
            effect.setTexture("diffuseSampler", alphaTexture);
            effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
          }
        }
        BindClipPlane(effect, material, scene);
        engine.setZOffset(-this.zOffset);
        engine.setZOffsetUnits(-this.zOffsetUnits);
        renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => {
          effect.setMatrix("world", world);
        });
        engine.setZOffset(0);
        engine.setZOffsetUnits(0);
      }
      /**
       * Returns whether or not the outline renderer is ready for a given submesh.
       * All the dependencies e.g. submeshes, texture, effect... mus be ready
       * @param subMesh Defines the submesh to check readiness for
       * @param useInstances Defines whether wee are trying to render instances or not
       * @param renderPassId Render pass id to use to render the mesh
       * @returns true if ready otherwise false
       */
      isReady(subMesh, useInstances, renderPassId) {
        renderPassId = renderPassId ?? this._passIdForDrawWrapper[0];
        const defines = [];
        const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];
        const mesh = subMesh.getMesh();
        const material = subMesh.getMaterial();
        if (!material) {
          return false;
        }
        const scene = mesh.getScene();
        let uv1 = false;
        let uv2 = false;
        const color = false;
        if (material.needAlphaTestingForMesh(mesh)) {
          defines.push("#define ALPHATEST");
          if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
            attribs.push(VertexBuffer.UVKind);
            defines.push("#define UV1");
            uv1 = true;
          }
          if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
            attribs.push(VertexBuffer.UV2Kind);
            defines.push("#define UV2");
            uv2 = true;
          }
        }
        if (material.useLogarithmicDepth) {
          defines.push("#define LOGARITHMICDEPTH");
        }
        PrepareStringDefinesForClipPlanes(material, scene, defines);
        const fallbacks = new EffectFallbacks();
        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
          attribs.push(VertexBuffer.MatricesIndicesKind);
          attribs.push(VertexBuffer.MatricesWeightsKind);
          if (mesh.numBoneInfluencers > 4) {
            attribs.push(VertexBuffer.MatricesIndicesExtraKind);
            attribs.push(VertexBuffer.MatricesWeightsExtraKind);
          }
          const skeleton = mesh.skeleton;
          defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
          if (mesh.numBoneInfluencers > 0) {
            fallbacks.addCPUSkinningFallback(0, mesh);
          }
          if (skeleton.isUsingTextureForMatrices) {
            defines.push("#define BONETEXTURE");
          } else {
            defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
          }
        } else {
          defines.push("#define NUM_BONE_INFLUENCERS 0");
        }
        const numMorphInfluencers = mesh.morphTargetManager ? PrepareDefinesAndAttributesForMorphTargets(
          mesh.morphTargetManager,
          defines,
          attribs,
          mesh,
          true,
          // usePositionMorph
          true,
          // useNormalMorph
          false,
          // useTangentMorph
          uv1,
          // useUVMorph
          uv2,
          // useUV2Morph
          color
          // useColorMorph
        ) : 0;
        if (useInstances) {
          defines.push("#define INSTANCES");
          PushAttributesForInstances(attribs);
          if (subMesh.getRenderingMesh().hasThinInstances) {
            defines.push("#define THIN_INSTANCES");
          }
        }
        const bvaManager = mesh.bakedVertexAnimationManager;
        if (bvaManager && bvaManager.isEnabled) {
          defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
          if (useInstances) {
            attribs.push("bakedVertexAnimationSettingsInstanced");
          }
        }
        const drawWrapper = subMesh._getDrawWrapper(renderPassId, true);
        const cachedDefines = drawWrapper.defines;
        const join = defines.join("\n");
        if (cachedDefines !== join) {
          const uniforms = [
            "world",
            "mBones",
            "viewProjection",
            "diffuseMatrix",
            "offset",
            "color",
            "logarithmicDepthConstant",
            "morphTargetInfluences",
            "boneTextureWidth",
            "morphTargetCount",
            "morphTargetTextureInfo",
            "morphTargetTextureIndices",
            "bakedVertexAnimationSettings",
            "bakedVertexAnimationTextureSizeInverted",
            "bakedVertexAnimationTime",
            "bakedVertexAnimationTexture"
          ];
          const samplers = ["diffuseSampler", "boneSampler", "morphTargets", "bakedVertexAnimationTexture"];
          AddClipPlaneUniforms(uniforms);
          drawWrapper.setEffect(this.scene.getEngine().createEffect("outline", {
            attributes: attribs,
            uniformsNames: uniforms,
            uniformBuffersNames: [],
            samplers,
            defines: join,
            fallbacks,
            onCompiled: null,
            onError: null,
            indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },
            shaderLanguage: this._shaderLanguage,
            extraInitializationsAsync: async () => {
              if (this._shaderLanguage === 1) {
                await Promise.all([import("./outline.fragment-JEQ53MUD.js"), import("./outline.vertex-4LICRXCS.js")]);
              } else {
                await Promise.all([import("./outline.fragment-6TUT732Y.js"), import("./outline.vertex-EINSBFYE.js")]);
              }
            }
          }, this.scene.getEngine()), join);
        }
        return drawWrapper.effect.isReady();
      }
      _beforeRenderingMesh(mesh, subMesh, batch) {
        if (!this.enabled) {
          return;
        }
        this._savedDepthWrite = this._engine.getDepthWrite();
        if (mesh.renderOutline) {
          const material = subMesh.getMaterial();
          if (material && material.needAlphaBlendingForMesh(mesh)) {
            this._engine.cacheStencilState();
            this._engine.setDepthWrite(false);
            this._engine.setColorWrite(false);
            this._engine.setStencilBuffer(true);
            this._engine.setStencilOperationPass(7681);
            this._engine.setStencilFunction(519);
            this._engine.setStencilMask(_OutlineRenderer._StencilReference);
            this._engine.setStencilFunctionReference(_OutlineRenderer._StencilReference);
            this._engine.stencilStateComposer.useStencilGlobalOnly = true;
            this.render(
              subMesh,
              batch,
              /* This sets offset to 0 */
              true,
              this._passIdForDrawWrapper[1]
            );
            this._engine.setColorWrite(true);
            this._engine.setStencilFunction(517);
          }
          this._engine.setDepthWrite(false);
          this.render(subMesh, batch, false, this._passIdForDrawWrapper[0]);
          this._engine.setDepthWrite(this._savedDepthWrite);
          if (material && material.needAlphaBlendingForMesh(mesh)) {
            this._engine.stencilStateComposer.useStencilGlobalOnly = false;
            this._engine.restoreStencilState();
          }
        }
      }
      _afterRenderingMesh(mesh, subMesh, batch) {
        if (!this.enabled) {
          return;
        }
        if (mesh.renderOverlay) {
          const currentMode = this._engine.getAlphaMode();
          const alphaBlendState = this._engine.alphaState.alphaBlend;
          this._engine.setAlphaMode(2);
          this.render(subMesh, batch, true, this._passIdForDrawWrapper[3]);
          this._engine.setAlphaMode(currentMode);
          this._engine.setDepthWrite(this._savedDepthWrite);
          this._engine.alphaState.setAlphaBlend(alphaBlendState);
        }
        if (mesh.renderOutline && this._savedDepthWrite) {
          this._engine.setDepthWrite(true);
          this._engine.setColorWrite(false);
          this.render(subMesh, batch, false, this._passIdForDrawWrapper[2]);
          this._engine.setColorWrite(true);
        }
      }
    };
    OutlineRenderer._StencilReference = 4;
  }
});

export {
  AnimationPropertiesOverride,
  init_animationPropertiesOverride,
  AbstractAssetContainer,
  KeepAssets,
  InstantiatedEntries,
  AssetContainer,
  init_assetContainer,
  Sound,
  init_sound,
  AddParser,
  GetParser,
  AddIndividualParser,
  GetIndividualParser,
  Parse,
  init_babylonFileParser_function,
  Skeleton,
  init_skeleton,
  AutoRotationBehavior,
  init_autoRotationBehavior,
  BouncingBehavior,
  init_bouncingBehavior,
  FramingBehavior,
  init_framingBehavior,
  InterpolatingBehavior,
  init_interpolatingBehavior,
  PickingCustomization,
  Ray,
  CreatePickingRay,
  CreatePickingRayToRef,
  CreatePickingRayInCameraSpace,
  CreatePickingRayInCameraSpaceToRef,
  PickWithBoundingInfo,
  Pick,
  PickWithRay,
  MultiPick,
  MultiPickWithRay,
  GetForwardRay,
  GetForwardRayToRef,
  AddRayExtensions,
  init_ray,
  PivotTools,
  init_pivotTools,
  CreatePlaneVertexData,
  CreatePlane,
  PlaneBuilder,
  init_planeBuilder,
  PointerDragBehavior,
  init_pointerDragBehavior,
  BaseSixDofDragBehavior,
  init_baseSixDofDragBehavior,
  SixDofDragBehavior,
  init_sixDofDragBehavior,
  BaseCameraMouseWheelInput,
  init_BaseCameraMouseWheelInput,
  BaseCameraPointersInput,
  init_BaseCameraPointersInput,
  CameraInputTypes,
  CameraInputsManager,
  init_cameraInputsManager,
  ArcRotateCameraKeyboardMoveInput,
  init_arcRotateCameraKeyboardMoveInput,
  ArcRotateCameraMouseWheelInput,
  init_arcRotateCameraMouseWheelInput,
  ArcRotateCameraPointersInput,
  init_arcRotateCameraPointersInput,
  ArcRotateCameraInputsManager,
  init_arcRotateCameraInputsManager,
  FollowCameraKeyboardMoveInput,
  init_followCameraKeyboardMoveInput,
  FollowCameraMouseWheelInput,
  init_followCameraMouseWheelInput,
  FollowCameraPointersInput,
  init_followCameraPointersInput,
  FreeCameraKeyboardMoveInput,
  init_freeCameraKeyboardMoveInput,
  FreeCameraMouseInput,
  init_freeCameraMouseInput,
  FreeCameraMouseWheelInput,
  init_freeCameraMouseWheelInput,
  FreeCameraTouchInput,
  init_freeCameraTouchInput,
  FreeCameraInputsManager,
  init_freeCameraInputsManager,
  GeospatialCameraPointersInput,
  init_geospatialCameraPointersInput,
  GeospatialCameraMouseWheelInput,
  init_geospatialCameraMouseWheelInput,
  GeospatialCameraKeyboardInput,
  init_geospatialCameraKeyboardInput,
  FreeCamera,
  init_freeCamera,
  ComputeAlpha,
  ComputeBeta,
  ArcRotateCamera,
  init_arcRotateCamera,
  FollowCameraInputsManager,
  init_followCameraInputsManager,
  FollowCamera,
  ArcFollowCamera,
  init_followCamera,
  init_engine_dynamicTexture,
  DynamicTexture,
  init_dynamicTexture,
  GroundMesh,
  init_groundMesh,
  CreateGroundVertexData,
  CreateTiledGroundVertexData,
  CreateGroundFromHeightMapVertexData,
  CreateGround,
  CreateTiledGround,
  CreateGroundFromHeightMap,
  GroundBuilder,
  init_groundBuilder,
  CreateTorusVertexData,
  CreateTorus,
  TorusBuilder,
  init_torusBuilder,
  GeospatialCamera,
  ComputeLookAtFromYawPitchToRef,
  ComputeYawPitchFromLookAtToRef,
  init_geospatialCamera,
  CreateCylinderVertexData,
  CreateCylinder,
  CylinderBuilder,
  init_cylinderBuilder,
  HemisphericLight,
  init_hemisphericLight,
  UtilityLayerRenderer,
  init_utilityLayerRenderer,
  GizmoAnchorPoint,
  GizmoCoordinatesMode,
  Gizmo,
  init_gizmo,
  AxisDragGizmo,
  init_axisDragGizmo,
  AxesViewer,
  init_axesViewer,
  DebugLayerTab,
  DebugLayer,
  init_debugLayer,
  CreateBoxVertexData,
  CreateSegmentedBoxVertexData,
  CreateBox,
  BoxBuilder,
  init_boxBuilder,
  CreateSphereVertexData,
  CreateSphere,
  SphereBuilder,
  init_sphereBuilder,
  PhysicsJoint,
  DistanceJoint,
  MotorEnabledJoint,
  HingeJoint,
  Hinge2Joint,
  init_physicsJoint,
  PhysicsImpostor,
  init_physicsImpostor,
  CreateCapsuleVertexData,
  CreateCapsule,
  CapsuleBuilder,
  init_capsuleBuilder,
  CreateRibbonVertexData,
  CreateRibbon,
  RibbonBuilder,
  init_ribbonBuilder,
  CreateDiscVertexData,
  CreateDisc,
  DiscBuilder,
  init_discBuilder,
  CreateTiledPlaneVertexData,
  CreateTiledPlane,
  TiledPlaneBuilder,
  init_tiledPlaneBuilder,
  CreateTiledBoxVertexData,
  CreateTiledBox,
  TiledBoxBuilder,
  init_tiledBoxBuilder,
  CreateTorusKnotVertexData,
  CreateTorusKnot,
  TorusKnotBuilder,
  init_torusKnotBuilder,
  CreateLineSystemVertexData,
  CreateDashedLinesVertexData,
  CreateLineSystem,
  CreateLines,
  CreateDashedLines,
  LinesBuilder,
  init_linesBuilder,
  ExtrudeShape,
  ExtrudeShapeCustom,
  ShapeBuilder,
  init_shapeBuilder,
  CreateLathe,
  LatheBuilder,
  init_latheBuilder,
  CreateTube,
  TubeBuilder,
  init_tubeBuilder,
  CreatePolyhedronVertexData,
  CreatePolyhedron,
  PolyhedronBuilder,
  init_polyhedronBuilder,
  CreateIcoSphereVertexData,
  CreateIcoSphere,
  IcoSphereBuilder,
  init_icoSphereBuilder,
  CreateDecal,
  DecalBuilder,
  init_decalBuilder,
  _PrimaryIsoTriangle,
  PolyhedronData,
  GeodesicData,
  init_geodesicMesh,
  CreateGeodesic,
  init_geodesicBuilder,
  GoldbergMesh,
  init_goldbergMesh,
  CreateGoldbergVertexData,
  CreateGoldberg,
  init_goldbergBuilder,
  MeshBuilder,
  init_meshBuilder,
  PhysicsViewer,
  init_physicsViewer,
  SkeletonViewer,
  init_skeletonViewer,
  backbufferColorTextureHandle,
  backbufferDepthStencilTextureHandle,
  init_frameGraphTypes,
  FrameGraphPass,
  init_pass,
  FrameGraphObjectListPass,
  init_objectListPass,
  FrameGraphRenderPass,
  init_renderPass,
  FrameGraphTask,
  init_frameGraphTask,
  FrameGraphTaskMultiRenderTarget,
  init_frameGraphTaskMultiRenderTarget,
  MultiRenderTarget,
  init_multiRenderTarget,
  ThinDepthPeelingRenderer,
  init_thinDepthPeelingRenderer,
  FrameGraphRenderTarget,
  init_frameGraphRenderTarget,
  FrameGraphObjectRendererTask,
  init_objectRendererTask,
  FrameGraphUtilityLayerRendererTask,
  init_utilityLayerRendererTask,
  FindMainCamera,
  FindMainObjectRenderer,
  CreateUtilityLayerRenderer,
  FrameGraphUtils,
  init_frameGraphUtils,
  DirectionalLightFrustumViewer,
  init_directionalLightFrustumViewer,
  _TimeToken,
  init_timeToken,
  init_abstractEngine_timeQuery,
  init_engine_query,
  _forceTransformFeedbackToBundle,
  init_engine_transformFeedback,
  init_engine_videoTexture,
  ConversionMode,
  CopyTextureToTexture,
  init_copyTextureToTexture,
  FrameGraphContext,
  init_frameGraphContext,
  FrameGraphRenderContext,
  init_frameGraphRenderContext,
  textureSizeIsObject,
  getDimensionsFromTextureSize,
  init_textureCreationOptions,
  FrameGraphTextureManager,
  init_frameGraphTextureManager,
  FrameGraph,
  init_frameGraph,
  PropertyTypeForEdition,
  editableInPropertyPage,
  init_nodeDecorator,
  ShadowLight,
  init_shadowLight,
  DirectionalLight,
  init_directionalLight,
  ThinGlowBlurPostProcess,
  ThinEffectLayer,
  init_thinEffectLayer,
  ThinBlurPostProcess,
  init_thinBlurPostProcess,
  ThinGlowLayer,
  init_thinGlowLayer,
  FrameGraphPostProcessTask,
  init_postProcessTask,
  ThinBloomMergePostProcess,
  init_thinBloomMergePostProcess,
  ThinExtractHighlightsPostProcess,
  init_thinExtractHighlightsPostProcess,
  ThinBloomEffect,
  init_thinBloomEffect,
  ThinChromaticAberrationPostProcess,
  init_thinChromaticAberrationPostProcess,
  ThinCircleOfConfusionPostProcess,
  init_thinCircleOfConfusionPostProcess,
  ThinDepthOfFieldMergePostProcess,
  init_thinDepthOfFieldMergePostProcess,
  ThinDepthOfFieldBlurPostProcess,
  init_thinDepthOfFieldBlurPostProcess,
  ThinDepthOfFieldEffectBlurLevel,
  ThinDepthOfFieldEffect,
  init_thinDepthOfFieldEffect,
  ThinFXAAPostProcess,
  init_thinFXAAPostProcess,
  FrameGraphFXAATask,
  init_fxaaTask,
  ThinGrainPostProcess,
  init_thinGrainPostProcess,
  ThinImageProcessingPostProcess,
  init_thinImageProcessingPostProcess,
  FrameGraphPassTask,
  FrameGraphPassCubeTask,
  init_passTask,
  ThinSharpenPostProcess,
  init_thinSharpenPostProcess,
  ThinSSAO2PostProcess,
  init_thinSSAO2PostProcess,
  ThinSSAO2BlurPostProcess,
  init_thinSSAO2BlurPostProcess,
  ThinSSAO2RenderingPipeline,
  init_thinSSAO2RenderingPipeline,
  ThinSSRPostProcess,
  init_thinSSRPostProcess,
  ThinSSRBlurPostProcess,
  init_thinSSRBlurPostProcess,
  ThinSSRRenderingPipeline,
  init_thinSSRRenderingPipeline,
  BlurPostProcess,
  init_blurPostProcess,
  ShadowGenerator,
  init_shadowGenerator,
  DepthRenderer,
  init_depthRenderer,
  ThinMinMaxReducer,
  init_thinMinMaxReducer,
  MinMaxReducer,
  init_minMaxReducer,
  DepthReducer,
  init_depthReducer,
  CascadedShadowGenerator,
  init_cascadedShadowGenerator,
  AxisScaleGizmo,
  init_axisScaleGizmo,
  DragOperation,
  BoundingBoxGizmo,
  init_boundingBoxGizmo,
  PlaneRotationGizmo,
  init_planeRotationGizmo,
  RotationGizmo,
  init_rotationGizmo,
  PlaneDragGizmo,
  init_planeDragGizmo,
  PositionGizmo,
  init_positionGizmo,
  ScaleGizmo,
  init_scaleGizmo,
  GizmoManager,
  init_gizmoManager,
  CreateHemisphere,
  HemisphereBuilder,
  init_hemisphereBuilder,
  SpotLight,
  init_spotLight,
  LightGizmo,
  init_lightGizmo,
  CameraGizmo,
  init_cameraGizmo,
  CubeTexture,
  init_cubeTexture,
  SceneLoaderAnimationGroupLoadingMode,
  RegisterSceneLoaderPlugin,
  registerSceneLoaderPlugin,
  GetRegisteredSceneLoaderPluginMetadata,
  ImportMeshAsync,
  LoadSceneAsync,
  loadSceneAsync,
  AppendSceneAsync,
  appendSceneAsync,
  LoadAssetContainerAsync,
  loadAssetContainerAsync,
  ImportAnimationsAsync,
  importAnimationsAsync,
  SceneLoader,
  init_sceneLoader,
  NodeMaterialBlockConnectionPointTypes,
  init_nodeMaterialBlockConnectionPointTypes,
  NodeMaterialBlockTargets,
  init_nodeMaterialBlockTargets,
  NodeMaterialConnectionPointCompatibilityStates,
  NodeMaterialConnectionPointDirection,
  NodeMaterialConnectionPoint,
  init_nodeMaterialBlockConnectionPoint,
  NodeMaterialBlock,
  init_nodeMaterialBlock,
  FragmentOutputBlockColorSpace,
  FragmentOutputBlock,
  init_fragmentOutputBlock,
  NodeMaterialModes,
  init_nodeMaterialModes,
  NodeMaterialSystemValues,
  init_nodeMaterialSystemValues,
  AnimatedInputBlockTypes,
  init_animatedInputBlockTypes,
  InputBlock,
  init_inputBlock,
  ScreenSizeBlock,
  init_screenSizeBlock,
  SfeModeDefine,
  SmartFilterFragmentOutputBlock,
  init_smartFilterFragmentOutputBlock,
  TransformBlock,
  init_transformBlock,
  VertexOutputBlock,
  init_vertexOutputBlock,
  CurrentScreenBlock,
  init_currentScreenBlock,
  ParticleTextureBlock,
  init_particleTextureBlock,
  ParticleRampGradientBlock,
  init_particleRampGradientBlock,
  ParticleBlendMultiplyBlock,
  init_particleBlendMultiplyBlock,
  VectorMergerBlock,
  init_vectorMergerBlock,
  RemapBlock,
  init_remapBlock,
  BaseMathBlock,
  init_baseMathBlock,
  MultiplyBlock,
  init_multiplyBlock,
  BaseParticleSystem,
  init_baseParticleSystem,
  ColorSplitterBlock,
  init_colorSplitterBlock,
  TrigonometryBlockOperations,
  TrigonometryBlock,
  init_trigonometryBlock,
  NodeMaterialDefines,
  NodeMaterial,
  init_nodeMaterial,
  PhysicsConstraintAxisLimitMode,
  PhysicsConstraintAxis,
  PhysicsConstraintType,
  PhysicsShapeType,
  PhysicsConstraintMotorType,
  PhysicsEventType,
  PhysicsMotionType,
  PhysicsPrestepType,
  PhysicsActivationControl,
  init_IPhysicsEnginePlugin,
  EngineInstrumentation,
  init_engineInstrumentation,
  SceneInstrumentation,
  init_sceneInstrumentation,
  EffectLayer,
  init_effectLayer,
  EffectLayerSceneComponent,
  init_effectLayerSceneComponent,
  GlowLayer,
  init_glowLayer,
  ShadowGeneratorSceneComponent,
  init_shadowGeneratorSceneComponent,
  PointLight,
  init_pointLight,
  AreaLight,
  init_areaLight,
  RectAreaLight,
  init_rectAreaLight,
  init_thinInstanceMesh,
  ClusteredLightContainer,
  init_clusteredLightContainer,
  IblCdfGenerator,
  init_iblCdfGenerator,
  RawTexture2DArray,
  init_rawTexture2DArray,
  MorphTargetManager,
  init_morphTargetManager,
  CastingResult,
  init_castingResult,
  PhysicsRaycastResult,
  init_physicsRaycastResult,
  PhysicsEngine,
  init_physicsEngine,
  ReflectionProbe,
  init_reflectionProbe,
  Sprite,
  init_sprite,
  SpriteSceneComponent,
  init_spriteSceneComponent,
  SpriteManager,
  init_spriteManager,
  HtmlElementTexture,
  init_htmlElementTexture,
  CustomProceduralTexture,
  init_customProceduralTexture,
  RawTexture3D,
  init_rawTexture3D,
  ShadowDepthWrapper,
  init_shadowDepthWrapper,
  GaussianSplattingMaterial,
  init_gaussianSplattingMaterial,
  GradientBlockColorStep,
  GradientBlock,
  init_gradientBlock,
  ThinMatrix,
  init_thinMath_matrix,
  GaussianSplattingMesh,
  init_gaussianSplattingMesh,
  Deferred,
  init_deferred,
  FilesInput,
  init_filesInput,
  SceneSerializer,
  init_sceneSerializer,
  VideoRecorder,
  init_videoRecorder,
  FxaaPostProcess,
  init_fxaaPostProcess,
  CreateScreenshot,
  CreateScreenshotAsync,
  CreateScreenshotWithResizeAsync,
  CreateScreenshotUsingRenderTarget,
  CreateScreenshotUsingRenderTargetAsync,
  CreateScreenshotForFrameGraphAsync,
  ScreenshotTools,
  init_screenshotTools,
  ColorGradient,
  Color3Gradient,
  FactorGradient,
  GradientHelper,
  init_gradients,
  DataReader,
  init_dataReader,
  DataStorage,
  init_dataStorage,
  Particle,
  init_particle,
  BoxParticleEmitter,
  init_boxParticleEmitter,
  _ConnectAtTheEnd,
  init_executionQueue,
  SubEmitterType,
  SubEmitter,
  init_subEmitter,
  MeshParticleEmitter,
  init_meshParticleEmitter,
  EmptyGeneratorFunc,
  CustomParticleEmitter,
  init_customParticleEmitter,
  PointParticleEmitter,
  init_pointParticleEmitter,
  HemisphericParticleEmitter,
  init_hemisphericParticleEmitter,
  SphereParticleEmitter,
  SphereDirectedParticleEmitter,
  init_sphereParticleEmitter,
  CylinderParticleEmitter,
  CylinderDirectedParticleEmitter,
  init_cylinderParticleEmitter,
  ConeParticleEmitter,
  ConeDirectedParticleEmitter,
  init_coneParticleEmitter,
  Attractor,
  init_attractor,
  ParticleSystem,
  init_particleSystem,
  SceneRecorder,
  init_sceneRecorder,
  PressureObserverWrapper,
  init_pressureObserverWrapper,
  DynamicFloat32Array,
  init_dynamicFloat32Array,
  PerformanceViewerCollector,
  init_performanceViewerCollector,
  PerfCollectionStrategy,
  init_performanceViewerCollectionStrategies,
  init_performanceViewerSceneExtension,
  captureEquirectangularFromScene,
  init_equirectangularCapture,
  AsyncLock,
  init_asyncLock,
  Lazy,
  init_lazy,
  GPUParticleSystem,
  init_gpuParticleSystem,
  ParticleSystemSet,
  init_particleSystemSet,
  ParticleHelper,
  init_particleHelper,
  FlowMap,
  init_flowMap,
  NodeParticleBlockConnectionPointTypes,
  init_nodeParticleBlockConnectionPointTypes,
  NodeParticleConnectionPointCompatibilityStates,
  NodeParticleConnectionPointDirection,
  NodeParticleConnectionPoint,
  init_nodeParticleBlockConnectionPoint,
  NodeParticleBlock,
  init_nodeParticleBlock,
  NodeParticleContextualSources,
  init_nodeParticleContextualSources,
  NodeParticleSystemSources,
  init_nodeParticleSystemSources,
  NodeParticleBuildState,
  init_nodeParticleBuildState,
  _TriggerSubEmitter,
  init_triggerTools,
  ParticleGradientBlock,
  init_particleGradientBlock,
  SystemBlock,
  init_systemBlock,
  ParticleInputBlock,
  init_particleInputBlock,
  ParticleTextureSourceBlock,
  init_particleSourceTextureBlock,
  UpdatePositionBlock,
  init_updatePositionBlock,
  ParticleMathBlockOperations,
  ParticleMathBlock,
  init_particleMathBlock,
  BoxShapeBlock,
  init_boxShapeBlock,
  CreateParticleBlock,
  init_createParticleBlock,
  NodeParticleSystemSet,
  init_nodeParticleSystemSet,
  ParticleConverterBlock,
  init_particleConverterBlock,
  ParticleFloatToIntBlockOperations,
  ParticleFloatToIntBlock,
  init_particleFloatToIntBlock,
  ParticleGradientValueBlock,
  init_particleGradientValueBlock,
  ParticleRandomBlockLocks,
  ParticleRandomBlock,
  init_particleRandomBlock,
  ParticleVectorLengthBlock,
  init_particleVectorLengthBlock,
  ParticleConditionBlockTests,
  ParticleConditionBlock,
  init_particleConditionBlock,
  ConeShapeBlock,
  init_coneShapeBlock,
  CylinderShapeBlock,
  init_cylinderShapeBlock,
  CustomShapeBlock,
  init_customShapeBlock,
  MeshShapeBlock,
  init_meshShapeBlock,
  PointShapeBlock,
  init_pointShapeBlock,
  SetupSpriteSheetBlock,
  init_setupSpriteSheetBlock,
  SphereShapeBlock,
  init_sphereShapeBlock,
  UpdateAngleBlock,
  init_updateAngleBlock,
  BasicSpriteUpdateBlock,
  init_basicSpriteUpdateBlock,
  UpdateAttractorBlock,
  init_updateAttractorBlock,
  UpdateColorBlock,
  init_updateColorBlock,
  UpdateDirectionBlock,
  init_updateDirectionBlock,
  UpdateFlowMapBlock,
  init_updateFlowMapBlock,
  UpdateNoiseBlock,
  init_updateNoiseBlock,
  UpdateSizeBlock,
  init_updateSizeBlock,
  UpdateRemapBlock,
  init_updateRemapBlock,
  ConvertToNodeParticleSystemSetAsync,
  init_nodeParticleSystemSet_helper,
  PhysicsEngine2,
  init_physicsEngine2,
  init_joinedPhysicsEngineComponent,
  init_physicsEngineComponent,
  PostProcessRenderEffect,
  init_postProcessRenderEffect,
  ExtractHighlightsPostProcess,
  init_extractHighlightsPostProcess,
  BloomMergePostProcess,
  init_bloomMergePostProcess,
  BloomEffect,
  init_bloomEffect,
  ChromaticAberrationPostProcess,
  init_chromaticAberrationPostProcess,
  CircleOfConfusionPostProcess,
  init_circleOfConfusionPostProcess,
  DepthOfFieldBlurPostProcess,
  init_depthOfFieldBlurPostProcess,
  DepthOfFieldMergePostProcess,
  init_depthOfFieldMergePostProcess,
  DepthOfFieldEffectBlurLevel,
  DepthOfFieldEffect,
  init_depthOfFieldEffect,
  GrainPostProcess,
  init_grainPostProcess,
  ImageProcessingPostProcess,
  init_imageProcessingPostProcess,
  GeometryBufferRenderer,
  init_geometryBufferRenderer,
  GeometryBufferRendererSceneComponent,
  init_geometryBufferRendererSceneComponent,
  SharpenPostProcess,
  init_sharpenPostProcess,
  PostProcessRenderPipeline,
  init_postProcessRenderPipeline,
  PostProcessRenderPipelineManager,
  init_postProcessRenderPipelineManager,
  PostProcessRenderPipelineManagerSceneComponent,
  init_postProcessRenderPipelineManagerSceneComponent,
  DefaultRenderingPipeline,
  init_defaultRenderingPipeline,
  LensRenderingPipeline,
  init_lensRenderingPipeline,
  SSAO2RenderingPipeline,
  init_ssao2RenderingPipeline,
  SSAORenderingPipeline,
  init_ssaoRenderingPipeline,
  SSRRenderingPipeline,
  init_ssrRenderingPipeline,
  BoundingBoxRenderer,
  init_boundingBoxRenderer,
  EdgesRenderer,
  LineEdgesRenderer,
  init_edgesRenderer,
  IblCdfGeneratorSceneComponent,
  init_iblCdfGeneratorSceneComponent,
  IblShadowsRenderPipeline,
  init_iblShadowsRenderPipeline,
  OutlineRenderer,
  init_outlineRenderer
};
//# sourceMappingURL=chunk-YERFS6AN.js.map
