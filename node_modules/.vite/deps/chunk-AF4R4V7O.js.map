{
  "version": 3,
  "sources": ["../../../dev/core/src/Bones/bone.ts", "../../../dev/core/src/Animations/runtimeAnimation.ts", "../../../dev/core/src/Animations/animatable.core.ts", "../../../dev/core/src/Animations/animatable.ts", "../../../dev/core/src/Animations/animationGroup.ts"],
  "sourcesContent": ["import type { Skeleton } from \"./skeleton\";\r\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Node } from \"../node\";\r\nimport { Space } from \"../Maths/math.axis\";\r\n\r\nimport type { Animation } from \"../Animations/animation\";\r\nimport type { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\n\r\n/**\r\n * Class used to store bone information\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\r\n */\r\nexport class Bone extends Node {\r\n    private static _TmpVecs: Vector3[] = BuildArray(2, Vector3.Zero);\r\n    private static _TmpQuat = Quaternion.Identity();\r\n    private static _TmpMats: Matrix[] = BuildArray(5, Matrix.Identity);\r\n\r\n    /**\r\n     * Gets the list of child bones\r\n     */\r\n    public children: Bone[] = [];\r\n\r\n    /** Gets the animations associated with this bone */\r\n    public override animations: Animation[] = [];\r\n\r\n    /**\r\n     * Gets or sets bone length\r\n     */\r\n    public length: number;\r\n\r\n    /**\r\n     * @internal Internal only\r\n     * Set this value to map this bone to a different index in the transform matrices\r\n     * Set this value to -1 to exclude the bone from the transform matrices\r\n     */\r\n    public _index: Nullable<number> = null;\r\n\r\n    private _skeleton: Skeleton;\r\n    private _localMatrix: Matrix; // transformation of the bone, in local space\r\n    private _absoluteMatrix: Matrix; // transformation of the bone, in world space (relative to the skeleton root)\r\n    private _bindMatrix: Matrix; // the bind matrix, in local space\r\n    private _absoluteBindMatrix: Matrix; // the bind matrix, in world space (relative to the skeleton root)\r\n    private _absoluteInverseBindMatrix: Matrix; // the inverse of the bind matrix, in world space (relative to the skeleton root)\r\n    private _finalMatrix: Matrix; // the final matrix used to transform vertices of the mesh according to the bone, in world space (relative to the skeleton root). It is the multiplication of _absoluteInverseBindMatrix with _absoluteMatrix.\r\n    private _restMatrix: Matrix; // a matrix for the exclusive use of the end user (not used internally by the framework), in local space\r\n    private _scalingDeterminant = 1;\r\n\r\n    private _localScaling: Vector3;\r\n    private _localRotation: Quaternion;\r\n    private _localPosition: Vector3;\r\n    private _needToDecompose = true;\r\n    private _needToCompose = false;\r\n\r\n    /** @internal */\r\n    public _linkedTransformNode: Nullable<TransformNode> = null;\r\n\r\n    /** @internal */\r\n    public _waitingTransformNodeId: Nullable<string> = null;\r\n\r\n    /** @internal */\r\n    get _matrix(): Matrix {\r\n        this._compose();\r\n        return this._localMatrix;\r\n    }\r\n\r\n    /** @internal */\r\n    set _matrix(value: Matrix) {\r\n        // skip if the matrices are the same\r\n        if (value.updateFlag === this._localMatrix.updateFlag && !this._needToCompose) {\r\n            return;\r\n        }\r\n\r\n        this._needToCompose = false; // in case there was a pending compose\r\n\r\n        this._localMatrix.copyFrom(value);\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    /**\r\n     * Create a new bone\r\n     * @param name defines the bone name\r\n     * @param skeleton defines the parent skeleton\r\n     * @param parentBone defines the parent (can be null if the bone is the root)\r\n     * @param localMatrix defines the local matrix (default: identity)\r\n     * @param restMatrix defines the rest matrix (default: localMatrix)\r\n     * @param bindMatrix defines the bind matrix (default: localMatrix)\r\n     * @param index defines index of the bone in the hierarchy (default: null)\r\n     */\r\n    constructor(\r\n        /**\r\n         * defines the bone name\r\n         */\r\n        public override name: string,\r\n        skeleton: Skeleton,\r\n        parentBone: Nullable<Bone> = null,\r\n        localMatrix: Nullable<Matrix> = null,\r\n        restMatrix: Nullable<Matrix> = null,\r\n        bindMatrix: Nullable<Matrix> = null,\r\n        index: Nullable<number> = null\r\n    ) {\r\n        super(name, skeleton.getScene(), false);\r\n        this._skeleton = skeleton;\r\n        this._localMatrix = localMatrix?.clone() ?? Matrix.Identity();\r\n        this._restMatrix = restMatrix ?? this._localMatrix.clone();\r\n        this._bindMatrix = bindMatrix ?? this._localMatrix.clone();\r\n        this._index = index;\r\n\r\n        this._absoluteMatrix = new Matrix();\r\n        this._absoluteBindMatrix = new Matrix();\r\n        this._absoluteInverseBindMatrix = new Matrix();\r\n        this._finalMatrix = new Matrix();\r\n\r\n        skeleton.bones.push(this);\r\n\r\n        this.setParent(parentBone, false);\r\n\r\n        this._updateAbsoluteBindMatrices();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"Bone\";\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * Gets the parent skeleton\r\n     * @returns a skeleton\r\n     */\r\n    public getSkeleton(): Skeleton {\r\n        return this._skeleton;\r\n    }\r\n\r\n    public override get parent(): Bone {\r\n        return this._parentNode as Bone;\r\n    }\r\n\r\n    /**\r\n     * Gets parent bone\r\n     * @returns a bone or null if the bone is the root of the bone hierarchy\r\n     */\r\n    public getParent(): Nullable<Bone> {\r\n        return this.parent;\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing the children of the bone\r\n     * @returns an array containing the children of the bone (can be empty if the bone has no children)\r\n     */\r\n    public override getChildren(): Array<Bone> {\r\n        return this.children;\r\n    }\r\n\r\n    /**\r\n     * Gets the node index in matrix array generated for rendering\r\n     * @returns the node index\r\n     */\r\n    public getIndex(): number {\r\n        return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;\r\n    }\r\n\r\n    public override set parent(newParent: Nullable<Bone>) {\r\n        this.setParent(newParent);\r\n    }\r\n\r\n    /**\r\n     * Sets the parent bone\r\n     * @param parent defines the parent (can be null if the bone is the root)\r\n     * @param updateAbsoluteBindMatrices defines if the absolute bind and absolute inverse bind matrices must be updated\r\n     */\r\n    public setParent(parent: Nullable<Bone>, updateAbsoluteBindMatrices: boolean = true): void {\r\n        if (this.parent === parent) {\r\n            return;\r\n        }\r\n\r\n        if (this.parent) {\r\n            const index = this.parent.children.indexOf(this);\r\n            if (index !== -1) {\r\n                this.parent.children.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        this._parentNode = parent;\r\n\r\n        if (this.parent) {\r\n            this.parent.children.push(this);\r\n        }\r\n\r\n        if (updateAbsoluteBindMatrices) {\r\n            this._updateAbsoluteBindMatrices();\r\n        }\r\n\r\n        this.markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the local matrix\r\n     * @returns the local matrix\r\n     */\r\n    public getLocalMatrix(): Matrix {\r\n        this._compose();\r\n        return this._localMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the bind matrix\r\n     * @returns the bind matrix\r\n     */\r\n    public getBindMatrix(): Matrix {\r\n        return this._bindMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the bind matrix.\r\n     * @returns the bind matrix\r\n     * @deprecated Please use getBindMatrix instead\r\n     */\r\n    public getBaseMatrix(): Matrix {\r\n        return this.getBindMatrix();\r\n    }\r\n\r\n    /**\r\n     * Gets the rest matrix\r\n     * @returns the rest matrix\r\n     */\r\n    public getRestMatrix(): Matrix {\r\n        return this._restMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the rest matrix\r\n     * @returns the rest matrix\r\n     * @deprecated Please use getRestMatrix instead\r\n     */\r\n    public getRestPose(): Matrix {\r\n        return this.getRestMatrix();\r\n    }\r\n\r\n    /**\r\n     * Sets the rest matrix\r\n     * @param matrix the local-space rest matrix to set for this bone\r\n     */\r\n    public setRestMatrix(matrix: Matrix): void {\r\n        this._restMatrix.copyFrom(matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets the rest matrix\r\n     * @param matrix the local-space rest to set for this bone\r\n     * @deprecated Please use setRestMatrix instead\r\n     */\r\n    public setRestPose(matrix: Matrix): void {\r\n        this.setRestMatrix(matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the bind matrix\r\n     * @returns the bind matrix\r\n     * @deprecated Please use getBindMatrix instead\r\n     */\r\n    public getBindPose(): Matrix {\r\n        return this.getBindMatrix();\r\n    }\r\n\r\n    /**\r\n     * Sets the bind matrix\r\n     * This will trigger a recomputation of the absolute bind and absolute inverse bind matrices for this bone and its children\r\n     * Note that the local matrix will also be set with the matrix passed in parameter!\r\n     * @param matrix the local-space bind matrix to set for this bone\r\n     */\r\n    public setBindMatrix(matrix: Matrix): void {\r\n        this.updateMatrix(matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets the bind matrix\r\n     * @param matrix the local-space bind to set for this bone\r\n     * @deprecated Please use setBindMatrix instead\r\n     */\r\n    public setBindPose(matrix: Matrix): void {\r\n        this.setBindMatrix(matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix used to store the final world transformation of the bone (ie. the matrix sent to shaders)\r\n     * @returns the final world matrix\r\n     */\r\n    public getFinalMatrix(): Matrix {\r\n        return this._finalMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the matrix used to store the final world transformation of the bone (ie. the matrix sent to shaders)\r\n     * @deprecated Please use getFinalMatrix instead\r\n     * @returns the final world matrix\r\n     */\r\n    public override getWorldMatrix(): Matrix {\r\n        return this.getFinalMatrix();\r\n    }\r\n\r\n    /**\r\n     * Sets the local matrix to the rest matrix\r\n     */\r\n    public returnToRest(): void {\r\n        if (this._linkedTransformNode) {\r\n            const localScaling = TmpVectors.Vector3[0];\r\n            const localRotation = TmpVectors.Quaternion[0];\r\n            const localPosition = TmpVectors.Vector3[1];\r\n\r\n            this.getRestMatrix().decompose(localScaling, localRotation, localPosition);\r\n\r\n            this._linkedTransformNode.position.copyFrom(localPosition);\r\n            this._linkedTransformNode.rotationQuaternion = this._linkedTransformNode.rotationQuaternion ?? Quaternion.Identity();\r\n            this._linkedTransformNode.rotationQuaternion.copyFrom(localRotation);\r\n            this._linkedTransformNode.scaling.copyFrom(localScaling);\r\n        } else {\r\n            this._matrix = this._restMatrix;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the inverse of the bind matrix, in world space (relative to the skeleton root)\r\n     * @returns the inverse bind matrix, in world space\r\n     */\r\n    public getAbsoluteInverseBindMatrix(): Matrix {\r\n        return this._absoluteInverseBindMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the inverse of the bind matrix, in world space (relative to the skeleton root)\r\n     * @returns the inverse bind matrix, in world space\r\n     * @deprecated Please use getAbsoluteInverseBindMatrix instead\r\n     */\r\n    public getInvertedAbsoluteTransform(): Matrix {\r\n        return this.getAbsoluteInverseBindMatrix();\r\n    }\r\n\r\n    /**\r\n     * Gets the bone matrix, in world space (relative to the skeleton root)\r\n     * @returns the bone matrix, in world space\r\n     */\r\n    public getAbsoluteMatrix(): Matrix {\r\n        this._skeleton.computeAbsoluteMatrices();\r\n        return this._absoluteMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the bone matrix, in world space (relative to the skeleton root)\r\n     * @returns the bone matrix, in world space\r\n     * @deprecated Please use getAbsoluteMatrix instead\r\n     */\r\n    public getAbsoluteTransform(): Matrix {\r\n        return this.getAbsoluteMatrix();\r\n    }\r\n\r\n    /**\r\n     * Links with the given transform node.\r\n     * The local matrix of this bone is overwritten by the transform of the node every frame.\r\n     * @param transformNode defines the transform node to link to\r\n     */\r\n    public linkTransformNode(transformNode: Nullable<TransformNode>): void {\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode--;\r\n        }\r\n\r\n        this._linkedTransformNode = transformNode;\r\n\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode++;\r\n        }\r\n    }\r\n\r\n    // Properties (matches TransformNode properties)\r\n\r\n    /**\r\n     * Gets the node used to drive the bone's transformation\r\n     * @returns a transform node or null\r\n     */\r\n    public getTransformNode() {\r\n        return this._linkedTransformNode;\r\n    }\r\n\r\n    /** Gets or sets current position (in local space) */\r\n    public get position(): Vector3 {\r\n        this._decompose();\r\n        return this._localPosition;\r\n    }\r\n\r\n    public set position(newPosition: Vector3) {\r\n        this._decompose();\r\n        this._localPosition.copyFrom(newPosition);\r\n\r\n        this._markAsDirtyAndCompose();\r\n    }\r\n\r\n    /** Gets or sets current rotation (in local space) */\r\n    public get rotation(): Vector3 {\r\n        return this.getRotation();\r\n    }\r\n\r\n    public set rotation(newRotation: Vector3) {\r\n        this.setRotation(newRotation);\r\n    }\r\n\r\n    /** Gets or sets current rotation quaternion (in local space) */\r\n    public get rotationQuaternion() {\r\n        this._decompose();\r\n        return this._localRotation;\r\n    }\r\n\r\n    public set rotationQuaternion(newRotation: Quaternion) {\r\n        this.setRotationQuaternion(newRotation);\r\n    }\r\n\r\n    /** Gets or sets current scaling (in local space) */\r\n    public get scaling(): Vector3 {\r\n        return this.getScale();\r\n    }\r\n\r\n    public set scaling(newScaling: Vector3) {\r\n        this.setScale(newScaling);\r\n    }\r\n\r\n    /**\r\n     * Gets the animation properties override\r\n     */\r\n    public override get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        return this._skeleton.animationPropertiesOverride;\r\n    }\r\n\r\n    // Methods\r\n    private _decompose() {\r\n        if (!this._needToDecompose) {\r\n            return;\r\n        }\r\n\r\n        this._needToDecompose = false;\r\n\r\n        if (!this._localScaling) {\r\n            this._localScaling = Vector3.Zero();\r\n            this._localRotation = Quaternion.Zero();\r\n            this._localPosition = Vector3.Zero();\r\n        }\r\n        this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);\r\n    }\r\n\r\n    private _compose() {\r\n        if (!this._needToCompose) {\r\n            return;\r\n        }\r\n\r\n        if (!this._localScaling) {\r\n            this._needToCompose = false;\r\n            return;\r\n        }\r\n\r\n        this._needToCompose = false;\r\n        Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);\r\n    }\r\n\r\n    /**\r\n     * Update the bind (and optionally the local) matrix\r\n     * @param bindMatrix defines the new matrix to set to the bind/local matrix, in local space\r\n     * @param updateAbsoluteBindMatrices defines if the absolute bind and absolute inverse bind matrices must be recomputed (default: true)\r\n     * @param updateLocalMatrix defines if the local matrix should also be updated with the matrix passed in parameter (default: true)\r\n     */\r\n    public updateMatrix(bindMatrix: Matrix, updateAbsoluteBindMatrices = true, updateLocalMatrix = true): void {\r\n        this._bindMatrix.copyFrom(bindMatrix);\r\n\r\n        if (updateAbsoluteBindMatrices) {\r\n            this._updateAbsoluteBindMatrices();\r\n        }\r\n\r\n        if (updateLocalMatrix) {\r\n            this._matrix = bindMatrix;\r\n        } else {\r\n            this.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateAbsoluteBindMatrices(bindMatrix?: Matrix, updateChildren = true): void {\r\n        if (!bindMatrix) {\r\n            bindMatrix = this._bindMatrix;\r\n        }\r\n\r\n        if (this.parent) {\r\n            bindMatrix.multiplyToRef(this.parent._absoluteBindMatrix, this._absoluteBindMatrix);\r\n        } else {\r\n            this._absoluteBindMatrix.copyFrom(bindMatrix);\r\n        }\r\n\r\n        this._absoluteBindMatrix.invertToRef(this._absoluteInverseBindMatrix);\r\n\r\n        if (updateChildren) {\r\n            for (let index = 0; index < this.children.length; index++) {\r\n                this.children[index]._updateAbsoluteBindMatrices();\r\n            }\r\n        }\r\n\r\n        this._scalingDeterminant = this._absoluteBindMatrix.determinant() < 0 ? -1 : 1;\r\n    }\r\n\r\n    /**\r\n     * Flag the bone as dirty (Forcing it to update everything)\r\n     * @returns this bone\r\n     */\r\n    public override markAsDirty(): Bone {\r\n        this._currentRenderId++;\r\n        this._childUpdateId++;\r\n        this._skeleton._markAsDirty();\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _markAsDirtyAndCompose() {\r\n        this.markAsDirty();\r\n        this._needToCompose = true;\r\n    }\r\n\r\n    private _markAsDirtyAndDecompose() {\r\n        this.markAsDirty();\r\n        this._needToDecompose = true;\r\n    }\r\n\r\n    private _updatePosition(vec: Vector3, space = Space.LOCAL, tNode?: TransformNode, translationMode = true): void {\r\n        const lm = this.getLocalMatrix();\r\n\r\n        if (space == Space.LOCAL) {\r\n            if (translationMode) {\r\n                lm.addAtIndex(12, vec.x);\r\n                lm.addAtIndex(13, vec.y);\r\n                lm.addAtIndex(14, vec.z);\r\n            } else {\r\n                lm.setTranslationFromFloats(vec.x, vec.y, vec.z);\r\n            }\r\n        } else {\r\n            const tmat = Bone._TmpMats[0];\r\n            const tvec = Bone._TmpVecs[0];\r\n\r\n            if (this.parent) {\r\n                tmat.copyFrom(this.parent.getAbsoluteMatrix());\r\n                if (tNode) {\r\n                    tmat.multiplyToRef(tNode.getWorldMatrix(), tmat);\r\n                }\r\n            } else {\r\n                Matrix.IdentityToRef(tmat);\r\n            }\r\n\r\n            if (translationMode) {\r\n                tmat.setTranslationFromFloats(0, 0, 0);\r\n            }\r\n            tmat.invert();\r\n            Vector3.TransformCoordinatesToRef(vec, tmat, tvec);\r\n\r\n            if (translationMode) {\r\n                lm.addAtIndex(12, tvec.x);\r\n                lm.addAtIndex(13, tvec.y);\r\n                lm.addAtIndex(14, tvec.z);\r\n            } else {\r\n                lm.setTranslationFromFloats(tvec.x, tvec.y, tvec.z);\r\n            }\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    /**\r\n     * Translate the bone in local or world space\r\n     * @param vec The amount to translate the bone\r\n     * @param space The space that the translation is in (default: Space.LOCAL)\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public translate(vec: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        this._updatePosition(vec, space, tNode, true);\r\n    }\r\n\r\n    /**\r\n     * Set the position of the bone in local or world space\r\n     * @param position The position to set the bone\r\n     * @param space The space that the position is in (default: Space.LOCAL)\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setPosition(position: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        this._updatePosition(position, space, tNode, false);\r\n    }\r\n\r\n    /**\r\n     * Set the absolute position of the bone (world space)\r\n     * @param position The position to set the bone\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setAbsolutePosition(position: Vector3, tNode?: TransformNode) {\r\n        this.setPosition(position, Space.WORLD, tNode);\r\n    }\r\n\r\n    /**\r\n     * Scale the bone on the x, y and z axes (in local space)\r\n     * @param x The amount to scale the bone on the x axis\r\n     * @param y The amount to scale the bone on the y axis\r\n     * @param z The amount to scale the bone on the z axis\r\n     * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)\r\n     */\r\n    public scale(x: number, y: number, z: number, scaleChildren = false): void {\r\n        const locMat = this.getLocalMatrix();\r\n\r\n        // Apply new scaling on top of current local matrix\r\n        const scaleMat = Bone._TmpMats[0];\r\n        Matrix.ScalingToRef(x, y, z, scaleMat);\r\n        scaleMat.multiplyToRef(locMat, locMat);\r\n\r\n        // Invert scaling matrix and apply the inverse to all children\r\n        scaleMat.invert();\r\n\r\n        for (const child of this.children) {\r\n            const cm = child.getLocalMatrix();\r\n            cm.multiplyToRef(scaleMat, cm);\r\n            cm.multiplyAtIndex(12, x);\r\n            cm.multiplyAtIndex(13, y);\r\n            cm.multiplyAtIndex(14, z);\r\n\r\n            child._markAsDirtyAndDecompose();\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n\r\n        if (scaleChildren) {\r\n            for (const child of this.children) {\r\n                child.scale(x, y, z, scaleChildren);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the bone scaling in local space\r\n     * @param scale defines the scaling vector\r\n     */\r\n    public setScale(scale: Vector3): void {\r\n        this._decompose();\r\n        this._localScaling.copyFrom(scale);\r\n        this._markAsDirtyAndCompose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current scaling in local space\r\n     * @returns the current scaling vector\r\n     */\r\n    public getScale(): Vector3 {\r\n        this._decompose();\r\n        return this._localScaling;\r\n    }\r\n\r\n    /**\r\n     * Gets the current scaling in local space and stores it in a target vector\r\n     * @param result defines the target vector\r\n     */\r\n    public getScaleToRef(result: Vector3) {\r\n        this._decompose();\r\n        result.copyFrom(this._localScaling);\r\n    }\r\n\r\n    /**\r\n     * Set the yaw, pitch, and roll of the bone in local or world space\r\n     * @param yaw The rotation of the bone on the y axis\r\n     * @param pitch The rotation of the bone on the x axis\r\n     * @param roll The rotation of the bone on the z axis\r\n     * @param space The space that the axes of rotation are in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setYawPitchRoll(yaw: number, pitch: number, roll: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Add a rotation to the bone on an axis in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param amount The amount to rotate the bone\r\n     * @param space The space that the axis is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public rotate(axis: Vector3, amount: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        const rmat = Bone._TmpMats[0];\r\n        rmat.setTranslationFromFloats(0, 0, 0);\r\n        Matrix.RotationAxisToRef(axis, amount, rmat);\r\n        this._rotateWithMatrix(rmat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the rotation of the bone to a particular axis angle in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param angle The angle that the bone should be rotated to\r\n     * @param space The space that the axis is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setAxisAngle(axis: Vector3, angle: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.RotationAxisToRef(axis, angle, quat);\r\n\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.RotationAxisToRef(axis, angle, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the euler rotation of the bone in local or world space\r\n     * @param rotation The euler rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setRotation(rotation: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the quaternion rotation of the bone in local or world space\r\n     * @param quat The quaternion rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setRotationQuaternion(quat: Quaternion, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            this._decompose();\r\n            this._localRotation.copyFrom(quat);\r\n\r\n            this._markAsDirtyAndCompose();\r\n\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.FromQuaternionToRef(quat, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the rotation matrix of the bone in local or world space\r\n     * @param rotMat The rotation matrix that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     */\r\n    public setRotationMatrix(rotMat: Matrix, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.FromRotationMatrixToRef(rotMat, quat);\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat2 = Bone._TmpMats[1];\r\n        rotMat2.copyFrom(rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat2);\r\n\r\n        this._rotateWithMatrix(rotMat2, space, tNode);\r\n    }\r\n\r\n    private _rotateWithMatrix(rmat: Matrix, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        const lmat = this.getLocalMatrix();\r\n        const lx = lmat.m[12];\r\n        const ly = lmat.m[13];\r\n        const lz = lmat.m[14];\r\n        const parent = this.getParent();\r\n        const parentScale = Bone._TmpMats[3];\r\n        const parentScaleInv = Bone._TmpMats[4];\r\n\r\n        if (parent && space == Space.WORLD) {\r\n            if (tNode) {\r\n                parentScale.copyFrom(tNode.getWorldMatrix());\r\n                parent.getAbsoluteMatrix().multiplyToRef(parentScale, parentScale);\r\n            } else {\r\n                parentScale.copyFrom(parent.getAbsoluteMatrix());\r\n            }\r\n            parentScaleInv.copyFrom(parentScale);\r\n            parentScaleInv.invert();\r\n            lmat.multiplyToRef(parentScale, lmat);\r\n            lmat.multiplyToRef(rmat, lmat);\r\n            lmat.multiplyToRef(parentScaleInv, lmat);\r\n        } else {\r\n            if (space == Space.WORLD && tNode) {\r\n                parentScale.copyFrom(tNode.getWorldMatrix());\r\n                parentScaleInv.copyFrom(parentScale);\r\n                parentScaleInv.invert();\r\n                lmat.multiplyToRef(parentScale, lmat);\r\n                lmat.multiplyToRef(rmat, lmat);\r\n                lmat.multiplyToRef(parentScaleInv, lmat);\r\n            } else {\r\n                lmat.multiplyToRef(rmat, lmat);\r\n            }\r\n        }\r\n\r\n        lmat.setTranslationFromFloats(lx, ly, lz);\r\n\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    private _getAbsoluteInverseMatrixUnscaledToRef(rotMatInv: Matrix, tNode?: TransformNode): boolean {\r\n        const scaleMatrix = Bone._TmpMats[2];\r\n        rotMatInv.copyFrom(this.getAbsoluteMatrix());\r\n\r\n        if (tNode) {\r\n            rotMatInv.multiplyToRef(tNode.getWorldMatrix(), rotMatInv);\r\n            Matrix.ScalingToRef(tNode.scaling.x, tNode.scaling.y, tNode.scaling.z, scaleMatrix);\r\n        } else {\r\n            Matrix.IdentityToRef(scaleMatrix);\r\n        }\r\n\r\n        rotMatInv.invert();\r\n        if (isNaN(rotMatInv.m[0])) {\r\n            // Matrix failed to invert.\r\n            // This can happen if scale is zero for example.\r\n            return false;\r\n        }\r\n\r\n        scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);\r\n        rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the position of the bone in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The position of the bone\r\n     */\r\n    public getPosition(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const pos = Vector3.Zero();\r\n\r\n        this.getPositionToRef(space, tNode, pos);\r\n\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Copy the position of the bone to a vector3 in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 to copy the position to\r\n     */\r\n    public getPositionToRef(space = Space.LOCAL, tNode: Nullable<TransformNode>, result: Vector3): void {\r\n        if (space == Space.LOCAL) {\r\n            const lm = this.getLocalMatrix();\r\n\r\n            result.x = lm.m[12];\r\n            result.y = lm.m[13];\r\n            result.z = lm.m[14];\r\n        } else {\r\n            const tmat = Bone._TmpMats[0].copyFrom(this.getAbsoluteMatrix());\r\n\r\n            if (tNode) {\r\n                tmat.multiplyToRef(tNode.getWorldMatrix(), tmat);\r\n            }\r\n\r\n            result.x = tmat.m[12];\r\n            result.y = tmat.m[13];\r\n            result.z = tmat.m[14];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the absolute position of the bone (world space)\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The absolute position of the bone\r\n     */\r\n    public getAbsolutePosition(tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const pos = Vector3.Zero();\r\n\r\n        this.getPositionToRef(Space.WORLD, tNode, pos);\r\n\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Copy the absolute position of the bone (world space) to the result param\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 to copy the absolute position to\r\n     */\r\n    public getAbsolutePositionToRef(tNode: TransformNode, result: Vector3) {\r\n        this.getPositionToRef(Space.WORLD, tNode, result);\r\n    }\r\n\r\n    /**\r\n     * Compute the absolute matrices of this bone and its children\r\n     */\r\n    public computeAbsoluteMatrices(): void {\r\n        this._compose();\r\n\r\n        if (this.parent) {\r\n            this._localMatrix.multiplyToRef(this.parent._absoluteMatrix, this._absoluteMatrix);\r\n        } else {\r\n            this._absoluteMatrix.copyFrom(this._localMatrix);\r\n\r\n            const poseMatrix = this._skeleton.getPoseMatrix();\r\n\r\n            if (poseMatrix) {\r\n                this._absoluteMatrix.multiplyToRef(poseMatrix, this._absoluteMatrix);\r\n            }\r\n        }\r\n\r\n        const children = this.children;\r\n        const len = children.length;\r\n\r\n        for (let i = 0; i < len; i++) {\r\n            children[i].computeAbsoluteMatrices();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compute the absolute matrices of this bone and its children\r\n     * @deprecated Please use computeAbsoluteMatrices instead\r\n     */\r\n    public computeAbsoluteTransforms(): void {\r\n        this.computeAbsoluteMatrices();\r\n    }\r\n\r\n    /**\r\n     * Get the world direction from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The world direction\r\n     */\r\n    public getDirection(localAxis: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getDirectionToRef(localAxis, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the world direction to a vector3 from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 that the world direction will be copied to\r\n     */\r\n    public getDirectionToRef(localAxis: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        const tMat = Bone._TmpMats[0].copyFrom(this.getAbsoluteMatrix());\r\n\r\n        if (tNode) {\r\n            tMat.multiplyToRef(tNode.getWorldMatrix(), tMat);\r\n        }\r\n\r\n        Vector3.TransformNormalToRef(localAxis, tMat, result);\r\n\r\n        result.normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the euler rotation of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The euler rotation\r\n     */\r\n    public getRotation(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getRotationToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 that the rotation should be copied to\r\n     */\r\n    public getRotationToRef(space = Space.LOCAL, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        const quat = Bone._TmpQuat;\r\n\r\n        this.getRotationQuaternionToRef(space, tNode, quat);\r\n\r\n        quat.toEulerAnglesToRef(result);\r\n    }\r\n\r\n    /**\r\n     * Get the quaternion rotation of the bone in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The quaternion rotation\r\n     */\r\n    public getRotationQuaternion(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Quaternion {\r\n        const result = Quaternion.Identity();\r\n\r\n        this.getRotationQuaternionToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    public getRotationQuaternionToRef(space = Space.LOCAL, tNode: Nullable<TransformNode> = null, result: Quaternion): void {\r\n        if (space == Space.LOCAL) {\r\n            this._decompose();\r\n            result.copyFrom(this._localRotation);\r\n        } else {\r\n            const mat = Bone._TmpMats[0];\r\n            const amat = this.getAbsoluteMatrix();\r\n\r\n            if (tNode) {\r\n                amat.multiplyToRef(tNode.getWorldMatrix(), mat);\r\n            } else {\r\n                mat.copyFrom(amat);\r\n            }\r\n\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n\r\n            mat.decompose(undefined, result, undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the rotation matrix of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The rotation matrix\r\n     */\r\n    public getRotationMatrix(space = Space.LOCAL, tNode: TransformNode): Matrix {\r\n        const result = Matrix.Identity();\r\n\r\n        this.getRotationMatrixToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    public getRotationMatrixToRef(space = Space.LOCAL, tNode: TransformNode, result: Matrix): void {\r\n        if (space == Space.LOCAL) {\r\n            this.getLocalMatrix().getRotationMatrixToRef(result);\r\n        } else {\r\n            const mat = Bone._TmpMats[0];\r\n            const amat = this.getAbsoluteMatrix();\r\n\r\n            if (tNode) {\r\n                amat.multiplyToRef(tNode.getWorldMatrix(), mat);\r\n            } else {\r\n                mat.copyFrom(amat);\r\n            }\r\n\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n\r\n            mat.getRotationMatrixToRef(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone\r\n     * @param position The local position\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The world position\r\n     */\r\n    public getAbsolutePositionFromLocal(position: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getAbsolutePositionFromLocalToRef(position, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone and copy it to the result param\r\n     * @param position The local position\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 that the world position should be copied to\r\n     */\r\n    public getAbsolutePositionFromLocalToRef(position: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        const tmat = Bone._TmpMats[0].copyFrom(this.getAbsoluteMatrix());\r\n\r\n        if (tNode) {\r\n            tmat.multiplyToRef(tNode.getWorldMatrix(), tmat);\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    }\r\n\r\n    /**\r\n     * Get the local position of a point that is in world space\r\n     * @param position The world position\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @returns The local position\r\n     */\r\n    public getLocalPositionFromAbsolute(position: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getLocalPositionFromAbsoluteToRef(position, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the local position of a point that is in world space and copy it to the result param\r\n     * @param position The world position\r\n     * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD\r\n     * @param result The vector3 that the local position should be copied to\r\n     */\r\n    public getLocalPositionFromAbsoluteToRef(position: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        const tmat = Bone._TmpMats[0].copyFrom(this.getAbsoluteMatrix());\r\n\r\n        if (tNode) {\r\n            tmat.multiplyToRef(tNode.getWorldMatrix(), tmat);\r\n        }\r\n\r\n        tmat.invert();\r\n\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    }\r\n\r\n    /**\r\n     * Set the current local matrix as the restMatrix for this bone.\r\n     */\r\n    public setCurrentPoseAsRest(): void {\r\n        this.setRestMatrix(this.getLocalMatrix());\r\n    }\r\n\r\n    /**\r\n     * Releases associated resources\r\n     */\r\n    public override dispose(): void {\r\n        this._linkedTransformNode = null;\r\n\r\n        const index = this._skeleton.bones.indexOf(this);\r\n        if (index !== -1) {\r\n            this._skeleton.bones.splice(index, 1);\r\n        }\r\n\r\n        if (this._parentNode && (this._parentNode as Bone).children) {\r\n            const children = (this._parentNode as Bone).children;\r\n            const index = children.indexOf(this);\r\n            if (index !== -1) {\r\n                children.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport type { _IAnimationState } from \"./animation\";\r\nimport {\r\n    Animation,\r\n    _StaticOffsetValueColor3,\r\n    _StaticOffsetValueColor4,\r\n    _StaticOffsetValueQuaternion,\r\n    _StaticOffsetValueSize,\r\n    _StaticOffsetValueVector2,\r\n    _StaticOffsetValueVector3,\r\n} from \"./animation\";\r\nimport type { AnimationEvent } from \"./animationEvent\";\r\nimport type { Animatable } from \"./animatable\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\n\r\n/**\r\n * Defines a runtime animation\r\n */\r\nexport class RuntimeAnimation {\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * The current frame of the runtime animation\r\n     */\r\n    private _currentFrame: number = 0;\r\n\r\n    /**\r\n     * The animation used by the runtime animation\r\n     */\r\n    public _animation: Animation;\r\n\r\n    /**\r\n     * The target of the runtime animation\r\n     */\r\n    private _target: any;\r\n\r\n    /**\r\n     * The initiating animatable\r\n     */\r\n    private _host: Animatable;\r\n\r\n    /**\r\n     * The original value of the runtime animation\r\n     */\r\n    private _originalValue = new Array<any>();\r\n\r\n    /**\r\n     * The original blend value of the runtime animation\r\n     */\r\n    private _originalBlendValue: Nullable<any> = null;\r\n\r\n    /**\r\n     * The offsets cache of the runtime animation\r\n     */\r\n    private _offsetsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * The high limits cache of the runtime animation\r\n     */\r\n    private _highLimitsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * Specifies if the runtime animation has been stopped\r\n     */\r\n    private _stopped = false;\r\n\r\n    /**\r\n     * The blending factor of the runtime animation\r\n     */\r\n    private _blendingFactor = 0;\r\n\r\n    /**\r\n     * The BabylonJS scene\r\n     */\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The current value of the runtime animation\r\n     */\r\n    private _currentValue: Nullable<any> = null;\r\n\r\n    /** @internal */\r\n    public _animationState: _IAnimationState;\r\n\r\n    /**\r\n     * The active target of the runtime animation\r\n     */\r\n    private _activeTargets: any[];\r\n    private _currentActiveTarget: Nullable<any> = null;\r\n    private _directTarget: Nullable<any> = null;\r\n\r\n    /**\r\n     * The target path of the runtime animation\r\n     */\r\n    private _targetPath: string = \"\";\r\n\r\n    /**\r\n     * The weight of the runtime animation\r\n     */\r\n    private _weight = 1.0;\r\n\r\n    /**\r\n     * The absolute frame offset of the runtime animation\r\n     */\r\n    private _absoluteFrameOffset = 0;\r\n\r\n    /**\r\n     * The previous elapsed time (since start of animation) of the runtime animation\r\n     */\r\n    private _previousElapsedTime: number = 0;\r\n\r\n    private _yoyoDirection: number = 1;\r\n\r\n    /**\r\n     * The previous absolute frame of the runtime animation (meaning, without taking into account the from/to values, only the elapsed time and the fps)\r\n     */\r\n    private _previousAbsoluteFrame: number = 0;\r\n\r\n    private _enableBlending: boolean;\r\n\r\n    private _keys: IAnimationKey[];\r\n    private _minFrame: number;\r\n    private _maxFrame: number;\r\n    private _targetIsArray = false;\r\n\r\n    /** @internal */\r\n    public _coreRuntimeAnimation: RuntimeAnimation | null = null;\r\n\r\n    /**\r\n     * Gets the current frame of the runtime animation\r\n     */\r\n    public get currentFrame(): number {\r\n        return this._currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets the weight of the runtime animation\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the runtime animation\r\n     */\r\n    public get currentValue(): any {\r\n        return this._currentValue;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target path of the runtime animation\r\n     */\r\n    public get targetPath(): string {\r\n        return this._targetPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual target of the runtime animation\r\n     */\r\n    public get target(): any {\r\n        return this._currentActiveTarget;\r\n    }\r\n\r\n    /**\r\n     * Gets the additive state of the runtime animation\r\n     */\r\n    public get isAdditive(): boolean {\r\n        return this._host && this._host.isAdditive;\r\n    }\r\n\r\n    /** @internal */\r\n    public _onLoop: () => void;\r\n\r\n    /**\r\n     * Create a new RuntimeAnimation object\r\n     * @param target defines the target of the animation\r\n     * @param animation defines the source animation object\r\n     * @param scene defines the hosting scene\r\n     * @param host defines the initiating Animatable\r\n     */\r\n    public constructor(target: any, animation: Animation, scene: Scene, host: Animatable) {\r\n        this._animation = animation;\r\n        this._target = target;\r\n        this._scene = scene;\r\n        this._host = host;\r\n        this._activeTargets = [];\r\n\r\n        animation._runtimeAnimations.push(this);\r\n\r\n        // State\r\n        this._animationState = {\r\n            key: 0,\r\n            repeatCount: 0,\r\n            loopMode: this._getCorrectLoopMode(),\r\n        };\r\n\r\n        if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            this._animationState.workValue = Matrix.Zero();\r\n        }\r\n\r\n        // Limits\r\n        this._keys = this._animation.getKeys();\r\n        this._minFrame = this._keys[0].frame;\r\n        this._maxFrame = this._keys[this._keys.length - 1].frame;\r\n\r\n        // Add a start key at frame 0 if missing\r\n        if (this._minFrame !== 0) {\r\n            const newKey = { frame: 0, value: this._keys[0].value };\r\n            this._keys.splice(0, 0, newKey);\r\n        }\r\n\r\n        // Check data\r\n        if (this._target instanceof Array) {\r\n            let index = 0;\r\n            for (const target of this._target) {\r\n                this._preparePath(target, index);\r\n                this._getOriginalValues(index);\r\n                index++;\r\n            }\r\n            this._targetIsArray = true;\r\n        } else {\r\n            this._preparePath(this._target);\r\n            this._getOriginalValues();\r\n            this._targetIsArray = false;\r\n            this._directTarget = this._activeTargets[0];\r\n        }\r\n\r\n        // Cloning events locally\r\n        const events = animation.getEvents();\r\n        if (events && events.length > 0) {\r\n            for (const e of events) {\r\n                this._events.push(e._clone());\r\n            }\r\n        }\r\n\r\n        this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\r\n    }\r\n\r\n    private _preparePath(target: any, targetIndex = 0) {\r\n        const targetPropertyPath = this._animation.targetPropertyPath;\r\n\r\n        if (targetPropertyPath.length > 1) {\r\n            let property = target;\r\n            for (let index = 0; index < targetPropertyPath.length - 1; index++) {\r\n                const name = targetPropertyPath[index];\r\n                property = property[name];\r\n                if (property === undefined) {\r\n                    throw new Error(`Invalid property (${name}) in property path (${targetPropertyPath.join(\".\")})`);\r\n                }\r\n            }\r\n\r\n            this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\r\n            this._activeTargets[targetIndex] = property;\r\n        } else {\r\n            this._targetPath = targetPropertyPath[0];\r\n            this._activeTargets[targetIndex] = target;\r\n        }\r\n\r\n        if (this._activeTargets[targetIndex][this._targetPath] === undefined) {\r\n            throw new Error(`Invalid property (${this._targetPath}) in property path (${targetPropertyPath.join(\".\")})`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the animation from the runtime animation\r\n     */\r\n    public get animation(): Animation {\r\n        return this._animation;\r\n    }\r\n\r\n    /**\r\n     * Resets the runtime animation to the beginning\r\n     * @param restoreOriginal defines whether to restore the target property to the original value\r\n     */\r\n    public reset(restoreOriginal = false): void {\r\n        if (restoreOriginal) {\r\n            if (this._target instanceof Array) {\r\n                let index = 0;\r\n                for (const target of this._target) {\r\n                    if (this._originalValue[index] !== undefined) {\r\n                        this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\r\n                    }\r\n                    index++;\r\n                }\r\n            } else {\r\n                if (this._originalValue[0] !== undefined) {\r\n                    this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._offsetsCache = {};\r\n        this._highLimitsCache = {};\r\n        this._currentFrame = 0;\r\n        this._blendingFactor = 0;\r\n\r\n        // Events\r\n        for (let index = 0; index < this._events.length; index++) {\r\n            this._events[index].isDone = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies if the runtime animation is stopped\r\n     * @returns Boolean specifying if the runtime animation is stopped\r\n     */\r\n    public isStopped(): boolean {\r\n        return this._stopped;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the runtime animation\r\n     */\r\n    public dispose(): void {\r\n        const index = this._animation.runtimeAnimations.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._animation.runtimeAnimations.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the interpolated value to the target\r\n     * @param currentValue defines the value computed by the animation\r\n     * @param weight defines the weight to apply to this value (Defaults to 1.0)\r\n     */\r\n    public setValue(currentValue: any, weight: number) {\r\n        if (this._targetIsArray) {\r\n            for (let index = 0; index < this._target.length; index++) {\r\n                const target = this._target[index];\r\n                this._setValue(target, this._activeTargets[index], currentValue, weight, index);\r\n            }\r\n            return;\r\n        }\r\n        this._setValue(this._target, this._directTarget, currentValue, weight, 0);\r\n    }\r\n\r\n    private _getOriginalValues(targetIndex = 0) {\r\n        let originalValue: any;\r\n        const target = this._activeTargets[targetIndex];\r\n\r\n        if (target.getLocalMatrix && this._targetPath === \"_matrix\") {\r\n            // For bones\r\n            originalValue = target.getLocalMatrix();\r\n        } else {\r\n            originalValue = target[this._targetPath];\r\n        }\r\n\r\n        if (originalValue && originalValue.clone) {\r\n            this._originalValue[targetIndex] = originalValue.clone();\r\n        } else {\r\n            this._originalValue[targetIndex] = originalValue;\r\n        }\r\n    }\r\n\r\n    private _registerTargetForLateAnimationBinding(runtimeAnimation: RuntimeAnimation, originalValue: any): void {\r\n        const target = runtimeAnimation.target;\r\n        this._scene._registeredForLateAnimationBindings.pushNoDuplicate(target);\r\n\r\n        if (!target._lateAnimationHolders) {\r\n            target._lateAnimationHolders = {};\r\n        }\r\n\r\n        if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath] = {\r\n                totalWeight: 0,\r\n                totalAdditiveWeight: 0,\r\n                animations: [],\r\n                additiveAnimations: [],\r\n                originalValue: originalValue,\r\n            };\r\n        }\r\n\r\n        if (runtimeAnimation.isAdditive) {\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\r\n        } else {\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\r\n        }\r\n    }\r\n\r\n    private _setValue(target: any, destination: any, currentValue: any, weight: number, targetIndex: number): void {\r\n        // Set value\r\n        this._currentActiveTarget = destination;\r\n\r\n        this._weight = weight;\r\n\r\n        if (this._enableBlending && this._blendingFactor <= 1.0) {\r\n            if (!this._originalBlendValue) {\r\n                const originalValue = destination[this._targetPath];\r\n\r\n                if (originalValue.clone) {\r\n                    this._originalBlendValue = originalValue.clone();\r\n                } else {\r\n                    this._originalBlendValue = originalValue;\r\n                }\r\n            }\r\n\r\n            if (this._originalBlendValue.m) {\r\n                // Matrix\r\n                if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n                    if (this._currentValue) {\r\n                        Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                } else {\r\n                    if (this._currentValue) {\r\n                        Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                }\r\n            } else {\r\n                this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n            }\r\n\r\n            const blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\r\n            this._blendingFactor += blendingSpeed;\r\n        } else {\r\n            if (!this._currentValue) {\r\n                if (currentValue?.clone) {\r\n                    this._currentValue = currentValue.clone();\r\n                } else {\r\n                    this._currentValue = currentValue;\r\n                }\r\n            } else if (this._currentValue.copyFrom) {\r\n                this._currentValue.copyFrom(currentValue);\r\n            } else {\r\n                this._currentValue = currentValue;\r\n            }\r\n        }\r\n\r\n        if (weight !== -1.0) {\r\n            this._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\r\n        } else {\r\n            if (this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT) {\r\n                if (this._currentValue.addToRef) {\r\n                    this._currentValue.addToRef(this._originalValue[targetIndex], destination[this._targetPath]);\r\n                } else {\r\n                    destination[this._targetPath] = this._originalValue[targetIndex] + this._currentValue;\r\n                }\r\n            } else {\r\n                destination[this._targetPath] = this._currentValue;\r\n            }\r\n        }\r\n\r\n        if (target.markAsDirty) {\r\n            target.markAsDirty(this._animation.targetProperty);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the loop pmode of the runtime animation\r\n     * @returns Loop Mode\r\n     */\r\n    private _getCorrectLoopMode(): number | undefined {\r\n        if (this._target && this._target.animationPropertiesOverride) {\r\n            return this._target.animationPropertiesOverride.loopMode as number;\r\n        }\r\n\r\n        return this._animation.loopMode;\r\n    }\r\n\r\n    /**\r\n     * Move the current animation to a given frame\r\n     * @param frame defines the frame to move to\r\n     * @param weight defines the weight to apply to the animation (-1.0 by default)\r\n     */\r\n    public goToFrame(frame: number, weight = -1): void {\r\n        const keys = this._animation.getKeys();\r\n\r\n        if (frame < keys[0].frame) {\r\n            frame = keys[0].frame;\r\n        } else if (frame > keys[keys.length - 1].frame) {\r\n            frame = keys[keys.length - 1].frame;\r\n        }\r\n\r\n        // Need to reset animation events\r\n        const events = this._events;\r\n        if (events.length) {\r\n            for (let index = 0; index < events.length; index++) {\r\n                if (!events[index].onlyOnce) {\r\n                    // reset events in the future\r\n                    events[index].isDone = events[index].frame < frame;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._currentFrame = frame;\r\n        const currentValue = this._animation._interpolate(frame, this._animationState);\r\n\r\n        this.setValue(currentValue, weight);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _prepareForSpeedRatioChange(newSpeedRatio: number): void {\r\n        const newAbsoluteFrame = (this._previousElapsedTime * (this._animation.framePerSecond * newSpeedRatio)) / 1000.0;\r\n\r\n        this._absoluteFrameOffset = this._previousAbsoluteFrame - newAbsoluteFrame;\r\n    }\r\n\r\n    /**\r\n     * Execute the current animation\r\n     * @param elapsedTimeSinceAnimationStart defines the elapsed time (in milliseconds) since the animation was started\r\n     * @param from defines the lower frame of the animation range\r\n     * @param to defines the upper frame of the animation range\r\n     * @param loop defines if the current animation must loop\r\n     * @param speedRatio defines the current speed ratio\r\n     * @param weight defines the weight of the animation (default is -1 so no weight)\r\n     * @returns a boolean indicating if the animation is running\r\n     */\r\n    public animate(elapsedTimeSinceAnimationStart: number, from: number, to: number, loop: boolean, speedRatio: number, weight = -1.0): boolean {\r\n        const animation = this._animation;\r\n        const targetPropertyPath = animation.targetPropertyPath;\r\n        if (!targetPropertyPath || targetPropertyPath.length < 1) {\r\n            this._stopped = true;\r\n            return false;\r\n        }\r\n\r\n        let returnValue = true;\r\n        let currentFrame: number;\r\n        const events = this._events;\r\n        let frameRange = 0;\r\n\r\n        if (!this._coreRuntimeAnimation) {\r\n            // Check limits\r\n            if (from < this._minFrame || from > this._maxFrame) {\r\n                from = this._minFrame;\r\n            }\r\n            if (to < this._minFrame || to > this._maxFrame) {\r\n                to = this._maxFrame;\r\n            }\r\n\r\n            frameRange = to - from;\r\n            let offsetValue: any;\r\n\r\n            // Compute the frame according to the elapsed time and the fps of the animation (\"from\" and \"to\" are not factored in!)\r\n            let absoluteFrame = (elapsedTimeSinceAnimationStart * (animation.framePerSecond * speedRatio)) / 1000.0 + this._absoluteFrameOffset;\r\n            let highLimitValue = 0;\r\n\r\n            // Apply the yoyo function if required\r\n            let yoyoLoop = false;\r\n            const yoyoMode = loop && this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_YOYO;\r\n            if (yoyoMode) {\r\n                const position = (absoluteFrame - from) / frameRange;\r\n\r\n                // Apply the yoyo curve\r\n                const sin = Math.sin(position * Math.PI);\r\n                const yoyoPosition = Math.abs(sin);\r\n\r\n                // Map the yoyo position back to the range\r\n                absoluteFrame = yoyoPosition * frameRange + from;\r\n\r\n                const direction = sin >= 0 ? 1 : -1;\r\n                if (this._yoyoDirection !== direction) {\r\n                    yoyoLoop = true;\r\n                }\r\n\r\n                this._yoyoDirection = direction;\r\n            }\r\n\r\n            this._previousElapsedTime = elapsedTimeSinceAnimationStart;\r\n            this._previousAbsoluteFrame = absoluteFrame;\r\n\r\n            if (!loop && to >= from && ((absoluteFrame >= frameRange && speedRatio > 0) || (absoluteFrame <= 0 && speedRatio < 0))) {\r\n                // If we are out of range and not looping get back to caller\r\n                returnValue = false;\r\n                highLimitValue = animation.evaluate(to);\r\n            } else if (!loop && from >= to && ((absoluteFrame <= frameRange && speedRatio < 0) || (absoluteFrame >= 0 && speedRatio > 0))) {\r\n                returnValue = false;\r\n                highLimitValue = animation.evaluate(from);\r\n            } else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\r\n                const keyOffset = to.toString() + from.toString();\r\n                if (!this._offsetsCache[keyOffset]) {\r\n                    this._animationState.repeatCount = 0;\r\n                    this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE; // force a specific codepath in animation._interpolate()!\r\n                    const fromValue = animation._interpolate(from, this._animationState);\r\n                    const toValue = animation._interpolate(to, this._animationState);\r\n\r\n                    this._animationState.loopMode = this._getCorrectLoopMode();\r\n                    switch (animation.dataType) {\r\n                        // Float\r\n                        case Animation.ANIMATIONTYPE_FLOAT:\r\n                            this._offsetsCache[keyOffset] = toValue - fromValue;\r\n                            break;\r\n                        // Quaternion\r\n                        case Animation.ANIMATIONTYPE_QUATERNION:\r\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                            break;\r\n                        // Vector3\r\n                        case Animation.ANIMATIONTYPE_VECTOR3:\r\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                            break;\r\n                        // Vector2\r\n                        case Animation.ANIMATIONTYPE_VECTOR2:\r\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                            break;\r\n                        // Size\r\n                        case Animation.ANIMATIONTYPE_SIZE:\r\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                            break;\r\n                        // Color3\r\n                        case Animation.ANIMATIONTYPE_COLOR3:\r\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n\r\n                    this._highLimitsCache[keyOffset] = toValue;\r\n                }\r\n\r\n                highLimitValue = this._highLimitsCache[keyOffset];\r\n                offsetValue = this._offsetsCache[keyOffset];\r\n            }\r\n\r\n            if (offsetValue === undefined) {\r\n                switch (animation.dataType) {\r\n                    // Float\r\n                    case Animation.ANIMATIONTYPE_FLOAT:\r\n                        offsetValue = 0;\r\n                        break;\r\n                    // Quaternion\r\n                    case Animation.ANIMATIONTYPE_QUATERNION:\r\n                        offsetValue = _StaticOffsetValueQuaternion;\r\n                        break;\r\n                    // Vector3\r\n                    case Animation.ANIMATIONTYPE_VECTOR3:\r\n                        offsetValue = _StaticOffsetValueVector3;\r\n                        break;\r\n                    // Vector2\r\n                    case Animation.ANIMATIONTYPE_VECTOR2:\r\n                        offsetValue = _StaticOffsetValueVector2;\r\n                        break;\r\n                    // Size\r\n                    case Animation.ANIMATIONTYPE_SIZE:\r\n                        offsetValue = _StaticOffsetValueSize;\r\n                        break;\r\n                    // Color3\r\n                    case Animation.ANIMATIONTYPE_COLOR3:\r\n                        offsetValue = _StaticOffsetValueColor3;\r\n                        break;\r\n                    case Animation.ANIMATIONTYPE_COLOR4:\r\n                        offsetValue = _StaticOffsetValueColor4;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // Compute value\r\n\r\n            if (this._host && this._host.syncRoot) {\r\n                // If we must sync with an animatable, calculate the current frame based on the frame of the root animatable\r\n                const syncRoot = this._host.syncRoot;\r\n                const hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\r\n                currentFrame = from + frameRange * hostNormalizedFrame;\r\n            } else {\r\n                if ((absoluteFrame > 0 && from > to) || (absoluteFrame < 0 && from < to)) {\r\n                    currentFrame = returnValue && frameRange !== 0 ? to + (absoluteFrame % frameRange) : from;\r\n                } else {\r\n                    currentFrame = returnValue && frameRange !== 0 ? from + (absoluteFrame % frameRange) : to;\r\n                }\r\n            }\r\n\r\n            // Reset event/state if looping\r\n            if ((!yoyoMode && ((speedRatio > 0 && this.currentFrame > currentFrame) || (speedRatio < 0 && this.currentFrame < currentFrame))) || (yoyoMode && yoyoLoop)) {\r\n                this._onLoop();\r\n\r\n                // Need to reset animation events\r\n                for (let index = 0; index < events.length; index++) {\r\n                    if (!events[index].onlyOnce) {\r\n                        // reset event, the animation is looping\r\n                        events[index].isDone = false;\r\n                    }\r\n                }\r\n\r\n                this._animationState.key = speedRatio > 0 ? 0 : animation.getKeys().length - 1;\r\n            }\r\n            this._currentFrame = currentFrame;\r\n            this._animationState.repeatCount = frameRange === 0 ? 0 : (absoluteFrame / frameRange) >> 0;\r\n            this._animationState.highLimitValue = highLimitValue;\r\n            this._animationState.offsetValue = offsetValue;\r\n        } else {\r\n            frameRange = to - from;\r\n            currentFrame = this._coreRuntimeAnimation.currentFrame;\r\n            this._currentFrame = currentFrame;\r\n            this._animationState.repeatCount = this._coreRuntimeAnimation._animationState.repeatCount;\r\n            this._animationState.highLimitValue = this._coreRuntimeAnimation._animationState.highLimitValue;\r\n            this._animationState.offsetValue = this._coreRuntimeAnimation._animationState.offsetValue;\r\n        }\r\n\r\n        const currentValue = animation._interpolate(currentFrame, this._animationState);\r\n\r\n        // Set value\r\n        this.setValue(currentValue, weight);\r\n\r\n        // Check events\r\n        if (events.length) {\r\n            for (let index = 0; index < events.length; index++) {\r\n                // Make sure current frame has passed event frame and that event frame is within the current range\r\n                // Also, handle both forward and reverse animations\r\n                if (\r\n                    (frameRange >= 0 && currentFrame >= events[index].frame && events[index].frame >= from) ||\r\n                    (frameRange < 0 && currentFrame <= events[index].frame && events[index].frame <= from)\r\n                ) {\r\n                    const event = events[index];\r\n                    if (!event.isDone) {\r\n                        // If event should be done only once, remove it.\r\n                        if (event.onlyOnce) {\r\n                            events.splice(index, 1);\r\n                            index--;\r\n                        }\r\n                        event.isDone = true;\r\n                        event.action(currentFrame);\r\n                    } // Don't do anything if the event has already been done.\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!returnValue) {\r\n            this._stopped = true;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n}\r\n", "import { Observable } from \"core/Misc/observable\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\r\nimport { Animation } from \"./animation\";\r\nimport { PrecisionDate } from \"core/Misc/precisionDate\";\r\nimport { Matrix, Quaternion, TmpVectors, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { Bone } from \"core/Bones/bone\";\r\nimport type { Node } from \"../node\";\r\n\r\n/**\r\n * Class used to store an actual running animation\r\n */\r\nexport class Animatable {\r\n    /**\r\n     * If true, the animatable will be processed even if it is considered actively paused (weight of 0 and previous weight of 0).\r\n     * This can be used to force the full processing of paused animatables in the animation engine.\r\n     * Default is false.\r\n     */\r\n    public static ProcessPausedAnimatables = false;\r\n\r\n    private _localDelayOffset: Nullable<number> = null;\r\n    private _pausedDelay: Nullable<number> = null;\r\n    private _manualJumpDelay: Nullable<number> = null;\r\n    /** @hidden */\r\n    public _runtimeAnimations = new Array<RuntimeAnimation>();\r\n    private _paused = false;\r\n    private _scene: Scene;\r\n    private _speedRatio = 1;\r\n    private _weight = -1.0;\r\n    private _previousWeight = -1.0;\r\n    private _syncRoot: Nullable<Animatable> = null;\r\n    private _frameToSyncFromJump: Nullable<number> = null;\r\n    private _goToFrame: Nullable<number> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\r\n     * This will only apply for non looping animation (default is true)\r\n     */\r\n    public disposeOnEnd = true;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the animation has started\r\n     */\r\n    public animationStarted = false;\r\n\r\n    /**\r\n     * Observer raised when the animation ends\r\n     */\r\n    public onAnimationEndObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Observer raised when the animation loops\r\n     */\r\n    public onAnimationLoopObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Gets the root Animatable used to synchronize and normalize animations\r\n     */\r\n    public get syncRoot(): Nullable<Animatable> {\r\n        return this._syncRoot;\r\n    }\r\n\r\n    /**\r\n     * Gets the current frame of the first RuntimeAnimation\r\n     * Used to synchronize Animatables\r\n     */\r\n    public get masterFrame(): number {\r\n        if (this._runtimeAnimations.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        return this._runtimeAnimations[0].currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    public set weight(value: number) {\r\n        if (value === -1) {\r\n            // -1 is ok and means no weight\r\n            this._weight = -1;\r\n            return;\r\n        }\r\n\r\n        // Else weight must be in [0, 1] range\r\n        this._weight = Math.min(Math.max(value, 0), 1.0);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._speedRatio;\r\n    }\r\n\r\n    public set speedRatio(value: number) {\r\n        for (let index = 0; index < this._runtimeAnimations.length; index++) {\r\n            const animation = this._runtimeAnimations[index];\r\n\r\n            animation._prepareForSpeedRatioChange(value);\r\n        }\r\n        this._speedRatio = value;\r\n\r\n        // Resync _manualJumpDelay in case goToFrame was called before speedRatio was set.\r\n        if (this._goToFrame !== null) {\r\n            this.goToFrame(this._goToFrame);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the elapsed time since the animatable started in milliseconds\r\n     */\r\n    public get elapsedTime(): number {\r\n        return this._localDelayOffset === null ? 0 : this._scene._animationTime - this._localDelayOffset;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Animatable\r\n     * @param scene defines the hosting scene\r\n     * @param target defines the target object\r\n     * @param fromFrame defines the starting frame number (default is 0)\r\n     * @param toFrame defines the ending frame number (default is 100)\r\n     * @param loopAnimation defines if the animation must loop (default is false)\r\n     * @param speedRatio defines the factor to apply to animation speed (default is 1)\r\n     * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\r\n     * @param animations defines a group of animation to add to the new Animatable\r\n     * @param onAnimationLoop defines a callback to call when animation loops\r\n     * @param isAdditive defines whether the animation should be evaluated additively\r\n     * @param playOrder defines the order in which this animatable should be processed in the list of active animatables (default: 0)\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        /** defines the target object */\r\n        public target: any,\r\n        /** [0] defines the starting frame number (default is 0) */\r\n        public fromFrame: number = 0,\r\n        /** [100] defines the ending frame number (default is 100) */\r\n        public toFrame: number = 100,\r\n        /** [false] defines if the animation must loop (default is false)  */\r\n        public loopAnimation: boolean = false,\r\n        speedRatio: number = 1.0,\r\n        /** defines a callback to call when animation ends if it is not looping */\r\n        public onAnimationEnd?: Nullable<() => void>,\r\n        animations?: Animation[],\r\n        /** defines a callback to call when animation loops */\r\n        public onAnimationLoop?: Nullable<() => void>,\r\n        /** [false] defines whether the animation should be evaluated additively */\r\n        public isAdditive: boolean = false,\r\n        /** [0] defines the order in which this animatable should be processed in the list of active animatables (default: 0) */\r\n        public playOrder = 0\r\n    ) {\r\n        this._scene = scene;\r\n        if (animations) {\r\n            this.appendAnimations(target, animations);\r\n        }\r\n\r\n        this._speedRatio = speedRatio;\r\n        scene._activeAnimatables.push(this);\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Synchronize and normalize current Animatable with a source Animatable\r\n     * This is useful when using animation weights and when animations are not of the same length\r\n     * @param root defines the root Animatable to synchronize with (null to stop synchronizing)\r\n     * @returns the current Animatable\r\n     */\r\n    public syncWith(root: Nullable<Animatable>): Animatable {\r\n        this._syncRoot = root;\r\n\r\n        if (root) {\r\n            // Make sure this animatable will animate after the root\r\n            const index = this._scene._activeAnimatables.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                this._scene._activeAnimatables.push(this);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of runtime animations\r\n     * @returns an array of RuntimeAnimation\r\n     */\r\n    public getAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Adds more animations to the current animatable\r\n     * @param target defines the target of the animations\r\n     * @param animations defines the new animations to add\r\n     */\r\n    public appendAnimations(target: any, animations: Animation[]): void {\r\n        for (let index = 0; index < animations.length; index++) {\r\n            const animation = animations[index];\r\n\r\n            const newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\r\n            newRuntimeAnimation._onLoop = () => {\r\n                this.onAnimationLoopObservable.notifyObservers(this);\r\n                if (this.onAnimationLoop) {\r\n                    this.onAnimationLoop();\r\n                }\r\n            };\r\n\r\n            this._runtimeAnimations.push(newRuntimeAnimation);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the source animation for a specific property\r\n     * @param property defines the property to look for\r\n     * @returns null or the source animation for the given property\r\n     */\r\n    public getAnimationByTargetProperty(property: string): Nullable<Animation> {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index].animation;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the runtime animation for a specific property\r\n     * @param property defines the property to look for\r\n     * @returns null or the runtime animation for the given property\r\n     */\r\n    public getRuntimeAnimationByTargetProperty(property: string): Nullable<RuntimeAnimation> {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Resets the animatable to its original state\r\n     */\r\n    public reset(): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].reset(true);\r\n        }\r\n\r\n        this._localDelayOffset = null;\r\n        this._pausedDelay = null;\r\n    }\r\n\r\n    /**\r\n     * Allows the animatable to blend with current running animations\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     * @param blendingSpeed defines the blending speed to use\r\n     */\r\n    public enableBlending(blendingSpeed: number): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = true;\r\n            runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable animation blending\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     */\r\n    public disableBlending(): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Jump directly to a given frame\r\n     * @param frame defines the frame to jump to\r\n     * @param useWeight defines whether the animation weight should be applied to the image to be jumped to (false by default)\r\n     */\r\n    public goToFrame(frame: number, useWeight = false): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        if (runtimeAnimations[0]) {\r\n            const fps = runtimeAnimations[0].animation.framePerSecond;\r\n            this._frameToSyncFromJump = this._frameToSyncFromJump ?? runtimeAnimations[0].currentFrame;\r\n            const delay = this.speedRatio === 0 ? 0 : (((frame - this._frameToSyncFromJump) / fps) * 1000) / this.speedRatio;\r\n            this._manualJumpDelay = -delay;\r\n        }\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].goToFrame(frame, useWeight ? this._weight : -1);\r\n        }\r\n\r\n        this._goToFrame = frame;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the animations for this animatable are paused\r\n     */\r\n    public get paused() {\r\n        return this._paused;\r\n    }\r\n\r\n    /**\r\n     * Pause the animation\r\n     */\r\n    public pause(): void {\r\n        if (this._paused) {\r\n            return;\r\n        }\r\n        this._paused = true;\r\n    }\r\n\r\n    /**\r\n     * Restart the animation\r\n     */\r\n    public restart(): void {\r\n        this._paused = false;\r\n    }\r\n\r\n    private _raiseOnAnimationEnd() {\r\n        if (this.onAnimationEnd) {\r\n            this.onAnimationEnd();\r\n        }\r\n\r\n        this.onAnimationEndObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Stop and delete the current animation\r\n     * @param animationName defines a string used to only stop some of the runtime animations instead of all\r\n     * @param targetMask a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n     * @param useGlobalSplice if true, the animatables will be removed by the caller of this function (false by default)\r\n     * @param skipOnAnimationEnd defines if the system should not raise onAnimationEnd. Default is false\r\n     */\r\n    public stop(animationName?: string, targetMask?: (target: any) => boolean, useGlobalSplice = false, skipOnAnimationEnd = false): void {\r\n        if (animationName || targetMask) {\r\n            const idx = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (idx > -1) {\r\n                const runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (let index = runtimeAnimations.length - 1; index >= 0; index--) {\r\n                    const runtimeAnimation = runtimeAnimations[index];\r\n                    if (animationName && runtimeAnimation.animation.name != animationName) {\r\n                        continue;\r\n                    }\r\n                    if (targetMask && !targetMask(runtimeAnimation.target)) {\r\n                        continue;\r\n                    }\r\n\r\n                    runtimeAnimation.dispose();\r\n                    runtimeAnimations.splice(index, 1);\r\n                }\r\n\r\n                if (runtimeAnimations.length == 0) {\r\n                    if (!useGlobalSplice) {\r\n                        this._scene._activeAnimatables.splice(idx, 1);\r\n                    }\r\n                    if (!skipOnAnimationEnd) {\r\n                        this._raiseOnAnimationEnd();\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const index = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (index > -1) {\r\n                if (!useGlobalSplice) {\r\n                    this._scene._activeAnimatables.splice(index, 1);\r\n                }\r\n                const runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (let index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n\r\n                this._runtimeAnimations.length = 0;\r\n\r\n                if (!skipOnAnimationEnd) {\r\n                    this._raiseOnAnimationEnd();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Wait asynchronously for the animation to end\r\n     * @returns a promise which will be fulfilled when the animation ends\r\n     */\r\n    public async waitAsync(): Promise<Animatable> {\r\n        return await new Promise((resolve) => {\r\n            this.onAnimationEndObservable.add(\r\n                () => {\r\n                    resolve(this);\r\n                },\r\n                undefined,\r\n                undefined,\r\n                this,\r\n                true\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _animate(delay: number): boolean {\r\n        if (this._paused) {\r\n            this.animationStarted = false;\r\n            if (this._pausedDelay === null) {\r\n                this._pausedDelay = delay;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        if (this._localDelayOffset === null) {\r\n            this._localDelayOffset = delay;\r\n            this._pausedDelay = null;\r\n        } else if (this._pausedDelay !== null) {\r\n            this._localDelayOffset += delay - this._pausedDelay;\r\n            this._pausedDelay = null;\r\n        }\r\n\r\n        if (this._manualJumpDelay !== null) {\r\n            this._localDelayOffset += this.speedRatio < 0 ? -this._manualJumpDelay : this._manualJumpDelay;\r\n            this._manualJumpDelay = null;\r\n            this._frameToSyncFromJump = null;\r\n        }\r\n\r\n        this._goToFrame = null;\r\n\r\n        if (!Animatable.ProcessPausedAnimatables && this._weight === 0 && this._previousWeight === 0) {\r\n            // We consider that an animatable with a weight === 0 is \"actively\" paused\r\n            return true;\r\n        }\r\n\r\n        this._previousWeight = this._weight;\r\n\r\n        // Animating\r\n        let running = false;\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n        let index: number;\r\n\r\n        for (index = 0; index < runtimeAnimations.length; index++) {\r\n            const animation = runtimeAnimations[index];\r\n            const isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\r\n            running = running || isRunning;\r\n        }\r\n\r\n        this.animationStarted = running;\r\n\r\n        if (!running) {\r\n            if (this.disposeOnEnd) {\r\n                // Remove from active animatables\r\n                index = this._scene._activeAnimatables.indexOf(this);\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n\r\n                // Dispose all runtime animations\r\n                for (index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n            }\r\n\r\n            this._raiseOnAnimationEnd();\r\n\r\n            if (this.disposeOnEnd) {\r\n                this.onAnimationEnd = null;\r\n                this.onAnimationLoop = null;\r\n                this.onAnimationLoopObservable.clear();\r\n                this.onAnimationEndObservable.clear();\r\n            }\r\n        }\r\n\r\n        return running;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nfunction ProcessLateAnimationBindingsForMatrices(holder: {\r\n    totalWeight: number;\r\n    totalAdditiveWeight: number;\r\n    animations: RuntimeAnimation[];\r\n    additiveAnimations: RuntimeAnimation[];\r\n    originalValue: Matrix;\r\n}): any {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return holder.originalValue;\r\n    }\r\n\r\n    let normalizer = 1.0;\r\n    const finalPosition = TmpVectors.Vector3[0];\r\n    const finalScaling = TmpVectors.Vector3[1];\r\n    const finalQuaternion = TmpVectors.Quaternion[0];\r\n    let startIndex = 0;\r\n    const originalAnimation = holder.animations[0];\r\n    const originalValue = holder.originalValue;\r\n\r\n    let scale = 1;\r\n    let skipOverride = false;\r\n    if (holder.totalWeight < 1.0) {\r\n        // We need to mix the original value in\r\n        scale = 1.0 - holder.totalWeight;\r\n        originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    } else {\r\n        startIndex = 1;\r\n        // We need to normalize the weights\r\n        normalizer = holder.totalWeight;\r\n        scale = originalAnimation.weight / normalizer;\r\n        if (scale == 1) {\r\n            if (holder.totalAdditiveWeight) {\r\n                skipOverride = true;\r\n            } else {\r\n                return originalAnimation.currentValue;\r\n            }\r\n        }\r\n\r\n        originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    }\r\n\r\n    // Add up the override animations\r\n    if (!skipOverride) {\r\n        finalScaling.scaleInPlace(scale);\r\n        finalPosition.scaleInPlace(scale);\r\n        finalQuaternion.scaleInPlace(scale);\r\n\r\n        for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n            const runtimeAnimation = holder.animations[animIndex];\r\n            if (runtimeAnimation.weight === 0) {\r\n                continue;\r\n            }\r\n\r\n            scale = runtimeAnimation.weight / normalizer;\r\n            const currentPosition = TmpVectors.Vector3[2];\r\n            const currentScaling = TmpVectors.Vector3[3];\r\n            const currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n            runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n\r\n            currentScaling.scaleAndAddToRef(scale, finalScaling);\r\n            currentQuaternion.scaleAndAddToRef(Quaternion.Dot(finalQuaternion, currentQuaternion) > 0 ? scale : -scale, finalQuaternion);\r\n            currentPosition.scaleAndAddToRef(scale, finalPosition);\r\n        }\r\n\r\n        finalQuaternion.normalize();\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        const currentPosition = TmpVectors.Vector3[2];\r\n        const currentScaling = TmpVectors.Vector3[3];\r\n        const currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n        runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n        currentScaling.multiplyToRef(finalScaling, currentScaling);\r\n        Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\r\n        finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\r\n        Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\r\n        currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\r\n    }\r\n\r\n    const workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\r\n    Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\r\n    return workValue;\r\n}\r\n\r\n/** @internal */\r\nfunction ProcessLateAnimationBindingsForQuaternions(\r\n    holder: {\r\n        totalWeight: number;\r\n        totalAdditiveWeight: number;\r\n        animations: RuntimeAnimation[];\r\n        additiveAnimations: RuntimeAnimation[];\r\n        originalValue: Quaternion;\r\n    },\r\n    refQuaternion: Quaternion\r\n): Quaternion {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return refQuaternion;\r\n    }\r\n\r\n    const originalAnimation = holder.animations[0];\r\n    const originalValue = holder.originalValue;\r\n    let cumulativeQuaternion = refQuaternion;\r\n\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\r\n        cumulativeQuaternion.copyFrom(originalValue);\r\n    } else if (holder.animations.length === 1) {\r\n        Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\r\n\r\n        if (holder.totalAdditiveWeight === 0) {\r\n            return cumulativeQuaternion;\r\n        }\r\n    } else if (holder.animations.length > 1) {\r\n        // Add up the override animations\r\n        let normalizer = 1.0;\r\n        let quaternions: Array<Quaternion>;\r\n        let weights: Array<number>;\r\n\r\n        if (holder.totalWeight < 1.0) {\r\n            const scale = 1.0 - holder.totalWeight;\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n\r\n            quaternions.push(originalValue);\r\n            weights.push(scale);\r\n        } else {\r\n            if (holder.animations.length === 2) {\r\n                // Slerp as soon as we can\r\n                Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\r\n\r\n                if (holder.totalAdditiveWeight === 0) {\r\n                    return refQuaternion;\r\n                }\r\n            }\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n            normalizer = holder.totalWeight;\r\n        }\r\n\r\n        for (let animIndex = 0; animIndex < holder.animations.length; animIndex++) {\r\n            const runtimeAnimation = holder.animations[animIndex];\r\n            quaternions.push(runtimeAnimation.currentValue);\r\n            weights.push(runtimeAnimation.weight / normalizer);\r\n        }\r\n\r\n        // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\r\n\r\n        let cumulativeAmount = 0;\r\n        for (let index = 0; index < quaternions.length; ) {\r\n            if (!index) {\r\n                Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\r\n                cumulativeQuaternion = refQuaternion;\r\n                cumulativeAmount = weights[index] + weights[index + 1];\r\n                index += 2;\r\n                continue;\r\n            }\r\n            cumulativeAmount += weights[index];\r\n            Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\r\n        Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\r\n    }\r\n\r\n    return cumulativeQuaternion;\r\n}\r\n\r\n/** @internal */\r\nfunction ProcessLateAnimationBindings(scene: Scene): void {\r\n    if (!scene._registeredForLateAnimationBindings.length) {\r\n        return;\r\n    }\r\n    for (let index = 0; index < scene._registeredForLateAnimationBindings.length; index++) {\r\n        const target = scene._registeredForLateAnimationBindings.data[index];\r\n\r\n        for (const path in target._lateAnimationHolders) {\r\n            const holder = target._lateAnimationHolders[path];\r\n            const originalAnimation: RuntimeAnimation = holder.animations[0];\r\n            const originalValue = holder.originalValue;\r\n            if (originalValue === undefined || originalValue === null) {\r\n                continue;\r\n            }\r\n            const matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\r\n\r\n            let finalValue: any = target[path];\r\n            if (matrixDecomposeMode) {\r\n                finalValue = ProcessLateAnimationBindingsForMatrices(holder);\r\n            } else {\r\n                const quaternionMode = originalValue.w !== undefined;\r\n                if (quaternionMode) {\r\n                    finalValue = ProcessLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\r\n                } else {\r\n                    let startIndex = 0;\r\n                    let normalizer = 1.0;\r\n\r\n                    const originalAnimationIsLoopRelativeFromCurrent =\r\n                        originalAnimation && originalAnimation._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;\r\n\r\n                    if (holder.totalWeight < 1.0) {\r\n                        // We need to mix the original value in\r\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\r\n                            finalValue = originalValue.clone ? originalValue.clone() : originalValue;\r\n                        } else if (originalAnimation && originalValue.scale) {\r\n                            finalValue = originalValue.scale(1.0 - holder.totalWeight);\r\n                        } else if (originalAnimation) {\r\n                            finalValue = originalValue * (1.0 - holder.totalWeight);\r\n                        } else if (originalValue.clone) {\r\n                            finalValue = originalValue.clone();\r\n                        } else {\r\n                            finalValue = originalValue;\r\n                        }\r\n                    } else if (originalAnimation) {\r\n                        // We need to normalize the weights\r\n                        normalizer = holder.totalWeight;\r\n                        const scale = originalAnimation.weight / normalizer;\r\n                        if (scale !== 1) {\r\n                            if (originalAnimation.currentValue.scale) {\r\n                                finalValue = originalAnimation.currentValue.scale(scale);\r\n                            } else {\r\n                                finalValue = originalAnimation.currentValue * scale;\r\n                            }\r\n                        } else {\r\n                            finalValue = originalAnimation.currentValue;\r\n                        }\r\n\r\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\r\n                            if (finalValue.addToRef) {\r\n                                finalValue.addToRef(originalValue, finalValue);\r\n                            } else {\r\n                                finalValue += originalValue;\r\n                            }\r\n                        }\r\n\r\n                        startIndex = 1;\r\n                    }\r\n\r\n                    // Add up the override animations\r\n                    for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n                        const runtimeAnimation = holder.animations[animIndex];\r\n                        const scale = runtimeAnimation.weight / normalizer;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n\r\n                    // Add up the additive animations\r\n                    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n                        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n                        const scale: number = runtimeAnimation.weight;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            target[path] = finalValue;\r\n        }\r\n\r\n        target._lateAnimationHolders = {};\r\n    }\r\n    scene._registeredForLateAnimationBindings.reset();\r\n}\r\n\r\n/** @internal */\r\nexport function RegisterTargetForLateAnimationBinding(scene: Scene, runtimeAnimation: RuntimeAnimation, originalValue: any): void {\r\n    const target = runtimeAnimation.target;\r\n    scene._registeredForLateAnimationBindings.pushNoDuplicate(target);\r\n\r\n    if (!target._lateAnimationHolders) {\r\n        target._lateAnimationHolders = {};\r\n    }\r\n\r\n    if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath] = {\r\n            totalWeight: 0,\r\n            totalAdditiveWeight: 0,\r\n            animations: [],\r\n            additiveAnimations: [],\r\n            originalValue: originalValue,\r\n        };\r\n    }\r\n\r\n    if (runtimeAnimation.isAdditive) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\r\n    } else {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\r\n    }\r\n}\r\n\r\n/**\r\n * Initialize all the inter dependecies between the animations and Scene and Bone\r\n * @param sceneClass defines the scene prototype to use\r\n * @param boneClass defines the bone prototype to use\r\n */\r\nexport function AddAnimationExtensions(sceneClass: typeof Scene, boneClass: typeof Bone): void {\r\n    if (boneClass) {\r\n        boneClass.prototype.copyAnimationRange = function (\r\n            source: Bone,\r\n            rangeName: string,\r\n            frameOffset: number,\r\n            rescaleAsRequired = false,\r\n            skelDimensionsRatio: Nullable<Vector3> = null\r\n        ): boolean {\r\n            // all animation may be coming from a library skeleton, so may need to create animation\r\n            if (this.animations.length === 0) {\r\n                this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\r\n                this.animations[0].setKeys([]);\r\n            }\r\n\r\n            // get animation info / verify there is such a range from the source bone\r\n            const sourceRange = source.animations[0].getRange(rangeName);\r\n            if (!sourceRange) {\r\n                return false;\r\n            }\r\n            const from = sourceRange.from;\r\n            const to = sourceRange.to;\r\n            const sourceKeys = source.animations[0].getKeys();\r\n\r\n            // rescaling prep\r\n            const sourceBoneLength = source.length;\r\n            const sourceParent = source.getParent();\r\n            const parent = this.getParent();\r\n            const parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\r\n            const parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\r\n\r\n            const dimensionsScalingReqd =\r\n                rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\r\n\r\n            const destKeys = this.animations[0].getKeys();\r\n\r\n            // loop vars declaration\r\n            let orig: { frame: number; value: Matrix };\r\n            let origTranslation: Vector3;\r\n            let mat: Matrix;\r\n\r\n            for (let key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\r\n                orig = sourceKeys[key];\r\n                if (orig.frame >= from && orig.frame <= to) {\r\n                    if (rescaleAsRequired) {\r\n                        mat = orig.value.clone();\r\n\r\n                        // scale based on parent ratio, when bone has parent\r\n                        if (parentScalingReqd) {\r\n                            origTranslation = mat.getTranslation();\r\n                            mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\r\n\r\n                            // scale based on skeleton dimension ratio when root bone, and value is passed\r\n                        } else if (dimensionsScalingReqd && skelDimensionsRatio) {\r\n                            origTranslation = mat.getTranslation();\r\n                            mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\r\n\r\n                            // use original when root bone, and no data for skelDimensionsRatio\r\n                        } else {\r\n                            mat = orig.value;\r\n                        }\r\n                    } else {\r\n                        mat = orig.value;\r\n                    }\r\n                    destKeys.push({ frame: orig.frame + frameOffset, value: mat });\r\n                }\r\n            }\r\n            this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\r\n            return true;\r\n        };\r\n    }\r\n\r\n    if (!sceneClass) {\r\n        return;\r\n    }\r\n\r\n    sceneClass.prototype._animate = function (customDeltaTime?: number): void {\r\n        if (!this.animationsEnabled) {\r\n            return;\r\n        }\r\n\r\n        // Getting time\r\n        const now = PrecisionDate.Now;\r\n        if (!this._animationTimeLast) {\r\n            if (this._pendingData.length > 0) {\r\n                return;\r\n            }\r\n            this._animationTimeLast = now;\r\n        }\r\n\r\n        this.deltaTime = customDeltaTime !== undefined ? customDeltaTime : this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\r\n        this._animationTimeLast = now;\r\n\r\n        const animatables = this._activeAnimatables;\r\n        if (animatables.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this._animationTime += this.deltaTime;\r\n        const animationTime = this._animationTime;\r\n\r\n        for (let index = 0; index < animatables.length; index++) {\r\n            const animatable = animatables[index];\r\n\r\n            if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\r\n                index--; // Array was updated\r\n            }\r\n        }\r\n\r\n        // Late animation bindings\r\n        ProcessLateAnimationBindings(this);\r\n    };\r\n\r\n    sceneClass.prototype.sortActiveAnimatables = function (): void {\r\n        this._activeAnimatables.sort((a, b) => {\r\n            return a.playOrder - b.playOrder;\r\n        });\r\n    };\r\n\r\n    sceneClass.prototype.beginWeightedAnimation = function (\r\n        target: any,\r\n        from: number,\r\n        to: number,\r\n        weight = 1.0,\r\n        loop?: boolean,\r\n        speedRatio: number = 1.0,\r\n        onAnimationEnd?: () => void,\r\n        animatable?: Animatable,\r\n        targetMask?: (target: any) => boolean,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable {\r\n        const returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\r\n        returnedAnimatable.weight = weight;\r\n\r\n        return returnedAnimatable;\r\n    };\r\n\r\n    sceneClass.prototype.beginAnimation = function (\r\n        target: any,\r\n        from: number,\r\n        to: number,\r\n        loop?: boolean,\r\n        speedRatio: number = 1.0,\r\n        onAnimationEnd?: () => void,\r\n        animatable?: Animatable,\r\n        stopCurrent = true,\r\n        targetMask?: (target: any) => boolean,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable {\r\n        // get speed speedRatio, to and from, based on the sign and value(s)\r\n        if (speedRatio < 0) {\r\n            const tmp = from;\r\n            from = to;\r\n            to = tmp;\r\n            speedRatio = -speedRatio;\r\n        }\r\n        // if from > to switch speed ratio\r\n        if (from > to) {\r\n            speedRatio = -speedRatio;\r\n        }\r\n        if (stopCurrent) {\r\n            this.stopAnimation(target, undefined, targetMask);\r\n        }\r\n\r\n        if (!animatable) {\r\n            animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\r\n        }\r\n\r\n        const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\r\n        // Local animations\r\n        if (target.animations && shouldRunTargetAnimations) {\r\n            animatable.appendAnimations(target, target.animations);\r\n        }\r\n\r\n        // Children animations\r\n        if (target.getAnimatables) {\r\n            const animatables = target.getAnimatables();\r\n            for (let index = 0; index < animatables.length; index++) {\r\n                this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\r\n            }\r\n        }\r\n\r\n        animatable.reset();\r\n\r\n        return animatable;\r\n    };\r\n\r\n    sceneClass.prototype.beginHierarchyAnimation = function (\r\n        target: any,\r\n        directDescendantsOnly: boolean,\r\n        from: number,\r\n        to: number,\r\n        loop?: boolean,\r\n        speedRatio: number = 1.0,\r\n        onAnimationEnd?: () => void,\r\n        animatable?: Animatable,\r\n        stopCurrent = true,\r\n        targetMask?: (target: any) => boolean,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable[] {\r\n        const children = target.getDescendants(directDescendantsOnly);\r\n\r\n        const result = [];\r\n        result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n        for (const child of children) {\r\n            result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    sceneClass.prototype.beginDirectAnimation = function (\r\n        target: any,\r\n        animations: Animation[],\r\n        from: number,\r\n        to: number,\r\n        loop?: boolean,\r\n        speedRatio: number = 1.0,\r\n        onAnimationEnd?: () => void,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable {\r\n        // get speed speedRatio, to and from, based on the sign and value(s)\r\n        if (speedRatio < 0) {\r\n            const tmp = from;\r\n            from = to;\r\n            to = tmp;\r\n            speedRatio = -speedRatio;\r\n        }\r\n        // if from > to switch speed ratio\r\n        if (from > to) {\r\n            speedRatio = -speedRatio;\r\n        }\r\n        const animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\r\n\r\n        return animatable;\r\n    };\r\n\r\n    sceneClass.prototype.beginDirectHierarchyAnimation = function (\r\n        target: Node,\r\n        directDescendantsOnly: boolean,\r\n        animations: Animation[],\r\n        from: number,\r\n        to: number,\r\n        loop?: boolean,\r\n        speedRatio?: number,\r\n        onAnimationEnd?: () => void,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable[] {\r\n        const children = target.getDescendants(directDescendantsOnly);\r\n\r\n        const result = [];\r\n        result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n        for (const child of children) {\r\n            result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    sceneClass.prototype.getAnimatableByTarget = function (target: any): Nullable<Animatable> {\r\n        for (let index = 0; index < this._activeAnimatables.length; index++) {\r\n            if (this._activeAnimatables[index].target === target) {\r\n                return this._activeAnimatables[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    sceneClass.prototype.getAllAnimatablesByTarget = function (target: any): Array<Animatable> {\r\n        const result = [];\r\n        for (let index = 0; index < this._activeAnimatables.length; index++) {\r\n            if (this._activeAnimatables[index].target === target) {\r\n                result.push(this._activeAnimatables[index]);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    sceneClass.prototype.stopAnimation = function (target: any, animationName?: string, targetMask?: (target: any) => boolean): void {\r\n        const animatables = this.getAllAnimatablesByTarget(target);\r\n\r\n        for (const animatable of animatables) {\r\n            animatable.stop(animationName, targetMask);\r\n        }\r\n    };\r\n\r\n    sceneClass.prototype.stopAllAnimations = function (): void {\r\n        if (this._activeAnimatables) {\r\n            for (let i = 0; i < this._activeAnimatables.length; i++) {\r\n                this._activeAnimatables[i].stop(undefined, undefined, true);\r\n            }\r\n            this._activeAnimatables.length = 0;\r\n        }\r\n\r\n        for (const group of this.animationGroups) {\r\n            group.stop();\r\n        }\r\n    };\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Bone } from \"../Bones/bone\";\r\nimport type { Node } from \"../node\";\r\nimport { AddAnimationExtensions } from \"./animatable.core\";\r\nimport type { Animatable } from \"./animatable.core\";\r\nimport type { Animation } from \"./animation\";\r\nimport { Scene } from \"core/scene\";\r\n\r\nexport * from \"./animatable.core\";\r\n\r\ndeclare module \"../scene\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Scene {\r\n        /**\r\n         * Sort active animatables based on their playOrder property\r\n         */\r\n        sortActiveAnimatables(): void;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param weight defines the weight to apply to the animation (1.0 by default)\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginWeightedAnimation(\r\n            target: any,\r\n            from: number,\r\n            to: number,\r\n            weight: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         *\r\n         * Note that it is possible that the value(s) of speedRatio from and to will be changed if the animation is inverted\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animate if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginAnimation(\r\n            target: any,\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target and its hierarchy\r\n         * @param target defines the target\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginHierarchyAnimation(\r\n            target: any,\r\n            directDescendantsOnly: boolean,\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable[];\r\n\r\n        /**\r\n         * Begin a new animation on a given node\r\n         *\r\n         * Note that it is possible that the value(s) of speedRatio from and to will be changed if the animation is inverted\r\n         * @param target defines the target where the animation will take place\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginDirectAnimation(\r\n            target: any,\r\n            animations: Animation[],\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Begin a new animation on a given node and its hierarchy\r\n         * @param target defines the root node where the animation will take place\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of animatables created for all nodes\r\n         */\r\n        beginDirectHierarchyAnimation(\r\n            target: Node,\r\n            directDescendantsOnly: boolean,\r\n            animations: Animation[],\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable[];\r\n\r\n        /**\r\n         * Gets the animatable associated with a specific target\r\n         * @param target defines the target of the animatable\r\n         * @returns the required animatable if found\r\n         */\r\n        getAnimatableByTarget(target: any): Nullable<Animatable>;\r\n\r\n        /**\r\n         * Gets all animatables associated with a given target\r\n         * @param target defines the target to look animatables for\r\n         * @returns an array of Animatables\r\n         */\r\n        getAllAnimatablesByTarget(target: any): Array<Animatable>;\r\n\r\n        /**\r\n         * Stops and removes all animations that have been applied to the scene\r\n         */\r\n        stopAllAnimations(): void;\r\n    }\r\n}\r\n\r\ndeclare module \"../Bones/bone\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Bone {\r\n        /**\r\n         * Copy an animation range from another bone\r\n         * @param source defines the source bone\r\n         * @param rangeName defines the range name to copy\r\n         * @param frameOffset defines the frame offset\r\n         * @param rescaleAsRequired defines if rescaling must be applied if required\r\n         * @param skelDimensionsRatio defines the scaling ratio\r\n         * @returns true if operation was successful\r\n         */\r\n        copyAnimationRange(source: Bone, rangeName: string, frameOffset: number, rescaleAsRequired: boolean, skelDimensionsRatio: Nullable<Vector3>): boolean;\r\n    }\r\n}\r\n\r\n// Connect everything!\r\nAddAnimationExtensions(Scene, Bone);\r\n", "import type { Animatable } from \"./animatable.core\";\r\nimport { Animation } from \"./animation\";\r\nimport type { IMakeAnimationAdditiveOptions } from \"./animation\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\n\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Node } from \"../node\";\r\n\r\nimport { Tags } from \"../Misc/tags\";\r\nimport type { AnimationGroupMask } from \"./animationGroupMask\";\r\nimport \"./animatable\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport { UniqueIdGenerator } from \"core/Misc/uniqueIdGenerator\";\r\n\r\n/**\r\n * This class defines the direct association between an animation and a target\r\n */\r\nexport class TargetedAnimation {\r\n    /**\r\n     * Animation to perform\r\n     */\r\n    public animation: Animation;\r\n\r\n    /**\r\n     * Target to animate\r\n     */\r\n    public target: any;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the targeted animation\r\n     */\r\n    public readonly uniqueId = UniqueIdGenerator.UniqueId;\r\n\r\n    /**\r\n     * Returns the string \"TargetedAnimation\"\r\n     * @returns \"TargetedAnimation\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetedAnimation\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new targeted animation\r\n     * @param parent The animation group to which the animation belongs\r\n     */\r\n    constructor(public readonly parent: AnimationGroup) {}\r\n\r\n    /**\r\n     * Serialize the object\r\n     * @returns the JSON object representing the current entity\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.animation = this.animation.serialize();\r\n        serializationObject.targetId = this.target.id;\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n\r\n/**\r\n * Options to be used when creating an additive group animation\r\n */\r\nexport interface IMakeAnimationGroupAdditiveOptions extends IMakeAnimationAdditiveOptions {\r\n    /**\r\n     * Defines if the animation group should be cloned or not (default is false)\r\n     */\r\n    cloneOriginalAnimationGroup?: boolean;\r\n    /**\r\n     * The name of the cloned animation group if cloneOriginalAnimationGroup is true\r\n     */\r\n    clonedAnimationGroupName?: string;\r\n}\r\n\r\n/**\r\n * Use this class to create coordinated animations on multiple targets\r\n */\r\nexport class AnimationGroup implements IDisposable {\r\n    private _scene: Scene;\r\n\r\n    private _targetedAnimations = new Array<TargetedAnimation>();\r\n    private _animatables = new Array<Animatable>();\r\n    private _from = Number.MAX_VALUE;\r\n    private _to = -Number.MAX_VALUE;\r\n    private _isStarted: boolean;\r\n    private _isPaused: boolean;\r\n    private _speedRatio = 1;\r\n    private _loopAnimation = false;\r\n    private _isAdditive = false;\r\n    private _weight = -1;\r\n    private _playOrder = 0;\r\n    private _enableBlending: Nullable<boolean> = null;\r\n    private _blendingSpeed: Nullable<number> = null;\r\n    private _numActiveAnimatables = 0;\r\n    private _shouldStart = true;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * This observable will notify when one animation have ended\r\n     */\r\n    public onAnimationEndObservable = new Observable<TargetedAnimation>();\r\n\r\n    /**\r\n     * Observer raised when one animation loops\r\n     */\r\n    public onAnimationLoopObservable = new Observable<TargetedAnimation>();\r\n\r\n    /**\r\n     * Observer raised when all animations have looped\r\n     */\r\n    public onAnimationGroupLoopObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations have ended.\r\n     */\r\n    public onAnimationGroupEndObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations have paused.\r\n     */\r\n    public onAnimationGroupPauseObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations are playing.\r\n     */\r\n    public onAnimationGroupPlayObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the node\r\n     */\r\n    public metadata: any = null;\r\n\r\n    private _mask: Nullable<AnimationGroupMask> = null;\r\n\r\n    /**\r\n     * Gets or sets the mask associated with this animation group. This mask is used to filter which objects should be animated.\r\n     */\r\n    public get mask() {\r\n        return this._mask;\r\n    }\r\n\r\n    public set mask(value: Nullable<AnimationGroupMask>) {\r\n        if (this._mask === value) {\r\n            return;\r\n        }\r\n\r\n        this._mask = value;\r\n\r\n        this.syncWithMask(true);\r\n    }\r\n\r\n    /**\r\n     * Makes sure that the animations are either played or stopped according to the animation group mask.\r\n     * Note however that the call won't have any effect if the animation group has not been started yet.\r\n     * @param forceUpdate If true, forces to loop over the animatables even if no mask is defined (used internally, you shouldn't need to use it). Default: false.\r\n     */\r\n    public syncWithMask(forceUpdate = false) {\r\n        if (!this.mask && !forceUpdate) {\r\n            this._numActiveAnimatables = this._targetedAnimations.length;\r\n            return;\r\n        }\r\n\r\n        this._numActiveAnimatables = 0;\r\n\r\n        for (let i = 0; i < this._animatables.length; ++i) {\r\n            const animatable = this._animatables[i];\r\n\r\n            if (!this.mask || this.mask.disabled || this.mask.retainsTarget(animatable.target.name)) {\r\n                this._numActiveAnimatables++;\r\n                if (animatable.paused) {\r\n                    animatable.restart();\r\n                }\r\n            } else {\r\n                if (!animatable.paused) {\r\n                    animatable.pause();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all animations for the targets not retained by the animation group mask.\r\n     * Use this function if you know you won't need those animations anymore and if you want to free memory.\r\n     */\r\n    public removeUnmaskedAnimations() {\r\n        if (!this.mask || this.mask.disabled) {\r\n            return;\r\n        }\r\n\r\n        // Removes all animatables (in case the animation group has already been started)\r\n        for (let i = 0; i < this._animatables.length; ++i) {\r\n            const animatable = this._animatables[i];\r\n\r\n            if (!this.mask.retainsTarget(animatable.target.name)) {\r\n                animatable.stop();\r\n                this._animatables.splice(i, 1);\r\n                --i;\r\n            }\r\n        }\r\n\r\n        // Removes the targeted animations\r\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n\r\n            if (!this.mask.retainsTarget(targetedAnimation.target.name)) {\r\n                this._targetedAnimations.splice(index, 1);\r\n                --index;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the first frame\r\n     */\r\n    public get from(): number {\r\n        return this._from;\r\n    }\r\n\r\n    public set from(value: number) {\r\n        if (this._from === value) {\r\n            return;\r\n        }\r\n\r\n        this._from = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.fromFrame = this._from;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the last frame\r\n     */\r\n    public get to(): number {\r\n        return this._to;\r\n    }\r\n\r\n    public set to(value: number) {\r\n        if (this._to === value) {\r\n            return;\r\n        }\r\n\r\n        this._to = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.toFrame = this._to;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the animations are started\r\n     */\r\n    public get isStarted(): boolean {\r\n        return this._isStarted;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating that the current group is playing\r\n     */\r\n    public get isPlaying(): boolean {\r\n        return this._isStarted && !this._isPaused;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._speedRatio;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\r\n    public set speedRatio(value: number) {\r\n        if (this._speedRatio === value) {\r\n            return;\r\n        }\r\n\r\n        this._speedRatio = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.speedRatio = this._speedRatio;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets if all animations should loop or not\r\n     */\r\n    public get loopAnimation(): boolean {\r\n        return this._loopAnimation;\r\n    }\r\n\r\n    public set loopAnimation(value: boolean) {\r\n        if (this._loopAnimation === value) {\r\n            return;\r\n        }\r\n\r\n        this._loopAnimation = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.loopAnimation = this._loopAnimation;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets if all animations should be evaluated additively\r\n     */\r\n    public get isAdditive(): boolean {\r\n        return this._isAdditive;\r\n    }\r\n\r\n    public set isAdditive(value: boolean) {\r\n        if (this._isAdditive === value) {\r\n            return;\r\n        }\r\n\r\n        this._isAdditive = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.isAdditive = this._isAdditive;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the weight to apply to all animations of the group\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    public set weight(value: number) {\r\n        if (this._weight === value) {\r\n            return;\r\n        }\r\n\r\n        this._weight = value;\r\n        this.setWeightForAllAnimatables(this._weight);\r\n    }\r\n\r\n    /**\r\n     * Gets the targeted animations for this animation group\r\n     */\r\n    public get targetedAnimations(): Array<TargetedAnimation> {\r\n        return this._targetedAnimations;\r\n    }\r\n\r\n    /**\r\n     * returning the list of animatables controlled by this animation group.\r\n     */\r\n    public get animatables(): Array<Animatable> {\r\n        return this._animatables;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of target animations\r\n     */\r\n    public get children() {\r\n        return this._targetedAnimations;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the order of play of the animation group (default: 0)\r\n     */\r\n    public get playOrder() {\r\n        return this._playOrder;\r\n    }\r\n\r\n    public set playOrder(value: number) {\r\n        if (this._playOrder === value) {\r\n            return;\r\n        }\r\n\r\n        this._playOrder = value;\r\n\r\n        if (this._animatables.length > 0) {\r\n            for (let i = 0; i < this._animatables.length; i++) {\r\n                this._animatables[i].playOrder = this._playOrder;\r\n            }\r\n\r\n            this._scene.sortActiveAnimatables();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allows the animations of the animation group to blend with current running animations\r\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.enableBlending)\r\n     */\r\n    public get enableBlending() {\r\n        return this._enableBlending;\r\n    }\r\n\r\n    public set enableBlending(value: Nullable<boolean>) {\r\n        if (this._enableBlending === value) {\r\n            return;\r\n        }\r\n\r\n        this._enableBlending = value;\r\n\r\n        if (value !== null) {\r\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\r\n                this._targetedAnimations[i].animation.enableBlending = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the animation blending speed\r\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.blendingSpeed)\r\n     */\r\n    public get blendingSpeed() {\r\n        return this._blendingSpeed;\r\n    }\r\n\r\n    public set blendingSpeed(value: Nullable<number>) {\r\n        if (this._blendingSpeed === value) {\r\n            return;\r\n        }\r\n\r\n        this._blendingSpeed = value;\r\n\r\n        if (value !== null) {\r\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\r\n                this._targetedAnimations[i].animation.blendingSpeed = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the length (in seconds) of the animation group\r\n     * This function assumes that all animations are played at the same framePerSecond speed!\r\n     * Note: you can only call this method after you've added at least one targeted animation!\r\n     * @param from Starting frame range (default is AnimationGroup.from)\r\n     * @param to Ending frame range (default is AnimationGroup.to)\r\n     * @returns The length in seconds\r\n     */\r\n    public getLength(from?: number, to?: number): number {\r\n        from = from ?? this._from;\r\n        to = to ?? this._to;\r\n\r\n        const fps = this.targetedAnimations[0].animation.framePerSecond * this._speedRatio;\r\n\r\n        return (to - from) / fps;\r\n    }\r\n\r\n    /**\r\n     * Merge the array of animation groups into a new animation group\r\n     * @param animationGroups List of animation groups to merge\r\n     * @param disposeSource If true, animation groups will be disposed after being merged (default: true)\r\n     * @param normalize If true, animation groups will be normalized before being merged, so that all animations have the same \"from\" and \"to\" frame (default: false)\r\n     * @param weight Weight for the new animation group. If not provided, it will inherit the weight from the first animation group of the array\r\n     * @returns The new animation group or null if no animation groups were passed\r\n     */\r\n    public static MergeAnimationGroups(animationGroups: Array<AnimationGroup>, disposeSource = true, normalize = false, weight?: number): Nullable<AnimationGroup> {\r\n        if (animationGroups.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        weight = weight ?? animationGroups[0].weight;\r\n\r\n        let beginFrame = Number.MAX_VALUE;\r\n        let endFrame = -Number.MAX_VALUE;\r\n\r\n        if (normalize) {\r\n            for (const animationGroup of animationGroups) {\r\n                if (animationGroup.from < beginFrame) {\r\n                    beginFrame = animationGroup.from;\r\n                }\r\n\r\n                if (animationGroup.to > endFrame) {\r\n                    endFrame = animationGroup.to;\r\n                }\r\n            }\r\n        }\r\n\r\n        const mergedAnimationGroup = new AnimationGroup(animationGroups[0].name + \"_merged\", animationGroups[0]._scene, weight);\r\n\r\n        for (const animationGroup of animationGroups) {\r\n            if (normalize) {\r\n                animationGroup.normalize(beginFrame, endFrame);\r\n            }\r\n\r\n            for (const targetedAnimation of animationGroup.targetedAnimations) {\r\n                mergedAnimationGroup.addTargetedAnimation(targetedAnimation.animation, targetedAnimation.target);\r\n            }\r\n\r\n            if (disposeSource) {\r\n                animationGroup.dispose();\r\n            }\r\n        }\r\n\r\n        return mergedAnimationGroup;\r\n    }\r\n\r\n    /**\r\n     * Gets the scene the animation group belongs to\r\n     * @returns The scene the animation group belongs to\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new Animation Group.\r\n     * This helps managing several animations at once.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\r\n     * @param name Defines the name of the group\r\n     * @param scene Defines the scene the group belongs to\r\n     * @param weight Defines the weight to use for animations in the group (-1.0 by default, meaning \"no weight\")\r\n     * @param playOrder Defines the order of play of the animation group (default is 0)\r\n     */\r\n    public constructor(\r\n        /** The name of the animation group */\r\n        public name: string,\r\n        scene: Nullable<Scene> = null,\r\n        weight = -1,\r\n        playOrder = 0\r\n    ) {\r\n        this._scene = scene || EngineStore.LastCreatedScene!;\r\n        this._weight = weight;\r\n        this._playOrder = playOrder;\r\n        this.uniqueId = this._scene.getUniqueId();\r\n\r\n        this._scene.addAnimationGroup(this);\r\n    }\r\n\r\n    /**\r\n     * Add an animation (with its target) in the group\r\n     * @param animation defines the animation we want to add\r\n     * @param target defines the target of the animation\r\n     * @returns the TargetedAnimation object\r\n     */\r\n    public addTargetedAnimation(animation: Animation, target: any): TargetedAnimation {\r\n        const targetedAnimation = new TargetedAnimation(this);\r\n        targetedAnimation.animation = animation;\r\n        targetedAnimation.target = target;\r\n\r\n        const keys = animation.getKeys();\r\n        if (this._from > keys[0].frame) {\r\n            this._from = keys[0].frame;\r\n        }\r\n\r\n        if (this._to < keys[keys.length - 1].frame) {\r\n            this._to = keys[keys.length - 1].frame;\r\n        }\r\n\r\n        if (this._enableBlending !== null) {\r\n            animation.enableBlending = this._enableBlending;\r\n        }\r\n\r\n        if (this._blendingSpeed !== null) {\r\n            animation.blendingSpeed = this._blendingSpeed;\r\n        }\r\n\r\n        this._targetedAnimations.push(targetedAnimation);\r\n        this._shouldStart = true;\r\n\r\n        return targetedAnimation;\r\n    }\r\n\r\n    /**\r\n     * Remove an animation from the group\r\n     * @param animation defines the animation we want to remove\r\n     */\r\n    public removeTargetedAnimation(animation: Animation) {\r\n        for (let index = this._targetedAnimations.length - 1; index > -1; index--) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            if (targetedAnimation.animation === animation) {\r\n                this._targetedAnimations.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\r\n     * It can add constant keys at begin or end\r\n     * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\r\n     * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\r\n     * @returns the animation group\r\n     */\r\n    public normalize(beginFrame: Nullable<number> = null, endFrame: Nullable<number> = null): AnimationGroup {\r\n        if (beginFrame == null) {\r\n            beginFrame = this._from;\r\n        }\r\n        if (endFrame == null) {\r\n            endFrame = this._to;\r\n        }\r\n\r\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            const keys = targetedAnimation.animation.getKeys();\r\n            const startKey = keys[0];\r\n            const endKey = keys[keys.length - 1];\r\n\r\n            if (startKey.frame > beginFrame) {\r\n                const newKey: IAnimationKey = {\r\n                    frame: beginFrame,\r\n                    value: startKey.value,\r\n                    inTangent: startKey.inTangent,\r\n                    outTangent: startKey.outTangent,\r\n                    interpolation: startKey.interpolation,\r\n                };\r\n                keys.splice(0, 0, newKey);\r\n            }\r\n\r\n            if (endKey.frame < endFrame) {\r\n                const newKey: IAnimationKey = {\r\n                    frame: endFrame,\r\n                    value: endKey.value,\r\n                    inTangent: endKey.inTangent,\r\n                    outTangent: endKey.outTangent,\r\n                    interpolation: endKey.interpolation,\r\n                };\r\n                keys.push(newKey);\r\n            }\r\n        }\r\n\r\n        this._from = beginFrame;\r\n        this._to = endFrame;\r\n\r\n        return this;\r\n    }\r\n\r\n    private _animationLoopCount: number;\r\n    private _animationLoopFlags: boolean[] = [];\r\n\r\n    private _processLoop(animatable: Animatable, targetedAnimation: TargetedAnimation, index: number) {\r\n        animatable.onAnimationLoop = () => {\r\n            this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\r\n\r\n            if (this._animationLoopFlags[index]) {\r\n                return;\r\n            }\r\n\r\n            this._animationLoopFlags[index] = true;\r\n\r\n            this._animationLoopCount++;\r\n            if (this._animationLoopCount === this._numActiveAnimatables) {\r\n                this.onAnimationGroupLoopObservable.notifyObservers(this);\r\n                this._animationLoopCount = 0;\r\n                this._animationLoopFlags.length = 0;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Start all animations on given targets\r\n     * @param loop defines if animations must loop\r\n     * @param speedRatio defines the ratio to apply to animation speed (1 by default)\r\n     * @param from defines the from key (optional)\r\n     * @param to defines the to key (optional)\r\n     * @param isAdditive defines the additive state for the resulting animatables (optional)\r\n     * @returns the current animation group\r\n     */\r\n    public start(loop = false, speedRatio = 1, from?: number, to?: number, isAdditive?: boolean): AnimationGroup {\r\n        if (this._isStarted || this._targetedAnimations.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        this._loopAnimation = loop;\r\n\r\n        this._shouldStart = false;\r\n        this._animationLoopCount = 0;\r\n        this._animationLoopFlags.length = 0;\r\n\r\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            const animatable = this._scene.beginDirectAnimation(\r\n                targetedAnimation.target,\r\n                [targetedAnimation.animation],\r\n                from !== undefined ? from : this._from,\r\n                to !== undefined ? to : this._to,\r\n                loop,\r\n                speedRatio,\r\n                undefined,\r\n                undefined,\r\n                isAdditive !== undefined ? isAdditive : this._isAdditive\r\n            );\r\n            animatable.weight = this._weight;\r\n            animatable.playOrder = this._playOrder;\r\n            animatable.onAnimationEnd = () => {\r\n                this.onAnimationEndObservable.notifyObservers(targetedAnimation);\r\n                this._checkAnimationGroupEnded(animatable);\r\n            };\r\n\r\n            this._processLoop(animatable, targetedAnimation, index);\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        this.syncWithMask();\r\n\r\n        this._scene.sortActiveAnimatables();\r\n\r\n        this._speedRatio = speedRatio;\r\n\r\n        this._isStarted = true;\r\n        this._isPaused = false;\r\n\r\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Pause all animations\r\n     * @returns the animation group\r\n     */\r\n    public pause(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        this._isPaused = true;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.pause();\r\n        }\r\n\r\n        this.onAnimationGroupPauseObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Play all animations to initial state\r\n     * This function will start() the animations if they were not started or will restart() them if they were paused\r\n     * @param loop defines if animations must loop\r\n     * @returns the animation group\r\n     */\r\n    public play(loop?: boolean): AnimationGroup {\r\n        // only if there are animatable available\r\n        if (this.isStarted && this._animatables.length && !this._shouldStart) {\r\n            if (loop !== undefined) {\r\n                this.loopAnimation = loop;\r\n            }\r\n            this.restart();\r\n        } else {\r\n            this.stop();\r\n            this.start(loop, this._speedRatio);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reset all animations to initial state\r\n     * @returns the animation group\r\n     */\r\n    public reset(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            this.play();\r\n            this.goToFrame(0);\r\n            this.stop(true);\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.reset();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Restart animations from after pausing it\r\n     * @returns the animation group\r\n     */\r\n    public restart(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.restart();\r\n        }\r\n\r\n        this.syncWithMask();\r\n\r\n        this._isPaused = false;\r\n\r\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Stop all animations\r\n     * @param skipOnAnimationEnd defines if the system should not raise onAnimationEnd. Default is false\r\n     * @returns the animation group\r\n     */\r\n    public stop(skipOnAnimationEnd = false): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        const list = this._animatables.slice();\r\n        for (let index = 0; index < list.length; index++) {\r\n            list[index].stop(undefined, undefined, true, skipOnAnimationEnd);\r\n        }\r\n\r\n        // We will take care of removing all stopped animatables\r\n        let curIndex = 0;\r\n        for (let index = 0; index < this._scene._activeAnimatables.length; index++) {\r\n            const animatable = this._scene._activeAnimatables[index];\r\n            if (animatable._runtimeAnimations.length > 0) {\r\n                this._scene._activeAnimatables[curIndex++] = animatable;\r\n            } else if (skipOnAnimationEnd) {\r\n                // We normally rely on the onAnimationEnd callback (assigned in the start function) to be notified when an animatable\r\n                // ends and should be removed from the active animatables array. However, if the animatable is stopped with the skipOnAnimationEnd\r\n                // flag set to true, then we need to explicitly remove it from the active animatables array.\r\n                this._checkAnimationGroupEnded(animatable, skipOnAnimationEnd);\r\n            }\r\n        }\r\n        this._scene._activeAnimatables.length = curIndex;\r\n\r\n        this._isStarted = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set animation weight for all animatables\r\n     *\r\n     * @since 6.12.4\r\n     *  You can pass the weight to the AnimationGroup constructor, or use the weight property to set it after the group has been created,\r\n     *  making it easier to define the overall animation weight than calling setWeightForAllAnimatables() after the animation group has been started\r\n     * @param weight defines the weight to use\r\n     * @returns the animationGroup\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\r\n     */\r\n    public setWeightForAllAnimatables(weight: number): AnimationGroup {\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.weight = weight;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Synchronize and normalize all animatables with a source animatable\r\n     * @param root defines the root animatable to synchronize with (null to stop synchronizing)\r\n     * @returns the animationGroup\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\r\n     */\r\n    public syncAllAnimationsWith(root: Nullable<Animatable>): AnimationGroup {\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.syncWith(root);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Goes to a specific frame in this animation group. Note that the animation group must be in playing or paused status\r\n     * @param frame the frame number to go to\r\n     * @param useWeight defines whether the animation weight should be applied to the image to be jumped to (false by default)\r\n     * @returns the animationGroup\r\n     */\r\n    public goToFrame(frame: number, useWeight = false): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.goToFrame(frame, useWeight);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Helper to get the current frame. This will return 0 if the AnimationGroup is not running, and it might return wrong results if multiple animations are running in different frames.\r\n     * @returns current animation frame.\r\n     */\r\n    public getCurrentFrame(): number {\r\n        return this.animatables[0]?.masterFrame || 0;\r\n    }\r\n\r\n    /**\r\n     * Dispose all associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this.isStarted) {\r\n            this.stop();\r\n        }\r\n        this._targetedAnimations.length = 0;\r\n        this._animatables.length = 0;\r\n\r\n        // Remove from scene\r\n        this._scene.removeAnimationGroup(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.animationGroups.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.animationGroups.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        this.onAnimationEndObservable.clear();\r\n        this.onAnimationGroupEndObservable.clear();\r\n        this.onAnimationGroupPauseObservable.clear();\r\n        this.onAnimationGroupPlayObservable.clear();\r\n        this.onAnimationLoopObservable.clear();\r\n        this.onAnimationGroupLoopObservable.clear();\r\n    }\r\n\r\n    private _checkAnimationGroupEnded(animatable: Animatable, skipOnAnimationEnd = false) {\r\n        // animatable should be taken out of the array\r\n        const idx = this._animatables.indexOf(animatable);\r\n        if (idx > -1) {\r\n            this._animatables.splice(idx, 1);\r\n        }\r\n\r\n        // all animatables were removed? animation group ended!\r\n        if (this._animatables.length === this._targetedAnimations.length - this._numActiveAnimatables) {\r\n            this._isStarted = false;\r\n            if (!skipOnAnimationEnd) {\r\n                this.onAnimationGroupEndObservable.notifyObservers(this);\r\n            }\r\n            this._animatables.length = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current animation group and returns a copy\r\n     * @param newName defines the name of the new group\r\n     * @param targetConverter defines an optional function used to convert current animation targets to new ones\r\n     * @param cloneAnimations defines if the animations should be cloned or referenced\r\n     * @returns the new animation group\r\n     */\r\n    public clone(newName: string, targetConverter?: (oldTarget: any) => any, cloneAnimations = false): AnimationGroup {\r\n        const newGroup = new AnimationGroup(newName || this.name, this._scene, this._weight, this._playOrder);\r\n\r\n        newGroup._from = this.from;\r\n        newGroup._to = this.to;\r\n        newGroup._speedRatio = this.speedRatio;\r\n        newGroup._loopAnimation = this.loopAnimation;\r\n        newGroup._isAdditive = this.isAdditive;\r\n        newGroup._enableBlending = this.enableBlending;\r\n        newGroup._blendingSpeed = this.blendingSpeed;\r\n        newGroup.metadata = this.metadata;\r\n        newGroup.mask = this.mask;\r\n\r\n        for (const targetAnimation of this._targetedAnimations) {\r\n            newGroup.addTargetedAnimation(\r\n                cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation,\r\n                targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target\r\n            );\r\n        }\r\n\r\n        return newGroup;\r\n    }\r\n\r\n    /**\r\n     * Serializes the animationGroup to an object\r\n     * @returns Serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.from = this.from;\r\n        serializationObject.to = this.to;\r\n        serializationObject.speedRatio = this.speedRatio;\r\n        serializationObject.loopAnimation = this.loopAnimation;\r\n        serializationObject.isAdditive = this.isAdditive;\r\n        serializationObject.weight = this.weight;\r\n        serializationObject.playOrder = this.playOrder;\r\n        serializationObject.enableBlending = this.enableBlending;\r\n        serializationObject.blendingSpeed = this.blendingSpeed;\r\n\r\n        serializationObject.targetedAnimations = [];\r\n        for (let targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\r\n            const targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\r\n            serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\r\n        }\r\n\r\n        if (Tags && Tags.HasTags(this)) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n\r\n        // Metadata\r\n        if (this.metadata) {\r\n            serializationObject.metadata = this.metadata;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Returns a new AnimationGroup object parsed from the source provided.\r\n     * @param parsedAnimationGroup defines the source\r\n     * @param scene defines the scene that will receive the animationGroup\r\n     * @param nodeMap a map of node.id to node in this scene, to accelerate node lookup\r\n     * @returns a new AnimationGroup\r\n     */\r\n    public static Parse(parsedAnimationGroup: any, scene: Scene, nodeMap?: Map<Node[\"id\"], Node>): AnimationGroup {\r\n        const animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene, parsedAnimationGroup.weight, parsedAnimationGroup.playOrder);\r\n        for (let i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\r\n            const targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\r\n            const animation = Animation.Parse(targetedAnimation.animation);\r\n            const id = targetedAnimation.targetId;\r\n            if (targetedAnimation.animation.property === \"influence\") {\r\n                // morph target animation\r\n                const morphTarget = scene.getMorphTargetById(id);\r\n                if (morphTarget) {\r\n                    animationGroup.addTargetedAnimation(animation, morphTarget);\r\n                }\r\n            } else {\r\n                const targetNode = nodeMap ? nodeMap.get(id) : scene.getNodeById(id);\r\n\r\n                if (targetNode != null) {\r\n                    animationGroup.addTargetedAnimation(animation, targetNode);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);\r\n        }\r\n\r\n        if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\r\n            animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\r\n        }\r\n\r\n        if (parsedAnimationGroup.speedRatio !== undefined) {\r\n            animationGroup._speedRatio = parsedAnimationGroup.speedRatio;\r\n        }\r\n        if (parsedAnimationGroup.loopAnimation !== undefined) {\r\n            animationGroup._loopAnimation = parsedAnimationGroup.loopAnimation;\r\n        }\r\n\r\n        if (parsedAnimationGroup.isAdditive !== undefined) {\r\n            animationGroup._isAdditive = parsedAnimationGroup.isAdditive;\r\n        }\r\n\r\n        if (parsedAnimationGroup.weight !== undefined) {\r\n            animationGroup._weight = parsedAnimationGroup.weight;\r\n        }\r\n\r\n        if (parsedAnimationGroup.playOrder !== undefined) {\r\n            animationGroup._playOrder = parsedAnimationGroup.playOrder;\r\n        }\r\n\r\n        if (parsedAnimationGroup.enableBlending !== undefined) {\r\n            animationGroup._enableBlending = parsedAnimationGroup.enableBlending;\r\n        }\r\n\r\n        if (parsedAnimationGroup.blendingSpeed !== undefined) {\r\n            animationGroup._blendingSpeed = parsedAnimationGroup.blendingSpeed;\r\n        }\r\n\r\n        if (parsedAnimationGroup.metadata !== undefined) {\r\n            animationGroup.metadata = parsedAnimationGroup.metadata;\r\n        }\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n     * @param sourceAnimationGroup defines the AnimationGroup containing animations to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to (default: 0)\r\n     * @param range defines the name of the AnimationRange belonging to the animations in the group to convert\r\n     * @param cloneOriginal defines whether or not to clone the group and convert the clone or convert the original group (default is false)\r\n     * @param clonedName defines the name of the resulting cloned AnimationGroup if cloneOriginal is true\r\n     * @returns a new AnimationGroup if cloneOriginal is true or the original AnimationGroup if cloneOriginal is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimationGroup: AnimationGroup, referenceFrame: number, range?: string, cloneOriginal?: boolean, clonedName?: string): AnimationGroup;\r\n\r\n    /**\r\n     * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n     * @param sourceAnimationGroup defines the AnimationGroup containing animations to convert\r\n     * @param options defines the options to use when converting keyframes\r\n     * @returns a new AnimationGroup if options.cloneOriginalAnimationGroup is true or the original AnimationGroup if options.cloneOriginalAnimationGroup is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimationGroup: AnimationGroup, options?: IMakeAnimationGroupAdditiveOptions): AnimationGroup;\r\n\r\n    /** @internal */\r\n    public static MakeAnimationAdditive(\r\n        sourceAnimationGroup: AnimationGroup,\r\n        referenceFrameOrOptions?: number | IMakeAnimationGroupAdditiveOptions,\r\n        range?: string,\r\n        cloneOriginal = false,\r\n        clonedName?: string\r\n    ): AnimationGroup {\r\n        let options: IMakeAnimationGroupAdditiveOptions;\r\n\r\n        if (typeof referenceFrameOrOptions === \"object\") {\r\n            options = referenceFrameOrOptions;\r\n        } else {\r\n            options = {\r\n                referenceFrame: referenceFrameOrOptions,\r\n                range: range,\r\n                cloneOriginalAnimationGroup: cloneOriginal,\r\n                clonedAnimationName: clonedName,\r\n            };\r\n        }\r\n\r\n        let animationGroup = sourceAnimationGroup;\r\n        if (options.cloneOriginalAnimationGroup) {\r\n            animationGroup = sourceAnimationGroup.clone(options.clonedAnimationGroupName || animationGroup.name);\r\n        }\r\n\r\n        const targetedAnimations = animationGroup.targetedAnimations;\r\n        for (let index = 0; index < targetedAnimations.length; index++) {\r\n            const targetedAnimation = targetedAnimations[index];\r\n            targetedAnimation.animation = Animation.MakeAnimationAdditive(targetedAnimation.animation, options);\r\n        }\r\n\r\n        animationGroup.isAdditive = true;\r\n\r\n        if (options.clipKeys) {\r\n            // We need to recalculate the from/to frames for the animation group because some keys may have been removed\r\n            let from = Number.MAX_VALUE;\r\n            let to = -Number.MAX_VALUE;\r\n\r\n            const targetedAnimations = animationGroup.targetedAnimations;\r\n            for (let index = 0; index < targetedAnimations.length; index++) {\r\n                const targetedAnimation = targetedAnimations[index];\r\n                const animation = targetedAnimation.animation;\r\n                const keys = animation.getKeys();\r\n\r\n                if (from > keys[0].frame) {\r\n                    from = keys[0].frame;\r\n                }\r\n\r\n                if (to < keys[keys.length - 1].frame) {\r\n                    to = keys[keys.length - 1].frame;\r\n                }\r\n            }\r\n\r\n            animationGroup._from = from;\r\n            animationGroup._to = to;\r\n        }\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation, keeping only the keys that are inside a given key range\r\n     * @param sourceAnimationGroup defines the animation group on which to operate\r\n     * @param fromKey defines the lower bound of the range\r\n     * @param toKey defines the upper bound of the range\r\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\r\n     * @returns a new animation group stripped from all the keys outside the given range\r\n     */\r\n    public static ClipKeys(sourceAnimationGroup: AnimationGroup, fromKey: number, toKey: number, name?: string, dontCloneAnimations?: boolean): AnimationGroup {\r\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\r\n\r\n        return AnimationGroup.ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations);\r\n    }\r\n\r\n    /**\r\n     * Updates an existing animation, keeping only the keys that are inside a given key range\r\n     * @param animationGroup defines the animation group on which to operate\r\n     * @param fromKey defines the lower bound of the range\r\n     * @param toKey defines the upper bound of the range\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\r\n     * @returns the animationGroup stripped from all the keys outside the given range\r\n     */\r\n    public static ClipKeysInPlace(animationGroup: AnimationGroup, fromKey: number, toKey: number, dontCloneAnimations?: boolean): AnimationGroup {\r\n        return AnimationGroup.ClipInPlace(animationGroup, fromKey, toKey, dontCloneAnimations, false);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation, keeping only the frames that are inside a given frame range\r\n     * @param sourceAnimationGroup defines the animation group on which to operate\r\n     * @param fromFrame defines the lower bound of the range\r\n     * @param toFrame defines the upper bound of the range\r\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\r\n     * @returns a new animation group stripped from all the frames outside the given range\r\n     */\r\n    public static ClipFrames(sourceAnimationGroup: AnimationGroup, fromFrame: number, toFrame: number, name?: string, dontCloneAnimations?: boolean): AnimationGroup {\r\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\r\n\r\n        return AnimationGroup.ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations);\r\n    }\r\n\r\n    /**\r\n     * Updates an existing animation, keeping only the frames that are inside a given frame range\r\n     * @param animationGroup defines the animation group on which to operate\r\n     * @param fromFrame defines the lower bound of the range\r\n     * @param toFrame defines the upper bound of the range\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\r\n     * @returns the animationGroup stripped from all the frames outside the given range\r\n     */\r\n    public static ClipFramesInPlace(animationGroup: AnimationGroup, fromFrame: number, toFrame: number, dontCloneAnimations?: boolean): AnimationGroup {\r\n        return AnimationGroup.ClipInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations, true);\r\n    }\r\n\r\n    /**\r\n     * Updates an existing animation, keeping only the keys that are inside a given key or frame range\r\n     * @param animationGroup defines the animation group on which to operate\r\n     * @param start defines the lower bound of the range\r\n     * @param end defines the upper bound of the range\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\r\n     * @param useFrame defines if the range is defined by frame numbers or key indices (default is false which means use key indices)\r\n     * @returns the animationGroup stripped from all the keys outside the given range\r\n     */\r\n    public static ClipInPlace(animationGroup: AnimationGroup, start: number, end: number, dontCloneAnimations?: boolean, useFrame = false): AnimationGroup {\r\n        let from = Number.MAX_VALUE;\r\n        let to = -Number.MAX_VALUE;\r\n\r\n        const targetedAnimations = animationGroup.targetedAnimations;\r\n        for (let index = 0; index < targetedAnimations.length; index++) {\r\n            const targetedAnimation = targetedAnimations[index];\r\n            const animation = dontCloneAnimations ? targetedAnimation.animation : targetedAnimation.animation.clone();\r\n\r\n            if (useFrame) {\r\n                // Make sure we have keys corresponding to the bounds of the frame range\r\n                animation.createKeyForFrame(start);\r\n                animation.createKeyForFrame(end);\r\n            }\r\n\r\n            const keys = animation.getKeys();\r\n            const newKeys: IAnimationKey[] = [];\r\n\r\n            let startFrame = Number.MAX_VALUE;\r\n            for (let k = 0; k < keys.length; k++) {\r\n                const key = keys[k];\r\n                if ((!useFrame && k >= start && k <= end) || (useFrame && key.frame >= start && key.frame <= end)) {\r\n                    const newKey: IAnimationKey = {\r\n                        frame: key.frame,\r\n                        value: key.value.clone ? key.value.clone() : key.value,\r\n                        inTangent: key.inTangent,\r\n                        outTangent: key.outTangent,\r\n                        interpolation: key.interpolation,\r\n                        lockedTangent: key.lockedTangent,\r\n                    };\r\n                    if (startFrame === Number.MAX_VALUE) {\r\n                        startFrame = newKey.frame;\r\n                    }\r\n                    newKey.frame -= startFrame;\r\n                    newKeys.push(newKey);\r\n                }\r\n            }\r\n\r\n            if (newKeys.length === 0) {\r\n                targetedAnimations.splice(index, 1);\r\n                index--;\r\n                continue;\r\n            }\r\n\r\n            if (from > newKeys[0].frame) {\r\n                from = newKeys[0].frame;\r\n            }\r\n\r\n            if (to < newKeys[newKeys.length - 1].frame) {\r\n                to = newKeys[newKeys.length - 1].frame;\r\n            }\r\n\r\n            animation.setKeys(newKeys, true);\r\n            targetedAnimation.animation = animation; // in case the animation has been cloned\r\n        }\r\n\r\n        animationGroup._from = from;\r\n        animationGroup._to = to;\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"AnimationGroup\"\r\n     * @returns \"AnimationGroup\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"AnimationGroup\";\r\n    }\r\n\r\n    /**\r\n     * Creates a detailed string about the object\r\n     * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\r\n     * @returns a string representing the object\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + this.getClassName();\r\n        if (fullDetails) {\r\n            ret += \", from: \" + this._from;\r\n            ret += \", to: \" + this._to;\r\n            ret += \", isStarted: \" + this._isStarted;\r\n            ret += \", speedRatio: \" + this._speedRatio;\r\n            ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\r\n            ret += \", animatables length: \" + this._animatables;\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["index", "target", "index", "targetedAnimations"]
}
