import {
  EffectRenderer,
  EffectWrapper,
  init_effectRenderer
} from "./chunk-4L5VDV4X.js";
import {
  __decorate,
  init_decorators,
  init_tslib_es6,
  nativeOverride
} from "./chunk-KU6EWKFQ.js";
import {
  Tools,
  init_tools
} from "./chunk-TQMUJQOB.js";
import {
  EncodeArrayBufferToBase64,
  init_stringTools
} from "./chunk-X7JT3LZV.js";
import {
  EngineStore,
  init_engineStore
} from "./chunk-TS7QJBPS.js";
import {
  Clamp,
  init_math_scalar_functions
} from "./chunk-XBFJXXXT.js";
import {
  Logger,
  init_logger
} from "./chunk-2X44KPCK.js";
import {
  __esm
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@babylonjs/core/Misc/dumpTools.js
async function _CreateDumpResourcesAsync() {
  const canvas = EngineStore.LastCreatedEngine?.createCanvas(100, 100) ?? new OffscreenCanvas(100, 100);
  if (canvas instanceof OffscreenCanvas) {
    Logger.Warn("DumpData: OffscreenCanvas will be used for dumping data. This may result in lossy alpha values.");
  }
  const { ThinEngine: thinEngineClass } = await import("./thinEngine-HLPBKEJ7.js");
  if (!thinEngineClass.IsSupported) {
    throw new Error("DumpData: No WebGL context available. Cannot dump data.");
  }
  const options = {
    preserveDrawingBuffer: true,
    depth: false,
    stencil: false,
    alpha: true,
    premultipliedAlpha: false,
    antialias: false,
    failIfMajorPerformanceCaveat: false
  };
  const engine = new thinEngineClass(canvas, false, options);
  EngineStore.Instances.pop();
  EngineStore.OnEnginesDisposedObservable.add((e) => {
    if (engine && e !== engine && !engine.isDisposed && EngineStore.Instances.length === 0) {
      Dispose();
    }
  });
  engine.getCaps().parallelShaderCompile = void 0;
  const renderer = new EffectRenderer(engine);
  const { passPixelShader } = await import("./pass.fragment-GQ4PNZOK.js");
  const wrapper = new EffectWrapper({
    engine,
    name: passPixelShader.name,
    fragmentShader: passPixelShader.shader,
    samplerNames: ["textureSampler"]
  });
  return {
    canvas,
    dumpEngine: { engine, renderer, wrapper }
  };
}
async function _GetDumpResourcesAsync() {
  if (!ResourcesPromise) {
    ResourcesPromise = _CreateDumpResourcesAsync();
  }
  return await ResourcesPromise;
}
async function DumpFramebuffer(width, height, engine, successCallback, mimeType = "image/png", fileName, quality) {
  const bufferView = await engine.readPixels(0, 0, width, height);
  const data = new Uint8Array(bufferView.buffer);
  DumpData(width, height, data, successCallback, mimeType, fileName, true, void 0, quality);
}
async function DumpDataAsync(width, height, data, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
  if (data instanceof Float32Array) {
    const data2 = new Uint8Array(data.length);
    let n = data.length;
    while (n--) {
      const v = data[n];
      data2[n] = Math.round(Clamp(v) * 255);
    }
    data = data2;
  }
  const blob = await EncodingHelper.EncodeImageAsync(data, width, height, mimeType, invertY, quality);
  if (fileName !== void 0) {
    Tools.DownloadBlob(blob, fileName);
  }
  if (blob.type !== mimeType) {
    Logger.Warn(`DumpData: The requested mimeType '${mimeType}' is not supported. The result has mimeType '${blob.type}' instead.`);
  }
  const buffer = await blob.arrayBuffer();
  if (toArrayBuffer) {
    return buffer;
  }
  return `data:${mimeType};base64,${EncodeArrayBufferToBase64(buffer)}`;
}
function DumpData(width, height, data, successCallback, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
  if (fileName === void 0 && !successCallback) {
    fileName = "";
  }
  DumpDataAsync(width, height, data, mimeType, fileName, invertY, toArrayBuffer, quality).then((result) => {
    if (successCallback) {
      successCallback(result);
    }
  });
}
function Dispose() {
  if (!ResourcesPromise) {
    return;
  }
  ResourcesPromise?.then((resources) => {
    if (resources.canvas instanceof HTMLCanvasElement) {
      resources.canvas.remove();
    }
    if (resources.dumpEngine) {
      resources.dumpEngine.engine.dispose();
      resources.dumpEngine.renderer.dispose();
      resources.dumpEngine.wrapper.dispose();
    }
  });
  ResourcesPromise = null;
}
var ResourcesPromise, EncodingHelper, EncodeImageAsync, DumpTools, InitSideEffects;
var init_dumpTools = __esm({
  "node_modules/@babylonjs/core/Misc/dumpTools.js"() {
    init_tslib_es6();
    init_effectRenderer();
    init_tools();
    init_math_scalar_functions();
    init_engineStore();
    init_logger();
    init_stringTools();
    init_decorators();
    ResourcesPromise = null;
    EncodingHelper = class {
      /**
       * Encodes image data to the given mime type.
       * This is put into a helper class so we can apply the nativeOverride decorator to it.
       * @internal
       */
      static async EncodeImageAsync(pixelData, width, height, mimeType, invertY, quality) {
        const resources = await _GetDumpResourcesAsync();
        const dumpEngine = resources.dumpEngine;
        dumpEngine.engine.setSize(width, height, true);
        const texture = dumpEngine.engine.createRawTexture(pixelData, width, height, 5, false, !invertY, 1);
        dumpEngine.renderer.setViewport();
        dumpEngine.renderer.applyEffectWrapper(dumpEngine.wrapper);
        dumpEngine.wrapper.effect._bindTexture("textureSampler", texture);
        dumpEngine.renderer.draw();
        texture.dispose();
        return await new Promise((resolve, reject) => {
          Tools.ToBlob(resources.canvas, (blob) => {
            if (!blob) {
              reject(new Error("EncodeImageAsync: Failed to convert canvas to blob."));
            } else {
              resolve(blob);
            }
          }, mimeType, quality);
        });
      }
    };
    __decorate([
      nativeOverride
    ], EncodingHelper, "EncodeImageAsync", null);
    EncodeImageAsync = EncodingHelper.EncodeImageAsync;
    DumpTools = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      DumpData,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      DumpDataAsync,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      DumpFramebuffer,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      Dispose
    };
    InitSideEffects = () => {
      Tools.DumpData = DumpData;
      Tools.DumpDataAsync = DumpDataAsync;
      Tools.DumpFramebuffer = DumpFramebuffer;
    };
    InitSideEffects();
  }
});

export {
  EncodeImageAsync,
  DumpFramebuffer,
  DumpDataAsync,
  DumpData,
  Dispose,
  DumpTools,
  init_dumpTools
};
//# sourceMappingURL=chunk-RSNSIAVI.js.map
