import {
  AbstractMesh,
  init_abstractMesh
} from "./chunk-TMHG26QH.js";
import {
  WebGPUPerfCounter,
  init_webgpuPerfCounter
} from "./chunk-GVBFKIFY.js";
import {
  init_buffer
} from "./chunk-YEEYUO2W.js";
import {
  AbstractEngine,
  init_abstractEngine
} from "./chunk-WTQMXJ7P.js";
import {
  ILog2,
  init_math_scalar_functions
} from "./chunk-XBFJXXXT.js";
import {
  Logger,
  init_logger
} from "./chunk-2X44KPCK.js";
import {
  __esm
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@babylonjs/core/Meshes/buffer.js
var init_buffer2 = __esm({
  "node_modules/@babylonjs/core/Meshes/buffer.js"() {
    init_buffer();
  }
});

// node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.query.js
var _OcclusionDataStorage;
var init_abstractEngine_query = __esm({
  "node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.query.js"() {
    init_abstractMesh();
    init_abstractEngine();
    _OcclusionDataStorage = class {
      constructor() {
        this.occlusionInternalRetryCounter = 0;
        this.isOcclusionQueryInProgress = false;
        this.isOccluded = false;
        this.occlusionRetryCount = -1;
        this.occlusionType = AbstractMesh.OCCLUSION_TYPE_NONE;
        this.occlusionQueryAlgorithmType = AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE;
        this.forceRenderingWhenOccluded = false;
      }
    };
    AbstractEngine.prototype.createQuery = function() {
      return null;
    };
    AbstractEngine.prototype.deleteQuery = function(query) {
      return this;
    };
    AbstractEngine.prototype.isQueryResultAvailable = function(query) {
      return false;
    };
    AbstractEngine.prototype.getQueryResult = function(query) {
      return 0;
    };
    AbstractEngine.prototype.beginOcclusionQuery = function(algorithmType, query) {
      return false;
    };
    AbstractEngine.prototype.endOcclusionQuery = function(algorithmType) {
      return this;
    };
    Object.defineProperty(AbstractMesh.prototype, "isOcclusionQueryInProgress", {
      get: function() {
        return this._occlusionDataStorage.isOcclusionQueryInProgress;
      },
      set: function(value) {
        this._occlusionDataStorage.isOcclusionQueryInProgress = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(AbstractMesh.prototype, "_occlusionDataStorage", {
      get: function() {
        if (!this.__occlusionDataStorage) {
          this.__occlusionDataStorage = new _OcclusionDataStorage();
        }
        return this.__occlusionDataStorage;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(AbstractMesh.prototype, "isOccluded", {
      get: function() {
        return this._occlusionDataStorage.isOccluded;
      },
      set: function(value) {
        this._occlusionDataStorage.isOccluded = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractMesh.prototype, "occlusionQueryAlgorithmType", {
      get: function() {
        return this._occlusionDataStorage.occlusionQueryAlgorithmType;
      },
      set: function(value) {
        this._occlusionDataStorage.occlusionQueryAlgorithmType = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractMesh.prototype, "occlusionType", {
      get: function() {
        return this._occlusionDataStorage.occlusionType;
      },
      set: function(value) {
        this._occlusionDataStorage.occlusionType = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractMesh.prototype, "occlusionRetryCount", {
      get: function() {
        return this._occlusionDataStorage.occlusionRetryCount;
      },
      set: function(value) {
        this._occlusionDataStorage.occlusionRetryCount = value;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbstractMesh.prototype, "forceRenderingWhenOccluded", {
      get: function() {
        return this._occlusionDataStorage.forceRenderingWhenOccluded;
      },
      set: function(value) {
        this._occlusionDataStorage.forceRenderingWhenOccluded = value;
      },
      enumerable: true,
      configurable: true
    });
    AbstractMesh.prototype._checkOcclusionQuery = function() {
      const dataStorage = this._occlusionDataStorage;
      if (dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_NONE) {
        dataStorage.isOccluded = false;
        return false;
      }
      const engine = this.getEngine();
      if (!engine.getCaps().supportOcclusionQuery) {
        dataStorage.isOccluded = false;
        return false;
      }
      if (!engine.isQueryResultAvailable) {
        dataStorage.isOccluded = false;
        return false;
      }
      if (this.isOcclusionQueryInProgress && this._occlusionQuery !== null && this._occlusionQuery !== void 0) {
        const isOcclusionQueryAvailable = engine.isQueryResultAvailable(this._occlusionQuery);
        if (isOcclusionQueryAvailable) {
          const occlusionQueryResult = engine.getQueryResult(this._occlusionQuery);
          dataStorage.isOcclusionQueryInProgress = false;
          dataStorage.occlusionInternalRetryCounter = 0;
          dataStorage.isOccluded = occlusionQueryResult > 0 ? false : true;
        } else {
          dataStorage.occlusionInternalRetryCounter++;
          if (dataStorage.occlusionRetryCount !== -1 && dataStorage.occlusionInternalRetryCounter > dataStorage.occlusionRetryCount) {
            dataStorage.isOcclusionQueryInProgress = false;
            dataStorage.occlusionInternalRetryCounter = 0;
            dataStorage.isOccluded = dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC ? false : dataStorage.isOccluded;
          } else {
            return dataStorage.occlusionType === AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC ? false : dataStorage.isOccluded;
          }
        }
      }
      const scene = this.getScene();
      if (scene.getBoundingBoxRenderer) {
        const occlusionBoundingBoxRenderer = scene.getBoundingBoxRenderer();
        if (this._occlusionQuery === null) {
          this._occlusionQuery = engine.createQuery();
        }
        if (this._occlusionQuery && engine.beginOcclusionQuery(dataStorage.occlusionQueryAlgorithmType, this._occlusionQuery)) {
          occlusionBoundingBoxRenderer.renderOcclusionBoundingBox(this);
          engine.endOcclusionQuery(dataStorage.occlusionQueryAlgorithmType);
          this._occlusionDataStorage.isOcclusionQueryInProgress = true;
        }
      }
      return dataStorage.isOccluded;
    };
  }
});

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuTextureHelper.js
var WebGPUTextureHelper;
var init_webgpuTextureHelper = __esm({
  "node_modules/@babylonjs/core/Engines/WebGPU/webgpuTextureHelper.js"() {
    init_math_scalar_functions();
    WebGPUTextureHelper = class {
      static ComputeNumMipmapLevels(width, height) {
        return ILog2(Math.max(width, height)) + 1;
      }
      static GetTextureTypeFromFormat(format) {
        switch (format) {
          // One Component = 8 bits unsigned
          case "r8unorm":
          case "r8uint":
          case "rg8unorm":
          case "rg8uint":
          case "rgba8unorm":
          case "rgba8unorm-srgb":
          case "rgba8uint":
          case "bgra8unorm":
          case "bgra8unorm-srgb":
          case "rgb10a2uint":
          // composite format - let's say it's byte...
          case "rgb10a2unorm":
          // composite format - let's say it's byte...
          case "rgb9e5ufloat":
          // composite format - let's say it's byte...
          case "rg11b10ufloat":
          // composite format - let's say it's byte...
          case "bc7-rgba-unorm":
          case "bc7-rgba-unorm-srgb":
          case "bc6h-rgb-ufloat":
          case "bc5-rg-unorm":
          case "bc3-rgba-unorm":
          case "bc3-rgba-unorm-srgb":
          case "bc2-rgba-unorm":
          case "bc2-rgba-unorm-srgb":
          case "bc4-r-unorm":
          case "bc1-rgba-unorm":
          case "bc1-rgba-unorm-srgb":
          case "etc2-rgb8unorm":
          case "etc2-rgb8unorm-srgb":
          case "etc2-rgb8a1unorm":
          case "etc2-rgb8a1unorm-srgb":
          case "etc2-rgba8unorm":
          case "etc2-rgba8unorm-srgb":
          case "eac-r11unorm":
          case "eac-rg11unorm":
          case "astc-4x4-unorm":
          case "astc-4x4-unorm-srgb":
          case "astc-5x4-unorm":
          case "astc-5x4-unorm-srgb":
          case "astc-5x5-unorm":
          case "astc-5x5-unorm-srgb":
          case "astc-6x5-unorm":
          case "astc-6x5-unorm-srgb":
          case "astc-6x6-unorm":
          case "astc-6x6-unorm-srgb":
          case "astc-8x5-unorm":
          case "astc-8x5-unorm-srgb":
          case "astc-8x6-unorm":
          case "astc-8x6-unorm-srgb":
          case "astc-8x8-unorm":
          case "astc-8x8-unorm-srgb":
          case "astc-10x5-unorm":
          case "astc-10x5-unorm-srgb":
          case "astc-10x6-unorm":
          case "astc-10x6-unorm-srgb":
          case "astc-10x8-unorm":
          case "astc-10x8-unorm-srgb":
          case "astc-10x10-unorm":
          case "astc-10x10-unorm-srgb":
          case "astc-12x10-unorm":
          case "astc-12x10-unorm-srgb":
          case "astc-12x12-unorm":
          case "astc-12x12-unorm-srgb":
          case "stencil8":
            return 0;
          // One Component = 8 bits signed
          case "r8snorm":
          case "r8sint":
          case "rg8snorm":
          case "rg8sint":
          case "rgba8snorm":
          case "rgba8sint":
          case "bc6h-rgb-float":
          case "bc5-rg-snorm":
          case "bc4-r-snorm":
          case "eac-r11snorm":
          case "eac-rg11snorm":
            return 3;
          // One component = 16 bits unsigned
          case "r16uint":
          case "r16unorm":
          case "rg16unorm":
          case "rgba16unorm":
          case "rg16uint":
          case "rgba16uint":
          case "depth16unorm":
            return 5;
          // One component = 16 bits signed
          case "r16sint":
          case "r16snorm":
          case "rg16snorm":
          case "rgba16snorm":
          case "rg16sint":
          case "rgba16sint":
            return 4;
          case "r16float":
          case "rg16float":
          case "rgba16float":
            return 2;
          // One component = 32 bits unsigned
          case "r32uint":
          case "rg32uint":
          case "rgba32uint":
            return 7;
          // One component = 32 bits signed
          case "r32sint":
          case "rg32sint":
          case "rgba32sint":
            return 7;
          case "r32float":
          case "rg32float":
          case "rgba32float":
          case "depth32float":
          case "depth32float-stencil8":
          case "depth24plus":
          case "depth24plus-stencil8":
            return 1;
        }
        return 0;
      }
      static GetBlockInformationFromFormat(format) {
        switch (format) {
          // 8 bits formats
          case "r8unorm":
          case "r8snorm":
          case "r8uint":
          case "r8sint":
            return { width: 1, height: 1, length: 1 };
          // 16 bits formats
          case "r16uint":
          case "r16sint":
          case "r16unorm":
          case "r16snorm":
          case "r16float":
          case "rg8unorm":
          case "rg8snorm":
          case "rg8uint":
          case "rg8sint":
            return { width: 1, height: 1, length: 2 };
          // 32 bits formats
          case "r32uint":
          case "r32sint":
          case "r32float":
          case "rg16uint":
          case "rg16sint":
          case "rg16float":
          case "rg16unorm":
          case "rg16snorm":
          case "rgba8unorm":
          case "rgba8unorm-srgb":
          case "rgba8snorm":
          case "rgba8uint":
          case "rgba8sint":
          case "bgra8unorm":
          case "bgra8unorm-srgb":
          case "rgb9e5ufloat":
          case "rgb10a2uint":
          case "rgb10a2unorm":
          case "rg11b10ufloat":
            return { width: 1, height: 1, length: 4 };
          // 64 bits formats
          case "rg32uint":
          case "rg32sint":
          case "rg32float":
          case "rgba16uint":
          case "rgba16sint":
          case "rgba16float":
          case "rgba16unorm":
          case "rgba16snorm":
            return { width: 1, height: 1, length: 8 };
          // 128 bits formats
          case "rgba32uint":
          case "rgba32sint":
          case "rgba32float":
            return { width: 1, height: 1, length: 16 };
          // Depth and stencil formats
          case "stencil8":
            throw "No fixed size for Stencil8 format!";
          case "depth16unorm":
            return { width: 1, height: 1, length: 2 };
          case "depth24plus":
            throw "No fixed size for Depth24Plus format!";
          case "depth24plus-stencil8":
            throw "No fixed size for Depth24PlusStencil8 format!";
          case "depth32float":
            return { width: 1, height: 1, length: 4 };
          case "depth32float-stencil8":
            return { width: 1, height: 1, length: 5 };
          // BC compressed formats usable if "texture-compression-bc" is both
          // supported by the device/user agent and enabled in requestDevice.
          case "bc7-rgba-unorm":
          case "bc7-rgba-unorm-srgb":
          case "bc6h-rgb-ufloat":
          case "bc6h-rgb-float":
          case "bc5-rg-unorm":
          case "bc5-rg-snorm":
          case "bc3-rgba-unorm":
          case "bc3-rgba-unorm-srgb":
          case "bc2-rgba-unorm":
          case "bc2-rgba-unorm-srgb":
            return { width: 4, height: 4, length: 16 };
          case "bc4-r-unorm":
          case "bc4-r-snorm":
          case "bc1-rgba-unorm":
          case "bc1-rgba-unorm-srgb":
            return { width: 4, height: 4, length: 8 };
          // ETC2 compressed formats usable if "texture-compression-etc2" is both
          // supported by the device/user agent and enabled in requestDevice.
          case "etc2-rgb8unorm":
          case "etc2-rgb8unorm-srgb":
          case "etc2-rgb8a1unorm":
          case "etc2-rgb8a1unorm-srgb":
          case "eac-r11unorm":
          case "eac-r11snorm":
            return { width: 4, height: 4, length: 8 };
          case "etc2-rgba8unorm":
          case "etc2-rgba8unorm-srgb":
          case "eac-rg11unorm":
          case "eac-rg11snorm":
            return { width: 4, height: 4, length: 16 };
          // ASTC compressed formats usable if "texture-compression-astc" is both
          // supported by the device/user agent and enabled in requestDevice.
          case "astc-4x4-unorm":
          case "astc-4x4-unorm-srgb":
            return { width: 4, height: 4, length: 16 };
          case "astc-5x4-unorm":
          case "astc-5x4-unorm-srgb":
            return { width: 5, height: 4, length: 16 };
          case "astc-5x5-unorm":
          case "astc-5x5-unorm-srgb":
            return { width: 5, height: 5, length: 16 };
          case "astc-6x5-unorm":
          case "astc-6x5-unorm-srgb":
            return { width: 6, height: 5, length: 16 };
          case "astc-6x6-unorm":
          case "astc-6x6-unorm-srgb":
            return { width: 6, height: 6, length: 16 };
          case "astc-8x5-unorm":
          case "astc-8x5-unorm-srgb":
            return { width: 8, height: 5, length: 16 };
          case "astc-8x6-unorm":
          case "astc-8x6-unorm-srgb":
            return { width: 8, height: 6, length: 16 };
          case "astc-8x8-unorm":
          case "astc-8x8-unorm-srgb":
            return { width: 8, height: 8, length: 16 };
          case "astc-10x5-unorm":
          case "astc-10x5-unorm-srgb":
            return { width: 10, height: 5, length: 16 };
          case "astc-10x6-unorm":
          case "astc-10x6-unorm-srgb":
            return { width: 10, height: 6, length: 16 };
          case "astc-10x8-unorm":
          case "astc-10x8-unorm-srgb":
            return { width: 10, height: 8, length: 16 };
          case "astc-10x10-unorm":
          case "astc-10x10-unorm-srgb":
            return { width: 10, height: 10, length: 16 };
          case "astc-12x10-unorm":
          case "astc-12x10-unorm-srgb":
            return { width: 12, height: 10, length: 16 };
          case "astc-12x12-unorm":
          case "astc-12x12-unorm-srgb":
            return { width: 12, height: 12, length: 16 };
        }
        return { width: 1, height: 1, length: 4 };
      }
      static IsHardwareTexture(texture) {
        return !!texture.release;
      }
      static IsInternalTexture(texture) {
        return !!texture.dispose;
      }
      static IsImageBitmap(imageBitmap) {
        return imageBitmap.close !== void 0;
      }
      static IsImageBitmapArray(imageBitmap) {
        return Array.isArray(imageBitmap) && imageBitmap[0].close !== void 0;
      }
      static IsCompressedFormat(format) {
        switch (format) {
          case "bc7-rgba-unorm-srgb":
          case "bc7-rgba-unorm":
          case "bc6h-rgb-float":
          case "bc6h-rgb-ufloat":
          case "bc5-rg-snorm":
          case "bc5-rg-unorm":
          case "bc4-r-snorm":
          case "bc4-r-unorm":
          case "bc3-rgba-unorm-srgb":
          case "bc3-rgba-unorm":
          case "bc2-rgba-unorm-srgb":
          case "bc2-rgba-unorm":
          case "bc1-rgba-unorm-srgb":
          case "bc1-rgba-unorm":
          case "etc2-rgb8unorm":
          case "etc2-rgb8unorm-srgb":
          case "etc2-rgb8a1unorm":
          case "etc2-rgb8a1unorm-srgb":
          case "etc2-rgba8unorm":
          case "etc2-rgba8unorm-srgb":
          case "eac-r11unorm":
          case "eac-r11snorm":
          case "eac-rg11unorm":
          case "eac-rg11snorm":
          case "astc-4x4-unorm":
          case "astc-4x4-unorm-srgb":
          case "astc-5x4-unorm":
          case "astc-5x4-unorm-srgb":
          case "astc-5x5-unorm":
          case "astc-5x5-unorm-srgb":
          case "astc-6x5-unorm":
          case "astc-6x5-unorm-srgb":
          case "astc-6x6-unorm":
          case "astc-6x6-unorm-srgb":
          case "astc-8x5-unorm":
          case "astc-8x5-unorm-srgb":
          case "astc-8x6-unorm":
          case "astc-8x6-unorm-srgb":
          case "astc-8x8-unorm":
          case "astc-8x8-unorm-srgb":
          case "astc-10x5-unorm":
          case "astc-10x5-unorm-srgb":
          case "astc-10x6-unorm":
          case "astc-10x6-unorm-srgb":
          case "astc-10x8-unorm":
          case "astc-10x8-unorm-srgb":
          case "astc-10x10-unorm":
          case "astc-10x10-unorm-srgb":
          case "astc-12x10-unorm":
          case "astc-12x10-unorm-srgb":
          case "astc-12x12-unorm":
          case "astc-12x12-unorm-srgb":
            return true;
        }
        return false;
      }
      static GetWebGPUTextureFormat(type, format, useSRGBBuffer = false) {
        switch (format) {
          case 15:
            return "depth16unorm";
          case 16:
            return "depth24plus";
          case 13:
            return "depth24plus-stencil8";
          case 14:
            return "depth32float";
          case 18:
            return "depth32float-stencil8";
          case 19:
            return "stencil8";
          case 36492:
            return useSRGBBuffer ? "bc7-rgba-unorm-srgb" : "bc7-rgba-unorm";
          case 36495:
            return "bc6h-rgb-ufloat";
          case 36494:
            return "bc6h-rgb-float";
          case 33779:
            return useSRGBBuffer ? "bc3-rgba-unorm-srgb" : "bc3-rgba-unorm";
          case 33778:
            return useSRGBBuffer ? "bc2-rgba-unorm-srgb" : "bc2-rgba-unorm";
          case 33777:
          case 33776:
            return useSRGBBuffer ? "bc1-rgba-unorm-srgb" : "bc1-rgba-unorm";
          case 37808:
            return useSRGBBuffer ? "astc-4x4-unorm-srgb" : "astc-4x4-unorm";
          case 36196:
          case 37492:
            return useSRGBBuffer ? "etc2-rgb8unorm-srgb" : "etc2-rgb8unorm";
          case 37496:
            return useSRGBBuffer ? "etc2-rgba8unorm-srgb" : "etc2-rgba8unorm";
        }
        switch (type) {
          case 3:
            switch (format) {
              case 6:
                return "r8snorm";
              case 7:
                return "rg8snorm";
              case 4:
                throw "RGB format not supported in WebGPU";
              case 8:
                return "r8sint";
              case 9:
                return "rg8sint";
              case 10:
                throw "RGB_INTEGER format not supported in WebGPU";
              case 11:
                return "rgba8sint";
              default:
                return "rgba8snorm";
            }
          case 0:
            switch (format) {
              case 6:
                return "r8unorm";
              case 7:
                return "rg8unorm";
              case 4:
                throw "TEXTUREFORMAT_RGB format not supported in WebGPU";
              case 5:
                return useSRGBBuffer ? "rgba8unorm-srgb" : "rgba8unorm";
              case 12:
                return useSRGBBuffer ? "bgra8unorm-srgb" : "bgra8unorm";
              case 8:
                return "r8uint";
              case 9:
                return "rg8uint";
              case 10:
                throw "RGB_INTEGER format not supported in WebGPU";
              case 11:
                return "rgba8uint";
              case 0:
                throw "TEXTUREFORMAT_ALPHA format not supported in WebGPU";
              case 1:
                throw "TEXTUREFORMAT_LUMINANCE format not supported in WebGPU";
              case 2:
                throw "TEXTUREFORMAT_LUMINANCE_ALPHA format not supported in WebGPU";
              default:
                return "rgba8unorm";
            }
          case 4:
            switch (format) {
              case 8:
                return "r16sint";
              case 9:
                return "rg16sint";
              case 10:
                throw "TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU";
              case 11:
                return "rgba16sint";
              default:
                return "rgba16sint";
            }
          case 5:
            switch (format) {
              case 8:
                return "r16uint";
              case 9:
                return "rg16uint";
              case 10:
                throw "TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU";
              case 11:
                return "rgba16uint";
              default:
                return "rgba16uint";
            }
          case 6:
            switch (format) {
              case 8:
                return "r32sint";
              case 9:
                return "rg32sint";
              case 10:
                throw "TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU";
              case 11:
                return "rgba32sint";
              default:
                return "rgba32sint";
            }
          case 7:
            switch (format) {
              case 8:
                return "r32uint";
              case 9:
                return "rg32uint";
              case 10:
                throw "TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU";
              case 11:
                return "rgba32uint";
              default:
                return "rgba32uint";
            }
          case 1:
            switch (format) {
              case 6:
                return "r32float";
              // By default. Other possibility is R16Float.
              case 7:
                return "rg32float";
              // By default. Other possibility is RG16Float.
              case 4:
                throw "TEXTUREFORMAT_RGB format not supported in WebGPU";
              case 5:
                return "rgba32float";
              // By default. Other possibility is RGBA16Float.
              default:
                return "rgba32float";
            }
          case 2:
            switch (format) {
              case 6:
                return "r16float";
              case 7:
                return "rg16float";
              case 4:
                throw "TEXTUREFORMAT_RGB format not supported in WebGPU";
              case 5:
                return "rgba16float";
              default:
                return "rgba16float";
            }
          case 10:
            throw "TEXTURETYPE_UNSIGNED_SHORT_5_6_5 format not supported in WebGPU";
          case 13:
            switch (format) {
              case 5:
                return "rg11b10ufloat";
              case 11:
                throw "TEXTUREFORMAT_RGBA_INTEGER format not supported in WebGPU when type is TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV";
              default:
                return "rg11b10ufloat";
            }
          case 14:
            switch (format) {
              case 5:
                return "rgb9e5ufloat";
              case 11:
                throw "TEXTUREFORMAT_RGBA_INTEGER format not supported in WebGPU when type is TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV";
              default:
                return "rgb9e5ufloat";
            }
          case 8:
            throw "TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 format not supported in WebGPU";
          case 9:
            throw "TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 format not supported in WebGPU";
          case 11:
            switch (format) {
              case 5:
                return "rgb10a2unorm";
              case 11:
                return "rgb10a2uint";
              default:
                return "rgb10a2unorm";
            }
        }
        return useSRGBBuffer ? "rgba8unorm-srgb" : "rgba8unorm";
      }
      static GetNumChannelsFromWebGPUTextureFormat(format) {
        switch (format) {
          case "r8unorm":
          case "r8snorm":
          case "r8uint":
          case "r8sint":
          case "bc4-r-unorm":
          case "bc4-r-snorm":
          case "r16uint":
          case "r16sint":
          case "depth16unorm":
          case "r16float":
          case "r16unorm":
          case "r16snorm":
          case "r32uint":
          case "r32sint":
          case "r32float":
          case "depth32float":
          case "stencil8":
          case "depth24plus":
          case "eac-r11unorm":
          case "eac-r11snorm":
            return 1;
          case "rg8unorm":
          case "rg8snorm":
          case "rg8uint":
          case "rg8sint":
          case "depth32float-stencil8":
          case "bc5-rg-unorm":
          case "bc5-rg-snorm":
          case "rg16uint":
          case "rg16sint":
          case "rg16float":
          case "rg16unorm":
          case "rg16snorm":
          case "rg32uint":
          case "rg32sint":
          case "rg32float":
          case "depth24plus-stencil8":
          case "eac-rg11unorm":
          case "eac-rg11snorm":
            return 2;
          case "rgb9e5ufloat":
          case "rg11b10ufloat":
          case "bc6h-rgb-ufloat":
          case "bc6h-rgb-float":
          case "etc2-rgb8unorm":
          case "etc2-rgb8unorm-srgb":
            return 3;
          case "rgba8unorm":
          case "rgba8unorm-srgb":
          case "rgba8snorm":
          case "rgba8uint":
          case "rgba8sint":
          case "bgra8unorm":
          case "bgra8unorm-srgb":
          case "rgba16unorm":
          case "rgba16snorm":
          case "rgb10a2uint":
          case "rgb10a2unorm":
          case "bc7-rgba-unorm":
          case "bc7-rgba-unorm-srgb":
          case "bc3-rgba-unorm":
          case "bc3-rgba-unorm-srgb":
          case "bc2-rgba-unorm":
          case "bc2-rgba-unorm-srgb":
          case "bc1-rgba-unorm":
          case "bc1-rgba-unorm-srgb":
          case "rgba16uint":
          case "rgba16sint":
          case "rgba16float":
          case "rgba32uint":
          case "rgba32sint":
          case "rgba32float":
          case "etc2-rgb8a1unorm":
          case "etc2-rgb8a1unorm-srgb":
          case "etc2-rgba8unorm":
          case "etc2-rgba8unorm-srgb":
          case "astc-4x4-unorm":
          case "astc-4x4-unorm-srgb":
          case "astc-5x4-unorm":
          case "astc-5x4-unorm-srgb":
          case "astc-5x5-unorm":
          case "astc-5x5-unorm-srgb":
          case "astc-6x5-unorm":
          case "astc-6x5-unorm-srgb":
          case "astc-6x6-unorm":
          case "astc-6x6-unorm-srgb":
          case "astc-8x5-unorm":
          case "astc-8x5-unorm-srgb":
          case "astc-8x6-unorm":
          case "astc-8x6-unorm-srgb":
          case "astc-8x8-unorm":
          case "astc-8x8-unorm-srgb":
          case "astc-10x5-unorm":
          case "astc-10x5-unorm-srgb":
          case "astc-10x6-unorm":
          case "astc-10x6-unorm-srgb":
          case "astc-10x8-unorm":
          case "astc-10x8-unorm-srgb":
          case "astc-10x10-unorm":
          case "astc-10x10-unorm-srgb":
          case "astc-12x10-unorm":
          case "astc-12x10-unorm-srgb":
          case "astc-12x12-unorm":
          case "astc-12x12-unorm-srgb":
            return 4;
        }
        throw `Unknown format ${format}!`;
      }
      static HasStencilAspect(format) {
        switch (format) {
          case "stencil8":
          case "depth32float-stencil8":
          case "depth24plus-stencil8":
            return true;
        }
        return false;
      }
      static HasDepthAspect(format) {
        switch (format) {
          case "depth16unorm":
          case "depth24plus":
          case "depth24plus-stencil8":
          case "depth32float":
          case "depth32float-stencil8":
            return true;
        }
        return false;
      }
      static HasDepthAndStencilAspects(format) {
        switch (format) {
          case "depth32float-stencil8":
          case "depth24plus-stencil8":
            return true;
        }
        return false;
      }
      static GetDepthFormatOnly(format) {
        switch (format) {
          case "depth16unorm":
            return "depth16unorm";
          case "depth24plus":
            return "depth24plus";
          case "depth24plus-stencil8":
            return "depth24plus";
          case "depth32float":
            return "depth32float";
          case "depth32float-stencil8":
            return "depth32float";
        }
        return format;
      }
      static GetSample(sampleCount) {
        return sampleCount > 1 ? 4 : 1;
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/thinWebGPUEngine.js
var ThinWebGPUEngine;
var init_thinWebGPUEngine = __esm({
  "node_modules/@babylonjs/core/Engines/thinWebGPUEngine.js"() {
    init_abstractEngine();
    init_logger();
    init_webgpuTextureHelper();
    init_webgpuPerfCounter();
    ThinWebGPUEngine = class extends AbstractEngine {
      constructor() {
        super(...arguments);
        this.dbgShowShaderCode = false;
        this.dbgSanityChecks = true;
        this.dbgVerboseLogsNumFrames = 10;
        this.dbgLogIfNotDrawWrapper = true;
        this.dbgShowEmptyEnableEffectCalls = true;
        this.dbgVerboseLogsForFirstFrames = false;
        this._currentRenderPass = null;
        this._snapshotRenderingMode = 0;
        this._timestampIndex = 0;
      }
      /**
       * Enables or disables GPU timing measurements.
       * Note that this is only supported if the "timestamp-query" extension is enabled in the options.
       */
      get enableGPUTimingMeasurements() {
        return this._timestampQuery.enable;
      }
      set enableGPUTimingMeasurements(enable) {
        if (this._timestampQuery.enable === enable) {
          return;
        }
        this.gpuTimeInFrameForMainPass = enable ? new WebGPUPerfCounter() : void 0;
        this._timestampQuery.enable = enable;
      }
      _currentPassIsMainPass() {
        return this._currentRenderTarget === null;
      }
      /** @internal */
      _endCurrentRenderPass() {
        if (!this._currentRenderPass) {
          return 0;
        }
        const currentPassIndex = this._currentPassIsMainPass() ? 2 : 1;
        if (!this._snapshotRendering.endRenderPass(this._currentRenderPass) && !this.compatibilityMode) {
          this._bundleList.run(this._currentRenderPass);
          this._bundleList.reset();
        }
        this._currentRenderPass.end();
        this._timestampQuery.endPass(this._timestampIndex, this._currentRenderTarget && this._currentRenderTarget.gpuTimeInFrame ? this._currentRenderTarget.gpuTimeInFrame : this.gpuTimeInFrameForMainPass);
        this._timestampIndex += 2;
        if (this.dbgVerboseLogsForFirstFrames) {
          if (this._count === void 0) {
            this._count = 0;
          }
          if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
            Logger.Log("frame #" + this._count + " - " + (currentPassIndex === 2 ? "main" : "render target") + " end pass" + (currentPassIndex === 1 ? " - internalTexture.uniqueId=" + this._currentRenderTarget?.texture?.uniqueId : ""));
          }
        }
        this._currentRenderPass = null;
        return currentPassIndex;
      }
      /**
       * @internal
       */
      _generateMipmaps(texture, commandEncoder) {
        commandEncoder = commandEncoder ?? this._renderEncoder;
        const gpuHardwareTexture = texture._hardwareTexture;
        if (!gpuHardwareTexture) {
          return;
        }
        if (commandEncoder === this._renderEncoder) {
          this._endCurrentRenderPass();
        }
        const mipmapCount = WebGPUTextureHelper.ComputeNumMipmapLevels(texture.width, texture.height);
        if (this.dbgVerboseLogsForFirstFrames) {
          if (this._count === void 0) {
            this._count = 0;
          }
          if (!this._count || this._count < this.dbgVerboseLogsNumFrames) {
            Logger.Log("frame #" + this._count + " - generate mipmaps - width=" + texture.width + ", height=" + texture.height + ", isCube=" + texture.isCube + ", command encoder=" + (commandEncoder === this._renderEncoder ? "render" : "copy"));
          }
        }
        if (texture.isCube) {
          this._textureHelper.generateCubeMipmaps(gpuHardwareTexture, mipmapCount, commandEncoder);
        } else if (texture._source === 3 || texture._source === 11) {
          this._textureHelper.generateMipmaps(gpuHardwareTexture, texture.mipLevelCount, 0, commandEncoder);
        } else {
          this._textureHelper.generateMipmaps(gpuHardwareTexture, mipmapCount, 0, commandEncoder);
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/WebGPU/webgpuBundleList.js
var WebGPURenderItemViewport, WebGPURenderItemScissor, WebGPURenderItemStencilRef, WebGPURenderItemBlendColor, WebGPURenderItemBeginOcclusionQuery, WebGPURenderItemEndOcclusionQuery, WebGPURenderItemBundles, WebGPUBundleList;
var init_webgpuBundleList = __esm({
  "node_modules/@babylonjs/core/Engines/WebGPU/webgpuBundleList.js"() {
    init_webgpuTextureHelper();
    WebGPURenderItemViewport = class _WebGPURenderItemViewport {
      constructor(x, y, w, h) {
        this.x = Math.floor(x);
        this.y = Math.floor(y);
        this.w = Math.floor(w);
        this.h = Math.floor(h);
      }
      run(renderPass) {
        renderPass.setViewport(this.x, this.y, this.w, this.h, 0, 1);
      }
      clone() {
        return new _WebGPURenderItemViewport(this.x, this.y, this.w, this.h);
      }
    };
    WebGPURenderItemScissor = class _WebGPURenderItemScissor {
      constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
      }
      run(renderPass) {
        renderPass.setScissorRect(this.x, this.y, this.w, this.h);
      }
      clone() {
        return new _WebGPURenderItemScissor(this.x, this.y, this.w, this.h);
      }
    };
    WebGPURenderItemStencilRef = class _WebGPURenderItemStencilRef {
      constructor(ref) {
        this.ref = ref;
      }
      run(renderPass) {
        renderPass.setStencilReference(this.ref);
      }
      clone() {
        return new _WebGPURenderItemStencilRef(this.ref);
      }
    };
    WebGPURenderItemBlendColor = class _WebGPURenderItemBlendColor {
      constructor(color) {
        this.color = color;
      }
      run(renderPass) {
        renderPass.setBlendConstant(this.color);
      }
      clone() {
        return new _WebGPURenderItemBlendColor(this.color);
      }
    };
    WebGPURenderItemBeginOcclusionQuery = class _WebGPURenderItemBeginOcclusionQuery {
      constructor(query) {
        this.query = query;
      }
      run(renderPass) {
        renderPass.beginOcclusionQuery(this.query);
      }
      clone() {
        return new _WebGPURenderItemBeginOcclusionQuery(this.query);
      }
    };
    WebGPURenderItemEndOcclusionQuery = class _WebGPURenderItemEndOcclusionQuery {
      constructor() {
      }
      run(renderPass) {
        renderPass.endOcclusionQuery();
      }
      clone() {
        return new _WebGPURenderItemEndOcclusionQuery();
      }
    };
    WebGPURenderItemBundles = class _WebGPURenderItemBundles {
      constructor() {
        this.bundles = [];
      }
      run(renderPass) {
        renderPass.executeBundles(this.bundles);
      }
      clone() {
        const cloned = new _WebGPURenderItemBundles();
        cloned.bundles = this.bundles;
        return cloned;
      }
    };
    WebGPUBundleList = class _WebGPUBundleList {
      constructor(device) {
        this.numDrawCalls = 0;
        this._device = device;
        this._list = new Array(10);
        this._listLength = 0;
      }
      addBundle(bundle) {
        if (!this._currentItemIsBundle) {
          const item = new WebGPURenderItemBundles();
          this._list[this._listLength++] = item;
          this._currentBundleList = item.bundles;
          this._currentItemIsBundle = true;
        }
        if (bundle) {
          this._currentBundleList.push(bundle);
        }
      }
      _finishBundle() {
        if (this._currentItemIsBundle && this._bundleEncoder) {
          this._currentBundleList.push(this._bundleEncoder.finish());
          this._bundleEncoder = void 0;
          this._currentItemIsBundle = false;
        }
      }
      addItem(item) {
        this._finishBundle();
        this._list[this._listLength++] = item;
        this._currentItemIsBundle = false;
      }
      getBundleEncoder(colorFormats, depthStencilFormat, sampleCount) {
        if (!this._currentItemIsBundle) {
          this.addBundle();
          this._bundleEncoder = this._device.createRenderBundleEncoder({
            colorFormats,
            depthStencilFormat,
            sampleCount: WebGPUTextureHelper.GetSample(sampleCount)
          });
        }
        return this._bundleEncoder;
      }
      close() {
        this._finishBundle();
      }
      run(renderPass) {
        this.close();
        for (let i = 0; i < this._listLength; ++i) {
          this._list[i].run(renderPass);
        }
      }
      reset() {
        this._listLength = 0;
        this._currentItemIsBundle = false;
        this.numDrawCalls = 0;
      }
      clone() {
        this.close();
        const cloned = new _WebGPUBundleList(this._device);
        cloned._list = new Array(this._listLength);
        cloned._listLength = this._listLength;
        cloned.numDrawCalls = this.numDrawCalls;
        for (let i = 0; i < this._listLength; ++i) {
          cloned._list[i] = this._list[i].clone();
        }
        return cloned;
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.query.js
var init_engine_query = __esm({
  "node_modules/@babylonjs/core/Engines/WebGPU/Extensions/engine.query.js"() {
    init_thinWebGPUEngine();
    init_webgpuBundleList();
    init_abstractEngine_query();
    ThinWebGPUEngine.prototype.getGPUFrameTimeCounter = function() {
      return this._timestampQuery.gpuFrameTimeCounter;
    };
    ThinWebGPUEngine.prototype.captureGPUFrameTime = function(value) {
      this._timestampQuery.enable = value && !!this._caps.timerQuery;
    };
    ThinWebGPUEngine.prototype.createQuery = function() {
      return this._occlusionQuery.createQuery();
    };
    ThinWebGPUEngine.prototype.deleteQuery = function(query) {
      this._occlusionQuery.deleteQuery(query);
      return this;
    };
    ThinWebGPUEngine.prototype.isQueryResultAvailable = function(query) {
      return this._occlusionQuery.isQueryResultAvailable(query);
    };
    ThinWebGPUEngine.prototype.getQueryResult = function(query) {
      return this._occlusionQuery.getQueryResult(query);
    };
    ThinWebGPUEngine.prototype.beginOcclusionQuery = function(algorithmType, query) {
      if (this.compatibilityMode) {
        if (this._occlusionQuery.canBeginQuery(query)) {
          this._currentRenderPass?.beginOcclusionQuery(query);
          return true;
        }
      } else {
        this._bundleList.addItem(new WebGPURenderItemBeginOcclusionQuery(query));
        return true;
      }
      return false;
    };
    ThinWebGPUEngine.prototype.endOcclusionQuery = function() {
      if (this.compatibilityMode) {
        this._currentRenderPass?.endOcclusionQuery();
      } else {
        this._bundleList.addItem(new WebGPURenderItemEndOcclusionQuery());
      }
      return this;
    };
  }
});

export {
  init_buffer2 as init_buffer,
  _OcclusionDataStorage,
  init_abstractEngine_query,
  WebGPUTextureHelper,
  init_webgpuTextureHelper,
  ThinWebGPUEngine,
  init_thinWebGPUEngine,
  WebGPURenderItemViewport,
  WebGPURenderItemScissor,
  WebGPURenderItemStencilRef,
  WebGPURenderItemBlendColor,
  WebGPUBundleList,
  init_webgpuBundleList,
  init_engine_query
};
//# sourceMappingURL=chunk-YW3NGYMJ.js.map
