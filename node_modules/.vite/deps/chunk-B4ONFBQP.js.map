{
  "version": 3,
  "sources": ["../../../dev/core/src/Engines/Extensions/engine.multiRender.ts"],
  "sourcesContent": ["import { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { IMultiRenderTargetOptions } from \"../../Materials/Textures/multiRenderTarget\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport { ThinEngine } from \"../thinEngine\";\r\nimport type { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\nimport type { WebGLRenderTargetWrapper } from \"../WebGL/webGLRenderTargetWrapper\";\r\nimport type { WebGLHardwareTexture } from \"../WebGL/webGLHardwareTexture\";\r\nimport type { TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Unbind a list of render target textures from the webGL context\r\n         * This is used only when drawBuffer extension or webGL2 are active\r\n         * @param rtWrapper defines the render target wrapper to unbind\r\n         * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n         * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n         */\r\n        unBindMultiColorAttachmentFramebuffer(rtWrapper: RenderTargetWrapper, disableGenerateMipMaps: boolean, onBeforeUnbind?: () => void): void;\r\n\r\n        /**\r\n         * Create a multi render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multiple-render-target\r\n         * @param size defines the size of the texture\r\n         * @param options defines the creation options\r\n         * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n         * @returns a new render target wrapper ready to render textures\r\n         */\r\n        createMultipleRenderTarget(size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers?: boolean): RenderTargetWrapper;\r\n\r\n        /**\r\n         * Update the sample count for a given multiple render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multisample-render-targets\r\n         * @param rtWrapper defines the render target wrapper to update\r\n         * @param samples defines the sample count to set\r\n         * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n         * @returns the effective sample count (could be 0 if multisample render targets are not supported)\r\n         */\r\n        updateMultipleRenderTargetTextureSampleCount(rtWrapper: Nullable<RenderTargetWrapper>, samples: number, initializeBuffers?: boolean): number;\r\n\r\n        /**\r\n         * Generates mipmaps for the texture of the (multi) render target\r\n         * @param texture The render target containing the textures to generate the mipmaps for\r\n         */\r\n        generateMipMapsMultiFramebuffer(texture: RenderTargetWrapper): void;\r\n\r\n        /**\r\n         * Resolves the MSAA textures of the (multi) render target into their non-MSAA version.\r\n         * Note that if \"texture\" is not a MSAA render target, no resolve is performed.\r\n         * @param texture The render target texture containing the MSAA textures to resolve\r\n         */\r\n        resolveMultiFramebuffer(texture: RenderTargetWrapper): void;\r\n\r\n        /**\r\n         * Select a subsets of attachments to draw to.\r\n         * @param attachments gl attachments\r\n         */\r\n        bindAttachments(attachments: number[]): void;\r\n\r\n        /**\r\n         * Creates a layout object to draw/clear on specific textures in a MRT\r\n         * @param textureStatus textureStatus[i] indicates if the i-th is active\r\n         * @param backBufferLayout if true, the layout will be built to account for the back buffer only, and textureStatus won't be used\r\n         * @returns A layout to be fed to the engine, calling `bindAttachments`.\r\n         */\r\n        buildTextureLayout(textureStatus: boolean[], backBufferLayout?: boolean): number[];\r\n\r\n        /**\r\n         * Restores the webgl state to only draw on the main color attachment\r\n         * when the frame buffer associated is the canvas frame buffer\r\n         */\r\n        restoreSingleAttachment(): void;\r\n\r\n        /**\r\n         * Restores the webgl state to only draw on the main color attachment\r\n         * when the frame buffer associated is not the canvas frame buffer\r\n         */\r\n        restoreSingleAttachmentForRenderTarget(): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.restoreSingleAttachment = function (): void {\r\n    const gl = this._gl;\r\n\r\n    this.bindAttachments([gl.BACK]);\r\n};\r\n\r\nThinEngine.prototype.restoreSingleAttachmentForRenderTarget = function (): void {\r\n    const gl = this._gl;\r\n\r\n    this.bindAttachments([gl.COLOR_ATTACHMENT0]);\r\n};\r\n\r\nThinEngine.prototype.buildTextureLayout = function (textureStatus: boolean[], backBufferLayout = false): number[] {\r\n    const gl = this._gl;\r\n\r\n    const result = [];\r\n\r\n    if (backBufferLayout) {\r\n        result.push(gl.BACK);\r\n    } else {\r\n        for (let i = 0; i < textureStatus.length; i++) {\r\n            if (textureStatus[i]) {\r\n                result.push((<any>gl)[\"COLOR_ATTACHMENT\" + i]);\r\n            } else {\r\n                result.push(gl.NONE);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nThinEngine.prototype.bindAttachments = function (attachments: number[]): void {\r\n    const gl = this._gl;\r\n\r\n    gl.drawBuffers(attachments);\r\n};\r\n\r\nThinEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (\r\n    rtWrapper: WebGLRenderTargetWrapper,\r\n    disableGenerateMipMaps: boolean = false,\r\n    onBeforeUnbind?: () => void\r\n): void {\r\n    this._currentRenderTarget = null;\r\n\r\n    if (!rtWrapper.disableAutomaticMSAAResolve) {\r\n        this.resolveMultiFramebuffer(rtWrapper);\r\n    }\r\n\r\n    if (!disableGenerateMipMaps) {\r\n        this.generateMipMapsMultiFramebuffer(rtWrapper);\r\n    }\r\n\r\n    if (onBeforeUnbind) {\r\n        if (rtWrapper._MSAAFramebuffer) {\r\n            // Bind the correct framebuffer\r\n            this._bindUnboundFramebuffer(rtWrapper._framebuffer);\r\n        }\r\n        onBeforeUnbind();\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(null);\r\n};\r\n\r\nThinEngine.prototype.createMultipleRenderTarget = function (size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers: boolean = true): RenderTargetWrapper {\r\n    let generateMipMaps = false;\r\n    let generateDepthBuffer = true;\r\n    let generateStencilBuffer = false;\r\n    let generateDepthTexture = false;\r\n    let depthTextureFormat: number | undefined = undefined;\r\n    let textureCount = 1;\r\n    let samples = 1;\r\n\r\n    const defaultType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    const defaultSamplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    const defaultUseSRGBBuffer = false;\r\n    const defaultFormat = Constants.TEXTUREFORMAT_RGBA;\r\n    const defaultTarget = Constants.TEXTURE_2D;\r\n\r\n    let types: number[] = [];\r\n    let samplingModes: number[] = [];\r\n    let useSRGBBuffers: boolean[] = [];\r\n    let formats: number[] = [];\r\n    let targets: number[] = [];\r\n    let faceIndex: number[] = [];\r\n    let layerIndex: number[] = [];\r\n    let layers: number[] = [];\r\n    let labels: string[] = [];\r\n    let dontCreateTextures = false;\r\n\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size) as WebGLRenderTargetWrapper;\r\n\r\n    if (options !== undefined) {\r\n        generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\r\n        generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n        generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\r\n        textureCount = options.textureCount ?? 1;\r\n        samples = options.samples ?? samples;\r\n        types = options.types || types;\r\n        samplingModes = options.samplingModes || samplingModes;\r\n        useSRGBBuffers = options.useSRGBBuffers || useSRGBBuffers;\r\n        formats = options.formats || formats;\r\n        targets = options.targetTypes || targets;\r\n        faceIndex = options.faceIndex || faceIndex;\r\n        layerIndex = options.layerIndex || layerIndex;\r\n        layers = options.layerCounts || layers;\r\n        labels = options.labels || labels;\r\n        dontCreateTextures = options.dontCreateTextures ?? false;\r\n\r\n        if (\r\n            this.webGLVersion > 1 &&\r\n            (options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24 ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32_FLOAT ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8)\r\n        ) {\r\n            depthTextureFormat = options.depthTextureFormat;\r\n        }\r\n    }\r\n\r\n    if (depthTextureFormat === undefined) {\r\n        depthTextureFormat = generateStencilBuffer ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    // Create the framebuffer\r\n    const currentFramebuffer = this._currentFramebuffer;\r\n    const framebuffer = gl.createFramebuffer();\r\n    this._bindUnboundFramebuffer(framebuffer);\r\n\r\n    const width = (<{ width: number; height: number }>size).width ?? <number>size;\r\n    const height = (<{ width: number; height: number }>size).height ?? <number>size;\r\n\r\n    const textures: InternalTexture[] = [];\r\n    const attachments: number[] = [];\r\n\r\n    const useStencilTexture =\r\n        this.webGLVersion > 1 &&\r\n        (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 ||\r\n            depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 ||\r\n            depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8);\r\n\r\n    rtWrapper.label = options?.label ?? \"MultiRenderTargetWrapper\";\r\n    rtWrapper._framebuffer = framebuffer;\r\n    rtWrapper._generateDepthBuffer = generateDepthTexture || generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = generateDepthTexture ? useStencilTexture : generateStencilBuffer;\r\n    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(rtWrapper._generateStencilBuffer, rtWrapper._generateDepthBuffer, width, height, 1, depthTextureFormat);\r\n    rtWrapper._attachments = attachments;\r\n\r\n    for (let i = 0; i < textureCount; i++) {\r\n        let samplingMode = samplingModes[i] || defaultSamplingMode;\r\n        let type = types[i] || defaultType;\r\n        let useSRGBBuffer = useSRGBBuffers[i] || defaultUseSRGBBuffer;\r\n        const format = formats[i] || defaultFormat;\r\n\r\n        const target = targets[i] || defaultTarget;\r\n        const layerCount = layers[i] ?? 1;\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n            Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\r\n        }\r\n\r\n        useSRGBBuffer = useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU);\r\n\r\n        const isWebGL2 = this.webGLVersion > 1;\r\n        const attachment = (<any>gl)[isWebGL2 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n\r\n        attachments.push(attachment);\r\n\r\n        if (target === -1 || dontCreateTextures) {\r\n            continue;\r\n        }\r\n\r\n        const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\r\n        textures[i] = texture;\r\n\r\n        gl.activeTexture((<any>gl)[\"TEXTURE\" + i]);\r\n        gl.bindTexture(target, texture._hardwareTexture!.underlyingResource);\r\n\r\n        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filters.min);\r\n        gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n        const internalSizedFormat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);\r\n        const internalFormat = this._getInternalFormat(format);\r\n        const webGLTextureType = this._getWebGLTextureType(type);\r\n\r\n        if (isWebGL2 && (target === Constants.TEXTURE_2D_ARRAY || target === Constants.TEXTURE_3D)) {\r\n            if (target === Constants.TEXTURE_2D_ARRAY) {\r\n                texture.is2DArray = true;\r\n            } else {\r\n                texture.is3D = true;\r\n            }\r\n\r\n            texture.baseDepth = texture.depth = layerCount;\r\n\r\n            gl.texImage3D(target, 0, internalSizedFormat, width, height, layerCount, 0, internalFormat, webGLTextureType, null);\r\n        } else if (target === Constants.TEXTURE_CUBE_MAP) {\r\n            // We have to generate all faces to complete the framebuffer\r\n            for (let i = 0; i < 6; i++) {\r\n                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, internalSizedFormat, width, height, 0, internalFormat, webGLTextureType, null);\r\n            }\r\n            texture.isCube = true;\r\n        } else {\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, internalSizedFormat, width, height, 0, internalFormat, webGLTextureType, null);\r\n        }\r\n\r\n        if (generateMipMaps) {\r\n            gl.generateMipmap(target);\r\n        }\r\n\r\n        // Unbind\r\n        this._bindTextureDirectly(target, null);\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.isReady = true;\r\n        texture.samples = 1;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.type = type;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n        texture.format = format;\r\n        texture.label = labels[i] ?? rtWrapper.label + \"-Texture\" + i;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n    }\r\n\r\n    if (generateDepthTexture && this._caps.depthTextureExtension && !dontCreateTextures) {\r\n        // Depth texture\r\n        const depthTexture = new InternalTexture(this, InternalTextureSource.Depth);\r\n\r\n        let depthTextureType = Constants.TEXTURETYPE_UNSIGNED_SHORT;\r\n        let glDepthTextureInternalFormat: GLenum = gl.DEPTH_COMPONENT16;\r\n        let glDepthTextureFormat: GLenum = gl.DEPTH_COMPONENT;\r\n        let glDepthTextureType: GLenum = gl.UNSIGNED_SHORT;\r\n        let glDepthTextureAttachment: GLenum = gl.DEPTH_ATTACHMENT;\r\n        if (this.webGLVersion < 2) {\r\n            glDepthTextureInternalFormat = gl.DEPTH_COMPONENT;\r\n        } else {\r\n            if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32_FLOAT) {\r\n                depthTextureType = Constants.TEXTURETYPE_FLOAT;\r\n                glDepthTextureType = gl.FLOAT;\r\n                glDepthTextureInternalFormat = gl.DEPTH_COMPONENT32F;\r\n            } else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8) {\r\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                glDepthTextureType = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;\r\n                glDepthTextureInternalFormat = gl.DEPTH32F_STENCIL8;\r\n                glDepthTextureFormat = gl.DEPTH_STENCIL;\r\n                glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\r\n            } else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24) {\r\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                glDepthTextureType = gl.UNSIGNED_INT;\r\n                glDepthTextureInternalFormat = gl.DEPTH_COMPONENT24;\r\n                glDepthTextureAttachment = gl.DEPTH_ATTACHMENT;\r\n            } else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 || depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8) {\r\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_INT_24_8;\r\n                glDepthTextureType = gl.UNSIGNED_INT_24_8;\r\n                glDepthTextureInternalFormat = gl.DEPTH24_STENCIL8;\r\n                glDepthTextureFormat = gl.DEPTH_STENCIL;\r\n                glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\r\n            }\r\n        }\r\n\r\n        this._bindTextureDirectly(gl.TEXTURE_2D, depthTexture, true);\r\n\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, glDepthTextureInternalFormat, width, height, 0, glDepthTextureFormat, glDepthTextureType, null);\r\n\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, glDepthTextureAttachment, gl.TEXTURE_2D, depthTexture._hardwareTexture!.underlyingResource, 0);\r\n\r\n        this._bindTextureDirectly(gl.TEXTURE_2D, null);\r\n\r\n        rtWrapper._depthStencilTexture = depthTexture;\r\n        rtWrapper._depthStencilTextureWithStencil = useStencilTexture;\r\n\r\n        depthTexture.baseWidth = width;\r\n        depthTexture.baseHeight = height;\r\n        depthTexture.width = width;\r\n        depthTexture.height = height;\r\n        depthTexture.isReady = true;\r\n        depthTexture.samples = 1;\r\n        depthTexture.generateMipMaps = generateMipMaps;\r\n        depthTexture.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        depthTexture.format = depthTextureFormat;\r\n        depthTexture.type = depthTextureType;\r\n        depthTexture.label = rtWrapper.label + \"-DepthStencil\";\r\n\r\n        textures[textureCount] = depthTexture;\r\n        this._internalTexturesCache.push(depthTexture);\r\n    }\r\n    rtWrapper.setTextures(textures);\r\n    if (initializeBuffers) {\r\n        gl.drawBuffers(attachments);\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(currentFramebuffer);\r\n\r\n    rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\r\n\r\n    this.resetTextureCache();\r\n\r\n    if (!dontCreateTextures) {\r\n        this.updateMultipleRenderTargetTextureSampleCount(rtWrapper, samples, initializeBuffers);\r\n    } else if (samples > 1) {\r\n        const framebuffer = gl.createFramebuffer();\r\n\r\n        if (!framebuffer) {\r\n            throw new Error(\"Unable to create multi sampled framebuffer\");\r\n        }\r\n\r\n        rtWrapper._samples = samples;\r\n        rtWrapper._MSAAFramebuffer = framebuffer;\r\n\r\n        if (textureCount > 0 && initializeBuffers) {\r\n            this._bindUnboundFramebuffer(framebuffer);\r\n            gl.drawBuffers(attachments);\r\n            this._bindUnboundFramebuffer(currentFramebuffer);\r\n        }\r\n    }\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nThinEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (\r\n    rtWrapper: Nullable<WebGLRenderTargetWrapper>,\r\n    samples: number,\r\n    initializeBuffers: boolean = true\r\n): number {\r\n    if (this.webGLVersion < 2 || !rtWrapper) {\r\n        return 1;\r\n    }\r\n\r\n    if (rtWrapper.samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    const gl = this._gl;\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    // Dispose previous render buffers\r\n    if (rtWrapper._depthStencilBuffer) {\r\n        gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);\r\n        rtWrapper._depthStencilBuffer = null;\r\n    }\r\n\r\n    if (rtWrapper._MSAAFramebuffer) {\r\n        gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);\r\n        rtWrapper._MSAAFramebuffer = null;\r\n    }\r\n\r\n    const count = rtWrapper._attachments!.length; // We do it this way instead of rtWrapper.textures.length to avoid taking into account the depth/stencil texture, in case it has been created\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const texture = rtWrapper.textures![i];\r\n        const hardwareTexture = texture._hardwareTexture as Nullable<WebGLHardwareTexture>;\r\n\r\n        hardwareTexture?.releaseMSAARenderBuffers();\r\n    }\r\n\r\n    if (samples > 1 && typeof gl.renderbufferStorageMultisample === \"function\") {\r\n        const framebuffer = gl.createFramebuffer();\r\n\r\n        if (!framebuffer) {\r\n            throw new Error(\"Unable to create multi sampled framebuffer\");\r\n        }\r\n\r\n        rtWrapper._MSAAFramebuffer = framebuffer;\r\n        this._bindUnboundFramebuffer(framebuffer);\r\n\r\n        const attachments = [];\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            const texture = rtWrapper.textures![i];\r\n            const hardwareTexture = texture._hardwareTexture as WebGLHardwareTexture;\r\n            const attachment = (<any>gl)[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n\r\n            const colorRenderbuffer = this._createRenderBuffer(\r\n                texture.width,\r\n                texture.height,\r\n                samples,\r\n                -1 /* not used */,\r\n                this._getRGBABufferInternalSizedFormat(texture.type, texture.format, texture._useSRGBBuffer),\r\n                attachment\r\n            );\r\n\r\n            if (!colorRenderbuffer) {\r\n                throw new Error(\"Unable to create multi sampled framebuffer\");\r\n            }\r\n\r\n            hardwareTexture.addMSAARenderBuffer(colorRenderbuffer);\r\n            texture.samples = samples;\r\n\r\n            attachments.push(attachment);\r\n        }\r\n        if (initializeBuffers) {\r\n            gl.drawBuffers(attachments);\r\n        }\r\n    } else {\r\n        this._bindUnboundFramebuffer(rtWrapper._framebuffer);\r\n    }\r\n\r\n    const depthFormat = rtWrapper._depthStencilTexture ? rtWrapper._depthStencilTexture.format : undefined;\r\n\r\n    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(\r\n        rtWrapper._generateStencilBuffer,\r\n        rtWrapper._generateDepthBuffer,\r\n        rtWrapper.width,\r\n        rtWrapper.height,\r\n        samples,\r\n        depthFormat\r\n    );\r\n\r\n    this._bindUnboundFramebuffer(null);\r\n\r\n    rtWrapper._samples = samples;\r\n\r\n    return samples;\r\n};\r\n\r\nThinEngine.prototype.generateMipMapsMultiFramebuffer = function (texture: RenderTargetWrapper): void {\r\n    const rtWrapper = texture as WebGLRenderTargetWrapper;\r\n    const gl = this._gl;\r\n\r\n    if (!rtWrapper.isMulti) {\r\n        return;\r\n    }\r\n\r\n    for (let i = 0; i < rtWrapper._attachments!.length; i++) {\r\n        const texture = rtWrapper.textures![i];\r\n        if (texture?.generateMipMaps && !texture?.isCube && !texture?.is3D) {\r\n            this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            this._bindTextureDirectly(gl.TEXTURE_2D, null);\r\n        }\r\n    }\r\n};\r\n\r\nThinEngine.prototype.resolveMultiFramebuffer = function (texture: RenderTargetWrapper): void {\r\n    const rtWrapper = texture as WebGLRenderTargetWrapper;\r\n    const gl = this._gl;\r\n\r\n    if (!rtWrapper._MSAAFramebuffer || !rtWrapper.isMulti) {\r\n        return;\r\n    }\r\n\r\n    let bufferBits = rtWrapper.resolveMSAAColors ? gl.COLOR_BUFFER_BIT : 0;\r\n    bufferBits |= rtWrapper._generateDepthBuffer && rtWrapper.resolveMSAADepth ? gl.DEPTH_BUFFER_BIT : 0;\r\n    bufferBits |= rtWrapper._generateStencilBuffer && rtWrapper.resolveMSAAStencil ? gl.STENCIL_BUFFER_BIT : 0;\r\n\r\n    const attachments = rtWrapper._attachments!;\r\n    const count = attachments.length;\r\n\r\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, rtWrapper._MSAAFramebuffer);\r\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, rtWrapper._framebuffer);\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const texture = rtWrapper.textures![i];\r\n\r\n        for (let j = 0; j < count; j++) {\r\n            attachments[j] = gl.NONE;\r\n        }\r\n\r\n        attachments[i] = (<any>gl)[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n        gl.readBuffer(attachments[i]);\r\n        gl.drawBuffers(attachments);\r\n        gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, bufferBits, gl.NEAREST);\r\n    }\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        attachments[i] = (<any>gl)[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n    }\r\n\r\n    gl.drawBuffers(attachments);\r\n    gl.bindFramebuffer(this._gl.FRAMEBUFFER, rtWrapper._MSAAFramebuffer);\r\n};\r\n"],
  "mappings": "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",
  "names": ["i", "framebuffer", "texture"]
}
