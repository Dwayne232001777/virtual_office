{
  "version": 3,
  "sources": ["../../../dev/core/src/Collisions/intersectionInfo.ts", "../../../dev/core/src/Culling/boundingBox.ts", "../../../dev/core/src/Culling/boundingSphere.ts", "../../../dev/core/src/Culling/boundingInfo.ts", "../../../dev/core/src/Meshes/subMesh.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class IntersectionInfo {\r\n    public faceId = 0;\r\n    public subMeshId = 0;\r\n    public _internalSubMeshId = 0;\r\n\r\n    constructor(\r\n        public bu: Nullable<number>,\r\n        public bv: Nullable<number>,\r\n        public distance: number\r\n    ) {}\r\n}\r\n", "import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { BoundingSphere } from \"../Culling/boundingSphere\";\r\n\r\nimport type { ICullable } from \"./boundingInfo\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\nimport type { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\n/**\r\n * Class used to store bounding box information\r\n */\r\nexport class BoundingBox implements ICullable {\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in local space\r\n     */\r\n    public readonly vectors: Vector3[] = BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the center of the bounding box in local space\r\n     */\r\n    public readonly center: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the center of the bounding box in world space\r\n     */\r\n    public readonly centerWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets half the size of the extent in local space. Multiply by 2 to obtain the full size of the box!\r\n     */\r\n    public readonly extendSize: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets half the size of the extent in world space. Multiply by 2 to obtain the full size of the box!\r\n     */\r\n    public readonly extendSizeWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the OBB (object bounding box) directions\r\n     */\r\n    public readonly directions: Vector3[] = BuildArray(3, Vector3.Zero);\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in world space\r\n     */\r\n    public readonly vectorsWorld: Vector3[] = BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the minimum vector in world space\r\n     */\r\n    public readonly minimumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in world space\r\n     */\r\n    public readonly maximumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\r\n    public readonly minimum: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\r\n    public readonly maximum: Vector3 = Vector3.Zero();\r\n\r\n    private _worldMatrix: DeepImmutable<Matrix>;\r\n    private static readonly _TmpVector3 = BuildArray(3, Vector3.Zero);\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _tag: number;\r\n\r\n    /** @internal */\r\n    public _drawWrapperFront: Nullable<DrawWrapper> = null;\r\n    /** @internal */\r\n    public _drawWrapperBack: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Creates a new bounding box\r\n     * @param min defines the minimum vector (in local space)\r\n     * @param max defines the maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Recreates the entire bounding box from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const vectors = this.vectors;\r\n\r\n        this.minimum.copyFromFloats(minX, minY, minZ);\r\n        this.maximum.copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[0].copyFromFloats(minX, minY, minZ);\r\n        vectors[1].copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[2].copyFromFloats(maxX, minY, minZ);\r\n        vectors[3].copyFromFloats(minX, maxY, minZ);\r\n        vectors[4].copyFromFloats(minX, minY, maxZ);\r\n        vectors[5].copyFromFloats(maxX, maxY, minZ);\r\n        vectors[6].copyFromFloats(minX, maxY, maxZ);\r\n        vectors[7].copyFromFloats(maxX, minY, maxZ);\r\n\r\n        // OBB\r\n        max.addToRef(min, this.center).scaleInPlace(0.5);\r\n        max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\r\n\r\n        this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\r\n\r\n        this._update(this._worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding box by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding box\r\n     */\r\n    public scale(factor: number): BoundingBox {\r\n        const tmpVectors = BoundingBox._TmpVector3;\r\n        const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\r\n        const len = diff.length();\r\n        diff.normalizeFromLength(len);\r\n        const distance = len * factor;\r\n        const newRadius = diff.scaleInPlace(distance * 0.5);\r\n\r\n        const min = this.center.subtractToRef(newRadius, tmpVectors[1]);\r\n        const max = this.center.addToRef(newRadius, tmpVectors[2]);\r\n\r\n        this.reConstruct(min, max, this._worldMatrix);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix of the bounding box\r\n     * @returns a matrix\r\n     */\r\n    public getWorldMatrix(): DeepImmutable<Matrix> {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _update(world: DeepImmutable<Matrix>): void {\r\n        const minWorld = this.minimumWorld;\r\n        const maxWorld = this.maximumWorld;\r\n        const directions = this.directions;\r\n        const vectorsWorld = this.vectorsWorld;\r\n        const vectors = this.vectors;\r\n\r\n        if (!world.isIdentity()) {\r\n            minWorld.setAll(Number.MAX_VALUE);\r\n            maxWorld.setAll(-Number.MAX_VALUE);\r\n\r\n            for (let index = 0; index < 8; ++index) {\r\n                const v = vectorsWorld[index];\r\n                Vector3.TransformCoordinatesToRef(vectors[index], world, v);\r\n                minWorld.minimizeInPlace(v);\r\n                maxWorld.maximizeInPlace(v);\r\n            }\r\n\r\n            // Extend\r\n            maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\r\n            maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\r\n        } else {\r\n            minWorld.copyFrom(this.minimum);\r\n            maxWorld.copyFrom(this.maximum);\r\n            for (let index = 0; index < 8; ++index) {\r\n                vectorsWorld[index].copyFrom(vectors[index]);\r\n            }\r\n\r\n            // Extend\r\n            this.extendSizeWorld.copyFrom(this.extendSize);\r\n            this.centerWorld.copyFrom(this.center);\r\n        }\r\n\r\n        Vector3.FromArrayToRef(world.m, 0, directions[0]);\r\n        Vector3.FromArrayToRef(world.m, 4, directions[1]);\r\n        Vector3.FromArrayToRef(world.m, 8, directions[2]);\r\n\r\n        this._worldMatrix = world;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is intersecting the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is entirely inside the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is inside the bounding box\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside the bounding box\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        const min = this.minimumWorld;\r\n        const max = this.maximumWorld;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const pointX = point.x,\r\n            pointY = point.y,\r\n            pointZ = point.z;\r\n        const delta = -Epsilon;\r\n\r\n        if (maxX - pointX < delta || delta > pointX - minX) {\r\n            return false;\r\n        }\r\n\r\n        if (maxY - pointY < delta || delta > pointY - minY) {\r\n            return false;\r\n        }\r\n\r\n        if (maxZ - pointZ < delta || delta > pointZ - minZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a bounding sphere\r\n     * @param sphere defines the sphere to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>): boolean {\r\n        return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a box defined by a min and max vectors\r\n     * @param min defines the min vector to use\r\n     * @param max defines the max vector to use\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsMinMax(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>): boolean {\r\n        const myMin = this.minimumWorld;\r\n        const myMax = this.maximumWorld;\r\n        const myMinX = myMin.x,\r\n            myMinY = myMin.y,\r\n            myMinZ = myMin.z,\r\n            myMaxX = myMax.x,\r\n            myMaxY = myMax.y,\r\n            myMaxZ = myMax.z;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        if (myMaxX < minX || myMinX > maxX) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxY < minY || myMinY > maxY) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxZ < minZ || myMinZ > maxZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the class\r\n     */\r\n    public dispose(): void {\r\n        this._drawWrapperFront?.dispose();\r\n        this._drawWrapperBack?.dispose();\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Tests if two bounding boxes are intersections\r\n     * @param box0 defines the first box to test\r\n     * @param box1 defines the second box to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static Intersects(box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean {\r\n        return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defines by a min/max vectors intersects a sphere\r\n     * @param minPoint defines the minimum vector of the bounding box\r\n     * @param maxPoint defines the maximum vector of the bounding box\r\n     * @param sphereCenter defines the sphere center\r\n     * @param sphereRadius defines the sphere radius\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IntersectsSphere(minPoint: DeepImmutable<Vector3>, maxPoint: DeepImmutable<Vector3>, sphereCenter: DeepImmutable<Vector3>, sphereRadius: number): boolean {\r\n        const vector = BoundingBox._TmpVector3[0];\r\n        Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\r\n        const num = Vector3.DistanceSquared(sphereCenter, vector);\r\n        return num <= sphereRadius * sphereRadius;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public static IsCompletelyInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors intersects frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IsInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            let canReturnFalse = true;\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\r\n                    canReturnFalse = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (canReturnFalse) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n", "import type { DeepImmutable } from \"../types\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\n/**\r\n * Class used to store bounding sphere information\r\n */\r\nexport class BoundingSphere {\r\n    /**\r\n     * Gets the center of the bounding sphere in local space\r\n     */\r\n    public readonly center = Vector3.Zero();\r\n    /**\r\n     * Radius of the bounding sphere in local space\r\n     */\r\n    public radius: number;\r\n    /**\r\n     * Gets the center of the bounding sphere in world space\r\n     */\r\n    public readonly centerWorld = Vector3.Zero();\r\n    /**\r\n     * Radius of the bounding sphere in world space\r\n     */\r\n    public radiusWorld: number;\r\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\r\n    public readonly minimum = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\r\n    public readonly maximum = Vector3.Zero();\r\n\r\n    private _worldMatrix: DeepImmutable<Matrix>;\r\n    private static readonly _TmpVector3 = BuildArray(3, Vector3.Zero);\r\n\r\n    /**\r\n     * Creates a new bounding sphere\r\n     * @param min defines the minimum vector (in local space)\r\n     * @param max defines the maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Recreates the entire bounding sphere from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.minimum.copyFrom(min);\r\n        this.maximum.copyFrom(max);\r\n\r\n        const distance = Vector3.Distance(min, max);\r\n\r\n        max.addToRef(min, this.center).scaleInPlace(0.5);\r\n        this.radius = distance * 0.5;\r\n\r\n        this._update(worldMatrix || Matrix.IdentityReadOnly);\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding sphere by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding box\r\n     */\r\n    public scale(factor: number): BoundingSphere {\r\n        const newRadius = this.radius * factor;\r\n        const tmpVectors = BoundingSphere._TmpVector3;\r\n        const tempRadiusVector = tmpVectors[0].setAll(newRadius);\r\n        const min = this.center.subtractToRef(tempRadiusVector, tmpVectors[1]);\r\n        const max = this.center.addToRef(tempRadiusVector, tmpVectors[2]);\r\n\r\n        this.reConstruct(min, max, this._worldMatrix);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix of the bounding box\r\n     * @returns a matrix\r\n     */\r\n    public getWorldMatrix(): DeepImmutable<Matrix> {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * @internal\r\n     */\r\n    public _update(worldMatrix: DeepImmutable<Matrix>): void {\r\n        if (!worldMatrix.isIdentity()) {\r\n            Vector3.TransformCoordinatesToRef(this.center, worldMatrix, this.centerWorld);\r\n            const tempVector = BoundingSphere._TmpVector3[0];\r\n            Vector3.TransformNormalFromFloatsToRef(1.0, 1.0, 1.0, worldMatrix, tempVector);\r\n            this.radiusWorld = Math.max(Math.abs(tempVector.x), Math.abs(tempVector.y), Math.abs(tempVector.z)) * this.radius;\r\n        } else {\r\n            this.centerWorld.copyFrom(this.center);\r\n            this.radiusWorld = this.radius;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding sphere is intersecting the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        const center = this.centerWorld;\r\n        const radius = this.radiusWorld;\r\n        for (let i = 0; i < 6; i++) {\r\n            if (frustumPlanes[i].dotCoordinate(center) <= -radius) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding sphere center is in between the frustum planes.\r\n     * Used for optimistic fast inclusion.\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if the sphere center is in between the frustum planes\r\n     */\r\n    public isCenterInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        const center = this.centerWorld;\r\n        for (let i = 0; i < 6; i++) {\r\n            if (frustumPlanes[i].dotCoordinate(center) < 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is inside the bounding sphere\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside the bounding sphere\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        const squareDistance = Vector3.DistanceSquared(this.centerWorld, point);\r\n        if (this.radiusWorld * this.radiusWorld < squareDistance) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Checks if two sphere intersect\r\n     * @param sphere0 sphere 0\r\n     * @param sphere1 sphere 1\r\n     * @returns true if the spheres intersect\r\n     */\r\n    public static Intersects(sphere0: DeepImmutable<BoundingSphere>, sphere1: DeepImmutable<BoundingSphere>): boolean {\r\n        const squareDistance = Vector3.DistanceSquared(sphere0.centerWorld, sphere1.centerWorld);\r\n        const radiusSum = sphere0.radiusWorld + sphere1.radiusWorld;\r\n\r\n        if (radiusSum * radiusSum < squareDistance) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates a sphere from a center and a radius\r\n     * @param center The center\r\n     * @param radius radius\r\n     * @param matrix Optional worldMatrix\r\n     * @returns The sphere\r\n     */\r\n    public static CreateFromCenterAndRadius(center: DeepImmutable<Vector3>, radius: number, matrix?: DeepImmutable<Matrix>): BoundingSphere {\r\n        this._TmpVector3[0].copyFrom(center);\r\n        this._TmpVector3[1].copyFromFloats(0, 0, radius);\r\n        this._TmpVector3[2].copyFrom(center);\r\n        this._TmpVector3[0].addInPlace(this._TmpVector3[1]);\r\n        this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);\r\n\r\n        const sphere = new BoundingSphere(this._TmpVector3[0], this._TmpVector3[2]);\r\n\r\n        if (matrix) {\r\n            sphere._worldMatrix = matrix;\r\n        } else {\r\n            sphere._worldMatrix = Matrix.Identity();\r\n        }\r\n\r\n        return sphere;\r\n    }\r\n}\r\n", "import type { DeepImmutable } from \"../types\";\r\nimport { BuildArray } from \"../Misc/arrayTools\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { BoundingBox } from \"./boundingBox\";\r\nimport { BoundingSphere } from \"./boundingSphere\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\n\r\nconst _Result0 = { min: 0, max: 0 };\r\nconst _Result1 = { min: 0, max: 0 };\r\nconst ComputeBoxExtents = (axis: DeepImmutable<Vector3>, box: DeepImmutable<BoundingBox>, result: { min: number; max: number }) => {\r\n    const p = Vector3.Dot(box.centerWorld, axis);\r\n\r\n    const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;\r\n    const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;\r\n    const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;\r\n\r\n    const r = r0 + r1 + r2;\r\n    result.min = p - r;\r\n    result.max = p + r;\r\n};\r\n\r\nconst AxisOverlap = (axis: DeepImmutable<Vector3>, box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean => {\r\n    ComputeBoxExtents(axis, box0, _Result0);\r\n    ComputeBoxExtents(axis, box1, _Result1);\r\n    return !(_Result0.min > _Result1.max || _Result1.min > _Result0.max);\r\n};\r\n\r\n/**\r\n * Interface for cullable objects\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#back-face-culling\r\n */\r\nexport interface ICullable {\r\n    /**\r\n     * Checks if the object or part of the object is in the frustum\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isInFrustum(frustumPlanes: Plane[]): boolean;\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;\r\n}\r\n\r\n/**\r\n * Info for a bounding data of a mesh\r\n */\r\nexport class BoundingInfo implements ICullable {\r\n    /**\r\n     * Bounding box for the mesh\r\n     */\r\n    public readonly boundingBox: BoundingBox;\r\n    /**\r\n     * Bounding sphere for the mesh\r\n     */\r\n    public readonly boundingSphere: BoundingSphere;\r\n\r\n    private _isLocked = false;\r\n\r\n    private static readonly _TmpVector3 = BuildArray(2, Vector3.Zero);\r\n\r\n    /**\r\n     * Constructs bounding info\r\n     * @param minimum min vector of the bounding box/sphere\r\n     * @param maximum max vector of the bounding box/sphere\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);\r\n        this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Recreates the entire bounding info from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox.reConstruct(min, max, worldMatrix);\r\n        this.boundingSphere.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * min vector of the bounding box/sphere\r\n     */\r\n    public get minimum(): Vector3 {\r\n        return this.boundingBox.minimum;\r\n    }\r\n\r\n    /**\r\n     * max vector of the bounding box/sphere\r\n     */\r\n    public get maximum(): Vector3 {\r\n        return this.boundingBox.maximum;\r\n    }\r\n\r\n    /**\r\n     * If the info is locked and won't be updated to avoid perf overhead\r\n     */\r\n    public get isLocked(): boolean {\r\n        return this._isLocked;\r\n    }\r\n\r\n    public set isLocked(value: boolean) {\r\n        this._isLocked = value;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Updates the bounding sphere and box\r\n     * @param world world matrix to be used to update\r\n     */\r\n    public update(world: DeepImmutable<Matrix>) {\r\n        if (this._isLocked) {\r\n            return;\r\n        }\r\n        this.boundingBox._update(world);\r\n        this.boundingSphere._update(world);\r\n    }\r\n\r\n    /**\r\n     * Recreate the bounding info to be centered around a specific point given a specific extend.\r\n     * @param center New center of the bounding info\r\n     * @param extend New extend of the bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public centerOn(center: DeepImmutable<Vector3>, extend: DeepImmutable<Vector3>): BoundingInfo {\r\n        const minimum = BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);\r\n        const maximum = BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);\r\n\r\n        this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n        this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grows the bounding info to include the given point.\r\n     * @param point The point that will be included in the current bounding info (in local space)\r\n     * @returns the current bounding info\r\n     */\r\n    public encapsulate(point: Vector3): BoundingInfo {\r\n        const minimum = Vector3.Minimize(this.minimum, point);\r\n        const maximum = Vector3.Maximize(this.maximum, point);\r\n        this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grows the bounding info to encapsulate the given bounding info.\r\n     * @param toEncapsulate The bounding info that will be encapsulated in the current bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public encapsulateBoundingInfo(toEncapsulate: BoundingInfo): BoundingInfo {\r\n        const invw = TmpVectors.Matrix[0];\r\n        this.boundingBox.getWorldMatrix().invertToRef(invw);\r\n\r\n        const v = TmpVectors.Vector3[0];\r\n\r\n        Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.minimumWorld, invw, v);\r\n        this.encapsulate(v);\r\n\r\n        Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.maximumWorld, invw, v);\r\n        this.encapsulate(v);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding info by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding info\r\n     */\r\n    public scale(factor: number): BoundingInfo {\r\n        this.boundingBox.scale(factor);\r\n        this.boundingSphere.scale(factor);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)\r\n     * The different strategies available are:\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD most accurate but slower @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_STANDARD\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY faster but less accurate @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * @returns true if the bounding info is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>, strategy: number = Constants.MESHES_CULLINGSTRATEGY_STANDARD): boolean {\r\n        const inclusionTest =\r\n            strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION || strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n        if (inclusionTest) {\r\n            if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!this.boundingSphere.isInFrustum(frustumPlanes)) {\r\n            return false;\r\n        }\r\n\r\n        const bSphereOnlyTest =\r\n            strategy === Constants.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY || strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n        if (bSphereOnlyTest) {\r\n            return true;\r\n        }\r\n\r\n        return this.boundingBox.isInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Gets the world distance between the min and max points of the bounding box\r\n     */\r\n    public get diagonalLength(): number {\r\n        const boundingBox = this.boundingBox;\r\n        const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo._TmpVector3[0]);\r\n        return diag.length();\r\n    }\r\n\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return this.boundingBox.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Checks if a point is inside the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\r\n     * @param point the point to check intersection with\r\n     * @returns if the point intersects\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        if (!this.boundingSphere.centerWorld) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingSphere.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingBox.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\r\n     * @param boundingInfo the bounding info to check intersection with\r\n     * @param precise if the intersection should be done using OBB\r\n     * @returns if the bounding info intersects\r\n     */\r\n    public intersects(boundingInfo: DeepImmutable<BoundingInfo>, precise: boolean): boolean {\r\n        if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {\r\n            return false;\r\n        }\r\n\r\n        if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {\r\n            return false;\r\n        }\r\n\r\n        if (!precise) {\r\n            return true;\r\n        }\r\n\r\n        const box0 = this.boundingBox;\r\n        const box1 = boundingInfo.boundingBox;\r\n\r\n        if (!AxisOverlap(box0.directions[0], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!AxisOverlap(box0.directions[1], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!AxisOverlap(box0.directions[2], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!AxisOverlap(box1.directions[0], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!AxisOverlap(box1.directions[1], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!AxisOverlap(box1.directions[2], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!AxisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!AxisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!AxisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!AxisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!AxisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!AxisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!AxisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!AxisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!AxisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n", "import type { Nullable, IndicesArray, DeepImmutable, FloatArray } from \"../types\";\r\nimport type { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { ICullable } from \"../Culling/boundingInfo\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { extractMinAndMaxIndexed } from \"../Maths/math.functions\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { MaterialDefines } from \"../Materials/materialDefines\";\r\nimport type { MultiMaterial } from \"../Materials/multiMaterial\";\r\nimport type { AbstractMesh } from \"./abstractMesh\";\r\nimport type { Mesh } from \"./mesh\";\r\nimport type { Ray } from \"../Culling/ray\";\r\nimport type { TrianglePickingPredicate } from \"../Culling/ray\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * Defines a subdivision inside a mesh\r\n */\r\nexport class SubMesh implements ICullable {\r\n    private _engine: AbstractEngine;\r\n    /** @internal */\r\n    public _drawWrappers: Array<DrawWrapper>; // index in this array = pass id\r\n    private _mainDrawWrapperOverride: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Gets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public get materialDefines(): Nullable<MaterialDefines> {\r\n        return this._mainDrawWrapperOverride ? (this._mainDrawWrapperOverride.defines as MaterialDefines) : (this._getDrawWrapper()?.defines as Nullable<MaterialDefines>);\r\n    }\r\n\r\n    /**\r\n     * Sets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public set materialDefines(defines: Nullable<MaterialDefines>) {\r\n        const drawWrapper = this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true)!;\r\n        drawWrapper.defines = defines;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getDrawWrapper(passId?: number, createIfNotExisting = false): DrawWrapper | undefined {\r\n        passId = passId ?? this._engine.currentRenderPassId;\r\n        let drawWrapper = this._drawWrappers[passId];\r\n        if (!drawWrapper && createIfNotExisting) {\r\n            this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());\r\n        }\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _removeDrawWrapper(passId: number, disposeWrapper = true, immediate = false): void {\r\n        if (disposeWrapper) {\r\n            this._drawWrappers[passId]?.dispose(immediate);\r\n        }\r\n        this._drawWrappers[passId] = undefined as any;\r\n    }\r\n\r\n    /**\r\n     * Gets associated (main) effect (possibly the effect override if defined)\r\n     */\r\n    public get effect(): Nullable<Effect> {\r\n        return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (this._getDrawWrapper()?.effect ?? null);\r\n    }\r\n\r\n    /** @internal */\r\n    public get _drawWrapper(): DrawWrapper {\r\n        return this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true)!;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _drawWrapperOverride(): Nullable<DrawWrapper> {\r\n        return this._mainDrawWrapperOverride;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setMainDrawWrapperOverride(wrapper: Nullable<DrawWrapper>): void {\r\n        this._mainDrawWrapperOverride = wrapper;\r\n    }\r\n\r\n    /**\r\n     * Sets associated effect (effect used to render this submesh)\r\n     * @param effect defines the effect to associate with\r\n     * @param defines defines the set of defines used to compile this effect\r\n     * @param materialContext material context associated to the effect\r\n     * @param resetContext true to reset the draw context\r\n     */\r\n    public setEffect(effect: Nullable<Effect>, defines: Nullable<string | MaterialDefines> = null, materialContext?: IMaterialContext, resetContext = true) {\r\n        const drawWrapper = this._drawWrapper;\r\n        drawWrapper.setEffect(effect, defines, resetContext);\r\n        if (materialContext !== undefined) {\r\n            drawWrapper.materialContext = materialContext;\r\n        }\r\n        if (!effect) {\r\n            drawWrapper.defines = null;\r\n            drawWrapper.materialContext = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache\r\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\r\n     * @param immediate If true, the draw wrapper will dispose the effect immediately (false by default)\r\n     */\r\n    public resetDrawCache(passId?: number, immediate = false): void {\r\n        if (this._drawWrappers) {\r\n            if (passId !== undefined) {\r\n                this._removeDrawWrapper(passId, true, immediate);\r\n                return;\r\n            } else {\r\n                for (const drawWrapper of this._drawWrappers) {\r\n                    drawWrapper?.dispose(immediate);\r\n                }\r\n            }\r\n        }\r\n        this._drawWrappers = [];\r\n    }\r\n\r\n    /** @internal */\r\n    public _linesIndexCount: number = 0;\r\n    private _mesh: AbstractMesh;\r\n    private _renderingMesh: Mesh;\r\n    private _boundingInfo: BoundingInfo;\r\n    private _linesIndexBuffer: Nullable<DataBuffer> = null;\r\n    /** @internal */\r\n    public _lastColliderWorldVertices: Nullable<Vector3[]> = null;\r\n    /** @internal */\r\n    public _trianglePlanes: Plane[];\r\n    /** @internal */\r\n    public _lastColliderTransformMatrix: Nullable<Matrix> = null;\r\n    /** @internal */\r\n    public _wasDispatched = false;\r\n\r\n    /** @internal */\r\n    public _renderId = 0;\r\n    /** @internal */\r\n    public _alphaIndex: number = 0;\r\n    /** @internal */\r\n    public _distanceToCamera: number = 0;\r\n    /** @internal */\r\n    public _id: number;\r\n\r\n    private _currentMaterial: Nullable<Material> = null;\r\n\r\n    /**\r\n     * Add a new submesh to a mesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns the new submesh\r\n     */\r\n    public static AddToMesh(\r\n        materialIndex: number,\r\n        verticesStart: number,\r\n        verticesCount: number,\r\n        indexStart: number,\r\n        indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true\r\n    ): SubMesh {\r\n        return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n\r\n    /**\r\n     * Creates a new submesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\r\n     */\r\n    constructor(\r\n        /** the material index to use */\r\n        public materialIndex: number,\r\n        /** vertex index start */\r\n        public verticesStart: number,\r\n        /** vertices count */\r\n        public verticesCount: number,\r\n        /** index start */\r\n        public indexStart: number,\r\n        /** indices count */\r\n        public indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true,\r\n        addToMesh = true\r\n    ) {\r\n        this._mesh = mesh;\r\n        this._renderingMesh = renderingMesh || <Mesh>mesh;\r\n        if (addToMesh) {\r\n            mesh.subMeshes.push(this);\r\n        }\r\n\r\n        this._engine = this._mesh.getScene().getEngine();\r\n        this.resetDrawCache();\r\n        this._trianglePlanes = [];\r\n\r\n        this._id = mesh.subMeshes.length - 1;\r\n\r\n        if (createBoundingBox) {\r\n            this.refreshBoundingInfo();\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if this submesh covers the entire parent mesh\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get IsGlobal(): boolean {\r\n        return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh BoundingInfo object\r\n     * @returns current bounding info (or mesh's one if the submesh is global)\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        if (this.IsGlobal || this._mesh.hasThinInstances) {\r\n            return this._mesh.getBoundingInfo();\r\n        }\r\n\r\n        return this._boundingInfo;\r\n    }\r\n\r\n    /**\r\n     * Sets the submesh BoundingInfo\r\n     * @param boundingInfo defines the new bounding info to use\r\n     * @returns the SubMesh\r\n     */\r\n    public setBoundingInfo(boundingInfo: BoundingInfo): SubMesh {\r\n        this._boundingInfo = boundingInfo;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh of the current submesh\r\n     * @returns the parent mesh\r\n     */\r\n    public getMesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the rendering mesh of the submesh\r\n     * @returns the rendering mesh (could be different from parent mesh)\r\n     */\r\n    public getRenderingMesh(): Mesh {\r\n        return this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the replacement mesh of the submesh\r\n     * @returns the replacement mesh (could be different from parent mesh)\r\n     */\r\n    public getReplacementMesh(): Nullable<AbstractMesh> {\r\n        return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n    }\r\n\r\n    /**\r\n     * Returns the effective mesh of the submesh\r\n     * @returns the effective mesh (could be different from parent mesh)\r\n     */\r\n    public getEffectiveMesh(): AbstractMesh {\r\n        const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n\r\n        return replacementMesh ? replacementMesh : this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh material\r\n     * @param getDefaultMaterial Defines whether or not to get the default material if nothing has been defined.\r\n     * @returns null or the current material\r\n     */\r\n    public getMaterial(getDefaultMaterial = true): Nullable<Material> {\r\n        const rootMaterial = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId) ?? this._renderingMesh.material;\r\n\r\n        if (!rootMaterial) {\r\n            return getDefaultMaterial && this._mesh.getScene()._hasDefaultMaterial ? this._mesh.getScene().defaultMaterial : null;\r\n        } else if (this._isMultiMaterial(rootMaterial)) {\r\n            const effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\r\n\r\n            if (this._currentMaterial !== effectiveMaterial) {\r\n                this._currentMaterial = effectiveMaterial;\r\n                this.resetDrawCache();\r\n            }\r\n\r\n            return effectiveMaterial;\r\n        }\r\n\r\n        return rootMaterial;\r\n    }\r\n\r\n    private _isMultiMaterial(material: Material): material is MultiMaterial {\r\n        return (material as MultiMaterial).getSubMaterial !== undefined;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Sets a new updated BoundingInfo object to the submesh\r\n     * @param data defines an optional position array to use to determine the bounding info\r\n     * @returns the SubMesh\r\n     */\r\n    public refreshBoundingInfo(data: Nullable<FloatArray> = null): SubMesh {\r\n        this._lastColliderWorldVertices = null;\r\n\r\n        if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\r\n            return this;\r\n        }\r\n\r\n        if (!data) {\r\n            data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\r\n        }\r\n\r\n        if (!data) {\r\n            this._boundingInfo = this._mesh.getBoundingInfo();\r\n            return this;\r\n        }\r\n\r\n        const indices = <IndicesArray>this._renderingMesh.getIndices();\r\n        let extend: { minimum: Vector3; maximum: Vector3 };\r\n\r\n        //is this the only submesh?\r\n        if (this.indexStart === 0 && this.indexCount === indices.length) {\r\n            const boundingInfo = this._renderingMesh.getBoundingInfo();\r\n\r\n            //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\r\n            extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };\r\n        } else {\r\n            extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\r\n        }\r\n\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\r\n        } else {\r\n            this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        return boundingInfo._checkCollision(collider);\r\n    }\r\n\r\n    /**\r\n     * Updates the submesh BoundingInfo\r\n     * @param world defines the world matrix to use to update the bounding info\r\n     * @returns the submesh\r\n     */\r\n    public updateBoundingInfo(world: DeepImmutable<Matrix>): SubMesh {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            this.refreshBoundingInfo();\r\n            boundingInfo = this.getBoundingInfo();\r\n        }\r\n        if (boundingInfo) {\r\n            boundingInfo.update(world);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is intersecting with the frustum\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is inside the frustum\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Plane[]): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh\r\n     * @param enableAlphaMode defines if alpha needs to be used\r\n     * @returns the submesh\r\n     */\r\n    public render(enableAlphaMode: boolean): SubMesh {\r\n        this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getLinesIndexBuffer(indices: IndicesArray, engine: AbstractEngine): DataBuffer {\r\n        if (!this._linesIndexBuffer) {\r\n            const adjustedIndexCount = Math.floor(this.indexCount / 3) * 6;\r\n            const shouldUseUint32 = this.verticesStart + this.verticesCount > 65535;\r\n            const linesIndices = shouldUseUint32 ? new Uint32Array(adjustedIndexCount) : new Uint16Array(adjustedIndexCount);\r\n\r\n            let offset = 0;\r\n            if (indices.length === 0) {\r\n                // Unindexed mesh\r\n                for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\r\n                    linesIndices[offset++] = index;\r\n                    linesIndices[offset++] = index + 1;\r\n                    linesIndices[offset++] = index + 1;\r\n                    linesIndices[offset++] = index + 2;\r\n                    linesIndices[offset++] = index + 2;\r\n                    linesIndices[offset++] = index;\r\n                }\r\n            } else {\r\n                for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\r\n                    linesIndices[offset++] = indices[index];\r\n                    linesIndices[offset++] = indices[index + 1];\r\n                    linesIndices[offset++] = indices[index + 1];\r\n                    linesIndices[offset++] = indices[index + 2];\r\n                    linesIndices[offset++] = indices[index + 2];\r\n                    linesIndices[offset++] = indices[index];\r\n                }\r\n            }\r\n\r\n            this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\r\n            this._linesIndexCount = linesIndices.length;\r\n        }\r\n        return this._linesIndexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Checks if the submesh intersects with a ray\r\n     * @param ray defines the ray to test\r\n     * @returns true is the passed ray intersects the submesh bounding box\r\n     */\r\n    public canIntersects(ray: Ray): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return ray.intersectsBox(boundingInfo.boundingBox);\r\n    }\r\n\r\n    /**\r\n     * Intersects current submesh with a ray\r\n     * @param ray defines the ray to test\r\n     * @param positions defines mesh's positions array\r\n     * @param indices defines mesh's indices array\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns intersection info or null if no intersection\r\n     */\r\n    public intersects(ray: Ray, positions: Vector3[], indices: IndicesArray, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<IntersectionInfo> {\r\n        const material = this.getMaterial();\r\n        if (!material) {\r\n            return null;\r\n        }\r\n        let step = 3;\r\n        let checkStopper = false;\r\n\r\n        switch (material.fillMode) {\r\n            case Constants.MATERIAL_PointListDrawMode:\r\n            case Constants.MATERIAL_LineLoopDrawMode:\r\n            case Constants.MATERIAL_LineStripDrawMode:\r\n            case Constants.MATERIAL_TriangleFanDrawMode:\r\n                return null;\r\n            case Constants.MATERIAL_TriangleStripDrawMode:\r\n                step = 1;\r\n                checkStopper = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        // LineMesh first as it's also a Mesh...\r\n        if (material.fillMode === Constants.MATERIAL_LineListDrawMode) {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length) {\r\n                return this._intersectUnIndexedLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n            }\r\n            return this._intersectLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n        } else {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length && this._mesh._unIndexed) {\r\n                return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\r\n            }\r\n\r\n            return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\r\n            const p0 = positions[indices[index]];\r\n            const p1 = positions[indices[index + 1]];\r\n\r\n            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectUnIndexedLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\r\n            const p0 = positions[index];\r\n            const p1 = positions[index + 1];\r\n\r\n            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectTriangles(\r\n        ray: Ray,\r\n        positions: Vector3[],\r\n        indices: IndicesArray,\r\n        step: number,\r\n        checkStopper: boolean,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Triangles test\r\n        let faceId = -1;\r\n        for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\r\n            faceId++;\r\n            const indexA = indices[index];\r\n            const indexB = indices[index + 1];\r\n            const indexC = indices[index + 2];\r\n\r\n            if (checkStopper && indexC === 0xffffffff) {\r\n                index += 2;\r\n                continue;\r\n            }\r\n\r\n            const p0 = positions[indexA];\r\n            const p1 = positions[indexB];\r\n            const p2 = positions[indexC];\r\n\r\n            // stay defensive and don't check against undefined positions.\r\n            if (!p0 || !p1 || !p2) {\r\n                continue;\r\n            }\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, indexA, indexB, indexC)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = faceId;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectUnIndexedTriangles(\r\n        ray: Ray,\r\n        positions: Vector3[],\r\n        indices: IndicesArray,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n        // Triangles test\r\n        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\r\n            const p0 = positions[index];\r\n            const p1 = positions[index + 1];\r\n            const p2 = positions[index + 2];\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, -1, -1, -1)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = index / 3;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._linesIndexBuffer = null;\r\n        }\r\n    }\r\n\r\n    // Clone\r\n    /**\r\n     * Creates a new submesh from the passed mesh\r\n     * @param newMesh defines the new hosting mesh\r\n     * @param newRenderingMesh defines an optional rendering mesh\r\n     * @returns the new submesh\r\n     */\r\n    public clone(newMesh: AbstractMesh, newRenderingMesh?: Mesh): SubMesh {\r\n        const result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\r\n\r\n        if (!this.IsGlobal) {\r\n            const boundingInfo = this.getBoundingInfo();\r\n\r\n            if (!boundingInfo) {\r\n                return result;\r\n            }\r\n\r\n            result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Dispose\r\n\r\n    /**\r\n     * Release associated resources\r\n     * @param immediate If true, the effect will be disposed immediately (false by default)\r\n     */\r\n    public dispose(immediate = false): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\r\n            this._linesIndexBuffer = null;\r\n        }\r\n\r\n        // Remove from mesh\r\n        const index = this._mesh.subMeshes.indexOf(this);\r\n        this._mesh.subMeshes.splice(index, 1);\r\n\r\n        this.resetDrawCache(undefined, immediate);\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns the string \"SubMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"SubMesh\";\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a new submesh from indices data\r\n     * @param materialIndex the index of the main mesh material\r\n     * @param startIndex the index where to start the copy in the mesh indices array\r\n     * @param indexCount the number of indices to copy then from the startIndex\r\n     * @param mesh the main mesh to create the submesh from\r\n     * @param renderingMesh the optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns a new submesh\r\n     */\r\n    public static CreateFromIndices(\r\n        materialIndex: number,\r\n        startIndex: number,\r\n        indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true\r\n    ): SubMesh {\r\n        let minVertexIndex = Number.MAX_VALUE;\r\n        let maxVertexIndex = -Number.MAX_VALUE;\r\n\r\n        const whatWillRender = renderingMesh || mesh;\r\n        const indices = whatWillRender.getIndices()!;\r\n\r\n        for (let index = startIndex; index < startIndex + indexCount; index++) {\r\n            const vertexIndex = indices[index];\r\n\r\n            if (vertexIndex < minVertexIndex) {\r\n                minVertexIndex = vertexIndex;\r\n            }\r\n            if (vertexIndex > maxVertexIndex) {\r\n                maxVertexIndex = vertexIndex;\r\n            }\r\n        }\r\n\r\n        return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
