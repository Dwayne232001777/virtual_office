import {
  ArcRotateCameraInputsManager,
  CameraInputTypes,
  CameraInputsManager,
  CustomParticleEmitter,
  FrameGraph,
  FrameGraphObjectRendererTask,
  FrameGraphTask,
  FrameGraphTaskMultiRenderTarget,
  FreeCamera,
  FreeCameraInputsManager,
  backbufferColorTextureHandle,
  backbufferDepthStencilTextureHandle,
  editableInPropertyPage,
  init_arcRotateCameraInputsManager,
  init_cameraInputsManager,
  init_customParticleEmitter,
  init_frameGraph,
  init_frameGraphTask,
  init_frameGraphTaskMultiRenderTarget,
  init_frameGraphTypes,
  init_freeCamera,
  init_freeCameraInputsManager,
  init_nodeDecorator,
  init_objectRendererTask
} from "./chunk-YERFS6AN.js";
import {
  Camera,
  GetEnvironmentBRDFTexture,
  PBRBaseMaterial,
  TargetCamera,
  init_brdfTextureTools,
  init_camera,
  init_pbrBaseMaterial,
  init_targetCamera
} from "./chunk-JWLZD23T.js";
import {
  Material,
  init_material
} from "./chunk-OBADV6JF.js";
import {
  Node,
  init_node
} from "./chunk-E7XHG63E.js";
import {
  KeyboardEventTypes,
  Scene,
  SceneComponentConstants,
  init_keyboardEvents,
  init_scene,
  init_sceneComponent
} from "./chunk-U45B254N.js";
import {
  PointerEventTypes,
  init_pointerEvents
} from "./chunk-CCNHJS5Q.js";
import {
  UniqueIdGenerator,
  init_uniqueIdGenerator
} from "./chunk-3DVETICX.js";
import {
  Axis,
  Engine,
  init_engine,
  init_math_axis
} from "./chunk-E2UXTG46.js";
import {
  SerializationHelper,
  init_decorators_serialization
} from "./chunk-HNJVWIJU.js";
import {
  Color3,
  Color4,
  TmpColors,
  init_math_color
} from "./chunk-FQA5U7KF.js";
import {
  __decorate,
  expandToProperty,
  init_decorators,
  init_tslib_es6,
  serialize,
  serializeAsColor3,
  serializeAsTexture,
  serializeAsVector3
} from "./chunk-KU6EWKFQ.js";
import {
  Tools,
  init_tools
} from "./chunk-TQMUJQOB.js";
import {
  WebRequest,
  init_webRequest
} from "./chunk-T55R2ONV.js";
import {
  AbstractEngine,
  init_abstractEngine
} from "./chunk-WTQMXJ7P.js";
import {
  ShaderStore,
  init_shaderStore
} from "./chunk-4OYBTWIA.js";
import {
  Matrix,
  Quaternion,
  Vector2,
  Vector3,
  init_math_vector
} from "./chunk-VQZCJUUR.js";
import {
  GetClass,
  RegisterClass,
  init_typeStore
} from "./chunk-7ANHXSNA.js";
import {
  IsWindowObjectExist,
  init_domManagement
} from "./chunk-YU3PZQGE.js";
import {
  Logger,
  init_logger
} from "./chunk-2X44KPCK.js";
import {
  Observable,
  init_observable
} from "./chunk-PY47FUFT.js";
import {
  __esm
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@babylonjs/core/Gamepads/gamepad.js
var StickValues, Gamepad, GenericPad;
var init_gamepad = __esm({
  "node_modules/@babylonjs/core/Gamepads/gamepad.js"() {
    init_observable();
    StickValues = class {
      /**
       * Initializes the gamepad x and y control stick values
       * @param x The x component of the gamepad control stick value
       * @param y The y component of the gamepad control stick value
       */
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
    };
    Gamepad = class _Gamepad {
      /**
       * Specifies if the gamepad has been connected
       */
      get isConnected() {
        return this._isConnected;
      }
      /**
       * Initializes the gamepad
       * @param id The id of the gamepad
       * @param index The index of the gamepad
       * @param browserGamepad The browser gamepad
       * @param leftStickX The x component of the left joystick
       * @param leftStickY The y component of the left joystick
       * @param rightStickX The x component of the right joystick
       * @param rightStickY The y component of the right joystick
       */
      constructor(id, index, browserGamepad, leftStickX = 0, leftStickY = 1, rightStickX = 2, rightStickY = 3) {
        this.id = id;
        this.index = index;
        this.browserGamepad = browserGamepad;
        this._leftStick = { x: 0, y: 0 };
        this._rightStick = { x: 0, y: 0 };
        this._isConnected = true;
        this._invertLeftStickY = false;
        this.type = _Gamepad.GAMEPAD;
        this._leftStickAxisX = leftStickX;
        this._leftStickAxisY = leftStickY;
        this._rightStickAxisX = rightStickX;
        this._rightStickAxisY = rightStickY;
        if (this.browserGamepad.axes.length >= 2) {
          this._leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };
        }
        if (this.browserGamepad.axes.length >= 4) {
          this._rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };
        }
      }
      /**
       * Callback triggered when the left joystick has changed
       * @param callback callback to trigger
       */
      onleftstickchanged(callback) {
        this._onleftstickchanged = callback;
      }
      /**
       * Callback triggered when the right joystick has changed
       * @param callback callback to trigger
       */
      onrightstickchanged(callback) {
        this._onrightstickchanged = callback;
      }
      /**
       * Gets the left joystick
       */
      get leftStick() {
        return this._leftStick;
      }
      /**
       * Sets the left joystick values
       */
      set leftStick(newValues) {
        if (this._onleftstickchanged && (this._leftStick.x !== newValues.x || this._leftStick.y !== newValues.y)) {
          this._onleftstickchanged(newValues);
        }
        this._leftStick = newValues;
      }
      /**
       * Gets the right joystick
       */
      get rightStick() {
        return this._rightStick;
      }
      /**
       * Sets the right joystick value
       */
      set rightStick(newValues) {
        if (this._onrightstickchanged && (this._rightStick.x !== newValues.x || this._rightStick.y !== newValues.y)) {
          this._onrightstickchanged(newValues);
        }
        this._rightStick = newValues;
      }
      /**
       * Updates the gamepad joystick positions
       */
      update() {
        if (this._leftStick) {
          this.leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };
          if (this._invertLeftStickY) {
            this.leftStick.y *= -1;
          }
        }
        if (this._rightStick) {
          this.rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };
        }
      }
      /**
       * Disposes the gamepad
       */
      dispose() {
      }
    };
    Gamepad.GAMEPAD = 0;
    Gamepad.GENERIC = 1;
    Gamepad.XBOX = 2;
    Gamepad.POSE_ENABLED = 3;
    Gamepad.DUALSHOCK = 4;
    GenericPad = class extends Gamepad {
      /**
       * Callback triggered when a button has been pressed
       * @param callback Called when a button has been pressed
       */
      onbuttondown(callback) {
        this._onbuttondown = callback;
      }
      /**
       * Callback triggered when a button has been released
       * @param callback Called when a button has been released
       */
      onbuttonup(callback) {
        this._onbuttonup = callback;
      }
      /**
       * Initializes the generic gamepad
       * @param id The id of the generic gamepad
       * @param index The index of the generic gamepad
       * @param browserGamepad The browser gamepad
       */
      constructor(id, index, browserGamepad) {
        super(id, index, browserGamepad);
        this.onButtonDownObservable = new Observable();
        this.onButtonUpObservable = new Observable();
        this.type = Gamepad.GENERIC;
        this._buttons = new Array(browserGamepad.buttons.length);
      }
      _setButtonValue(newValue, currentValue, buttonIndex) {
        if (newValue !== currentValue) {
          if (newValue === 1) {
            if (this._onbuttondown) {
              this._onbuttondown(buttonIndex);
            }
            this.onButtonDownObservable.notifyObservers(buttonIndex);
          }
          if (newValue === 0) {
            if (this._onbuttonup) {
              this._onbuttonup(buttonIndex);
            }
            this.onButtonUpObservable.notifyObservers(buttonIndex);
          }
        }
        return newValue;
      }
      /**
       * Updates the generic gamepad
       */
      update() {
        super.update();
        for (let index = 0; index < this._buttons.length; index++) {
          this._buttons[index] = this._setButtonValue(this.browserGamepad.buttons[index].value, this._buttons[index], index);
        }
      }
      /**
       * Disposes the generic gamepad
       */
      dispose() {
        super.dispose();
        this.onButtonDownObservable.clear();
        this.onButtonUpObservable.clear();
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraGamepadInput.js
var ArcRotateCameraGamepadInput;
var init_arcRotateCameraGamepadInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/arcRotateCameraGamepadInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_gamepad();
    ArcRotateCameraGamepadInput = class {
      constructor() {
        this.gamepadRotationSensibility = 80;
        this.gamepadMoveSensibility = 40;
        this._yAxisScale = 1;
      }
      /**
       * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted
       */
      get invertYAxis() {
        return this._yAxisScale !== 1;
      }
      set invertYAxis(value) {
        this._yAxisScale = value ? -1 : 1;
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       */
      attachControl() {
        const manager = this.camera.getScene().gamepadManager;
        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {
          if (gamepad.type !== Gamepad.POSE_ENABLED) {
            if (!this.gamepad || gamepad.type === Gamepad.XBOX) {
              this.gamepad = gamepad;
            }
          }
        });
        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {
          if (this.gamepad === gamepad) {
            this.gamepad = null;
          }
        });
        this.gamepad = manager.getGamepadByType(Gamepad.XBOX);
        if (!this.gamepad && manager.gamepads.length) {
          this.gamepad = manager.gamepads[0];
        }
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);
        this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);
        this.gamepad = null;
      }
      /**
       * Update the current camera state depending on the inputs that have been used this frame.
       * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
       */
      checkInputs() {
        if (this.gamepad) {
          const camera = this.camera;
          const rsValues = this.gamepad.rightStick;
          if (rsValues) {
            if (rsValues.x != 0) {
              const normalizedRX = rsValues.x / this.gamepadRotationSensibility;
              if (normalizedRX != 0 && Math.abs(normalizedRX) > 5e-3) {
                camera.inertialAlphaOffset += normalizedRX;
              }
            }
            if (rsValues.y != 0) {
              const normalizedRY = rsValues.y / this.gamepadRotationSensibility * this._yAxisScale;
              if (normalizedRY != 0 && Math.abs(normalizedRY) > 5e-3) {
                camera.inertialBetaOffset += normalizedRY;
              }
            }
          }
          const lsValues = this.gamepad.leftStick;
          if (lsValues && lsValues.y != 0) {
            const normalizedLY = lsValues.y / this.gamepadMoveSensibility;
            if (normalizedLY != 0 && Math.abs(normalizedLY) > 5e-3) {
              this.camera.inertialRadiusOffset -= normalizedLY;
            }
          }
        }
      }
      /**
       * Gets the class name of the current intput.
       * @returns the class name
       */
      getClassName() {
        return "ArcRotateCameraGamepadInput";
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "gamepad";
      }
    };
    __decorate([
      serialize()
    ], ArcRotateCameraGamepadInput.prototype, "gamepadRotationSensibility", void 0);
    __decorate([
      serialize()
    ], ArcRotateCameraGamepadInput.prototype, "gamepadMoveSensibility", void 0);
    CameraInputTypes["ArcRotateCameraGamepadInput"] = ArcRotateCameraGamepadInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/flyCameraKeyboardInput.js
var FlyCameraKeyboardInput;
var init_flyCameraKeyboardInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/flyCameraKeyboardInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_keyboardEvents();
    init_math_vector();
    init_tools();
    FlyCameraKeyboardInput = class {
      constructor() {
        this.keysForward = [87];
        this.keysBackward = [83];
        this.keysUp = [69];
        this.keysDown = [81];
        this.keysRight = [68];
        this.keysLeft = [65];
        this._keys = new Array();
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        if (this._onCanvasBlurObserver) {
          return;
        }
        this._scene = this.camera.getScene();
        this._engine = this._scene.getEngine();
        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {
          this._keys.length = 0;
        });
        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {
          const evt = info.event;
          if (info.type === KeyboardEventTypes.KEYDOWN) {
            if (this.keysForward.indexOf(evt.keyCode) !== -1 || this.keysBackward.indexOf(evt.keyCode) !== -1 || this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1) {
              const index = this._keys.indexOf(evt.keyCode);
              if (index === -1) {
                this._keys.push(evt.keyCode);
              }
              if (!noPreventDefault) {
                evt.preventDefault();
              }
            }
          } else {
            if (this.keysForward.indexOf(evt.keyCode) !== -1 || this.keysBackward.indexOf(evt.keyCode) !== -1 || this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1) {
              const index = this._keys.indexOf(evt.keyCode);
              if (index >= 0) {
                this._keys.splice(index, 1);
              }
              if (!noPreventDefault) {
                evt.preventDefault();
              }
            }
          }
        });
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        if (this._scene) {
          if (this._onKeyboardObserver) {
            this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
          }
          if (this._onCanvasBlurObserver) {
            this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
          }
          this._onKeyboardObserver = null;
          this._onCanvasBlurObserver = null;
        }
        this._keys.length = 0;
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "FlyCameraKeyboardInput";
      }
      /**
       * @internal
       */
      _onLostFocus() {
        this._keys.length = 0;
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "keyboard";
      }
      /**
       * Update the current camera state depending on the inputs that have been used this frame.
       * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
       */
      checkInputs() {
        if (this._onKeyboardObserver) {
          const camera = this.camera;
          for (let index = 0; index < this._keys.length; index++) {
            const keyCode = this._keys[index];
            const speed = camera._computeLocalCameraSpeed();
            if (this.keysForward.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, speed);
            } else if (this.keysBackward.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, -speed);
            } else if (this.keysUp.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, speed, 0);
            } else if (this.keysDown.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, -speed, 0);
            } else if (this.keysRight.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(speed, 0, 0);
            } else if (this.keysLeft.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(-speed, 0, 0);
            }
            if (camera.getScene().useRightHandedSystem) {
              camera._localDirection.z *= -1;
            }
            camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);
            Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);
            camera.cameraDirection.addInPlace(camera._transformedDirection);
          }
        }
      }
    };
    __decorate([
      serialize()
    ], FlyCameraKeyboardInput.prototype, "keysForward", void 0);
    __decorate([
      serialize()
    ], FlyCameraKeyboardInput.prototype, "keysBackward", void 0);
    __decorate([
      serialize()
    ], FlyCameraKeyboardInput.prototype, "keysUp", void 0);
    __decorate([
      serialize()
    ], FlyCameraKeyboardInput.prototype, "keysDown", void 0);
    __decorate([
      serialize()
    ], FlyCameraKeyboardInput.prototype, "keysRight", void 0);
    __decorate([
      serialize()
    ], FlyCameraKeyboardInput.prototype, "keysLeft", void 0);
    CameraInputTypes["FlyCameraKeyboardInput"] = FlyCameraKeyboardInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/flyCameraMouseInput.js
var FlyCameraMouseInput;
var init_flyCameraMouseInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/flyCameraMouseInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_pointerEvents();
    init_math_vector();
    init_math_axis();
    init_tools();
    FlyCameraMouseInput = class {
      /**
       * Listen to mouse events to control the camera.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs
       */
      constructor() {
        this.buttons = [0, 1, 2];
        this.buttonsYaw = [-1, 0, 1];
        this.buttonsPitch = [-1, 0, 1];
        this.buttonsRoll = [2];
        this.activeButton = -1;
        this.angularSensibility = 1e3;
        this._previousPosition = null;
      }
      /**
       * Attach the mouse control to the HTML DOM element.
       * @param noPreventDefault Defines whether events caught by the controls should call preventdefault().
       */
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        this._noPreventDefault = noPreventDefault;
        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver((p) => {
          this._pointerInput(p);
        }, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
        this._rollObserver = this.camera.getScene().onBeforeRenderObservable.add(() => {
          if (this.camera.rollCorrect) {
            this.camera.restoreRoll(this.camera.rollCorrect);
          }
        });
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        if (this._observer) {
          this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
          this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver);
          this._observer = null;
          this._rollObserver = null;
          this._previousPosition = null;
          this._noPreventDefault = void 0;
        }
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name.
       */
      getClassName() {
        return "FlyCameraMouseInput";
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input's friendly name.
       */
      getSimpleName() {
        return "mouse";
      }
      // Track mouse movement, when the pointer is not locked.
      _pointerInput(p) {
        const e = p.event;
        const camera = this.camera;
        const engine = camera.getEngine();
        if (!this.touchEnabled && e.pointerType === "touch") {
          return;
        }
        if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(e.button) === -1) {
          return;
        }
        const srcElement = e.target;
        if (p.type === PointerEventTypes.POINTERDOWN) {
          try {
            srcElement?.setPointerCapture(e.pointerId);
          } catch (e2) {
          }
          this._previousPosition = {
            x: e.clientX,
            y: e.clientY
          };
          this.activeButton = e.button;
          if (!this._noPreventDefault) {
            e.preventDefault();
          }
          if (engine.isPointerLock) {
            this._onMouseMove(p.event);
          }
        } else if (p.type === PointerEventTypes.POINTERUP) {
          try {
            srcElement?.releasePointerCapture(e.pointerId);
          } catch (e2) {
          }
          this.activeButton = -1;
          this._previousPosition = null;
          if (!this._noPreventDefault) {
            e.preventDefault();
          }
        } else if (p.type === PointerEventTypes.POINTERMOVE) {
          if (!this._previousPosition) {
            if (engine.isPointerLock) {
              this._onMouseMove(p.event);
            }
            return;
          }
          const offsetX = e.clientX - this._previousPosition.x;
          const offsetY = e.clientY - this._previousPosition.y;
          this._rotateCamera(offsetX, offsetY);
          this._previousPosition = {
            x: e.clientX,
            y: e.clientY
          };
          if (!this._noPreventDefault) {
            e.preventDefault();
          }
        }
      }
      // Track mouse movement, when pointer is locked.
      _onMouseMove(e) {
        const camera = this.camera;
        const engine = camera.getEngine();
        if (!engine.isPointerLock) {
          return;
        }
        const offsetX = e.movementX;
        const offsetY = e.movementY;
        this._rotateCamera(offsetX, offsetY);
        this._previousPosition = null;
        if (!this._noPreventDefault) {
          e.preventDefault();
        }
      }
      /**
       * Rotate camera by mouse offset.
       * @param offsetX
       * @param offsetY
       */
      _rotateCamera(offsetX, offsetY) {
        const camera = this.camera;
        const handednessMultiplier = camera._calculateHandednessMultiplier();
        const x = offsetX * handednessMultiplier / this.angularSensibility;
        const y = offsetY * handednessMultiplier / this.angularSensibility;
        const currentRotation = Quaternion.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, camera.rotation.z);
        let rotationChange;
        if (this.buttonsPitch.some((v) => {
          return v === this.activeButton;
        })) {
          rotationChange = Quaternion.RotationAxis(Axis.X, y);
          currentRotation.multiplyInPlace(rotationChange);
        }
        if (this.buttonsYaw.some((v) => {
          return v === this.activeButton;
        })) {
          rotationChange = Quaternion.RotationAxis(Axis.Y, x);
          currentRotation.multiplyInPlace(rotationChange);
          const limit = camera.bankedTurnLimit + camera._trackRoll;
          if (camera.bankedTurn && -limit < camera.rotation.z && camera.rotation.z < limit) {
            const bankingDelta = camera.bankedTurnMultiplier * -x;
            rotationChange = Quaternion.RotationAxis(Axis.Z, bankingDelta);
            currentRotation.multiplyInPlace(rotationChange);
          }
        }
        if (this.buttonsRoll.some((v) => {
          return v === this.activeButton;
        })) {
          rotationChange = Quaternion.RotationAxis(Axis.Z, -x);
          camera._trackRoll -= x;
          currentRotation.multiplyInPlace(rotationChange);
        }
        currentRotation.toEulerAnglesToRef(camera.rotation);
      }
    };
    __decorate([
      serialize()
    ], FlyCameraMouseInput.prototype, "buttons", void 0);
    __decorate([
      serialize()
    ], FlyCameraMouseInput.prototype, "angularSensibility", void 0);
    CameraInputTypes["FlyCameraMouseInput"] = FlyCameraMouseInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraGamepadInput.js
var FreeCameraGamepadInput;
var init_freeCameraGamepadInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/freeCameraGamepadInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_math_vector();
    init_gamepad();
    FreeCameraGamepadInput = class {
      constructor() {
        this.gamepadAngularSensibility = 200;
        this.gamepadMoveSensibility = 40;
        this.deadzoneDelta = 0.1;
        this._yAxisScale = 1;
        this._cameraTransform = Matrix.Identity();
        this._deltaTransform = Vector3.Zero();
        this._vector3 = Vector3.Zero();
        this._vector2 = Vector2.Zero();
      }
      /**
       * Gets or sets a boolean indicating that Yaxis (for right stick) should be inverted
       */
      get invertYAxis() {
        return this._yAxisScale !== 1;
      }
      set invertYAxis(value) {
        this._yAxisScale = value ? -1 : 1;
      }
      /**
       * Attach the input controls to a specific dom element to get the input from.
       */
      attachControl() {
        const manager = this.camera.getScene().gamepadManager;
        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {
          if (gamepad.type !== Gamepad.POSE_ENABLED) {
            if (!this.gamepad || gamepad.type === Gamepad.XBOX) {
              this.gamepad = gamepad;
            }
          }
        });
        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {
          if (this.gamepad === gamepad) {
            this.gamepad = null;
          }
        });
        this.gamepad = manager.getGamepadByType(Gamepad.XBOX);
        if (!this.gamepad && manager.gamepads.length) {
          this.gamepad = manager.gamepads[0];
        }
      }
      /**
       * Detach the current controls from the specified dom element.
       */
      detachControl() {
        this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);
        this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);
        this.gamepad = null;
      }
      /**
       * Update the current camera state depending on the inputs that have been used this frame.
       * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
       */
      checkInputs() {
        if (this.gamepad && this.gamepad.leftStick) {
          const camera = this.camera;
          const lsValues = this.gamepad.leftStick;
          if (this.gamepadMoveSensibility !== 0) {
            lsValues.x = Math.abs(lsValues.x) > this.deadzoneDelta ? lsValues.x / this.gamepadMoveSensibility : 0;
            lsValues.y = Math.abs(lsValues.y) > this.deadzoneDelta ? lsValues.y / this.gamepadMoveSensibility : 0;
          }
          let rsValues = this.gamepad.rightStick;
          if (rsValues && this.gamepadAngularSensibility !== 0) {
            rsValues.x = Math.abs(rsValues.x) > this.deadzoneDelta ? rsValues.x / this.gamepadAngularSensibility : 0;
            rsValues.y = (Math.abs(rsValues.y) > this.deadzoneDelta ? rsValues.y / this.gamepadAngularSensibility : 0) * this._yAxisScale;
          } else {
            rsValues = { x: 0, y: 0 };
          }
          if (!camera.rotationQuaternion) {
            Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, this._cameraTransform);
          } else {
            camera.rotationQuaternion.toRotationMatrix(this._cameraTransform);
          }
          const speed = camera._computeLocalCameraSpeed() * 50;
          this._vector3.copyFromFloats(lsValues.x * speed, 0, -lsValues.y * speed);
          Vector3.TransformCoordinatesToRef(this._vector3, this._cameraTransform, this._deltaTransform);
          camera.cameraDirection.addInPlace(this._deltaTransform);
          this._vector2.copyFromFloats(rsValues.y, rsValues.x);
          camera.cameraRotation.addInPlace(this._vector2);
        }
      }
      /**
       * Gets the class name of the current input.
       * @returns the class name
       */
      getClassName() {
        return "FreeCameraGamepadInput";
      }
      /**
       * Get the friendly name associated with the input class.
       * @returns the input friendly name
       */
      getSimpleName() {
        return "gamepad";
      }
    };
    __decorate([
      serialize()
    ], FreeCameraGamepadInput.prototype, "gamepadAngularSensibility", void 0);
    __decorate([
      serialize()
    ], FreeCameraGamepadInput.prototype, "gamepadMoveSensibility", void 0);
    CameraInputTypes["FreeCameraGamepadInput"] = FreeCameraGamepadInput;
  }
});

// node_modules/@babylonjs/core/Cameras/touchCamera.js
var TouchCamera;
var init_touchCamera = __esm({
  "node_modules/@babylonjs/core/Cameras/touchCamera.js"() {
    init_freeCamera();
    init_math_vector();
    init_node();
    Node.AddNodeConstructor("TouchCamera", (name3, scene) => {
      return () => new TouchCamera(name3, Vector3.Zero(), scene);
    });
    TouchCamera = class extends FreeCamera {
      /**
       * Defines the touch sensibility for rotation.
       * The higher the faster.
       */
      get touchAngularSensibility() {
        const touch = this.inputs.attached["touch"];
        if (touch) {
          return touch.touchAngularSensibility;
        }
        return 0;
      }
      set touchAngularSensibility(value) {
        const touch = this.inputs.attached["touch"];
        if (touch) {
          touch.touchAngularSensibility = value;
        }
      }
      /**
       * Defines the touch sensibility for move.
       * The higher the faster.
       */
      get touchMoveSensibility() {
        const touch = this.inputs.attached["touch"];
        if (touch) {
          return touch.touchMoveSensibility;
        }
        return 0;
      }
      set touchMoveSensibility(value) {
        const touch = this.inputs.attached["touch"];
        if (touch) {
          touch.touchMoveSensibility = value;
        }
      }
      /**
       * Instantiates a new touch camera.
       * This represents a FPS type of camera controlled by touch.
       * This is like a universal camera minus the Gamepad controls.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera
       * @param name Define the name of the camera in the scene
       * @param position Define the start position of the camera in the scene
       * @param scene Define the scene the camera belongs to
       */
      constructor(name3, position, scene) {
        super(name3, position, scene);
        this.inputs.addTouch();
        this._setupInputs();
      }
      /**
       * Gets the current object class name.
       * @returns the class name
       */
      getClassName() {
        return "TouchCamera";
      }
      /** @internal */
      _setupInputs() {
        const touch = this.inputs.attached["touch"];
        const mouse = this.inputs.attached["mouse"];
        if (mouse) {
          mouse.touchEnabled = !touch;
        } else if (touch) {
          touch.allowMouse = !mouse;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/flyCameraInputsManager.js
var FlyCameraInputsManager;
var init_flyCameraInputsManager = __esm({
  "node_modules/@babylonjs/core/Cameras/flyCameraInputsManager.js"() {
    init_cameraInputsManager();
    init_flyCameraMouseInput();
    init_flyCameraKeyboardInput();
    FlyCameraInputsManager = class extends CameraInputsManager {
      /**
       * Instantiates a new FlyCameraInputsManager.
       * @param camera Defines the camera the inputs belong to.
       */
      constructor(camera) {
        super(camera);
      }
      /**
       * Add keyboard input support to the input manager.
       * @returns the new FlyCameraKeyboardMoveInput().
       */
      addKeyboard() {
        this.add(new FlyCameraKeyboardInput());
        return this;
      }
      /**
       * Add mouse input support to the input manager.
       * @returns the new FlyCameraMouseInput().
       */
      addMouse() {
        this.add(new FlyCameraMouseInput());
        return this;
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/flyCamera.js
var FlyCamera;
var init_flyCamera = __esm({
  "node_modules/@babylonjs/core/Cameras/flyCamera.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_targetCamera();
    init_flyCameraInputsManager();
    init_tools();
    init_typeStore();
    init_abstractEngine();
    FlyCamera = class extends TargetCamera {
      /**
       * Gets the input sensibility for mouse input.
       * Higher values reduce sensitivity.
       */
      get angularSensibility() {
        const mouse = this.inputs.attached["mouse"];
        if (mouse) {
          return mouse.angularSensibility;
        }
        return 0;
      }
      /**
       * Sets the input sensibility for a mouse input.
       * Higher values reduce sensitivity.
       */
      set angularSensibility(value) {
        const mouse = this.inputs.attached["mouse"];
        if (mouse) {
          mouse.angularSensibility = value;
        }
      }
      /**
       * Get the keys for camera movement forward.
       */
      get keysForward() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysForward;
        }
        return [];
      }
      /**
       * Set the keys for camera movement forward.
       */
      set keysForward(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysForward = value;
        }
      }
      /**
       * Get the keys for camera movement backward.
       */
      get keysBackward() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysBackward;
        }
        return [];
      }
      set keysBackward(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysBackward = value;
        }
      }
      /**
       * Get the keys for camera movement up.
       */
      get keysUp() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysUp;
        }
        return [];
      }
      /**
       * Set the keys for camera movement up.
       */
      set keysUp(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysUp = value;
        }
      }
      /**
       * Get the keys for camera movement down.
       */
      get keysDown() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysDown;
        }
        return [];
      }
      /**
       * Set the keys for camera movement down.
       */
      set keysDown(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysDown = value;
        }
      }
      /**
       * Get the keys for camera movement left.
       */
      get keysLeft() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysLeft;
        }
        return [];
      }
      /**
       * Set the keys for camera movement left.
       */
      set keysLeft(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysLeft = value;
        }
      }
      /**
       * Set the keys for camera movement right.
       */
      get keysRight() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysRight;
        }
        return [];
      }
      /**
       * Set the keys for camera movement right.
       */
      set keysRight(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysRight = value;
        }
      }
      /**
       * Instantiates a FlyCamera.
       * This is a flying camera, designed for 3D movement and rotation in all directions,
       * such as in a 3D Space Shooter or a Flight Simulator.
       * @param name Define the name of the camera in the scene.
       * @param position Define the starting position of the camera in the scene.
       * @param scene Define the scene the camera belongs to.
       * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active, if no other camera has been defined as active.
       */
      constructor(name3, position, scene, setActiveOnSceneIfNoneActive = true) {
        super(name3, position, scene, setActiveOnSceneIfNoneActive);
        this.ellipsoid = new Vector3(1, 1, 1);
        this.ellipsoidOffset = new Vector3(0, 0, 0);
        this.checkCollisions = false;
        this.applyGravity = false;
        this.cameraDirection = Vector3.Zero();
        this._trackRoll = 0;
        this.rollCorrect = 100;
        this.bankedTurn = false;
        this.bankedTurnLimit = Math.PI / 2;
        this.bankedTurnMultiplier = 1;
        this._needMoveForGravity = false;
        this._oldPosition = Vector3.Zero();
        this._diffPosition = Vector3.Zero();
        this._newPosition = Vector3.Zero();
        this._collisionMask = -1;
        this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {
          const updatePosition = (newPos) => {
            this._newPosition.copyFrom(newPos);
            this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);
            if (this._diffPosition.length() > AbstractEngine.CollisionsEpsilon) {
              this.position.addInPlace(this._diffPosition);
              if (this.onCollide && collidedMesh) {
                this.onCollide(collidedMesh);
              }
            }
          };
          updatePosition(newPosition);
        };
        this.inputs = new FlyCameraInputsManager(this);
        this.inputs.addKeyboard().addMouse();
      }
      /**
       * Attached controls to the current camera.
       * @param ignored defines an ignored parameter kept for backward compatibility.
       * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
       */
      attachControl(ignored, noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        this.inputs.attachElement(noPreventDefault);
      }
      /**
       * Detach a control from the HTML DOM element.
       * The camera will stop reacting to that input.
       */
      detachControl() {
        this.inputs.detachElement();
        this.cameraDirection = new Vector3(0, 0, 0);
      }
      /**
       * Get the mask that the camera ignores in collision events.
       */
      get collisionMask() {
        return this._collisionMask;
      }
      /**
       * Set the mask that the camera ignores in collision events.
       */
      set collisionMask(mask) {
        this._collisionMask = !isNaN(mask) ? mask : -1;
      }
      /**
       * @internal
       */
      _collideWithWorld(displacement) {
        let globalPosition;
        if (this.parent) {
          globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());
        } else {
          globalPosition = this.position;
        }
        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);
        this._oldPosition.addInPlace(this.ellipsoidOffset);
        const coordinator = this.getScene().collisionCoordinator;
        if (!this._collider) {
          this._collider = coordinator.createCollider();
        }
        this._collider._radius = this.ellipsoid;
        this._collider.collisionMask = this._collisionMask;
        let actualDisplacement = displacement;
        if (this.applyGravity) {
          actualDisplacement = displacement.add(this.getScene().gravity);
        }
        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
      }
      /** @internal */
      _checkInputs() {
        if (!this._localDirection) {
          this._localDirection = Vector3.Zero();
          this._transformedDirection = Vector3.Zero();
        }
        this.inputs.checkInputs();
        super._checkInputs();
      }
      /**
       * Enable movement without a user input. This allows gravity to always be applied.
       */
      set needMoveForGravity(value) {
        this._needMoveForGravity = value;
      }
      /**
       * When true, gravity is applied whether there is user input or not.
       */
      get needMoveForGravity() {
        return this._needMoveForGravity;
      }
      /** @internal */
      _decideIfNeedsToMove() {
        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
      }
      /** @internal */
      _updatePosition() {
        if (this.checkCollisions && this.getScene().collisionsEnabled) {
          this._collideWithWorld(this.cameraDirection);
        } else {
          super._updatePosition();
        }
      }
      /**
       * Restore the Roll to its target value at the rate specified.
       * @param rate - Higher means slower restoring.
       * @internal
       */
      restoreRoll(rate) {
        const limit = this._trackRoll;
        const z = this.rotation.z;
        const delta = limit - z;
        const minRad = 1e-3;
        if (Math.abs(delta) >= minRad) {
          this.rotation.z += delta / rate;
          if (Math.abs(limit - this.rotation.z) <= minRad) {
            this.rotation.z = limit;
          }
        }
      }
      /**
       * Destroy the camera and release the current resources held by it.
       */
      dispose() {
        this.inputs.clear();
        super.dispose();
      }
      /**
       * Get the current object class name.
       * @returns the class name.
       */
      getClassName() {
        return "FlyCamera";
      }
    };
    __decorate([
      serializeAsVector3()
    ], FlyCamera.prototype, "ellipsoid", void 0);
    __decorate([
      serializeAsVector3()
    ], FlyCamera.prototype, "ellipsoidOffset", void 0);
    __decorate([
      serialize()
    ], FlyCamera.prototype, "checkCollisions", void 0);
    __decorate([
      serialize()
    ], FlyCamera.prototype, "applyGravity", void 0);
    RegisterClass("BABYLON.FlyCamera", FlyCamera);
  }
});

// node_modules/@babylonjs/core/Gamepads/xboxGamepad.js
var Xbox360Button, Xbox360Dpad, Xbox360Pad;
var init_xboxGamepad = __esm({
  "node_modules/@babylonjs/core/Gamepads/xboxGamepad.js"() {
    init_observable();
    init_gamepad();
    (function(Xbox360Button2) {
      Xbox360Button2[Xbox360Button2["A"] = 0] = "A";
      Xbox360Button2[Xbox360Button2["B"] = 1] = "B";
      Xbox360Button2[Xbox360Button2["X"] = 2] = "X";
      Xbox360Button2[Xbox360Button2["Y"] = 3] = "Y";
      Xbox360Button2[Xbox360Button2["LB"] = 4] = "LB";
      Xbox360Button2[Xbox360Button2["RB"] = 5] = "RB";
      Xbox360Button2[Xbox360Button2["Back"] = 8] = "Back";
      Xbox360Button2[Xbox360Button2["Start"] = 9] = "Start";
      Xbox360Button2[Xbox360Button2["LeftStick"] = 10] = "LeftStick";
      Xbox360Button2[Xbox360Button2["RightStick"] = 11] = "RightStick";
    })(Xbox360Button || (Xbox360Button = {}));
    (function(Xbox360Dpad2) {
      Xbox360Dpad2[Xbox360Dpad2["Up"] = 12] = "Up";
      Xbox360Dpad2[Xbox360Dpad2["Down"] = 13] = "Down";
      Xbox360Dpad2[Xbox360Dpad2["Left"] = 14] = "Left";
      Xbox360Dpad2[Xbox360Dpad2["Right"] = 15] = "Right";
    })(Xbox360Dpad || (Xbox360Dpad = {}));
    Xbox360Pad = class extends Gamepad {
      /**
       * Creates a new XBox360 gamepad object
       * @param id defines the id of this gamepad
       * @param index defines its index
       * @param gamepad defines the internal HTML gamepad object
       * @param xboxOne defines if it is a XBox One gamepad
       */
      constructor(id, index, gamepad, xboxOne = false) {
        super(id, index, gamepad, 0, 1, 2, 3);
        this._leftTrigger = 0;
        this._rightTrigger = 0;
        this.onButtonDownObservable = new Observable();
        this.onButtonUpObservable = new Observable();
        this.onPadDownObservable = new Observable();
        this.onPadUpObservable = new Observable();
        this._buttonA = 0;
        this._buttonB = 0;
        this._buttonX = 0;
        this._buttonY = 0;
        this._buttonBack = 0;
        this._buttonStart = 0;
        this._buttonLb = 0;
        this._buttonRb = 0;
        this._buttonLeftStick = 0;
        this._buttonRightStick = 0;
        this._dPadUp = 0;
        this._dPadDown = 0;
        this._dPadLeft = 0;
        this._dPadRight = 0;
        this._isXboxOnePad = false;
        this.type = Gamepad.XBOX;
        this._isXboxOnePad = xboxOne;
      }
      /**
       * Defines the callback to call when left trigger is pressed
       * @param callback defines the callback to use
       */
      onlefttriggerchanged(callback) {
        this._onlefttriggerchanged = callback;
      }
      /**
       * Defines the callback to call when right trigger is pressed
       * @param callback defines the callback to use
       */
      onrighttriggerchanged(callback) {
        this._onrighttriggerchanged = callback;
      }
      /**
       * Gets the left trigger value
       */
      get leftTrigger() {
        return this._leftTrigger;
      }
      /**
       * Sets the left trigger value
       */
      set leftTrigger(newValue) {
        if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {
          this._onlefttriggerchanged(newValue);
        }
        this._leftTrigger = newValue;
      }
      /**
       * Gets the right trigger value
       */
      get rightTrigger() {
        return this._rightTrigger;
      }
      /**
       * Sets the right trigger value
       */
      set rightTrigger(newValue) {
        if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {
          this._onrighttriggerchanged(newValue);
        }
        this._rightTrigger = newValue;
      }
      /**
       * Defines the callback to call when a button is pressed
       * @param callback defines the callback to use
       */
      onbuttondown(callback) {
        this._onbuttondown = callback;
      }
      /**
       * Defines the callback to call when a button is released
       * @param callback defines the callback to use
       */
      onbuttonup(callback) {
        this._onbuttonup = callback;
      }
      /**
       * Defines the callback to call when a pad is pressed
       * @param callback defines the callback to use
       */
      ondpaddown(callback) {
        this._ondpaddown = callback;
      }
      /**
       * Defines the callback to call when a pad is released
       * @param callback defines the callback to use
       */
      ondpadup(callback) {
        this._ondpadup = callback;
      }
      _setButtonValue(newValue, currentValue, buttonType) {
        if (newValue !== currentValue) {
          if (newValue === 1) {
            if (this._onbuttondown) {
              this._onbuttondown(buttonType);
            }
            this.onButtonDownObservable.notifyObservers(buttonType);
          }
          if (newValue === 0) {
            if (this._onbuttonup) {
              this._onbuttonup(buttonType);
            }
            this.onButtonUpObservable.notifyObservers(buttonType);
          }
        }
        return newValue;
      }
      _setDpadValue(newValue, currentValue, buttonType) {
        if (newValue !== currentValue) {
          if (newValue === 1) {
            if (this._ondpaddown) {
              this._ondpaddown(buttonType);
            }
            this.onPadDownObservable.notifyObservers(buttonType);
          }
          if (newValue === 0) {
            if (this._ondpadup) {
              this._ondpadup(buttonType);
            }
            this.onPadUpObservable.notifyObservers(buttonType);
          }
        }
        return newValue;
      }
      /**
       * Gets the value of the `A` button
       */
      get buttonA() {
        return this._buttonA;
      }
      /**
       * Sets the value of the `A` button
       */
      set buttonA(value) {
        this._buttonA = this._setButtonValue(
          value,
          this._buttonA,
          0
          /* Xbox360Button.A */
        );
      }
      /**
       * Gets the value of the `B` button
       */
      get buttonB() {
        return this._buttonB;
      }
      /**
       * Sets the value of the `B` button
       */
      set buttonB(value) {
        this._buttonB = this._setButtonValue(
          value,
          this._buttonB,
          1
          /* Xbox360Button.B */
        );
      }
      /**
       * Gets the value of the `X` button
       */
      get buttonX() {
        return this._buttonX;
      }
      /**
       * Sets the value of the `X` button
       */
      set buttonX(value) {
        this._buttonX = this._setButtonValue(
          value,
          this._buttonX,
          2
          /* Xbox360Button.X */
        );
      }
      /**
       * Gets the value of the `Y` button
       */
      get buttonY() {
        return this._buttonY;
      }
      /**
       * Sets the value of the `Y` button
       */
      set buttonY(value) {
        this._buttonY = this._setButtonValue(
          value,
          this._buttonY,
          3
          /* Xbox360Button.Y */
        );
      }
      /**
       * Gets the value of the `Start` button
       */
      get buttonStart() {
        return this._buttonStart;
      }
      /**
       * Sets the value of the `Start` button
       */
      set buttonStart(value) {
        this._buttonStart = this._setButtonValue(
          value,
          this._buttonStart,
          9
          /* Xbox360Button.Start */
        );
      }
      /**
       * Gets the value of the `Back` button
       */
      get buttonBack() {
        return this._buttonBack;
      }
      /**
       * Sets the value of the `Back` button
       */
      set buttonBack(value) {
        this._buttonBack = this._setButtonValue(
          value,
          this._buttonBack,
          8
          /* Xbox360Button.Back */
        );
      }
      /**
       * Gets the value of the `Left` button
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      get buttonLB() {
        return this._buttonLb;
      }
      /**
       * Sets the value of the `Left` button
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      set buttonLB(value) {
        this._buttonLb = this._setButtonValue(
          value,
          this._buttonLb,
          4
          /* Xbox360Button.LB */
        );
      }
      /**
       * Gets the value of the `Right` button
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      get buttonRB() {
        return this._buttonRb;
      }
      /**
       * Sets the value of the `Right` button
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      set buttonRB(value) {
        this._buttonRb = this._setButtonValue(
          value,
          this._buttonRb,
          5
          /* Xbox360Button.RB */
        );
      }
      /**
       * Gets the value of the Left joystick
       */
      get buttonLeftStick() {
        return this._buttonLeftStick;
      }
      /**
       * Sets the value of the Left joystick
       */
      set buttonLeftStick(value) {
        this._buttonLeftStick = this._setButtonValue(
          value,
          this._buttonLeftStick,
          10
          /* Xbox360Button.LeftStick */
        );
      }
      /**
       * Gets the value of the Right joystick
       */
      get buttonRightStick() {
        return this._buttonRightStick;
      }
      /**
       * Sets the value of the Right joystick
       */
      set buttonRightStick(value) {
        this._buttonRightStick = this._setButtonValue(
          value,
          this._buttonRightStick,
          11
          /* Xbox360Button.RightStick */
        );
      }
      /**
       * Gets the value of D-pad up
       */
      get dPadUp() {
        return this._dPadUp;
      }
      /**
       * Sets the value of D-pad up
       */
      set dPadUp(value) {
        this._dPadUp = this._setDpadValue(
          value,
          this._dPadUp,
          12
          /* Xbox360Dpad.Up */
        );
      }
      /**
       * Gets the value of D-pad down
       */
      get dPadDown() {
        return this._dPadDown;
      }
      /**
       * Sets the value of D-pad down
       */
      set dPadDown(value) {
        this._dPadDown = this._setDpadValue(
          value,
          this._dPadDown,
          13
          /* Xbox360Dpad.Down */
        );
      }
      /**
       * Gets the value of D-pad left
       */
      get dPadLeft() {
        return this._dPadLeft;
      }
      /**
       * Sets the value of D-pad left
       */
      set dPadLeft(value) {
        this._dPadLeft = this._setDpadValue(
          value,
          this._dPadLeft,
          14
          /* Xbox360Dpad.Left */
        );
      }
      /**
       * Gets the value of D-pad right
       */
      get dPadRight() {
        return this._dPadRight;
      }
      /**
       * Sets the value of D-pad right
       */
      set dPadRight(value) {
        this._dPadRight = this._setDpadValue(
          value,
          this._dPadRight,
          15
          /* Xbox360Dpad.Right */
        );
      }
      /**
       * Force the gamepad to synchronize with device values
       */
      update() {
        super.update();
        if (this._isXboxOnePad) {
          this.buttonA = this.browserGamepad.buttons[0].value;
          this.buttonB = this.browserGamepad.buttons[1].value;
          this.buttonX = this.browserGamepad.buttons[2].value;
          this.buttonY = this.browserGamepad.buttons[3].value;
          this.buttonLB = this.browserGamepad.buttons[4].value;
          this.buttonRB = this.browserGamepad.buttons[5].value;
          this.leftTrigger = this.browserGamepad.buttons[6].value;
          this.rightTrigger = this.browserGamepad.buttons[7].value;
          this.buttonBack = this.browserGamepad.buttons[8].value;
          this.buttonStart = this.browserGamepad.buttons[9].value;
          this.buttonLeftStick = this.browserGamepad.buttons[10].value;
          this.buttonRightStick = this.browserGamepad.buttons[11].value;
          this.dPadUp = this.browserGamepad.buttons[12].value;
          this.dPadDown = this.browserGamepad.buttons[13].value;
          this.dPadLeft = this.browserGamepad.buttons[14].value;
          this.dPadRight = this.browserGamepad.buttons[15].value;
        } else {
          this.buttonA = this.browserGamepad.buttons[0].value;
          this.buttonB = this.browserGamepad.buttons[1].value;
          this.buttonX = this.browserGamepad.buttons[2].value;
          this.buttonY = this.browserGamepad.buttons[3].value;
          this.buttonLB = this.browserGamepad.buttons[4].value;
          this.buttonRB = this.browserGamepad.buttons[5].value;
          this.leftTrigger = this.browserGamepad.buttons[6].value;
          this.rightTrigger = this.browserGamepad.buttons[7].value;
          this.buttonBack = this.browserGamepad.buttons[8].value;
          this.buttonStart = this.browserGamepad.buttons[9].value;
          this.buttonLeftStick = this.browserGamepad.buttons[10].value;
          this.buttonRightStick = this.browserGamepad.buttons[11].value;
          this.dPadUp = this.browserGamepad.buttons[12].value;
          this.dPadDown = this.browserGamepad.buttons[13].value;
          this.dPadLeft = this.browserGamepad.buttons[14].value;
          this.dPadRight = this.browserGamepad.buttons[15].value;
        }
      }
      /**
       * Disposes the gamepad
       */
      dispose() {
        super.dispose();
        this.onButtonDownObservable.clear();
        this.onButtonUpObservable.clear();
        this.onPadDownObservable.clear();
        this.onPadUpObservable.clear();
      }
    };
  }
});

// node_modules/@babylonjs/core/Gamepads/dualShockGamepad.js
var DualShockButton, DualShockDpad, DualShockPad;
var init_dualShockGamepad = __esm({
  "node_modules/@babylonjs/core/Gamepads/dualShockGamepad.js"() {
    init_observable();
    init_gamepad();
    (function(DualShockButton2) {
      DualShockButton2[DualShockButton2["Cross"] = 0] = "Cross";
      DualShockButton2[DualShockButton2["Circle"] = 1] = "Circle";
      DualShockButton2[DualShockButton2["Square"] = 2] = "Square";
      DualShockButton2[DualShockButton2["Triangle"] = 3] = "Triangle";
      DualShockButton2[DualShockButton2["L1"] = 4] = "L1";
      DualShockButton2[DualShockButton2["R1"] = 5] = "R1";
      DualShockButton2[DualShockButton2["Share"] = 8] = "Share";
      DualShockButton2[DualShockButton2["Options"] = 9] = "Options";
      DualShockButton2[DualShockButton2["LeftStick"] = 10] = "LeftStick";
      DualShockButton2[DualShockButton2["RightStick"] = 11] = "RightStick";
    })(DualShockButton || (DualShockButton = {}));
    (function(DualShockDpad2) {
      DualShockDpad2[DualShockDpad2["Up"] = 12] = "Up";
      DualShockDpad2[DualShockDpad2["Down"] = 13] = "Down";
      DualShockDpad2[DualShockDpad2["Left"] = 14] = "Left";
      DualShockDpad2[DualShockDpad2["Right"] = 15] = "Right";
    })(DualShockDpad || (DualShockDpad = {}));
    DualShockPad = class extends Gamepad {
      /**
       * Creates a new DualShock gamepad object
       * @param id defines the id of this gamepad
       * @param index defines its index
       * @param gamepad defines the internal HTML gamepad object
       */
      constructor(id, index, gamepad) {
        super(id.replace("STANDARD GAMEPAD", "SONY PLAYSTATION DUALSHOCK"), index, gamepad, 0, 1, 2, 3);
        this._leftTrigger = 0;
        this._rightTrigger = 0;
        this.onButtonDownObservable = new Observable();
        this.onButtonUpObservable = new Observable();
        this.onPadDownObservable = new Observable();
        this.onPadUpObservable = new Observable();
        this._buttonCross = 0;
        this._buttonCircle = 0;
        this._buttonSquare = 0;
        this._buttonTriangle = 0;
        this._buttonShare = 0;
        this._buttonOptions = 0;
        this._buttonL1 = 0;
        this._buttonR1 = 0;
        this._buttonLeftStick = 0;
        this._buttonRightStick = 0;
        this._dPadUp = 0;
        this._dPadDown = 0;
        this._dPadLeft = 0;
        this._dPadRight = 0;
        this.type = Gamepad.DUALSHOCK;
      }
      /**
       * Defines the callback to call when left trigger is pressed
       * @param callback defines the callback to use
       */
      onlefttriggerchanged(callback) {
        this._onlefttriggerchanged = callback;
      }
      /**
       * Defines the callback to call when right trigger is pressed
       * @param callback defines the callback to use
       */
      onrighttriggerchanged(callback) {
        this._onrighttriggerchanged = callback;
      }
      /**
       * Gets the left trigger value
       */
      get leftTrigger() {
        return this._leftTrigger;
      }
      /**
       * Sets the left trigger value
       */
      set leftTrigger(newValue) {
        if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {
          this._onlefttriggerchanged(newValue);
        }
        this._leftTrigger = newValue;
      }
      /**
       * Gets the right trigger value
       */
      get rightTrigger() {
        return this._rightTrigger;
      }
      /**
       * Sets the right trigger value
       */
      set rightTrigger(newValue) {
        if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {
          this._onrighttriggerchanged(newValue);
        }
        this._rightTrigger = newValue;
      }
      /**
       * Defines the callback to call when a button is pressed
       * @param callback defines the callback to use
       */
      onbuttondown(callback) {
        this._onbuttondown = callback;
      }
      /**
       * Defines the callback to call when a button is released
       * @param callback defines the callback to use
       */
      onbuttonup(callback) {
        this._onbuttonup = callback;
      }
      /**
       * Defines the callback to call when a pad is pressed
       * @param callback defines the callback to use
       */
      ondpaddown(callback) {
        this._ondpaddown = callback;
      }
      /**
       * Defines the callback to call when a pad is released
       * @param callback defines the callback to use
       */
      ondpadup(callback) {
        this._ondpadup = callback;
      }
      _setButtonValue(newValue, currentValue, buttonType) {
        if (newValue !== currentValue) {
          if (newValue === 1) {
            if (this._onbuttondown) {
              this._onbuttondown(buttonType);
            }
            this.onButtonDownObservable.notifyObservers(buttonType);
          }
          if (newValue === 0) {
            if (this._onbuttonup) {
              this._onbuttonup(buttonType);
            }
            this.onButtonUpObservable.notifyObservers(buttonType);
          }
        }
        return newValue;
      }
      _setDpadValue(newValue, currentValue, buttonType) {
        if (newValue !== currentValue) {
          if (newValue === 1) {
            if (this._ondpaddown) {
              this._ondpaddown(buttonType);
            }
            this.onPadDownObservable.notifyObservers(buttonType);
          }
          if (newValue === 0) {
            if (this._ondpadup) {
              this._ondpadup(buttonType);
            }
            this.onPadUpObservable.notifyObservers(buttonType);
          }
        }
        return newValue;
      }
      /**
       * Gets the value of the `Cross` button
       */
      get buttonCross() {
        return this._buttonCross;
      }
      /**
       * Sets the value of the `Cross` button
       */
      set buttonCross(value) {
        this._buttonCross = this._setButtonValue(
          value,
          this._buttonCross,
          0
          /* DualShockButton.Cross */
        );
      }
      /**
       * Gets the value of the `Circle` button
       */
      get buttonCircle() {
        return this._buttonCircle;
      }
      /**
       * Sets the value of the `Circle` button
       */
      set buttonCircle(value) {
        this._buttonCircle = this._setButtonValue(
          value,
          this._buttonCircle,
          1
          /* DualShockButton.Circle */
        );
      }
      /**
       * Gets the value of the `Square` button
       */
      get buttonSquare() {
        return this._buttonSquare;
      }
      /**
       * Sets the value of the `Square` button
       */
      set buttonSquare(value) {
        this._buttonSquare = this._setButtonValue(
          value,
          this._buttonSquare,
          2
          /* DualShockButton.Square */
        );
      }
      /**
       * Gets the value of the `Triangle` button
       */
      get buttonTriangle() {
        return this._buttonTriangle;
      }
      /**
       * Sets the value of the `Triangle` button
       */
      set buttonTriangle(value) {
        this._buttonTriangle = this._setButtonValue(
          value,
          this._buttonTriangle,
          3
          /* DualShockButton.Triangle */
        );
      }
      /**
       * Gets the value of the `Options` button
       */
      get buttonOptions() {
        return this._buttonOptions;
      }
      /**
       * Sets the value of the `Options` button
       */
      set buttonOptions(value) {
        this._buttonOptions = this._setButtonValue(
          value,
          this._buttonOptions,
          9
          /* DualShockButton.Options */
        );
      }
      /**
       * Gets the value of the `Share` button
       */
      get buttonShare() {
        return this._buttonShare;
      }
      /**
       * Sets the value of the `Share` button
       */
      set buttonShare(value) {
        this._buttonShare = this._setButtonValue(
          value,
          this._buttonShare,
          8
          /* DualShockButton.Share */
        );
      }
      /**
       * Gets the value of the `L1` button
       */
      get buttonL1() {
        return this._buttonL1;
      }
      /**
       * Sets the value of the `L1` button
       */
      set buttonL1(value) {
        this._buttonL1 = this._setButtonValue(
          value,
          this._buttonL1,
          4
          /* DualShockButton.L1 */
        );
      }
      /**
       * Gets the value of the `R1` button
       */
      get buttonR1() {
        return this._buttonR1;
      }
      /**
       * Sets the value of the `R1` button
       */
      set buttonR1(value) {
        this._buttonR1 = this._setButtonValue(
          value,
          this._buttonR1,
          5
          /* DualShockButton.R1 */
        );
      }
      /**
       * Gets the value of the Left joystick
       */
      get buttonLeftStick() {
        return this._buttonLeftStick;
      }
      /**
       * Sets the value of the Left joystick
       */
      set buttonLeftStick(value) {
        this._buttonLeftStick = this._setButtonValue(
          value,
          this._buttonLeftStick,
          10
          /* DualShockButton.LeftStick */
        );
      }
      /**
       * Gets the value of the Right joystick
       */
      get buttonRightStick() {
        return this._buttonRightStick;
      }
      /**
       * Sets the value of the Right joystick
       */
      set buttonRightStick(value) {
        this._buttonRightStick = this._setButtonValue(
          value,
          this._buttonRightStick,
          11
          /* DualShockButton.RightStick */
        );
      }
      /**
       * Gets the value of D-pad up
       */
      get dPadUp() {
        return this._dPadUp;
      }
      /**
       * Sets the value of D-pad up
       */
      set dPadUp(value) {
        this._dPadUp = this._setDpadValue(
          value,
          this._dPadUp,
          12
          /* DualShockDpad.Up */
        );
      }
      /**
       * Gets the value of D-pad down
       */
      get dPadDown() {
        return this._dPadDown;
      }
      /**
       * Sets the value of D-pad down
       */
      set dPadDown(value) {
        this._dPadDown = this._setDpadValue(
          value,
          this._dPadDown,
          13
          /* DualShockDpad.Down */
        );
      }
      /**
       * Gets the value of D-pad left
       */
      get dPadLeft() {
        return this._dPadLeft;
      }
      /**
       * Sets the value of D-pad left
       */
      set dPadLeft(value) {
        this._dPadLeft = this._setDpadValue(
          value,
          this._dPadLeft,
          14
          /* DualShockDpad.Left */
        );
      }
      /**
       * Gets the value of D-pad right
       */
      get dPadRight() {
        return this._dPadRight;
      }
      /**
       * Sets the value of D-pad right
       */
      set dPadRight(value) {
        this._dPadRight = this._setDpadValue(
          value,
          this._dPadRight,
          15
          /* DualShockDpad.Right */
        );
      }
      /**
       * Force the gamepad to synchronize with device values
       */
      update() {
        super.update();
        this.buttonCross = this.browserGamepad.buttons[0].value;
        this.buttonCircle = this.browserGamepad.buttons[1].value;
        this.buttonSquare = this.browserGamepad.buttons[2].value;
        this.buttonTriangle = this.browserGamepad.buttons[3].value;
        this.buttonL1 = this.browserGamepad.buttons[4].value;
        this.buttonR1 = this.browserGamepad.buttons[5].value;
        this.leftTrigger = this.browserGamepad.buttons[6].value;
        this.rightTrigger = this.browserGamepad.buttons[7].value;
        this.buttonShare = this.browserGamepad.buttons[8].value;
        this.buttonOptions = this.browserGamepad.buttons[9].value;
        this.buttonLeftStick = this.browserGamepad.buttons[10].value;
        this.buttonRightStick = this.browserGamepad.buttons[11].value;
        this.dPadUp = this.browserGamepad.buttons[12].value;
        this.dPadDown = this.browserGamepad.buttons[13].value;
        this.dPadLeft = this.browserGamepad.buttons[14].value;
        this.dPadRight = this.browserGamepad.buttons[15].value;
      }
      /**
       * Disposes the gamepad
       */
      dispose() {
        super.dispose();
        this.onButtonDownObservable.clear();
        this.onButtonUpObservable.clear();
        this.onPadDownObservable.clear();
        this.onPadUpObservable.clear();
      }
    };
  }
});

// node_modules/@babylonjs/core/Gamepads/gamepadManager.js
var GamepadManager;
var init_gamepadManager = __esm({
  "node_modules/@babylonjs/core/Gamepads/gamepadManager.js"() {
    init_observable();
    init_domManagement();
    init_xboxGamepad();
    init_gamepad();
    init_dualShockGamepad();
    init_tools();
    init_abstractEngine();
    GamepadManager = class {
      /**
       * Initializes the gamepad manager
       * @param _scene BabylonJS scene
       */
      constructor(_scene) {
        this._scene = _scene;
        this._babylonGamepads = [];
        this._oneGamepadConnected = false;
        this._isMonitoring = false;
        this.onGamepadDisconnectedObservable = new Observable();
        if (!IsWindowObjectExist()) {
          this._gamepadEventSupported = false;
        } else {
          this._gamepadEventSupported = "GamepadEvent" in window;
          this._gamepadSupport = navigator && navigator.getGamepads;
        }
        this.onGamepadConnectedObservable = new Observable((observer) => {
          for (const i in this._babylonGamepads) {
            const gamepad = this._babylonGamepads[i];
            if (gamepad && gamepad._isConnected) {
              this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);
            }
          }
        });
        this._onGamepadConnectedEvent = (evt) => {
          const gamepad = evt.gamepad;
          if (gamepad.index in this._babylonGamepads) {
            if (this._babylonGamepads[gamepad.index].isConnected) {
              return;
            }
          }
          let newGamepad;
          if (this._babylonGamepads[gamepad.index]) {
            newGamepad = this._babylonGamepads[gamepad.index];
            newGamepad.browserGamepad = gamepad;
            newGamepad._isConnected = true;
          } else {
            newGamepad = this._addNewGamepad(gamepad);
          }
          this.onGamepadConnectedObservable.notifyObservers(newGamepad);
          this._startMonitoringGamepads();
        };
        this._onGamepadDisconnectedEvent = (evt) => {
          const gamepad = evt.gamepad;
          for (const i in this._babylonGamepads) {
            if (this._babylonGamepads[i].index === gamepad.index) {
              const disconnectedGamepad = this._babylonGamepads[i];
              disconnectedGamepad._isConnected = false;
              this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);
              if (disconnectedGamepad.dispose) {
                disconnectedGamepad.dispose();
              }
              break;
            }
          }
        };
        if (this._gamepadSupport) {
          this._updateGamepadObjects();
          if (this._babylonGamepads.length) {
            this._startMonitoringGamepads();
          }
          if (this._gamepadEventSupported) {
            const hostWindow = this._scene ? this._scene.getEngine().getHostWindow() : window;
            if (hostWindow) {
              hostWindow.addEventListener("gamepadconnected", this._onGamepadConnectedEvent, false);
              hostWindow.addEventListener("gamepaddisconnected", this._onGamepadDisconnectedEvent, false);
            }
          } else {
            this._startMonitoringGamepads();
          }
        }
      }
      /**
       * The gamepads in the game pad manager
       */
      get gamepads() {
        return this._babylonGamepads;
      }
      /**
       * Get the gamepad controllers based on type
       * @param type The type of gamepad controller
       * @returns Nullable gamepad
       */
      getGamepadByType(type = Gamepad.XBOX) {
        for (const gamepad of this._babylonGamepads) {
          if (gamepad && gamepad.type === type) {
            return gamepad;
          }
        }
        return null;
      }
      /**
       * Disposes the gamepad manager
       */
      dispose() {
        if (this._gamepadEventSupported) {
          if (this._onGamepadConnectedEvent) {
            window.removeEventListener("gamepadconnected", this._onGamepadConnectedEvent);
          }
          if (this._onGamepadDisconnectedEvent) {
            window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnectedEvent);
          }
          this._onGamepadConnectedEvent = null;
          this._onGamepadDisconnectedEvent = null;
        }
        for (const gamepad of this._babylonGamepads) {
          gamepad.dispose();
        }
        this.onGamepadConnectedObservable.clear();
        this.onGamepadDisconnectedObservable.clear();
        this._oneGamepadConnected = false;
        this._stopMonitoringGamepads();
        this._babylonGamepads = [];
      }
      _addNewGamepad(gamepad) {
        if (!this._oneGamepadConnected) {
          this._oneGamepadConnected = true;
        }
        let newGamepad;
        const dualShock = gamepad.id.search("054c") !== -1 && gamepad.id.search("0ce6") === -1;
        const xboxOne = gamepad.id.search("Xbox One") !== -1;
        if (xboxOne || gamepad.id.search("Xbox 360") !== -1 || gamepad.id.search("xinput") !== -1 || gamepad.id.search("045e") !== -1 && gamepad.id.search("Surface Dock") === -1) {
          newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);
        } else if (dualShock) {
          newGamepad = new DualShockPad(gamepad.id, gamepad.index, gamepad);
        } else {
          newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);
        }
        this._babylonGamepads[newGamepad.index] = newGamepad;
        return newGamepad;
      }
      _startMonitoringGamepads() {
        if (!this._isMonitoring) {
          this._isMonitoring = true;
          this._checkGamepadsStatus();
        }
      }
      _stopMonitoringGamepads() {
        this._isMonitoring = false;
      }
      /** @internal */
      _checkGamepadsStatus() {
        this._updateGamepadObjects();
        for (const i in this._babylonGamepads) {
          const gamepad = this._babylonGamepads[i];
          if (!gamepad || !gamepad.isConnected) {
            continue;
          }
          try {
            gamepad.update();
          } catch {
            if (this._loggedErrors.indexOf(gamepad.index) === -1) {
              Tools.Warn(`Error updating gamepad ${gamepad.id}`);
              this._loggedErrors.push(gamepad.index);
            }
          }
        }
        if (this._isMonitoring) {
          AbstractEngine.QueueNewFrame(() => {
            this._checkGamepadsStatus();
          });
        }
      }
      // This function is called only on Chrome, which does not properly support
      // connection/disconnection events and forces you to recopy again the gamepad object
      _updateGamepadObjects() {
        const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
        for (let i = 0; i < gamepads.length; i++) {
          const gamepad = gamepads[i];
          if (gamepad) {
            if (!this._babylonGamepads[gamepad.index]) {
              const newGamepad = this._addNewGamepad(gamepad);
              this.onGamepadConnectedObservable.notifyObservers(newGamepad);
            } else {
              this._babylonGamepads[i].browserGamepad = gamepad;
              if (!this._babylonGamepads[i].isConnected) {
                this._babylonGamepads[i]._isConnected = true;
                this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Gamepads/gamepadSceneComponent.js
var GamepadSystemSceneComponent;
var init_gamepadSceneComponent = __esm({
  "node_modules/@babylonjs/core/Gamepads/gamepadSceneComponent.js"() {
    init_scene();
    init_sceneComponent();
    init_gamepadManager();
    init_freeCameraInputsManager();
    init_freeCameraGamepadInput();
    init_arcRotateCameraInputsManager();
    init_arcRotateCameraGamepadInput();
    Object.defineProperty(Scene.prototype, "gamepadManager", {
      get: function() {
        if (!this._gamepadManager) {
          this._gamepadManager = new GamepadManager(this);
          let component = this._getComponent(SceneComponentConstants.NAME_GAMEPAD);
          if (!component) {
            component = new GamepadSystemSceneComponent(this);
            this._addComponent(component);
          }
        }
        return this._gamepadManager;
      },
      enumerable: true,
      configurable: true
    });
    FreeCameraInputsManager.prototype.addGamepad = function() {
      this.add(new FreeCameraGamepadInput());
      return this;
    };
    ArcRotateCameraInputsManager.prototype.addGamepad = function() {
      this.add(new ArcRotateCameraGamepadInput());
      return this;
    };
    GamepadSystemSceneComponent = class {
      /**
       * Creates a new instance of the component for the given scene
       * @param scene Defines the scene to register the component in
       */
      constructor(scene) {
        this.name = SceneComponentConstants.NAME_GAMEPAD;
        this.scene = scene;
      }
      /**
       * Registers the component in a given scene
       */
      register() {
      }
      /**
       * Rebuilds the elements related to this component in case of
       * context lost for instance.
       */
      rebuild() {
      }
      /**
       * Disposes the component and the associated resources
       */
      dispose() {
        const gamepadManager = this.scene._gamepadManager;
        if (gamepadManager) {
          gamepadManager.dispose();
          this.scene._gamepadManager = null;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/universalCamera.js
var UniversalCamera;
var init_universalCamera = __esm({
  "node_modules/@babylonjs/core/Cameras/universalCamera.js"() {
    init_touchCamera();
    init_node();
    init_math_vector();
    init_camera();
    init_gamepadSceneComponent();
    Node.AddNodeConstructor("FreeCamera", (name3, scene) => {
      return () => new UniversalCamera(name3, Vector3.Zero(), scene);
    });
    UniversalCamera = class extends TouchCamera {
      /**
       * Defines the gamepad rotation sensibility.
       * This is the threshold from when rotation starts to be accounted for to prevent jittering.
       */
      get gamepadAngularSensibility() {
        const gamepad = this.inputs.attached["gamepad"];
        if (gamepad) {
          return gamepad.gamepadAngularSensibility;
        }
        return 0;
      }
      set gamepadAngularSensibility(value) {
        const gamepad = this.inputs.attached["gamepad"];
        if (gamepad) {
          gamepad.gamepadAngularSensibility = value;
        }
      }
      /**
       * Defines the gamepad move sensibility.
       * This is the threshold from when moving starts to be accounted for to prevent jittering.
       */
      get gamepadMoveSensibility() {
        const gamepad = this.inputs.attached["gamepad"];
        if (gamepad) {
          return gamepad.gamepadMoveSensibility;
        }
        return 0;
      }
      set gamepadMoveSensibility(value) {
        const gamepad = this.inputs.attached["gamepad"];
        if (gamepad) {
          gamepad.gamepadMoveSensibility = value;
        }
      }
      /**
       * The Universal Camera is the one to choose for first person shooter type games, and works with all the keyboard, mouse, touch and gamepads. This replaces the earlier Free Camera,
       * which still works and will still be found in many Playgrounds.
       * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera
       * @param name Define the name of the camera in the scene
       * @param position Define the start position of the camera in the scene
       * @param scene Define the scene the camera belongs to
       */
      constructor(name3, position, scene) {
        super(name3, position, scene);
        this.inputs.addGamepad();
      }
      /**
       * Gets the current object class name.
       * @returns the class name
       */
      getClassName() {
        return "UniversalCamera";
      }
    };
    Camera._CreateDefaultParsedCamera = (name3, scene) => {
      return new UniversalCamera(name3, Vector3.Zero(), scene);
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/Node/Types/nodeRenderGraphTypes.js
var NodeRenderGraphBlockConnectionPointTypes, NodeRenderGraphConnectionPointCompatibilityStates, NodeRenderGraphConnectionPointDirection;
var init_nodeRenderGraphTypes = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Node/Types/nodeRenderGraphTypes.js"() {
    (function(NodeRenderGraphBlockConnectionPointTypes2) {
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["Texture"] = 1] = "Texture";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureBackBuffer"] = 2] = "TextureBackBuffer";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureBackBufferDepthStencilAttachment"] = 4] = "TextureBackBufferDepthStencilAttachment";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureDepthStencilAttachment"] = 8] = "TextureDepthStencilAttachment";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureViewDepth"] = 16] = "TextureViewDepth";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureViewNormal"] = 32] = "TextureViewNormal";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureAlbedo"] = 64] = "TextureAlbedo";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureReflectivity"] = 128] = "TextureReflectivity";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureWorldPosition"] = 256] = "TextureWorldPosition";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureVelocity"] = 512] = "TextureVelocity";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureIrradiance"] = 1024] = "TextureIrradiance";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureAlbedoSqrt"] = 2048] = "TextureAlbedoSqrt";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureScreenDepth"] = 4096] = "TextureScreenDepth";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureWorldNormal"] = 8192] = "TextureWorldNormal";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureLocalPosition"] = 16384] = "TextureLocalPosition";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureLinearVelocity"] = 32768] = "TextureLinearVelocity";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureNormalizedViewDepth"] = 65536] = "TextureNormalizedViewDepth";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureAllButBackBufferDepthStencil"] = 1048571] = "TextureAllButBackBufferDepthStencil";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureAllButBackBuffer"] = 1048569] = "TextureAllButBackBuffer";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["TextureAll"] = 1048575] = "TextureAll";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["ResourceContainer"] = 1048576] = "ResourceContainer";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["ShadowGenerator"] = 2097152] = "ShadowGenerator";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["ShadowLight"] = 4194304] = "ShadowLight";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["Camera"] = 16777216] = "Camera";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["ObjectList"] = 33554432] = "ObjectList";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["AutoDetect"] = 268435456] = "AutoDetect";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["BasedOnInput"] = 536870912] = "BasedOnInput";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["Undefined"] = 1073741824] = "Undefined";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["Object"] = 2147483648] = "Object";
      NodeRenderGraphBlockConnectionPointTypes2[NodeRenderGraphBlockConnectionPointTypes2["All"] = 4294967295] = "All";
    })(NodeRenderGraphBlockConnectionPointTypes || (NodeRenderGraphBlockConnectionPointTypes = {}));
    (function(NodeRenderGraphConnectionPointCompatibilityStates2) {
      NodeRenderGraphConnectionPointCompatibilityStates2[NodeRenderGraphConnectionPointCompatibilityStates2["Compatible"] = 0] = "Compatible";
      NodeRenderGraphConnectionPointCompatibilityStates2[NodeRenderGraphConnectionPointCompatibilityStates2["TypeIncompatible"] = 1] = "TypeIncompatible";
      NodeRenderGraphConnectionPointCompatibilityStates2[NodeRenderGraphConnectionPointCompatibilityStates2["HierarchyIssue"] = 2] = "HierarchyIssue";
    })(NodeRenderGraphConnectionPointCompatibilityStates || (NodeRenderGraphConnectionPointCompatibilityStates = {}));
    (function(NodeRenderGraphConnectionPointDirection2) {
      NodeRenderGraphConnectionPointDirection2[NodeRenderGraphConnectionPointDirection2["Input"] = 0] = "Input";
      NodeRenderGraphConnectionPointDirection2[NodeRenderGraphConnectionPointDirection2["Output"] = 1] = "Output";
    })(NodeRenderGraphConnectionPointDirection || (NodeRenderGraphConnectionPointDirection = {}));
  }
});

// node_modules/@babylonjs/core/FrameGraph/Node/nodeRenderGraphBlockConnectionPoint.js
var NodeRenderGraphConnectionPoint;
var init_nodeRenderGraphBlockConnectionPoint = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Node/nodeRenderGraphBlockConnectionPoint.js"() {
    init_observable();
    init_nodeRenderGraphTypes();
    NodeRenderGraphConnectionPoint = class {
      /** Gets the direction of the point */
      get direction() {
        return this._direction;
      }
      /**
       * Checks if the value is a texture handle
       * @param value The value to check
       * @returns True if the value is a texture handle
       */
      static IsTextureHandle(value) {
        return value !== void 0 && Number.isFinite(value);
      }
      /**
       * Checks if the value is a shadow generator task
       * @param value The value to check
       * @returns True if the value is a shadow generator
       */
      static IsShadowGenerator(value) {
        return value !== void 0 && value.mapSize !== void 0;
      }
      /**
       * Checks if the value is a shadow light
       * @param value The value to check
       * @returns True if the value is a shadow light
       */
      static IsShadowLight(value) {
        return value !== void 0 && value.setShadowProjectionMatrix !== void 0;
      }
      /**
       * Gets or sets the connection point type (default is Undefined)
       */
      get type() {
        if (this._type === NodeRenderGraphBlockConnectionPointTypes.AutoDetect) {
          if (this._ownerBlock.isInput) {
            return this._ownerBlock.type;
          }
          if (this._connectedPoint) {
            return this._connectedPoint.type;
          }
          if (this._linkedConnectionSource) {
            if (this._linkedConnectionSource.isConnected) {
              return this._linkedConnectionSource.type;
            }
            if (this._linkedConnectionSource._defaultConnectionPointType) {
              return this._linkedConnectionSource._defaultConnectionPointType;
            }
          }
          if (this._defaultConnectionPointType) {
            return this._defaultConnectionPointType;
          }
        }
        if (this._type === NodeRenderGraphBlockConnectionPointTypes.BasedOnInput) {
          if (this._typeConnectionSource) {
            const typeConnectionSource = typeof this._typeConnectionSource === "function" ? this._typeConnectionSource() : this._typeConnectionSource;
            if (!typeConnectionSource.isConnected) {
              return this._defaultConnectionPointType ?? typeConnectionSource.type;
            }
            return typeConnectionSource._connectedPoint.type;
          } else if (this._defaultConnectionPointType) {
            return this._defaultConnectionPointType;
          }
        }
        return this._type;
      }
      set type(value) {
        this._type = value;
      }
      /**
       * Gets a boolean indicating that the current point is connected to another NodeRenderGraphBlock
       */
      get isConnected() {
        return this.connectedPoint !== null || this.hasEndpoints;
      }
      /** Get the other side of the connection (if any) */
      get connectedPoint() {
        return this._connectedPoint;
      }
      /** Get the block that owns this connection point */
      get ownerBlock() {
        return this._ownerBlock;
      }
      /** Get the block connected on the other side of this connection (if any) */
      get sourceBlock() {
        if (!this._connectedPoint) {
          return null;
        }
        return this._connectedPoint.ownerBlock;
      }
      /** Get the block connected on the endpoints of this connection (if any) */
      get connectedBlocks() {
        if (this._endpoints.length === 0) {
          return [];
        }
        return this._endpoints.map((e) => e.ownerBlock);
      }
      /** Gets the list of connected endpoints */
      get endpoints() {
        return this._endpoints;
      }
      /** Gets a boolean indicating if that output point is connected to at least one input */
      get hasEndpoints() {
        return this._endpoints && this._endpoints.length > 0;
      }
      /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */
      get innerType() {
        if (this._linkedConnectionSource && !this._isMainLinkSource && this._linkedConnectionSource.isConnected) {
          return this.type;
        }
        return this._type;
      }
      /**
       * Creates a block suitable to be used as an input for this input point.
       * If null is returned, a block based on the point type will be created.
       * @returns The returned string parameter is the name of the output point of NodeRenderGraphBlock (first parameter of the returned array) that can be connected to the input
       */
      createCustomInputBlock() {
        return null;
      }
      /**
       * Creates a new connection point
       * @param name defines the connection point name
       * @param ownerBlock defines the block hosting this connection point
       * @param direction defines the direction of the connection point
       */
      constructor(name3, ownerBlock, direction) {
        this._connectedPoint = null;
        this._acceptedConnectionPointType = null;
        this._endpoints = new Array();
        this._type = NodeRenderGraphBlockConnectionPointTypes.Undefined;
        this._linkedConnectionSource = null;
        this._isMainLinkSource = false;
        this._typeConnectionSource = null;
        this._defaultConnectionPointType = null;
        this.needDualDirectionValidation = false;
        this.acceptedConnectionPointTypes = [];
        this.excludedConnectionPointTypes = [];
        this.onConnectionObservable = new Observable();
        this.onDisconnectionObservable = new Observable();
        this.isExposedOnFrame = false;
        this.exposedPortPosition = -1;
        this._ownerBlock = ownerBlock;
        this.name = name3;
        this._direction = direction;
      }
      /**
       * Gets the current class name e.g. "NodeRenderGraphConnectionPoint"
       * @returns the class name
       */
      getClassName() {
        return "NodeRenderGraphConnectionPoint";
      }
      /**
       * Gets a boolean indicating if the current point can be connected to another point
       * @param connectionPoint defines the other connection point
       * @returns a boolean
       */
      canConnectTo(connectionPoint) {
        return this.checkCompatibilityState(connectionPoint) === 0;
      }
      /**
       * Gets a number indicating if the current point can be connected to another point
       * @param connectionPoint defines the other connection point
       * @returns a number defining the compatibility state
       */
      checkCompatibilityState(connectionPoint) {
        const ownerBlock = this._ownerBlock;
        const otherBlock = connectionPoint.ownerBlock;
        if (this.type !== connectionPoint.type && connectionPoint.innerType !== NodeRenderGraphBlockConnectionPointTypes.AutoDetect) {
          if (connectionPoint.acceptedConnectionPointTypes && connectionPoint.acceptedConnectionPointTypes.indexOf(this.type) !== -1) {
            return 0;
          } else {
            return 1;
          }
        }
        if (connectionPoint.excludedConnectionPointTypes && connectionPoint.excludedConnectionPointTypes.indexOf(this.type) !== -1) {
          return 1;
        }
        let targetBlock = otherBlock;
        let sourceBlock = ownerBlock;
        if (this.direction === 0) {
          targetBlock = ownerBlock;
          sourceBlock = otherBlock;
        }
        if (targetBlock.isAnAncestorOf(sourceBlock)) {
          return 2;
        }
        return 0;
      }
      /**
       * Connect this point to another connection point
       * @param connectionPoint defines the other connection point
       * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)
       * @returns the current connection point
       */
      connectTo(connectionPoint, ignoreConstraints = false) {
        if (!ignoreConstraints && !this.canConnectTo(connectionPoint)) {
          throw `Cannot connect these two connectors. source: "${this.ownerBlock.name}".${this.name}, target: "${connectionPoint.ownerBlock.name}".${connectionPoint.name}`;
        }
        this._endpoints.push(connectionPoint);
        connectionPoint._connectedPoint = this;
        this.onConnectionObservable.notifyObservers(connectionPoint);
        connectionPoint.onConnectionObservable.notifyObservers(this);
        return this;
      }
      /**
       * Disconnect this point from one of his endpoint
       * @param endpoint defines the other connection point
       * @returns the current connection point
       */
      disconnectFrom(endpoint) {
        const index = this._endpoints.indexOf(endpoint);
        if (index === -1) {
          return this;
        }
        this._endpoints.splice(index, 1);
        endpoint._connectedPoint = null;
        this.onDisconnectionObservable.notifyObservers(endpoint);
        endpoint.onDisconnectionObservable.notifyObservers(this);
        return this;
      }
      /**
       * Fills the list of excluded connection point types with all types other than those passed in the parameter
       * @param mask Types (ORed values of NodeRenderGraphBlockConnectionPointTypes) that are allowed, and thus will not be pushed to the excluded list
       */
      addExcludedConnectionPointFromAllowedTypes(mask) {
        let bitmask = 0;
        let val = 2 ** bitmask;
        while (val < NodeRenderGraphBlockConnectionPointTypes.All) {
          if (!(mask & val)) {
            this.excludedConnectionPointTypes.push(val);
          }
          bitmask++;
          val = 2 ** bitmask;
        }
      }
      /**
       * Adds accepted connection point types
       * @param mask Types (ORed values of NodeRenderGraphBlockConnectionPointTypes) that are allowed to connect to this point
       */
      addAcceptedConnectionPointTypes(mask) {
        let bitmask = 0;
        let val = 2 ** bitmask;
        while (val < NodeRenderGraphBlockConnectionPointTypes.All) {
          if (mask & val && this.acceptedConnectionPointTypes.indexOf(val) === -1) {
            this.acceptedConnectionPointTypes.push(val);
          }
          bitmask++;
          val = 2 ** bitmask;
        }
      }
      /**
       * Serializes this point in a JSON representation
       * @param isInput defines if the connection point is an input (default is true)
       * @returns the serialized point object
       */
      serialize(isInput = true) {
        const serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.displayName = this.displayName;
        if (isInput && this.connectedPoint) {
          serializationObject.inputName = this.name;
          serializationObject.targetBlockId = this.connectedPoint.ownerBlock.uniqueId;
          serializationObject.targetConnectionName = this.connectedPoint.name;
          serializationObject.isExposedOnFrame = true;
          serializationObject.exposedPortPosition = this.exposedPortPosition;
        }
        if (this.isExposedOnFrame || this.exposedPortPosition >= 0) {
          serializationObject.isExposedOnFrame = true;
          serializationObject.exposedPortPosition = this.exposedPortPosition;
        }
        return serializationObject;
      }
      /**
       * Release resources
       */
      dispose() {
        this.onConnectionObservable.clear();
        this.onDisconnectionObservable.clear();
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/Node/nodeRenderGraphBlock.js
var NodeRenderGraphBlock;
var init_nodeRenderGraphBlock = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Node/nodeRenderGraphBlock.js"() {
    init_tslib_es6();
    init_typeStore();
    init_decorators();
    init_uniqueIdGenerator();
    init_nodeRenderGraphTypes();
    init_observable();
    init_logger();
    init_nodeRenderGraphBlockConnectionPoint();
    NodeRenderGraphBlock = class {
      /**
       * Gets or sets the disable flag of the task associated with this block
       */
      get disabled() {
        return !!this._frameGraphTask?.disabled;
      }
      set disabled(value) {
        if (this._frameGraphTask) {
          this._frameGraphTask.disabled = value;
        }
      }
      /**
       * Gets the frame graph task associated with this block
       */
      get task() {
        return this._frameGraphTask;
      }
      /**
       * Gets the list of input points
       */
      get inputs() {
        return this._inputs;
      }
      /** Gets the list of output points */
      get outputs() {
        return this._outputs;
      }
      /**
       * Gets or set the name of the block
       */
      get name() {
        return this._name;
      }
      set name(value) {
        this._name = value;
      }
      /**
       * Gets a boolean indicating if this block is an input
       */
      get isInput() {
        return this._isInput;
      }
      /**
       * Gets a boolean indicating if this block is a teleport out
       */
      get isTeleportOut() {
        return this._isTeleportOut;
      }
      /**
       * Gets a boolean indicating if this block is a teleport in
       */
      get isTeleportIn() {
        return this._isTeleportIn;
      }
      /**
       * Gets a boolean indicating if this block is a debug block
       */
      get isDebug() {
        return this._isDebug;
      }
      /**
       * Gets a boolean indicating that this block can only be used once per node render graph
       */
      get isUnique() {
        return this._isUnique;
      }
      /**
       * Gets the current class name e.g. "NodeRenderGraphBlock"
       * @returns the class name
       */
      getClassName() {
        return "NodeRenderGraphBlock";
      }
      _inputRename(name3) {
        return name3;
      }
      _outputRename(name3) {
        return name3;
      }
      /**
       * Checks if the current block is an ancestor of a given block
       * @param block defines the potential descendant block to check
       * @returns true if block is a descendant
       */
      isAnAncestorOf(block) {
        for (const output of this._outputs) {
          if (!output.hasEndpoints) {
            continue;
          }
          for (const endpoint of output.endpoints) {
            if (endpoint.ownerBlock === block) {
              return true;
            }
            if (endpoint.ownerBlock.isAnAncestorOf(block)) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Checks if the current block is an ancestor of a given type
       * @param type defines the potential type to check
       * @returns true if block is a descendant
       */
      isAnAncestorOfType(type) {
        if (this.getClassName() === type) {
          return true;
        }
        for (const output of this._outputs) {
          if (!output.hasEndpoints) {
            continue;
          }
          for (const endpoint of output.endpoints) {
            if (endpoint.ownerBlock.isAnAncestorOfType(type)) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Get the first descendant using a predicate
       * @param predicate defines the predicate to check
       * @returns descendant or null if none found
       */
      getDescendantOfPredicate(predicate) {
        if (predicate(this)) {
          return this;
        }
        for (const output of this._outputs) {
          if (!output.hasEndpoints) {
            continue;
          }
          for (const endpoint of output.endpoints) {
            const descendant = endpoint.ownerBlock.getDescendantOfPredicate(predicate);
            if (descendant) {
              return descendant;
            }
          }
        }
        return null;
      }
      /**
       * Creates a new NodeRenderGraphBlock
       * @param name defines the block name
       * @param frameGraph defines the hosting frame graph
       * @param scene defines the hosting scene
       * @param _additionalConstructionParameters defines additional parameters to pass to the block constructor
       */
      constructor(name3, frameGraph, scene, ..._additionalConstructionParameters) {
        this._name = "";
        this._isInput = false;
        this._isTeleportOut = false;
        this._isTeleportIn = false;
        this._isDebug = false;
        this._isUnique = false;
        this.onBuildObservable = new Observable();
        this._inputs = new Array();
        this._outputs = new Array();
        this._codeVariableName = "";
        this._additionalConstructionParameters = null;
        this.visibleOnFrame = false;
        this._name = name3;
        this._frameGraph = frameGraph;
        this._scene = scene;
        this._engine = scene.getEngine();
        this.uniqueId = UniqueIdGenerator.UniqueId;
      }
      /**
       * Register a new input. Must be called inside a block constructor
       * @param name defines the connection point name
       * @param type defines the connection point type
       * @param isOptional defines a boolean indicating that this input can be omitted
       * @param point an already created connection point. If not provided, create a new one
       * @returns the current block
       */
      registerInput(name3, type, isOptional = false, point) {
        point = point ?? new NodeRenderGraphConnectionPoint(
          name3,
          this,
          0
          /* NodeRenderGraphConnectionPointDirection.Input */
        );
        point.type = type;
        point.isOptional = isOptional;
        this._inputs.push(point);
        return this;
      }
      /**
       * Register a new output. Must be called inside a block constructor
       * @param name defines the connection point name
       * @param type defines the connection point type
       * @param point an already created connection point. If not provided, create a new one
       * @returns the current block
       */
      registerOutput(name3, type, point) {
        point = point ?? new NodeRenderGraphConnectionPoint(
          name3,
          this,
          1
          /* NodeRenderGraphConnectionPointDirection.Output */
        );
        point.type = type;
        this._outputs.push(point);
        return this;
      }
      _addDependenciesInput(additionalAllowedTypes = 0) {
        this.registerInput("dependencies", NodeRenderGraphBlockConnectionPointTypes.AutoDetect, true);
        const dependencies = this.getInputByName("dependencies");
        Object.defineProperty(this, "dependencies", {
          get: function() {
            return dependencies;
          },
          enumerable: true,
          configurable: true
        });
        dependencies.addExcludedConnectionPointFromAllowedTypes(NodeRenderGraphBlockConnectionPointTypes.TextureAllButBackBuffer | NodeRenderGraphBlockConnectionPointTypes.ResourceContainer | NodeRenderGraphBlockConnectionPointTypes.ShadowGenerator | NodeRenderGraphBlockConnectionPointTypes.ObjectList | NodeRenderGraphBlockConnectionPointTypes.ShadowLight | NodeRenderGraphBlockConnectionPointTypes.Camera | NodeRenderGraphBlockConnectionPointTypes.Object | additionalAllowedTypes);
        return dependencies;
      }
      _buildBlock(_state) {
      }
      _customBuildStep(_state) {
      }
      _propagateInputValueToOutput(inputConnectionPoint, outputConnectionPoint) {
        if (inputConnectionPoint.connectedPoint) {
          outputConnectionPoint.value = inputConnectionPoint.connectedPoint.value;
        }
      }
      /**
       * Build the current node and generate the vertex data
       * @param state defines the current generation state
       * @returns true if already built
       */
      build(state) {
        if (this._buildId === state.buildId) {
          return true;
        }
        this._buildId = state.buildId;
        for (const input of this._inputs) {
          if (!input.connectedPoint) {
            if (!input.isOptional) {
              state._notConnectedNonOptionalInputs.push(input);
            }
            continue;
          }
          const block = input.connectedPoint.ownerBlock;
          if (block && block !== this) {
            block.build(state);
          }
        }
        this._customBuildStep(state);
        if (state.verbose) {
          Logger.Log(`Building ${this.name} [${this.getClassName()}]`);
        }
        if (this._frameGraphTask) {
          this._frameGraphTask.name = this.name;
        }
        this._buildBlock(state);
        if (this._frameGraphTask) {
          this._frameGraphTask.dependencies = void 0;
          const dependenciesConnectedPoint = this.getInputByName("dependencies")?.connectedPoint;
          if (dependenciesConnectedPoint) {
            if (dependenciesConnectedPoint.type === NodeRenderGraphBlockConnectionPointTypes.ResourceContainer) {
              const container = dependenciesConnectedPoint.ownerBlock;
              for (let i = 0; i < container.inputs.length; i++) {
                const input = container.inputs[i];
                if (input.connectedPoint && input.connectedPoint.value !== void 0 && NodeRenderGraphConnectionPoint.IsTextureHandle(input.connectedPoint.value)) {
                  this._frameGraphTask.dependencies = this._frameGraphTask.dependencies || /* @__PURE__ */ new Set();
                  this._frameGraphTask.dependencies.add(input.connectedPoint.value);
                }
              }
            } else if (NodeRenderGraphConnectionPoint.IsTextureHandle(dependenciesConnectedPoint.value)) {
              this._frameGraphTask.dependencies = this._frameGraphTask.dependencies || /* @__PURE__ */ new Set();
              this._frameGraphTask.dependencies.add(dependenciesConnectedPoint.value);
            }
          }
          this._frameGraph.addTask(this._frameGraphTask);
        }
        this.onBuildObservable.notifyObservers(this);
        return false;
      }
      _getConnectedTextures(targetConnectedPoint) {
        let textureHandles;
        if (targetConnectedPoint) {
          if (targetConnectedPoint.type === NodeRenderGraphBlockConnectionPointTypes.ResourceContainer) {
            const container = targetConnectedPoint.ownerBlock;
            textureHandles = [];
            for (let i = 0; i < container.inputs.length; i++) {
              const input = container.inputs[i];
              if (input.connectedPoint && input.connectedPoint.value !== void 0 && NodeRenderGraphConnectionPoint.IsTextureHandle(input.connectedPoint.value)) {
                textureHandles.push(input.connectedPoint.value);
              }
            }
          } else {
            textureHandles = targetConnectedPoint.value;
          }
        }
        return textureHandles;
      }
      _linkConnectionTypes(inputIndex0, inputIndex1, looseCoupling = false) {
        if (looseCoupling) {
          this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];
        } else {
          this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];
          this._inputs[inputIndex0]._isMainLinkSource = true;
        }
        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];
      }
      /**
       * Initialize the block and prepare the context for build
       */
      initialize() {
      }
      /**
       * Lets the block try to connect some inputs automatically
       */
      autoConfigure() {
      }
      /**
       * Find an input by its name
       * @param name defines the name of the input to look for
       * @returns the input or null if not found
       */
      getInputByName(name3) {
        const filter = this._inputs.filter((e) => e.name === name3);
        if (filter.length) {
          return filter[0];
        }
        return null;
      }
      /**
       * Find an output by its name
       * @param name defines the name of the output to look for
       * @returns the output or null if not found
       */
      getOutputByName(name3) {
        const filter = this._outputs.filter((e) => e.name === name3);
        if (filter.length) {
          return filter[0];
        }
        return null;
      }
      /**
       * Serializes this block in a JSON representation
       * @returns the serialized block object
       */
      serialize() {
        const serializationObject = {};
        serializationObject.customType = "BABYLON." + this.getClassName();
        serializationObject.id = this.uniqueId;
        serializationObject.name = this.name;
        serializationObject.comments = this.comments;
        serializationObject.visibleOnFrame = this.visibleOnFrame;
        serializationObject.disabled = this.disabled;
        if (this._additionalConstructionParameters) {
          serializationObject.additionalConstructionParameters = this._additionalConstructionParameters;
        }
        serializationObject.inputs = [];
        serializationObject.outputs = [];
        for (const input of this.inputs) {
          serializationObject.inputs.push(input.serialize());
        }
        for (const output of this.outputs) {
          serializationObject.outputs.push(output.serialize(false));
        }
        return serializationObject;
      }
      /**
       * @internal
       */
      _deserialize(serializationObject) {
        this._name = serializationObject.name;
        this.comments = serializationObject.comments;
        this.visibleOnFrame = serializationObject.visibleOnFrame;
        this.disabled = serializationObject.disabled;
        this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);
      }
      _deserializePortDisplayNamesAndExposedOnFrame(serializationObject) {
        const serializedInputs = serializationObject.inputs;
        const serializedOutputs = serializationObject.outputs;
        if (serializedInputs) {
          for (const port of serializedInputs) {
            const input = this.inputs.find((i) => i.name === port.name);
            if (!input) {
              continue;
            }
            if (port.displayName) {
              input.displayName = port.displayName;
            }
            if (port.isExposedOnFrame) {
              input.isExposedOnFrame = port.isExposedOnFrame;
              input.exposedPortPosition = port.exposedPortPosition;
            }
          }
        }
        if (serializedOutputs) {
          for (let i = 0; i < serializedOutputs.length; i++) {
            const port = serializedOutputs[i];
            if (port.displayName) {
              this.outputs[i].displayName = port.displayName;
            }
            if (port.isExposedOnFrame) {
              this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;
              this.outputs[i].exposedPortPosition = port.exposedPortPosition;
            }
          }
        }
      }
      _dumpPropertiesCode() {
        const variableName = this._codeVariableName;
        return `${variableName}.visibleOnFrame = ${this.visibleOnFrame};
${variableName}.disabled = ${this.disabled};
`;
      }
      /**
       * @internal
       */
      _dumpCodeForOutputConnections(alreadyDumped) {
        let codeString = "";
        if (alreadyDumped.indexOf(this) !== -1) {
          return codeString;
        }
        alreadyDumped.push(this);
        for (const input of this.inputs) {
          if (!input.isConnected) {
            continue;
          }
          const connectedOutput = input.connectedPoint;
          const connectedBlock = connectedOutput.ownerBlock;
          codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);
          codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(input.name)});
`;
        }
        return codeString;
      }
      /**
       * @internal
       */
      _dumpCode(uniqueNames, alreadyDumped) {
        alreadyDumped.push(this);
        const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, "");
        this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;
        if (uniqueNames.indexOf(this._codeVariableName) !== -1) {
          let index = 0;
          do {
            index++;
            this._codeVariableName = nameAsVariableName + index;
          } while (uniqueNames.indexOf(this._codeVariableName) !== -1);
        }
        uniqueNames.push(this._codeVariableName);
        let codeString = `
// ${this.getClassName()}
`;
        if (this.comments) {
          codeString += `// ${this.comments}
`;
        }
        const className = this.getClassName();
        if (className === "NodeRenderGraphInputBlock") {
          const block = this;
          const blockType = block.type;
          codeString += `var ${this._codeVariableName} = new BABYLON.NodeRenderGraphInputBlock("${this.name}", nodeRenderGraph.frameGraph, scene, BABYLON.NodeRenderGraphBlockConnectionPointTypes.${NodeRenderGraphBlockConnectionPointTypes[blockType]});
`;
        } else {
          if (this._additionalConstructionParameters) {
            codeString += `var ${this._codeVariableName} = new BABYLON.${className}("${this.name}", nodeRenderGraph.frameGraph, scene, ...${JSON.stringify(this._additionalConstructionParameters)});
`;
          } else {
            codeString += `var ${this._codeVariableName} = new BABYLON.${className}("${this.name}", nodeRenderGraph.frameGraph, scene);
`;
          }
        }
        codeString += this._dumpPropertiesCode() + "\n";
        for (const input of this.inputs) {
          if (!input.isConnected) {
            continue;
          }
          const connectedOutput = input.connectedPoint;
          const connectedBlock = connectedOutput.ownerBlock;
          if (alreadyDumped.indexOf(connectedBlock) === -1) {
            codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
          }
        }
        for (const output of this.outputs) {
          if (!output.hasEndpoints) {
            continue;
          }
          for (const endpoint of output.endpoints) {
            const connectedBlock = endpoint.ownerBlock;
            if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {
              codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);
            }
          }
        }
        return codeString;
      }
      /**
       * Clone the current block to a new identical block
       * @returns a copy of the current block
       */
      clone() {
        const serializationObject = this.serialize();
        const blockType = GetClass(serializationObject.customType);
        if (blockType) {
          const additionalConstructionParameters = serializationObject.additionalConstructionParameters;
          const block = additionalConstructionParameters ? new blockType("", this._frameGraph, this._scene, ...additionalConstructionParameters) : new blockType("", this._frameGraph, this._scene);
          block._deserialize(serializationObject);
          return block;
        }
        return null;
      }
      /**
       * Release resources
       */
      dispose() {
        for (const input of this.inputs) {
          input.dispose();
        }
        for (const output of this.outputs) {
          output.dispose();
        }
        this._frameGraphTask?.dispose();
        this._frameGraphTask = void 0;
        this.onBuildObservable.clear();
      }
    };
    __decorate([
      serialize("comment")
    ], NodeRenderGraphBlock.prototype, "comments", void 0);
  }
});

// node_modules/@babylonjs/core/FrameGraph/Tasks/Texture/copyToBackbufferColorTask.js
var FrameGraphCopyToBackbufferColorTask;
var init_copyToBackbufferColorTask = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Tasks/Texture/copyToBackbufferColorTask.js"() {
    init_frameGraphTypes();
    init_frameGraphTask();
    FrameGraphCopyToBackbufferColorTask = class extends FrameGraphTask {
      getClassName() {
        return "FrameGraphCopyToBackbufferColorTask";
      }
      record() {
        if (this.sourceTexture === void 0) {
          throw new Error(`FrameGraphCopyToBackbufferColorTask "${this.name}": sourceTexture is required`);
        }
        const pass = this._frameGraph.addRenderPass(this.name);
        pass.addDependencies(this.sourceTexture);
        pass.setRenderTarget(backbufferColorTextureHandle);
        pass.setExecuteFunc((context) => {
          if (!context.isBackbuffer(this.sourceTexture)) {
            context.copyTexture(this.sourceTexture);
          }
        });
        const passDisabled = this._frameGraph.addRenderPass(this.name + "_disabled", true);
        passDisabled.setRenderTarget(backbufferColorTextureHandle);
        passDisabled.setExecuteFunc((_context) => {
        });
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/Node/Blocks/outputBlock.js
var NodeRenderGraphOutputBlock;
var init_outputBlock = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Node/Blocks/outputBlock.js"() {
    init_nodeRenderGraphBlock();
    init_typeStore();
    init_nodeRenderGraphTypes();
    init_copyToBackbufferColorTask();
    NodeRenderGraphOutputBlock = class extends NodeRenderGraphBlock {
      /**
       * Gets the frame graph task associated with this block
       */
      get task() {
        return this._frameGraphTask;
      }
      /**
       * Create a new NodeRenderGraphOutputBlock
       * @param name defines the block name
       * @param frameGraph defines the hosting frame graph
       * @param scene defines the hosting scene
       */
      constructor(name3, frameGraph, scene) {
        super(name3, frameGraph, scene);
        this._isUnique = true;
        this.registerInput("texture", NodeRenderGraphBlockConnectionPointTypes.Texture);
        this._addDependenciesInput();
        this.texture.addAcceptedConnectionPointTypes(NodeRenderGraphBlockConnectionPointTypes.TextureAll);
        this._frameGraphTask = new FrameGraphCopyToBackbufferColorTask(name3, frameGraph);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "NodeRenderGraphOutputBlock";
      }
      /**
       * Gets the texture input component
       */
      get texture() {
        return this._inputs[0];
      }
      _buildBlock(state) {
        super._buildBlock(state);
        this._frameGraphTask.name = this.name;
        const textureConnectedPoint = this.texture.connectedPoint;
        if (textureConnectedPoint) {
          this._frameGraphTask.sourceTexture = textureConnectedPoint.value;
        }
      }
    };
    RegisterClass("BABYLON.NodeRenderGraphOutputBlock", NodeRenderGraphOutputBlock);
  }
});

// node_modules/@babylonjs/core/FrameGraph/Node/Blocks/inputBlock.js
var NodeRenderGraphInputBlock;
var init_inputBlock = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Node/Blocks/inputBlock.js"() {
    init_tslib_es6();
    init_observable();
    init_nodeRenderGraphTypes();
    init_nodeRenderGraphBlock();
    init_typeStore();
    init_nodeDecorator();
    init_frameGraphTypes();
    NodeRenderGraphInputBlock = class extends NodeRenderGraphBlock {
      /**
       * Gets or sets the connection point type (default is Undefined)
       */
      get type() {
        return this._type;
      }
      /**
       * Creates a new NodeRenderGraphInputBlock
       * @param name defines the block name
       * @param frameGraph defines the hosting frame graph
       * @param scene defines the hosting scene
       * @param type defines the type of the input (can be set to NodeRenderGraphBlockConnectionPointTypes.Undefined)
       */
      constructor(name3, frameGraph, scene, type = NodeRenderGraphBlockConnectionPointTypes.Undefined) {
        super(name3, frameGraph, scene);
        this._storedValue = null;
        this._type = NodeRenderGraphBlockConnectionPointTypes.Undefined;
        this.onValueChangedObservable = new Observable();
        this.isExternal = false;
        this._type = type;
        this._isInput = true;
        this.registerOutput("output", type);
        this.setDefaultValue();
      }
      /**
       * Set the input block to its default value (based on its type)
       */
      setDefaultValue() {
        switch (this.type) {
          case NodeRenderGraphBlockConnectionPointTypes.Texture:
          case NodeRenderGraphBlockConnectionPointTypes.TextureViewDepth:
          case NodeRenderGraphBlockConnectionPointTypes.TextureScreenDepth:
          case NodeRenderGraphBlockConnectionPointTypes.TextureNormalizedViewDepth:
          case NodeRenderGraphBlockConnectionPointTypes.TextureViewNormal:
          case NodeRenderGraphBlockConnectionPointTypes.TextureWorldNormal:
          case NodeRenderGraphBlockConnectionPointTypes.TextureAlbedo:
          case NodeRenderGraphBlockConnectionPointTypes.TextureReflectivity:
          case NodeRenderGraphBlockConnectionPointTypes.TextureLocalPosition:
          case NodeRenderGraphBlockConnectionPointTypes.TextureWorldPosition:
          case NodeRenderGraphBlockConnectionPointTypes.TextureVelocity:
          case NodeRenderGraphBlockConnectionPointTypes.TextureLinearVelocity:
          case NodeRenderGraphBlockConnectionPointTypes.TextureIrradiance:
          case NodeRenderGraphBlockConnectionPointTypes.TextureAlbedoSqrt: {
            const options = {
              size: { width: 100, height: 100 },
              options: {
                createMipMaps: false,
                targetTypes: [3553],
                types: [0],
                formats: [5],
                layerCounts: [0],
                samples: 1,
                useSRGBBuffers: [false],
                creationFlags: [0]
              },
              sizeIsPercentage: true,
              isHistoryTexture: false
            };
            this.creationOptions = options;
            break;
          }
          case NodeRenderGraphBlockConnectionPointTypes.TextureDepthStencilAttachment: {
            const options = {
              size: { width: 100, height: 100 },
              options: {
                createMipMaps: false,
                targetTypes: [3553],
                types: [0],
                formats: [13],
                layerCounts: [0],
                useSRGBBuffers: [false],
                creationFlags: [0],
                labels: [this.name],
                samples: 1
              },
              sizeIsPercentage: true,
              isHistoryTexture: false
            };
            this.creationOptions = options;
            break;
          }
          case NodeRenderGraphBlockConnectionPointTypes.ObjectList:
            this.value = { meshes: null, particleSystems: null };
            this.isExternal = true;
            break;
          case NodeRenderGraphBlockConnectionPointTypes.Camera:
            this.value = this._scene.cameras[0];
            this.isExternal = true;
            break;
          default:
            this.isExternal = true;
        }
      }
      /**
       * Gets or sets the value of that point.
       */
      get value() {
        return this._storedValue;
      }
      set value(value) {
        this._storedValue = value;
        this.output.value = void 0;
        this.onValueChangedObservable.notifyObservers(this);
      }
      /**
       * Gets the value as a specific type
       * @returns the value as a specific type
       */
      getTypedValue() {
        return this._storedValue;
      }
      /**
       * Gets the value as an internal texture
       * @returns The internal texture stored in value if value is an internal texture, otherwise null
       */
      getInternalTextureFromValue() {
        if (this._storedValue._swapAndDie) {
          return this._storedValue;
        }
        return null;
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "NodeRenderGraphInputBlock";
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Check if the block is a texture of any type
       * @returns true if the block is a texture
       */
      isAnyTexture() {
        return (this.type & NodeRenderGraphBlockConnectionPointTypes.TextureAll) !== 0;
      }
      /**
       * Gets a boolean indicating that the connection point is the back buffer texture
       * @returns true if the connection point is the back buffer texture
       */
      isBackBuffer() {
        return (this.type & NodeRenderGraphBlockConnectionPointTypes.TextureBackBuffer) !== 0;
      }
      /**
       * Gets a boolean indicating that the connection point is a depth/stencil attachment texture
       * @returns true if the connection point is a depth/stencil attachment texture
       */
      isBackBufferDepthStencilAttachment() {
        return (this.type & NodeRenderGraphBlockConnectionPointTypes.TextureBackBufferDepthStencilAttachment) !== 0;
      }
      /**
       * Check if the block is a camera
       * @returns true if the block is a camera
       */
      isCamera() {
        return (this.type & NodeRenderGraphBlockConnectionPointTypes.Camera) !== 0;
      }
      /**
       * Check if the block is an object list
       * @returns true if the block is an object list
       */
      isObjectList() {
        return (this.type & NodeRenderGraphBlockConnectionPointTypes.ObjectList) !== 0;
      }
      /**
       * Check if the block is a shadow light
       * @returns true if the block is a shadow light
       */
      isShadowLight() {
        return (this.type & NodeRenderGraphBlockConnectionPointTypes.ShadowLight) !== 0;
      }
      _buildBlock(state) {
        super._buildBlock(state);
        if (this.isExternal) {
          if (this.isBackBuffer()) {
            this.output.value = backbufferColorTextureHandle;
          } else if (this.isBackBufferDepthStencilAttachment()) {
            this.output.value = backbufferDepthStencilTextureHandle;
          } else if (this.isCamera()) {
            this.output.value = this.getTypedValue();
          } else if (this.isObjectList()) {
            this.output.value = this.getTypedValue();
          } else if (this.isShadowLight()) {
            this.output.value = this.getTypedValue();
          } else {
            if (this._storedValue === void 0 || this._storedValue === null) {
              throw new Error(`NodeRenderGraphInputBlock: External input "${this.name}" is not set`);
            }
            const texture = this.getInternalTextureFromValue();
            if (texture) {
              this.output.value = this._frameGraph.textureManager.importTexture(this.name, texture, this.output.value);
            }
          }
          return;
        }
        if ((this.type & NodeRenderGraphBlockConnectionPointTypes.TextureAllButBackBuffer) !== 0) {
          const textureCreateOptions = this.creationOptions;
          if (!textureCreateOptions) {
            throw new Error(`NodeRenderGraphInputBlock: Creation options are missing for texture "${this.name}"`);
          }
          this.output.value = this._frameGraph.textureManager.createRenderTargetTexture(this.name, textureCreateOptions);
        }
      }
      dispose() {
        this._storedValue = null;
        this.onValueChangedObservable.clear();
        super.dispose();
      }
      _dumpPropertiesCode() {
        const codes = [];
        codes.push(`${this._codeVariableName}.isExternal = ${this.isExternal};`);
        if (this.isAnyTexture()) {
          if (!this.isExternal) {
            codes.push(`${this._codeVariableName}.creationOptions = ${JSON.stringify(this.creationOptions)};`);
          } else {
            codes.push(`${this._codeVariableName}.value = EXTERNAL_TEXTURE; // TODO: set the external texture`);
          }
        } else if (this.isCamera()) {
          codes.push(`${this._codeVariableName}.value = EXTERNAL_CAMERA; // TODO: set the external camera`);
        } else if (this.isObjectList()) {
          codes.push(`${this._codeVariableName}.value = EXTERNAL_OBJECT_LIST; // TODO: set the external object list`);
        } else if (this.isShadowLight()) {
          codes.push(`${this._codeVariableName}.value = EXTERNAL_SHADOW_LIGHT; // TODO: set the external shadow light`);
        }
        return super._dumpPropertiesCode() + codes.join("\n");
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.type = this.type;
        serializationObject.isExternal = this.isExternal;
        if (this.creationOptions) {
          serializationObject.creationOptions = this.creationOptions;
        }
        return serializationObject;
      }
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        this._type = serializationObject.type;
        this.output.type = this._type;
        this.isExternal = serializationObject.isExternal;
        if (serializationObject.creationOptions) {
          if (serializationObject.creationOptions.options.depthTextureFormat !== void 0) {
            serializationObject.creationOptions.options.formats = [serializationObject.creationOptions.options.depthTextureFormat];
          }
          this.creationOptions = serializationObject.creationOptions;
        }
      }
    };
    __decorate([
      editableInPropertyPage("Is external", 0, "PROPERTIES")
    ], NodeRenderGraphInputBlock.prototype, "isExternal", void 0);
    RegisterClass("BABYLON.NodeRenderGraphInputBlock", NodeRenderGraphInputBlock);
  }
});

// node_modules/@babylonjs/core/FrameGraph/Tasks/Texture/clearTextureTask.js
var FrameGraphClearTextureTask;
var init_clearTextureTask = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Tasks/Texture/clearTextureTask.js"() {
    init_math_color();
    init_frameGraphTaskMultiRenderTarget();
    init_frameGraphTypes();
    FrameGraphClearTextureTask = class extends FrameGraphTaskMultiRenderTarget {
      /**
       * Constructs a new clear task.
       * @param name The name of the task.
       * @param frameGraph The frame graph the task belongs to.
       */
      constructor(name3, frameGraph) {
        super(name3, frameGraph);
        this.color = new Color4(0.2, 0.2, 0.3, 1);
        this.clearColor = true;
        this.convertColorToLinearSpace = false;
        this.clearDepth = false;
        this.clearStencil = false;
        this.stencilValue = 0;
        this.outputTexture = this._frameGraph.textureManager.createDanglingHandle();
        this.outputDepthTexture = this._frameGraph.textureManager.createDanglingHandle();
      }
      getClassName() {
        return "FrameGraphClearTextureTask";
      }
      record(skipCreationOfDisabledPasses = false) {
        if (this.targetTexture === void 0 && this.depthTexture === void 0) {
          throw new Error(`FrameGraphClearTextureTask ${this.name}: targetTexture and depthTexture can't both be undefined.`);
        }
        const textureManager = this._frameGraph.textureManager;
        const targetTextures = this.targetTexture !== void 0 ? Array.isArray(this.targetTexture) ? this.targetTexture : [this.targetTexture] : void 0;
        if (this.targetTexture !== void 0) {
          textureManager.resolveDanglingHandle(this.outputTexture, targetTextures[0]);
        }
        if (this.depthTexture !== void 0) {
          textureManager.resolveDanglingHandle(this.outputDepthTexture, this.depthTexture);
        }
        if (this.targetTexture !== void 0 && this.depthTexture !== void 0) {
          const targetDescription = textureManager.getTextureDescription(targetTextures[0]);
          const depthDescription = textureManager.getTextureDescription(this.depthTexture);
          if (targetDescription.size.width !== depthDescription.size.width || targetDescription.size.height !== depthDescription.size.height) {
            throw new Error(`FrameGraphClearTextureTask ${this.name}: the depth texture (size: ${depthDescription.size.width}x${depthDescription.size.height}) and the target texture (size: ${targetDescription.size.width}x${targetDescription.size.height}) must have the same dimensions.`);
          }
          const textureSamples = targetDescription.options.samples || 1;
          const depthSamples = depthDescription.options.samples || 1;
          if (textureSamples !== depthSamples && textureSamples !== 0 && depthSamples !== 0) {
            throw new Error(`FrameGraphClearTextureTask ${this.name}: the depth texture (${depthSamples} samples) and the target texture (${textureSamples} samples) must have the same number of samples.`);
          }
        }
        const attachments = this._frameGraph.engine.buildTextureLayout(targetTextures ? Array(targetTextures.length).fill(true) : [], this.targetTexture === backbufferColorTextureHandle && !this._frameGraph.textureManager.backBufferTextureOverriden);
        const color = TmpColors.Color4[0];
        const pass = this._frameGraph.addRenderPass(this.name);
        pass.setRenderTarget(targetTextures);
        pass.setRenderTargetDepth(this.depthTexture);
        pass.setInitializeFunc(() => {
          const renderTargetWrapper = pass.frameGraphRenderTarget.renderTargetWrapper;
          if (renderTargetWrapper) {
            renderTargetWrapper.disableAutomaticMSAAResolve = true;
          }
        });
        pass.setExecuteFunc((context) => {
          this._updateLayerAndFaceIndices(pass);
          color.copyFrom(this.color);
          if (this.convertColorToLinearSpace) {
            color.toLinearSpaceToRef(color);
          }
          context.clearAttachments(color, attachments, !!this.clearColor, !!this.clearDepth, !!this.clearStencil, this.stencilValue);
        });
        if (!skipCreationOfDisabledPasses) {
          const passDisabled = this._frameGraph.addRenderPass(this.name + "_disabled", true);
          passDisabled.setRenderTarget(targetTextures);
          passDisabled.setRenderTargetDepth(this.depthTexture);
          passDisabled.setExecuteFunc((_context) => {
          });
        }
        return pass;
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/Node/Blocks/Textures/clearBlock.js
var NodeRenderGraphClearBlock;
var init_clearBlock = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Node/Blocks/Textures/clearBlock.js"() {
    init_tslib_es6();
    init_nodeRenderGraphBlock();
    init_typeStore();
    init_nodeRenderGraphTypes();
    init_math_color();
    init_nodeDecorator();
    init_clearTextureTask();
    NodeRenderGraphClearBlock = class extends NodeRenderGraphBlock {
      /**
       * Gets the frame graph task associated with this block
       */
      get task() {
        return this._frameGraphTask;
      }
      /**
       * Create a new NodeRenderGraphClearBlock
       * @param name defines the block name
       * @param frameGraph defines the hosting frame graph
       * @param scene defines the hosting scene
       */
      constructor(name3, frameGraph, scene) {
        super(name3, frameGraph, scene);
        this.registerInput("target", NodeRenderGraphBlockConnectionPointTypes.AutoDetect, true);
        this.registerInput("depth", NodeRenderGraphBlockConnectionPointTypes.AutoDetect, true);
        this._addDependenciesInput();
        this.registerOutput("output", NodeRenderGraphBlockConnectionPointTypes.BasedOnInput);
        this.registerOutput("outputDepth", NodeRenderGraphBlockConnectionPointTypes.BasedOnInput);
        this.target.addExcludedConnectionPointFromAllowedTypes(NodeRenderGraphBlockConnectionPointTypes.TextureAll | NodeRenderGraphBlockConnectionPointTypes.ResourceContainer);
        this.depth.addExcludedConnectionPointFromAllowedTypes(NodeRenderGraphBlockConnectionPointTypes.TextureDepthStencilAttachment | NodeRenderGraphBlockConnectionPointTypes.TextureBackBufferDepthStencilAttachment);
        this.output._typeConnectionSource = this.target;
        this.outputDepth._typeConnectionSource = this.depth;
        this._frameGraphTask = new FrameGraphClearTextureTask(name3, frameGraph);
      }
      /** Gets or sets the clear color */
      get color() {
        return this._frameGraphTask.color;
      }
      set color(value) {
        this._frameGraphTask.color = value;
      }
      /** Gets or sets a boolean indicating whether the color part of the texture should be cleared. */
      get clearColor() {
        return !!this._frameGraphTask.clearColor;
      }
      set clearColor(value) {
        this._frameGraphTask.clearColor = value;
      }
      /** Gets or sets a boolean indicating whether the color should be converted to linear space. */
      get convertColorToLinearSpace() {
        return !!this._frameGraphTask.convertColorToLinearSpace;
      }
      set convertColorToLinearSpace(value) {
        this._frameGraphTask.convertColorToLinearSpace = value;
      }
      /** Gets or sets a boolean indicating whether the depth part of the texture should be cleared. */
      get clearDepth() {
        return !!this._frameGraphTask.clearDepth;
      }
      set clearDepth(value) {
        this._frameGraphTask.clearDepth = value;
      }
      /** Gets or sets a boolean indicating whether the stencil part of the texture should be cleared. */
      get clearStencil() {
        return !!this._frameGraphTask.clearStencil;
      }
      set clearStencil(value) {
        this._frameGraphTask.clearStencil = value;
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "NodeRenderGraphClearBlock";
      }
      /**
       * Gets the target input component
       */
      get target() {
        return this._inputs[0];
      }
      /**
       * Gets the depth texture input component
       */
      get depth() {
        return this._inputs[1];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Gets the output depth component
       */
      get outputDepth() {
        return this._outputs[1];
      }
      _buildBlock(state) {
        super._buildBlock(state);
        this.output.value = this._frameGraphTask.outputTexture;
        this.outputDepth.value = this._frameGraphTask.outputDepthTexture;
        this._frameGraphTask.targetTexture = this._getConnectedTextures(this.target.connectedPoint);
        this._frameGraphTask.depthTexture = this.depth.connectedPoint?.value;
      }
      _dumpPropertiesCode() {
        const codes = [];
        codes.push(`${this._codeVariableName}.color = new BABYLON.Color4(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.color.a});`);
        codes.push(`${this._codeVariableName}.clearColor = ${this.clearColor};`);
        codes.push(`${this._codeVariableName}.convertColorToLinearSpace = ${this.convertColorToLinearSpace};`);
        codes.push(`${this._codeVariableName}.clearDepth = ${this.clearDepth};`);
        codes.push(`${this._codeVariableName}.clearStencil = ${this.clearStencil};`);
        return super._dumpPropertiesCode() + codes.join("\n");
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.color = this.color.asArray();
        serializationObject.clearColor = this.clearColor;
        serializationObject.convertColorToLinearSpace = this.convertColorToLinearSpace;
        serializationObject.clearDepth = this.clearDepth;
        serializationObject.clearStencil = this.clearStencil;
        return serializationObject;
      }
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        this.color = Color4.FromArray(serializationObject.color);
        this.clearColor = serializationObject.clearColor;
        this.convertColorToLinearSpace = !!serializationObject.convertColorToLinearSpace;
        this.clearDepth = serializationObject.clearDepth;
        this.clearStencil = serializationObject.clearStencil;
      }
    };
    __decorate([
      editableInPropertyPage(
        "Color",
        7
        /* PropertyTypeForEdition.Color4 */
      )
    ], NodeRenderGraphClearBlock.prototype, "color", null);
    __decorate([
      editableInPropertyPage("Clear color", 0, void 0, { embedded: true })
    ], NodeRenderGraphClearBlock.prototype, "clearColor", null);
    __decorate([
      editableInPropertyPage(
        "Convert color to linear space",
        0
        /* PropertyTypeForEdition.Boolean */
      )
    ], NodeRenderGraphClearBlock.prototype, "convertColorToLinearSpace", null);
    __decorate([
      editableInPropertyPage("Clear depth", 0, void 0, { embedded: true })
    ], NodeRenderGraphClearBlock.prototype, "clearDepth", null);
    __decorate([
      editableInPropertyPage("Clear stencil", 0, void 0, { embedded: true })
    ], NodeRenderGraphClearBlock.prototype, "clearStencil", null);
    RegisterClass("BABYLON.NodeRenderGraphClearBlock", NodeRenderGraphClearBlock);
  }
});

// node_modules/@babylonjs/core/FrameGraph/Node/nodeRenderGraphConnectionPointCustomObject.js
var NodeRenderGraphConnectionPointCustomObject;
var init_nodeRenderGraphConnectionPointCustomObject = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Node/nodeRenderGraphConnectionPointCustomObject.js"() {
    init_nodeRenderGraphBlockConnectionPoint();
    NodeRenderGraphConnectionPointCustomObject = class _NodeRenderGraphConnectionPointCustomObject extends NodeRenderGraphConnectionPoint {
      /**
       * Creates a new connection point
       * @param name defines the connection point name
       * @param ownerBlock defines the block hosting this connection point
       * @param direction defines the direction of the connection point
       * @param _blockType
       * @param _blockName
       */
      constructor(name3, ownerBlock, direction, _blockType, _blockName) {
        super(name3, ownerBlock, direction);
        this._blockType = _blockType;
        this._blockName = _blockName;
        this.needDualDirectionValidation = true;
      }
      checkCompatibilityState(connectionPoint) {
        return connectionPoint instanceof _NodeRenderGraphConnectionPointCustomObject && connectionPoint._blockName === this._blockName ? 0 : 1;
      }
      createCustomInputBlock() {
        return [new this._blockType(this._blockName), this.name];
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/Node/Blocks/Rendering/baseObjectRendererBlock.js
var NodeRenderGraphBaseObjectRendererBlock;
var init_baseObjectRendererBlock = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Node/Blocks/Rendering/baseObjectRendererBlock.js"() {
    init_tslib_es6();
    init_nodeRenderGraphBlock();
    init_nodeRenderGraphTypes();
    init_nodeDecorator();
    init_nodeRenderGraphBlockConnectionPoint();
    init_nodeRenderGraphConnectionPointCustomObject();
    init_objectRendererTask();
    NodeRenderGraphBaseObjectRendererBlock = class _NodeRenderGraphBaseObjectRendererBlock extends NodeRenderGraphBlock {
      /**
       * Gets the frame graph task associated with this block
       */
      get task() {
        return this._frameGraphTask;
      }
      /**
       * Create a new NodeRenderGraphBaseObjectRendererBlock
       * @param name defines the block name
       * @param frameGraph defines the hosting frame graph
       * @param scene defines the hosting scene
       * @param doNotChangeAspectRatio True (default) to not change the aspect ratio of the scene in the RTT
       * @param enableClusteredLights True (default) to enable clustered lights
       */
      constructor(name3, frameGraph, scene, doNotChangeAspectRatio = true, enableClusteredLights = true) {
        super(name3, frameGraph, scene);
        this._additionalConstructionParameters = [doNotChangeAspectRatio, enableClusteredLights];
        this.registerInput("target", NodeRenderGraphBlockConnectionPointTypes.AutoDetect);
        this.registerInput("depth", NodeRenderGraphBlockConnectionPointTypes.AutoDetect, true);
        this.registerInput("camera", NodeRenderGraphBlockConnectionPointTypes.Camera);
        this.registerInput("objects", NodeRenderGraphBlockConnectionPointTypes.ObjectList);
        this._addDependenciesInput();
        this.registerInput("shadowGenerators", NodeRenderGraphBlockConnectionPointTypes.AutoDetect, true);
        this.registerOutput("output", NodeRenderGraphBlockConnectionPointTypes.BasedOnInput);
        this.registerOutput("outputDepth", NodeRenderGraphBlockConnectionPointTypes.BasedOnInput);
        this.registerOutput("objectRenderer", NodeRenderGraphBlockConnectionPointTypes.Object, new NodeRenderGraphConnectionPointCustomObject("objectRenderer", this, 1, _NodeRenderGraphBaseObjectRendererBlock, "NodeRenderGraphBaseObjectRendererBlock"));
        this.target.addExcludedConnectionPointFromAllowedTypes(NodeRenderGraphBlockConnectionPointTypes.TextureAllButBackBufferDepthStencil | NodeRenderGraphBlockConnectionPointTypes.ResourceContainer);
        this.depth.addExcludedConnectionPointFromAllowedTypes(NodeRenderGraphBlockConnectionPointTypes.TextureDepthStencilAttachment | NodeRenderGraphBlockConnectionPointTypes.TextureBackBufferDepthStencilAttachment);
        this.shadowGenerators.addExcludedConnectionPointFromAllowedTypes(NodeRenderGraphBlockConnectionPointTypes.ShadowGenerator | NodeRenderGraphBlockConnectionPointTypes.ResourceContainer);
        this.output._typeConnectionSource = this.target;
        this.outputDepth._typeConnectionSource = this.depth;
        this._createFrameGraphObject();
      }
      _createFrameGraphObject() {
        this._frameGraphTask?.dispose();
        this._frameGraphTask = new FrameGraphObjectRendererTask(this.name, this._frameGraph, this._scene, {
          doNotChangeAspectRatio: this._additionalConstructionParameters[0],
          enableClusteredLights: this._additionalConstructionParameters[1]
        });
      }
      _saveState(state) {
        state.disabled = this._frameGraphTask.disabled;
        state.isMainObjectRenderer = this.isMainObjectRenderer;
        state.depthTest = this.depthTest;
        state.depthWrite = this.depthWrite;
        state.disableShadows = this.disableShadows;
        state.renderInLinearSpace = this.renderInLinearSpace;
        state.renderMeshes = this.renderMeshes;
        state.renderDepthOnlyMeshes = this.renderDepthOnlyMeshes;
        state.renderOpaqueMeshes = this.renderOpaqueMeshes;
        state.renderAlphaTestMeshes = this.renderAlphaTestMeshes;
        state.renderTransparentMeshes = this.renderTransparentMeshes;
        state.useOITForTransparentMeshes = this.useOITForTransparentMeshes;
        state.renderParticles = this.renderParticles;
        state.renderSprites = this.renderSprites;
        state.forceLayerMaskCheck = this.forceLayerMaskCheck;
        state.enableBoundingBoxRendering = this.enableBoundingBoxRendering;
        state.enableOutlineRendering = this.enableOutlineRendering;
      }
      _restoreState(state) {
        this._frameGraphTask.disabled = state.disabled;
        this.isMainObjectRenderer = state.isMainObjectRenderer;
        this.depthTest = state.depthTest;
        this.depthWrite = state.depthWrite;
        this.disableShadows = state.disableShadows;
        this.renderInLinearSpace = state.renderInLinearSpace;
        this.renderMeshes = state.renderMeshes;
        this.renderDepthOnlyMeshes = state.renderDepthOnlyMeshes;
        this.renderOpaqueMeshes = state.renderOpaqueMeshes;
        this.renderAlphaTestMeshes = state.renderAlphaTestMeshes;
        this.renderTransparentMeshes = state.renderTransparentMeshes;
        this.useOITForTransparentMeshes = state.useOITForTransparentMeshes;
        this.renderParticles = state.renderParticles;
        this.renderSprites = state.renderSprites;
        this.forceLayerMaskCheck = state.forceLayerMaskCheck;
        this.enableBoundingBoxRendering = state.enableBoundingBoxRendering;
        this.enableOutlineRendering = state.enableOutlineRendering;
      }
      _createFrameGraphObjectWithState(doNotChangeAspectRatio, enableClusteredLights) {
        const state = {};
        this._saveState(state);
        this._additionalConstructionParameters = [doNotChangeAspectRatio, enableClusteredLights];
        this._createFrameGraphObject();
        this._restoreState(state);
      }
      /** Indicates that this object renderer is the main object renderer of the frame graph. */
      get isMainObjectRenderer() {
        return this._frameGraphTask.isMainObjectRenderer;
      }
      set isMainObjectRenderer(value) {
        this._frameGraphTask.isMainObjectRenderer = value;
      }
      /** Indicates if depth testing must be enabled or disabled */
      get depthTest() {
        return this._frameGraphTask.depthTest;
      }
      set depthTest(value) {
        this._frameGraphTask.depthTest = value;
      }
      /** Indicates if depth writing must be enabled or disabled */
      get depthWrite() {
        return this._frameGraphTask.depthWrite;
      }
      set depthWrite(value) {
        this._frameGraphTask.depthWrite = value;
      }
      /** Indicates if meshes should be rendered */
      get renderMeshes() {
        return this._frameGraphTask.renderMeshes;
      }
      set renderMeshes(value) {
        this._frameGraphTask.renderMeshes = value;
      }
      /** Indicates if depth-only meshes should be rendered */
      get renderDepthOnlyMeshes() {
        return this._frameGraphTask.renderDepthOnlyMeshes;
      }
      set renderDepthOnlyMeshes(value) {
        this._frameGraphTask.renderDepthOnlyMeshes = value;
      }
      /** Indicates if opaque meshes should be rendered */
      get renderOpaqueMeshes() {
        return this._frameGraphTask.renderOpaqueMeshes;
      }
      set renderOpaqueMeshes(value) {
        this._frameGraphTask.renderOpaqueMeshes = value;
      }
      /** Indicates if alpha tested meshes should be rendered */
      get renderAlphaTestMeshes() {
        return this._frameGraphTask.renderAlphaTestMeshes;
      }
      set renderAlphaTestMeshes(value) {
        this._frameGraphTask.renderAlphaTestMeshes = value;
      }
      /** Indicates if transparent meshes should be rendered */
      get renderTransparentMeshes() {
        return this._frameGraphTask.renderTransparentMeshes;
      }
      set renderTransparentMeshes(value) {
        this._frameGraphTask.renderTransparentMeshes = value;
      }
      /** Indicates if use of Order Independent Transparency (OIT) for transparent meshes should be enabled */
      get useOITForTransparentMeshes() {
        return this._frameGraphTask.useOITForTransparentMeshes;
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      set useOITForTransparentMeshes(value) {
        this._frameGraphTask.useOITForTransparentMeshes = value;
      }
      /** Defines the number of passes to use for Order Independent Transparency */
      get oitPassCount() {
        return this._frameGraphTask.oitPassCount;
      }
      set oitPassCount(value) {
        this._frameGraphTask.oitPassCount = value;
      }
      /** Indicates if particles should be rendered */
      get renderParticles() {
        return this._frameGraphTask.renderParticles;
      }
      set renderParticles(value) {
        this._frameGraphTask.renderParticles = value;
      }
      /** Indicates if sprites should be rendered */
      get renderSprites() {
        return this._frameGraphTask.renderSprites;
      }
      set renderSprites(value) {
        this._frameGraphTask.renderSprites = value;
      }
      /** Indicates if layer mask check must be forced */
      get forceLayerMaskCheck() {
        return this._frameGraphTask.forceLayerMaskCheck;
      }
      set forceLayerMaskCheck(value) {
        this._frameGraphTask.forceLayerMaskCheck = value;
      }
      /** Indicates if bounding boxes should be rendered */
      get enableBoundingBoxRendering() {
        return this._frameGraphTask.enableBoundingBoxRendering;
      }
      set enableBoundingBoxRendering(value) {
        this._frameGraphTask.enableBoundingBoxRendering = value;
      }
      /** Indicates if outlines/overlays should be rendered */
      get enableOutlineRendering() {
        return this._frameGraphTask.enableOutlineRendering;
      }
      set enableOutlineRendering(value) {
        this._frameGraphTask.enableOutlineRendering = value;
      }
      /** Indicates if shadows must be enabled or disabled */
      get disableShadows() {
        return this._frameGraphTask.disableShadows;
      }
      set disableShadows(value) {
        this._frameGraphTask.disableShadows = value;
      }
      /** If image processing should be disabled */
      get renderInLinearSpace() {
        return this._frameGraphTask.disableImageProcessing;
      }
      set renderInLinearSpace(value) {
        this._frameGraphTask.disableImageProcessing = value;
      }
      /** True (default) to not change the aspect ratio of the scene in the RTT */
      get doNotChangeAspectRatio() {
        return this._frameGraphTask.objectRenderer.options.doNotChangeAspectRatio;
      }
      set doNotChangeAspectRatio(value) {
        this._createFrameGraphObjectWithState(value, this.enableClusteredLights);
      }
      /** True (default) to enable clustered lights */
      get enableClusteredLights() {
        return this._frameGraphTask.objectRenderer.options.enableClusteredLights;
      }
      set enableClusteredLights(value) {
        this._createFrameGraphObjectWithState(this.doNotChangeAspectRatio, value);
      }
      /** If true, MSAA color textures will be resolved at the end of the render pass (default: true) */
      get resolveMSAAColors() {
        return this._frameGraphTask.resolveMSAAColors;
      }
      set resolveMSAAColors(value) {
        this._frameGraphTask.resolveMSAAColors = value;
      }
      /** If true, MSAA depth texture will be resolved at the end of the render pass (default: false) */
      get resolveMSAADepth() {
        return this._frameGraphTask.resolveMSAADepth;
      }
      set resolveMSAADepth(value) {
        this._frameGraphTask.resolveMSAADepth = value;
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "NodeRenderGraphBaseObjectRendererBlock";
      }
      /**
       * Gets the target texture input component
       */
      get target() {
        return this._inputs[0];
      }
      /**
       * Gets the depth texture input component
       */
      get depth() {
        return this._inputs[1];
      }
      /**
       * Gets the camera input component
       */
      get camera() {
        return this._inputs[2];
      }
      /**
       * Gets the objects input component
       */
      get objects() {
        return this._inputs[3];
      }
      /**
       * Gets the dependencies input component
       */
      get dependencies() {
        return this._inputs[4];
      }
      /**
       * Gets the shadowGenerators input component
       */
      get shadowGenerators() {
        return this._inputs[5];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      /**
       * Gets the output depth component
       */
      get outputDepth() {
        return this._outputs[1];
      }
      /**
       * Gets the objectRenderer component
       */
      get objectRenderer() {
        return this._outputs[2];
      }
      _buildBlock(state) {
        super._buildBlock(state);
        this.output.value = this._frameGraphTask.outputTexture;
        this.outputDepth.value = this._frameGraphTask.outputDepthTexture;
        this.objectRenderer.value = this._frameGraphTask;
        this._frameGraphTask.targetTexture = this._getConnectedTextures(this.target.connectedPoint);
        this._frameGraphTask.depthTexture = this.depth.connectedPoint?.value;
        this._frameGraphTask.camera = this.camera.connectedPoint?.value;
        this._frameGraphTask.objectList = this.objects.connectedPoint?.value;
        this._frameGraphTask.shadowGenerators = [];
        const shadowGeneratorsConnectedPoint = this.shadowGenerators.connectedPoint;
        if (shadowGeneratorsConnectedPoint) {
          if (shadowGeneratorsConnectedPoint.type === NodeRenderGraphBlockConnectionPointTypes.ResourceContainer) {
            const container = shadowGeneratorsConnectedPoint.ownerBlock;
            for (const input of container.inputs) {
              if (input.connectedPoint && input.connectedPoint.value !== void 0 && NodeRenderGraphConnectionPoint.IsShadowGenerator(input.connectedPoint.value)) {
                this._frameGraphTask.shadowGenerators.push(input.connectedPoint.value);
              }
            }
          } else if (NodeRenderGraphConnectionPoint.IsShadowGenerator(shadowGeneratorsConnectedPoint.value)) {
            this._frameGraphTask.shadowGenerators[0] = shadowGeneratorsConnectedPoint.value;
          }
        }
      }
      _dumpPropertiesCode() {
        const codes = [];
        codes.push(`${this._codeVariableName}.isMainObjectRenderer = ${this.isMainObjectRenderer};`);
        codes.push(`${this._codeVariableName}.depthTest = ${this.depthTest};`);
        codes.push(`${this._codeVariableName}.depthWrite = ${this.depthWrite};`);
        codes.push(`${this._codeVariableName}.renderMeshes = ${this.renderMeshes};`);
        codes.push(`${this._codeVariableName}.renderDepthOnlyMeshes = ${this.renderDepthOnlyMeshes};`);
        codes.push(`${this._codeVariableName}.renderOpaqueMeshes = ${this.renderOpaqueMeshes};`);
        codes.push(`${this._codeVariableName}.renderAlphaTestMeshes = ${this.renderAlphaTestMeshes};`);
        codes.push(`${this._codeVariableName}.renderTransparentMeshes = ${this.renderTransparentMeshes};`);
        codes.push(`${this._codeVariableName}.useOITForTransparentMeshes = ${this.useOITForTransparentMeshes};`);
        codes.push(`${this._codeVariableName}.oitPassCount = ${this.oitPassCount};`);
        codes.push(`${this._codeVariableName}.renderParticles = ${this.renderParticles};`);
        codes.push(`${this._codeVariableName}.renderSprites = ${this.renderSprites};`);
        codes.push(`${this._codeVariableName}.forceLayerMaskCheck = ${this.forceLayerMaskCheck};`);
        codes.push(`${this._codeVariableName}.enableBoundingBoxRendering = ${this.enableBoundingBoxRendering};`);
        codes.push(`${this._codeVariableName}.enableOutlineRendering = ${this.enableOutlineRendering};`);
        codes.push(`${this._codeVariableName}.disableShadows = ${this.disableShadows};`);
        codes.push(`${this._codeVariableName}.renderInLinearSpace = ${this.renderInLinearSpace};`);
        codes.push(`${this._codeVariableName}.resolveMSAAColors = ${this.resolveMSAAColors};`);
        codes.push(`${this._codeVariableName}.resolveMSAADepth = ${this.resolveMSAADepth};`);
        return super._dumpPropertiesCode() + codes.join("\n");
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.isMainObjectRenderer = this.isMainObjectRenderer;
        serializationObject.depthTest = this.depthTest;
        serializationObject.depthWrite = this.depthWrite;
        serializationObject.renderMeshes = this.renderMeshes;
        serializationObject.renderDepthOnlyMeshes = this.renderDepthOnlyMeshes;
        serializationObject.renderOpaqueMeshes = this.renderOpaqueMeshes;
        serializationObject.renderAlphaTestMeshes = this.renderAlphaTestMeshes;
        serializationObject.renderTransparentMeshes = this.renderTransparentMeshes;
        serializationObject.useOITForTransparentMeshes = this.useOITForTransparentMeshes;
        serializationObject.oitPassCount = this.oitPassCount;
        serializationObject.renderParticles = this.renderParticles;
        serializationObject.renderSprites = this.renderSprites;
        serializationObject.forceLayerMaskCheck = this.forceLayerMaskCheck;
        serializationObject.enableBoundingBoxRendering = this.enableBoundingBoxRendering;
        serializationObject.enableOutlineRendering = this.enableOutlineRendering;
        serializationObject.disableShadows = this.disableShadows;
        serializationObject.renderInLinearSpace = this.renderInLinearSpace;
        serializationObject.resolveMSAAColors = this.resolveMSAAColors;
        serializationObject.resolveMSAADepth = this.resolveMSAADepth;
        return serializationObject;
      }
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
        this.isMainObjectRenderer = !!serializationObject.isMainObjectRenderer;
        this.depthTest = serializationObject.depthTest;
        this.depthWrite = serializationObject.depthWrite;
        this.renderMeshes = serializationObject.renderMeshes ?? true;
        this.renderDepthOnlyMeshes = serializationObject.renderDepthOnlyMeshes ?? true;
        this.renderOpaqueMeshes = serializationObject.renderOpaqueMeshes ?? true;
        this.renderAlphaTestMeshes = serializationObject.renderAlphaTestMeshes ?? true;
        this.renderTransparentMeshes = serializationObject.renderTransparentMeshes ?? true;
        this.useOITForTransparentMeshes = serializationObject.useOITForTransparentMeshes ?? false;
        this.oitPassCount = serializationObject.oitPassCount ?? 5;
        this.renderParticles = serializationObject.renderParticles ?? true;
        this.renderSprites = serializationObject.renderSprites ?? true;
        this.forceLayerMaskCheck = serializationObject.forceLayerMaskCheck ?? true;
        this.enableBoundingBoxRendering = serializationObject.enableBoundingBoxRendering ?? true;
        this.enableOutlineRendering = serializationObject.enableOutlineRendering ?? true;
        this.disableShadows = serializationObject.disableShadows;
        this.renderInLinearSpace = !!serializationObject.renderInLinearSpace;
        this.resolveMSAAColors = serializationObject.resolveMSAAColors ?? true;
        this.resolveMSAADepth = serializationObject.resolveMSAADepth ?? false;
      }
    };
    __decorate([
      editableInPropertyPage("Is main object renderer", 0, "GENERAL")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "isMainObjectRenderer", null);
    __decorate([
      editableInPropertyPage("Depth test", 0, "GENERAL")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "depthTest", null);
    __decorate([
      editableInPropertyPage("Depth write", 0, "GENERAL")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "depthWrite", null);
    __decorate([
      editableInPropertyPage("Render meshes", 0, "RENDERING")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "renderMeshes", null);
    __decorate([
      editableInPropertyPage("Render depth-only meshes", 0, "RENDERING")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "renderDepthOnlyMeshes", null);
    __decorate([
      editableInPropertyPage("Render opaque meshes", 0, "RENDERING")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "renderOpaqueMeshes", null);
    __decorate([
      editableInPropertyPage("Render alpha test meshes", 0, "RENDERING")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "renderAlphaTestMeshes", null);
    __decorate([
      editableInPropertyPage("Render transparent meshes", 0, "RENDERING")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "renderTransparentMeshes", null);
    __decorate([
      editableInPropertyPage("Use OIT for transparent meshes", 0, "RENDERING")
      // eslint-disable-next-line @typescript-eslint/naming-convention
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "useOITForTransparentMeshes", null);
    __decorate([
      editableInPropertyPage("Pass count", 2, "RENDERING", { min: 1, max: 20 })
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "oitPassCount", null);
    __decorate([
      editableInPropertyPage("Render particles", 0, "RENDERING")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "renderParticles", null);
    __decorate([
      editableInPropertyPage("Render sprites", 0, "RENDERING")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "renderSprites", null);
    __decorate([
      editableInPropertyPage("Force layer mask check", 0, "GENERAL")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "forceLayerMaskCheck", null);
    __decorate([
      editableInPropertyPage("Render bounding boxes", 0, "RENDERING")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "enableBoundingBoxRendering", null);
    __decorate([
      editableInPropertyPage("Render outlines/overlays", 0, "RENDERING")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "enableOutlineRendering", null);
    __decorate([
      editableInPropertyPage("Disable shadows", 0, "GENERAL")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "disableShadows", null);
    __decorate([
      editableInPropertyPage("Disable image processing", 0, "GENERAL")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "renderInLinearSpace", null);
    __decorate([
      editableInPropertyPage("Do not change aspect ratio", 0, "GENERAL")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "doNotChangeAspectRatio", null);
    __decorate([
      editableInPropertyPage("Enable clustered lights", 0, "GENERAL")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "enableClusteredLights", null);
    __decorate([
      editableInPropertyPage("Resolve MSAA colors", 0, "GENERAL")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "resolveMSAAColors", null);
    __decorate([
      editableInPropertyPage("Resolve MSAA depth", 0, "GENERAL")
    ], NodeRenderGraphBaseObjectRendererBlock.prototype, "resolveMSAADepth", null);
  }
});

// node_modules/@babylonjs/core/FrameGraph/Node/Blocks/Rendering/objectRendererBlock.js
var NodeRenderGraphObjectRendererBlock;
var init_objectRendererBlock = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Node/Blocks/Rendering/objectRendererBlock.js"() {
    init_typeStore();
    init_baseObjectRendererBlock();
    NodeRenderGraphObjectRendererBlock = class extends NodeRenderGraphBaseObjectRendererBlock {
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "NodeRenderGraphObjectRendererBlock";
      }
    };
    RegisterClass("BABYLON.NodeRenderGraphObjectRendererBlock", NodeRenderGraphObjectRendererBlock);
  }
});

// node_modules/@babylonjs/core/FrameGraph/Node/nodeRenderGraphBuildState.js
var NodeRenderGraphBuildState;
var init_nodeRenderGraphBuildState = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Node/nodeRenderGraphBuildState.js"() {
    init_logger();
    NodeRenderGraphBuildState = class {
      constructor() {
        this.verbose = false;
        this._notConnectedNonOptionalInputs = [];
      }
      /**
       * Emits console errors and exceptions if there is a failing check
       * @param errorObservable defines an Observable to send the error message
       * @returns true if all checks pass
       */
      emitErrors(errorObservable = null) {
        let errorMessage = "";
        for (const notConnectedInput of this._notConnectedNonOptionalInputs) {
          errorMessage += `input "${notConnectedInput.name}" from block "${notConnectedInput.ownerBlock.name}"[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.
`;
        }
        if (errorMessage) {
          if (errorObservable) {
            errorObservable.notifyObservers(errorMessage);
          }
          Logger.Error("Build of node render graph failed:\n" + errorMessage);
          return false;
        }
        return true;
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/Tasks/Misc/cullObjectsTask.js
var FrameGraphCullObjectsTask;
var init_cullObjectsTask = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Tasks/Misc/cullObjectsTask.js"() {
    init_frameGraphTask();
    FrameGraphCullObjectsTask = class extends FrameGraphTask {
      /**
       * Creates a new cull objects task.
       * @param name The name of the task.
       * @param frameGraph The frame graph the task belongs to.
       * @param scene The scene to cull objects from.
       */
      constructor(name3, frameGraph, scene) {
        super(name3, frameGraph);
        this._scene = scene;
        this.outputObjectList = {
          meshes: null,
          particleSystems: null
        };
      }
      getClassName() {
        return "FrameGraphCullObjectsTask";
      }
      record() {
        if (this.objectList === void 0 || this.camera === void 0) {
          throw new Error(`FrameGraphCullObjectsTask ${this.name}: objectList and camera are required`);
        }
        this.outputObjectList.meshes = this.objectList.meshes;
        this.outputObjectList.particleSystems = this.objectList.particleSystems;
        const pass = this._frameGraph.addObjectListPass(this.name);
        pass.setObjectList(this.outputObjectList);
        pass.setExecuteFunc((_context) => {
          this.outputObjectList.particleSystems = this.objectList.particleSystems;
          if (this._scene._activeMeshesFrozen) {
            return;
          }
          this.outputObjectList.meshes = [];
          this.camera._updateFrustumPlanes();
          const frustumPlanes = this.camera._frustumPlanes;
          const meshes = this.objectList.meshes || this._scene.meshes;
          for (let i = 0; i < meshes.length; i++) {
            const mesh = meshes[i];
            if (mesh.isBlocked || !mesh.isReady() || !mesh.isEnabled() || mesh.scaling.hasAZeroComponent) {
              continue;
            }
            if (mesh.isVisible && mesh.visibility > 0 && (mesh.layerMask & this.camera.layerMask) !== 0 && (this._scene.skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(frustumPlanes))) {
              this.outputObjectList.meshes.push(mesh);
            }
          }
        });
        const passDisabled = this._frameGraph.addObjectListPass(this.name + "_disabled", true);
        passDisabled.setObjectList(this.outputObjectList);
        passDisabled.setExecuteFunc((_context) => {
          this.outputObjectList.meshes = this.objectList.meshes;
          this.outputObjectList.particleSystems = this.objectList.particleSystems;
        });
      }
    };
  }
});

// node_modules/@babylonjs/core/FrameGraph/Node/Blocks/cullObjectsBlock.js
var NodeRenderGraphCullObjectsBlock;
var init_cullObjectsBlock = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Node/Blocks/cullObjectsBlock.js"() {
    init_nodeRenderGraphBlock();
    init_typeStore();
    init_nodeRenderGraphTypes();
    init_cullObjectsTask();
    NodeRenderGraphCullObjectsBlock = class extends NodeRenderGraphBlock {
      /**
       * Gets the frame graph task associated with this block
       */
      get task() {
        return this._frameGraphTask;
      }
      /**
       * Create a new NodeRenderGraphCullObjectsBlock
       * @param name defines the block name
       * @param frameGraph defines the hosting frame graph
       * @param scene defines the hosting scene
       */
      constructor(name3, frameGraph, scene) {
        super(name3, frameGraph, scene);
        this.registerInput("camera", NodeRenderGraphBlockConnectionPointTypes.Camera);
        this.registerInput("objects", NodeRenderGraphBlockConnectionPointTypes.ObjectList);
        this._addDependenciesInput();
        this.registerOutput("output", NodeRenderGraphBlockConnectionPointTypes.ObjectList);
        this._frameGraphTask = new FrameGraphCullObjectsTask(this.name, frameGraph, scene);
      }
      /**
       * Gets the current class name
       * @returns the class name
       */
      getClassName() {
        return "NodeRenderGraphCullObjectsBlock";
      }
      /**
       * Gets the camera input component
       */
      get camera() {
        return this._inputs[0];
      }
      /**
       * Gets the objects input component
       */
      get objects() {
        return this._inputs[1];
      }
      /**
       * Gets the output component
       */
      get output() {
        return this._outputs[0];
      }
      _buildBlock(state) {
        super._buildBlock(state);
        this.output.value = this._frameGraphTask.outputObjectList;
        this._frameGraphTask.camera = this.camera.connectedPoint?.value;
        this._frameGraphTask.objectList = this.objects.connectedPoint?.value;
      }
      _dumpPropertiesCode() {
        const codes = [];
        return super._dumpPropertiesCode() + codes.join("\n");
      }
      serialize() {
        const serializationObject = super.serialize();
        return serializationObject;
      }
      _deserialize(serializationObject) {
        super._deserialize(serializationObject);
      }
    };
    RegisterClass("BABYLON.NodeRenderGraphCullObjectsBlock", NodeRenderGraphCullObjectsBlock);
  }
});

// node_modules/@babylonjs/core/FrameGraph/Node/nodeRenderGraph.js
var NodeRenderGraph;
var init_nodeRenderGraph = __esm({
  "node_modules/@babylonjs/core/FrameGraph/Node/nodeRenderGraph.js"() {
    init_tslib_es6();
    init_observable();
    init_outputBlock();
    init_frameGraph();
    init_typeStore();
    init_decorators();
    init_decorators_serialization();
    init_webRequest();
    init_inputBlock();
    init_tools();
    init_engine();
    init_nodeRenderGraphTypes();
    init_clearBlock();
    init_baseObjectRendererBlock();
    init_objectRendererBlock();
    init_nodeRenderGraphBuildState();
    init_cullObjectsBlock();
    NodeRenderGraph = class _NodeRenderGraph {
      /** @returns the inspector from bundle or global */
      _getGlobalNodeRenderGraphEditor() {
        if (typeof NODERENDERGRAPHEDITOR !== "undefined") {
          return NODERENDERGRAPHEDITOR;
        }
        if (typeof BABYLON !== "undefined" && typeof BABYLON.NodeRenderGraphEditor !== "undefined") {
          return BABYLON;
        }
        return void 0;
      }
      /**
       * Observable raised after the node render graph is built
       * Note that this is the same observable as the one in the underlying FrameGraph!
       */
      get onBuildObservable() {
        return this._frameGraph.onBuildObservable;
      }
      /**
       * Gets the frame graph used by this node render graph
       */
      get frameGraph() {
        return this._frameGraph;
      }
      /**
       * Gets the scene used by this node render graph
       * @returns the scene used by this node render graph
       */
      getScene() {
        return this._scene;
      }
      /**
       * Gets the options used to create this node render graph
       */
      get options() {
        return this._options;
      }
      /**
       * Creates a new node render graph
       * @param name defines the name of the node render graph
       * @param scene defines the scene to use to execute the graph
       * @param options defines the options to use when creating the graph
       */
      constructor(name3, scene, options) {
        this._buildId = _NodeRenderGraph._BuildIdGenerator++;
        this.BJSNODERENDERGRAPHEDITOR = this._getGlobalNodeRenderGraphEditor();
        this.editorData = null;
        this.attachedBlocks = [];
        this.onBeforeBuildObservable = new Observable();
        this.onBuildErrorObservable = new Observable();
        this.outputBlock = null;
        this._resizeObserver = null;
        this.name = name3;
        this._scene = scene;
        this._engine = scene.getEngine();
        options = {
          debugTextures: false,
          autoConfigure: false,
          verbose: false,
          rebuildGraphOnEngineResize: true,
          autoFillExternalInputs: true,
          ...options
        };
        this._options = options;
        this._frameGraph = new FrameGraph(this._scene, options.debugTextures, this);
        this._frameGraph.name = name3;
        if (options.rebuildGraphOnEngineResize) {
          this._resizeObserver = this._engine.onResizeObservable.add(async () => {
            await this.buildAsync(false, true, false);
          });
        }
      }
      /**
       * Gets the current class name ("NodeRenderGraph")
       * @returns the class name
       */
      getClassName() {
        return "NodeRenderGraph";
      }
      /**
       * Gets a block by its name
       * @param name defines the name of the block to retrieve
       * @returns the required block or null if not found
       */
      getBlockByName(name3) {
        let result = null;
        for (const block of this.attachedBlocks) {
          if (block.name === name3) {
            if (!result) {
              result = block;
            } else {
              Tools.Warn("More than one block was found with the name `" + name3 + "`");
              return result;
            }
          }
        }
        return result;
      }
      /**
       * Get a block using a predicate
       * @param predicate defines the predicate used to find the good candidate
       * @returns the required block or null if not found
       */
      getBlockByPredicate(predicate) {
        for (const block of this.attachedBlocks) {
          if (predicate(block)) {
            return block;
          }
        }
        return null;
      }
      /**
       * Get all blocks that match a predicate
       * @param predicate defines the predicate used to find the good candidate(s)
       * @returns the list of blocks found
       */
      getBlocksByPredicate(predicate) {
        const blocks = [];
        for (const block of this.attachedBlocks) {
          if (predicate(block)) {
            blocks.push(block);
          }
        }
        return blocks;
      }
      /**
       * Gets the list of input blocks attached to this material
       * @returns an array of InputBlocks
       */
      getInputBlocks() {
        const blocks = [];
        for (const block of this.attachedBlocks) {
          if (block.isInput) {
            blocks.push(block);
          }
        }
        return blocks;
      }
      /**
       * Launch the node render graph editor
       * @param config Define the configuration of the editor
       * @returns a promise fulfilled when the node editor is visible
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      async edit(config) {
        return await new Promise((resolve) => {
          this.BJSNODERENDERGRAPHEDITOR = this.BJSNODERENDERGRAPHEDITOR || this._getGlobalNodeRenderGraphEditor();
          if (typeof this.BJSNODERENDERGRAPHEDITOR == "undefined") {
            const editorUrl = config && config.editorURL ? config.editorURL : _NodeRenderGraph.EditorURL;
            Tools.LoadBabylonScript(editorUrl, () => {
              this.BJSNODERENDERGRAPHEDITOR = this.BJSNODERENDERGRAPHEDITOR || this._getGlobalNodeRenderGraphEditor();
              this._createNodeEditor(config?.nodeRenderGraphEditorConfig);
              resolve();
            });
          } else {
            this._createNodeEditor(config?.nodeRenderGraphEditorConfig);
            resolve();
          }
        });
      }
      /**
       * Creates the node editor window.
       * @param additionalConfig Additional configuration for the FGE
       */
      _createNodeEditor(additionalConfig) {
        const nodeEditorConfig = {
          nodeRenderGraph: this,
          customBlockDescriptions: _NodeRenderGraph.CustomBlockDescriptions,
          ...additionalConfig
        };
        this.BJSNODERENDERGRAPHEDITOR.NodeRenderGraphEditor.Show(nodeEditorConfig);
      }
      /**
       * Build the final list of blocks that will be executed by the "execute" method.
       * It also builds the underlying frame graph unless specified otherwise.
       * @param dontBuildFrameGraph If the underlying frame graph should not be built (default: false)
       * @param waitForReadiness If the method should wait for the frame graph to be ready before resolving (default: true). Note that this parameter has no effect if "dontBuildFrameGraph" is true.
       * @param setAsSceneFrameGraph If the built frame graph must be set as the scene's frame graph (default: true)
       */
      async buildAsync(dontBuildFrameGraph = false, waitForReadiness = true, setAsSceneFrameGraph = true) {
        if (!this.outputBlock) {
          throw new Error("You must define the outputBlock property before building the node render graph");
        }
        if (setAsSceneFrameGraph) {
          this._scene.frameGraph = this._frameGraph;
        }
        this._initializeBlock(this.outputBlock);
        this._frameGraph.clear();
        const state = new NodeRenderGraphBuildState();
        state.buildId = this._buildId;
        state.verbose = this._options.verbose;
        if (this._options.autoFillExternalInputs) {
          this._autoFillExternalInputs();
        }
        this.onBeforeBuildObservable.notifyObservers(this._frameGraph);
        const objectRendererBlocks = this.getBlocksByPredicate((block) => block instanceof NodeRenderGraphBaseObjectRendererBlock);
        if (objectRendererBlocks.length > 0 && !objectRendererBlocks.find((block) => block.isMainObjectRenderer)) {
          objectRendererBlocks[0].isMainObjectRenderer = true;
        }
        try {
          this.outputBlock.build(state);
          if (!dontBuildFrameGraph) {
            await this._frameGraph.buildAsync(waitForReadiness);
          }
        } finally {
          this._buildId = _NodeRenderGraph._BuildIdGenerator++;
          state.emitErrors(this.onBuildErrorObservable);
        }
      }
      _autoFillExternalInputs() {
        const allInputs = this.getInputBlocks();
        const shadowLights = [];
        for (const light of this._scene.lights) {
          if (light.setShadowProjectionMatrix !== void 0) {
            shadowLights.push(light);
          }
        }
        let cameraIndex = 0;
        let lightIndex = 0;
        for (const input of allInputs) {
          if (!input.isExternal) {
            continue;
          }
          if (!input.isAnAncestorOfType("NodeRenderGraphOutputBlock")) {
            continue;
          }
          if ((input.type & NodeRenderGraphBlockConnectionPointTypes.TextureAllButBackBuffer) !== 0) {
          } else if (input.isCamera()) {
            const camera = this._scene.cameras[cameraIndex++] || this._scene.cameras[0];
            if (!this._scene.cameraToUseForPointers) {
              this._scene.cameraToUseForPointers = camera;
            }
            input.value = camera;
          } else if (input.isObjectList()) {
            input.value = { meshes: this._scene.meshes, particleSystems: this._scene.particleSystems };
          } else if (input.isShadowLight()) {
            if (lightIndex < shadowLights.length) {
              input.value = shadowLights[lightIndex++];
              lightIndex = lightIndex % shadowLights.length;
            }
          }
        }
      }
      /**
       * Returns a promise that resolves when the node render graph is ready to be executed
       * This method must be called after the graph has been built (NodeRenderGraph.build called)!
       * @param timeStep Time step in ms between retries (default is 16)
       * @param maxTimeout Maximum time in ms to wait for the graph to be ready (default is 10000)
       * @returns The promise that resolves when the graph is ready
       */
      // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
      async whenReadyAsync(timeStep = 16, maxTimeout = 1e4) {
        this._frameGraph.pausedExecution = true;
        await this._frameGraph.whenReadyAsync(timeStep, maxTimeout);
        this._frameGraph.pausedExecution = false;
      }
      /**
       * Execute the graph (the graph must have been built before!)
       */
      execute() {
        this._frameGraph.execute();
      }
      _initializeBlock(node) {
        node.initialize();
        if (this._options.autoConfigure) {
          node.autoConfigure();
        }
        if (this.attachedBlocks.indexOf(node) === -1) {
          this.attachedBlocks.push(node);
        }
        for (const input of node.inputs) {
          const connectedPoint = input.connectedPoint;
          if (connectedPoint) {
            const block = connectedPoint.ownerBlock;
            if (block !== node) {
              this._initializeBlock(block);
            }
          }
        }
      }
      /**
       * Clear the current graph
       */
      clear() {
        this.outputBlock = null;
        this.attachedBlocks.length = 0;
      }
      /**
       * Remove a block from the current graph
       * @param block defines the block to remove
       */
      removeBlock(block) {
        const attachedBlockIndex = this.attachedBlocks.indexOf(block);
        if (attachedBlockIndex > -1) {
          this.attachedBlocks.splice(attachedBlockIndex, 1);
        }
        if (block === this.outputBlock) {
          this.outputBlock = null;
        }
      }
      /**
       * Clear the current graph and load a new one from a serialization object
       * @param source defines the JSON representation of the graph
       * @param merge defines whether or not the source must be merged or replace the current content
       */
      parseSerializedObject(source, merge = false) {
        if (!merge) {
          this.clear();
        }
        const map = {};
        for (const parsedBlock of source.blocks) {
          const blockType = GetClass(parsedBlock.customType);
          if (blockType) {
            const additionalConstructionParameters = parsedBlock.additionalConstructionParameters;
            const block = additionalConstructionParameters ? new blockType("", this._frameGraph, this._scene, ...additionalConstructionParameters) : new blockType("", this._frameGraph, this._scene);
            block._deserialize(parsedBlock);
            map[parsedBlock.id] = block;
            this.attachedBlocks.push(block);
          }
        }
        for (const block of this.attachedBlocks) {
          if (block.isTeleportOut) {
            const teleportOut = block;
            const id = teleportOut._tempEntryPointUniqueId;
            if (id) {
              const source2 = map[id];
              if (source2) {
                source2.attachToEndpoint(teleportOut);
              }
            }
          }
        }
        for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {
          const parsedBlock = source.blocks[blockIndex];
          const block = map[parsedBlock.id];
          if (!block) {
            continue;
          }
          if (block.inputs.length && parsedBlock.inputs.some((i) => i.targetConnectionName) && !merge) {
            continue;
          }
          this._restoreConnections(block, source, map);
        }
        if (source.outputNodeId) {
          this.outputBlock = map[source.outputNodeId];
        }
        if (source.locations || source.editorData && source.editorData.locations) {
          const locations = source.locations || source.editorData.locations;
          for (const location of locations) {
            if (map[location.blockId]) {
              location.blockId = map[location.blockId].uniqueId;
            }
          }
          if (merge && this.editorData && this.editorData.locations) {
            locations.concat(this.editorData.locations);
          }
          if (source.locations) {
            this.editorData = {
              locations
            };
          } else {
            this.editorData = source.editorData;
            this.editorData.locations = locations;
          }
          const blockMap = {};
          for (const key in map) {
            blockMap[key] = map[key].uniqueId;
          }
          this.editorData.map = blockMap;
        }
        this.comment = source.comment;
      }
      _restoreConnections(block, source, map) {
        for (const outputPoint of block.outputs) {
          for (const candidate of source.blocks) {
            const target = map[candidate.id];
            if (!target) {
              continue;
            }
            for (const input of candidate.inputs) {
              if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {
                const inputPoint = target.getInputByName(input.inputName);
                if (!inputPoint || inputPoint.isConnected) {
                  continue;
                }
                outputPoint.connectTo(inputPoint, true);
                this._restoreConnections(target, source, map);
                continue;
              }
            }
          }
        }
      }
      /**
       * Generate a string containing the code declaration required to create an equivalent of this node render graph
       * @returns a string
       */
      generateCode() {
        let alreadyDumped = [];
        const blocks = [];
        const uniqueNames = ["const", "var", "let"];
        if (this.outputBlock) {
          this._gatherBlocks(this.outputBlock, blocks);
        }
        const options = JSON.stringify(this._options);
        let codeString = `let nodeRenderGraph = new BABYLON.NodeRenderGraph("${this.name || "render graph"}", scene, ${options});
`;
        for (const node of blocks) {
          if (node.isInput && alreadyDumped.indexOf(node) === -1) {
            codeString += node._dumpCode(uniqueNames, alreadyDumped) + "\n";
          }
        }
        if (this.outputBlock) {
          alreadyDumped = [];
          codeString += "// Connections\n";
          codeString += this.outputBlock._dumpCodeForOutputConnections(alreadyDumped);
          codeString += "// Output nodes\n";
          codeString += `nodeRenderGraph.outputBlock = ${this.outputBlock._codeVariableName};
`;
          codeString += `nodeRenderGraph.build();
`;
        }
        return codeString;
      }
      _gatherBlocks(rootNode, list) {
        if (list.indexOf(rootNode) !== -1) {
          return;
        }
        list.push(rootNode);
        for (const input of rootNode.inputs) {
          const connectedPoint = input.connectedPoint;
          if (connectedPoint) {
            const block = connectedPoint.ownerBlock;
            if (block !== rootNode) {
              this._gatherBlocks(block, list);
            }
          }
        }
        if (rootNode.isTeleportOut) {
          const block = rootNode;
          if (block.entryPoint) {
            this._gatherBlocks(block.entryPoint, list);
          }
        }
      }
      /**
       * Clear the current graph and set it to a default state
       */
      setToDefault() {
        this.clear();
        this.editorData = null;
        const colorTexture = new NodeRenderGraphInputBlock("Color Texture", this._frameGraph, this._scene, NodeRenderGraphBlockConnectionPointTypes.Texture);
        colorTexture.creationOptions.options.samples = 4;
        const depthTexture = new NodeRenderGraphInputBlock("Depth Texture", this._frameGraph, this._scene, NodeRenderGraphBlockConnectionPointTypes.TextureDepthStencilAttachment);
        depthTexture.creationOptions.options.samples = 4;
        const clear = new NodeRenderGraphClearBlock("Clear", this._frameGraph, this._scene);
        clear.clearDepth = true;
        clear.clearStencil = true;
        colorTexture.output.connectTo(clear.target);
        depthTexture.output.connectTo(clear.depth);
        const camera = new NodeRenderGraphInputBlock("Camera", this._frameGraph, this._scene, NodeRenderGraphBlockConnectionPointTypes.Camera);
        const objectList = new NodeRenderGraphInputBlock("Object List", this._frameGraph, this._scene, NodeRenderGraphBlockConnectionPointTypes.ObjectList);
        const cull = new NodeRenderGraphCullObjectsBlock("Cull", this._frameGraph, this._scene);
        camera.output.connectTo(cull.camera);
        objectList.output.connectTo(cull.objects);
        const mainRendering = new NodeRenderGraphObjectRendererBlock("Main Rendering", this._frameGraph, this._scene);
        camera.output.connectTo(mainRendering.camera);
        cull.output.connectTo(mainRendering.objects);
        clear.output.connectTo(mainRendering.target);
        clear.outputDepth.connectTo(mainRendering.depth);
        const output = new NodeRenderGraphOutputBlock("Output", this._frameGraph, this._scene);
        mainRendering.output.connectTo(output.texture);
        this.outputBlock = output;
      }
      /**
       * Makes a duplicate of the current node render graph.
       * Note that you should call buildAsync() on the returned graph to make it usable.
       * @param name defines the name to use for the new node render graph
       * @returns the new node render graph
       */
      clone(name3) {
        const serializationObject = this.serialize();
        const clone = SerializationHelper.Clone(() => new _NodeRenderGraph(name3, this._scene), this);
        clone.name = name3;
        clone.parseSerializedObject(serializationObject);
        clone._buildId = this._buildId;
        return clone;
      }
      /**
       * Serializes this node render graph in a JSON representation
       * @param selectedBlocks defines the list of blocks to save (if null the whole node render graph will be saved)
       * @returns the serialized node render graph object
       */
      serialize(selectedBlocks) {
        const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);
        serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData));
        let blocks = [];
        if (selectedBlocks) {
          blocks = selectedBlocks;
        } else {
          serializationObject.customType = "BABYLON.NodeRenderGraph";
          if (this.outputBlock) {
            serializationObject.outputNodeId = this.outputBlock.uniqueId;
          }
        }
        serializationObject.blocks = [];
        for (const block of blocks) {
          serializationObject.blocks.push(block.serialize());
        }
        if (!selectedBlocks) {
          for (const block of this.attachedBlocks) {
            if (blocks.indexOf(block) !== -1) {
              continue;
            }
            serializationObject.blocks.push(block.serialize());
          }
        }
        return serializationObject;
      }
      /**
       * Disposes the resources
       */
      dispose() {
        for (const block of this.attachedBlocks) {
          block.dispose();
        }
        this._frameGraph.dispose();
        this._frameGraph = void 0;
        this._engine.onResizeObservable.remove(this._resizeObserver);
        this._resizeObserver = null;
        this.attachedBlocks.length = 0;
        this.onBuildErrorObservable.clear();
      }
      /**
       * Creates a new node render graph set to default basic configuration
       * @param name defines the name of the node render graph
       * @param scene defines the scene to use
       * @param nodeRenderGraphOptions defines options to use when creating the node render graph
       * @returns a new NodeRenderGraph
       */
      static async CreateDefaultAsync(name3, scene, nodeRenderGraphOptions) {
        const renderGraph = new _NodeRenderGraph(name3, scene, nodeRenderGraphOptions);
        renderGraph.setToDefault();
        await renderGraph.buildAsync(false, true, false);
        return renderGraph;
      }
      /**
       * Creates a node render graph from parsed graph data
       * @param source defines the JSON representation of the node render graph
       * @param scene defines the scene to use
       * @param nodeRenderGraphOptions defines options to use when creating the node render
       * @param skipBuild defines whether to skip building the node render graph (default is true)
       * @returns a new node render graph
       */
      static Parse(source, scene, nodeRenderGraphOptions, skipBuild = true) {
        const renderGraph = SerializationHelper.Parse(() => new _NodeRenderGraph(source.name, scene, nodeRenderGraphOptions), source, null);
        renderGraph.parseSerializedObject(source);
        if (!skipBuild) {
          void renderGraph.buildAsync();
        }
        return renderGraph;
      }
      /**
       * Creates a node render graph from a snippet saved by the node render graph editor
       * @param snippetId defines the snippet to load
       * @param scene defines the scene to use
       * @param nodeRenderGraphOptions defines options to use when creating the node render graph
       * @param nodeRenderGraph defines a node render graph to update (instead of creating a new one)
       * @param skipBuild defines whether to skip building the node render graph (default is true)
       * @returns a promise that will resolve to the new node render graph
       */
      // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
      static ParseFromSnippetAsync(snippetId, scene, nodeRenderGraphOptions, nodeRenderGraph, skipBuild = true) {
        if (snippetId === "_BLANK") {
          return _NodeRenderGraph.CreateDefaultAsync("blank", scene, nodeRenderGraphOptions);
        }
        return new Promise((resolve, reject) => {
          const request = new WebRequest();
          request.addEventListener("readystatechange", async () => {
            if (request.readyState == 4) {
              if (request.status == 200) {
                const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
                const serializationObject = JSON.parse(snippet.nodeRenderGraph);
                if (!nodeRenderGraph) {
                  nodeRenderGraph = SerializationHelper.Parse(() => new _NodeRenderGraph(snippetId, scene, nodeRenderGraphOptions), serializationObject, null);
                }
                nodeRenderGraph.parseSerializedObject(serializationObject);
                nodeRenderGraph.snippetId = snippetId;
                try {
                  if (!skipBuild) {
                    await nodeRenderGraph.buildAsync();
                  }
                  resolve(nodeRenderGraph);
                } catch (err) {
                  reject(err);
                }
              } else {
                reject("Unable to load the snippet " + snippetId);
              }
            }
          });
          request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
          request.send();
        });
      }
    };
    NodeRenderGraph._BuildIdGenerator = 0;
    NodeRenderGraph.EditorURL = `${Tools._DefaultCdnUrl}/v${Engine.Version}/NodeRenderGraph/babylon.nodeRenderGraph.js`;
    NodeRenderGraph.SnippetUrl = `https://snippet.babylonjs.com`;
    NodeRenderGraph.CustomBlockDescriptions = [];
    __decorate([
      serialize()
    ], NodeRenderGraph.prototype, "name", void 0);
    __decorate([
      serialize("comment")
    ], NodeRenderGraph.prototype, "comment", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrMaterial.js
var PBRMaterial;
var init_pbrMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrMaterial.js"() {
    init_tslib_es6();
    init_decorators();
    init_brdfTextureTools();
    init_math_color();
    init_pbrBaseMaterial();
    init_typeStore();
    init_material();
    init_decorators_serialization();
    PBRMaterial = class _PBRMaterial extends PBRBaseMaterial {
      /**
       * Stores the refracted light information in a texture.
       */
      get refractionTexture() {
        return this.subSurface.refractionTexture;
      }
      set refractionTexture(value) {
        this.subSurface.refractionTexture = value;
        if (value) {
          this.subSurface.isRefractionEnabled = true;
        } else if (!this.subSurface.linkRefractionWithTransparency) {
          this.subSurface.isRefractionEnabled = false;
        }
      }
      /**
       * Index of refraction of the material base layer.
       * https://en.wikipedia.org/wiki/List_of_refractive_indices
       *
       * This does not only impact refraction but also the Base F0 of Dielectric Materials.
       *
       * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))
       */
      get indexOfRefraction() {
        return this.subSurface.indexOfRefraction;
      }
      set indexOfRefraction(value) {
        this.subSurface.indexOfRefraction = value;
      }
      /**
       * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.
       */
      get invertRefractionY() {
        return this.subSurface.invertRefractionY;
      }
      set invertRefractionY(value) {
        this.subSurface.invertRefractionY = value;
      }
      /**
       * This parameters will make the material used its opacity to control how much it is refracting against not.
       * Materials half opaque for instance using refraction could benefit from this control.
       */
      get linkRefractionWithTransparency() {
        return this.subSurface.linkRefractionWithTransparency;
      }
      set linkRefractionWithTransparency(value) {
        this.subSurface.linkRefractionWithTransparency = value;
        if (value) {
          this.subSurface.isRefractionEnabled = true;
        }
      }
      /**
       * BJS is using an hardcoded light falloff based on a manually sets up range.
       * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.
       * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
       */
      get usePhysicalLightFalloff() {
        return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
      }
      /**
       * BJS is using an hardcoded light falloff based on a manually sets up range.
       * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.
       * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
       */
      set usePhysicalLightFalloff(value) {
        if (value !== this.usePhysicalLightFalloff) {
          this._markAllSubMeshesAsTexturesDirty();
          if (value) {
            this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
          } else {
            this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;
          }
        }
      }
      /**
       * In order to support the falloff compatibility with gltf, a special mode has been added
       * to reproduce the gltf light falloff.
       */
      get useGLTFLightFalloff() {
        return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF;
      }
      /**
       * In order to support the falloff compatibility with gltf, a special mode has been added
       * to reproduce the gltf light falloff.
       */
      set useGLTFLightFalloff(value) {
        if (value !== this.useGLTFLightFalloff) {
          this._markAllSubMeshesAsTexturesDirty();
          if (value) {
            this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_GLTF;
          } else {
            this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;
          }
        }
      }
      /**
       * Instantiates a new PBRMaterial instance.
       *
       * @param name The material name
       * @param scene The scene the material will be use in.
       * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
       */
      constructor(name3, scene, forceGLSL = false) {
        super(name3, scene, forceGLSL);
        this.directIntensity = 1;
        this.emissiveIntensity = 1;
        this.environmentIntensity = 1;
        this.specularIntensity = 1;
        this.disableBumpMap = false;
        this.ambientTextureStrength = 1;
        this.ambientTextureImpactOnAnalyticalLights = _PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
        this.metallicF0Factor = 1;
        this.metallicReflectanceColor = Color3.White();
        this.useOnlyMetallicFromMetallicReflectanceTexture = false;
        this.ambientColor = new Color3(0, 0, 0);
        this.albedoColor = new Color3(1, 1, 1);
        this.baseWeight = 1;
        this.reflectivityColor = new Color3(1, 1, 1);
        this.reflectionColor = new Color3(1, 1, 1);
        this.emissiveColor = new Color3(0, 0, 0);
        this.microSurface = 1;
        this.useLightmapAsShadowmap = false;
        this.useAlphaFromAlbedoTexture = false;
        this.forceAlphaTest = false;
        this.alphaCutOff = 0.4;
        this.useSpecularOverAlpha = true;
        this.useMicroSurfaceFromReflectivityMapAlpha = false;
        this.useRoughnessFromMetallicTextureAlpha = true;
        this.useRoughnessFromMetallicTextureGreen = false;
        this.useMetallnessFromMetallicTextureBlue = false;
        this.useAmbientOcclusionFromMetallicTextureRed = false;
        this.useAmbientInGrayScale = false;
        this.useAutoMicroSurfaceFromReflectivityMap = false;
        this.useRadianceOverAlpha = true;
        this.useObjectSpaceNormalMap = false;
        this.useParallax = false;
        this.useParallaxOcclusion = false;
        this.parallaxScaleBias = 0.05;
        this.disableLighting = false;
        this.forceIrradianceInFragment = false;
        this.maxSimultaneousLights = 4;
        this.invertNormalMapX = false;
        this.invertNormalMapY = false;
        this.twoSidedLighting = false;
        this.useAlphaFresnel = false;
        this.useLinearAlphaFresnel = false;
        this.environmentBRDFTexture = null;
        this.forceNormalForward = false;
        this.enableSpecularAntiAliasing = false;
        this.useHorizonOcclusion = true;
        this.useRadianceOcclusion = true;
        this.unlit = false;
        this.applyDecalMapAfterDetailMap = false;
        this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());
      }
      /**
       * @returns the name of this material class.
       */
      getClassName() {
        return "PBRMaterial";
      }
      /**
       * Makes a duplicate of the current material.
       * @param name - name to use for the new material.
       * @param cloneTexturesOnlyOnce - if a texture is used in more than one channel (e.g diffuse and opacity), only clone it once and reuse it on the other channels. Default false.
       * @param rootUrl defines the root URL to use to load textures
       * @returns cloned material instance
       */
      clone(name3, cloneTexturesOnlyOnce = true, rootUrl = "") {
        const clone = SerializationHelper.Clone(() => new _PBRMaterial(name3, this.getScene()), this, { cloneTexturesOnlyOnce });
        clone.id = name3;
        clone.name = name3;
        this.stencil.copyTo(clone.stencil);
        this._clonePlugins(clone, rootUrl);
        return clone;
      }
      /**
       * Serializes this PBR Material.
       * @returns - An object with the serialized material.
       */
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.customType = "BABYLON.PBRMaterial";
        return serializationObject;
      }
      // Statics
      /**
       * Parses a PBR Material from a serialized object.
       * @param source - Serialized object.
       * @param scene - BJS scene instance.
       * @param rootUrl - url for the scene object
       * @returns - PBRMaterial
       */
      static Parse(source, scene, rootUrl) {
        const material = SerializationHelper.Parse(() => new _PBRMaterial(source.name, scene), source, scene, rootUrl);
        if (source.stencil) {
          material.stencil.parse(source.stencil, scene, rootUrl);
        }
        Material._ParsePlugins(source, material, scene, rootUrl);
        if (source.clearCoat) {
          material.clearCoat.parse(source.clearCoat, scene, rootUrl);
        }
        if (source.anisotropy) {
          material.anisotropy.parse(source.anisotropy, scene, rootUrl);
        }
        if (source.brdf) {
          material.brdf.parse(source.brdf, scene, rootUrl);
        }
        if (source.sheen) {
          material.sheen.parse(source.sheen, scene, rootUrl);
        }
        if (source.subSurface) {
          material.subSurface.parse(source.subSurface, scene, rootUrl);
        }
        if (source.iridescence) {
          material.iridescence.parse(source.iridescence, scene, rootUrl);
        }
        return material;
      }
    };
    PBRMaterial.PBRMATERIAL_OPAQUE = PBRBaseMaterial.PBRMATERIAL_OPAQUE;
    PBRMaterial.PBRMATERIAL_ALPHATEST = PBRBaseMaterial.PBRMATERIAL_ALPHATEST;
    PBRMaterial.PBRMATERIAL_ALPHABLEND = PBRBaseMaterial.PBRMATERIAL_ALPHABLEND;
    PBRMaterial.PBRMATERIAL_ALPHATESTANDBLEND = PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND;
    PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "directIntensity", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "emissiveIntensity", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "environmentIntensity", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "specularIntensity", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "disableBumpMap", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "albedoTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "baseWeightTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "baseDiffuseRoughnessTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "ambientTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "ambientTextureStrength", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "ambientTextureImpactOnAnalyticalLights", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], PBRMaterial.prototype, "opacityTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "reflectionTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "emissiveTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "reflectivityTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "metallicTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "metallic", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "roughness", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "metallicF0Factor", void 0);
    __decorate([
      serializeAsColor3(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "metallicReflectanceColor", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useOnlyMetallicFromMetallicReflectanceTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "metallicReflectanceTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "reflectanceTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "microSurfaceTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "bumpTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty", null)
    ], PBRMaterial.prototype, "lightmapTexture", void 0);
    __decorate([
      serializeAsColor3("ambient"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "ambientColor", void 0);
    __decorate([
      serializeAsColor3("albedo"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "albedoColor", void 0);
    __decorate([
      serialize("baseWeight"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "baseWeight", void 0);
    __decorate([
      serialize("baseDiffuseRoughness"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "baseDiffuseRoughness", void 0);
    __decorate([
      serializeAsColor3("reflectivity"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "reflectivityColor", void 0);
    __decorate([
      serializeAsColor3("reflection"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "reflectionColor", void 0);
    __decorate([
      serializeAsColor3("emissive"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "emissiveColor", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "microSurface", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useLightmapAsShadowmap", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], PBRMaterial.prototype, "useAlphaFromAlbedoTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], PBRMaterial.prototype, "forceAlphaTest", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], PBRMaterial.prototype, "alphaCutOff", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useSpecularOverAlpha", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useMicroSurfaceFromReflectivityMapAlpha", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useRoughnessFromMetallicTextureAlpha", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useRoughnessFromMetallicTextureGreen", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useMetallnessFromMetallicTextureBlue", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useAmbientOcclusionFromMetallicTextureRed", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useAmbientInGrayScale", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useAutoMicroSurfaceFromReflectivityMap", void 0);
    __decorate([
      serialize()
    ], PBRMaterial.prototype, "usePhysicalLightFalloff", null);
    __decorate([
      serialize()
    ], PBRMaterial.prototype, "useGLTFLightFalloff", null);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useRadianceOverAlpha", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useObjectSpaceNormalMap", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useParallax", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useParallaxOcclusion", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "parallaxScaleBias", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], PBRMaterial.prototype, "disableLighting", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "forceIrradianceInFragment", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], PBRMaterial.prototype, "maxSimultaneousLights", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "invertNormalMapX", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "invertNormalMapY", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "twoSidedLighting", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useAlphaFresnel", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useLinearAlphaFresnel", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "environmentBRDFTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "forceNormalForward", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "enableSpecularAntiAliasing", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useHorizonOcclusion", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useRadianceOcclusion", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRMaterial.prototype, "unlit", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRMaterial.prototype, "applyDecalMapAfterDetailMap", void 0);
    RegisterClass("BABYLON.PBRMaterial", PBRMaterial);
  }
});

// node_modules/@babylonjs/core/Materials/uniformBufferEffectCommonAccessor.js
var UniformBufferEffectCommonAccessor;
var init_uniformBufferEffectCommonAccessor = __esm({
  "node_modules/@babylonjs/core/Materials/uniformBufferEffectCommonAccessor.js"() {
    UniformBufferEffectCommonAccessor = class {
      _isUbo(uboOrEffect) {
        return uboOrEffect.addUniform !== void 0;
      }
      constructor(uboOrEffect) {
        if (this._isUbo(uboOrEffect)) {
          this.setMatrix3x3 = uboOrEffect.updateMatrix3x3.bind(uboOrEffect);
          this.setMatrix2x2 = uboOrEffect.updateMatrix2x2.bind(uboOrEffect);
          this.setFloat = uboOrEffect.updateFloat.bind(uboOrEffect);
          this.setFloat2 = uboOrEffect.updateFloat2.bind(uboOrEffect);
          this.setFloat3 = uboOrEffect.updateFloat3.bind(uboOrEffect);
          this.setFloat4 = uboOrEffect.updateFloat4.bind(uboOrEffect);
          this.setFloatArray = uboOrEffect.updateFloatArray.bind(uboOrEffect);
          this.setArray = uboOrEffect.updateArray.bind(uboOrEffect);
          this.setIntArray = uboOrEffect.updateIntArray.bind(uboOrEffect);
          this.setMatrix = uboOrEffect.updateMatrix.bind(uboOrEffect);
          this.setMatrices = uboOrEffect.updateMatrices.bind(uboOrEffect);
          this.setVector3 = uboOrEffect.updateVector3.bind(uboOrEffect);
          this.setVector4 = uboOrEffect.updateVector4.bind(uboOrEffect);
          this.setColor3 = uboOrEffect.updateColor3.bind(uboOrEffect);
          this.setColor4 = uboOrEffect.updateColor4.bind(uboOrEffect);
          this.setDirectColor4 = uboOrEffect.updateDirectColor4.bind(uboOrEffect);
          this.setInt = uboOrEffect.updateInt.bind(uboOrEffect);
          this.setInt2 = uboOrEffect.updateInt2.bind(uboOrEffect);
          this.setInt3 = uboOrEffect.updateInt3.bind(uboOrEffect);
          this.setInt4 = uboOrEffect.updateInt4.bind(uboOrEffect);
        } else {
          this.setMatrix3x3 = uboOrEffect.setMatrix3x3.bind(uboOrEffect);
          this.setMatrix2x2 = uboOrEffect.setMatrix2x2.bind(uboOrEffect);
          this.setFloat = uboOrEffect.setFloat.bind(uboOrEffect);
          this.setFloat2 = uboOrEffect.setFloat2.bind(uboOrEffect);
          this.setFloat3 = uboOrEffect.setFloat3.bind(uboOrEffect);
          this.setFloat4 = uboOrEffect.setFloat4.bind(uboOrEffect);
          this.setFloatArray = uboOrEffect.setFloatArray.bind(uboOrEffect);
          this.setArray = uboOrEffect.setArray.bind(uboOrEffect);
          this.setIntArray = uboOrEffect.setIntArray.bind(uboOrEffect);
          this.setMatrix = uboOrEffect.setMatrix.bind(uboOrEffect);
          this.setMatrices = uboOrEffect.setMatrices.bind(uboOrEffect);
          this.setVector3 = uboOrEffect.setVector3.bind(uboOrEffect);
          this.setVector4 = uboOrEffect.setVector4.bind(uboOrEffect);
          this.setColor3 = uboOrEffect.setColor3.bind(uboOrEffect);
          this.setColor4 = uboOrEffect.setColor4.bind(uboOrEffect);
          this.setDirectColor4 = uboOrEffect.setDirectColor4.bind(uboOrEffect);
          this.setInt = uboOrEffect.setInt.bind(uboOrEffect);
          this.setInt2 = uboOrEffect.setInt2.bind(uboOrEffect);
          this.setInt3 = uboOrEffect.setInt3.bind(uboOrEffect);
          this.setInt4 = uboOrEffect.setInt4.bind(uboOrEffect);
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Shaders/gpuUpdateParticles.fragment.js
var name, shader;
var init_gpuUpdateParticles_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/gpuUpdateParticles.fragment.js"() {
    init_shaderStore();
    name = "gpuUpdateParticlesPixelShader";
    shader = `#version 300 es
void main() {discard;}
`;
    if (!ShaderStore.ShadersStore[name]) {
      ShaderStore.ShadersStore[name] = shader;
    }
  }
});

// node_modules/@babylonjs/core/Shaders/gpuUpdateParticles.vertex.js
var name2, shader2;
var init_gpuUpdateParticles_vertex = __esm({
  "node_modules/@babylonjs/core/Shaders/gpuUpdateParticles.vertex.js"() {
    init_shaderStore();
    name2 = "gpuUpdateParticlesVertexShader";
    shader2 = `#version 300 es
#define PI 3.14159
uniform float currentCount;uniform float timeDelta;uniform float stopFactor;
#ifndef LOCAL
uniform mat4 emitterWM;
#endif
uniform vec2 lifeTime;uniform vec2 emitPower;uniform vec2 sizeRange;uniform vec4 scaleRange;
#ifdef FLOWMAP
uniform mat4 flowMapProjection;uniform float flowMapStrength;uniform sampler2D flowMapSampler;
#endif
#ifndef COLORGRADIENTS
uniform vec4 color1;uniform vec4 color2;
#endif
uniform vec3 gravity;uniform sampler2D randomSampler;uniform sampler2D randomSampler2;uniform vec4 angleRange;
#ifdef BOXEMITTER
uniform vec3 direction1;uniform vec3 direction2;uniform vec3 minEmitBox;uniform vec3 maxEmitBox;
#endif
#ifdef POINTEMITTER
uniform vec3 direction1;uniform vec3 direction2;
#endif
#ifdef HEMISPHERICEMITTER
uniform float radius;uniform float radiusRange;uniform float directionRandomizer;
#endif
#ifdef SPHEREEMITTER
uniform float radius;uniform float radiusRange;
#ifdef DIRECTEDSPHEREEMITTER
uniform vec3 direction1;uniform vec3 direction2;
#else
uniform float directionRandomizer;
#endif
#endif
#ifdef CYLINDEREMITTER
uniform float radius;uniform float height;uniform float radiusRange;
#ifdef DIRECTEDCYLINDEREMITTER
uniform vec3 direction1;uniform vec3 direction2;
#else
uniform float directionRandomizer;
#endif
#endif
#ifdef CONEEMITTER
uniform vec2 radius;uniform float coneAngle;uniform vec2 height;
#ifdef DIRECTEDCONEEMITTER
uniform vec3 direction1;uniform vec3 direction2;
#else
uniform float directionRandomizer;
#endif
#endif
in vec3 position;
#ifdef CUSTOMEMITTER
in vec3 initialPosition;
#endif
in float age;in float life;in vec4 seed;in vec3 size;
#ifndef COLORGRADIENTS
in vec4 color;
#endif
in vec3 direction;
#ifndef BILLBOARD
in vec3 initialDirection;
#endif
#ifdef ANGULARSPEEDGRADIENTS
in float angle;
#else
in vec2 angle;
#endif
#ifdef ANIMATESHEET
in float cellIndex;
#ifdef ANIMATESHEETRANDOMSTART
in float cellStartOffset;
#endif
#endif
#ifdef NOISE
in vec3 noiseCoordinates1;in vec3 noiseCoordinates2;
#endif
out vec3 outPosition;
#ifdef CUSTOMEMITTER
out vec3 outInitialPosition;
#endif
out float outAge;out float outLife;out vec4 outSeed;out vec3 outSize;
#ifndef COLORGRADIENTS
out vec4 outColor;
#endif
out vec3 outDirection;
#ifndef BILLBOARD
out vec3 outInitialDirection;
#endif
#ifdef ANGULARSPEEDGRADIENTS
out float outAngle;
#else
out vec2 outAngle;
#endif
#ifdef ANIMATESHEET
out float outCellIndex;
#ifdef ANIMATESHEETRANDOMSTART
out float outCellStartOffset;
#endif
#endif
#ifdef NOISE
out vec3 outNoiseCoordinates1;out vec3 outNoiseCoordinates2;
#endif
#ifdef SIZEGRADIENTS
uniform sampler2D sizeGradientSampler;
#endif 
#ifdef ANGULARSPEEDGRADIENTS
uniform sampler2D angularSpeedGradientSampler;
#endif 
#ifdef VELOCITYGRADIENTS
uniform sampler2D velocityGradientSampler;
#endif
#ifdef LIMITVELOCITYGRADIENTS
uniform sampler2D limitVelocityGradientSampler;uniform float limitVelocityDamping;
#endif
#ifdef DRAGGRADIENTS
uniform sampler2D dragGradientSampler;
#endif
#ifdef NOISE
uniform vec3 noiseStrength;uniform sampler2D noiseSampler;
#endif
#ifdef ANIMATESHEET
uniform vec4 cellInfos;
#endif
vec3 getRandomVec3(float offset) {return texture(randomSampler2,vec2(float(gl_VertexID)*offset/currentCount,0)).rgb;}
vec4 getRandomVec4(float offset) {return texture(randomSampler,vec2(float(gl_VertexID)*offset/currentCount,0));}
void main() {float newAge=age+timeDelta; 
if (newAge>=life && stopFactor != 0.) {vec3 newPosition;vec3 newDirection;vec4 randoms=getRandomVec4(seed.x);outLife=lifeTime.x+(lifeTime.y-lifeTime.x)*randoms.r;outAge=newAge-life;outSeed=seed;
#ifdef SIZEGRADIENTS 
outSize.x=texture(sizeGradientSampler,vec2(0,0)).r;
#else
outSize.x=sizeRange.x+(sizeRange.y-sizeRange.x)*randoms.g;
#endif
outSize.y=scaleRange.x+(scaleRange.y-scaleRange.x)*randoms.b;outSize.z=scaleRange.z+(scaleRange.w-scaleRange.z)*randoms.a; 
#ifndef COLORGRADIENTS
outColor=color1+(color2-color1)*randoms.b;
#endif
#ifndef ANGULARSPEEDGRADIENTS 
outAngle.y=angleRange.x+(angleRange.y-angleRange.x)*randoms.a;outAngle.x=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;
#else
outAngle=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;
#endif 
#ifdef POINTEMITTER
vec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);newPosition=vec3(0,0,0);newDirection=direction1+(direction2-direction1)*randoms3;
#elif defined(BOXEMITTER)
vec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);newPosition=minEmitBox+(maxEmitBox-minEmitBox)*randoms2;newDirection=direction1+(direction2-direction1)*randoms3; 
#elif defined(HEMISPHERICEMITTER)
vec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);float phi=2.0*PI*randoms2.x;float theta=acos(2.0*randoms2.y-1.0);float randX=cos(phi)*sin(theta);float randY=cos(theta);float randZ=sin(phi)*sin(theta);newPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,abs(randY),randZ);newDirection=newPosition+directionRandomizer*randoms3; 
#elif defined(SPHEREEMITTER)
vec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);float phi=2.0*PI*randoms2.x;float theta=acos(2.0*randoms2.y-1.0);float randX=cos(phi)*sin(theta);float randY=cos(theta);float randZ=sin(phi)*sin(theta);newPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,randY,randZ);
#ifdef DIRECTEDSPHEREEMITTER
newDirection=normalize(direction1+(direction2-direction1)*randoms3);
#else
newDirection=normalize(newPosition+directionRandomizer*randoms3);
#endif
#elif defined(CYLINDEREMITTER)
vec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);float yPos=(randoms2.x-0.5)*height;float angle=randoms2.y*PI*2.;float inverseRadiusRangeSquared=((1.-radiusRange)*(1.-radiusRange));float positionRadius=radius*sqrt(inverseRadiusRangeSquared+(randoms2.z*(1.-inverseRadiusRangeSquared)));float xPos=positionRadius*cos(angle);float zPos=positionRadius*sin(angle);newPosition=vec3(xPos,yPos,zPos);
#ifdef DIRECTEDCYLINDEREMITTER
newDirection=direction1+(direction2-direction1)*randoms3;
#else
angle=angle+((randoms3.x-0.5)*PI)*directionRandomizer;newDirection=vec3(cos(angle),(randoms3.y-0.5)*directionRandomizer,sin(angle));newDirection=normalize(newDirection);
#endif
#elif defined(CONEEMITTER)
vec3 randoms2=getRandomVec3(seed.y);float s=2.0*PI*randoms2.x;
#ifdef CONEEMITTERSPAWNPOINT
float h=0.0001;
#else
float h=randoms2.y*height.y;h=1.-h*h; 
#endif
float lRadius=radius.x-radius.x*randoms2.z*radius.y;lRadius=lRadius*h;float randX=lRadius*sin(s);float randZ=lRadius*cos(s);float randY=h *height.x;newPosition=vec3(randX,randY,randZ); 
vec3 randoms3=getRandomVec3(seed.z);
#ifdef DIRECTEDCONEEMITTER
newDirection=direction1+(direction2-direction1)*randoms3;
#else
if (abs(cos(coneAngle))==1.0) {newDirection=vec3(0.,1.0,0.);} else {newDirection=normalize(newPosition+directionRandomizer*randoms3); }
#endif
#elif defined(CUSTOMEMITTER)
newPosition=initialPosition;outInitialPosition=initialPosition;
#else 
newPosition=vec3(0.,0.,0.);newDirection=2.0*(getRandomVec3(seed.w)-vec3(0.5,0.5,0.5));
#endif
float power=emitPower.x+(emitPower.y-emitPower.x)*randoms.a;
#ifdef LOCAL
outPosition=newPosition;
#else
outPosition=(emitterWM*vec4(newPosition,1.)).xyz;
#endif
#ifdef CUSTOMEMITTER
outDirection=direction;
#ifndef BILLBOARD 
outInitialDirection=direction;
#endif
#else
#ifdef LOCAL
vec3 initial=newDirection;
#else 
vec3 initial=(emitterWM*vec4(newDirection,0.)).xyz;
#endif
outDirection=initial*power;
#ifndef BILLBOARD 
outInitialDirection=initial;
#endif
#endif
#ifdef ANIMATESHEET 
outCellIndex=cellInfos.x;
#ifdef ANIMATESHEETRANDOMSTART
outCellStartOffset=randoms.a*outLife;
#endif 
#endif
#ifdef NOISE
outNoiseCoordinates1=noiseCoordinates1;outNoiseCoordinates2=noiseCoordinates2;
#endif
} else {float directionScale=timeDelta;outAge=newAge;float ageGradient=newAge/life;
#ifdef VELOCITYGRADIENTS
directionScale*=texture(velocityGradientSampler,vec2(ageGradient,0)).r;
#endif
#ifdef DRAGGRADIENTS
directionScale*=1.0-texture(dragGradientSampler,vec2(ageGradient,0)).r;
#endif
#if defined(CUSTOMEMITTER)
outPosition=position+(direction-position)*ageGradient; 
outInitialPosition=initialPosition;
#else
outPosition=position+direction*directionScale;
#endif
outLife=life;outSeed=seed;
#ifndef COLORGRADIENTS 
outColor=color;
#endif
#ifdef SIZEGRADIENTS
outSize.x=texture(sizeGradientSampler,vec2(ageGradient,0)).r;outSize.yz=size.yz;
#else
outSize=size;
#endif 
#ifndef BILLBOARD 
outInitialDirection=initialDirection;
#endif
#ifdef CUSTOMEMITTER
outDirection=direction;
#else
vec3 updatedDirection=direction+gravity*timeDelta;
#ifdef FLOWMAP
vec4 clipSpace=(flowMapProjection*vec4(position,1.));vec3 ndcSpace=clipSpace.xyz/clipSpace.w;vec2 flowMapUV=ndcSpace.xy*0.5+0.5;vec4 flowMapValue=texture(flowMapSampler,flowMapUV);vec3 flowMapDirection=(flowMapValue.xyz*2.0-1.0)*flowMapValue.w;updatedDirection+=flowMapDirection*timeDelta*flowMapStrength;
#endif
#ifdef LIMITVELOCITYGRADIENTS
float limitVelocity=texture(limitVelocityGradientSampler,vec2(ageGradient,0)).r;float currentVelocity=length(updatedDirection);if (currentVelocity>limitVelocity) {updatedDirection=updatedDirection*limitVelocityDamping;}
#endif
outDirection=updatedDirection;
#ifdef NOISE
float fetchedR=texture(noiseSampler,vec2(noiseCoordinates1.x,noiseCoordinates1.y)*vec2(0.5)+vec2(0.5)).r;float fetchedG=texture(noiseSampler,vec2(noiseCoordinates1.z,noiseCoordinates2.x)*vec2(0.5)+vec2(0.5)).r;float fetchedB=texture(noiseSampler,vec2(noiseCoordinates2.y,noiseCoordinates2.z)*vec2(0.5)+vec2(0.5)).r;vec3 force=vec3(2.*fetchedR-1.,2.*fetchedG-1.,2.*fetchedB-1.)*noiseStrength;outDirection=outDirection+force*timeDelta;outNoiseCoordinates1=noiseCoordinates1;outNoiseCoordinates2=noiseCoordinates2;
#endif 
#endif 
#ifdef ANGULARSPEEDGRADIENTS
float angularSpeed=texture(angularSpeedGradientSampler,vec2(ageGradient,0)).r;outAngle=angle+angularSpeed*timeDelta;
#else
outAngle=vec2(angle.x+angle.y*timeDelta,angle.y);
#endif
#ifdef ANIMATESHEET 
float offsetAge=outAge;float dist=cellInfos.y-cellInfos.x;
#ifdef ANIMATESHEETRANDOMSTART
outCellStartOffset=cellStartOffset;offsetAge+=cellStartOffset;
#else
float cellStartOffset=0.;
#endif 
float ratio=0.;if (cellInfos.w==1.0) {ratio=clamp(mod(cellStartOffset+cellInfos.z*offsetAge,life)/life,0.,1.0);}
else {ratio=clamp(cellStartOffset+cellInfos.z*offsetAge/life,0.,1.0);}
outCellIndex=float(int(cellInfos.x+ratio*dist));
#endif
}}`;
    if (!ShaderStore.ShadersStore[name2]) {
      ShaderStore.ShadersStore[name2] = shader2;
    }
  }
});

// node_modules/@babylonjs/core/Particles/webgl2ParticleSystem.js
var WebGL2ParticleSystem;
var init_webgl2ParticleSystem = __esm({
  "node_modules/@babylonjs/core/Particles/webgl2ParticleSystem.js"() {
    init_customParticleEmitter();
    init_uniformBufferEffectCommonAccessor();
    init_typeStore();
    init_gpuUpdateParticles_fragment();
    init_gpuUpdateParticles_vertex();
    WebGL2ParticleSystem = class {
      /** @internal */
      constructor(parent, engine) {
        this._renderVAO = [];
        this._updateVAO = [];
        this.alignDataInBuffer = false;
        this._parent = parent;
        this._engine = engine;
        this._updateEffectOptions = {
          attributes: [
            "position",
            "initialPosition",
            "age",
            "life",
            "seed",
            "size",
            "color",
            "direction",
            "initialDirection",
            "angle",
            "cellIndex",
            "cellStartOffset",
            "noiseCoordinates1",
            "noiseCoordinates2"
          ],
          uniformsNames: [
            "currentCount",
            "timeDelta",
            "emitterWM",
            "lifeTime",
            "color1",
            "color2",
            "sizeRange",
            "scaleRange",
            "gravity",
            "emitPower",
            "direction1",
            "direction2",
            "minEmitBox",
            "maxEmitBox",
            "radius",
            "directionRandomizer",
            "height",
            "coneAngle",
            "stopFactor",
            "angleRange",
            "radiusRange",
            "cellInfos",
            "noiseStrength",
            "limitVelocityDamping",
            "flowMapProjection",
            "flowMapStrength"
          ],
          uniformBuffersNames: [],
          samplers: [
            "randomSampler",
            "randomSampler2",
            "sizeGradientSampler",
            "angularSpeedGradientSampler",
            "velocityGradientSampler",
            "limitVelocityGradientSampler",
            "noiseSampler",
            "dragGradientSampler",
            "flowMapSampler"
          ],
          defines: "",
          fallbacks: null,
          onCompiled: null,
          onError: null,
          indexParameters: null,
          maxSimultaneousLights: 0,
          transformFeedbackVaryings: []
        };
      }
      /** @internal */
      contextLost() {
        this._updateEffect = void 0;
        this._renderVAO.length = 0;
        this._updateVAO.length = 0;
      }
      /** @internal */
      isUpdateBufferCreated() {
        return !!this._updateEffect;
      }
      /** @internal */
      isUpdateBufferReady() {
        return this._updateEffect?.isReady() ?? false;
      }
      /** @internal */
      createUpdateBuffer(defines) {
        this._updateEffectOptions.transformFeedbackVaryings = ["outPosition"];
        this._updateEffectOptions.transformFeedbackVaryings.push("outAge");
        this._updateEffectOptions.transformFeedbackVaryings.push("outSize");
        this._updateEffectOptions.transformFeedbackVaryings.push("outLife");
        this._updateEffectOptions.transformFeedbackVaryings.push("outSeed");
        this._updateEffectOptions.transformFeedbackVaryings.push("outDirection");
        if (this._parent.particleEmitterType instanceof CustomParticleEmitter) {
          this._updateEffectOptions.transformFeedbackVaryings.push("outInitialPosition");
        }
        if (!this._parent._colorGradientsTexture) {
          this._updateEffectOptions.transformFeedbackVaryings.push("outColor");
        }
        if (!this._parent._isBillboardBased) {
          this._updateEffectOptions.transformFeedbackVaryings.push("outInitialDirection");
        }
        if (this._parent.noiseTexture) {
          this._updateEffectOptions.transformFeedbackVaryings.push("outNoiseCoordinates1");
          this._updateEffectOptions.transformFeedbackVaryings.push("outNoiseCoordinates2");
        }
        this._updateEffectOptions.transformFeedbackVaryings.push("outAngle");
        if (this._parent.isAnimationSheetEnabled) {
          this._updateEffectOptions.transformFeedbackVaryings.push("outCellIndex");
          if (this._parent.spriteRandomStartCell) {
            this._updateEffectOptions.transformFeedbackVaryings.push("outCellStartOffset");
          }
        }
        this._updateEffectOptions.defines = defines;
        this._updateEffect = this._engine.createEffect("gpuUpdateParticles", this._updateEffectOptions, this._engine);
        return new UniformBufferEffectCommonAccessor(this._updateEffect);
      }
      /** @internal */
      createVertexBuffers(updateBuffer, renderVertexBuffers) {
        this._updateVAO.push(this._createUpdateVAO(updateBuffer));
        this._renderVAO.push(this._engine.recordVertexArrayObject(renderVertexBuffers, null, this._parent._getWrapper(this._parent.blendMode).effect));
        this._engine.bindArrayBuffer(null);
        this._renderVertexBuffers = renderVertexBuffers;
      }
      /** @internal */
      createParticleBuffer(data) {
        return data;
      }
      /** @internal */
      bindDrawBuffers(index, effect, indexBuffer) {
        if (indexBuffer) {
          this._engine.bindBuffers(this._renderVertexBuffers, indexBuffer, effect);
        } else {
          this._engine.bindVertexArrayObject(this._renderVAO[index], null);
        }
      }
      /** @internal */
      preUpdateParticleBuffer() {
        const engine = this._engine;
        this._engine.enableEffect(this._updateEffect);
        if (!engine.setState) {
          throw new Error("GPU particles cannot work without a full Engine. ThinEngine is not supported");
        }
      }
      /** @internal */
      updateParticleBuffer(index, targetBuffer, currentActiveCount) {
        this._updateEffect.setTexture("randomSampler", this._parent._randomTexture);
        this._updateEffect.setTexture("randomSampler2", this._parent._randomTexture2);
        if (this._parent._flowMap) {
          this._updateEffect.setTexture("flowMapSampler", this._parent._flowMap);
        }
        if (this._parent._sizeGradientsTexture) {
          this._updateEffect.setTexture("sizeGradientSampler", this._parent._sizeGradientsTexture);
        }
        if (this._parent._angularSpeedGradientsTexture) {
          this._updateEffect.setTexture("angularSpeedGradientSampler", this._parent._angularSpeedGradientsTexture);
        }
        if (this._parent._velocityGradientsTexture) {
          this._updateEffect.setTexture("velocityGradientSampler", this._parent._velocityGradientsTexture);
        }
        if (this._parent._limitVelocityGradientsTexture) {
          this._updateEffect.setTexture("limitVelocityGradientSampler", this._parent._limitVelocityGradientsTexture);
        }
        if (this._parent._dragGradientsTexture) {
          this._updateEffect.setTexture("dragGradientSampler", this._parent._dragGradientsTexture);
        }
        if (this._parent.noiseTexture) {
          this._updateEffect.setTexture("noiseSampler", this._parent.noiseTexture);
        }
        this._engine.bindVertexArrayObject(this._updateVAO[index], null);
        const engine = this._engine;
        engine.bindTransformFeedbackBuffer(targetBuffer.getBuffer());
        engine.setRasterizerState(false);
        engine.beginTransformFeedback(true);
        engine.drawArraysType(3, 0, currentActiveCount);
        engine.endTransformFeedback();
        engine.setRasterizerState(true);
        engine.bindTransformFeedbackBuffer(null);
      }
      /** @internal */
      releaseBuffers() {
      }
      /** @internal */
      releaseVertexBuffers() {
        for (let index = 0; index < this._updateVAO.length; index++) {
          this._engine.releaseVertexArrayObject(this._updateVAO[index]);
        }
        this._updateVAO.length = 0;
        for (let index = 0; index < this._renderVAO.length; index++) {
          this._engine.releaseVertexArrayObject(this._renderVAO[index]);
        }
        this._renderVAO.length = 0;
      }
      _createUpdateVAO(source) {
        const updateVertexBuffers = {};
        updateVertexBuffers["position"] = source.createVertexBuffer("position", 0, 3);
        let offset = 3;
        updateVertexBuffers["age"] = source.createVertexBuffer("age", offset, 1);
        offset += 1;
        updateVertexBuffers["size"] = source.createVertexBuffer("size", offset, 3);
        offset += 3;
        updateVertexBuffers["life"] = source.createVertexBuffer("life", offset, 1);
        offset += 1;
        updateVertexBuffers["seed"] = source.createVertexBuffer("seed", offset, 4);
        offset += 4;
        updateVertexBuffers["direction"] = source.createVertexBuffer("direction", offset, 3);
        offset += 3;
        if (this._parent.particleEmitterType instanceof CustomParticleEmitter) {
          updateVertexBuffers["initialPosition"] = source.createVertexBuffer("initialPosition", offset, 3);
          offset += 3;
        }
        if (!this._parent._colorGradientsTexture) {
          updateVertexBuffers["color"] = source.createVertexBuffer("color", offset, 4);
          offset += 4;
        }
        if (!this._parent._isBillboardBased) {
          updateVertexBuffers["initialDirection"] = source.createVertexBuffer("initialDirection", offset, 3);
          offset += 3;
        }
        if (this._parent.noiseTexture) {
          updateVertexBuffers["noiseCoordinates1"] = source.createVertexBuffer("noiseCoordinates1", offset, 3);
          offset += 3;
          updateVertexBuffers["noiseCoordinates2"] = source.createVertexBuffer("noiseCoordinates2", offset, 3);
          offset += 3;
        }
        if (this._parent._angularSpeedGradientsTexture) {
          updateVertexBuffers["angle"] = source.createVertexBuffer("angle", offset, 1);
          offset += 1;
        } else {
          updateVertexBuffers["angle"] = source.createVertexBuffer("angle", offset, 2);
          offset += 2;
        }
        if (this._parent._isAnimationSheetEnabled) {
          updateVertexBuffers["cellIndex"] = source.createVertexBuffer("cellIndex", offset, 1);
          offset += 1;
          if (this._parent.spriteRandomStartCell) {
            updateVertexBuffers["cellStartOffset"] = source.createVertexBuffer("cellStartOffset", offset, 1);
            offset += 1;
          }
        }
        const vao = this._engine.recordVertexArrayObject(updateVertexBuffers, null, this._updateEffect);
        this._engine.bindArrayBuffer(null);
        return vao;
      }
    };
    RegisterClass("BABYLON.WebGL2ParticleSystem", WebGL2ParticleSystem);
  }
});

export {
  StickValues,
  Gamepad,
  GenericPad,
  init_gamepad,
  ArcRotateCameraGamepadInput,
  init_arcRotateCameraGamepadInput,
  FlyCameraKeyboardInput,
  init_flyCameraKeyboardInput,
  FlyCameraMouseInput,
  init_flyCameraMouseInput,
  FreeCameraGamepadInput,
  init_freeCameraGamepadInput,
  TouchCamera,
  init_touchCamera,
  FlyCameraInputsManager,
  init_flyCameraInputsManager,
  FlyCamera,
  init_flyCamera,
  Xbox360Button,
  Xbox360Dpad,
  Xbox360Pad,
  init_xboxGamepad,
  DualShockButton,
  DualShockDpad,
  DualShockPad,
  init_dualShockGamepad,
  GamepadManager,
  init_gamepadManager,
  GamepadSystemSceneComponent,
  init_gamepadSceneComponent,
  UniversalCamera,
  init_universalCamera,
  NodeRenderGraphBlockConnectionPointTypes,
  NodeRenderGraphConnectionPointCompatibilityStates,
  NodeRenderGraphConnectionPointDirection,
  init_nodeRenderGraphTypes,
  NodeRenderGraphConnectionPoint,
  init_nodeRenderGraphBlockConnectionPoint,
  NodeRenderGraphBlock,
  init_nodeRenderGraphBlock,
  FrameGraphCopyToBackbufferColorTask,
  init_copyToBackbufferColorTask,
  NodeRenderGraphOutputBlock,
  init_outputBlock,
  NodeRenderGraphInputBlock,
  init_inputBlock,
  FrameGraphClearTextureTask,
  init_clearTextureTask,
  NodeRenderGraphClearBlock,
  init_clearBlock,
  NodeRenderGraphConnectionPointCustomObject,
  init_nodeRenderGraphConnectionPointCustomObject,
  NodeRenderGraphBaseObjectRendererBlock,
  init_baseObjectRendererBlock,
  NodeRenderGraphObjectRendererBlock,
  init_objectRendererBlock,
  NodeRenderGraphBuildState,
  init_nodeRenderGraphBuildState,
  FrameGraphCullObjectsTask,
  init_cullObjectsTask,
  NodeRenderGraphCullObjectsBlock,
  init_cullObjectsBlock,
  NodeRenderGraph,
  init_nodeRenderGraph,
  PBRMaterial,
  init_pbrMaterial,
  UniformBufferEffectCommonAccessor,
  init_uniformBufferEffectCommonAccessor,
  WebGL2ParticleSystem,
  init_webgl2ParticleSystem
};
//# sourceMappingURL=chunk-2EJYNSOB.js.map
