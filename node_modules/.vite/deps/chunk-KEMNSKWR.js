import {
  UniformBuffer,
  init_uniformBuffer
} from "./chunk-ETNKJY4V.js";
import {
  Effect,
  init_effect
} from "./chunk-WTQMXJ7P.js";
import {
  InvertMatrixToRef,
  Matrix,
  MultiplyMatricesToRef,
  Vector3,
  init_math_vector,
  init_thinMath_matrix_functions
} from "./chunk-VQZCJUUR.js";
import {
  __esm
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@babylonjs/core/Materials/floatingOriginMatrixOverrides.js
function OffsetWorldToRef(offset, world, ref) {
  const refArray = ref.asArray();
  const worldArray = world.asArray();
  for (let i = 0; i < 16; i++) {
    refArray[i] = worldArray[i];
  }
  refArray[12] -= offset.x;
  refArray[13] -= offset.y;
  refArray[14] -= offset.z;
  ref.markAsUpdated();
  return ref;
}
function GetFullOffsetView(offset, viewMatrix, ref) {
  InvertMatrixToRef(viewMatrix, TempMat1);
  OffsetWorldToRef(offset, TempMat1, TempMat2);
  InvertMatrixToRef(TempMat2, ref);
  return ref;
}
function OffsetViewToRef(offset, view, ref) {
  if (!FloatingOriginCurrentScene.eyeAtCamera) {
    return GetFullOffsetView(offset, view, ref);
  }
  const refArray = ref.asArray();
  const viewArray = view.asArray();
  for (let i = 0; i < 16; i++) {
    refArray[i] = viewArray[i];
  }
  refArray[12] = 0;
  refArray[13] = 0;
  refArray[14] = 0;
  ref.markAsUpdated();
  return ref;
}
function OffsetViewProjectionToRef(offset, view, projection, ref) {
  MultiplyMatricesToRef(OffsetViewToRef(offset, view, ref), projection, ref);
  return ref;
}
function OffsetClipPlaneToRef(offset, plane, ref) {
  ref.normal.copyFrom(plane.normal);
  ref.d = plane.d + Vector3.Dot(plane.normal, offset);
  return ref;
}
function GetOffsetTransformMatrices(offset, viewMatrices, projectionMatrices, length, resultArray) {
  for (let cascadeIndex = 0; cascadeIndex < length; ++cascadeIndex) {
    GetFullOffsetViewProjectionToRef(offset, viewMatrices[cascadeIndex], projectionMatrices[cascadeIndex], TempMat1);
    TempMat1.copyToArray(resultArray, cascadeIndex * 16);
  }
  return resultArray;
}
function OffsetWorldViewToRef(offset, worldView, view, ref) {
  InvertMatrixToRef(view, TempMat1);
  MultiplyMatricesToRef(worldView, TempMat1, TempMat2);
  OffsetWorldToRef(offset, TempMat2, TempMat1);
  OffsetViewToRef(offset, view, TempMat2);
  MultiplyMatricesToRef(TempMat1, TempMat2, ref);
  return ref;
}
function GetFullOffsetViewProjectionToRef(offset, viewMatrix, projectionMatrix, ref) {
  GetFullOffsetView(offset, viewMatrix, TempMat2);
  MultiplyMatricesToRef(TempMat2, projectionMatrix, ref);
  return ref;
}
function OffsetWorldViewProjectionToRef(offset, worldViewProjection, viewProjection, view, projection, ref) {
  InvertMatrixToRef(viewProjection, TempMat1);
  MultiplyMatricesToRef(worldViewProjection, TempMat1, TempMat2);
  OffsetWorldToRef(offset, TempMat2, TempMat1);
  OffsetViewProjectionToRef(offset, view, projection, TempMat2);
  MultiplyMatricesToRef(TempMat1, TempMat2, ref);
  return ref;
}
function GetOffsetMatrix(uniformName, mat) {
  const scene = FloatingOriginCurrentScene.getScene();
  if (!scene || TempFinalMat === mat) {
    return mat;
  }
  TempFinalMat.updateFlag = mat.updateFlag;
  const offset = scene.floatingOriginOffset;
  switch (uniformName) {
    case "world":
      return OffsetWorldToRef(offset, mat, TempFinalMat);
    case "view":
      return OffsetViewToRef(offset, mat, TempFinalMat);
    case "worldView":
      return OffsetWorldViewToRef(offset, mat, scene.getViewMatrix(), TempFinalMat);
    case "viewProjection":
      return OffsetViewProjectionToRef(offset, scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);
    case "worldViewProjection":
      return OffsetWorldViewProjectionToRef(offset, mat, scene.getTransformMatrix(), scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);
    default:
      if (uniformName.startsWith("u_")) {
        const lowercaseUniformName = uniformName.toLowerCase();
        if (lowercaseUniformName.startsWith("u_worldviewprojection")) {
          return OffsetWorldViewProjectionToRef(offset, mat, scene.getTransformMatrix(), scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);
        }
        if (lowercaseUniformName.startsWith("u_viewprojection")) {
          return OffsetViewProjectionToRef(offset, scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);
        }
        if (lowercaseUniformName.startsWith("u_worldview")) {
          return OffsetWorldViewToRef(offset, mat, scene.getViewMatrix(), TempFinalMat);
        }
        if (lowercaseUniformName.startsWith("u_world")) {
          return OffsetWorldToRef(offset, mat, TempFinalMat);
        }
        if (lowercaseUniformName.startsWith("u_view")) {
          return OffsetViewToRef(offset, mat, TempFinalMat);
        }
      }
      return mat;
  }
}
function ResetMatrixFunctions() {
  Effect.prototype.setMatrix = OriginalSetMatrix;
  EffectInternal._setMatrixOverride = void 0;
  UniformBufferInternal.prototype._updateMatrixForUniform = OriginalUpdateMatrixForUniform;
  UniformBufferInternal.prototype._updateMatrixForUniformOverride = void 0;
}
function OverrideMatrixFunctions() {
  EffectInternal.prototype._setMatrixOverride = OriginalSetMatrix;
  EffectInternal.prototype.setMatrix = function(uniformName, matrix) {
    this._setMatrixOverride(uniformName, GetOffsetMatrix(uniformName, matrix));
    return this;
  };
  UniformBufferInternal.prototype._updateMatrixForUniformOverride = OriginalUpdateMatrixForUniform;
  UniformBufferInternal.prototype._updateMatrixForUniform = function(uniformName, matrix) {
    this._updateMatrixForUniformOverride(uniformName, GetOffsetMatrix(uniformName, matrix));
  };
}
var TempFinalMat, TempMat1, TempMat2, FloatingOriginCurrentScene, UniformBufferInternal, EffectInternal, OriginalUpdateMatrixForUniform, OriginalSetMatrix;
var init_floatingOriginMatrixOverrides = __esm({
  "node_modules/@babylonjs/core/Materials/floatingOriginMatrixOverrides.js"() {
    init_effect();
    init_math_vector();
    init_thinMath_matrix_functions();
    init_uniformBuffer();
    TempFinalMat = new Matrix();
    TempMat1 = new Matrix();
    TempMat2 = new Matrix();
    FloatingOriginCurrentScene = {
      getScene: () => void 0,
      eyeAtCamera: true
      // When true, we can assume viewMatrix translation is at origin. Otherwise, we must do full offset calculations
    };
    UniformBufferInternal = UniformBuffer;
    EffectInternal = Effect;
    OriginalUpdateMatrixForUniform = UniformBufferInternal.prototype._updateMatrixForUniform;
    OriginalSetMatrix = Effect.prototype.setMatrix;
  }
});

export {
  FloatingOriginCurrentScene,
  OffsetViewToRef,
  OffsetClipPlaneToRef,
  GetOffsetTransformMatrices,
  GetFullOffsetViewProjectionToRef,
  ResetMatrixFunctions,
  OverrideMatrixFunctions,
  init_floatingOriginMatrixOverrides
};
//# sourceMappingURL=chunk-KEMNSKWR.js.map
