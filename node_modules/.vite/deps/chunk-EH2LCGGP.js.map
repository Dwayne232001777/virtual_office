{
  "version": 3,
  "sources": ["../../../dev/core/src/AudioV2/abstractAudio/abstractSound.ts", "../../../dev/core/src/AudioV2/abstractAudio/abstractSoundInstance.ts"],
  "sourcesContent": ["import { Observable } from \"../../Misc/observable\";\nimport type { Nullable } from \"../../types\";\nimport { SoundState } from \"../soundState\";\nimport { AudioNodeType } from \"./abstractAudioNode\";\nimport type { _AbstractSoundInstance } from \"./abstractSoundInstance\";\nimport { AbstractSoundSource, type ISoundSourceOptions } from \"./abstractSoundSource\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { IVolumeAudioOptions } from \"./subNodes/volumeAudioSubNode\";\n\n/** @internal */\nexport interface IAbstractSoundOptionsBase {\n    /**\n     * Whether the sound should start playing automatically. Defaults to `false`.\n     */\n    autoplay: boolean;\n    /**\n     * The maximum number of instances that can play at the same time. Defaults to `Infinity`.\n     */\n    maxInstances: number;\n}\n\n/** @internal */\nexport interface IAbstractSoundPlayOptionsBase {\n    /**\n     * Whether the sound should loop. Defaults to `false`.\n     */\n    loop: boolean;\n    /**\n     * The time within the sound buffer to start playing at, in seconds. Defaults to `0`.\n     */\n    startOffset: number;\n}\n\n/**\n * Options for creating a sound.\n */\nexport interface IAbstractSoundOptions extends IAbstractSoundOptionsBase, IAbstractSoundPlayOptions, ISoundSourceOptions {}\n\n/**\n * Options for playing a sound.\n */\nexport interface IAbstractSoundPlayOptions extends IAbstractSoundPlayOptionsBase, IVolumeAudioOptions {}\n\n/**\n * Options stored in a sound.\n * @internal\n */\nexport interface IAbstractSoundStoredOptions extends IAbstractSoundOptionsBase, IAbstractSoundPlayOptionsBase {}\n\n/**\n * Abstract class representing a sound in the audio engine.\n */\nexport abstract class AbstractSound extends AbstractSoundSource {\n    private _newestInstance: Nullable<_AbstractSoundInstance> = null;\n    private _privateInstances = new Set<_AbstractSoundInstance>();\n    private _state: SoundState = SoundState.Stopped;\n\n    protected _instances: ReadonlySet<_AbstractSoundInstance> = this._privateInstances;\n    protected abstract readonly _options: IAbstractSoundStoredOptions;\n\n    /**\n     * Observable for when the sound stops playing.\n     */\n    public readonly onEndedObservable = new Observable<AbstractSound>();\n\n    protected constructor(name: string, engine: AudioEngineV2, options: Partial<IAbstractSoundOptions>) {\n        super(name, engine, options, AudioNodeType.HAS_INPUTS_AND_OUTPUTS); // Inputs are for instances.\n    }\n\n    /**\n     * The number of active instances of the sound that are currently playing.\n     */\n    public get activeInstancesCount(): number {\n        return this._instances.size;\n    }\n\n    /**\n     * Whether the sound should start playing automatically. Defaults to `false`.\n     */\n    public get autoplay(): boolean {\n        return this._options.autoplay;\n    }\n\n    /**\n     * The current playback time of the sound, in seconds.\n     */\n    public get currentTime(): number {\n        const instance = this._getNewestInstance();\n        return instance ? instance.currentTime : 0;\n    }\n\n    public set currentTime(value: number) {\n        this.startOffset = value;\n\n        const instance = this._getNewestInstance();\n        if (instance) {\n            instance.currentTime = value;\n        }\n    }\n\n    /**\n     * Whether the sound should loop. Defaults to `false`.\n     */\n    public get loop(): boolean {\n        return this._options.loop;\n    }\n\n    public set loop(value: boolean) {\n        this._options.loop = value;\n    }\n\n    /**\n     * The maximum number of instances that can play at the same time. Defaults to `Infinity`.\n     */\n    public get maxInstances(): number {\n        return this._options.maxInstances;\n    }\n\n    public set maxInstances(value: number) {\n        this._options.maxInstances = value;\n    }\n\n    /**\n     * The time within the sound buffer to start playing at, in seconds. Defaults to `0`.\n     */\n    public get startOffset(): number {\n        return this._options.startOffset;\n    }\n\n    public set startOffset(value: number) {\n        this._options.startOffset = value;\n    }\n\n    /**\n     * The state of the sound.\n     */\n    public get state(): SoundState {\n        return this._state;\n    }\n\n    /**\n     * Releases associated resources.\n     */\n    public override dispose(): void {\n        super.dispose();\n\n        this.stop();\n\n        this._newestInstance = null;\n\n        this._privateInstances.clear();\n        this.onEndedObservable.clear();\n    }\n\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    public abstract play(options?: Partial<IAbstractSoundPlayOptions>): void;\n\n    /**\n     * Pauses the sound.\n     */\n    public pause(): void {\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.pause();\n        }\n\n        this._state = SoundState.Paused;\n    }\n\n    /**\n     * Resumes the sound.\n     */\n    public resume(): void {\n        if (this._state !== SoundState.Paused) {\n            return;\n        }\n\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.resume();\n        }\n\n        this._state = SoundState.Started;\n    }\n\n    /**\n     * Stops the sound.\n     * - Triggers `onEndedObservable` if the sound is playing.\n     */\n    public abstract stop(): void;\n\n    protected _beforePlay(instance: _AbstractSoundInstance): void {\n        if (this.state === SoundState.Paused && this._instances.size > 0) {\n            this.resume();\n            return;\n        }\n\n        instance.onEndedObservable.addOnce(this._onInstanceEnded);\n        this._privateInstances.add(instance);\n        this._newestInstance = instance;\n    }\n\n    protected _afterPlay(instance: _AbstractSoundInstance): void {\n        this._state = instance.state;\n    }\n\n    protected _getNewestInstance(): Nullable<_AbstractSoundInstance> {\n        if (this._instances.size === 0) {\n            return null;\n        }\n\n        if (!this._newestInstance) {\n            const it = this._instances.values();\n            for (let next = it.next(); !next.done; next = it.next()) {\n                this._newestInstance = next.value;\n            }\n        }\n\n        return this._newestInstance;\n    }\n\n    protected _setState(state: SoundState): void {\n        this._state = state;\n    }\n\n    protected abstract _createInstance(): _AbstractSoundInstance;\n\n    protected _stopExcessInstances(): void {\n        if (this.maxInstances < Infinity) {\n            const numberOfInstancesToStop = Array.from(this._instances).filter((instance) => instance.state === SoundState.Started).length - this.maxInstances;\n            const it = this._instances.values();\n\n            for (let i = 0; i < numberOfInstancesToStop; i++) {\n                const instance = it.next().value;\n                instance.stop();\n            }\n        }\n    }\n\n    private _onInstanceEnded: (instance: _AbstractSoundInstance) => void = (instance) => {\n        if (this._newestInstance === instance) {\n            this._newestInstance = null;\n        }\n\n        this._privateInstances.delete(instance);\n\n        if (this._instances.size === 0) {\n            this._state = SoundState.Stopped;\n            this.onEndedObservable.notifyObservers(this);\n        }\n\n        instance.dispose();\n    };\n}\n", "import { Observable } from \"../../Misc/observable\";\nimport { SoundState } from \"../soundState\";\nimport { AbstractAudioNode, AudioNodeType } from \"./abstractAudioNode\";\nimport type { AbstractSound, IAbstractSoundPlayOptions, IAbstractSoundPlayOptionsBase } from \"./abstractSound\";\n\n/**\n * Options for creating a sound instance.\n * @internal\n * */\nexport interface IAbstractSoundInstanceOptions extends IAbstractSoundPlayOptionsBase {}\n\n/** @internal */\nexport abstract class _AbstractSoundInstance extends AbstractAudioNode {\n    protected _sound: AbstractSound;\n    protected _state: SoundState = SoundState.Stopped;\n\n    /** Observable triggered when the sound instance's playback ends */\n    public readonly onEndedObservable = new Observable<_AbstractSoundInstance>();\n\n    /** Observable triggered if the sound instance encounters an error and can not be played */\n    public readonly onErrorObservable = new Observable<any>();\n\n    /** Observable triggered when the sound instance's state changes */\n    public readonly onStateChangedObservable = new Observable<_AbstractSoundInstance>();\n\n    protected abstract readonly _options: IAbstractSoundInstanceOptions;\n\n    protected constructor(sound: AbstractSound) {\n        super(sound.engine, AudioNodeType.HAS_OUTPUTS);\n\n        this._sound = sound;\n    }\n\n    public abstract currentTime: number;\n\n    public abstract readonly startTime: number;\n\n    /** The playback state of the sound instance */\n    public get state(): SoundState {\n        return this._state;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n        this.stop();\n        this.onEndedObservable.clear();\n        this.onStateChangedObservable.clear();\n    }\n\n    public abstract play(options: Partial<IAbstractSoundPlayOptions>): void;\n    public abstract pause(): void;\n    public abstract resume(): void;\n    public abstract stop(): void;\n\n    protected _setState(value: SoundState) {\n        if (this._state === value) {\n            return;\n        }\n\n        this._state = value;\n        this.onStateChangedObservable.notifyObservers(this);\n\n        if (this._state === SoundState.Stopped) {\n            this.onEndedObservable.notifyObservers(this);\n        }\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA,IAoDsB;AApDtB;;;AAKA;AA+CM,IAAgB,gBAAhB,cAAsC,oBAAmB;MAa3D,YAAsB,MAAc,QAAuB,SAAuC;AAC9F;UAAM;UAAM;UAAQ;UAAO;;QAAA;AAbvB,aAAA,kBAAoD;AACpD,aAAA,oBAAoB,oBAAI,IAAG;AAC3B,aAAA,SAAM;AAEJ,aAAA,aAAkD,KAAK;AAMjD,aAAA,oBAAoB,IAAI,WAAU;AAoL1C,aAAA,mBAA+D,CAAC,aAAY;AAChF,cAAI,KAAK,oBAAoB,UAAU;AACnC,iBAAK,kBAAkB;UAC3B;AAEA,eAAK,kBAAkB,OAAO,QAAQ;AAEtC,cAAI,KAAK,WAAW,SAAS,GAAG;AAC5B,iBAAK,SAAM;AACX,iBAAK,kBAAkB,gBAAgB,IAAI;UAC/C;AAEA,mBAAS,QAAO;QACpB;MA7LA;;;;MAKA,IAAW,uBAAoB;AAC3B,eAAO,KAAK,WAAW;MAC3B;;;;MAKA,IAAW,WAAQ;AACf,eAAO,KAAK,SAAS;MACzB;;;;MAKA,IAAW,cAAW;AAClB,cAAM,WAAW,KAAK,mBAAkB;AACxC,eAAO,WAAW,SAAS,cAAc;MAC7C;MAEA,IAAW,YAAY,OAAa;AAChC,aAAK,cAAc;AAEnB,cAAM,WAAW,KAAK,mBAAkB;AACxC,YAAI,UAAU;AACV,mBAAS,cAAc;QAC3B;MACJ;;;;MAKA,IAAW,OAAI;AACX,eAAO,KAAK,SAAS;MACzB;MAEA,IAAW,KAAK,OAAc;AAC1B,aAAK,SAAS,OAAO;MACzB;;;;MAKA,IAAW,eAAY;AACnB,eAAO,KAAK,SAAS;MACzB;MAEA,IAAW,aAAa,OAAa;AACjC,aAAK,SAAS,eAAe;MACjC;;;;MAKA,IAAW,cAAW;AAClB,eAAO,KAAK,SAAS;MACzB;MAEA,IAAW,YAAY,OAAa;AAChC,aAAK,SAAS,cAAc;MAChC;;;;MAKA,IAAW,QAAK;AACZ,eAAO,KAAK;MAChB;;;;MAKgB,UAAO;AACnB,cAAM,QAAO;AAEb,aAAK,KAAI;AAET,aAAK,kBAAkB;AAEvB,aAAK,kBAAkB,MAAK;AAC5B,aAAK,kBAAkB,MAAK;MAChC;;;;MAYO,QAAK;AACR,cAAM,KAAK,KAAK,WAAW,OAAM;AACjC,iBAAS,OAAO,GAAG,KAAI,GAAI,CAAC,KAAK,MAAM,OAAO,GAAG,KAAI,GAAI;AACrD,eAAK,MAAM,MAAK;QACpB;AAEA,aAAK,SAAM;MACf;;;;MAKO,SAAM;AACT,YAAI,KAAK,WAAM,GAAwB;AACnC;QACJ;AAEA,cAAM,KAAK,KAAK,WAAW,OAAM;AACjC,iBAAS,OAAO,GAAG,KAAI,GAAI,CAAC,KAAK,MAAM,OAAO,GAAG,KAAI,GAAI;AACrD,eAAK,MAAM,OAAM;QACrB;AAEA,aAAK,SAAM;MACf;MAQU,YAAY,UAAgC;AAClD,YAAI,KAAK,UAAK,KAA0B,KAAK,WAAW,OAAO,GAAG;AAC9D,eAAK,OAAM;AACX;QACJ;AAEA,iBAAS,kBAAkB,QAAQ,KAAK,gBAAgB;AACxD,aAAK,kBAAkB,IAAI,QAAQ;AACnC,aAAK,kBAAkB;MAC3B;MAEU,WAAW,UAAgC;AACjD,aAAK,SAAS,SAAS;MAC3B;MAEU,qBAAkB;AACxB,YAAI,KAAK,WAAW,SAAS,GAAG;AAC5B,iBAAO;QACX;AAEA,YAAI,CAAC,KAAK,iBAAiB;AACvB,gBAAM,KAAK,KAAK,WAAW,OAAM;AACjC,mBAAS,OAAO,GAAG,KAAI,GAAI,CAAC,KAAK,MAAM,OAAO,GAAG,KAAI,GAAI;AACrD,iBAAK,kBAAkB,KAAK;UAChC;QACJ;AAEA,eAAO,KAAK;MAChB;MAEU,UAAU,OAAiB;AACjC,aAAK,SAAS;MAClB;MAIU,uBAAoB;AAC1B,YAAI,KAAK,eAAe,UAAU;AAC9B,gBAAM,0BAA0B,MAAM,KAAK,KAAK,UAAU,EAAE;YAAO,CAAC,aAAa,SAAS,UAAK;;UAAuB,EAAE,SAAS,KAAK;AACtI,gBAAM,KAAK,KAAK,WAAW,OAAM;AAEjC,mBAAS,IAAI,GAAG,IAAI,yBAAyB,KAAK;AAC9C,kBAAM,WAAW,GAAG,KAAI,EAAG;AAC3B,qBAAS,KAAI;UACjB;QACJ;MACJ;;;;;;ACjPJ,IAYsB;AAZtB;;;AAEA;AAUM,IAAgB,yBAAhB,cAA+C,kBAAiB;MAelE,YAAsB,OAAoB;AACtC;UAAM,MAAM;UAAM;;QAAA;AAdZ,aAAA,SAAM;AAGA,aAAA,oBAAoB,IAAI,WAAU;AAGlC,aAAA,oBAAoB,IAAI,WAAU;AAGlC,aAAA,2BAA2B,IAAI,WAAU;AAOrD,aAAK,SAAS;MAClB;;MAOA,IAAW,QAAK;AACZ,eAAO,KAAK;MAChB;;MAGgB,UAAO;AACnB,cAAM,QAAO;AACb,aAAK,KAAI;AACT,aAAK,kBAAkB,MAAK;AAC5B,aAAK,yBAAyB,MAAK;MACvC;MAOU,UAAU,OAAiB;AACjC,YAAI,KAAK,WAAW,OAAO;AACvB;QACJ;AAEA,aAAK,SAAS;AACd,aAAK,yBAAyB,gBAAgB,IAAI;AAElD,YAAI,KAAK,WAAM,GAAyB;AACpC,eAAK,kBAAkB,gBAAgB,IAAI;QAC/C;MACJ;;;;",
  "names": []
}
