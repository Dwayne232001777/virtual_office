{
  "version": 3,
  "sources": ["../../../dev/core/src/AudioV2/abstractAudio/staticSound.ts", "../../../dev/core/src/AudioV2/abstractAudio/staticSoundBuffer.ts", "../../../dev/core/src/AudioV2/abstractAudio/staticSoundInstance.ts", "../../../dev/core/src/AudioV2/webAudio/webAudioStaticSound.ts"],
  "sourcesContent": ["import type { Nullable } from \"../../types\";\nimport { SoundState } from \"../soundState\";\nimport type { IAbstractSoundOptions, IAbstractSoundPlayOptions, IAbstractSoundStoredOptions } from \"./abstractSound\";\nimport { AbstractSound } from \"./abstractSound\";\nimport type { PrimaryAudioBus } from \"./audioBus\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { IStaticSoundBufferOptions, StaticSoundBuffer } from \"./staticSoundBuffer\";\nimport type { _StaticSoundInstance } from \"./staticSoundInstance\";\n\n/** @internal */\nexport interface IStaticSoundOptionsBase {\n    /**\n     * The amount of time to play the sound for, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the sound plays for its full duration.\n     */\n    duration: number;\n    /**\n     * The end of the loop range in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop plays for the sound's full duration.\n     * - Has no effect if {@link loop} is `false`.\n     */\n    loopEnd: number;\n    /**\n     * The start of the loop range in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop starts at the beginning of the sound.\n     * - Has no effect if {@link loop} is `false`.\n     *\n     */\n    loopStart: number;\n}\n\n/**\n * Options stored in a static sound.\n * @internal\n */\nexport interface IStaticSoundStoredOptions extends IAbstractSoundStoredOptions, IStaticSoundOptionsBase {\n    /**\n     * The pitch of the sound, in cents. Defaults to `0`.\n     * - Can be combined with {@link playbackRate}.\n     */\n    pitch: number;\n    /**\n     * The playback rate of the sound. Defaults to `1`.\n     * - Can be combined with {@link pitch}.\n     */\n    playbackRate: number;\n}\n\n/**\n * Options for creating a static sound.\n */\nexport interface IStaticSoundOptions extends IAbstractSoundOptions, IStaticSoundBufferOptions, IStaticSoundStoredOptions {}\n\n/**\n * Options for playing a static sound.\n */\nexport interface IStaticSoundPlayOptions extends IAbstractSoundPlayOptions, IStaticSoundOptionsBase {\n    /**\n     * The time to wait before playing the sound, in seconds. Defaults to `0`.\n     */\n    waitTime: number;\n}\n\n/**\n * Options for stopping a static sound.\n */\nexport interface IStaticSoundStopOptions {\n    /**\n     * The time to wait before stopping the sound, in seconds. Defaults to `0`.\n     */\n    waitTime: number;\n}\n\n/**\n * Options for cloning a static sound.\n * - @see {@link StaticSound.clone}.\n */\nexport interface IStaticSoundCloneOptions {\n    /**\n     * Whether to clone the sound buffer when cloning the sound. Defaults to `false`.\n     * - If `true`, the original sound's buffer is cloned, and the cloned sound will use its own copy.\n     * - If `false`, the sound buffer is shared with the original sound.\n     */\n    cloneBuffer: boolean;\n\n    /**\n     * The output bus for the cloned sound. Defaults to `null`.\n     * - If not set or `null`, the cloned sound uses the original sound's `outBus`.\n     * @see {@link AudioEngineV2.defaultMainBus}\n     */\n    outBus: Nullable<PrimaryAudioBus>;\n}\n\n/**\n * Abstract class representing a static sound.\n *\n * A static sound has a sound buffer that is loaded into memory all at once. This allows it to have more capabilities\n * than a streaming sound, such as loop points and playback rate changes, but it also means that the sound must be\n * fully downloaded and decoded before it can be played, which may take a long time for sounds with long durations.\n *\n * To prevent downloading and decoding a sound multiple times, a sound's buffer can be shared with other sounds.\n * See {@link CreateSoundBufferAsync}, {@link StaticSoundBuffer} and {@link StaticSound.buffer} for more information.\n *\n * Static sounds are created by the {@link CreateSoundAsync} function.\n */\nexport abstract class StaticSound extends AbstractSound {\n    protected override _instances: Set<_StaticSoundInstance>;\n    protected abstract override readonly _options: IStaticSoundStoredOptions;\n\n    /**\n     * The sound buffer that the sound uses.\n     *\n     * This buffer can be shared with other static sounds.\n     */\n    public abstract readonly buffer: StaticSoundBuffer;\n\n    protected constructor(name: string, engine: AudioEngineV2, options: Partial<IStaticSoundOptions>) {\n        super(name, engine, options);\n    }\n\n    /**\n     * The amount of time to play the sound for, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the sound plays for its full duration.\n     */\n    public get duration(): number {\n        return this._options.duration;\n    }\n\n    public set duration(value: number) {\n        this._options.duration = value;\n    }\n\n    /**\n     * The start of the loop range, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop starts at the beginning of the sound.\n     */\n    public get loopStart(): number {\n        return this._options.loopStart;\n    }\n\n    public set loopStart(value: number) {\n        this._options.loopStart = value;\n    }\n\n    /**\n     * The end of the loop range, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop plays for the sound's full duration.\n     */\n    public get loopEnd(): number {\n        return this._options.loopEnd;\n    }\n\n    public set loopEnd(value: number) {\n        this._options.loopEnd = value;\n    }\n\n    /**\n     * The pitch of the sound, in cents. Defaults to `0`.\n     * - Gets combined with {@link playbackRate} to determine the final pitch.\n     */\n    public get pitch(): number {\n        return this._options.pitch;\n    }\n\n    public set pitch(value: number) {\n        this._options.pitch = value;\n\n        const it = this._instances.values();\n        for (let instance = it.next(); !instance.done; instance = it.next()) {\n            instance.value.pitch = value;\n        }\n    }\n\n    /**\n     * The playback rate of the sound. Defaults to `1`.\n     * - Gets combined with {@link pitch} to determine the final playback rate.\n     */\n    public get playbackRate(): number {\n        return this._options.playbackRate;\n    }\n\n    public set playbackRate(value: number) {\n        this._options.playbackRate = value;\n\n        const it = this._instances.values();\n        for (let instance = it.next(); !instance.done; instance = it.next()) {\n            instance.value.playbackRate = value;\n        }\n    }\n\n    /**\n     * Clones the sound.\n     * @param options Options for cloning the sound.\n     */\n    public abstract cloneAsync(options?: Partial<IStaticSoundCloneOptions>): Promise<StaticSound>;\n\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    public play(options: Partial<IStaticSoundPlayOptions> = {}): void {\n        if (this.state === SoundState.Paused) {\n            this.resume();\n            return;\n        }\n\n        options.duration ??= this.duration;\n        options.loop ??= this.loop;\n        options.loopStart ??= this.loopStart;\n        options.loopEnd ??= this.loopEnd;\n        options.startOffset ??= this.startOffset;\n        options.volume ??= 1;\n        options.waitTime ??= 0;\n\n        const instance = this._createInstance();\n        this._beforePlay(instance);\n        instance.play(options);\n        this._afterPlay(instance);\n\n        this._stopExcessInstances();\n    }\n\n    /**\n     * Stops the sound.\n     * - Triggers `onEndedObservable` if the sound is playing.\n     * @param options - The options to use when stopping the sound.\n     */\n    public stop(options: Partial<IStaticSoundStopOptions> = {}): void {\n        if (options.waitTime && 0 < options.waitTime) {\n            this._setState(SoundState.Stopping);\n        } else {\n            this._setState(SoundState.Stopped);\n        }\n\n        if (!this._instances) {\n            return;\n        }\n\n        for (const instance of Array.from(this._instances)) {\n            instance.stop(options);\n        }\n    }\n\n    protected abstract override _createInstance(): _StaticSoundInstance;\n}\n", "import type { AudioEngineV2 } from \"./audioEngineV2\";\n\nlet StaticSoundBufferId = 1;\n\n/**\n * Options for creating a static sound buffer.\n */\nexport interface IStaticSoundBufferOptions {\n    /**\n     * Whether to skip codec checking before attempting to load each source URL when `source` is a string array. Defaults to `false`.\n     * - Has no effect if the sound's source is not a string array.\n     * @see {@link CreateSoundAsync} `source` parameter.\n     */\n    skipCodecCheck: boolean;\n}\n\n/**\n * Options for cloning a static sound buffer.\n * - @see {@link StaticSoundBuffer.clone}.\n */\nexport interface IStaticSoundBufferCloneOptions {\n    /**\n     * The name of the cloned sound buffer. Defaults to `StaticSoundBuffer #${id}`.\n     */\n    name: string;\n}\n\n/**\n * Abstract class representing a static sound buffer.\n *\n * A static sound buffer is a fully downloaded and decoded array of audio data that is ready to be played.\n *\n * Static sound buffers can be reused multiple times by different {@link StaticSound} instances.\n *\n * Static sound buffers are created by the {@link CreateSoundBufferAsync} function.\n *\n * @see {@link StaticSound.buffer}\n */\nexport abstract class StaticSoundBuffer {\n    /**\n     * The engine that the sound buffer belongs to.\n     */\n    public readonly engine: AudioEngineV2;\n\n    /**\n     * The name of the sound buffer.\n     */\n    public name: string = `StaticSoundBuffer #${StaticSoundBufferId++}`;\n\n    protected constructor(engine: AudioEngineV2) {\n        this.engine = engine;\n    }\n\n    /**\n     * The sample rate of the sound buffer.\n     */\n    public abstract readonly sampleRate: number;\n\n    /**\n     * The length of the sound buffer, in sample frames.\n     */\n    public abstract readonly length: number;\n\n    /**\n     * The duration of the sound buffer, in seconds.\n     */\n    public abstract readonly duration: number;\n\n    /**\n     * The number of channels in the sound buffer.\n     */\n    public abstract readonly channelCount: number;\n\n    /**\n     * Clones the sound buffer.\n     * @param options Options for cloning the sound buffer.\n     */\n    public abstract clone(options?: Partial<IStaticSoundBufferCloneOptions>): StaticSoundBuffer;\n}\n", "import type { IAbstractSoundInstanceOptions } from \"./abstractSoundInstance\";\nimport { _AbstractSoundInstance } from \"./abstractSoundInstance\";\nimport type { IStaticSoundOptionsBase, IStaticSoundPlayOptions, IStaticSoundStopOptions } from \"./staticSound\";\n\n/**\n * Options for creating a static sound instance.\n * @internal\n */\nexport interface IStaticSoundInstanceOptions extends IAbstractSoundInstanceOptions, IStaticSoundOptionsBase {}\n\n/** @internal */\nexport abstract class _StaticSoundInstance extends _AbstractSoundInstance {\n    protected abstract override readonly _options: IStaticSoundInstanceOptions;\n\n    public abstract pitch: number;\n    public abstract playbackRate: number;\n\n    public abstract override play(options: Partial<IStaticSoundPlayOptions>): void;\n    public abstract override stop(options?: Partial<IStaticSoundStopOptions>): void;\n}\n", "import type { Nullable } from \"../../types\";\nimport type { AbstractAudioNode } from \"../abstractAudio/abstractAudioNode\";\nimport type { IStaticSoundCloneOptions, IStaticSoundOptions, IStaticSoundPlayOptions, IStaticSoundStopOptions, IStaticSoundStoredOptions } from \"../abstractAudio/staticSound\";\nimport { StaticSound } from \"../abstractAudio/staticSound\";\nimport type { IStaticSoundBufferCloneOptions, IStaticSoundBufferOptions } from \"../abstractAudio/staticSoundBuffer\";\nimport { StaticSoundBuffer } from \"../abstractAudio/staticSoundBuffer\";\nimport type { IStaticSoundInstanceOptions } from \"../abstractAudio/staticSoundInstance\";\nimport { _StaticSoundInstance } from \"../abstractAudio/staticSoundInstance\";\nimport { _HasSpatialAudioOptions, type AbstractSpatialAudio } from \"../abstractAudio/subProperties/abstractSpatialAudio\";\nimport { _StereoAudio } from \"../abstractAudio/subProperties/stereoAudio\";\nimport { _CleanUrl, _FileExtensionRegex } from \"../audioUtils\";\nimport { SoundState } from \"../soundState\";\nimport { _WebAudioParameterComponent } from \"./components/webAudioParameterComponent\";\nimport { _WebAudioBusAndSoundSubGraph } from \"./subNodes/webAudioBusAndSoundSubGraph\";\nimport { _SpatialWebAudio } from \"./subProperties/spatialWebAudio\";\nimport type { _WebAudioEngine } from \"./webAudioEngine\";\nimport type { IWebAudioInNode, IWebAudioOutNode, IWebAudioSuperNode } from \"./webAudioNode\";\n\ntype StaticSoundSourceType = ArrayBuffer | AudioBuffer | StaticSoundBuffer | string | string[];\n\n/** @internal */\nexport class _WebAudioStaticSound extends StaticSound implements IWebAudioSuperNode {\n    private _buffer: _WebAudioStaticSoundBuffer;\n    private _stereo: Nullable<_StereoAudio> = null;\n\n    protected override readonly _options: IStaticSoundStoredOptions;\n    protected _subGraph: _WebAudioBusAndSoundSubGraph;\n\n    /** @internal */\n    public _audioContext: AudioContext | OfflineAudioContext;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public constructor(name: string, engine: _WebAudioEngine, options: Partial<IStaticSoundOptions>) {\n        super(name, engine, options);\n\n        this._options = {\n            autoplay: options.autoplay ?? false,\n            duration: options.duration ?? 0,\n            loop: options.loop ?? false,\n            loopEnd: options.loopEnd ?? 0,\n            loopStart: options.loopStart ?? 0,\n            maxInstances: options.maxInstances ?? Infinity,\n            pitch: options.pitch ?? 0,\n            playbackRate: options.playbackRate ?? 1,\n            startOffset: options.startOffset ?? 0,\n        };\n\n        this._subGraph = new _WebAudioStaticSound._SubGraph(this);\n    }\n\n    /** @internal */\n    public async _initAsync(source: StaticSoundSourceType, options: Partial<IStaticSoundOptions>): Promise<void> {\n        this._audioContext = this.engine._audioContext;\n\n        if (source instanceof _WebAudioStaticSoundBuffer) {\n            this._buffer = source;\n        } else if (typeof source === \"string\" || Array.isArray(source) || source instanceof ArrayBuffer || source instanceof AudioBuffer) {\n            this._buffer = (await this.engine.createSoundBufferAsync(source, options)) as _WebAudioStaticSoundBuffer;\n        }\n\n        if (options.outBus) {\n            this.outBus = options.outBus;\n        } else if (options.outBusAutoDefault !== false) {\n            await this.engine.isReadyPromise;\n            this.outBus = this.engine.defaultMainBus;\n        }\n\n        await this._subGraph.initAsync(options);\n\n        if (_HasSpatialAudioOptions(options)) {\n            this._initSpatialProperty();\n        }\n\n        if (options.autoplay) {\n            this.play();\n        }\n\n        this.engine._addSound(this);\n    }\n\n    /** @internal */\n    public get buffer(): _WebAudioStaticSoundBuffer {\n        return this._buffer;\n    }\n\n    /** @internal */\n    public get _inNode() {\n        return this._subGraph._inNode;\n    }\n\n    /** @internal */\n    public get _outNode() {\n        return this._subGraph._outNode;\n    }\n\n    /** @internal */\n    public override get stereo(): _StereoAudio {\n        return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));\n    }\n\n    /** @internal */\n    public override async cloneAsync(options: Nullable<Partial<IStaticSoundCloneOptions>> = null): Promise<StaticSound> {\n        const clone = await this.engine.createSoundAsync(this.name, options?.cloneBuffer ? this.buffer.clone() : this.buffer, this._options);\n\n        clone.outBus = options?.outBus ? options.outBus : this.outBus;\n\n        return clone;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._stereo = null;\n\n        this._subGraph.dispose();\n\n        this.engine._removeSound(this);\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioStaticSound\";\n    }\n\n    protected _createInstance(): _WebAudioStaticSoundInstance {\n        return new _WebAudioStaticSoundInstance(this, this._options);\n    }\n\n    protected override _connect(node: IWebAudioInNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: IWebAudioInNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _createSpatialProperty(autoUpdate: boolean, minUpdateTime: number): AbstractSpatialAudio {\n        return new _SpatialWebAudio(this._subGraph, autoUpdate, minUpdateTime);\n    }\n\n    public _getOptions(): IStaticSoundStoredOptions {\n        return this._options;\n    }\n\n    private static _SubGraph = class extends _WebAudioBusAndSoundSubGraph {\n        protected override _owner: _WebAudioStaticSound;\n\n        protected get _downstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._downstreamNodes ?? null;\n        }\n\n        protected get _upstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._upstreamNodes ?? null;\n        }\n    };\n}\n\n/** @internal */\nexport class _WebAudioStaticSoundBuffer extends StaticSoundBuffer {\n    /** @internal */\n    public _audioBuffer: AudioBuffer;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public constructor(engine: _WebAudioEngine) {\n        super(engine);\n    }\n\n    public async _initAsync(source: StaticSoundSourceType, options: Partial<IStaticSoundBufferOptions>): Promise<void> {\n        if (source instanceof AudioBuffer) {\n            this._audioBuffer = source;\n        } else if (typeof source === \"string\") {\n            await this._initFromUrlAsync(source);\n        } else if (Array.isArray(source)) {\n            await this._initFromUrlsAsync(source, options.skipCodecCheck ?? false);\n        } else if (source instanceof ArrayBuffer) {\n            await this._initFromArrayBufferAsync(source);\n        }\n    }\n\n    /** @internal */\n    public get channelCount(): number {\n        return this._audioBuffer.numberOfChannels;\n    }\n\n    /** @internal */\n    public get duration(): number {\n        return this._audioBuffer.duration;\n    }\n\n    /** @internal */\n    public get length(): number {\n        return this._audioBuffer.length;\n    }\n\n    /** @internal */\n    public get sampleRate(): number {\n        return this._audioBuffer.sampleRate;\n    }\n\n    /** @internal */\n    public override clone(options: Nullable<Partial<IStaticSoundBufferCloneOptions>> = null): StaticSoundBuffer {\n        const audioBuffer = new AudioBuffer({\n            length: this._audioBuffer.length,\n            numberOfChannels: this._audioBuffer.numberOfChannels,\n            sampleRate: this._audioBuffer.sampleRate,\n        });\n\n        for (let i = 0; i < this._audioBuffer.numberOfChannels; i++) {\n            audioBuffer.copyToChannel(this._audioBuffer.getChannelData(i), i);\n        }\n\n        const buffer = new _WebAudioStaticSoundBuffer(this.engine);\n        buffer._audioBuffer = audioBuffer;\n        buffer.name = options?.name ? options.name : this.name;\n\n        return buffer;\n    }\n\n    private async _initFromArrayBufferAsync(arrayBuffer: ArrayBuffer): Promise<void> {\n        this._audioBuffer = await this.engine._audioContext.decodeAudioData(arrayBuffer);\n    }\n\n    private async _initFromUrlAsync(url: string): Promise<void> {\n        url = _CleanUrl(url);\n        await this._initFromArrayBufferAsync(await (await fetch(url)).arrayBuffer());\n    }\n\n    private async _initFromUrlsAsync(urls: string[], skipCodecCheck: boolean): Promise<void> {\n        for (const url of urls) {\n            if (skipCodecCheck) {\n                // eslint-disable-next-line no-await-in-loop\n                await this._initFromUrlAsync(url);\n            } else {\n                const matches = url.match(_FileExtensionRegex);\n                const format = matches?.at(1);\n                if (format && this.engine.isFormatValid(format)) {\n                    try {\n                        // eslint-disable-next-line no-await-in-loop\n                        await this._initFromUrlAsync(url);\n                    } catch {\n                        if (format && 0 < format.length) {\n                            this.engine.flagInvalidFormat(format);\n                        }\n                    }\n                }\n            }\n\n            if (this._audioBuffer) {\n                break;\n            }\n        }\n    }\n}\n\n/** @internal */\nclass _WebAudioStaticSoundInstance extends _StaticSoundInstance implements IWebAudioOutNode {\n    private _enginePlayTime: number = 0;\n    private _enginePauseTime: number = 0;\n    private _isConnected: boolean = false;\n    private _pitch: Nullable<_WebAudioParameterComponent> = null;\n    private _playbackRate: Nullable<_WebAudioParameterComponent> = null;\n    private _sourceNode: Nullable<AudioBufferSourceNode> = null;\n    private _volumeNode: GainNode;\n\n    protected override readonly _options: IStaticSoundInstanceOptions;\n    protected override _sound: _WebAudioStaticSound;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    public constructor(sound: _WebAudioStaticSound, options: IStaticSoundInstanceOptions) {\n        super(sound);\n\n        this._options = options;\n\n        this._volumeNode = new GainNode(sound._audioContext);\n        this._initSourceNode();\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._pitch?.dispose();\n        this._playbackRate?.dispose();\n\n        this._sourceNode = null;\n\n        this.stop();\n\n        this._deinitSourceNode();\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n\n    /** @internal */\n    public get currentTime(): number {\n        if (this._state === SoundState.Stopped) {\n            return 0;\n        }\n\n        const timeSinceLastStart = this._state === SoundState.Paused ? 0 : this.engine.currentTime - this._enginePlayTime;\n        return this._enginePauseTime + timeSinceLastStart + this._options.startOffset;\n    }\n\n    public set currentTime(value: number) {\n        const restart = this._state === SoundState.Starting || this._state === SoundState.Started;\n\n        if (restart) {\n            // Stop source node without sending `onEndedObservable` so instance's `dispose` function is not called.\n            const sourceNode = this._sourceNode;\n            this._deinitSourceNode();\n            sourceNode?.stop();\n            this._state = SoundState.Stopped;\n        }\n\n        if (this.state === SoundState.Paused) {\n            this._enginePauseTime = 0;\n        }\n\n        this._options.startOffset = value;\n\n        if (restart) {\n            this.play();\n        }\n    }\n\n    public get _outNode(): Nullable<AudioNode> {\n        return this._volumeNode;\n    }\n\n    /** @internal */\n    public set pitch(value: number) {\n        this._pitch?.setTargetValue(value);\n    }\n\n    /** @internal */\n    public set playbackRate(value: number) {\n        this._playbackRate?.setTargetValue(value);\n    }\n\n    /** @internal */\n    public get startTime(): number {\n        if (this._state === SoundState.Stopped) {\n            return 0;\n        }\n\n        return this._enginePlayTime;\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioStaticSoundInstance\";\n    }\n\n    /** @internal */\n    public play(options: Partial<IStaticSoundPlayOptions> = {}): void {\n        if (this._state === SoundState.Started) {\n            return;\n        }\n\n        if (options.duration !== undefined) {\n            this._options.duration = options.duration;\n        }\n        if (options.loop !== undefined) {\n            this._options.loop = options.loop;\n        }\n        if (options.loopStart !== undefined) {\n            this._options.loopStart = options.loopStart;\n        }\n        if (options.loopEnd !== undefined) {\n            this._options.loopEnd = options.loopEnd;\n        }\n        if (options.startOffset !== undefined) {\n            this._options.startOffset = options.startOffset;\n        }\n\n        let startOffset = this._options.startOffset;\n\n        if (this._state === SoundState.Paused) {\n            startOffset += this._enginePauseTime;\n            startOffset %= this._sound.buffer.duration;\n        }\n\n        this._enginePlayTime = this.engine.currentTime + (options.waitTime ?? 0);\n\n        this._volumeNode.gain.value = options.volume ?? 1;\n\n        this._initSourceNode();\n\n        if (this.engine.state === \"running\") {\n            this._setState(SoundState.Started);\n            this._sourceNode?.start(this._enginePlayTime, startOffset, this._options.duration > 0 ? this._options.duration : undefined);\n        } else if (this._options.loop) {\n            this._setState(SoundState.Starting);\n            this.engine.stateChangedObservable.add(this._onEngineStateChanged);\n        }\n    }\n\n    /** @internal */\n    public pause(): void {\n        if (this._state === SoundState.Paused) {\n            return;\n        }\n\n        this._setState(SoundState.Paused);\n        this._enginePauseTime += this.engine.currentTime - this._enginePlayTime;\n\n        if (this._state === SoundState.Started) {\n            this._sourceNode?.stop();\n        } else {\n            this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        }\n\n        this._deinitSourceNode();\n    }\n\n    /** @internal */\n    public resume(): void {\n        if (this._state === SoundState.Paused) {\n            this.play();\n        }\n    }\n\n    /** @internal */\n    public stop(options: Partial<IStaticSoundStopOptions> = {}): void {\n        if (this._state === SoundState.Stopped) {\n            return;\n        }\n\n        if (this._state === SoundState.Started) {\n            const engineStopTime = this.engine.currentTime + (options.waitTime ?? 0);\n            this._sourceNode?.stop(engineStopTime);\n        }\n\n        if (options.waitTime === undefined || options.waitTime <= 0) {\n            this._setState(SoundState.Stopped);\n            this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        }\n    }\n\n    protected override _connect(node: AbstractAudioNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the sound's subgraph.\n        if (node instanceof _WebAudioStaticSound && node._inNode) {\n            this._outNode?.connect(node._inNode);\n            this._isConnected = true;\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: AbstractAudioNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node instanceof _WebAudioStaticSound && node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n            this._isConnected = false;\n        }\n\n        return true;\n    }\n\n    protected _onEnded = () => {\n        this._enginePlayTime = 0;\n\n        if (this._state !== SoundState.Paused) {\n            this.onEndedObservable.notifyObservers(this);\n        }\n\n        this._deinitSourceNode();\n    };\n\n    private _deinitSourceNode(): void {\n        if (!this._sourceNode) {\n            return;\n        }\n\n        if (this._isConnected && !this._disconnect(this._sound)) {\n            throw new Error(\"Disconnect failed\");\n        }\n\n        this._sourceNode.disconnect(this._volumeNode);\n        this._sourceNode.removeEventListener(\"ended\", this._onEnded);\n\n        this._sourceNode = null;\n    }\n\n    private _initSourceNode(): void {\n        if (!this._sourceNode) {\n            this._sourceNode = new AudioBufferSourceNode(this._sound._audioContext, { buffer: this._sound.buffer._audioBuffer });\n\n            this._sourceNode.addEventListener(\"ended\", this._onEnded, { once: true });\n            this._sourceNode.connect(this._volumeNode);\n\n            if (!this._connect(this._sound)) {\n                throw new Error(\"Connect failed\");\n            }\n\n            this._pitch = new _WebAudioParameterComponent(this.engine, this._sourceNode.detune);\n            this._playbackRate = new _WebAudioParameterComponent(this.engine, this._sourceNode.playbackRate);\n        }\n\n        const node = this._sourceNode;\n        node.detune.value = this._sound.pitch;\n        node.loop = this._options.loop;\n        node.loopEnd = this._options.loopEnd;\n        node.loopStart = this._options.loopStart;\n        node.playbackRate.value = this._sound.playbackRate;\n    }\n\n    private _onEngineStateChanged = () => {\n        if (this.engine.state !== \"running\") {\n            return;\n        }\n\n        if (this._options.loop && this.state === SoundState.Starting) {\n            this.play();\n        }\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    };\n}\n"],
  "mappings": "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",
  "names": []
}
