import {
  init_depthPrePass
} from "./chunk-CMM7CFN7.js";
import {
  init_lightFragment
} from "./chunk-UJGSLBTF.js";
import {
  init_shadowsVertex
} from "./chunk-NKS7E6BM.js";
import {
  init_lightFragmentDeclaration
} from "./chunk-TKNHNFWT.js";
import {
  init_lightUboDeclaration
} from "./chunk-2ZNACRAK.js";
import {
  init_lightsFragmentFunctions
} from "./chunk-X6CSUTQL.js";
import "./chunk-SORF76VU.js";
import "./chunk-ZC27AFOZ.js";
import {
  init_shadowsFragmentFunctions
} from "./chunk-OHFWKX42.js";
import {
  EffectFallbacks,
  MaterialDefines,
  PushMaterial,
  init_effectFallbacks,
  init_materialDefines,
  init_pushMaterial
} from "./chunk-OBADV6JF.js";
import {
  init_imageProcessingCompatibility
} from "./chunk-O363AM3X.js";
import "./chunk-JTDOLEW4.js";
import {
  AddClipPlaneUniforms,
  BindBonesParameters,
  BindClipPlane,
  BindFogParameters,
  BindLights,
  BindLogDepth,
  HandleFallbacksForShadows,
  MaterialFlags,
  PrepareAttributesForBones,
  PrepareAttributesForInstances,
  PrepareDefinesForAttributes,
  PrepareDefinesForFrameBoundValues,
  PrepareDefinesForLights,
  PrepareDefinesForMisc,
  PrepareUniformsAndSamplersList,
  init_clipPlaneMaterialHelper,
  init_materialFlags,
  init_materialHelper_functions
} from "./chunk-R3NLUQNA.js";
import "./chunk-Y5XTKMAE.js";
import {
  init_logDepthFragment
} from "./chunk-NCRPMFYT.js";
import {
  init_fogFragment
} from "./chunk-ORGDVUQ5.js";
import {
  init_clipPlaneFragmentDeclaration
} from "./chunk-PLE22TB7.js";
import {
  init_fogFragmentDeclaration
} from "./chunk-YGF775II.js";
import {
  init_clipPlaneFragment
} from "./chunk-OYBIGYUP.js";
import {
  init_logDepthVertex
} from "./chunk-KOTVE4EO.js";
import {
  init_fogVertex
} from "./chunk-72KUQ4IQ.js";
import {
  init_fogVertexDeclaration
} from "./chunk-V3TVNJXE.js";
import {
  init_logDepthDeclaration
} from "./chunk-IEAIFCDZ.js";
import {
  init_instancesDeclaration
} from "./chunk-V6FF32RD.js";
import {
  init_instancesVertex
} from "./chunk-DJVZAM6B.js";
import {
  init_bakedVertexAnimation,
  init_bakedVertexAnimationDeclaration
} from "./chunk-MRV6TWLW.js";
import {
  init_bonesVertex
} from "./chunk-SWFW6DYT.js";
import {
  init_clipPlaneVertex
} from "./chunk-W5UENS42.js";
import {
  init_bonesDeclaration
} from "./chunk-QYWTSVQS.js";
import {
  init_clipPlaneVertexDeclaration
} from "./chunk-VTWDYKUG.js";
import {
  init_helperFunctions
} from "./chunk-VR6S6BQH.js";
import {
  Scene,
  init_scene
} from "./chunk-U45B254N.js";
import "./chunk-CCNHJS5Q.js";
import "./chunk-FV6YI4DO.js";
import "./chunk-KEMNSKWR.js";
import "./chunk-3DVETICX.js";
import "./chunk-ETNKJY4V.js";
import "./chunk-XUMUHFKD.js";
import "./chunk-3V3ZT36M.js";
import "./chunk-TYVCVQQX.js";
import "./chunk-WJTQGE6H.js";
import "./chunk-NER52ESJ.js";
import {
  VertexBuffer,
  init_buffer
} from "./chunk-YEEYUO2W.js";
import "./chunk-LNXOCKX5.js";
import "./chunk-W2Z3EUIE.js";
import "./chunk-6DIPKSGI.js";
import {
  SerializationHelper,
  init_decorators_serialization
} from "./chunk-HNJVWIJU.js";
import {
  Color3,
  init_math_color
} from "./chunk-FQA5U7KF.js";
import {
  __decorate,
  expandToProperty,
  init_decorators,
  init_tslib_es6,
  serialize,
  serializeAsColor3,
  serializeAsTexture
} from "./chunk-KU6EWKFQ.js";
import "./chunk-TQMUJQOB.js";
import "./chunk-X7JT3LZV.js";
import "./chunk-T55R2ONV.js";
import "./chunk-PSHGEZXL.js";
import "./chunk-WTQMXJ7P.js";
import "./chunk-HCT32MRG.js";
import {
  ShaderStore,
  init_shaderStore
} from "./chunk-4OYBTWIA.js";
import "./chunk-VQZCJUUR.js";
import {
  RegisterClass,
  init_typeStore
} from "./chunk-7ANHXSNA.js";
import "./chunk-YU3PZQGE.js";
import "./chunk-TS7QJBPS.js";
import "./chunk-XBFJXXXT.js";
import "./chunk-2X44KPCK.js";
import "./chunk-PY47FUFT.js";
import "./chunk-V4OQ3NZ2.js";

// node_modules/@babylonjs/materials/normal/normalMaterial.js
init_tslib_es6();
init_decorators();
init_decorators_serialization();
init_math_color();
init_materialDefines();
init_pushMaterial();
init_materialFlags();
init_buffer();
init_scene();
init_typeStore();

// node_modules/@babylonjs/materials/normal/normal.fragment.js
init_shaderStore();
init_helperFunctions();
init_lightFragmentDeclaration();
init_lightUboDeclaration();
init_lightsFragmentFunctions();
init_shadowsFragmentFunctions();
init_clipPlaneFragmentDeclaration();
init_logDepthDeclaration();
init_fogFragmentDeclaration();
init_clipPlaneFragment();
init_depthPrePass();
init_lightFragment();
init_logDepthFragment();
init_fogFragment();
init_imageProcessingCompatibility();
var name = "normalPixelShader";
var shader = `precision highp float;uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef LIGHTING
#include<helperFunctions>
#include<__decl__lightFragment>[0]
#include<__decl__lightFragment>[1]
#include<__decl__lightFragment>[2]
#include<__decl__lightFragment>[3]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#endif
#ifdef DIFFUSE
varying vec2 vDiffuseUV;uniform sampler2D diffuseSampler;uniform vec2 vDiffuseInfos;
#endif
#include<clipPlaneFragmentDeclaration>
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#if defined(CLUSTLIGHT_BATCH) && CLUSTLIGHT_BATCH>0
varying float vViewDepth;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;
#ifdef DIFFUSE
baseColor=texture2D(diffuseSampler,vDiffuseUV);
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
#include<depthPrePass>
baseColor.rgb*=vDiffuseInfos.y;
#endif
#ifdef NORMAL
baseColor=mix(baseColor,vec4(vNormalW,1.0),0.5);
#endif
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=vec3(1.0,1.0,1.0);
#endif
#ifdef LIGHTING
vec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;float shadow=1.;float glossiness=0.;float aggShadow=0.;float numLights=0.;
#include<lightFragment>[0]
#include<lightFragment>[1]
#include<lightFragment>[2]
#include<lightFragment>[3]
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor,0.0,1.0)*baseColor.rgb;
#else
vec3 finalDiffuse= baseColor.rgb;
#endif
vec4 color=vec4(finalDiffuse,alpha);
#include<logDepthFragment>
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}`;
if (!ShaderStore.ShadersStore[name]) {
  ShaderStore.ShadersStore[name] = shader;
}

// node_modules/@babylonjs/materials/normal/normal.vertex.js
init_shaderStore();
init_bonesDeclaration();
init_bakedVertexAnimationDeclaration();
init_instancesDeclaration();
init_clipPlaneVertexDeclaration();
init_logDepthDeclaration();
init_fogVertexDeclaration();
init_lightFragmentDeclaration();
init_lightUboDeclaration();
init_instancesVertex();
init_bonesVertex();
init_bakedVertexAnimation();
init_clipPlaneVertex();
init_logDepthVertex();
init_fogVertex();
init_shadowsVertex();
var name2 = "normalVertexShader";
var shader2 = `precision highp float;attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
uniform mat4 view;uniform mat4 viewProjection;
#ifdef DIFFUSE
varying vec2 vDiffuseUV;uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#include<clipPlaneVertexDeclaration>
#include<logDepthDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#if defined(CLUSTLIGHT_BATCH) && CLUSTLIGHT_BATCH>0
varying float vViewDepth;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;vPositionW=vec3(worldPos);
#ifdef NORMAL
vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));
#endif
#ifndef UV1
vec2 uv=vec2(0.,0.);
#endif
#ifndef UV2
vec2 uv2=vec2(0.,0.);
#endif
#ifdef DIFFUSE
if (vDiffuseInfos.x==0.)
{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}
else
{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}
#endif
#include<clipPlaneVertex>
#include<logDepthVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;
if (!ShaderStore.ShadersStore[name2]) {
  ShaderStore.ShadersStore[name2] = shader2;
}

// node_modules/@babylonjs/materials/normal/normalMaterial.js
init_effectFallbacks();
init_clipPlaneMaterialHelper();
init_materialHelper_functions();
var NormalMaterialDefines = class extends MaterialDefines {
  constructor() {
    super();
    this.DIFFUSE = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.LIGHT0 = false;
    this.LIGHT1 = false;
    this.LIGHT2 = false;
    this.LIGHT3 = false;
    this.SPOTLIGHT0 = false;
    this.SPOTLIGHT1 = false;
    this.SPOTLIGHT2 = false;
    this.SPOTLIGHT3 = false;
    this.HEMILIGHT0 = false;
    this.HEMILIGHT1 = false;
    this.HEMILIGHT2 = false;
    this.HEMILIGHT3 = false;
    this.DIRLIGHT0 = false;
    this.DIRLIGHT1 = false;
    this.DIRLIGHT2 = false;
    this.DIRLIGHT3 = false;
    this.POINTLIGHT0 = false;
    this.POINTLIGHT1 = false;
    this.POINTLIGHT2 = false;
    this.POINTLIGHT3 = false;
    this.SHADOW0 = false;
    this.SHADOW1 = false;
    this.SHADOW2 = false;
    this.SHADOW3 = false;
    this.SHADOWS = false;
    this.SHADOWESM0 = false;
    this.SHADOWESM1 = false;
    this.SHADOWESM2 = false;
    this.SHADOWESM3 = false;
    this.SHADOWPOISSON0 = false;
    this.SHADOWPOISSON1 = false;
    this.SHADOWPOISSON2 = false;
    this.SHADOWPOISSON3 = false;
    this.SHADOWPCF0 = false;
    this.SHADOWPCF1 = false;
    this.SHADOWPCF2 = false;
    this.SHADOWPCF3 = false;
    this.SHADOWPCSS0 = false;
    this.SHADOWPCSS1 = false;
    this.SHADOWPCSS2 = false;
    this.SHADOWPCSS3 = false;
    this.NORMAL = false;
    this.UV1 = false;
    this.UV2 = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.INSTANCES = false;
    this.THIN_INSTANCES = false;
    this.LIGHTING = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.LOGARITHMICDEPTH = false;
    this.AREALIGHTSUPPORTED = true;
    this.AREALIGHTNOROUGHTNESS = true;
    this.rebuild();
  }
};
var NormalMaterial = class _NormalMaterial extends PushMaterial {
  constructor(name3, scene) {
    super(name3, scene);
    this.diffuseColor = new Color3(1, 1, 1);
    this._disableLighting = false;
    this._maxSimultaneousLights = 4;
  }
  needAlphaBlending() {
    return this.alpha < 1;
  }
  needAlphaBlendingForMesh(mesh) {
    return this.needAlphaBlending() || mesh.visibility < 1;
  }
  needAlphaTesting() {
    return false;
  }
  getAlphaTestTexture() {
    return null;
  }
  // Methods
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    const drawWrapper = subMesh._drawWrapper;
    if (this.isFrozen) {
      if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new NormalMaterialDefines();
    }
    const defines = subMesh.materialDefines;
    const scene = this.getScene();
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      if (scene.texturesEnabled) {
        if (this._diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
          if (!this._diffuseTexture.isReady()) {
            return false;
          } else {
            defines._needUVs = true;
            defines.DIFFUSE = true;
          }
        }
      }
    }
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines, void 0, void 0, void 0, this._isVertexOutputInvariant);
    defines._needNormals = true;
    PrepareDefinesForLights(scene, mesh, defines, false, this._maxSimultaneousLights, this._disableLighting);
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, null, subMesh.getRenderingMesh().hasThinInstances);
    defines.LIGHTING = !this._disableLighting;
    PrepareDefinesForAttributes(mesh, defines, true, true);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const fallbacks = new EffectFallbacks();
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      HandleFallbacksForShadows(defines, fallbacks);
      if (defines.NUM_BONE_INFLUENCERS > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      defines.IMAGEPROCESSINGPOSTPROCESS = scene.imageProcessingConfiguration.applyByPostProcess;
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.UV1) {
        attribs.push(VertexBuffer.UVKind);
      }
      if (defines.UV2) {
        attribs.push(VertexBuffer.UV2Kind);
      }
      PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      PrepareAttributesForInstances(attribs, defines);
      const shaderName = "normal";
      const join = defines.toString();
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vDiffuseColor",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vDiffuseInfos",
        "mBones",
        "diffuseMatrix",
        "logarithmicDepthConstant"
      ];
      const samplers = ["diffuseSampler", "areaLightsLTC1Sampler", "areaLightsLTC2Sampler"];
      const uniformBuffers = [];
      AddClipPlaneUniforms(uniforms);
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: 4
      });
      subMesh.setEffect(scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 4 }
      }, engine), defines, this._materialContext);
    }
    if (defines["AREALIGHTUSED"]) {
      for (let index = 0; index < mesh.lightSources.length; index++) {
        if (!mesh.lightSources[index]._isReady()) {
          return false;
        }
      }
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    return true;
  }
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world);
    this._activeEffect.setMatrix("viewProjection", scene.getTransformMatrix());
    BindBonesParameters(mesh, this._activeEffect);
    if (this._mustRebind(scene, effect, subMesh)) {
      if (this.diffuseTexture && MaterialFlags.DiffuseTextureEnabled) {
        this._activeEffect.setTexture("diffuseSampler", this.diffuseTexture);
        this._activeEffect.setFloat2("vDiffuseInfos", this.diffuseTexture.coordinatesIndex, this.diffuseTexture.level);
        this._activeEffect.setMatrix("diffuseMatrix", this.diffuseTexture.getTextureMatrix());
      }
      BindClipPlane(effect, this, scene);
      if (this.pointsCloud) {
        this._activeEffect.setFloat("pointSize", this.pointSize);
      }
      if (this._useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
      scene.bindEyePosition(effect);
    }
    this._activeEffect.setColor4("vDiffuseColor", this.diffuseColor, this.alpha * mesh.visibility);
    if (scene.lightsEnabled && !this.disableLighting) {
      BindLights(scene, mesh, this._activeEffect, defines);
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      this._activeEffect.setMatrix("view", scene.getViewMatrix());
    }
    BindFogParameters(scene, mesh, this._activeEffect);
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  getAnimatables() {
    const results = [];
    if (this.diffuseTexture && this.diffuseTexture.animations && this.diffuseTexture.animations.length > 0) {
      results.push(this.diffuseTexture);
    }
    return results;
  }
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._diffuseTexture) {
      activeTextures.push(this._diffuseTexture);
    }
    return activeTextures;
  }
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this.diffuseTexture === texture) {
      return true;
    }
    return false;
  }
  dispose(forceDisposeEffect) {
    if (this.diffuseTexture) {
      this.diffuseTexture.dispose();
    }
    super.dispose(forceDisposeEffect);
  }
  clone(name3) {
    return SerializationHelper.Clone(() => new _NormalMaterial(name3, this.getScene()), this);
  }
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.NormalMaterial";
    return serializationObject;
  }
  getClassName() {
    return "NormalMaterial";
  }
  // Statics
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _NormalMaterial(source.name, scene), source, scene, rootUrl);
  }
};
__decorate([
  serializeAsTexture("diffuseTexture")
], NormalMaterial.prototype, "_diffuseTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], NormalMaterial.prototype, "diffuseTexture", void 0);
__decorate([
  serializeAsColor3()
], NormalMaterial.prototype, "diffuseColor", void 0);
__decorate([
  serialize("disableLighting")
], NormalMaterial.prototype, "_disableLighting", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], NormalMaterial.prototype, "disableLighting", void 0);
__decorate([
  serialize("maxSimultaneousLights")
], NormalMaterial.prototype, "_maxSimultaneousLights", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], NormalMaterial.prototype, "maxSimultaneousLights", void 0);
RegisterClass("BABYLON.NormalMaterial", NormalMaterial);
export {
  NormalMaterial
};
//# sourceMappingURL=normalMaterial-PT4JZHAB.js.map
