import {
  _AreSameIntegerClass,
  _AreSameMatrixClass,
  _AreSameVectorOrQuaternionClass,
  _GetClassNameOf,
  getNumericValue,
  init_utils,
  isNumeric
} from "./chunk-JZELQRBK.js";
import {
  FlowGraphBinaryOperationBlock,
  init_flowGraphBinaryOperationBlock
} from "./chunk-C2UBFGLR.js";
import {
  FlowGraphUnaryOperationBlock,
  init_flowGraphUnaryOperationBlock
} from "./chunk-RC5KAGLV.js";
import {
  FlowGraphCachedOperationBlock,
  init_flowGraphCachedOperationBlock
} from "./chunk-F3XX35TE.js";
import {
  FlowGraphInteger,
  FlowGraphMatrix2D,
  FlowGraphMatrix3D,
  RichTypeAny,
  RichTypeBoolean,
  RichTypeFlowGraphInteger,
  RichTypeNumber,
  getRichTypeByFlowGraphType,
  init_flowGraphInteger,
  init_flowGraphMatrix,
  init_flowGraphRichTypes
} from "./chunk-WADD4RBF.js";
import {
  Matrix,
  Quaternion,
  Vector2,
  Vector3,
  Vector4,
  init_math_vector
} from "./chunk-VQZCJUUR.js";
import {
  RegisterClass,
  init_typeStore
} from "./chunk-7ANHXSNA.js";
import {
  __esm
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@babylonjs/core/FlowGraph/Blocks/Data/flowGraphConstantOperationBlock.js
var FlowGraphConstantOperationBlock;
var init_flowGraphConstantOperationBlock = __esm({
  "node_modules/@babylonjs/core/FlowGraph/Blocks/Data/flowGraphConstantOperationBlock.js"() {
    init_flowGraphCachedOperationBlock();
    FlowGraphConstantOperationBlock = class extends FlowGraphCachedOperationBlock {
      constructor(richType, _operation, _className, config) {
        super(richType, config);
        this._operation = _operation;
        this._className = _className;
      }
      /**
       * the operation performed by this block
       * @param context the graph context
       * @returns the result of the operation
       */
      _doOperation(context) {
        return this._operation(context);
      }
      /**
       * Gets the class name of this block
       * @returns the class name
       */
      getClassName() {
        return this._className;
      }
    };
  }
});

// node_modules/@babylonjs/core/FlowGraph/Blocks/Data/flowGraphTernaryOperationBlock.js
var FlowGraphTernaryOperationBlock;
var init_flowGraphTernaryOperationBlock = __esm({
  "node_modules/@babylonjs/core/FlowGraph/Blocks/Data/flowGraphTernaryOperationBlock.js"() {
    init_flowGraphCachedOperationBlock();
    FlowGraphTernaryOperationBlock = class extends FlowGraphCachedOperationBlock {
      constructor(t1Type, t2Type, t3Type, resultRichType, _operation, _className, config) {
        super(resultRichType, config);
        this._operation = _operation;
        this._className = _className;
        this.a = this.registerDataInput("a", t1Type);
        this.b = this.registerDataInput("b", t2Type);
        this.c = this.registerDataInput("c", t3Type);
      }
      /**
       * the operation performed by this block
       * @param context the graph context
       * @returns the result of the operation
       */
      _doOperation(context) {
        return this._operation(this.a.getValue(context), this.b.getValue(context), this.c.getValue(context));
      }
      /**
       * Gets the class name of this block
       * @returns the class name
       */
      getClassName() {
        return this._className;
      }
    };
  }
});

// node_modules/@babylonjs/core/FlowGraph/Blocks/Data/Math/flowGraphMathBlocks.js
function ComponentWiseUnaryOperation(a, op) {
  const aClassName = _GetClassNameOf(a);
  switch (aClassName) {
    case "FlowGraphInteger":
      a = a;
      return new FlowGraphInteger(op(a.value));
    case "Vector2":
      a = a;
      return new Vector2(op(a.x), op(a.y));
    case "Vector3":
      a = a;
      return new Vector3(op(a.x), op(a.y), op(a.z));
    case "Vector4":
      a = a;
      return new Vector4(op(a.x), op(a.y), op(a.z), op(a.w));
    case "Quaternion":
      a = a;
      return new Quaternion(op(a.x), op(a.y), op(a.z), op(a.w));
    case "Matrix":
      a = a;
      return Matrix.FromArray(a.m.map(op));
    case "Matrix2D":
      a = a;
      return new FlowGraphMatrix2D(a.m.map(op));
    case "Matrix3D":
      a = a;
      return new FlowGraphMatrix3D(a.m.map(op));
    default:
      a = a;
      return op(a);
  }
}
function ComponentWiseBinaryOperation(a, b, op) {
  const aClassName = _GetClassNameOf(a);
  switch (aClassName) {
    case "FlowGraphInteger":
      a = a;
      b = b;
      return new FlowGraphInteger(op(a.value, b.value));
    case "Vector2":
      a = a;
      b = b;
      return new Vector2(op(a.x, b.x), op(a.y, b.y));
    case "Vector3":
      a = a;
      b = b;
      return new Vector3(op(a.x, b.x), op(a.y, b.y), op(a.z, b.z));
    case "Vector4":
      a = a;
      b = b;
      return new Vector4(op(a.x, b.x), op(a.y, b.y), op(a.z, b.z), op(a.w, b.w));
    case "Quaternion":
      a = a;
      b = b;
      return new Quaternion(op(a.x, b.x), op(a.y, b.y), op(a.z, b.z), op(a.w, b.w));
    case "Matrix":
      a = a;
      return Matrix.FromArray(a.m.map((v, i) => op(v, b.m[i])));
    case "Matrix2D":
      a = a;
      return new FlowGraphMatrix2D(a.m.map((v, i) => op(v, b.m[i])));
    case "Matrix3D":
      a = a;
      return new FlowGraphMatrix3D(a.m.map((v, i) => op(v, b.m[i])));
    default:
      return op(getNumericValue(a), getNumericValue(b));
  }
}
function Clamp(a, b, c) {
  return Math.min(Math.max(a, Math.min(b, c)), Math.max(b, c));
}
function ComponentWiseTernaryOperation(a, b, c, op) {
  const aClassName = _GetClassNameOf(a);
  switch (aClassName) {
    case "FlowGraphInteger":
      a = a;
      b = b;
      c = c;
      return new FlowGraphInteger(op(a.value, b.value, c.value));
    case "Vector2":
      a = a;
      b = b;
      c = c;
      return new Vector2(op(a.x, b.x, c.x), op(a.y, b.y, c.y));
    case "Vector3":
      a = a;
      b = b;
      c = c;
      return new Vector3(op(a.x, b.x, c.x), op(a.y, b.y, c.y), op(a.z, b.z, c.z));
    case "Vector4":
      a = a;
      b = b;
      c = c;
      return new Vector4(op(a.x, b.x, c.x), op(a.y, b.y, c.y), op(a.z, b.z, c.z), op(a.w, b.w, c.w));
    case "Quaternion":
      a = a;
      b = b;
      c = c;
      return new Quaternion(op(a.x, b.x, c.x), op(a.y, b.y, c.y), op(a.z, b.z, c.z), op(a.w, b.w, c.w));
    case "Matrix":
      return Matrix.FromArray(a.m.map((v, i) => op(v, b.m[i], c.m[i])));
    case "Matrix2D":
      return new FlowGraphMatrix2D(a.m.map((v, i) => op(v, b.m[i], c.m[i])));
    case "Matrix3D":
      return new FlowGraphMatrix3D(a.m.map((v, i) => op(v, b.m[i], c.m[i])));
    default:
      return op(getNumericValue(a), getNumericValue(b), getNumericValue(c));
  }
}
function Saturate(a) {
  return Math.min(Math.max(a, 0), 1);
}
function Interpolate(a, b, c) {
  return (1 - c) * a + c * b;
}
function ComparisonOperators(a, b, op) {
  if (isNumeric(a) && isNumeric(b)) {
    return op(getNumericValue(a), getNumericValue(b));
  } else {
    throw new Error(`Cannot compare ${a} and ${b}`);
  }
}
function CountOnes(n) {
  let result = 0;
  while (n) {
    result += n & 1;
    n >>= 1;
  }
  return result;
}
var FlowGraphAddBlock, FlowGraphSubtractBlock, FlowGraphMultiplyBlock, FlowGraphDivideBlock, FlowGraphRandomBlock, FlowGraphEBlock, FlowGraphPiBlock, FlowGraphInfBlock, FlowGraphNaNBlock, FlowGraphAbsBlock, FlowGraphSignBlock, FlowGraphTruncBlock, FlowGraphFloorBlock, FlowGraphCeilBlock, FlowGraphRoundBlock, FlowGraphFractionBlock, FlowGraphNegationBlock, FlowGraphModuloBlock, FlowGraphMinBlock, FlowGraphMaxBlock, FlowGraphClampBlock, FlowGraphSaturateBlock, FlowGraphMathInterpolationBlock, FlowGraphEqualityBlock, FlowGraphLessThanBlock, FlowGraphLessThanOrEqualBlock, FlowGraphGreaterThanBlock, FlowGraphGreaterThanOrEqualBlock, FlowGraphIsNanBlock, FlowGraphIsInfinityBlock, FlowGraphDegToRadBlock, FlowGraphRadToDegBlock, FlowGraphSinBlock, FlowGraphCosBlock, FlowGraphTanBlock, FlowGraphAsinBlock, FlowGraphAcosBlock, FlowGraphAtanBlock, FlowGraphAtan2Block, FlowGraphSinhBlock, FlowGraphCoshBlock, FlowGraphTanhBlock, FlowGraphAsinhBlock, FlowGraphAcoshBlock, FlowGraphAtanhBlock, FlowGraphExpBlock, FlowGraphLogBlock, FlowGraphLog2Block, FlowGraphLog10Block, FlowGraphSquareRootBlock, FlowGraphCubeRootBlock, FlowGraphPowerBlock, FlowGraphBitwiseNotBlock, FlowGraphBitwiseAndBlock, FlowGraphBitwiseOrBlock, FlowGraphBitwiseXorBlock, FlowGraphBitwiseLeftShiftBlock, FlowGraphBitwiseRightShiftBlock, FlowGraphLeadingZerosBlock, FlowGraphTrailingZerosBlock, FlowGraphOneBitsCounterBlock;
var init_flowGraphMathBlocks = __esm({
  "node_modules/@babylonjs/core/FlowGraph/Blocks/Data/Math/flowGraphMathBlocks.js"() {
    init_typeStore();
    init_flowGraphRichTypes();
    init_flowGraphBinaryOperationBlock();
    init_flowGraphConstantOperationBlock();
    init_math_vector();
    init_flowGraphUnaryOperationBlock();
    init_flowGraphTernaryOperationBlock();
    init_flowGraphInteger();
    init_flowGraphMatrix();
    init_utils();
    FlowGraphAddBlock = class extends FlowGraphBinaryOperationBlock {
      /**
       * Construct a new add block.
       * @param config optional configuration
       */
      constructor(config) {
        super(getRichTypeByFlowGraphType(config?.type), getRichTypeByFlowGraphType(config?.type), getRichTypeByFlowGraphType(config?.type), (a, b) => this._polymorphicAdd(a, b), "FlowGraphAddBlock", config);
      }
      _polymorphicAdd(a, b) {
        const aClassName = _GetClassNameOf(a);
        const bClassName = _GetClassNameOf(b);
        if (_AreSameVectorOrQuaternionClass(aClassName, bClassName) || _AreSameMatrixClass(aClassName, bClassName) || _AreSameIntegerClass(aClassName, bClassName)) {
          return a.add(b);
        } else if (aClassName === "Quaternion" || bClassName === "Vector4") {
          return new Vector4(a.x, a.y, a.z, a.w).addInPlace(b);
        } else if (aClassName === "Vector4" || bClassName === "Quaternion") {
          return a.add(b);
        } else {
          if (this.config?.preventIntegerFloatArithmetic && typeof a !== typeof b) {
            throw new Error("Cannot add different types of numbers.");
          }
          return getNumericValue(a) + getNumericValue(b);
        }
      }
    };
    RegisterClass("FlowGraphAddBlock", FlowGraphAddBlock);
    FlowGraphSubtractBlock = class extends FlowGraphBinaryOperationBlock {
      /**
       * Construct a new subtract block.
       * @param config optional configuration
       */
      constructor(config) {
        super(getRichTypeByFlowGraphType(config?.type), getRichTypeByFlowGraphType(config?.type), getRichTypeByFlowGraphType(config?.type), (a, b) => this._polymorphicSubtract(a, b), "FlowGraphSubtractBlock", config);
      }
      _polymorphicSubtract(a, b) {
        const aClassName = _GetClassNameOf(a);
        const bClassName = _GetClassNameOf(b);
        if (_AreSameVectorOrQuaternionClass(aClassName, bClassName) || _AreSameIntegerClass(aClassName, bClassName) || _AreSameMatrixClass(aClassName, bClassName)) {
          return a.subtract(b);
        } else if (aClassName === "Quaternion" || bClassName === "Vector4") {
          return new Vector4(a.x, a.y, a.z, a.w).subtractInPlace(b);
        } else if (aClassName === "Vector4" || bClassName === "Quaternion") {
          return a.subtract(b);
        } else {
          if (this.config?.preventIntegerFloatArithmetic && typeof a !== typeof b) {
            throw new Error("Cannot add different types of numbers.");
          }
          return getNumericValue(a) - getNumericValue(b);
        }
      }
    };
    RegisterClass("FlowGraphSubtractBlock", FlowGraphSubtractBlock);
    FlowGraphMultiplyBlock = class extends FlowGraphBinaryOperationBlock {
      constructor(config) {
        super(getRichTypeByFlowGraphType(config?.type), getRichTypeByFlowGraphType(config?.type), getRichTypeByFlowGraphType(config?.type), (a, b) => this._polymorphicMultiply(a, b), "FlowGraphMultiplyBlock", config);
      }
      _polymorphicMultiply(a, b) {
        const aClassName = _GetClassNameOf(a);
        const bClassName = _GetClassNameOf(b);
        if (_AreSameVectorOrQuaternionClass(aClassName, bClassName) || _AreSameIntegerClass(aClassName, bClassName)) {
          return a.multiply(b);
        } else if (aClassName === "Quaternion" || bClassName === "Vector4") {
          return new Vector4(a.x, a.y, a.z, a.w).multiplyInPlace(b);
        } else if (aClassName === "Vector4" || bClassName === "Quaternion") {
          return a.multiply(b);
        } else if (_AreSameMatrixClass(aClassName, bClassName)) {
          if (this.config?.useMatrixPerComponent) {
            const aM = a.m;
            for (let i = 0; i < aM.length; i++) {
              aM[i] *= b.m[i];
            }
            if (aClassName === "Matrix2D") {
              return new FlowGraphMatrix2D(aM);
            } else if (aClassName === "Matrix3D") {
              return new FlowGraphMatrix3D(aM);
            } else {
              return Matrix.FromArray(aM);
            }
          } else {
            a = a;
            b = b;
            return b.multiply(a);
          }
        } else {
          if (this.config?.preventIntegerFloatArithmetic && typeof a !== typeof b) {
            throw new Error("Cannot add different types of numbers.");
          }
          return getNumericValue(a) * getNumericValue(b);
        }
      }
    };
    RegisterClass("FlowGraphMultiplyBlock", FlowGraphMultiplyBlock);
    FlowGraphDivideBlock = class extends FlowGraphBinaryOperationBlock {
      /**
       * Construct a new divide block.
       * @param config - Optional configuration
       */
      constructor(config) {
        super(getRichTypeByFlowGraphType(config?.type), getRichTypeByFlowGraphType(config?.type), getRichTypeByFlowGraphType(config?.type), (a, b) => this._polymorphicDivide(a, b), "FlowGraphDivideBlock", config);
      }
      _polymorphicDivide(a, b) {
        const aClassName = _GetClassNameOf(a);
        const bClassName = _GetClassNameOf(b);
        if (_AreSameVectorOrQuaternionClass(aClassName, bClassName) || _AreSameIntegerClass(aClassName, bClassName)) {
          return a.divide(b);
        } else if (aClassName === "Quaternion" || bClassName === "Quaternion") {
          const aClone = a.clone();
          aClone.x /= b.x;
          aClone.y /= b.y;
          aClone.z /= b.z;
          aClone.w /= b.w;
          return aClone;
        } else if (aClassName === "Quaternion" || bClassName === "Vector4") {
          return new Vector4(a.x, a.y, a.z, a.w).divideInPlace(b);
        } else if (aClassName === "Vector4" || bClassName === "Quaternion") {
          return a.divide(b);
        } else if (_AreSameMatrixClass(aClassName, bClassName)) {
          if (this.config?.useMatrixPerComponent) {
            const aM = a.m;
            for (let i = 0; i < aM.length; i++) {
              aM[i] /= b.m[i];
            }
            if (aClassName === "Matrix2D") {
              return new FlowGraphMatrix2D(aM);
            } else if (aClassName === "Matrix3D") {
              return new FlowGraphMatrix3D(aM);
            } else {
              return Matrix.FromArray(aM);
            }
          } else {
            a = a;
            b = b;
            return a.divide(b);
          }
        } else {
          if (this.config?.preventIntegerFloatArithmetic && typeof a !== typeof b) {
            throw new Error("Cannot add different types of numbers.");
          }
          return getNumericValue(a) / getNumericValue(b);
        }
      }
    };
    RegisterClass("FlowGraphDivideBlock", FlowGraphDivideBlock);
    FlowGraphRandomBlock = class extends FlowGraphConstantOperationBlock {
      /**
       * Construct a new random block.
       * @param config optional configuration
       */
      constructor(config) {
        super(RichTypeNumber, (context) => this._random(context), "FlowGraphRandomBlock", config);
        this.min = this.registerDataInput("min", RichTypeNumber, config?.min ?? 0);
        this.max = this.registerDataInput("max", RichTypeNumber, config?.max ?? 1);
        if (config?.seed) {
          this._seed = config.seed;
        }
      }
      _isSeed(seed = this._seed) {
        return seed !== void 0;
      }
      _getRandomValue() {
        if (this._isSeed(this._seed)) {
          const x = Math.sin(this._seed++) * 1e4;
          return x - Math.floor(x);
        }
        return Math.random();
      }
      _random(context) {
        const min = this.min.getValue(context);
        const max = this.max.getValue(context);
        return this._getRandomValue() * (max - min) + min;
      }
    };
    RegisterClass("FlowGraphRandomBlock", FlowGraphRandomBlock);
    FlowGraphEBlock = class extends FlowGraphConstantOperationBlock {
      constructor(config) {
        super(RichTypeNumber, () => Math.E, "FlowGraphEBlock", config);
      }
    };
    RegisterClass("FlowGraphEBlock", FlowGraphEBlock);
    FlowGraphPiBlock = class extends FlowGraphConstantOperationBlock {
      constructor(config) {
        super(RichTypeNumber, () => Math.PI, "FlowGraphPIBlock", config);
      }
    };
    RegisterClass("FlowGraphPIBlock", FlowGraphPiBlock);
    FlowGraphInfBlock = class extends FlowGraphConstantOperationBlock {
      constructor(config) {
        super(RichTypeNumber, () => Number.POSITIVE_INFINITY, "FlowGraphInfBlock", config);
      }
    };
    RegisterClass("FlowGraphInfBlock", FlowGraphInfBlock);
    FlowGraphNaNBlock = class extends FlowGraphConstantOperationBlock {
      constructor(config) {
        super(RichTypeNumber, () => Number.NaN, "FlowGraphNaNBlock", config);
      }
    };
    RegisterClass("FlowGraphNaNBlock", FlowGraphNaNBlock);
    FlowGraphAbsBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeNumber, RichTypeNumber, (a) => this._polymorphicAbs(a), "FlowGraphAbsBlock", config);
      }
      _polymorphicAbs(a) {
        return ComponentWiseUnaryOperation(a, Math.abs);
      }
    };
    RegisterClass("FlowGraphAbsBlock", FlowGraphAbsBlock);
    FlowGraphSignBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeNumber, RichTypeNumber, (a) => this._polymorphicSign(a), "FlowGraphSignBlock", config);
      }
      _polymorphicSign(a) {
        return ComponentWiseUnaryOperation(a, Math.sign);
      }
    };
    RegisterClass("FlowGraphSignBlock", FlowGraphSignBlock);
    FlowGraphTruncBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeNumber, RichTypeNumber, (a) => this._polymorphicTrunc(a), "FlowGraphTruncBlock", config);
      }
      _polymorphicTrunc(a) {
        return ComponentWiseUnaryOperation(a, Math.trunc);
      }
    };
    RegisterClass("FlowGraphTruncBlock", FlowGraphTruncBlock);
    FlowGraphFloorBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeNumber, RichTypeNumber, (a) => this._polymorphicFloor(a), "FlowGraphFloorBlock", config);
      }
      _polymorphicFloor(a) {
        return ComponentWiseUnaryOperation(a, Math.floor);
      }
    };
    RegisterClass("FlowGraphFloorBlock", FlowGraphFloorBlock);
    FlowGraphCeilBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, (a) => this._polymorphicCeiling(a), "FlowGraphCeilBlock", config);
      }
      _polymorphicCeiling(a) {
        return ComponentWiseUnaryOperation(a, Math.ceil);
      }
    };
    RegisterClass("FlowGraphCeilBlock", FlowGraphCeilBlock);
    FlowGraphRoundBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, (a) => this._polymorphicRound(a), "FlowGraphRoundBlock", config);
      }
      _polymorphicRound(a) {
        return ComponentWiseUnaryOperation(a, (a2) => a2 < 0 && this.config?.roundHalfAwayFromZero ? -Math.round(-a2) : Math.round(a2));
      }
    };
    RegisterClass("FlowGraphRoundBlock", FlowGraphRoundBlock);
    FlowGraphFractionBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, (a) => this._polymorphicFraction(a), "FlowGraphFractBlock", config);
      }
      _polymorphicFraction(a) {
        return ComponentWiseUnaryOperation(a, (a2) => a2 - Math.floor(a2));
      }
    };
    RegisterClass("FlowGraphFractBlock", FlowGraphFractionBlock);
    FlowGraphNegationBlock = class extends FlowGraphUnaryOperationBlock {
      /**
       * construct a new negation block.
       * @param config optional configuration
       */
      constructor(config) {
        super(RichTypeAny, RichTypeAny, (a) => this._polymorphicNeg(a), "FlowGraphNegationBlock", config);
      }
      _polymorphicNeg(a) {
        return ComponentWiseUnaryOperation(a, (a2) => -a2);
      }
    };
    RegisterClass("FlowGraphNegationBlock", FlowGraphNegationBlock);
    FlowGraphModuloBlock = class extends FlowGraphBinaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicRemainder(a, b), "FlowGraphModuloBlock", config);
      }
      _polymorphicRemainder(a, b) {
        return ComponentWiseBinaryOperation(a, b, (a2, b2) => a2 % b2);
      }
    };
    RegisterClass("FlowGraphModuloBlock", FlowGraphModuloBlock);
    FlowGraphMinBlock = class extends FlowGraphBinaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicMin(a, b), "FlowGraphMinBlock", config);
      }
      _polymorphicMin(a, b) {
        return ComponentWiseBinaryOperation(a, b, Math.min);
      }
    };
    RegisterClass("FlowGraphMinBlock", FlowGraphMinBlock);
    FlowGraphMaxBlock = class extends FlowGraphBinaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicMax(a, b), "FlowGraphMaxBlock", config);
      }
      _polymorphicMax(a, b) {
        return ComponentWiseBinaryOperation(a, b, Math.max);
      }
    };
    RegisterClass("FlowGraphMaxBlock", FlowGraphMaxBlock);
    FlowGraphClampBlock = class extends FlowGraphTernaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, RichTypeAny, RichTypeAny, (a, b, c) => this._polymorphicClamp(a, b, c), "FlowGraphClampBlock", config);
      }
      _polymorphicClamp(a, b, c) {
        return ComponentWiseTernaryOperation(a, b, c, Clamp);
      }
    };
    RegisterClass("FlowGraphClampBlock", FlowGraphClampBlock);
    FlowGraphSaturateBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, (a) => this._polymorphicSaturate(a), "FlowGraphSaturateBlock", config);
      }
      _polymorphicSaturate(a) {
        return ComponentWiseUnaryOperation(a, Saturate);
      }
    };
    RegisterClass("FlowGraphSaturateBlock", FlowGraphSaturateBlock);
    FlowGraphMathInterpolationBlock = class extends FlowGraphTernaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, RichTypeAny, RichTypeAny, (a, b, c) => this._polymorphicInterpolate(a, b, c), "FlowGraphMathInterpolationBlock", config);
      }
      _polymorphicInterpolate(a, b, c) {
        return ComponentWiseTernaryOperation(a, b, c, Interpolate);
      }
    };
    RegisterClass("FlowGraphMathInterpolationBlock", FlowGraphMathInterpolationBlock);
    FlowGraphEqualityBlock = class extends FlowGraphBinaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, RichTypeBoolean, (a, b) => this._polymorphicEq(a, b), "FlowGraphEqualityBlock", config);
      }
      _polymorphicEq(a, b) {
        const aClassName = _GetClassNameOf(a);
        const bClassName = _GetClassNameOf(b);
        if (typeof a !== typeof b) {
          return false;
        }
        if (_AreSameVectorOrQuaternionClass(aClassName, bClassName) || _AreSameMatrixClass(aClassName, bClassName) || _AreSameIntegerClass(aClassName, bClassName)) {
          return a.equals(b);
        } else {
          return a === b;
        }
      }
    };
    RegisterClass("FlowGraphEqualityBlock", FlowGraphEqualityBlock);
    FlowGraphLessThanBlock = class extends FlowGraphBinaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, RichTypeBoolean, (a, b) => this._polymorphicLessThan(a, b), "FlowGraphLessThanBlock", config);
      }
      _polymorphicLessThan(a, b) {
        return ComparisonOperators(a, b, (a2, b2) => a2 < b2);
      }
    };
    RegisterClass("FlowGraphLessThanBlock", FlowGraphLessThanBlock);
    FlowGraphLessThanOrEqualBlock = class extends FlowGraphBinaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, RichTypeBoolean, (a, b) => this._polymorphicLessThanOrEqual(a, b), "FlowGraphLessThanOrEqualBlock", config);
      }
      _polymorphicLessThanOrEqual(a, b) {
        return ComparisonOperators(a, b, (a2, b2) => a2 <= b2);
      }
    };
    RegisterClass("FlowGraphLessThanOrEqualBlock", FlowGraphLessThanOrEqualBlock);
    FlowGraphGreaterThanBlock = class extends FlowGraphBinaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, RichTypeBoolean, (a, b) => this._polymorphicGreaterThan(a, b), "FlowGraphGreaterThanBlock", config);
      }
      _polymorphicGreaterThan(a, b) {
        return ComparisonOperators(a, b, (a2, b2) => a2 > b2);
      }
    };
    RegisterClass("FlowGraphGreaterThanBlock", FlowGraphGreaterThanBlock);
    FlowGraphGreaterThanOrEqualBlock = class extends FlowGraphBinaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, RichTypeBoolean, (a, b) => this._polymorphicGreaterThanOrEqual(a, b), "FlowGraphGreaterThanOrEqualBlock", config);
      }
      _polymorphicGreaterThanOrEqual(a, b) {
        return ComparisonOperators(a, b, (a2, b2) => a2 >= b2);
      }
    };
    RegisterClass("FlowGraphGreaterThanOrEqualBlock", FlowGraphGreaterThanOrEqualBlock);
    FlowGraphIsNanBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeBoolean, (a) => this._polymorphicIsNan(a), "FlowGraphIsNaNBlock", config);
      }
      _polymorphicIsNan(a) {
        if (isNumeric(a, true)) {
          return isNaN(getNumericValue(a));
        } else {
          throw new Error(`Cannot get NaN of ${a}`);
        }
      }
    };
    RegisterClass("FlowGraphIsNaNBlock", FlowGraphIsNanBlock);
    FlowGraphIsInfinityBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeBoolean, (a) => this._polymorphicIsInf(a), "FlowGraphIsInfBlock", config);
      }
      _polymorphicIsInf(a) {
        if (isNumeric(a)) {
          return !isFinite(getNumericValue(a));
        } else {
          throw new Error(`Cannot get isInf of ${a}`);
        }
      }
    };
    RegisterClass("FlowGraphIsInfBlock", FlowGraphIsInfinityBlock);
    FlowGraphDegToRadBlock = class extends FlowGraphUnaryOperationBlock {
      /**
       * Constructs a new instance of the flow graph math block.
       * @param config - Optional configuration for the flow graph block.
       */
      constructor(config) {
        super(RichTypeAny, RichTypeAny, (a) => this._polymorphicDegToRad(a), "FlowGraphDegToRadBlock", config);
      }
      _degToRad(a) {
        return a * Math.PI / 180;
      }
      _polymorphicDegToRad(a) {
        return ComponentWiseUnaryOperation(a, this._degToRad);
      }
    };
    RegisterClass("FlowGraphDegToRadBlock", FlowGraphDegToRadBlock);
    FlowGraphRadToDegBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, (a) => this._polymorphicRadToDeg(a), "FlowGraphRadToDegBlock", config);
      }
      _radToDeg(a) {
        return a * 180 / Math.PI;
      }
      _polymorphicRadToDeg(a) {
        return ComponentWiseUnaryOperation(a, this._radToDeg);
      }
    };
    RegisterClass("FlowGraphRadToDegBlock", FlowGraphRadToDegBlock);
    FlowGraphSinBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeNumber, RichTypeNumber, (a) => this._polymorphicSin(a), "FlowGraphSinBlock", config);
      }
      _polymorphicSin(a) {
        return ComponentWiseUnaryOperation(a, Math.sin);
      }
    };
    FlowGraphCosBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeNumber, RichTypeNumber, (a) => this._polymorphicCos(a), "FlowGraphCosBlock", config);
      }
      _polymorphicCos(a) {
        return ComponentWiseUnaryOperation(a, Math.cos);
      }
    };
    FlowGraphTanBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeNumber, RichTypeNumber, (a) => this._polymorphicTan(a), "FlowGraphTanBlock", config);
      }
      _polymorphicTan(a) {
        return ComponentWiseUnaryOperation(a, Math.tan);
      }
    };
    FlowGraphAsinBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeNumber, RichTypeNumber, (a) => this._polymorphicAsin(a), "FlowGraphASinBlock", config);
      }
      _polymorphicAsin(a) {
        return ComponentWiseUnaryOperation(a, Math.asin);
      }
    };
    RegisterClass("FlowGraphASinBlock", FlowGraphAsinBlock);
    FlowGraphAcosBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeNumber, RichTypeNumber, (a) => this._polymorphicAcos(a), "FlowGraphACosBlock", config);
      }
      _polymorphicAcos(a) {
        return ComponentWiseUnaryOperation(a, Math.acos);
      }
    };
    RegisterClass("FlowGraphACosBlock", FlowGraphAcosBlock);
    FlowGraphAtanBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeNumber, RichTypeNumber, (a) => this._polymorphicAtan(a), "FlowGraphATanBlock", config);
      }
      _polymorphicAtan(a) {
        return ComponentWiseUnaryOperation(a, Math.atan);
      }
    };
    RegisterClass("FlowGraphATanBlock", FlowGraphAtanBlock);
    FlowGraphAtan2Block = class extends FlowGraphBinaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicAtan2(a, b), "FlowGraphATan2Block", config);
      }
      _polymorphicAtan2(a, b) {
        return ComponentWiseBinaryOperation(a, b, Math.atan2);
      }
    };
    RegisterClass("FlowGraphATan2Block", FlowGraphAtan2Block);
    FlowGraphSinhBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, (a) => this._polymorphicSinh(a), "FlowGraphSinhBlock", config);
      }
      _polymorphicSinh(a) {
        return ComponentWiseUnaryOperation(a, Math.sinh);
      }
    };
    RegisterClass("FlowGraphSinhBlock", FlowGraphSinhBlock);
    FlowGraphCoshBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, (a) => this._polymorphicCosh(a), "FlowGraphCoshBlock", config);
      }
      _polymorphicCosh(a) {
        return ComponentWiseUnaryOperation(a, Math.cosh);
      }
    };
    RegisterClass("FlowGraphCoshBlock", FlowGraphCoshBlock);
    FlowGraphTanhBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeAny, (a) => this._polymorphicTanh(a), "FlowGraphTanhBlock", config);
      }
      _polymorphicTanh(a) {
        return ComponentWiseUnaryOperation(a, Math.tanh);
      }
    };
    RegisterClass("FlowGraphTanhBlock", FlowGraphTanhBlock);
    FlowGraphAsinhBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicAsinh(a), "FlowGraphASinhBlock", config);
      }
      _polymorphicAsinh(a) {
        return ComponentWiseUnaryOperation(a, Math.asinh);
      }
    };
    RegisterClass("FlowGraphASinhBlock", FlowGraphAsinhBlock);
    FlowGraphAcoshBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicAcosh(a), "FlowGraphACoshBlock", config);
      }
      _polymorphicAcosh(a) {
        return ComponentWiseUnaryOperation(a, Math.acosh);
      }
    };
    RegisterClass("FlowGraphACoshBlock", FlowGraphAcoshBlock);
    FlowGraphAtanhBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicAtanh(a), "FlowGraphATanhBlock", config);
      }
      _polymorphicAtanh(a) {
        return ComponentWiseUnaryOperation(a, Math.atanh);
      }
    };
    RegisterClass("FlowGraphATanhBlock", FlowGraphAtanhBlock);
    FlowGraphExpBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicExp(a), "FlowGraphExponentialBlock", config);
      }
      _polymorphicExp(a) {
        return ComponentWiseUnaryOperation(a, Math.exp);
      }
    };
    RegisterClass("FlowGraphExponentialBlock", FlowGraphExpBlock);
    FlowGraphLogBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicLog(a), "FlowGraphLogBlock", config);
      }
      _polymorphicLog(a) {
        return ComponentWiseUnaryOperation(a, Math.log);
      }
    };
    RegisterClass("FlowGraphLogBlock", FlowGraphLogBlock);
    FlowGraphLog2Block = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicLog2(a), "FlowGraphLog2Block", config);
      }
      _polymorphicLog2(a) {
        return ComponentWiseUnaryOperation(a, Math.log2);
      }
    };
    RegisterClass("FlowGraphLog2Block", FlowGraphLog2Block);
    FlowGraphLog10Block = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicLog10(a), "FlowGraphLog10Block", config);
      }
      _polymorphicLog10(a) {
        return ComponentWiseUnaryOperation(a, Math.log10);
      }
    };
    RegisterClass("FlowGraphLog10Block", FlowGraphLog10Block);
    FlowGraphSquareRootBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicSqrt(a), "FlowGraphSquareRootBlock", config);
      }
      _polymorphicSqrt(a) {
        return ComponentWiseUnaryOperation(a, Math.sqrt);
      }
    };
    RegisterClass("FlowGraphSquareRootBlock", FlowGraphSquareRootBlock);
    FlowGraphCubeRootBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicCubeRoot(a), "FlowGraphCubeRootBlock", config);
      }
      _polymorphicCubeRoot(a) {
        return ComponentWiseUnaryOperation(a, Math.cbrt);
      }
    };
    RegisterClass("FlowGraphCubeRootBlock", FlowGraphCubeRootBlock);
    FlowGraphPowerBlock = class extends FlowGraphBinaryOperationBlock {
      constructor(config) {
        super(RichTypeAny, RichTypeNumber, RichTypeNumber, (a, b) => this._polymorphicPow(a, b), "FlowGraphPowerBlock", config);
      }
      _polymorphicPow(a, b) {
        return ComponentWiseBinaryOperation(a, b, Math.pow);
      }
    };
    RegisterClass("FlowGraphPowerBlock", FlowGraphPowerBlock);
    FlowGraphBitwiseNotBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(getRichTypeByFlowGraphType(
          config?.valueType || "FlowGraphInteger"
          /* FlowGraphTypes.Integer */
        ), getRichTypeByFlowGraphType(
          config?.valueType || "FlowGraphInteger"
          /* FlowGraphTypes.Integer */
        ), (a) => {
          if (typeof a === "boolean") {
            return !a;
          } else if (typeof a === "number") {
            return ~a;
          }
          return new FlowGraphInteger(~a.value);
        }, "FlowGraphBitwiseNotBlock", config);
      }
    };
    RegisterClass("FlowGraphBitwiseNotBlock", FlowGraphBitwiseNotBlock);
    FlowGraphBitwiseAndBlock = class extends FlowGraphBinaryOperationBlock {
      constructor(config) {
        super(getRichTypeByFlowGraphType(
          config?.valueType || "FlowGraphInteger"
          /* FlowGraphTypes.Integer */
        ), getRichTypeByFlowGraphType(
          config?.valueType || "FlowGraphInteger"
          /* FlowGraphTypes.Integer */
        ), getRichTypeByFlowGraphType(
          config?.valueType || "FlowGraphInteger"
          /* FlowGraphTypes.Integer */
        ), (a, b) => {
          if (typeof a === "boolean" && typeof b === "boolean") {
            return a && b;
          } else if (typeof a === "number" && typeof b === "number") {
            return a & b;
          } else if (typeof a === "object" && typeof b === "object") {
            return new FlowGraphInteger(a.value & b.value);
          } else {
            throw new Error(`Cannot perform bitwise AND on ${a} and ${b}`);
          }
        }, "FlowGraphBitwiseAndBlock", config);
      }
    };
    RegisterClass("FlowGraphBitwiseAndBlock", FlowGraphBitwiseAndBlock);
    FlowGraphBitwiseOrBlock = class extends FlowGraphBinaryOperationBlock {
      constructor(config) {
        super(getRichTypeByFlowGraphType(
          config?.valueType || "FlowGraphInteger"
          /* FlowGraphTypes.Integer */
        ), getRichTypeByFlowGraphType(
          config?.valueType || "FlowGraphInteger"
          /* FlowGraphTypes.Integer */
        ), getRichTypeByFlowGraphType(
          config?.valueType || "FlowGraphInteger"
          /* FlowGraphTypes.Integer */
        ), (a, b) => {
          if (typeof a === "boolean" && typeof b === "boolean") {
            return a || b;
          } else if (typeof a === "number" && typeof b === "number") {
            return a | b;
          } else if (typeof a === "object" && typeof b === "object") {
            return new FlowGraphInteger(a.value | b.value);
          } else {
            throw new Error(`Cannot perform bitwise OR on ${a} and ${b}`);
          }
        }, "FlowGraphBitwiseOrBlock", config);
      }
    };
    RegisterClass("FlowGraphBitwiseOrBlock", FlowGraphBitwiseOrBlock);
    FlowGraphBitwiseXorBlock = class extends FlowGraphBinaryOperationBlock {
      constructor(config) {
        super(getRichTypeByFlowGraphType(
          config?.valueType || "FlowGraphInteger"
          /* FlowGraphTypes.Integer */
        ), getRichTypeByFlowGraphType(
          config?.valueType || "FlowGraphInteger"
          /* FlowGraphTypes.Integer */
        ), getRichTypeByFlowGraphType(
          config?.valueType || "FlowGraphInteger"
          /* FlowGraphTypes.Integer */
        ), (a, b) => {
          if (typeof a === "boolean" && typeof b === "boolean") {
            return a !== b;
          } else if (typeof a === "number" && typeof b === "number") {
            return a ^ b;
          } else if (typeof a === "object" && typeof b === "object") {
            return new FlowGraphInteger(a.value ^ b.value);
          } else {
            throw new Error(`Cannot perform bitwise XOR on ${a} and ${b}`);
          }
        }, "FlowGraphBitwiseXorBlock", config);
      }
    };
    RegisterClass("FlowGraphBitwiseXorBlock", FlowGraphBitwiseXorBlock);
    FlowGraphBitwiseLeftShiftBlock = class extends FlowGraphBinaryOperationBlock {
      constructor(config) {
        super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a, b) => new FlowGraphInteger(a.value << b.value), "FlowGraphBitwiseLeftShiftBlock", config);
      }
    };
    RegisterClass("FlowGraphBitwiseLeftShiftBlock", FlowGraphBitwiseLeftShiftBlock);
    FlowGraphBitwiseRightShiftBlock = class extends FlowGraphBinaryOperationBlock {
      constructor(config) {
        super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a, b) => new FlowGraphInteger(a.value >> b.value), "FlowGraphBitwiseRightShiftBlock", config);
      }
    };
    RegisterClass("FlowGraphBitwiseRightShiftBlock", FlowGraphBitwiseRightShiftBlock);
    FlowGraphLeadingZerosBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a) => new FlowGraphInteger(Math.clz32(a.value)), "FlowGraphLeadingZerosBlock", config);
      }
    };
    RegisterClass("FlowGraphLeadingZerosBlock", FlowGraphLeadingZerosBlock);
    FlowGraphTrailingZerosBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a) => new FlowGraphInteger(a.value ? 31 - Math.clz32(a.value & -a.value) : 32), "FlowGraphTrailingZerosBlock", config);
      }
    };
    RegisterClass("FlowGraphTrailingZerosBlock", FlowGraphTrailingZerosBlock);
    FlowGraphOneBitsCounterBlock = class extends FlowGraphUnaryOperationBlock {
      constructor(config) {
        super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a) => new FlowGraphInteger(CountOnes(a.value)), "FlowGraphOneBitsCounterBlock", config);
      }
    };
    RegisterClass("FlowGraphOneBitsCounterBlock", FlowGraphOneBitsCounterBlock);
  }
});

export {
  FlowGraphAddBlock,
  FlowGraphSubtractBlock,
  FlowGraphMultiplyBlock,
  FlowGraphDivideBlock,
  FlowGraphRandomBlock,
  FlowGraphEBlock,
  FlowGraphPiBlock,
  FlowGraphInfBlock,
  FlowGraphNaNBlock,
  FlowGraphAbsBlock,
  FlowGraphSignBlock,
  FlowGraphTruncBlock,
  FlowGraphFloorBlock,
  FlowGraphCeilBlock,
  FlowGraphRoundBlock,
  FlowGraphFractionBlock,
  FlowGraphNegationBlock,
  FlowGraphModuloBlock,
  FlowGraphMinBlock,
  FlowGraphMaxBlock,
  FlowGraphClampBlock,
  FlowGraphSaturateBlock,
  FlowGraphMathInterpolationBlock,
  FlowGraphEqualityBlock,
  FlowGraphLessThanBlock,
  FlowGraphLessThanOrEqualBlock,
  FlowGraphGreaterThanBlock,
  FlowGraphGreaterThanOrEqualBlock,
  FlowGraphIsNanBlock,
  FlowGraphIsInfinityBlock,
  FlowGraphDegToRadBlock,
  FlowGraphRadToDegBlock,
  FlowGraphSinBlock,
  FlowGraphCosBlock,
  FlowGraphTanBlock,
  FlowGraphAsinBlock,
  FlowGraphAcosBlock,
  FlowGraphAtanBlock,
  FlowGraphAtan2Block,
  FlowGraphSinhBlock,
  FlowGraphCoshBlock,
  FlowGraphTanhBlock,
  FlowGraphAsinhBlock,
  FlowGraphAcoshBlock,
  FlowGraphAtanhBlock,
  FlowGraphExpBlock,
  FlowGraphLogBlock,
  FlowGraphLog2Block,
  FlowGraphLog10Block,
  FlowGraphSquareRootBlock,
  FlowGraphCubeRootBlock,
  FlowGraphPowerBlock,
  FlowGraphBitwiseNotBlock,
  FlowGraphBitwiseAndBlock,
  FlowGraphBitwiseOrBlock,
  FlowGraphBitwiseXorBlock,
  FlowGraphBitwiseLeftShiftBlock,
  FlowGraphBitwiseRightShiftBlock,
  FlowGraphLeadingZerosBlock,
  FlowGraphTrailingZerosBlock,
  FlowGraphOneBitsCounterBlock,
  init_flowGraphMathBlocks
};
//# sourceMappingURL=chunk-NGKKXKQY.js.map
