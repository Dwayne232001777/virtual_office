{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Execution/ControlFlow/flowGraphForLoopBlock.ts"],
  "sourcesContent": ["import type { FlowGraphSignalConnection } from \"../../../flowGraphSignalConnection\";\r\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\r\nimport { FlowGraphExecutionBlockWithOutSignal } from \"core/FlowGraph/flowGraphExecutionBlockWithOutSignal\";\r\nimport type { FlowGraphContext } from \"../../../flowGraphContext\";\r\nimport { RichTypeAny, RichTypeFlowGraphInteger, RichTypeNumber } from \"../../../flowGraphRichTypes\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\r\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\r\nimport type { FlowGraphNumber } from \"core/FlowGraph/utils\";\r\nimport { getNumericValue } from \"core/FlowGraph/utils\";\r\nimport { FlowGraphInteger } from \"core/FlowGraph/CustomTypes/flowGraphInteger\";\r\n\r\n/**\r\n * Configuration for the For Loop block.\r\n */\r\nexport interface IFlowGraphForLoopBlockConfiguration extends IFlowGraphBlockConfiguration {\r\n    /**\r\n     * The initial index of the loop.\r\n     * if not set will default to 0\r\n     */\r\n    initialIndex?: FlowGraphNumber;\r\n\r\n    /**\r\n     * If set to true, the index of the case will be incremented when the loop is done.\r\n     * This will result that the index will equal endIndex when the loop finished its work.\r\n     * This is the default behavior in glTF interactivity\r\n     */\r\n    incrementIndexWhenLoopDone?: boolean;\r\n}\r\n/**\r\n * Block that executes an action in a loop.\r\n */\r\nexport class FlowGraphForLoopBlock extends FlowGraphExecutionBlockWithOutSignal {\r\n    /**\r\n     * The maximum number of iterations allowed for the loop.\r\n     * If the loop exceeds this number, it will stop. This number is configurable to avoid infinite loops.\r\n     */\r\n    public static MaxLoopIterations = 1000;\r\n    /**\r\n     * Input connection: The start index of the loop.\r\n     */\r\n    public readonly startIndex: FlowGraphDataConnection<FlowGraphNumber>;\r\n    /**\r\n     * Input connection: The end index of the loop.\r\n     */\r\n    public readonly endIndex: FlowGraphDataConnection<FlowGraphNumber>;\r\n    /**\r\n     * Input connection: The step of the loop.\r\n     */\r\n    public readonly step: FlowGraphDataConnection<number>;\r\n    /**\r\n     * Output connection: The current index of the loop.\r\n     */\r\n    public readonly index: FlowGraphDataConnection<FlowGraphInteger>;\r\n    /**\r\n     * Output connection: The signal that is activated when the loop body is executed.\r\n     */\r\n    public readonly executionFlow: FlowGraphSignalConnection;\r\n\r\n    /**\r\n     * Output connection: The completed signal. Triggered when condition is false.\r\n     * No out signal is available.\r\n     */\r\n    public readonly completed: FlowGraphSignalConnection;\r\n\r\n    public constructor(config?: IFlowGraphForLoopBlockConfiguration) {\r\n        super(config);\r\n\r\n        this.startIndex = this.registerDataInput(\"startIndex\", RichTypeAny, 0);\r\n        this.endIndex = this.registerDataInput(\"endIndex\", RichTypeAny);\r\n        this.step = this.registerDataInput(\"step\", RichTypeNumber, 1);\r\n\r\n        this.index = this.registerDataOutput(\"index\", RichTypeFlowGraphInteger, new FlowGraphInteger(getNumericValue(config?.initialIndex ?? 0)));\r\n        this.executionFlow = this._registerSignalOutput(\"executionFlow\");\r\n        this.completed = this._registerSignalOutput(\"completed\");\r\n\r\n        this._unregisterSignalOutput(\"out\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _execute(context: FlowGraphContext): void {\r\n        const index = getNumericValue(this.startIndex.getValue(context));\r\n        const step = this.step.getValue(context);\r\n        let endIndex = getNumericValue(this.endIndex.getValue(context));\r\n        for (let i = index; i < endIndex; i += step) {\r\n            this.index.setValue(new FlowGraphInteger(i), context);\r\n            this.executionFlow._activateSignal(context);\r\n            endIndex = getNumericValue(this.endIndex.getValue(context));\r\n            if (i > FlowGraphForLoopBlock.MaxLoopIterations * step) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (this.config?.incrementIndexWhenLoopDone) {\r\n            this.index.setValue(new FlowGraphInteger(getNumericValue(this.index.getValue(context)) + step), context);\r\n        }\r\n\r\n        this.completed._activateSignal(context);\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.ForLoop;\r\n    }\r\n}\r\nRegisterClass(FlowGraphBlockNames.ForLoop, FlowGraphForLoopBlock);\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IA8Ba;AA9Bb;;;AAEA;AACA;AAIA;AACA;AAsBM,IAAO,wBAAP,MAAO,+BAA8B,qCAAoC;MAiC3E,YAAmB,QAA4C;AAC3D,cAAM,MAAM;AAEZ,aAAK,aAAa,KAAK,kBAAkB,cAAc,aAAa,CAAC;AACrE,aAAK,WAAW,KAAK,kBAAkB,YAAY,WAAW;AAC9D,aAAK,OAAO,KAAK,kBAAkB,QAAQ,gBAAgB,CAAC;AAE5D,aAAK,QAAQ,KAAK,mBAAmB,SAAS,0BAA0B,IAAI,iBAAiB,gBAAgB,QAAQ,gBAAgB,CAAC,CAAC,CAAC;AACxI,aAAK,gBAAgB,KAAK,sBAAsB,eAAe;AAC/D,aAAK,YAAY,KAAK,sBAAsB,WAAW;AAEvD,aAAK,wBAAwB,KAAK;MACtC;;;;MAKO,SAAS,SAAyB;AACrC,cAAM,QAAQ,gBAAgB,KAAK,WAAW,SAAS,OAAO,CAAC;AAC/D,cAAM,OAAO,KAAK,KAAK,SAAS,OAAO;AACvC,YAAI,WAAW,gBAAgB,KAAK,SAAS,SAAS,OAAO,CAAC;AAC9D,iBAAS,IAAI,OAAO,IAAI,UAAU,KAAK,MAAM;AACzC,eAAK,MAAM,SAAS,IAAI,iBAAiB,CAAC,GAAG,OAAO;AACpD,eAAK,cAAc,gBAAgB,OAAO;AAC1C,qBAAW,gBAAgB,KAAK,SAAS,SAAS,OAAO,CAAC;AAC1D,cAAI,IAAI,uBAAsB,oBAAoB,MAAM;AACpD;UACJ;QACJ;AAEA,YAAI,KAAK,QAAQ,4BAA4B;AACzC,eAAK,MAAM,SAAS,IAAI,iBAAiB,gBAAgB,KAAK,MAAM,SAAS,OAAO,CAAC,IAAI,IAAI,GAAG,OAAO;QAC3G;AAEA,aAAK,UAAU,gBAAgB,OAAO;MAC1C;;;;MAKgB,eAAY;AACxB,eAAA;MACJ;;AAtEc,0BAAA,oBAAoB;AAwEtC,kBAAa,yBAA8B,qBAAqB;;;",
  "names": []
}
