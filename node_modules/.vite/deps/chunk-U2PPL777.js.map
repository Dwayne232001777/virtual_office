{
  "version": 3,
  "sources": ["../../../dev/core/src/Helpers/materialConversionHelper.ts", "../../../dev/core/src/Materials/Textures/textureMerger.ts", "../../../dev/core/src/Materials/GreasedLine/greasedLineMaterialDefaults.ts", "../../../dev/core/src/Misc/greasedLineTools.ts", "../../../dev/core/src/Materials/GreasedLine/greasedLinePluginMaterialShadersGLSL.ts", "../../../dev/core/src/Materials/GreasedLine/greasedLinePluginMaterialShadersWGSL.ts", "../../../dev/core/src/Materials/GreasedLine/greasedLinePluginMaterial.ts", "../../../dev/core/src/Materials/GreasedLine/greasedLineSimpleMaterial.ts", "../../../dev/core/src/Meshes/GreasedLine/greasedLineBaseMesh.ts"],
  "sourcesContent": ["import { Vector2 } from \"core/Maths/math.vector\";\r\n\r\n/**\r\n * Given the control points, solve for x based on a given t for a cubic bezier curve\r\n * @param t a value between 0 and 1\r\n * @param p0 first control point\r\n * @param p1 second control point\r\n * @param p2 third control point\r\n * @param p3 fourth control point\r\n * @returns number result of cubic bezier curve at the specified t\r\n */\r\nfunction CubicBezierCurve(t: number, p0: number, p1: number, p2: number, p3: number): number {\r\n    return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;\r\n}\r\n\r\n/**\r\n * Evaluates a specified specular power value to determine the appropriate roughness value,\r\n * based on a pre-defined cubic bezier curve with specular on the abscissa axis (x-axis)\r\n * and roughness on the ordinant axis (y-axis)\r\n * @param specularPower specular power of standard material\r\n * @param p0 first control point\r\n * @param p1 second control point\r\n * @param p2 third control point\r\n * @param p3 fourth control point\r\n * @returns Number representing the roughness value\r\n */\r\nexport function SpecularPowerToRoughness(specularPower: number, p0 = new Vector2(0, 1), p1 = new Vector2(0, 0.1), p2 = new Vector2(0, 0.1), p3 = new Vector2(1300, 0.1)): number {\r\n    // Given P0.x = 0, P1.x = 0, P2.x = 0\r\n    //   x = t * t * t * P3.x\r\n    //   t = (x / P3.x)^(1/3)\r\n    const t = Math.pow(specularPower / p3.x, 0.333333);\r\n    return CubicBezierCurve(t, p0.y, p1.y, p2.y, p3.y);\r\n}\r\n", "import type { Scene } from \"../../scene\";\nimport type { IProceduralTextureCreationOptions } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\nimport { ProceduralTexture } from \"./Procedurals/proceduralTexture\";\nimport type { BaseTexture } from \"./baseTexture\";\nimport type { TextureSize } from \"./textureCreationOptions\";\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\nimport { Constants } from \"../../Engines/constants\";\nimport type { Texture } from \"./texture\";\n\n/**\n * Configuration for a texture input source\n */\nexport interface ITextureChannelInput {\n    /** The texture to use as input */\n    texture: BaseTexture;\n    /** Source channel to read from (0=R, 1=G, 2=B, 3=A) */\n    sourceChannel: number;\n}\n\n/**\n * Configuration for a constant value input source\n */\nexport interface IConstantChannelInput {\n    /** Constant value between 0.0 and 1.0 */\n    value: number;\n}\n\n/**\n * Union type for channel input sources\n */\nexport type ChannelInput = ITextureChannelInput | IConstantChannelInput;\n\n/**\n * Configuration for texture merging operation\n */\nexport interface ITextureMergeConfiguration {\n    /** Configuration for red output channel */\n    red: ChannelInput;\n    /** Configuration for green output channel (optional, defaults to 0) */\n    green?: ChannelInput;\n    /** Configuration for blue output channel (optional, defaults to 0) */\n    blue?: ChannelInput;\n    /** Configuration for alpha output channel (optional, defaults to 1) */\n    alpha?: ChannelInput;\n    /** Output texture size. If not specified, uses the largest input texture size */\n    outputSize?: TextureSize;\n    /** Whether to generate mipmaps for the output texture */\n    generateMipMaps?: boolean;\n}\n\nconst _ShaderName = \"textureMerger\";\n\n/**\n * @internal\n * Check if a channel input is a texture input\n * @param input The channel input to check\n * @returns True if the input is a texture input, false otherwise\n */\nfunction IsTextureInput(input: ChannelInput): input is ITextureChannelInput {\n    return \"texture\" in input;\n}\n\n/**\n * @internal\n * Check if a channel input is a constant input\n * @param input The channel input to check\n * @returns True if the input is a constant input, false otherwise\n */\nfunction IsConstantInput(input: ChannelInput): input is IConstantChannelInput {\n    return \"value\" in input;\n}\n\n/**\n * @internal\n * Copy texture transformation properties from one texture to another\n * @param source The source texture\n * @param destination The destination texture\n */\nfunction CopyTextureTransform(source: Texture, destination: Texture) {\n    destination.uOffset = source.uOffset;\n    destination.vOffset = source.vOffset;\n    destination.uScale = source.uScale;\n    destination.vScale = source.vScale;\n    destination.uAng = source.uAng;\n    destination.vAng = source.vAng;\n    destination.wAng = source.wAng;\n    destination.uRotationCenter = source.uRotationCenter;\n    destination.vRotationCenter = source.vRotationCenter;\n}\n\n/**\n * @internal\n * Merge multiple texture channels into a single texture\n * @param name Name for the resulting texture\n * @param config Merge configuration\n * @param scene Scene to create the texture in\n * @returns The merged texture\n */\nexport async function MergeTexturesAsync(name: string, config: ITextureMergeConfiguration, scene: Scene): Promise<ProceduralTexture> {\n    const channels = [config.red, config.green, config.blue, config.alpha];\n    const textureInputs: BaseTexture[] = [];\n    const textureInputMap: number[] = []; // Maps channel index to texture input index (-1 for constants)\n\n    // Collect unique textures and validate inputs\n    for (let channelIndex = 0; channelIndex < 4; channelIndex++) {\n        const channel = channels[channelIndex];\n        if (channel) {\n            if (IsTextureInput(channel)) {\n                // Validate source channel\n                if (channel.sourceChannel < 0 || channel.sourceChannel > 3) {\n                    throw new Error(\"Source channel must be between 0 and 3 (R, G, B, A)\");\n                }\n\n                // Find or add texture to inputs\n                let textureIndex = textureInputs.indexOf(channel.texture);\n                if (textureIndex === -1) {\n                    textureIndex = textureInputs.length;\n                    textureInputs.push(channel.texture);\n                }\n                textureInputMap[channelIndex] = textureIndex;\n            } else if (IsConstantInput(channel)) {\n                // Validate constant value\n                if (channel.value < 0 || channel.value > 1) {\n                    throw new Error(\"Constant value must be between 0.0 and 1.0\");\n                }\n                textureInputMap[channelIndex] = -1;\n            } else {\n                throw new Error(\"Invalid channel input configuration\");\n            }\n        } else {\n            textureInputMap[channelIndex] = -1;\n        }\n    }\n\n    // Determine output size\n    let outputSize = config.outputSize;\n    if (!outputSize && textureInputs.length > 0) {\n        // Use the largest texture size\n        let maxSize = 0;\n        for (const texture of textureInputs) {\n            const size = texture.getSize();\n            const currentSize = Math.max(size.width, size.height);\n            if (currentSize > maxSize) {\n                maxSize = currentSize;\n                outputSize = size.width === size.height ? maxSize : size;\n            }\n        }\n    }\n    outputSize = outputSize || 512; // Fallback size\n\n    // Generate shader defines\n    const defines: string[] = [];\n    const usedTextures = new Set<number>();\n\n    for (let channelIndex = 0; channelIndex < 4; channelIndex++) {\n        const channel = channels[channelIndex];\n        const channelName = [\"RED\", \"GREEN\", \"BLUE\", \"ALPHA\"][channelIndex];\n\n        if (channel && IsTextureInput(channel)) {\n            defines.push(`${channelName}_FROM_TEXTURE`);\n            const textureIndex = textureInputMap[channelIndex];\n            usedTextures.add(textureIndex);\n        }\n    }\n\n    // Add texture defines for used textures\n    usedTextures.forEach((textureIndex) => {\n        defines.push(`USE_TEXTURE${textureIndex}`);\n    });\n\n    // Create the procedural texture\n    const outputTextureOptions: IProceduralTextureCreationOptions = {\n        type: Constants.TEXTURETYPE_HALF_FLOAT,\n        format: Constants.TEXTUREFORMAT_RGBA,\n        samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n        generateDepthBuffer: false,\n        generateMipMaps: false,\n        shaderLanguage: scene.getEngine().isWebGPU ? ShaderLanguage.WGSL : ShaderLanguage.GLSL,\n        extraInitializationsAsync: async () => {\n            if (scene.getEngine().isWebGPU) {\n                await Promise.all([import(\"../../ShadersWGSL/textureMerger.fragment\")]);\n            } else {\n                await Promise.all([import(\"../../Shaders/textureMerger.fragment\")]);\n            }\n        },\n    };\n    const proceduralTexture = new ProceduralTexture(name, outputSize, _ShaderName, scene, outputTextureOptions);\n    proceduralTexture.refreshRate = -1; // Do not auto-refresh\n\n    // Set the defines\n    proceduralTexture.defines = defines.length > 0 ? \"#define \" + defines.join(\"\\n#define \") + \"\\n\" : \"\";\n\n    // Set up texture inputs\n    for (let i = 0; i < textureInputs.length; i++) {\n        CopyTextureTransform(textureInputs[i] as Texture, proceduralTexture);\n        proceduralTexture.setTexture(`inputTexture${i}`, textureInputs[i]);\n    }\n\n    // Set up channel configuration\n    for (let channelIndex = 0; channelIndex < 4; channelIndex++) {\n        const channel = channels[channelIndex];\n        const channelName = [\"red\", \"green\", \"blue\", \"alpha\"][channelIndex];\n\n        if (channel && IsTextureInput(channel)) {\n            const textureIndex = textureInputMap[channelIndex];\n            proceduralTexture.setInt(`${channelName}TextureIndex`, textureIndex);\n            proceduralTexture.setInt(`${channelName}SourceChannel`, channel.sourceChannel);\n        } else {\n            // Use constant value (either provided or default)\n            let constantValue: number;\n            if (channel && IsConstantInput(channel)) {\n                constantValue = channel.value;\n            } else {\n                // Use default values: 0 for RGB, 1 for alpha\n                constantValue = channelIndex === 3 ? 1.0 : 0.0;\n            }\n            proceduralTexture.setFloat(`${channelName}ConstantValue`, constantValue);\n        }\n    }\n\n    return await new Promise<ProceduralTexture>((resolve, reject) => {\n        // Compile and render\n        proceduralTexture.executeWhenReady(() => {\n            try {\n                proceduralTexture.render();\n                resolve(proceduralTexture);\n            } catch (error) {\n                reject(error instanceof Error ? error : new Error(String(error)));\n            }\n        });\n    });\n}\n\n/**\n * @internal\n * Create a texture input configuration\n * @param texture The texture to read from\n * @param sourceChannel The channel to read (0=R, 1=G, 2=B, 3=A)\n * @returns Texture channel input configuration\n */\nexport function CreateTextureInput(texture: BaseTexture, sourceChannel: number): ITextureChannelInput {\n    return { texture, sourceChannel };\n}\n\n/**\n * @internal\n * Create a constant value input configuration\n * @param value The constant value (0.0-1.0)\n * @returns Constant channel input configuration\n */\nexport function CreateConstantInput(value: number): IConstantChannelInput {\n    return { value };\n}\n\n/**\n * @internal\n * Create a simple RGBA channel packing configuration\n * @param red Input for red channel\n * @param green Input for green channel (optional, defaults to 0)\n * @param blue Input for blue channel (optional, defaults to 0)\n * @param alpha Input for alpha channel (optional, defaults to 1)\n * @returns Texture merge configuration\n */\nexport function CreateRGBAConfiguration(red: ChannelInput, green?: ChannelInput, blue?: ChannelInput, alpha?: ChannelInput): ITextureMergeConfiguration {\n    return { red, green, blue, alpha };\n}\n", "import type { RawTexture } from \"../Textures/rawTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\n\r\n/**\r\n * Default settings for GreasedLine materials\r\n */\r\nexport class GreasedLineMaterialDefaults {\r\n    /**\r\n     * Default line color for newly created lines\r\n     */\r\n    public static DEFAULT_COLOR = Color3.White();\r\n    /**\r\n     * Default line width when sizeAttenuation is true\r\n     */\r\n    public static DEFAULT_WIDTH_ATTENUATED = 1;\r\n    /**\r\n     * Defaule line width\r\n     */\r\n    public static DEFAULT_WIDTH = 0.1;\r\n    /**\r\n     * Empty colors texture for WebGPU\r\n     */\r\n    public static EmptyColorsTexture: Nullable<RawTexture>;\r\n}\r\n", "import { Curve3 } from \"../Maths/math.path\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { IFontData } from \"../Meshes/Builders/textBuilder\";\r\nimport { CreateTextShapePaths } from \"../Meshes/Builders/textBuilder\";\r\nimport type { FloatArray, IndicesArray } from \"../types\";\r\nimport type { GreasedLinePoints, GreasedLinePointsOptions } from \"../Meshes/GreasedLine/greasedLineBaseMesh\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { GreasedLineMaterialDefaults } from \"../Materials/GreasedLine/greasedLineMaterialDefaults\";\r\n\r\n/**\r\n * Tool functions for GreasedLine\r\n */\r\nexport class GreasedLineTools {\r\n    /**\r\n     * Converts GreasedLinePoints to number[][]\r\n     * @param points GreasedLinePoints\r\n     * @param options GreasedLineToolsConvertPointsOptions\r\n     * @returns number[][] with x, y, z coordinates of the points, like [[x, y, z, x, y, z, ...], [x, y, z, ...]]\r\n     */\r\n    public static ConvertPoints(points: GreasedLinePoints, options?: GreasedLinePointsOptions): number[][] {\r\n        if (points.length && Array.isArray(points) && typeof points[0] === \"number\") {\r\n            return [<number[]>points];\r\n        } else if (points.length && Array.isArray(points[0]) && typeof points[0][0] === \"number\") {\r\n            return <number[][]>points;\r\n        } else if (points.length && !Array.isArray(points[0]) && points[0] instanceof Vector3) {\r\n            const positions: number[] = [];\r\n            for (let j = 0; j < points.length; j++) {\r\n                const p = points[j] as Vector3;\r\n                positions.push(p.x, p.y, p.z);\r\n            }\r\n            return [positions];\r\n        } else if (points.length > 0 && Array.isArray(points[0]) && points[0].length > 0 && points[0][0] instanceof Vector3) {\r\n            const positions: number[][] = [];\r\n            const vectorPoints = points as Vector3[][];\r\n            for (const p of vectorPoints) {\r\n                positions.push(p.flatMap((p2) => [p2.x, p2.y, p2.z]));\r\n            }\r\n            return positions;\r\n        } else if (points instanceof Float32Array) {\r\n            if (options?.floatArrayStride) {\r\n                const positions: number[][] = [];\r\n                const stride = options.floatArrayStride * 3;\r\n                for (let i = 0; i < points.length; i += stride) {\r\n                    const linePoints = new Array(stride); // Pre-allocate memory for the line\r\n                    for (let j = 0; j < stride; j++) {\r\n                        linePoints[j] = points[i + j];\r\n                    }\r\n                    positions.push(linePoints);\r\n                }\r\n                return positions;\r\n            } else {\r\n                return [Array.from(points)];\r\n            }\r\n        } else if (points.length && points[0] instanceof Float32Array) {\r\n            const positions: number[][] = [];\r\n            for (const p of points) {\r\n                positions.push(Array.from(p as Float32Array));\r\n            }\r\n\r\n            return positions;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Omit zero length lines predicate for the MeshesToLines function\r\n     * @param p1 point1 position of the face\r\n     * @param p2 point2 position of the face\r\n     * @param p3 point3 position of the face\r\n     * @returns original points or null if any edge length is zero\r\n     */\r\n    public static OmitZeroLengthPredicate(p1: Vector3, p2: Vector3, p3: Vector3) {\r\n        const fileredPoints = [];\r\n        // edge1\r\n        if (p2.subtract(p1).lengthSquared() > 0) {\r\n            fileredPoints.push([p1, p2]);\r\n        }\r\n        // edge2\r\n        if (p3.subtract(p2).lengthSquared() > 0) {\r\n            fileredPoints.push([p2, p3]);\r\n        }\r\n        // edge3\r\n        if (p1.subtract(p3).lengthSquared() > 0) {\r\n            fileredPoints.push([p3, p1]);\r\n        }\r\n        return fileredPoints.length === 0 ? null : fileredPoints;\r\n    }\r\n\r\n    /**\r\n     * Omit duplicate lines predicate for the MeshesToLines function\r\n     * @param p1 point1 position of the face\r\n     * @param p2 point2 position of the face\r\n     * @param p3 point3 position of the face\r\n     * @param points array of points to search in\r\n     * @returns original points or null if any edge length is zero\r\n     */\r\n    public static OmitDuplicatesPredicate(p1: Vector3, p2: Vector3, p3: Vector3, points: Vector3[][]) {\r\n        const fileredPoints = [];\r\n        // edge1\r\n        if (!GreasedLineTools._SearchInPoints(p1, p2, points)) {\r\n            fileredPoints.push([p1, p2]);\r\n        }\r\n        // edge2\r\n        if (!GreasedLineTools._SearchInPoints(p2, p3, points)) {\r\n            fileredPoints.push([p2, p3]);\r\n        }\r\n        // edge3\r\n        if (!GreasedLineTools._SearchInPoints(p3, p1, points)) {\r\n            fileredPoints.push([p3, p1]);\r\n        }\r\n        return fileredPoints.length === 0 ? null : fileredPoints;\r\n    }\r\n\r\n    private static _SearchInPoints(p1: Vector3, p2: Vector3, points: Vector3[][]) {\r\n        for (const ps of points) {\r\n            for (let i = 0; i < ps.length; i++) {\r\n                if (ps[i]?.equals(p1)) {\r\n                    // find the first point\r\n                    // if it has a sibling of p2 the line already exists\r\n                    if (ps[i + 1]?.equals(p2) || ps[i - 1]?.equals(p2)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets mesh triangles as line positions\r\n     * @param meshes array of meshes\r\n     * @param predicate predicate function which decides whether to include the mesh triangle/face in the ouput\r\n     * @returns array of arrays of points\r\n     */\r\n    public static MeshesToLines(\r\n        meshes: AbstractMesh[],\r\n        predicate?: (\r\n            p1: Vector3,\r\n            p2: Vector3,\r\n            p3: Vector3,\r\n            points: Vector3[][],\r\n            indiceIndex: number,\r\n            vertexIndex: number,\r\n            mesh: AbstractMesh,\r\n            meshIndex: number,\r\n            vertices: FloatArray,\r\n            indices: IndicesArray\r\n        ) => Vector3[][]\r\n    ) {\r\n        const points: Vector3[][] = [];\r\n\r\n        for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n            const mesh = meshes[meshIndex];\r\n            const vertices = mesh.getVerticesData(VertexBuffer.PositionKind);\r\n            const indices = mesh.getIndices();\r\n            if (vertices && indices) {\r\n                for (let i = 0, ii = 0; i < indices.length; i++) {\r\n                    const vi1 = indices[ii++] * 3;\r\n                    const vi2 = indices[ii++] * 3;\r\n                    const vi3 = indices[ii++] * 3;\r\n\r\n                    const p1 = new Vector3(vertices[vi1], vertices[vi1 + 1], vertices[vi1 + 2]);\r\n                    const p2 = new Vector3(vertices[vi2], vertices[vi2 + 1], vertices[vi2 + 2]);\r\n                    const p3 = new Vector3(vertices[vi3], vertices[vi3 + 1], vertices[vi3 + 2]);\r\n\r\n                    if (predicate) {\r\n                        const pointsFromPredicate = predicate(p1, p2, p3, points, i, vi1, mesh, meshIndex, vertices, indices);\r\n                        if (pointsFromPredicate) {\r\n                            for (const p of pointsFromPredicate) {\r\n                                points.push(p);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        points.push([p1, p2], [p2, p3], [p3, p1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Converts number coordinates to Vector3s\r\n     * @param points number array of x, y, z, x, y z, ... coordinates\r\n     * @returns Vector3 array\r\n     */\r\n    public static ToVector3Array(points: number[] | number[][]) {\r\n        if (Array.isArray(points[0])) {\r\n            const array: Vector3[][] = [];\r\n            const inputArray = points as number[][];\r\n            for (const subInputArray of inputArray) {\r\n                const subArray: Vector3[] = [];\r\n                for (let i = 0; i < subInputArray.length; i += 3) {\r\n                    subArray.push(new Vector3(subInputArray[i], subInputArray[i + 1], subInputArray[i + 2]));\r\n                }\r\n                array.push(subArray);\r\n            }\r\n            return array;\r\n        }\r\n\r\n        const inputArray = points as number[];\r\n        const array: Vector3[] = [];\r\n        for (let i = 0; i < inputArray.length; i += 3) {\r\n            array.push(new Vector3(inputArray[i], inputArray[i + 1], inputArray[i + 2]));\r\n        }\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * Gets a number array from a Vector3 array.\r\n     * You can you for example to convert your Vector3[] offsets to the required number[] for the offsets option.\r\n     * @param points Vector3 array\r\n     * @returns an array of x, y, z coordinates as numbers [x, y, z, x, y, z, x, y, z, ....]\r\n     */\r\n    public static ToNumberArray(points: Vector3[]) {\r\n        return points.flatMap((v) => [v.x, v.y, v.z]);\r\n    }\r\n\r\n    /**\r\n     * Calculates the sum of points of every line and the number of points in each line.\r\n     * This function is useful when you are drawing multiple lines in one mesh and you want\r\n     * to know the counts. For example for creating an offsets table.\r\n     * @param points point array\r\n     * @returns points count info\r\n     */\r\n    public static GetPointsCountInfo(points: number[][]): { total: number; counts: number[] } {\r\n        const counts = new Array(points.length);\r\n        let total = 0;\r\n        for (let n = points.length; n--; ) {\r\n            counts[n] = points[n].length / 3;\r\n            total += counts[n];\r\n        }\r\n        return { total, counts };\r\n    }\r\n\r\n    /**\r\n     * Gets the length of the line counting all it's segments length\r\n     * @param data array of line points\r\n     * @returns length of the line\r\n     */\r\n    public static GetLineLength(data: Vector3[] | number[]): number {\r\n        if (data.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        let points: Vector3[];\r\n        if (typeof data[0] === \"number\") {\r\n            points = GreasedLineTools.ToVector3Array(<number[]>data) as Vector3[];\r\n        } else {\r\n            points = data as Vector3[];\r\n        }\r\n\r\n        const tmp = TmpVectors.Vector3[0];\r\n        let length = 0;\r\n        for (let index = 0; index < points.length - 1; index++) {\r\n            const point1 = points[index];\r\n            const point2 = points[index + 1];\r\n            length += point2.subtractToRef(point1, tmp).length();\r\n        }\r\n        return length;\r\n    }\r\n\r\n    /**\r\n     * Gets the length from the beginning to each point of the line as array.\r\n     * @param data array of line points\r\n     * @param buf optional pre-allocated buffer to reduce memory pressure, should be at least `data.length * 4 / 3` bytes\r\n     * @returns length array of the line\r\n     */\r\n    public static GetLineLengthArray(data: number[], buf?: ArrayBuffer): Float32Array {\r\n        const out = buf ? new Float32Array(buf, 0, data.length / 3) : new Float32Array(data.length / 3);\r\n        let length = 0;\r\n        for (let index = 0, pointsLength = data.length / 3 - 1; index < pointsLength; index++) {\r\n            let x = data[index * 3 + 0];\r\n            let y = data[index * 3 + 1];\r\n            let z = data[index * 3 + 2];\r\n            x -= data[index * 3 + 3];\r\n            y -= data[index * 3 + 4];\r\n            z -= data[index * 3 + 5];\r\n            const currentLength = Math.sqrt(x * x + y * y + z * z);\r\n            length += currentLength;\r\n            out[index + 1] = length;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Divides a segment into smaller segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param point1 first point of the line\r\n     * @param point2 second point of the line\r\n     * @param segmentCount number of segments we want to have in the divided line\r\n     * @returns\r\n     */\r\n    public static SegmentizeSegmentByCount(point1: Vector3, point2: Vector3, segmentCount: number): Vector3[] {\r\n        const dividedLinePoints: Vector3[] = [];\r\n        const diff = point2.subtract(point1);\r\n        const divisor = TmpVectors.Vector3[0];\r\n        divisor.setAll(segmentCount);\r\n        const segmentVector = TmpVectors.Vector3[1];\r\n        diff.divideToRef(divisor, segmentVector);\r\n\r\n        let nextPoint = point1.clone();\r\n        dividedLinePoints.push(nextPoint);\r\n        for (let index = 0; index < segmentCount; index++) {\r\n            nextPoint = nextPoint.clone();\r\n            dividedLinePoints.push(nextPoint.addInPlace(segmentVector));\r\n        }\r\n\r\n        return dividedLinePoints;\r\n    }\r\n\r\n    /**\r\n     * Divides a line into segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param what line points\r\n     * @param segmentLength length of each segment of the resulting line (distance between two line points)\r\n     * @returns line point\r\n     */\r\n    public static SegmentizeLineBySegmentLength(what: Vector3[] | number[] | { point1: Vector3; point2: Vector3; length: number }[], segmentLength: number): Vector3[] {\r\n        const subLines =\r\n            what[0] instanceof Vector3\r\n                ? GreasedLineTools.GetLineSegments(what as Vector3[])\r\n                : typeof what[0] === \"number\"\r\n                  ? GreasedLineTools.GetLineSegments(GreasedLineTools.ToVector3Array(what as number[]) as Vector3[])\r\n                  : (what as { point1: Vector3; point2: Vector3; length: number }[]);\r\n        const points: Vector3[] = [];\r\n        for (const s of subLines) {\r\n            if (s.length > segmentLength) {\r\n                const segments = GreasedLineTools.SegmentizeSegmentByCount(s.point1, s.point2, Math.ceil(s.length / segmentLength));\r\n                for (const seg of segments) {\r\n                    points.push(seg);\r\n                }\r\n            } else {\r\n                points.push(s.point1);\r\n                points.push(s.point2);\r\n            }\r\n        }\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Divides a line into segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param what line points\r\n     * @param segmentCount number of segments\r\n     * @returns line point\r\n     */\r\n    public static SegmentizeLineBySegmentCount(what: Vector3[] | number[], segmentCount: number): Vector3[] {\r\n        const points = <Vector3[]>(typeof what[0] === \"number\" ? GreasedLineTools.ToVector3Array(<number[]>what) : what);\r\n        const segmentLength = GreasedLineTools.GetLineLength(points) / segmentCount;\r\n        return GreasedLineTools.SegmentizeLineBySegmentLength(points, segmentLength);\r\n    }\r\n    /**\r\n     * Gets line segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param points line points\r\n     * @returns segments information of the line segment including starting point, ending point and the distance between them\r\n     */\r\n    public static GetLineSegments(points: Vector3[]): { point1: Vector3; point2: Vector3; length: number }[] {\r\n        const segments = [];\r\n        for (let index = 0; index < points.length - 1; index++) {\r\n            const point1 = points[index];\r\n            const point2 = points[index + 1];\r\n            const length = point2.subtract(point1).length();\r\n            segments.push({ point1, point2, length });\r\n        }\r\n\r\n        return segments;\r\n    }\r\n\r\n    /**\r\n     * Gets the minimum and the maximum length of a line segment in the line.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param points line points\r\n     * @returns\r\n     */\r\n    public static GetMinMaxSegmentLength(points: Vector3[]): { min: number; max: number } {\r\n        const subLines = GreasedLineTools.GetLineSegments(points);\r\n        const sorted = subLines.sort((s) => s.length);\r\n        return {\r\n            min: sorted[0].length,\r\n            max: sorted[sorted.length - 1].length,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Finds the last visible position in world space of the line according to the visibility parameter\r\n     * @param lineSegments segments of the line\r\n     * @param lineLength total length of the line\r\n     * @param visbility normalized value of visibility\r\n     * @param localSpace if true the result will be in local space (default is false)\r\n     * @returns world space coordinate of the last visible piece of the line\r\n     */\r\n    public static GetPositionOnLineByVisibility(lineSegments: { point1: Vector3; point2: Vector3; length: number }[], lineLength: number, visbility: number, localSpace = false) {\r\n        const lengthVisibilityRatio = lineLength * visbility;\r\n        let sumSegmentLengths = 0;\r\n        let segmentIndex = 0;\r\n\r\n        const lineSegmentsLength = lineSegments.length;\r\n        for (let i = 0; i < lineSegmentsLength; i++) {\r\n            if (lengthVisibilityRatio <= sumSegmentLengths + lineSegments[i].length) {\r\n                segmentIndex = i;\r\n                break;\r\n            }\r\n            sumSegmentLengths += lineSegments[i].length;\r\n        }\r\n\r\n        const s = (lengthVisibilityRatio - sumSegmentLengths) / lineSegments[segmentIndex].length;\r\n\r\n        lineSegments[segmentIndex].point2.subtractToRef(lineSegments[segmentIndex].point1, TmpVectors.Vector3[0]);\r\n        TmpVectors.Vector3[1] = TmpVectors.Vector3[0].multiplyByFloats(s, s, s);\r\n        if (!localSpace) {\r\n            TmpVectors.Vector3[1].addInPlace(lineSegments[segmentIndex].point1);\r\n        }\r\n\r\n        return TmpVectors.Vector3[1].clone();\r\n    }\r\n\r\n    /**\r\n     * Creates lines in a shape of circle/arc.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param radiusX radiusX of the circle\r\n     * @param segments number of segments in the circle\r\n     * @param z z coordinate of the points. Defaults to 0.\r\n     * @param radiusY radiusY of the circle - you can draw an oval if using different values\r\n     * @param segmentAngle angle offset of the segments. Defaults to Math.PI * 2 / segments. Change this value to draw a part of the circle.\r\n     * @returns line points\r\n     */\r\n    public static GetCircleLinePoints(radiusX: number, segments: number, z = 0, radiusY = radiusX, segmentAngle = (Math.PI * 2) / segments) {\r\n        const points: Vector3[] = [];\r\n        for (let i = 0; i <= segments; i++) {\r\n            points.push(new Vector3(Math.cos(i * segmentAngle) * radiusX, Math.sin(i * segmentAngle) * radiusY, z));\r\n        }\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Gets line points in a shape of a bezier curve\r\n     * @param p0 bezier point0\r\n     * @param p1 bezier point1\r\n     * @param p2 bezier point2\r\n     * @param segments number of segments in the curve\r\n     * @returns\r\n     */\r\n    public static GetBezierLinePoints(p0: Vector3, p1: Vector3, p2: Vector3, segments: number) {\r\n        return Curve3.CreateQuadraticBezier(p0, p1, p2, segments)\r\n            .getPoints()\r\n            .flatMap((v) => [v.x, v.y, v.z]);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param position position of the arrow cap (mainly you want to create a triangle, set widthUp and widthDown to the same value and omit widthStartUp and widthStartDown)\r\n     * @param direction direction which the arrow points to\r\n     * @param length length (size) of the arrow cap itself\r\n     * @param widthUp the arrow width above the line\r\n     * @param widthDown the arrow width belove the line\r\n     * @param widthStartUp the arrow width at the start of the arrow above the line. In most scenarios this is 0.\r\n     * @param widthStartDown the arrow width at the start of the arrow below the line. In most scenarios this is 0.\r\n     * @returns\r\n     */\r\n    public static GetArrowCap(position: Vector3, direction: Vector3, length: number, widthUp: number, widthDown: number, widthStartUp = 0, widthStartDown = 0) {\r\n        const points = [position.clone(), position.add(direction.multiplyByFloats(length, length, length))];\r\n        const widths = [widthUp, widthDown, widthStartUp, widthStartDown];\r\n\r\n        return {\r\n            points,\r\n            widths,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets 3D positions of points from a text and font\r\n     * @param text Text\r\n     * @param size Size of the font\r\n     * @param resolution Resolution of the font\r\n     * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n     * @param z z coordinate\r\n     * @param includeInner include the inner parts of the font in the result. Default true. If false, only the outlines will be returned.\r\n     * @returns number[][] of 3D positions\r\n     */\r\n    public static GetPointsFromText(text: string, size: number, resolution: number, fontData: IFontData, z = 0, includeInner = true) {\r\n        const allPoints = [];\r\n        const shapePaths = CreateTextShapePaths(text, size, resolution, fontData);\r\n\r\n        for (const sp of shapePaths) {\r\n            for (const p of sp.paths) {\r\n                const points = [];\r\n                const points2d = p.getPoints();\r\n                for (const p2d of points2d) {\r\n                    points.push(p2d.x, p2d.y, z);\r\n                }\r\n                allPoints.push(points);\r\n            }\r\n\r\n            if (includeInner) {\r\n                for (const h of sp.holes) {\r\n                    const holes = [];\r\n                    const points2d = h.getPoints();\r\n                    for (const p2d of points2d) {\r\n                        holes.push(p2d.x, p2d.y, z);\r\n                    }\r\n                    allPoints.push(holes);\r\n                }\r\n            }\r\n        }\r\n\r\n        return allPoints;\r\n    }\r\n\r\n    /**\r\n     * Converts an array of Color3 to Uint8Array\r\n     * @param colors Arrray of Color3\r\n     * @returns Uin8Array of colors [r, g, b, a, r, g, b, a, ...]\r\n     */\r\n    public static Color3toRGBAUint8(colors: Color3[]): Uint8Array {\r\n        const colorTable: Uint8Array = new Uint8Array(colors.length * 4);\r\n        for (let i = 0, j = 0; i < colors.length; i++) {\r\n            colorTable[j++] = colors[i].r * 255;\r\n            colorTable[j++] = colors[i].g * 255;\r\n            colorTable[j++] = colors[i].b * 255;\r\n            colorTable[j++] = 255;\r\n        }\r\n\r\n        return colorTable;\r\n    }\r\n\r\n    /**\r\n     * Creates a RawTexture from an RGBA color array and sets it on the plugin material instance.\r\n     * @param name name of the texture\r\n     * @param colors Uint8Array of colors\r\n     * @param colorsSampling sampling mode of the created texture\r\n     * @param scene Scene\r\n     * @returns the colors texture\r\n     */\r\n    public static CreateColorsTexture(name: string, colors: Color3[], colorsSampling: number, scene: Scene) {\r\n        const maxTextureSize = scene.getEngine().getCaps().maxTextureSize ?? 1;\r\n        const width = colors.length > maxTextureSize ? maxTextureSize : colors.length;\r\n        const height = Math.ceil(colors.length / maxTextureSize);\r\n        if (height > 1) {\r\n            colors = [...colors, ...Array(width * height - colors.length).fill(colors[0])];\r\n        }\r\n        const colorsArray = GreasedLineTools.Color3toRGBAUint8(colors);\r\n        const colorsTexture = new RawTexture(colorsArray, width, height, Engine.TEXTUREFORMAT_RGBA, scene, false, true, colorsSampling);\r\n        colorsTexture.name = name;\r\n        return colorsTexture;\r\n    }\r\n\r\n    /**\r\n     * A minimum size texture for the colors sampler2D when there is no colors texture defined yet.\r\n     * For fast switching using the useColors property without the need to use defines.\r\n     * @param scene Scene\r\n     * @returns empty colors texture\r\n     */\r\n    public static PrepareEmptyColorsTexture(scene: Scene) {\r\n        if (!GreasedLineMaterialDefaults.EmptyColorsTexture) {\r\n            const colorsArray = new Uint8Array(4);\r\n            GreasedLineMaterialDefaults.EmptyColorsTexture = new RawTexture(colorsArray, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, false, RawTexture.NEAREST_NEAREST);\r\n            GreasedLineMaterialDefaults.EmptyColorsTexture.name = \"grlEmptyColorsTexture\";\r\n        }\r\n\r\n        return GreasedLineMaterialDefaults.EmptyColorsTexture;\r\n    }\r\n\r\n    /**\r\n     * Diposes the shared empty colors texture\r\n     */\r\n    public static DisposeEmptyColorsTexture() {\r\n        GreasedLineMaterialDefaults.EmptyColorsTexture?.dispose();\r\n        GreasedLineMaterialDefaults.EmptyColorsTexture = null;\r\n    }\r\n\r\n    /**\r\n     * Converts boolean to number.\r\n     * @param bool the bool value\r\n     * @returns 1 if true, 0 if false.\r\n     */\r\n    public static BooleanToNumber(bool?: boolean) {\r\n        return bool ? 1 : 0;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\nimport { GreasedLineMeshColorMode } from \"./greasedLineMaterialInterfaces\";\n\n/**\n * Returns GLSL custom shader code\n * @param shaderType vertex or fragment\n * @param cameraFacing is in camera facing mode?\n * @returns GLSL custom shader code\n */\n/** @internal */\nexport function GetCustomCode(shaderType: string, cameraFacing: boolean): Nullable<{ [pointName: string]: string }> {\n    if (shaderType === \"vertex\") {\n        const obj: any = {\n            CUSTOM_VERTEX_DEFINITIONS: `\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                `,\n            CUSTOM_VERTEX_UPDATE_POSITION: `\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                `,\n            CUSTOM_VERTEX_MAIN_END: `\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.01);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                `,\n        };\n        if (cameraFacing) {\n            obj[\"!gl_Position\\\\=viewProjection\\\\*worldPos;\"] = \"//\"; // not needed for camera facing GRL\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return obj;\n    }\n\n    if (shaderType === \"fragment\") {\n        return {\n            CUSTOM_FRAGMENT_DEFINITIONS: `\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                `,\n            CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: `\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                `,\n        };\n    }\n\n    return null;\n}\n", "import type { Nullable } from \"../../types\";\nimport { GreasedLineMeshColorMode } from \"./greasedLineMaterialInterfaces\";\n\n/**\n * Returns WGSL custom shader code\n * @param shaderType vertex or fragment\n * @param cameraFacing is in camera facing mode?\n * @returns WGSL custom shader code\n */\n/** @internal */\nexport function GetCustomCode(shaderType: string, cameraFacing: boolean): Nullable<{ [pointName: string]: string }> {\n    if (shaderType === \"vertex\") {\n        const obj: any = {\n            CUSTOM_VERTEX_DEFINITIONS: `\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                `,\n            CUSTOM_VERTEX_UPDATE_POSITION: `\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                `,\n            CUSTOM_VERTEX_MAIN_END: `\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.01);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                `,\n        };\n\n        if (cameraFacing) {\n            obj[\"!vertexOutputs\\\\.position\\\\s=\\\\sscene\\\\.viewProjection\\\\s\\\\*\\\\sworldPos;\"] = \"//\"; // not needed for camera facing GRL\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return obj;\n    }\n\n    if (shaderType === \"fragment\") {\n        return {\n            CUSTOM_FRAGMENT_DEFINITIONS: `\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                `,\n            CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: `\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                `,\n        };\n    }\n\n    return null;\n}\n", "import type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport { RawTexture } from \"../Textures/rawTexture\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { UniformBuffer } from \"../uniformBuffer\";\r\nimport { Vector2, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Color3 } from \"../../Maths/math.color\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Material } from \"../material\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { BaseTexture } from \"../Textures/baseTexture\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\n\r\nimport type { GreasedLineMaterialOptions, IGreasedLineMaterial } from \"./greasedLineMaterialInterfaces\";\r\nimport { GreasedLineMeshColorDistributionType, GreasedLineMeshColorMode } from \"./greasedLineMaterialInterfaces\";\r\nimport { GreasedLineMaterialDefaults } from \"./greasedLineMaterialDefaults\";\r\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools\";\r\nimport { GetCustomCode as getCustomCodeGLSL } from \"./greasedLinePluginMaterialShadersGLSL\";\r\nimport { GetCustomCode as getCustomCodeWGSL } from \"./greasedLinePluginMaterialShadersWGSL\";\r\nimport type { GreasedLineBaseMesh } from \"../../Meshes\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialGreasedLineDefines extends MaterialDefines {\r\n    /**\r\n     * The material has a color option specified\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_HAS_COLOR = false;\r\n    /**\r\n     * The material's size attenuation optiom\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_SIZE_ATTENUATION = false;\r\n    /**\r\n     * The type of color distribution is set to line this value equals to true.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = false;\r\n    /**\r\n     * True if scene is in right handed coordinate system.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = false;\r\n\r\n    /**\r\n     * True if the line is in camera facing mode\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_CAMERA_FACING = true;\r\n\r\n    /**\r\n     * True if the line uses offsets\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_USE_OFFSETS = false;\r\n}\r\n\r\n/**\r\n * GreasedLinePluginMaterial for GreasedLineMesh/GreasedLineRibbonMesh.\r\n * Use the GreasedLineBuilder.CreateGreasedLineMaterial function to create and instance of this class.\r\n */\r\nexport class GreasedLinePluginMaterial extends MaterialPluginBase implements IGreasedLineMaterial {\r\n    /**\r\n     * Plugin name\r\n     */\r\n    public static readonly GREASED_LINE_MATERIAL_NAME = \"GreasedLinePluginMaterial\";\r\n\r\n    /**\r\n     * Force all the greased lines to compile to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static ForceGLSL = false;\r\n\r\n    /**\r\n     * Whether to use the colors option to colorize the line\r\n     */\r\n    public useColors: boolean;\r\n\r\n    /**\r\n     * Normalized value of how much of the line will be visible\r\n     * 0 - 0% of the line will be visible\r\n     * 1 - 100% of the line will be visible\r\n     */\r\n    public visibility: number;\r\n\r\n    /**\r\n     * Dash offset\r\n     */\r\n    public dashOffset: number;\r\n\r\n    /**\r\n     * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.\r\n     */\r\n    public dashRatio: number;\r\n\r\n    /**\r\n     * Line base width. At each point the line width is calculated by widths[pointIndex] * width\r\n     */\r\n    public width: number;\r\n\r\n    /**\r\n     * The type of sampling of the colors texture. The values are the same when using with textures.\r\n     */\r\n    public colorsSampling: number;\r\n\r\n    /**\r\n     * Turns on/off dash mode\r\n     */\r\n    public useDash: boolean;\r\n\r\n    /**\r\n     * The mixing mode of the color paramater. Default value is GreasedLineMeshColorMode.SET\r\n     * @see GreasedLineMeshColorMode\r\n     */\r\n    public colorMode: GreasedLineMeshColorMode;\r\n\r\n    /**\r\n     * You can provide a colorsTexture to use instead of one generated from the 'colors' option\r\n     */\r\n    public colorsTexture: Nullable<RawTexture> = null;\r\n\r\n    private _scene: Scene;\r\n    private _dashCount: number;\r\n    private _dashArray: number;\r\n    private _color: Nullable<Color3>;\r\n    private _colors: Nullable<Color3[]>;\r\n    private _colorsDistributionType: GreasedLineMeshColorDistributionType;\r\n    private _resolution: Vector2;\r\n    private _aspect: number;\r\n    private _sizeAttenuation: boolean;\r\n\r\n    private _cameraFacing: boolean;\r\n\r\n    private _engine: AbstractEngine;\r\n\r\n    private _forceGLSL = false;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language\r\n     * @param _shaderLanguage The shader language to use\r\n     * @returns true if the plugin is compatible with the shader language. Return always true since both GLSL and WGSL are supported\r\n     */\r\n    public override isCompatible(_shaderLanguage: ShaderLanguage): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of the GreasedLinePluginMaterial\r\n     * @param material Base material for the plugin\r\n     * @param scene The scene\r\n     * @param options Plugin options\r\n     */\r\n    constructor(material: Material, scene?: Scene, options?: GreasedLineMaterialOptions) {\r\n        options = options || {\r\n            color: GreasedLineMaterialDefaults.DEFAULT_COLOR,\r\n        };\r\n\r\n        const defines = new MaterialGreasedLineDefines();\r\n        defines.GREASED_LINE_HAS_COLOR = !!options.color && !options.useColors;\r\n        defines.GREASED_LINE_SIZE_ATTENUATION = options.sizeAttenuation ?? false;\r\n        defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = options.colorDistributionType === GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE;\r\n        defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = (scene ?? material.getScene()).useRightHandedSystem;\r\n        defines.GREASED_LINE_CAMERA_FACING = options.cameraFacing ?? true;\r\n        super(material, GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME, 200, defines, true, true);\r\n\r\n        this._forceGLSL = options?.forceGLSL || GreasedLinePluginMaterial.ForceGLSL;\r\n\r\n        this._scene = scene ?? material.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._cameraFacing = options.cameraFacing ?? true;\r\n\r\n        this.visibility = options.visibility ?? 1;\r\n        this.useDash = options.useDash ?? false;\r\n        this.dashRatio = options.dashRatio ?? 0.5;\r\n        this.dashOffset = options.dashOffset ?? 0;\r\n        this.width = options.width ? options.width : options.sizeAttenuation ? GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED : GreasedLineMaterialDefaults.DEFAULT_WIDTH;\r\n        this._sizeAttenuation = options.sizeAttenuation ?? false;\r\n        this.colorMode = options.colorMode ?? GreasedLineMeshColorMode.COLOR_MODE_SET;\r\n        this._color = options.color ?? null;\r\n        this.useColors = options.useColors ?? false;\r\n        this._colorsDistributionType = options.colorDistributionType ?? GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;\r\n        this.colorsSampling = options.colorsSampling ?? RawTexture.NEAREST_NEAREST;\r\n        this._colors = options.colors ?? null;\r\n\r\n        this.dashCount = options.dashCount ?? 1; // calculate the _dashArray value, call the setter\r\n        this.resolution = options.resolution ?? new Vector2(this._engine.getRenderWidth(), this._engine.getRenderHeight()); // calculate aspect call the setter\r\n\r\n        if (options.colorsTexture) {\r\n            this.colorsTexture = options.colorsTexture; // colorsTexture from options takes precedence\r\n        } else {\r\n            if (this._colors) {\r\n                this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${material.name}-colors-texture`, this._colors, this.colorsSampling, this._scene);\r\n            } else {\r\n                this._color = this._color ?? GreasedLineMaterialDefaults.DEFAULT_COLOR;\r\n                GreasedLineTools.PrepareEmptyColorsTexture(this._scene);\r\n            }\r\n        }\r\n\r\n        this._engine.onDisposeObservable.add(() => {\r\n            GreasedLineTools.DisposeEmptyColorsTexture();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the shader attributes\r\n     * @param attributes array which will be filled with the attributes\r\n     */\r\n    override getAttributes(attributes: string[]) {\r\n        attributes.push(\"grl_offsets\");\r\n        attributes.push(\"grl_widths\");\r\n        attributes.push(\"grl_colorPointers\");\r\n        attributes.push(\"grl_counters\");\r\n        if (this._cameraFacing) {\r\n            attributes.push(\"grl_previousAndSide\");\r\n            attributes.push(\"grl_nextAndCounters\");\r\n        } else {\r\n            attributes.push(\"grl_slopes\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the shader samplers\r\n     * @param samplers\r\n     */\r\n    override getSamplers(samplers: string[]) {\r\n        samplers.push(\"grl_colors\");\r\n    }\r\n\r\n    /**\r\n     * Get the shader textures\r\n     * @param activeTextures array which will be filled with the textures\r\n     */\r\n    public override getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this.colorsTexture) {\r\n            activeTextures.push(this.colorsTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the shader uniforms\r\n     * @param shaderLanguage The shader language to use\r\n     * @returns uniforms\r\n     */\r\n    override getUniforms(shaderLanguage = ShaderLanguage.GLSL) {\r\n        const ubo = [\r\n            { name: \"grl_singleColor\", size: 3, type: \"vec3\" },\r\n            { name: \"grl_textureSize\", size: 2, type: \"vec2\" },\r\n            { name: \"grl_dashOptions\", size: 4, type: \"vec4\" },\r\n            { name: \"grl_colorMode_visibility_colorsWidth_useColors\", size: 4, type: \"vec4\" },\r\n        ];\r\n        if (this._cameraFacing) {\r\n            ubo.push({ name: \"grl_projection\", size: 16, type: \"mat4\" }, { name: \"grl_aspect_resolution_lineWidth\", size: 4, type: \"vec4\" });\r\n        }\r\n\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            ubo.push({\r\n                name: \"viewProjection\",\r\n                size: 16,\r\n                type: \"mat4\",\r\n            });\r\n        }\r\n\r\n        return {\r\n            ubo,\r\n            vertex:\r\n                this._cameraFacing && this._isGLSL(shaderLanguage)\r\n                    ? `\r\n                    uniform vec4 grl_aspect_resolution_lineWidth;\r\n                    uniform mat4 grl_projection;\r\n    `\r\n                    : \"\",\r\n            fragment: this._isGLSL(shaderLanguage)\r\n                ? `\r\n                    uniform vec4 grl_dashOptions;\r\n                    uniform vec2 grl_textureSize;\r\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\r\n                    uniform vec3 grl_singleColor;\r\n    `\r\n                : \"\",\r\n        };\r\n    }\r\n\r\n    // only getter, it doesn't make sense to use this plugin on a mesh other than GreasedLineMesh\r\n    // and it doesn't make sense to disable it on the mesh\r\n    get isEnabled() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Bind the uniform buffer\r\n     * @param uniformBuffer\r\n     */\r\n    override bindForSubMesh(uniformBuffer: UniformBuffer) {\r\n        if (this._cameraFacing) {\r\n            uniformBuffer.updateMatrix(\"grl_projection\", this._scene.getProjectionMatrix());\r\n            if (!this._isGLSL(this._material.shaderLanguage)) {\r\n                uniformBuffer.updateMatrix(\"viewProjection\", this._scene.getTransformMatrix());\r\n            }\r\n\r\n            const resolutionLineWidth = TmpVectors.Vector4[0];\r\n            resolutionLineWidth.x = this._aspect;\r\n            resolutionLineWidth.y = this._resolution.x;\r\n            resolutionLineWidth.z = this._resolution.y;\r\n            resolutionLineWidth.w = this.width;\r\n            uniformBuffer.updateVector4(\"grl_aspect_resolution_lineWidth\", resolutionLineWidth);\r\n        }\r\n\r\n        const dashOptions = TmpVectors.Vector4[0];\r\n        dashOptions.x = GreasedLineTools.BooleanToNumber(this.useDash);\r\n        dashOptions.y = this._dashArray;\r\n        dashOptions.z = this.dashOffset;\r\n        dashOptions.w = this.dashRatio;\r\n        uniformBuffer.updateVector4(\"grl_dashOptions\", dashOptions);\r\n\r\n        const colorModeVisibilityColorsWidthUseColors = TmpVectors.Vector4[1];\r\n        colorModeVisibilityColorsWidthUseColors.x = this.colorMode;\r\n        colorModeVisibilityColorsWidthUseColors.y = this.visibility;\r\n        colorModeVisibilityColorsWidthUseColors.z = this.colorsTexture ? this.colorsTexture.getSize().width : 0;\r\n        colorModeVisibilityColorsWidthUseColors.w = GreasedLineTools.BooleanToNumber(this.useColors);\r\n        uniformBuffer.updateVector4(\"grl_colorMode_visibility_colorsWidth_useColors\", colorModeVisibilityColorsWidthUseColors);\r\n\r\n        if (this._color) {\r\n            uniformBuffer.updateColor3(\"grl_singleColor\", this._color);\r\n        }\r\n        const texture = this.colorsTexture ?? GreasedLineMaterialDefaults.EmptyColorsTexture;\r\n        uniformBuffer.setTexture(\"grl_colors\", texture);\r\n        uniformBuffer.updateFloat2(\"grl_textureSize\", texture?.getSize().width ?? 1, texture?.getSize().height ?? 1);\r\n    }\r\n\r\n    /**\r\n     * Prepare the defines\r\n     * @param defines\r\n     * @param _scene\r\n     * @param mesh\r\n     */\r\n    override prepareDefines(defines: MaterialGreasedLineDefines, _scene: Scene, mesh: AbstractMesh) {\r\n        defines.GREASED_LINE_HAS_COLOR = !!this.color && !this.useColors;\r\n        defines.GREASED_LINE_SIZE_ATTENUATION = this._sizeAttenuation;\r\n        defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = this._colorsDistributionType === GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE;\r\n        defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = _scene.useRightHandedSystem;\r\n        defines.GREASED_LINE_CAMERA_FACING = this._cameraFacing;\r\n        defines.GREASED_LINE_USE_OFFSETS = !!(mesh as GreasedLineBaseMesh).offsets;\r\n    }\r\n\r\n    /**\r\n     * Get the class name\r\n     * @returns class name\r\n     */\r\n    override getClassName() {\r\n        return GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME;\r\n    }\r\n\r\n    /**\r\n     * Get shader code\r\n     * @param shaderType vertex/fragment\r\n     * @param shaderLanguage GLSL or WGSL\r\n     * @returns shader code\r\n     */\r\n    override getCustomCode(shaderType: string, shaderLanguage = ShaderLanguage.GLSL): Nullable<{ [pointName: string]: string }> {\r\n        if (this._isGLSL(shaderLanguage)) {\r\n            return getCustomCodeGLSL(shaderType, this._cameraFacing);\r\n        }\r\n        return getCustomCodeWGSL(shaderType, this._cameraFacing);\r\n    }\r\n\r\n    /**\r\n     * Disposes the plugin material.\r\n     */\r\n    public override dispose(): void {\r\n        this.colorsTexture?.dispose();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Returns the colors used to colorize the line\r\n     */\r\n    get colors() {\r\n        return this._colors;\r\n    }\r\n\r\n    /**\r\n     * Sets the colors used to colorize the line\r\n     */\r\n    set colors(value: Nullable<Color3[]>) {\r\n        this.setColors(value);\r\n    }\r\n\r\n    /**\r\n     * Creates or updates the colors texture\r\n     * @param colors color table RGBA\r\n     * @param lazy if lazy, the colors are not updated\r\n     * @param forceNewTexture force creation of a new texture\r\n     */\r\n    public setColors(colors: Nullable<Color3[]>, lazy = false, forceNewTexture = false): void {\r\n        const origColorsCount = this._colors?.length ?? 0;\r\n\r\n        this._colors = colors;\r\n\r\n        if (colors === null || colors.length === 0) {\r\n            this.colorsTexture?.dispose();\r\n            return;\r\n        }\r\n\r\n        if (lazy && !forceNewTexture) {\r\n            return;\r\n        }\r\n\r\n        if (this.colorsTexture && origColorsCount === colors.length && !forceNewTexture) {\r\n            const colorArray = GreasedLineTools.Color3toRGBAUint8(colors);\r\n            this.colorsTexture.update(colorArray);\r\n        } else {\r\n            this.colorsTexture?.dispose();\r\n            this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, colors, this.colorsSampling, this._scene);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the material. Use when material created in lazy mode.\r\n     */\r\n    public updateLazy() {\r\n        if (this._colors) {\r\n            this.setColors(this._colors, false, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the number of dashes in the line\r\n     */\r\n    get dashCount() {\r\n        return this._dashCount;\r\n    }\r\n    /**\r\n     * Sets the number of dashes in the line\r\n     * @param value dash\r\n     */\r\n    set dashCount(value: number) {\r\n        this._dashCount = value;\r\n        this._dashArray = 1 / value;\r\n    }\r\n\r\n    /**\r\n     * If set to true the line will be rendered always with the same width regardless how far it is located from the camera.\r\n     * Not supported for non camera facing lines.\r\n     */\r\n    get sizeAttenuation() {\r\n        return this._sizeAttenuation;\r\n    }\r\n\r\n    /**\r\n     * Turn on/off size attenuation of the width option and widths array.\r\n     * Not supported for non camera facing lines.\r\n     * @param value If set to true the line will be rendered always with the same width regardless how far it is located from the camera.\r\n     */\r\n    set sizeAttenuation(value: boolean) {\r\n        this._sizeAttenuation = value;\r\n        this.markAllDefinesAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the color of the line\r\n     */\r\n    get color() {\r\n        return this._color;\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the line\r\n     * @param value Color3 or null to clear the color. You need to clear the color if you use colors and useColors = true\r\n     */\r\n    set color(value: Nullable<Color3>) {\r\n        this.setColor(value);\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the line. If set the whole line will be mixed with this color according to the colorMode option.\r\n     * @param value color\r\n     * @param doNotMarkDirty if true, the material will not be marked as dirty\r\n     */\r\n    public setColor(value: Nullable<Color3>, doNotMarkDirty = false) {\r\n        if ((this._color === null && value !== null) || (this._color !== null && value === null)) {\r\n            this._color = value;\r\n            if (!doNotMarkDirty) {\r\n                this.markAllDefinesAsDirty();\r\n            }\r\n        } else {\r\n            this._color = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the color distributiopn type\r\n     */\r\n    get colorsDistributionType() {\r\n        return this._colorsDistributionType;\r\n    }\r\n\r\n    /**\r\n     * Sets the color distribution type\r\n     * @see GreasedLineMeshColorDistributionType\r\n     * @param value color distribution type\r\n     */\r\n    set colorsDistributionType(value: GreasedLineMeshColorDistributionType) {\r\n        this._colorsDistributionType = value;\r\n        this.markAllDefinesAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the resolution\r\n     */\r\n    get resolution() {\r\n        return this._resolution;\r\n    }\r\n\r\n    /**\r\n     * Sets the resolution\r\n     * @param value resolution of the screen for GreasedLine\r\n     */\r\n    set resolution(value: Vector2) {\r\n        this._aspect = value.x / value.y;\r\n        this._resolution = value;\r\n    }\r\n\r\n    /**\r\n     * Serializes this plugin material\r\n     * @returns serializationObjec\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        const greasedLineMaterialOptions: GreasedLineMaterialOptions = {\r\n            colorDistributionType: this._colorsDistributionType,\r\n            colorsSampling: this.colorsSampling,\r\n            colorMode: this.colorMode,\r\n            dashCount: this._dashCount,\r\n            dashOffset: this.dashOffset,\r\n            dashRatio: this.dashRatio,\r\n            resolution: this._resolution,\r\n            sizeAttenuation: this._sizeAttenuation,\r\n            useColors: this.useColors,\r\n            useDash: this.useDash,\r\n            visibility: this.visibility,\r\n            width: this.width,\r\n        };\r\n\r\n        if (this._colors) {\r\n            greasedLineMaterialOptions.colors = this._colors;\r\n        }\r\n        if (this._color) {\r\n            greasedLineMaterialOptions.color = this._color;\r\n        }\r\n\r\n        serializationObject.greasedLineMaterialOptions = greasedLineMaterialOptions;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized objects\r\n     * @param source serialized object\r\n     * @param scene scene\r\n     * @param rootUrl root url for textures\r\n     */\r\n    public override parse(source: any, scene: Scene, rootUrl: string): void {\r\n        super.parse(source, scene, rootUrl);\r\n        const greasedLineMaterialOptions = <GreasedLineMaterialOptions>source.greasedLineMaterialOptions;\r\n\r\n        this.colorsTexture?.dispose();\r\n\r\n        if (greasedLineMaterialOptions.color) {\r\n            this.setColor(greasedLineMaterialOptions.color, true);\r\n        }\r\n        if (greasedLineMaterialOptions.colorDistributionType) {\r\n            this.colorsDistributionType = greasedLineMaterialOptions.colorDistributionType;\r\n        }\r\n        if (greasedLineMaterialOptions.colors) {\r\n            this.colors = greasedLineMaterialOptions.colors;\r\n        }\r\n        if (greasedLineMaterialOptions.colorsSampling) {\r\n            this.colorsSampling = greasedLineMaterialOptions.colorsSampling;\r\n        }\r\n        if (greasedLineMaterialOptions.colorMode) {\r\n            this.colorMode = greasedLineMaterialOptions.colorMode;\r\n        }\r\n        if (greasedLineMaterialOptions.useColors) {\r\n            this.useColors = greasedLineMaterialOptions.useColors;\r\n        }\r\n        if (greasedLineMaterialOptions.visibility) {\r\n            this.visibility = greasedLineMaterialOptions.visibility;\r\n        }\r\n        if (greasedLineMaterialOptions.useDash) {\r\n            this.useDash = greasedLineMaterialOptions.useDash;\r\n        }\r\n        if (greasedLineMaterialOptions.dashCount) {\r\n            this.dashCount = greasedLineMaterialOptions.dashCount;\r\n        }\r\n        if (greasedLineMaterialOptions.dashRatio) {\r\n            this.dashRatio = greasedLineMaterialOptions.dashRatio;\r\n        }\r\n        if (greasedLineMaterialOptions.dashOffset) {\r\n            this.dashOffset = greasedLineMaterialOptions.dashOffset;\r\n        }\r\n        if (greasedLineMaterialOptions.width) {\r\n            this.width = greasedLineMaterialOptions.width;\r\n        }\r\n        if (greasedLineMaterialOptions.sizeAttenuation) {\r\n            this.sizeAttenuation = greasedLineMaterialOptions.sizeAttenuation;\r\n        }\r\n        if (greasedLineMaterialOptions.resolution) {\r\n            this.resolution = greasedLineMaterialOptions.resolution;\r\n        }\r\n        if (this.colors) {\r\n            this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, this.colors, this.colorsSampling, scene);\r\n        } else {\r\n            GreasedLineTools.PrepareEmptyColorsTexture(scene);\r\n        }\r\n\r\n        this.markAllDefinesAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param plugin define the config where to copy the info\r\n     */\r\n    public override copyTo(plugin: MaterialPluginBase): void {\r\n        const dest = plugin as GreasedLinePluginMaterial;\r\n\r\n        dest.colorsTexture?.dispose();\r\n\r\n        if (this._colors) {\r\n            dest.colorsTexture = GreasedLineTools.CreateColorsTexture(`${dest._material.name}-colors-texture`, this._colors, dest.colorsSampling, this._scene);\r\n        }\r\n\r\n        dest.setColor(this.color, true);\r\n        dest.colorsDistributionType = this.colorsDistributionType;\r\n        dest.colorsSampling = this.colorsSampling;\r\n        dest.colorMode = this.colorMode;\r\n        dest.useColors = this.useColors;\r\n        dest.visibility = this.visibility;\r\n        dest.useDash = this.useDash;\r\n        dest.dashCount = this.dashCount;\r\n        dest.dashRatio = this.dashRatio;\r\n        dest.dashOffset = this.dashOffset;\r\n        dest.width = this.width;\r\n        dest.sizeAttenuation = this.sizeAttenuation;\r\n        dest.resolution = this.resolution;\r\n\r\n        dest.markAllDefinesAsDirty();\r\n    }\r\n\r\n    private _isGLSL(shaderLanguage: ShaderLanguage) {\r\n        return shaderLanguage === ShaderLanguage.GLSL || this._forceGLSL;\r\n    }\r\n}\r\n\r\nRegisterClass(`BABYLON.${GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME}`, GreasedLinePluginMaterial);\r\n", "import type { Scene } from \"../../scene\";\r\nimport { RawTexture } from \"../Textures/rawTexture\";\r\nimport { ShaderMaterial } from \"../shaderMaterial\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Vector2 } from \"../../Maths/math.vector\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\nimport { TextureSampler } from \"../Textures/textureSampler\";\r\n\r\nimport type { GreasedLineMaterialOptions, IGreasedLineMaterial } from \"./greasedLineMaterialInterfaces\";\r\nimport { GreasedLineMeshColorDistributionType, GreasedLineMeshColorMode } from \"./greasedLineMaterialInterfaces\";\r\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools\";\r\nimport { GreasedLineMaterialDefaults } from \"./greasedLineMaterialDefaults\";\r\n\r\nexport const GreasedLineUseOffsetsSimpleMaterialDefine = \"GREASED_LINE_USE_OFFSETS\";\r\n\r\n/**\r\n * GreasedLineSimpleMaterial\r\n */\r\nexport class GreasedLineSimpleMaterial extends ShaderMaterial implements IGreasedLineMaterial {\r\n    /**\r\n     * Force to use GLSL in WebGPU\r\n     */\r\n    public static ForceGLSL = false;\r\n\r\n    private _visibility: number;\r\n    private _width: number;\r\n    private _useDash: boolean;\r\n    private _dashCount: number;\r\n    private _dashArray: number;\r\n    private _dashRatio: number;\r\n    private _dashOffset: number;\r\n    private _useColors: boolean;\r\n    private _color: Color3 = Color3.White();\r\n    private _colors: Nullable<Color3[]>;\r\n    private _colorsDistributionType: GreasedLineMeshColorDistributionType = GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;\r\n    private _colorMode: GreasedLineMeshColorMode;\r\n    private _colorsSampling: number;\r\n    private _resolution: Vector2;\r\n    private _sizeAttenuation: boolean;\r\n    private _colorsTexture: Nullable<RawTexture> = null;\r\n    private _cameraFacing: boolean;\r\n\r\n    /**\r\n     * GreasedLineSimple material constructor\r\n     * @param name material name\r\n     * @param scene the scene\r\n     * @param options material options\r\n     */\r\n    constructor(name: string, scene: Scene, options: GreasedLineMaterialOptions) {\r\n        const engine = scene.getEngine();\r\n        const isWGSL = engine.isWebGPU && !(options.forceGLSL || GreasedLineSimpleMaterial.ForceGLSL);\r\n\r\n        const defines = [\r\n            `COLOR_DISTRIBUTION_TYPE_LINE ${GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE}.`,\r\n            `COLOR_DISTRIBUTION_TYPE_SEGMENT ${GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT}.`,\r\n            `COLOR_MODE_SET ${GreasedLineMeshColorMode.COLOR_MODE_SET}.`,\r\n            `COLOR_MODE_ADD ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.`,\r\n            `COLOR_MODE_MULTIPLY ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.`,\r\n        ];\r\n        if (scene.useRightHandedSystem) {\r\n            defines.push(\"GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\");\r\n        }\r\n\r\n        const attributes = [\"position\", \"grl_widths\", \"grl_offsets\", \"grl_colorPointers\"];\r\n\r\n        if (options.cameraFacing) {\r\n            defines.push(\"GREASED_LINE_CAMERA_FACING\");\r\n            attributes.push(\"grl_previousAndSide\", \"grl_nextAndCounters\");\r\n        } else {\r\n            attributes.push(\"grl_slopes\");\r\n            attributes.push(\"grl_counters\");\r\n        }\r\n\r\n        const uniforms = [\r\n            \"grlColorsWidth\",\r\n            \"grlUseColors\",\r\n            \"grlWidth\",\r\n            \"grlColor\",\r\n            \"grl_colorModeAndColorDistributionType\",\r\n            \"grlResolution\",\r\n            \"grlAspect\",\r\n            \"grlAizeAttenuation\",\r\n            \"grlDashArray\",\r\n            \"grlDashOffset\",\r\n            \"grlDashRatio\",\r\n            \"grlUseDash\",\r\n            \"grlVisibility\",\r\n            \"grlColors\",\r\n        ];\r\n\r\n        if (!isWGSL) {\r\n            uniforms.push(\"world\", \"viewProjection\", \"view\", \"projection\");\r\n        }\r\n\r\n        super(\r\n            name,\r\n            scene,\r\n            {\r\n                vertex: \"greasedLine\",\r\n                fragment: \"greasedLine\",\r\n            },\r\n            {\r\n                uniformBuffers: isWGSL ? [\"Scene\", \"Mesh\"] : undefined,\r\n                attributes,\r\n                uniforms,\r\n                samplers: isWGSL ? [] : [\"grlColors\"],\r\n                defines,\r\n                extraInitializationsAsync: async () => {\r\n                    if (isWGSL) {\r\n                        await Promise.all([import(\"../../ShadersWGSL/greasedLine.vertex\"), import(\"../../ShadersWGSL/greasedLine.fragment\")]);\r\n                    } else {\r\n                        await Promise.all([import(\"../../Shaders/greasedLine.vertex\"), import(\"../../Shaders/greasedLine.fragment\")]);\r\n                    }\r\n                },\r\n                shaderLanguage: isWGSL ? ShaderLanguage.WGSL : ShaderLanguage.GLSL,\r\n            }\r\n        );\r\n\r\n        options = options || {\r\n            color: GreasedLineMaterialDefaults.DEFAULT_COLOR,\r\n        };\r\n\r\n        this.visibility = options.visibility ?? 1;\r\n        this.useDash = options.useDash ?? false;\r\n        this.dashRatio = options.dashRatio ?? 0.5;\r\n        this.dashOffset = options.dashOffset ?? 0;\r\n        this.dashCount = options.dashCount ?? 1; // calculate the _dashArray value, call the setter\r\n        this.width = options.width\r\n            ? options.width\r\n            : options.sizeAttenuation && options.cameraFacing\r\n              ? GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED\r\n              : GreasedLineMaterialDefaults.DEFAULT_WIDTH;\r\n        this.sizeAttenuation = options.sizeAttenuation ?? false;\r\n        this.color = options.color ?? Color3.White();\r\n        this.useColors = options.useColors ?? false;\r\n        this.colorsDistributionType = options.colorDistributionType ?? GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;\r\n        this.colorsSampling = options.colorsSampling ?? RawTexture.NEAREST_NEAREST;\r\n        this.colorMode = options.colorMode ?? GreasedLineMeshColorMode.COLOR_MODE_SET;\r\n        this._colors = options.colors ?? null;\r\n        this._cameraFacing = options.cameraFacing ?? true;\r\n        this.resolution = options.resolution ?? new Vector2(engine.getRenderWidth(), engine.getRenderHeight()); // calculate aspect call the setter\r\n\r\n        if (options.colorsTexture) {\r\n            this.colorsTexture = options.colorsTexture;\r\n        } else {\r\n            if (this._colors) {\r\n                this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this.name}-colors-texture`, this._colors, this.colorsSampling, scene);\r\n            } else {\r\n                this._color = this._color ?? GreasedLineMaterialDefaults.DEFAULT_COLOR;\r\n                this.colorsTexture = GreasedLineTools.PrepareEmptyColorsTexture(scene);\r\n            }\r\n        }\r\n\r\n        if (isWGSL) {\r\n            const sampler = new TextureSampler();\r\n            sampler.setParameters(); // use the default values\r\n            sampler.samplingMode = this.colorsSampling;\r\n            this.setTextureSampler(\"grlColorsSampler\", sampler);\r\n        }\r\n\r\n        engine.onDisposeObservable.add(() => {\r\n            GreasedLineTools.DisposeEmptyColorsTexture();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes the plugin material.\r\n     */\r\n    public override dispose(): void {\r\n        this._colorsTexture?.dispose();\r\n        super.dispose();\r\n    }\r\n\r\n    private _setColorModeAndColorDistributionType() {\r\n        this.setVector2(\"grl_colorModeAndColorDistributionType\", new Vector2(this._colorMode, this._colorsDistributionType));\r\n    }\r\n\r\n    /**\r\n     * Updates the material. Use when material created in lazy mode.\r\n     */\r\n    public updateLazy() {\r\n        if (this._colors) {\r\n            this.setColors(this._colors, false, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the colors used to colorize the line\r\n     */\r\n    get colors() {\r\n        return this._colors;\r\n    }\r\n\r\n    /**\r\n     * Sets the colors used to colorize the line\r\n     */\r\n    set colors(value: Nullable<Color3[]>) {\r\n        this.setColors(value);\r\n    }\r\n\r\n    /**\r\n     * Creates or updates the colors texture\r\n     * @param colors color table RGBA\r\n     * @param lazy if lazy, the colors are not updated\r\n     * @param forceNewTexture force creation of a new texture\r\n     */\r\n    public setColors(colors: Nullable<Color3[]>, lazy = false, forceNewTexture = false): void {\r\n        const origColorsCount = this._colors?.length ?? 0;\r\n\r\n        this._colors = colors;\r\n\r\n        if (colors === null || colors.length === 0) {\r\n            this._colorsTexture?.dispose();\r\n            return;\r\n        }\r\n\r\n        if (lazy && !forceNewTexture) {\r\n            return;\r\n        }\r\n\r\n        if (this._colorsTexture && origColorsCount === colors.length && !forceNewTexture) {\r\n            const colorArray = GreasedLineTools.Color3toRGBAUint8(colors);\r\n            this._colorsTexture.update(colorArray);\r\n        } else {\r\n            this._colorsTexture?.dispose();\r\n            this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this.name}-colors-texture`, colors, this.colorsSampling, this.getScene());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the colors texture\r\n     */\r\n    get colorsTexture() {\r\n        return (this._colorsTexture as RawTexture) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Sets the colorsTexture\r\n     */\r\n    set colorsTexture(value: RawTexture) {\r\n        this._colorsTexture = value;\r\n        this.setFloat(\"grlColorsWidth\", this._colorsTexture.getSize().width);\r\n        this.setTexture(\"grlColors\", this._colorsTexture);\r\n    }\r\n\r\n    /**\r\n     * Line base width. At each point the line width is calculated by widths[pointIndex] * width\r\n     */\r\n    get width() {\r\n        return this._width;\r\n    }\r\n\r\n    /**\r\n     * Line base width. At each point the line width is calculated by widths[pointIndex] * width\r\n     */\r\n    set width(value: number) {\r\n        this._width = value;\r\n        this.setFloat(\"grlWidth\", value);\r\n    }\r\n\r\n    /**\r\n     * Whether to use the colors option to colorize the line\r\n     */\r\n    get useColors() {\r\n        return this._useColors;\r\n    }\r\n\r\n    set useColors(value: boolean) {\r\n        this._useColors = value;\r\n        this.setFloat(\"grlUseColors\", GreasedLineTools.BooleanToNumber(value));\r\n    }\r\n\r\n    /**\r\n     * The type of sampling of the colors texture. The values are the same when using with textures.\r\n     */\r\n    get colorsSampling() {\r\n        return this._colorsSampling;\r\n    }\r\n\r\n    /**\r\n     * The type of sampling of the colors texture. The values are the same when using with textures.\r\n     */\r\n    set colorsSampling(value: number) {\r\n        this._colorsSampling = value;\r\n    }\r\n\r\n    /**\r\n     * Normalized value of how much of the line will be visible\r\n     * 0 - 0% of the line will be visible\r\n     * 1 - 100% of the line will be visible\r\n     */\r\n    get visibility() {\r\n        return this._visibility;\r\n    }\r\n\r\n    set visibility(value: number) {\r\n        this._visibility = value;\r\n        this.setFloat(\"grlVisibility\", value);\r\n    }\r\n\r\n    /**\r\n     * Turns on/off dash mode\r\n     */\r\n    get useDash() {\r\n        return this._useDash;\r\n    }\r\n\r\n    /**\r\n     * Turns on/off dash mode\r\n     */\r\n    set useDash(value: boolean) {\r\n        this._useDash = value;\r\n        this.setFloat(\"grlUseDash\", GreasedLineTools.BooleanToNumber(value));\r\n    }\r\n\r\n    /**\r\n     * Gets the dash offset\r\n     */\r\n    get dashOffset() {\r\n        return this._dashOffset;\r\n    }\r\n\r\n    /**\r\n     * Sets the dash offset\r\n     */\r\n    set dashOffset(value: number) {\r\n        this._dashOffset = value;\r\n        this.setFloat(\"grlDashOffset\", value);\r\n    }\r\n\r\n    /**\r\n     * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.\r\n     */\r\n    get dashRatio() {\r\n        return this._dashRatio;\r\n    }\r\n\r\n    /**\r\n     * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.\r\n     */\r\n    set dashRatio(value: number) {\r\n        this._dashRatio = value;\r\n        this.setFloat(\"grlDashRatio\", value);\r\n    }\r\n\r\n    /**\r\n     * Gets the number of dashes in the line\r\n     */\r\n    get dashCount() {\r\n        return this._dashCount;\r\n    }\r\n    /**\r\n     * Sets the number of dashes in the line\r\n     * @param value dash\r\n     */\r\n    set dashCount(value: number) {\r\n        this._dashCount = value;\r\n        this._dashArray = 1 / value;\r\n        this.setFloat(\"grlDashArray\", this._dashArray);\r\n    }\r\n\r\n    /**\r\n     * False means 1 unit in width = 1 unit on scene, true means 1 unit in width is reduced on the screen to make better looking lines\r\n     */\r\n    get sizeAttenuation() {\r\n        return this._sizeAttenuation;\r\n    }\r\n\r\n    /**\r\n     * Turn on/off attenuation of the width option and widths array.\r\n     * @param value false means 1 unit in width = 1 unit on scene, true means 1 unit in width is reduced on the screen to make better looking lines\r\n     */\r\n    set sizeAttenuation(value: boolean) {\r\n        this._sizeAttenuation = value;\r\n        this.setFloat(\"grlSizeAttenuation\", GreasedLineTools.BooleanToNumber(value));\r\n    }\r\n\r\n    /**\r\n     * Gets the color of the line\r\n     */\r\n    get color() {\r\n        return this._color;\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the line\r\n     * @param value Color3\r\n     */\r\n    set color(value: Color3) {\r\n        this.setColor(value);\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the line. If set the whole line will be mixed with this color according to the colorMode option.\r\n     * The simple material always needs a color to be set. If you set it to null it will set the color to the default color (GreasedLineSimpleMaterial.DEFAULT_COLOR).\r\n     * @param value color\r\n     */\r\n    public setColor(value: Nullable<Color3>) {\r\n        value = value ?? GreasedLineMaterialDefaults.DEFAULT_COLOR;\r\n        this._color = value;\r\n        this.setColor3(\"grlColor\", value);\r\n    }\r\n\r\n    /**\r\n     * Gets the color distributiopn type\r\n     */\r\n    get colorsDistributionType() {\r\n        return this._colorsDistributionType;\r\n    }\r\n\r\n    /**\r\n     * Sets the color distribution type\r\n     * @see GreasedLineMeshColorDistributionType\r\n     * @param value color distribution type\r\n     */\r\n    set colorsDistributionType(value: GreasedLineMeshColorDistributionType) {\r\n        this._colorsDistributionType = value;\r\n        this._setColorModeAndColorDistributionType();\r\n    }\r\n\r\n    /**\r\n     * Gets the mixing mode of the color and colors paramaters. Default value is GreasedLineMeshColorMode.SET.\r\n     * MATERIAL_TYPE_SIMPLE mixes the color and colors of the greased line material.\r\n     * @see GreasedLineMeshColorMode\r\n     */\r\n    get colorMode() {\r\n        return this._colorMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the mixing mode of the color and colors paramaters. Default value is GreasedLineMeshColorMode.SET.\r\n     * MATERIAL_TYPE_SIMPLE mixes the color and colors of the greased line material.\r\n     * @see GreasedLineMeshColorMode\r\n     */\r\n    set colorMode(value: GreasedLineMeshColorMode) {\r\n        this._colorMode = value;\r\n        this._setColorModeAndColorDistributionType();\r\n    }\r\n\r\n    /**\r\n     * Gets the resolution\r\n     */\r\n    get resolution() {\r\n        return this._resolution;\r\n    }\r\n\r\n    /**\r\n     * Sets the resolution\r\n     * @param value resolution of the screen for GreasedLine\r\n     */\r\n    set resolution(value: Vector2) {\r\n        this._resolution = value;\r\n        this.setVector2(\"grlResolution\", value);\r\n        this.setFloat(\"grlAspect\", value.x / value.y);\r\n    }\r\n\r\n    /**\r\n     * Serializes this plugin material\r\n     * @returns serializationObjec\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        const greasedLineMaterialOptions: GreasedLineMaterialOptions = {\r\n            colorDistributionType: this._colorsDistributionType,\r\n            colorsSampling: this._colorsSampling,\r\n            colorMode: this._colorMode,\r\n            color: this._color,\r\n            dashCount: this._dashCount,\r\n            dashOffset: this._dashOffset,\r\n            dashRatio: this._dashRatio,\r\n            resolution: this._resolution,\r\n            sizeAttenuation: this._sizeAttenuation,\r\n            useColors: this._useColors,\r\n            useDash: this._useDash,\r\n            visibility: this._visibility,\r\n            width: this._width,\r\n            cameraFacing: this._cameraFacing,\r\n        };\r\n\r\n        if (this._colors) {\r\n            greasedLineMaterialOptions.colors = this._colors;\r\n        }\r\n\r\n        serializationObject.greasedLineMaterialOptions = greasedLineMaterialOptions;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized objects\r\n     * @param source serialized object\r\n     * @param scene scene\r\n     * @param _rootUrl root url for textures\r\n     */\r\n    public parse(source: any, scene: Scene, _rootUrl: string): void {\r\n        const greasedLineMaterialOptions = <GreasedLineMaterialOptions>source.greasedLineMaterialOptions;\r\n\r\n        this._colorsTexture?.dispose();\r\n\r\n        if (greasedLineMaterialOptions.color) {\r\n            this.color = greasedLineMaterialOptions.color;\r\n        }\r\n        if (greasedLineMaterialOptions.colorDistributionType) {\r\n            this.colorsDistributionType = greasedLineMaterialOptions.colorDistributionType;\r\n        }\r\n        if (greasedLineMaterialOptions.colorsSampling) {\r\n            this.colorsSampling = greasedLineMaterialOptions.colorsSampling;\r\n        }\r\n        if (greasedLineMaterialOptions.colorMode) {\r\n            this.colorMode = greasedLineMaterialOptions.colorMode;\r\n        }\r\n        if (greasedLineMaterialOptions.useColors) {\r\n            this.useColors = greasedLineMaterialOptions.useColors;\r\n        }\r\n        if (greasedLineMaterialOptions.visibility) {\r\n            this.visibility = greasedLineMaterialOptions.visibility;\r\n        }\r\n        if (greasedLineMaterialOptions.useDash) {\r\n            this.useDash = greasedLineMaterialOptions.useDash;\r\n        }\r\n        if (greasedLineMaterialOptions.dashCount) {\r\n            this.dashCount = greasedLineMaterialOptions.dashCount;\r\n        }\r\n        if (greasedLineMaterialOptions.dashRatio) {\r\n            this.dashRatio = greasedLineMaterialOptions.dashRatio;\r\n        }\r\n        if (greasedLineMaterialOptions.dashOffset) {\r\n            this.dashOffset = greasedLineMaterialOptions.dashOffset;\r\n        }\r\n        if (greasedLineMaterialOptions.width) {\r\n            this.width = greasedLineMaterialOptions.width;\r\n        }\r\n        if (greasedLineMaterialOptions.sizeAttenuation) {\r\n            this.sizeAttenuation = greasedLineMaterialOptions.sizeAttenuation;\r\n        }\r\n        if (greasedLineMaterialOptions.resolution) {\r\n            this.resolution = greasedLineMaterialOptions.resolution;\r\n        }\r\n        if (greasedLineMaterialOptions.colors) {\r\n            this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this.name}-colors-texture`, greasedLineMaterialOptions.colors, this.colorsSampling, this.getScene());\r\n        } else {\r\n            this.colorsTexture = GreasedLineTools.PrepareEmptyColorsTexture(scene);\r\n        }\r\n\r\n        this._cameraFacing = greasedLineMaterialOptions.cameraFacing ?? true;\r\n        this.setDefine(\"GREASED_LINE_CAMERA_FACING\", this._cameraFacing);\r\n    }\r\n}\r\n", "import type { Scene } from \"../../scene\";\r\nimport type { IGreasedLineMaterial } from \"../../Materials/GreasedLine/greasedLineMaterialInterfaces\";\r\nimport { GreasedLinePluginMaterial } from \"../../Materials/GreasedLine/greasedLinePluginMaterial\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { Buffer } from \"../../Buffers/buffer\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport { GreasedLineSimpleMaterial, GreasedLineUseOffsetsSimpleMaterialDefine } from \"../../Materials/GreasedLine/greasedLineSimpleMaterial\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { FloatArray, IndicesArray } from \"../../types\";\r\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools\";\r\n\r\n/**\r\n * In POINTS_MODE_POINTS every array of points will become the center (backbone) of the ribbon. The ribbon will be expanded by `width / 2` to `+direction` and `-direction` as well.\r\n * In POINTS_MODE_PATHS every array of points specifies an edge. These will be used to build one ribbon.\r\n */\r\nexport const enum GreasedLineRibbonPointsMode {\r\n    POINTS_MODE_POINTS = 0,\r\n    POINTS_MODE_PATHS = 1,\r\n}\r\n\r\n/**\r\n * FACES_MODE_SINGLE_SIDED single sided with back face culling. Default value.\r\n * FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING single sided without back face culling. Sets backFaceCulling = false on the material so it affects all line ribbons added to the line ribbon instance.\r\n * FACES_MODE_DOUBLE_SIDED extra back faces are created. This doubles the amount of faces of the mesh.\r\n */\r\nexport const enum GreasedLineRibbonFacesMode {\r\n    FACES_MODE_SINGLE_SIDED = 0,\r\n    FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING = 1,\r\n    FACES_MODE_DOUBLE_SIDED = 2,\r\n}\r\n\r\n/**\r\n * Only with POINTS_MODE_PATHS.\r\n * AUTO_DIRECTIONS_FROM_FIRST_SEGMENT sets the direction (slope) of the ribbon from the direction of the first line segment. Recommended.\r\n * AUTO_DIRECTIONS_FROM_ALL_SEGMENTS in this mode the direction (slope) will be calculated for each line segment according to the direction vector between each point of the line segments. Slow method.\r\n * AUTO_DIRECTIONS_ENHANCED in this mode the direction (slope) will be calculated for each line segment according to the direction vector between each point of the line segments using a more sophisitcaed algorithm. Slowest method.\r\n * AUTO_DIRECTIONS_FACE_TO in this mode the direction (slope) will be calculated for each line segment according to the direction vector between each point of the line segments and a direction (face-to) vector specified in direction. The resulting line will face to the direction of this face-to vector.\r\n * AUTO_DIRECTIONS_NONE you have to set the direction (slope) manually. Recommended.\r\n */\r\nexport const enum GreasedLineRibbonAutoDirectionMode {\r\n    AUTO_DIRECTIONS_FROM_FIRST_SEGMENT = 0,\r\n    AUTO_DIRECTIONS_FROM_ALL_SEGMENTS = 1,\r\n    AUTO_DIRECTIONS_ENHANCED = 2,\r\n    AUTO_DIRECTIONS_FACE_TO = 3,\r\n    AUTO_DIRECTIONS_NONE = 99,\r\n}\r\n\r\nexport type GreasedLineRibbonOptions = {\r\n    /**\r\n     * Defines how the points are processed.\r\n     * In GreasedLineRibbonPointsMode.POINTS_MODE_POINTS every array of points will become the center of the ribbon. The ribbon will be expanded by width/2 to +direction and -direction as well.\r\n     * In GreasedLineRibbonPointsMode.POINTS_MODE_PATHS every array of points is one path. These will be used to buuid one ribbon.\r\n     */\r\n    pointsMode?: GreasedLineRibbonPointsMode;\r\n    /**\r\n     * Normalized directions of the slopes of the non camera facing lines.\r\n     */\r\n    directions?: Vector3[] | Vector3;\r\n    /**\r\n     * Defines the calculation mode of the directions which the line will be thickened to.\r\n     */\r\n    directionsAutoMode?: GreasedLineRibbonAutoDirectionMode;\r\n    /**\r\n     * Width of the ribbon.\r\n     */\r\n    width?: number;\r\n    /**\r\n     * Controls how the faces are created.\r\n     * GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED = single sided with back face culling. Default value.\r\n     * GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING = single sided without back face culling\r\n     * GreasedLineRibbonFacesMode.FACES_MODE_DOUBLE_SIDED = extra back faces are created. This doubles the amount of faces of the mesh.\r\n     */\r\n    facesMode?: GreasedLineRibbonFacesMode;\r\n    /**\r\n     * If true, the path will be closed.\r\n     */\r\n    closePath?: boolean;\r\n    /**\r\n     * If true, normals will be computed when creating the vertex buffers.\r\n     * This results to smooth shading of the mesh.\r\n     */\r\n    smoothShading?: boolean;\r\n};\r\n\r\nexport type GreasedLinePoints = Vector3[] | Vector3[][] | Float32Array | Float32Array[] | number[][] | number[];\r\n\r\n/**\r\n * Options for converting the points to the internal number[][] format used by GreasedLine\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface GreasedLinePointsOptions {\r\n    /**\r\n     * If defined and a Float32Array is used for the points parameter,\r\n     * it will create multiple disconnected lines.\r\n     * This parameter defines how many entries from the array to use for one line.\r\n     * One entry = 3 float values.\r\n     */\r\n    floatArrayStride?: number;\r\n}\r\n\r\n/**\r\n * Options for creating a GreasedLineMesh\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface GreasedLineMeshOptions {\r\n    /**\r\n     * Points of the line.\r\n     */\r\n    points: GreasedLinePoints;\r\n    /**\r\n     * Each line segment (from point to point) can have it's width multiplier. Final width = widths[segmentIdx] * width.\r\n     * Defaults to empty array.\r\n     */\r\n    widths?: number[];\r\n    /**\r\n     * If instance is specified, lines are added to the specified instance.\r\n     * Defaults to undefined.\r\n     */\r\n    instance?: GreasedLineBaseMesh;\r\n    /**\r\n     * You can manually set the color pointers so you can control which segment/part\r\n     * will use which color from the colors material option\r\n     */\r\n    colorPointers?: number[];\r\n    /**\r\n     * UVs for the mesh\r\n     */\r\n    uvs?: FloatArray;\r\n    /**\r\n     * If true, offsets and widths are updatable.\r\n     * Defaults to false.\r\n     */\r\n    updatable?: boolean;\r\n    /**\r\n     * Use when @see instance is specified.\r\n     * If true, the line will be rendered only after calling instance.updateLazy(). If false, line will be rerendered after every call to @see CreateGreasedLine\r\n     * Defaults to false.\r\n     */\r\n    lazy?: boolean;\r\n    /**\r\n     * The options for the ribbon which will be used as a line.\r\n     * If this option is set the line switches automatically to a non camera facing mode.\r\n     */\r\n    ribbonOptions?: GreasedLineRibbonOptions;\r\n    /**\r\n     * Options for converting the points.\r\n     */\r\n    pointsOptions?: GreasedLinePointsOptions;\r\n}\r\n\r\n/**\r\n * GreasedLineBaseMesh\r\n */\r\nexport abstract class GreasedLineBaseMesh extends Mesh {\r\n    protected _vertexPositions: FloatArray;\r\n    protected _indices: IndicesArray;\r\n    protected _uvs: FloatArray;\r\n    protected _points: number[][];\r\n    protected _offsets: number[];\r\n    protected _colorPointers: number[];\r\n    protected _widths: number[];\r\n\r\n    protected _offsetsBuffer?: Buffer;\r\n    protected _widthsBuffer?: Buffer;\r\n    protected _colorPointersBuffer?: Buffer;\r\n\r\n    protected _lazy = false;\r\n    protected _updatable = false;\r\n\r\n    protected _engine: AbstractEngine;\r\n\r\n    constructor(\r\n        public override readonly name: string,\r\n        scene: Scene,\r\n        protected _options: GreasedLineMeshOptions\r\n    ) {\r\n        super(name, scene, null, null, false, false);\r\n\r\n        this._engine = scene.getEngine();\r\n\r\n        this._lazy = _options.lazy ?? false;\r\n        this._updatable = _options.updatable ?? false;\r\n\r\n        this._vertexPositions = [];\r\n        this._indices = [];\r\n        this._uvs = [];\r\n        this._points = [];\r\n        this._colorPointers = _options.colorPointers ?? [];\r\n        this._widths = _options.widths ?? new Array(_options.points.length).fill(1);\r\n    }\r\n\r\n    /**\r\n     * \"GreasedLineMesh\"\r\n     * @returns \"GreasedLineMesh\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"GreasedLineMesh\";\r\n    }\r\n\r\n    protected abstract _setPoints(points: number[][], options?: GreasedLineMeshOptions): void;\r\n    protected abstract _updateColorPointers(): void;\r\n    protected abstract _updateWidths(): void;\r\n\r\n    protected _updateWidthsWithValue(defaulValue: number) {\r\n        let pointCount = 0;\r\n        for (const points of this._points) {\r\n            pointCount += points.length;\r\n        }\r\n        const countDiff = (pointCount / 3) * 2 - this._widths.length;\r\n        for (let i = 0; i < countDiff; i++) {\r\n            this._widths.push(defaulValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updated a lazy line. Rerenders the line and updates boundinfo as well.\r\n     */\r\n    public updateLazy() {\r\n        this._setPoints(this._points);\r\n        if (!this._options.colorPointers) {\r\n            this._updateColorPointers();\r\n        }\r\n        this._createVertexBuffers(this._options.ribbonOptions?.smoothShading);\r\n        !this.doNotSyncBoundingInfo && this.refreshBoundingInfo();\r\n\r\n        this.greasedLineMaterial?.updateLazy();\r\n    }\r\n\r\n    /**\r\n     * Adds new points to the line. It doesn't rerenders the line if in lazy mode.\r\n     * @param points points table\r\n     * @param options optional options\r\n     */\r\n    public addPoints(points: number[][], options?: GreasedLineMeshOptions) {\r\n        for (const p of points) {\r\n            this._points.push(p);\r\n        }\r\n\r\n        if (!this._lazy) {\r\n            this.setPoints(this._points, options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the line and it's resources\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public override dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false) {\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * @returns true if the mesh was created in lazy mode\r\n     */\r\n    public isLazy(): boolean {\r\n        return this._lazy;\r\n    }\r\n\r\n    /**\r\n     * Returns the UVs\r\n     */\r\n    get uvs() {\r\n        return this._uvs;\r\n    }\r\n\r\n    /**\r\n     * Sets the UVs\r\n     * @param uvs the UVs\r\n     */\r\n    set uvs(uvs: FloatArray) {\r\n        this._uvs = uvs instanceof Float32Array ? uvs : new Float32Array(uvs);\r\n        this._createVertexBuffers();\r\n    }\r\n\r\n    /**\r\n     * Returns the points offsets\r\n     * Return the points offsets\r\n     */\r\n    get offsets() {\r\n        return this._offsets;\r\n    }\r\n\r\n    /**\r\n     * Sets point offests\r\n     * @param offsets offset table [x,y,z, x,y,z, ....]\r\n     */\r\n    set offsets(offsets: number[]) {\r\n        if (this.material instanceof GreasedLineSimpleMaterial) {\r\n            this.material.setDefine(GreasedLineUseOffsetsSimpleMaterialDefine, offsets?.length > 0);\r\n        }\r\n        this._offsets = offsets;\r\n        if (!this._offsetsBuffer) {\r\n            this._createOffsetsBuffer(offsets);\r\n        } else {\r\n            this._offsetsBuffer.update(offsets);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets widths at each line point like [widthLower, widthUpper, widthLower, widthUpper, ...]\r\n     */\r\n    get widths() {\r\n        return this._widths;\r\n    }\r\n\r\n    /**\r\n     * Sets widths at each line point\r\n     * @param widths width table [widthLower, widthUpper, widthLower, widthUpper ...]\r\n     */\r\n    set widths(widths: number[]) {\r\n        this._widths = widths;\r\n        if (!this._lazy) {\r\n            this._widthsBuffer && this._widthsBuffer.update(widths);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the color pointer. Each vertex need a color pointer. These color pointers points to the colors in the color table @see colors\r\n     */\r\n    get colorPointers() {\r\n        return this._colorPointers;\r\n    }\r\n\r\n    /**\r\n     * Sets the color pointer\r\n     * @param colorPointers array of color pointer in the colors array. One pointer for every vertex is needed.\r\n     */\r\n    set colorPointers(colorPointers: number[]) {\r\n        this._colorPointers = colorPointers;\r\n        if (!this._lazy) {\r\n            this._colorPointersBuffer && this._colorPointersBuffer.update(colorPointers);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the pluginMaterial associated with line\r\n     */\r\n    get greasedLineMaterial(): IGreasedLineMaterial | undefined {\r\n        if (this.material && this.material instanceof GreasedLineSimpleMaterial) {\r\n            return this.material;\r\n        }\r\n        const materialPlugin = this.material?.pluginManager?.getPlugin(GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME);\r\n        if (materialPlugin) {\r\n            return <GreasedLinePluginMaterial>materialPlugin;\r\n        }\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Return copy the points.\r\n     */\r\n    get points() {\r\n        const pointsCopy: number[][] = [];\r\n        DeepCopier.DeepCopy(this._points, pointsCopy);\r\n        return pointsCopy;\r\n    }\r\n\r\n    /**\r\n     * Sets line points and rerenders the line.\r\n     * @param points points table\r\n     * @param options optional options\r\n     */\r\n    public setPoints(points: GreasedLinePoints, options?: GreasedLineMeshOptions) {\r\n        this._points = GreasedLineTools.ConvertPoints(points, options?.pointsOptions ?? this._options.pointsOptions);\r\n        this._updateWidths();\r\n        if (!options?.colorPointers) {\r\n            this._updateColorPointers();\r\n        }\r\n        this._setPoints(this._points, options);\r\n    }\r\n\r\n    protected _initGreasedLine() {\r\n        this._vertexPositions = [];\r\n        this._indices = [];\r\n        this._uvs = [];\r\n    }\r\n\r\n    protected _createLineOptions() {\r\n        const lineOptions: GreasedLineMeshOptions = {\r\n            points: this._points,\r\n            colorPointers: this._colorPointers,\r\n            lazy: this._lazy,\r\n            updatable: this._updatable,\r\n            uvs: this._uvs,\r\n            widths: this._widths,\r\n            ribbonOptions: this._options.ribbonOptions,\r\n        };\r\n        return lineOptions;\r\n    }\r\n\r\n    /**\r\n     * Serializes this GreasedLineMesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public override serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.type = this.getClassName();\r\n\r\n        serializationObject.lineOptions = this._createLineOptions();\r\n    }\r\n\r\n    protected _createVertexBuffers(computeNormals = false) {\r\n        const vertexData = new VertexData();\r\n        vertexData.positions = this._vertexPositions;\r\n        vertexData.indices = this._indices;\r\n        vertexData.uvs = this._uvs;\r\n        if (computeNormals) {\r\n            vertexData.normals = [];\r\n            VertexData.ComputeNormals(this._vertexPositions, this._indices, vertexData.normals);\r\n        }\r\n        vertexData.applyToMesh(this, this._options.updatable);\r\n        return vertexData;\r\n    }\r\n\r\n    protected _createOffsetsBuffer(offsets: number[]) {\r\n        const engine = this._scene.getEngine();\r\n\r\n        const offsetBuffer = new Buffer(engine, offsets, this._updatable, 3);\r\n        this.setVerticesBuffer(offsetBuffer.createVertexBuffer(\"grl_offsets\", 0, 3));\r\n        this._offsetsBuffer = offsetBuffer;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["array", "inputArray", "GetCustomCode", "GetCustomCode", "GreasedLineRibbonPointsMode", "GreasedLineRibbonFacesMode", "GreasedLineRibbonAutoDirectionMode"]
}
