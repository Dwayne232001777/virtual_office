import {
  CreateTextShapePaths,
  MaterialPluginBase,
  Mesh,
  ProceduralTexture,
  RawTexture,
  ShaderMaterial,
  init_materialPluginBase,
  init_mesh,
  init_proceduralTexture,
  init_rawTexture,
  init_shaderMaterial,
  init_textBuilder
} from "./chunk-JWLZD23T.js";
import {
  MaterialDefines,
  init_materialDefines
} from "./chunk-OBADV6JF.js";
import {
  VertexData,
  init_mesh_vertexData
} from "./chunk-TMHG26QH.js";
import {
  Engine,
  init_engine
} from "./chunk-E2UXTG46.js";
import {
  Curve3,
  init_math_path
} from "./chunk-2EZNXTHP.js";
import {
  Buffer,
  VertexBuffer,
  init_buffer
} from "./chunk-YEEYUO2W.js";
import {
  Color3,
  init_math_color
} from "./chunk-FQA5U7KF.js";
import {
  DeepCopier,
  init_deepCopier
} from "./chunk-TQMUJQOB.js";
import {
  TextureSampler,
  init_textureSampler
} from "./chunk-WTQMXJ7P.js";
import {
  TmpVectors,
  Vector2,
  Vector3,
  init_math_vector
} from "./chunk-VQZCJUUR.js";
import {
  RegisterClass,
  init_typeStore
} from "./chunk-7ANHXSNA.js";
import {
  __esm
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@babylonjs/core/Helpers/materialConversionHelper.js
function CubicBezierCurve(t, p0, p1, p2, p3) {
  return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;
}
function SpecularPowerToRoughness(specularPower, p0 = new Vector2(0, 1), p1 = new Vector2(0, 0.1), p2 = new Vector2(0, 0.1), p3 = new Vector2(1300, 0.1)) {
  const t = Math.pow(specularPower / p3.x, 0.333333);
  return CubicBezierCurve(t, p0.y, p1.y, p2.y, p3.y);
}
var init_materialConversionHelper = __esm({
  "node_modules/@babylonjs/core/Helpers/materialConversionHelper.js"() {
    init_math_vector();
  }
});

// node_modules/@babylonjs/core/Materials/Textures/textureMerger.js
function IsTextureInput(input) {
  return "texture" in input;
}
function IsConstantInput(input) {
  return "value" in input;
}
function CopyTextureTransform(source, destination) {
  destination.uOffset = source.uOffset;
  destination.vOffset = source.vOffset;
  destination.uScale = source.uScale;
  destination.vScale = source.vScale;
  destination.uAng = source.uAng;
  destination.vAng = source.vAng;
  destination.wAng = source.wAng;
  destination.uRotationCenter = source.uRotationCenter;
  destination.vRotationCenter = source.vRotationCenter;
}
async function MergeTexturesAsync(name, config, scene) {
  const channels = [config.red, config.green, config.blue, config.alpha];
  const textureInputs = [];
  const textureInputMap = [];
  for (let channelIndex = 0; channelIndex < 4; channelIndex++) {
    const channel = channels[channelIndex];
    if (channel) {
      if (IsTextureInput(channel)) {
        if (channel.sourceChannel < 0 || channel.sourceChannel > 3) {
          throw new Error("Source channel must be between 0 and 3 (R, G, B, A)");
        }
        let textureIndex = textureInputs.indexOf(channel.texture);
        if (textureIndex === -1) {
          textureIndex = textureInputs.length;
          textureInputs.push(channel.texture);
        }
        textureInputMap[channelIndex] = textureIndex;
      } else if (IsConstantInput(channel)) {
        if (channel.value < 0 || channel.value > 1) {
          throw new Error("Constant value must be between 0.0 and 1.0");
        }
        textureInputMap[channelIndex] = -1;
      } else {
        throw new Error("Invalid channel input configuration");
      }
    } else {
      textureInputMap[channelIndex] = -1;
    }
  }
  let outputSize = config.outputSize;
  if (!outputSize && textureInputs.length > 0) {
    let maxSize = 0;
    for (const texture of textureInputs) {
      const size = texture.getSize();
      const currentSize = Math.max(size.width, size.height);
      if (currentSize > maxSize) {
        maxSize = currentSize;
        outputSize = size.width === size.height ? maxSize : size;
      }
    }
  }
  outputSize = outputSize || 512;
  const defines = [];
  const usedTextures = /* @__PURE__ */ new Set();
  for (let channelIndex = 0; channelIndex < 4; channelIndex++) {
    const channel = channels[channelIndex];
    const channelName = ["RED", "GREEN", "BLUE", "ALPHA"][channelIndex];
    if (channel && IsTextureInput(channel)) {
      defines.push(`${channelName}_FROM_TEXTURE`);
      const textureIndex = textureInputMap[channelIndex];
      usedTextures.add(textureIndex);
    }
  }
  usedTextures.forEach((textureIndex) => {
    defines.push(`USE_TEXTURE${textureIndex}`);
  });
  const outputTextureOptions = {
    type: 2,
    format: 5,
    samplingMode: 1,
    generateDepthBuffer: false,
    generateMipMaps: false,
    shaderLanguage: scene.getEngine().isWebGPU ? 1 : 0,
    extraInitializationsAsync: async () => {
      if (scene.getEngine().isWebGPU) {
        await Promise.all([import("./textureMerger.fragment-Z7GJ4PBL.js")]);
      } else {
        await Promise.all([import("./textureMerger.fragment-4Z2LXIIP.js")]);
      }
    }
  };
  const proceduralTexture = new ProceduralTexture(name, outputSize, _ShaderName, scene, outputTextureOptions);
  proceduralTexture.refreshRate = -1;
  proceduralTexture.defines = defines.length > 0 ? "#define " + defines.join("\n#define ") + "\n" : "";
  for (let i = 0; i < textureInputs.length; i++) {
    CopyTextureTransform(textureInputs[i], proceduralTexture);
    proceduralTexture.setTexture(`inputTexture${i}`, textureInputs[i]);
  }
  for (let channelIndex = 0; channelIndex < 4; channelIndex++) {
    const channel = channels[channelIndex];
    const channelName = ["red", "green", "blue", "alpha"][channelIndex];
    if (channel && IsTextureInput(channel)) {
      const textureIndex = textureInputMap[channelIndex];
      proceduralTexture.setInt(`${channelName}TextureIndex`, textureIndex);
      proceduralTexture.setInt(`${channelName}SourceChannel`, channel.sourceChannel);
    } else {
      let constantValue;
      if (channel && IsConstantInput(channel)) {
        constantValue = channel.value;
      } else {
        constantValue = channelIndex === 3 ? 1 : 0;
      }
      proceduralTexture.setFloat(`${channelName}ConstantValue`, constantValue);
    }
  }
  return await new Promise((resolve, reject) => {
    proceduralTexture.executeWhenReady(() => {
      try {
        proceduralTexture.render();
        resolve(proceduralTexture);
      } catch (error) {
        reject(error instanceof Error ? error : new Error(String(error)));
      }
    });
  });
}
function CreateTextureInput(texture, sourceChannel) {
  return { texture, sourceChannel };
}
function CreateConstantInput(value) {
  return { value };
}
function CreateRGBAConfiguration(red, green, blue, alpha) {
  return { red, green, blue, alpha };
}
var _ShaderName;
var init_textureMerger = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/textureMerger.js"() {
    init_proceduralTexture();
    _ShaderName = "textureMerger";
  }
});

// node_modules/@babylonjs/core/Materials/GreasedLine/greasedLineMaterialDefaults.js
var GreasedLineMaterialDefaults;
var init_greasedLineMaterialDefaults = __esm({
  "node_modules/@babylonjs/core/Materials/GreasedLine/greasedLineMaterialDefaults.js"() {
    init_math_color();
    GreasedLineMaterialDefaults = class {
    };
    GreasedLineMaterialDefaults.DEFAULT_COLOR = Color3.White();
    GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED = 1;
    GreasedLineMaterialDefaults.DEFAULT_WIDTH = 0.1;
  }
});

// node_modules/@babylonjs/core/Misc/greasedLineTools.js
var GreasedLineTools;
var init_greasedLineTools = __esm({
  "node_modules/@babylonjs/core/Misc/greasedLineTools.js"() {
    init_math_path();
    init_buffer();
    init_math_vector();
    init_textBuilder();
    init_rawTexture();
    init_engine();
    init_greasedLineMaterialDefaults();
    GreasedLineTools = class _GreasedLineTools {
      /**
       * Converts GreasedLinePoints to number[][]
       * @param points GreasedLinePoints
       * @param options GreasedLineToolsConvertPointsOptions
       * @returns number[][] with x, y, z coordinates of the points, like [[x, y, z, x, y, z, ...], [x, y, z, ...]]
       */
      static ConvertPoints(points, options) {
        if (points.length && Array.isArray(points) && typeof points[0] === "number") {
          return [points];
        } else if (points.length && Array.isArray(points[0]) && typeof points[0][0] === "number") {
          return points;
        } else if (points.length && !Array.isArray(points[0]) && points[0] instanceof Vector3) {
          const positions = [];
          for (let j = 0; j < points.length; j++) {
            const p = points[j];
            positions.push(p.x, p.y, p.z);
          }
          return [positions];
        } else if (points.length > 0 && Array.isArray(points[0]) && points[0].length > 0 && points[0][0] instanceof Vector3) {
          const positions = [];
          const vectorPoints = points;
          for (const p of vectorPoints) {
            positions.push(p.flatMap((p2) => [p2.x, p2.y, p2.z]));
          }
          return positions;
        } else if (points instanceof Float32Array) {
          if (options?.floatArrayStride) {
            const positions = [];
            const stride = options.floatArrayStride * 3;
            for (let i = 0; i < points.length; i += stride) {
              const linePoints = new Array(stride);
              for (let j = 0; j < stride; j++) {
                linePoints[j] = points[i + j];
              }
              positions.push(linePoints);
            }
            return positions;
          } else {
            return [Array.from(points)];
          }
        } else if (points.length && points[0] instanceof Float32Array) {
          const positions = [];
          for (const p of points) {
            positions.push(Array.from(p));
          }
          return positions;
        }
        return [];
      }
      /**
       * Omit zero length lines predicate for the MeshesToLines function
       * @param p1 point1 position of the face
       * @param p2 point2 position of the face
       * @param p3 point3 position of the face
       * @returns original points or null if any edge length is zero
       */
      static OmitZeroLengthPredicate(p1, p2, p3) {
        const fileredPoints = [];
        if (p2.subtract(p1).lengthSquared() > 0) {
          fileredPoints.push([p1, p2]);
        }
        if (p3.subtract(p2).lengthSquared() > 0) {
          fileredPoints.push([p2, p3]);
        }
        if (p1.subtract(p3).lengthSquared() > 0) {
          fileredPoints.push([p3, p1]);
        }
        return fileredPoints.length === 0 ? null : fileredPoints;
      }
      /**
       * Omit duplicate lines predicate for the MeshesToLines function
       * @param p1 point1 position of the face
       * @param p2 point2 position of the face
       * @param p3 point3 position of the face
       * @param points array of points to search in
       * @returns original points or null if any edge length is zero
       */
      static OmitDuplicatesPredicate(p1, p2, p3, points) {
        const fileredPoints = [];
        if (!_GreasedLineTools._SearchInPoints(p1, p2, points)) {
          fileredPoints.push([p1, p2]);
        }
        if (!_GreasedLineTools._SearchInPoints(p2, p3, points)) {
          fileredPoints.push([p2, p3]);
        }
        if (!_GreasedLineTools._SearchInPoints(p3, p1, points)) {
          fileredPoints.push([p3, p1]);
        }
        return fileredPoints.length === 0 ? null : fileredPoints;
      }
      static _SearchInPoints(p1, p2, points) {
        for (const ps of points) {
          for (let i = 0; i < ps.length; i++) {
            if (ps[i]?.equals(p1)) {
              if (ps[i + 1]?.equals(p2) || ps[i - 1]?.equals(p2)) {
                return true;
              }
            }
          }
        }
        return false;
      }
      /**
       * Gets mesh triangles as line positions
       * @param meshes array of meshes
       * @param predicate predicate function which decides whether to include the mesh triangle/face in the ouput
       * @returns array of arrays of points
       */
      static MeshesToLines(meshes, predicate) {
        const points = [];
        for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
          const mesh = meshes[meshIndex];
          const vertices = mesh.getVerticesData(VertexBuffer.PositionKind);
          const indices = mesh.getIndices();
          if (vertices && indices) {
            for (let i = 0, ii = 0; i < indices.length; i++) {
              const vi1 = indices[ii++] * 3;
              const vi2 = indices[ii++] * 3;
              const vi3 = indices[ii++] * 3;
              const p1 = new Vector3(vertices[vi1], vertices[vi1 + 1], vertices[vi1 + 2]);
              const p2 = new Vector3(vertices[vi2], vertices[vi2 + 1], vertices[vi2 + 2]);
              const p3 = new Vector3(vertices[vi3], vertices[vi3 + 1], vertices[vi3 + 2]);
              if (predicate) {
                const pointsFromPredicate = predicate(p1, p2, p3, points, i, vi1, mesh, meshIndex, vertices, indices);
                if (pointsFromPredicate) {
                  for (const p of pointsFromPredicate) {
                    points.push(p);
                  }
                }
              } else {
                points.push([p1, p2], [p2, p3], [p3, p1]);
              }
            }
          }
        }
        return points;
      }
      /**
       * Converts number coordinates to Vector3s
       * @param points number array of x, y, z, x, y z, ... coordinates
       * @returns Vector3 array
       */
      static ToVector3Array(points) {
        if (Array.isArray(points[0])) {
          const array2 = [];
          const inputArray2 = points;
          for (const subInputArray of inputArray2) {
            const subArray = [];
            for (let i = 0; i < subInputArray.length; i += 3) {
              subArray.push(new Vector3(subInputArray[i], subInputArray[i + 1], subInputArray[i + 2]));
            }
            array2.push(subArray);
          }
          return array2;
        }
        const inputArray = points;
        const array = [];
        for (let i = 0; i < inputArray.length; i += 3) {
          array.push(new Vector3(inputArray[i], inputArray[i + 1], inputArray[i + 2]));
        }
        return array;
      }
      /**
       * Gets a number array from a Vector3 array.
       * You can you for example to convert your Vector3[] offsets to the required number[] for the offsets option.
       * @param points Vector3 array
       * @returns an array of x, y, z coordinates as numbers [x, y, z, x, y, z, x, y, z, ....]
       */
      static ToNumberArray(points) {
        return points.flatMap((v) => [v.x, v.y, v.z]);
      }
      /**
       * Calculates the sum of points of every line and the number of points in each line.
       * This function is useful when you are drawing multiple lines in one mesh and you want
       * to know the counts. For example for creating an offsets table.
       * @param points point array
       * @returns points count info
       */
      static GetPointsCountInfo(points) {
        const counts = new Array(points.length);
        let total = 0;
        for (let n = points.length; n--; ) {
          counts[n] = points[n].length / 3;
          total += counts[n];
        }
        return { total, counts };
      }
      /**
       * Gets the length of the line counting all it's segments length
       * @param data array of line points
       * @returns length of the line
       */
      static GetLineLength(data) {
        if (data.length === 0) {
          return 0;
        }
        let points;
        if (typeof data[0] === "number") {
          points = _GreasedLineTools.ToVector3Array(data);
        } else {
          points = data;
        }
        const tmp = TmpVectors.Vector3[0];
        let length = 0;
        for (let index = 0; index < points.length - 1; index++) {
          const point1 = points[index];
          const point2 = points[index + 1];
          length += point2.subtractToRef(point1, tmp).length();
        }
        return length;
      }
      /**
       * Gets the length from the beginning to each point of the line as array.
       * @param data array of line points
       * @param buf optional pre-allocated buffer to reduce memory pressure, should be at least `data.length * 4 / 3` bytes
       * @returns length array of the line
       */
      static GetLineLengthArray(data, buf) {
        const out = buf ? new Float32Array(buf, 0, data.length / 3) : new Float32Array(data.length / 3);
        let length = 0;
        for (let index = 0, pointsLength = data.length / 3 - 1; index < pointsLength; index++) {
          let x = data[index * 3 + 0];
          let y = data[index * 3 + 1];
          let z = data[index * 3 + 2];
          x -= data[index * 3 + 3];
          y -= data[index * 3 + 4];
          z -= data[index * 3 + 5];
          const currentLength = Math.sqrt(x * x + y * y + z * z);
          length += currentLength;
          out[index + 1] = length;
        }
        return out;
      }
      /**
       * Divides a segment into smaller segments.
       * A segment is a part of the line between it's two points.
       * @param point1 first point of the line
       * @param point2 second point of the line
       * @param segmentCount number of segments we want to have in the divided line
       * @returns
       */
      static SegmentizeSegmentByCount(point1, point2, segmentCount) {
        const dividedLinePoints = [];
        const diff = point2.subtract(point1);
        const divisor = TmpVectors.Vector3[0];
        divisor.setAll(segmentCount);
        const segmentVector = TmpVectors.Vector3[1];
        diff.divideToRef(divisor, segmentVector);
        let nextPoint = point1.clone();
        dividedLinePoints.push(nextPoint);
        for (let index = 0; index < segmentCount; index++) {
          nextPoint = nextPoint.clone();
          dividedLinePoints.push(nextPoint.addInPlace(segmentVector));
        }
        return dividedLinePoints;
      }
      /**
       * Divides a line into segments.
       * A segment is a part of the line between it's two points.
       * @param what line points
       * @param segmentLength length of each segment of the resulting line (distance between two line points)
       * @returns line point
       */
      static SegmentizeLineBySegmentLength(what, segmentLength) {
        const subLines = what[0] instanceof Vector3 ? _GreasedLineTools.GetLineSegments(what) : typeof what[0] === "number" ? _GreasedLineTools.GetLineSegments(_GreasedLineTools.ToVector3Array(what)) : what;
        const points = [];
        for (const s of subLines) {
          if (s.length > segmentLength) {
            const segments = _GreasedLineTools.SegmentizeSegmentByCount(s.point1, s.point2, Math.ceil(s.length / segmentLength));
            for (const seg of segments) {
              points.push(seg);
            }
          } else {
            points.push(s.point1);
            points.push(s.point2);
          }
        }
        return points;
      }
      /**
       * Divides a line into segments.
       * A segment is a part of the line between it's two points.
       * @param what line points
       * @param segmentCount number of segments
       * @returns line point
       */
      static SegmentizeLineBySegmentCount(what, segmentCount) {
        const points = typeof what[0] === "number" ? _GreasedLineTools.ToVector3Array(what) : what;
        const segmentLength = _GreasedLineTools.GetLineLength(points) / segmentCount;
        return _GreasedLineTools.SegmentizeLineBySegmentLength(points, segmentLength);
      }
      /**
       * Gets line segments.
       * A segment is a part of the line between it's two points.
       * @param points line points
       * @returns segments information of the line segment including starting point, ending point and the distance between them
       */
      static GetLineSegments(points) {
        const segments = [];
        for (let index = 0; index < points.length - 1; index++) {
          const point1 = points[index];
          const point2 = points[index + 1];
          const length = point2.subtract(point1).length();
          segments.push({ point1, point2, length });
        }
        return segments;
      }
      /**
       * Gets the minimum and the maximum length of a line segment in the line.
       * A segment is a part of the line between it's two points.
       * @param points line points
       * @returns
       */
      static GetMinMaxSegmentLength(points) {
        const subLines = _GreasedLineTools.GetLineSegments(points);
        const sorted = subLines.sort((s) => s.length);
        return {
          min: sorted[0].length,
          max: sorted[sorted.length - 1].length
        };
      }
      /**
       * Finds the last visible position in world space of the line according to the visibility parameter
       * @param lineSegments segments of the line
       * @param lineLength total length of the line
       * @param visbility normalized value of visibility
       * @param localSpace if true the result will be in local space (default is false)
       * @returns world space coordinate of the last visible piece of the line
       */
      static GetPositionOnLineByVisibility(lineSegments, lineLength, visbility, localSpace = false) {
        const lengthVisibilityRatio = lineLength * visbility;
        let sumSegmentLengths = 0;
        let segmentIndex = 0;
        const lineSegmentsLength = lineSegments.length;
        for (let i = 0; i < lineSegmentsLength; i++) {
          if (lengthVisibilityRatio <= sumSegmentLengths + lineSegments[i].length) {
            segmentIndex = i;
            break;
          }
          sumSegmentLengths += lineSegments[i].length;
        }
        const s = (lengthVisibilityRatio - sumSegmentLengths) / lineSegments[segmentIndex].length;
        lineSegments[segmentIndex].point2.subtractToRef(lineSegments[segmentIndex].point1, TmpVectors.Vector3[0]);
        TmpVectors.Vector3[1] = TmpVectors.Vector3[0].multiplyByFloats(s, s, s);
        if (!localSpace) {
          TmpVectors.Vector3[1].addInPlace(lineSegments[segmentIndex].point1);
        }
        return TmpVectors.Vector3[1].clone();
      }
      /**
       * Creates lines in a shape of circle/arc.
       * A segment is a part of the line between it's two points.
       * @param radiusX radiusX of the circle
       * @param segments number of segments in the circle
       * @param z z coordinate of the points. Defaults to 0.
       * @param radiusY radiusY of the circle - you can draw an oval if using different values
       * @param segmentAngle angle offset of the segments. Defaults to Math.PI * 2 / segments. Change this value to draw a part of the circle.
       * @returns line points
       */
      static GetCircleLinePoints(radiusX, segments, z = 0, radiusY = radiusX, segmentAngle = Math.PI * 2 / segments) {
        const points = [];
        for (let i = 0; i <= segments; i++) {
          points.push(new Vector3(Math.cos(i * segmentAngle) * radiusX, Math.sin(i * segmentAngle) * radiusY, z));
        }
        return points;
      }
      /**
       * Gets line points in a shape of a bezier curve
       * @param p0 bezier point0
       * @param p1 bezier point1
       * @param p2 bezier point2
       * @param segments number of segments in the curve
       * @returns
       */
      static GetBezierLinePoints(p0, p1, p2, segments) {
        return Curve3.CreateQuadraticBezier(p0, p1, p2, segments).getPoints().flatMap((v) => [v.x, v.y, v.z]);
      }
      /**
       *
       * @param position position of the arrow cap (mainly you want to create a triangle, set widthUp and widthDown to the same value and omit widthStartUp and widthStartDown)
       * @param direction direction which the arrow points to
       * @param length length (size) of the arrow cap itself
       * @param widthUp the arrow width above the line
       * @param widthDown the arrow width belove the line
       * @param widthStartUp the arrow width at the start of the arrow above the line. In most scenarios this is 0.
       * @param widthStartDown the arrow width at the start of the arrow below the line. In most scenarios this is 0.
       * @returns
       */
      static GetArrowCap(position, direction, length, widthUp, widthDown, widthStartUp = 0, widthStartDown = 0) {
        const points = [position.clone(), position.add(direction.multiplyByFloats(length, length, length))];
        const widths = [widthUp, widthDown, widthStartUp, widthStartDown];
        return {
          points,
          widths
        };
      }
      /**
       * Gets 3D positions of points from a text and font
       * @param text Text
       * @param size Size of the font
       * @param resolution Resolution of the font
       * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)
       * @param z z coordinate
       * @param includeInner include the inner parts of the font in the result. Default true. If false, only the outlines will be returned.
       * @returns number[][] of 3D positions
       */
      static GetPointsFromText(text, size, resolution, fontData, z = 0, includeInner = true) {
        const allPoints = [];
        const shapePaths = CreateTextShapePaths(text, size, resolution, fontData);
        for (const sp of shapePaths) {
          for (const p of sp.paths) {
            const points = [];
            const points2d = p.getPoints();
            for (const p2d of points2d) {
              points.push(p2d.x, p2d.y, z);
            }
            allPoints.push(points);
          }
          if (includeInner) {
            for (const h of sp.holes) {
              const holes = [];
              const points2d = h.getPoints();
              for (const p2d of points2d) {
                holes.push(p2d.x, p2d.y, z);
              }
              allPoints.push(holes);
            }
          }
        }
        return allPoints;
      }
      /**
       * Converts an array of Color3 to Uint8Array
       * @param colors Arrray of Color3
       * @returns Uin8Array of colors [r, g, b, a, r, g, b, a, ...]
       */
      static Color3toRGBAUint8(colors) {
        const colorTable = new Uint8Array(colors.length * 4);
        for (let i = 0, j = 0; i < colors.length; i++) {
          colorTable[j++] = colors[i].r * 255;
          colorTable[j++] = colors[i].g * 255;
          colorTable[j++] = colors[i].b * 255;
          colorTable[j++] = 255;
        }
        return colorTable;
      }
      /**
       * Creates a RawTexture from an RGBA color array and sets it on the plugin material instance.
       * @param name name of the texture
       * @param colors Uint8Array of colors
       * @param colorsSampling sampling mode of the created texture
       * @param scene Scene
       * @returns the colors texture
       */
      static CreateColorsTexture(name, colors, colorsSampling, scene) {
        const maxTextureSize = scene.getEngine().getCaps().maxTextureSize ?? 1;
        const width = colors.length > maxTextureSize ? maxTextureSize : colors.length;
        const height = Math.ceil(colors.length / maxTextureSize);
        if (height > 1) {
          colors = [...colors, ...Array(width * height - colors.length).fill(colors[0])];
        }
        const colorsArray = _GreasedLineTools.Color3toRGBAUint8(colors);
        const colorsTexture = new RawTexture(colorsArray, width, height, Engine.TEXTUREFORMAT_RGBA, scene, false, true, colorsSampling);
        colorsTexture.name = name;
        return colorsTexture;
      }
      /**
       * A minimum size texture for the colors sampler2D when there is no colors texture defined yet.
       * For fast switching using the useColors property without the need to use defines.
       * @param scene Scene
       * @returns empty colors texture
       */
      static PrepareEmptyColorsTexture(scene) {
        if (!GreasedLineMaterialDefaults.EmptyColorsTexture) {
          const colorsArray = new Uint8Array(4);
          GreasedLineMaterialDefaults.EmptyColorsTexture = new RawTexture(colorsArray, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, false, RawTexture.NEAREST_NEAREST);
          GreasedLineMaterialDefaults.EmptyColorsTexture.name = "grlEmptyColorsTexture";
        }
        return GreasedLineMaterialDefaults.EmptyColorsTexture;
      }
      /**
       * Diposes the shared empty colors texture
       */
      static DisposeEmptyColorsTexture() {
        GreasedLineMaterialDefaults.EmptyColorsTexture?.dispose();
        GreasedLineMaterialDefaults.EmptyColorsTexture = null;
      }
      /**
       * Converts boolean to number.
       * @param bool the bool value
       * @returns 1 if true, 0 if false.
       */
      static BooleanToNumber(bool) {
        return bool ? 1 : 0;
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/GreasedLine/greasedLinePluginMaterialShadersGLSL.js
function GetCustomCode(shaderType, cameraFacing) {
  if (shaderType === "vertex") {
    const obj = {
      CUSTOM_VERTEX_DEFINITIONS: `
                attribute float grl_widths;
                attribute vec3 grl_offsets;
                attribute float grl_colorPointers;
                varying float grlCounters;
                varying float grlColorPointer;

                #ifdef GREASED_LINE_CAMERA_FACING
                    attribute vec4 grl_previousAndSide;
                    attribute vec4 grl_nextAndCounters;

                    vec2 grlFix( vec4 i, float aspect ) {
                        vec2 res = i.xy / i.w;
                        res.x *= aspect;
                        return res;
                    }
                #else
                    attribute vec3 grl_slopes;
                    attribute float grl_counters;
                #endif
                `,
      CUSTOM_VERTEX_UPDATE_POSITION: `
                #ifdef GREASED_LINE_CAMERA_FACING
                    vec3 grlPositionOffset = grl_offsets;
                    positionUpdated += grlPositionOffset;
                #else
                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);
                #endif
                `,
      CUSTOM_VERTEX_MAIN_END: `
                grlColorPointer = grl_colorPointers;

                #ifdef GREASED_LINE_CAMERA_FACING

                    float grlAspect = grl_aspect_resolution_lineWidth.x;
                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;

                    vec3 grlPrevious = grl_previousAndSide.xyz;
                    float grlSide = grl_previousAndSide.w;

                    vec3 grlNext = grl_nextAndCounters.xyz;
                    grlCounters = grl_nextAndCounters.w;
                    float grlWidth = grlBaseWidth * grl_widths;
                    
                    vec3 worldDir = normalize(grlNext - grlPrevious);
                    vec3 nearPosition = positionUpdated + (worldDir * 0.01);
                    mat4 grlMatrix = viewProjection * finalWorld;
                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);
                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);
                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);
                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);
                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);

                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);

                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM
                        grlNormal.xy *= -.5 * grlWidth;
                    #else
                        grlNormal.xy *= .5 * grlWidth;
                    #endif

                    grlNormal *= grl_projection;

                    #ifdef GREASED_LINE_SIZE_ATTENUATION
                        grlNormal.xy *= grlFinalPosition.w;
                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;
                    #endif

                    grlFinalPosition.xy += grlNormal.xy * grlSide;
                    gl_Position = grlFinalPosition;

                    vPositionW = vec3(grlFinalPosition);
                #else
                    grlCounters = grl_counters;
                #endif
                `
    };
    if (cameraFacing) {
      obj["!gl_Position\\=viewProjection\\*worldPos;"] = "//";
    }
    return obj;
  }
  if (shaderType === "fragment") {
    return {
      CUSTOM_FRAGMENT_DEFINITIONS: `
                    #ifdef PBR
                         #define grlFinalColor finalColor
                    #else
                         #define grlFinalColor color
                    #endif

                    varying float grlCounters;
                    varying float grlColorPointer;
                    uniform sampler2D grl_colors;
                `,
      CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: `
                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;
                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;
                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;
                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;

                    float grlUseDash = grl_dashOptions.x;
                    float grlDashArray = grl_dashOptions.y;
                    float grlDashOffset = grl_dashOptions.z;
                    float grlDashRatio = grl_dashOptions.w;

                    grlFinalColor.a *= step(grlCounters, grlVisibility);
                    if(grlFinalColor.a == 0.) discard;

                    if(grlUseDash == 1.){
                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));
                        if (grlFinalColor.a == 0.) discard;
                    }

                    #ifdef GREASED_LINE_HAS_COLOR
                        if (grlColorMode == ${0}.) {
                            grlFinalColor.rgb = grl_singleColor;
                        } else if (grlColorMode == ${1}.) {
                            grlFinalColor.rgb += grl_singleColor;
                        } else if (grlColorMode == ${2}.) {
                            grlFinalColor.rgb *= grl_singleColor;
                        }
                    #else
                        if (grlUseColors == 1.) {
                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE
                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);
                            #else
                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));
                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);
                            #endif
                            if (grlColorMode == ${0}.) {
                                grlFinalColor = grlColor;
                            } else if (grlColorMode == ${1}.) {
                                grlFinalColor += grlColor;
                            } else if (grlColorMode == ${2}.) {
                                grlFinalColor *= grlColor;
                            }
                        }
                    #endif
                `
    };
  }
  return null;
}
var init_greasedLinePluginMaterialShadersGLSL = __esm({
  "node_modules/@babylonjs/core/Materials/GreasedLine/greasedLinePluginMaterialShadersGLSL.js"() {
  }
});

// node_modules/@babylonjs/core/Materials/GreasedLine/greasedLinePluginMaterialShadersWGSL.js
function GetCustomCode2(shaderType, cameraFacing) {
  if (shaderType === "vertex") {
    const obj = {
      CUSTOM_VERTEX_DEFINITIONS: `
                attribute grl_widths: f32;
                attribute grl_colorPointers: f32;
                varying grlCounters: f32;
                varying grlColorPointer: f32;

                #ifdef GREASED_LINE_USE_OFFSETS
                    attribute grl_offsets: vec3f;   
                #endif

                #ifdef GREASED_LINE_CAMERA_FACING
                    attribute grl_previousAndSide : vec4f;
                    attribute grl_nextAndCounters : vec4f;

                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {
                        var res = i.xy / i.w;
                        res.x *= aspect;
                        return res;
                    }
                #else
                    attribute grl_slopes: f32;
                    attribute grl_counters: f32;
                #endif


                `,
      CUSTOM_VERTEX_UPDATE_POSITION: `
                #ifdef GREASED_LINE_USE_OFFSETS
                    var grlPositionOffset: vec3f = input.grl_offsets;
                #else
                    var grlPositionOffset = vec3f(0.);
                #endif

                #ifdef GREASED_LINE_CAMERA_FACING
                    positionUpdated += grlPositionOffset;
                #else
                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);
                #endif
                `,
      CUSTOM_VERTEX_MAIN_END: `
                vertexOutputs.grlColorPointer = input.grl_colorPointers;

                #ifdef GREASED_LINE_CAMERA_FACING

                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;
                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;

                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;
                    let grlSide: f32 = input.grl_previousAndSide.w;

                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;
                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;

                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;

                    let worldDir: vec3f = normalize(grlNext - grlPrevious);
                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.01);
                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;
                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); 
                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);
                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);
                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);
                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);

                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);

                    let grlHalfWidth: f32 = 0.5 * grlWidth;
                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)
                        grlNormal.x *= -grlHalfWidth;
                        grlNormal.y *= -grlHalfWidth;
                    #else
                        grlNormal.x *= grlHalfWidth;
                        grlNormal.y *= grlHalfWidth;
                    #endif

                    grlNormal *= uniforms.grl_projection;

                    #if defined(GREASED_LINE_SIZE_ATTENUATION)
                        grlNormal.x *= grlFinalPosition.w;
                        grlNormal.y *= grlFinalPosition.w;

                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;
                        grlNormal.x /= pr.x;
                        grlNormal.y /= pr.y;
                    #endif

                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);
                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;
                
                #else
                    vertexOutputs.grlCounters = input.grl_counters;
                #endif
                `
    };
    if (cameraFacing) {
      obj["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"] = "//";
    }
    return obj;
  }
  if (shaderType === "fragment") {
    return {
      CUSTOM_FRAGMENT_DEFINITIONS: `
                    #ifdef PBR
                         #define grlFinalColor finalColor
                    #else
                         #define grlFinalColor color
                    #endif

                    varying grlCounters: f32;
                    varying grlColorPointer: 32;

                    var grl_colors: texture_2d<f32>;
                    var grl_colorsSampler: sampler;
                `,
      CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: `
                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;
                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;
                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;
                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;

                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;
                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;
                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;
                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;

                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);
                    if (grlFinalColor.a == 0.0) {
                        discard;
                    }

                    if (grlUseDash == 1.0) {
                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;
                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));

                        if (grlFinalColor.a == 0.0) {
                            discard;
                        }
                    }

                    #ifdef GREASED_LINE_HAS_COLOR
                        if (grlColorMode == ${0}.) {
                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);
                        } else if (grlColorMode == ${1}.) {
                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);
                        } else if (grlColorMode == ${2}.) {
                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);
                        }
                    #else
                        if (grlUseColors == 1.) {
                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE
                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));
                            #else
                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));
                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);
                            #endif
                            if (grlColorMode == ${0}.) {
                                grlFinalColor = grlColor;
                            } else if (grlColorMode == ${1}.) {
                                grlFinalColor += grlColor;
                            } else if (grlColorMode == ${2}.) {
                                grlFinalColor *= grlColor;
                            }
                        }
                    #endif


                `
    };
  }
  return null;
}
var init_greasedLinePluginMaterialShadersWGSL = __esm({
  "node_modules/@babylonjs/core/Materials/GreasedLine/greasedLinePluginMaterialShadersWGSL.js"() {
  }
});

// node_modules/@babylonjs/core/Materials/GreasedLine/greasedLinePluginMaterial.js
var MaterialGreasedLineDefines, GreasedLinePluginMaterial;
var init_greasedLinePluginMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/GreasedLine/greasedLinePluginMaterial.js"() {
    init_rawTexture();
    init_materialPluginBase();
    init_math_vector();
    init_materialDefines();
    init_typeStore();
    init_greasedLineMaterialDefaults();
    init_greasedLineTools();
    init_greasedLinePluginMaterialShadersGLSL();
    init_greasedLinePluginMaterialShadersWGSL();
    MaterialGreasedLineDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.GREASED_LINE_HAS_COLOR = false;
        this.GREASED_LINE_SIZE_ATTENUATION = false;
        this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = false;
        this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = false;
        this.GREASED_LINE_CAMERA_FACING = true;
        this.GREASED_LINE_USE_OFFSETS = false;
      }
    };
    GreasedLinePluginMaterial = class _GreasedLinePluginMaterial extends MaterialPluginBase {
      /**
       * Gets a boolean indicating that the plugin is compatible with a given shader language
       * @param _shaderLanguage The shader language to use
       * @returns true if the plugin is compatible with the shader language. Return always true since both GLSL and WGSL are supported
       */
      isCompatible(_shaderLanguage) {
        return true;
      }
      /**
       * Creates a new instance of the GreasedLinePluginMaterial
       * @param material Base material for the plugin
       * @param scene The scene
       * @param options Plugin options
       */
      constructor(material, scene, options) {
        options = options || {
          color: GreasedLineMaterialDefaults.DEFAULT_COLOR
        };
        const defines = new MaterialGreasedLineDefines();
        defines.GREASED_LINE_HAS_COLOR = !!options.color && !options.useColors;
        defines.GREASED_LINE_SIZE_ATTENUATION = options.sizeAttenuation ?? false;
        defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = options.colorDistributionType === 1;
        defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = (scene ?? material.getScene()).useRightHandedSystem;
        defines.GREASED_LINE_CAMERA_FACING = options.cameraFacing ?? true;
        super(material, _GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME, 200, defines, true, true);
        this.colorsTexture = null;
        this._forceGLSL = false;
        this._forceGLSL = options?.forceGLSL || _GreasedLinePluginMaterial.ForceGLSL;
        this._scene = scene ?? material.getScene();
        this._engine = this._scene.getEngine();
        this._cameraFacing = options.cameraFacing ?? true;
        this.visibility = options.visibility ?? 1;
        this.useDash = options.useDash ?? false;
        this.dashRatio = options.dashRatio ?? 0.5;
        this.dashOffset = options.dashOffset ?? 0;
        this.width = options.width ? options.width : options.sizeAttenuation ? GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED : GreasedLineMaterialDefaults.DEFAULT_WIDTH;
        this._sizeAttenuation = options.sizeAttenuation ?? false;
        this.colorMode = options.colorMode ?? 0;
        this._color = options.color ?? null;
        this.useColors = options.useColors ?? false;
        this._colorsDistributionType = options.colorDistributionType ?? 0;
        this.colorsSampling = options.colorsSampling ?? RawTexture.NEAREST_NEAREST;
        this._colors = options.colors ?? null;
        this.dashCount = options.dashCount ?? 1;
        this.resolution = options.resolution ?? new Vector2(this._engine.getRenderWidth(), this._engine.getRenderHeight());
        if (options.colorsTexture) {
          this.colorsTexture = options.colorsTexture;
        } else {
          if (this._colors) {
            this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${material.name}-colors-texture`, this._colors, this.colorsSampling, this._scene);
          } else {
            this._color = this._color ?? GreasedLineMaterialDefaults.DEFAULT_COLOR;
            GreasedLineTools.PrepareEmptyColorsTexture(this._scene);
          }
        }
        this._engine.onDisposeObservable.add(() => {
          GreasedLineTools.DisposeEmptyColorsTexture();
        });
      }
      /**
       * Get the shader attributes
       * @param attributes array which will be filled with the attributes
       */
      getAttributes(attributes) {
        attributes.push("grl_offsets");
        attributes.push("grl_widths");
        attributes.push("grl_colorPointers");
        attributes.push("grl_counters");
        if (this._cameraFacing) {
          attributes.push("grl_previousAndSide");
          attributes.push("grl_nextAndCounters");
        } else {
          attributes.push("grl_slopes");
        }
      }
      /**
       * Get the shader samplers
       * @param samplers
       */
      getSamplers(samplers) {
        samplers.push("grl_colors");
      }
      /**
       * Get the shader textures
       * @param activeTextures array which will be filled with the textures
       */
      getActiveTextures(activeTextures) {
        if (this.colorsTexture) {
          activeTextures.push(this.colorsTexture);
        }
      }
      /**
       * Get the shader uniforms
       * @param shaderLanguage The shader language to use
       * @returns uniforms
       */
      getUniforms(shaderLanguage = 0) {
        const ubo = [
          { name: "grl_singleColor", size: 3, type: "vec3" },
          { name: "grl_textureSize", size: 2, type: "vec2" },
          { name: "grl_dashOptions", size: 4, type: "vec4" },
          { name: "grl_colorMode_visibility_colorsWidth_useColors", size: 4, type: "vec4" }
        ];
        if (this._cameraFacing) {
          ubo.push({ name: "grl_projection", size: 16, type: "mat4" }, { name: "grl_aspect_resolution_lineWidth", size: 4, type: "vec4" });
        }
        if (shaderLanguage === 1) {
          ubo.push({
            name: "viewProjection",
            size: 16,
            type: "mat4"
          });
        }
        return {
          ubo,
          vertex: this._cameraFacing && this._isGLSL(shaderLanguage) ? `
                    uniform vec4 grl_aspect_resolution_lineWidth;
                    uniform mat4 grl_projection;
    ` : "",
          fragment: this._isGLSL(shaderLanguage) ? `
                    uniform vec4 grl_dashOptions;
                    uniform vec2 grl_textureSize;
                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;
                    uniform vec3 grl_singleColor;
    ` : ""
        };
      }
      // only getter, it doesn't make sense to use this plugin on a mesh other than GreasedLineMesh
      // and it doesn't make sense to disable it on the mesh
      get isEnabled() {
        return true;
      }
      /**
       * Bind the uniform buffer
       * @param uniformBuffer
       */
      bindForSubMesh(uniformBuffer) {
        if (this._cameraFacing) {
          uniformBuffer.updateMatrix("grl_projection", this._scene.getProjectionMatrix());
          if (!this._isGLSL(this._material.shaderLanguage)) {
            uniformBuffer.updateMatrix("viewProjection", this._scene.getTransformMatrix());
          }
          const resolutionLineWidth = TmpVectors.Vector4[0];
          resolutionLineWidth.x = this._aspect;
          resolutionLineWidth.y = this._resolution.x;
          resolutionLineWidth.z = this._resolution.y;
          resolutionLineWidth.w = this.width;
          uniformBuffer.updateVector4("grl_aspect_resolution_lineWidth", resolutionLineWidth);
        }
        const dashOptions = TmpVectors.Vector4[0];
        dashOptions.x = GreasedLineTools.BooleanToNumber(this.useDash);
        dashOptions.y = this._dashArray;
        dashOptions.z = this.dashOffset;
        dashOptions.w = this.dashRatio;
        uniformBuffer.updateVector4("grl_dashOptions", dashOptions);
        const colorModeVisibilityColorsWidthUseColors = TmpVectors.Vector4[1];
        colorModeVisibilityColorsWidthUseColors.x = this.colorMode;
        colorModeVisibilityColorsWidthUseColors.y = this.visibility;
        colorModeVisibilityColorsWidthUseColors.z = this.colorsTexture ? this.colorsTexture.getSize().width : 0;
        colorModeVisibilityColorsWidthUseColors.w = GreasedLineTools.BooleanToNumber(this.useColors);
        uniformBuffer.updateVector4("grl_colorMode_visibility_colorsWidth_useColors", colorModeVisibilityColorsWidthUseColors);
        if (this._color) {
          uniformBuffer.updateColor3("grl_singleColor", this._color);
        }
        const texture = this.colorsTexture ?? GreasedLineMaterialDefaults.EmptyColorsTexture;
        uniformBuffer.setTexture("grl_colors", texture);
        uniformBuffer.updateFloat2("grl_textureSize", texture?.getSize().width ?? 1, texture?.getSize().height ?? 1);
      }
      /**
       * Prepare the defines
       * @param defines
       * @param _scene
       * @param mesh
       */
      prepareDefines(defines, _scene, mesh) {
        defines.GREASED_LINE_HAS_COLOR = !!this.color && !this.useColors;
        defines.GREASED_LINE_SIZE_ATTENUATION = this._sizeAttenuation;
        defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = this._colorsDistributionType === 1;
        defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = _scene.useRightHandedSystem;
        defines.GREASED_LINE_CAMERA_FACING = this._cameraFacing;
        defines.GREASED_LINE_USE_OFFSETS = !!mesh.offsets;
      }
      /**
       * Get the class name
       * @returns class name
       */
      getClassName() {
        return _GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME;
      }
      /**
       * Get shader code
       * @param shaderType vertex/fragment
       * @param shaderLanguage GLSL or WGSL
       * @returns shader code
       */
      getCustomCode(shaderType, shaderLanguage = 0) {
        if (this._isGLSL(shaderLanguage)) {
          return GetCustomCode(shaderType, this._cameraFacing);
        }
        return GetCustomCode2(shaderType, this._cameraFacing);
      }
      /**
       * Disposes the plugin material.
       */
      dispose() {
        this.colorsTexture?.dispose();
        super.dispose();
      }
      /**
       * Returns the colors used to colorize the line
       */
      get colors() {
        return this._colors;
      }
      /**
       * Sets the colors used to colorize the line
       */
      set colors(value) {
        this.setColors(value);
      }
      /**
       * Creates or updates the colors texture
       * @param colors color table RGBA
       * @param lazy if lazy, the colors are not updated
       * @param forceNewTexture force creation of a new texture
       */
      setColors(colors, lazy = false, forceNewTexture = false) {
        const origColorsCount = this._colors?.length ?? 0;
        this._colors = colors;
        if (colors === null || colors.length === 0) {
          this.colorsTexture?.dispose();
          return;
        }
        if (lazy && !forceNewTexture) {
          return;
        }
        if (this.colorsTexture && origColorsCount === colors.length && !forceNewTexture) {
          const colorArray = GreasedLineTools.Color3toRGBAUint8(colors);
          this.colorsTexture.update(colorArray);
        } else {
          this.colorsTexture?.dispose();
          this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, colors, this.colorsSampling, this._scene);
        }
      }
      /**
       * Updates the material. Use when material created in lazy mode.
       */
      updateLazy() {
        if (this._colors) {
          this.setColors(this._colors, false, true);
        }
      }
      /**
       * Gets the number of dashes in the line
       */
      get dashCount() {
        return this._dashCount;
      }
      /**
       * Sets the number of dashes in the line
       * @param value dash
       */
      set dashCount(value) {
        this._dashCount = value;
        this._dashArray = 1 / value;
      }
      /**
       * If set to true the line will be rendered always with the same width regardless how far it is located from the camera.
       * Not supported for non camera facing lines.
       */
      get sizeAttenuation() {
        return this._sizeAttenuation;
      }
      /**
       * Turn on/off size attenuation of the width option and widths array.
       * Not supported for non camera facing lines.
       * @param value If set to true the line will be rendered always with the same width regardless how far it is located from the camera.
       */
      set sizeAttenuation(value) {
        this._sizeAttenuation = value;
        this.markAllDefinesAsDirty();
      }
      /**
       * Gets the color of the line
       */
      get color() {
        return this._color;
      }
      /**
       * Sets the color of the line
       * @param value Color3 or null to clear the color. You need to clear the color if you use colors and useColors = true
       */
      set color(value) {
        this.setColor(value);
      }
      /**
       * Sets the color of the line. If set the whole line will be mixed with this color according to the colorMode option.
       * @param value color
       * @param doNotMarkDirty if true, the material will not be marked as dirty
       */
      setColor(value, doNotMarkDirty = false) {
        if (this._color === null && value !== null || this._color !== null && value === null) {
          this._color = value;
          if (!doNotMarkDirty) {
            this.markAllDefinesAsDirty();
          }
        } else {
          this._color = value;
        }
      }
      /**
       * Gets the color distributiopn type
       */
      get colorsDistributionType() {
        return this._colorsDistributionType;
      }
      /**
       * Sets the color distribution type
       * @see GreasedLineMeshColorDistributionType
       * @param value color distribution type
       */
      set colorsDistributionType(value) {
        this._colorsDistributionType = value;
        this.markAllDefinesAsDirty();
      }
      /**
       * Gets the resolution
       */
      get resolution() {
        return this._resolution;
      }
      /**
       * Sets the resolution
       * @param value resolution of the screen for GreasedLine
       */
      set resolution(value) {
        this._aspect = value.x / value.y;
        this._resolution = value;
      }
      /**
       * Serializes this plugin material
       * @returns serializationObjec
       */
      serialize() {
        const serializationObject = super.serialize();
        const greasedLineMaterialOptions = {
          colorDistributionType: this._colorsDistributionType,
          colorsSampling: this.colorsSampling,
          colorMode: this.colorMode,
          dashCount: this._dashCount,
          dashOffset: this.dashOffset,
          dashRatio: this.dashRatio,
          resolution: this._resolution,
          sizeAttenuation: this._sizeAttenuation,
          useColors: this.useColors,
          useDash: this.useDash,
          visibility: this.visibility,
          width: this.width
        };
        if (this._colors) {
          greasedLineMaterialOptions.colors = this._colors;
        }
        if (this._color) {
          greasedLineMaterialOptions.color = this._color;
        }
        serializationObject.greasedLineMaterialOptions = greasedLineMaterialOptions;
        return serializationObject;
      }
      /**
       * Parses a serialized objects
       * @param source serialized object
       * @param scene scene
       * @param rootUrl root url for textures
       */
      parse(source, scene, rootUrl) {
        super.parse(source, scene, rootUrl);
        const greasedLineMaterialOptions = source.greasedLineMaterialOptions;
        this.colorsTexture?.dispose();
        if (greasedLineMaterialOptions.color) {
          this.setColor(greasedLineMaterialOptions.color, true);
        }
        if (greasedLineMaterialOptions.colorDistributionType) {
          this.colorsDistributionType = greasedLineMaterialOptions.colorDistributionType;
        }
        if (greasedLineMaterialOptions.colors) {
          this.colors = greasedLineMaterialOptions.colors;
        }
        if (greasedLineMaterialOptions.colorsSampling) {
          this.colorsSampling = greasedLineMaterialOptions.colorsSampling;
        }
        if (greasedLineMaterialOptions.colorMode) {
          this.colorMode = greasedLineMaterialOptions.colorMode;
        }
        if (greasedLineMaterialOptions.useColors) {
          this.useColors = greasedLineMaterialOptions.useColors;
        }
        if (greasedLineMaterialOptions.visibility) {
          this.visibility = greasedLineMaterialOptions.visibility;
        }
        if (greasedLineMaterialOptions.useDash) {
          this.useDash = greasedLineMaterialOptions.useDash;
        }
        if (greasedLineMaterialOptions.dashCount) {
          this.dashCount = greasedLineMaterialOptions.dashCount;
        }
        if (greasedLineMaterialOptions.dashRatio) {
          this.dashRatio = greasedLineMaterialOptions.dashRatio;
        }
        if (greasedLineMaterialOptions.dashOffset) {
          this.dashOffset = greasedLineMaterialOptions.dashOffset;
        }
        if (greasedLineMaterialOptions.width) {
          this.width = greasedLineMaterialOptions.width;
        }
        if (greasedLineMaterialOptions.sizeAttenuation) {
          this.sizeAttenuation = greasedLineMaterialOptions.sizeAttenuation;
        }
        if (greasedLineMaterialOptions.resolution) {
          this.resolution = greasedLineMaterialOptions.resolution;
        }
        if (this.colors) {
          this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, this.colors, this.colorsSampling, scene);
        } else {
          GreasedLineTools.PrepareEmptyColorsTexture(scene);
        }
        this.markAllDefinesAsDirty();
      }
      /**
       * Makes a duplicate of the current configuration into another one.
       * @param plugin define the config where to copy the info
       */
      copyTo(plugin) {
        const dest = plugin;
        dest.colorsTexture?.dispose();
        if (this._colors) {
          dest.colorsTexture = GreasedLineTools.CreateColorsTexture(`${dest._material.name}-colors-texture`, this._colors, dest.colorsSampling, this._scene);
        }
        dest.setColor(this.color, true);
        dest.colorsDistributionType = this.colorsDistributionType;
        dest.colorsSampling = this.colorsSampling;
        dest.colorMode = this.colorMode;
        dest.useColors = this.useColors;
        dest.visibility = this.visibility;
        dest.useDash = this.useDash;
        dest.dashCount = this.dashCount;
        dest.dashRatio = this.dashRatio;
        dest.dashOffset = this.dashOffset;
        dest.width = this.width;
        dest.sizeAttenuation = this.sizeAttenuation;
        dest.resolution = this.resolution;
        dest.markAllDefinesAsDirty();
      }
      _isGLSL(shaderLanguage) {
        return shaderLanguage === 0 || this._forceGLSL;
      }
    };
    GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME = "GreasedLinePluginMaterial";
    GreasedLinePluginMaterial.ForceGLSL = false;
    RegisterClass(`BABYLON.${GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME}`, GreasedLinePluginMaterial);
  }
});

// node_modules/@babylonjs/core/Materials/GreasedLine/greasedLineSimpleMaterial.js
var GreasedLineUseOffsetsSimpleMaterialDefine, GreasedLineSimpleMaterial;
var init_greasedLineSimpleMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/GreasedLine/greasedLineSimpleMaterial.js"() {
    init_rawTexture();
    init_shaderMaterial();
    init_math_color();
    init_math_vector();
    init_textureSampler();
    init_greasedLineTools();
    init_greasedLineMaterialDefaults();
    GreasedLineUseOffsetsSimpleMaterialDefine = "GREASED_LINE_USE_OFFSETS";
    GreasedLineSimpleMaterial = class _GreasedLineSimpleMaterial extends ShaderMaterial {
      /**
       * GreasedLineSimple material constructor
       * @param name material name
       * @param scene the scene
       * @param options material options
       */
      constructor(name, scene, options) {
        const engine = scene.getEngine();
        const isWGSL = engine.isWebGPU && !(options.forceGLSL || _GreasedLineSimpleMaterial.ForceGLSL);
        const defines = [
          `COLOR_DISTRIBUTION_TYPE_LINE ${1}.`,
          `COLOR_DISTRIBUTION_TYPE_SEGMENT ${0}.`,
          `COLOR_MODE_SET ${0}.`,
          `COLOR_MODE_ADD ${1}.`,
          `COLOR_MODE_MULTIPLY ${2}.`
        ];
        if (scene.useRightHandedSystem) {
          defines.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");
        }
        const attributes = ["position", "grl_widths", "grl_offsets", "grl_colorPointers"];
        if (options.cameraFacing) {
          defines.push("GREASED_LINE_CAMERA_FACING");
          attributes.push("grl_previousAndSide", "grl_nextAndCounters");
        } else {
          attributes.push("grl_slopes");
          attributes.push("grl_counters");
        }
        const uniforms = [
          "grlColorsWidth",
          "grlUseColors",
          "grlWidth",
          "grlColor",
          "grl_colorModeAndColorDistributionType",
          "grlResolution",
          "grlAspect",
          "grlAizeAttenuation",
          "grlDashArray",
          "grlDashOffset",
          "grlDashRatio",
          "grlUseDash",
          "grlVisibility",
          "grlColors"
        ];
        if (!isWGSL) {
          uniforms.push("world", "viewProjection", "view", "projection");
        }
        super(name, scene, {
          vertex: "greasedLine",
          fragment: "greasedLine"
        }, {
          uniformBuffers: isWGSL ? ["Scene", "Mesh"] : void 0,
          attributes,
          uniforms,
          samplers: isWGSL ? [] : ["grlColors"],
          defines,
          extraInitializationsAsync: async () => {
            if (isWGSL) {
              await Promise.all([import("./greasedLine.vertex-6LQNN3AM.js"), import("./greasedLine.fragment-AXUNIAZH.js")]);
            } else {
              await Promise.all([import("./greasedLine.vertex-E5T3KU5S.js"), import("./greasedLine.fragment-L67PVFHQ.js")]);
            }
          },
          shaderLanguage: isWGSL ? 1 : 0
        });
        this._color = Color3.White();
        this._colorsDistributionType = 0;
        this._colorsTexture = null;
        options = options || {
          color: GreasedLineMaterialDefaults.DEFAULT_COLOR
        };
        this.visibility = options.visibility ?? 1;
        this.useDash = options.useDash ?? false;
        this.dashRatio = options.dashRatio ?? 0.5;
        this.dashOffset = options.dashOffset ?? 0;
        this.dashCount = options.dashCount ?? 1;
        this.width = options.width ? options.width : options.sizeAttenuation && options.cameraFacing ? GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED : GreasedLineMaterialDefaults.DEFAULT_WIDTH;
        this.sizeAttenuation = options.sizeAttenuation ?? false;
        this.color = options.color ?? Color3.White();
        this.useColors = options.useColors ?? false;
        this.colorsDistributionType = options.colorDistributionType ?? 0;
        this.colorsSampling = options.colorsSampling ?? RawTexture.NEAREST_NEAREST;
        this.colorMode = options.colorMode ?? 0;
        this._colors = options.colors ?? null;
        this._cameraFacing = options.cameraFacing ?? true;
        this.resolution = options.resolution ?? new Vector2(engine.getRenderWidth(), engine.getRenderHeight());
        if (options.colorsTexture) {
          this.colorsTexture = options.colorsTexture;
        } else {
          if (this._colors) {
            this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this.name}-colors-texture`, this._colors, this.colorsSampling, scene);
          } else {
            this._color = this._color ?? GreasedLineMaterialDefaults.DEFAULT_COLOR;
            this.colorsTexture = GreasedLineTools.PrepareEmptyColorsTexture(scene);
          }
        }
        if (isWGSL) {
          const sampler = new TextureSampler();
          sampler.setParameters();
          sampler.samplingMode = this.colorsSampling;
          this.setTextureSampler("grlColorsSampler", sampler);
        }
        engine.onDisposeObservable.add(() => {
          GreasedLineTools.DisposeEmptyColorsTexture();
        });
      }
      /**
       * Disposes the plugin material.
       */
      dispose() {
        this._colorsTexture?.dispose();
        super.dispose();
      }
      _setColorModeAndColorDistributionType() {
        this.setVector2("grl_colorModeAndColorDistributionType", new Vector2(this._colorMode, this._colorsDistributionType));
      }
      /**
       * Updates the material. Use when material created in lazy mode.
       */
      updateLazy() {
        if (this._colors) {
          this.setColors(this._colors, false, true);
        }
      }
      /**
       * Returns the colors used to colorize the line
       */
      get colors() {
        return this._colors;
      }
      /**
       * Sets the colors used to colorize the line
       */
      set colors(value) {
        this.setColors(value);
      }
      /**
       * Creates or updates the colors texture
       * @param colors color table RGBA
       * @param lazy if lazy, the colors are not updated
       * @param forceNewTexture force creation of a new texture
       */
      setColors(colors, lazy = false, forceNewTexture = false) {
        const origColorsCount = this._colors?.length ?? 0;
        this._colors = colors;
        if (colors === null || colors.length === 0) {
          this._colorsTexture?.dispose();
          return;
        }
        if (lazy && !forceNewTexture) {
          return;
        }
        if (this._colorsTexture && origColorsCount === colors.length && !forceNewTexture) {
          const colorArray = GreasedLineTools.Color3toRGBAUint8(colors);
          this._colorsTexture.update(colorArray);
        } else {
          this._colorsTexture?.dispose();
          this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this.name}-colors-texture`, colors, this.colorsSampling, this.getScene());
        }
      }
      /**
       * Gets the colors texture
       */
      get colorsTexture() {
        return this._colorsTexture ?? null;
      }
      /**
       * Sets the colorsTexture
       */
      set colorsTexture(value) {
        this._colorsTexture = value;
        this.setFloat("grlColorsWidth", this._colorsTexture.getSize().width);
        this.setTexture("grlColors", this._colorsTexture);
      }
      /**
       * Line base width. At each point the line width is calculated by widths[pointIndex] * width
       */
      get width() {
        return this._width;
      }
      /**
       * Line base width. At each point the line width is calculated by widths[pointIndex] * width
       */
      set width(value) {
        this._width = value;
        this.setFloat("grlWidth", value);
      }
      /**
       * Whether to use the colors option to colorize the line
       */
      get useColors() {
        return this._useColors;
      }
      set useColors(value) {
        this._useColors = value;
        this.setFloat("grlUseColors", GreasedLineTools.BooleanToNumber(value));
      }
      /**
       * The type of sampling of the colors texture. The values are the same when using with textures.
       */
      get colorsSampling() {
        return this._colorsSampling;
      }
      /**
       * The type of sampling of the colors texture. The values are the same when using with textures.
       */
      set colorsSampling(value) {
        this._colorsSampling = value;
      }
      /**
       * Normalized value of how much of the line will be visible
       * 0 - 0% of the line will be visible
       * 1 - 100% of the line will be visible
       */
      get visibility() {
        return this._visibility;
      }
      set visibility(value) {
        this._visibility = value;
        this.setFloat("grlVisibility", value);
      }
      /**
       * Turns on/off dash mode
       */
      get useDash() {
        return this._useDash;
      }
      /**
       * Turns on/off dash mode
       */
      set useDash(value) {
        this._useDash = value;
        this.setFloat("grlUseDash", GreasedLineTools.BooleanToNumber(value));
      }
      /**
       * Gets the dash offset
       */
      get dashOffset() {
        return this._dashOffset;
      }
      /**
       * Sets the dash offset
       */
      set dashOffset(value) {
        this._dashOffset = value;
        this.setFloat("grlDashOffset", value);
      }
      /**
       * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.
       */
      get dashRatio() {
        return this._dashRatio;
      }
      /**
       * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.
       */
      set dashRatio(value) {
        this._dashRatio = value;
        this.setFloat("grlDashRatio", value);
      }
      /**
       * Gets the number of dashes in the line
       */
      get dashCount() {
        return this._dashCount;
      }
      /**
       * Sets the number of dashes in the line
       * @param value dash
       */
      set dashCount(value) {
        this._dashCount = value;
        this._dashArray = 1 / value;
        this.setFloat("grlDashArray", this._dashArray);
      }
      /**
       * False means 1 unit in width = 1 unit on scene, true means 1 unit in width is reduced on the screen to make better looking lines
       */
      get sizeAttenuation() {
        return this._sizeAttenuation;
      }
      /**
       * Turn on/off attenuation of the width option and widths array.
       * @param value false means 1 unit in width = 1 unit on scene, true means 1 unit in width is reduced on the screen to make better looking lines
       */
      set sizeAttenuation(value) {
        this._sizeAttenuation = value;
        this.setFloat("grlSizeAttenuation", GreasedLineTools.BooleanToNumber(value));
      }
      /**
       * Gets the color of the line
       */
      get color() {
        return this._color;
      }
      /**
       * Sets the color of the line
       * @param value Color3
       */
      set color(value) {
        this.setColor(value);
      }
      /**
       * Sets the color of the line. If set the whole line will be mixed with this color according to the colorMode option.
       * The simple material always needs a color to be set. If you set it to null it will set the color to the default color (GreasedLineSimpleMaterial.DEFAULT_COLOR).
       * @param value color
       */
      setColor(value) {
        value = value ?? GreasedLineMaterialDefaults.DEFAULT_COLOR;
        this._color = value;
        this.setColor3("grlColor", value);
      }
      /**
       * Gets the color distributiopn type
       */
      get colorsDistributionType() {
        return this._colorsDistributionType;
      }
      /**
       * Sets the color distribution type
       * @see GreasedLineMeshColorDistributionType
       * @param value color distribution type
       */
      set colorsDistributionType(value) {
        this._colorsDistributionType = value;
        this._setColorModeAndColorDistributionType();
      }
      /**
       * Gets the mixing mode of the color and colors paramaters. Default value is GreasedLineMeshColorMode.SET.
       * MATERIAL_TYPE_SIMPLE mixes the color and colors of the greased line material.
       * @see GreasedLineMeshColorMode
       */
      get colorMode() {
        return this._colorMode;
      }
      /**
       * Sets the mixing mode of the color and colors paramaters. Default value is GreasedLineMeshColorMode.SET.
       * MATERIAL_TYPE_SIMPLE mixes the color and colors of the greased line material.
       * @see GreasedLineMeshColorMode
       */
      set colorMode(value) {
        this._colorMode = value;
        this._setColorModeAndColorDistributionType();
      }
      /**
       * Gets the resolution
       */
      get resolution() {
        return this._resolution;
      }
      /**
       * Sets the resolution
       * @param value resolution of the screen for GreasedLine
       */
      set resolution(value) {
        this._resolution = value;
        this.setVector2("grlResolution", value);
        this.setFloat("grlAspect", value.x / value.y);
      }
      /**
       * Serializes this plugin material
       * @returns serializationObjec
       */
      serialize() {
        const serializationObject = super.serialize();
        const greasedLineMaterialOptions = {
          colorDistributionType: this._colorsDistributionType,
          colorsSampling: this._colorsSampling,
          colorMode: this._colorMode,
          color: this._color,
          dashCount: this._dashCount,
          dashOffset: this._dashOffset,
          dashRatio: this._dashRatio,
          resolution: this._resolution,
          sizeAttenuation: this._sizeAttenuation,
          useColors: this._useColors,
          useDash: this._useDash,
          visibility: this._visibility,
          width: this._width,
          cameraFacing: this._cameraFacing
        };
        if (this._colors) {
          greasedLineMaterialOptions.colors = this._colors;
        }
        serializationObject.greasedLineMaterialOptions = greasedLineMaterialOptions;
        return serializationObject;
      }
      /**
       * Parses a serialized objects
       * @param source serialized object
       * @param scene scene
       * @param _rootUrl root url for textures
       */
      parse(source, scene, _rootUrl) {
        const greasedLineMaterialOptions = source.greasedLineMaterialOptions;
        this._colorsTexture?.dispose();
        if (greasedLineMaterialOptions.color) {
          this.color = greasedLineMaterialOptions.color;
        }
        if (greasedLineMaterialOptions.colorDistributionType) {
          this.colorsDistributionType = greasedLineMaterialOptions.colorDistributionType;
        }
        if (greasedLineMaterialOptions.colorsSampling) {
          this.colorsSampling = greasedLineMaterialOptions.colorsSampling;
        }
        if (greasedLineMaterialOptions.colorMode) {
          this.colorMode = greasedLineMaterialOptions.colorMode;
        }
        if (greasedLineMaterialOptions.useColors) {
          this.useColors = greasedLineMaterialOptions.useColors;
        }
        if (greasedLineMaterialOptions.visibility) {
          this.visibility = greasedLineMaterialOptions.visibility;
        }
        if (greasedLineMaterialOptions.useDash) {
          this.useDash = greasedLineMaterialOptions.useDash;
        }
        if (greasedLineMaterialOptions.dashCount) {
          this.dashCount = greasedLineMaterialOptions.dashCount;
        }
        if (greasedLineMaterialOptions.dashRatio) {
          this.dashRatio = greasedLineMaterialOptions.dashRatio;
        }
        if (greasedLineMaterialOptions.dashOffset) {
          this.dashOffset = greasedLineMaterialOptions.dashOffset;
        }
        if (greasedLineMaterialOptions.width) {
          this.width = greasedLineMaterialOptions.width;
        }
        if (greasedLineMaterialOptions.sizeAttenuation) {
          this.sizeAttenuation = greasedLineMaterialOptions.sizeAttenuation;
        }
        if (greasedLineMaterialOptions.resolution) {
          this.resolution = greasedLineMaterialOptions.resolution;
        }
        if (greasedLineMaterialOptions.colors) {
          this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this.name}-colors-texture`, greasedLineMaterialOptions.colors, this.colorsSampling, this.getScene());
        } else {
          this.colorsTexture = GreasedLineTools.PrepareEmptyColorsTexture(scene);
        }
        this._cameraFacing = greasedLineMaterialOptions.cameraFacing ?? true;
        this.setDefine("GREASED_LINE_CAMERA_FACING", this._cameraFacing);
      }
    };
    GreasedLineSimpleMaterial.ForceGLSL = false;
  }
});

// node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineBaseMesh.js
var GreasedLineRibbonPointsMode, GreasedLineRibbonFacesMode, GreasedLineRibbonAutoDirectionMode, GreasedLineBaseMesh;
var init_greasedLineBaseMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineBaseMesh.js"() {
    init_greasedLinePluginMaterial();
    init_mesh();
    init_buffer();
    init_mesh_vertexData();
    init_deepCopier();
    init_greasedLineSimpleMaterial();
    init_greasedLineTools();
    (function(GreasedLineRibbonPointsMode2) {
      GreasedLineRibbonPointsMode2[GreasedLineRibbonPointsMode2["POINTS_MODE_POINTS"] = 0] = "POINTS_MODE_POINTS";
      GreasedLineRibbonPointsMode2[GreasedLineRibbonPointsMode2["POINTS_MODE_PATHS"] = 1] = "POINTS_MODE_PATHS";
    })(GreasedLineRibbonPointsMode || (GreasedLineRibbonPointsMode = {}));
    (function(GreasedLineRibbonFacesMode2) {
      GreasedLineRibbonFacesMode2[GreasedLineRibbonFacesMode2["FACES_MODE_SINGLE_SIDED"] = 0] = "FACES_MODE_SINGLE_SIDED";
      GreasedLineRibbonFacesMode2[GreasedLineRibbonFacesMode2["FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING"] = 1] = "FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING";
      GreasedLineRibbonFacesMode2[GreasedLineRibbonFacesMode2["FACES_MODE_DOUBLE_SIDED"] = 2] = "FACES_MODE_DOUBLE_SIDED";
    })(GreasedLineRibbonFacesMode || (GreasedLineRibbonFacesMode = {}));
    (function(GreasedLineRibbonAutoDirectionMode2) {
      GreasedLineRibbonAutoDirectionMode2[GreasedLineRibbonAutoDirectionMode2["AUTO_DIRECTIONS_FROM_FIRST_SEGMENT"] = 0] = "AUTO_DIRECTIONS_FROM_FIRST_SEGMENT";
      GreasedLineRibbonAutoDirectionMode2[GreasedLineRibbonAutoDirectionMode2["AUTO_DIRECTIONS_FROM_ALL_SEGMENTS"] = 1] = "AUTO_DIRECTIONS_FROM_ALL_SEGMENTS";
      GreasedLineRibbonAutoDirectionMode2[GreasedLineRibbonAutoDirectionMode2["AUTO_DIRECTIONS_ENHANCED"] = 2] = "AUTO_DIRECTIONS_ENHANCED";
      GreasedLineRibbonAutoDirectionMode2[GreasedLineRibbonAutoDirectionMode2["AUTO_DIRECTIONS_FACE_TO"] = 3] = "AUTO_DIRECTIONS_FACE_TO";
      GreasedLineRibbonAutoDirectionMode2[GreasedLineRibbonAutoDirectionMode2["AUTO_DIRECTIONS_NONE"] = 99] = "AUTO_DIRECTIONS_NONE";
    })(GreasedLineRibbonAutoDirectionMode || (GreasedLineRibbonAutoDirectionMode = {}));
    GreasedLineBaseMesh = class extends Mesh {
      constructor(name, scene, _options) {
        super(name, scene, null, null, false, false);
        this.name = name;
        this._options = _options;
        this._lazy = false;
        this._updatable = false;
        this._engine = scene.getEngine();
        this._lazy = _options.lazy ?? false;
        this._updatable = _options.updatable ?? false;
        this._vertexPositions = [];
        this._indices = [];
        this._uvs = [];
        this._points = [];
        this._colorPointers = _options.colorPointers ?? [];
        this._widths = _options.widths ?? new Array(_options.points.length).fill(1);
      }
      /**
       * "GreasedLineMesh"
       * @returns "GreasedLineMesh"
       */
      getClassName() {
        return "GreasedLineMesh";
      }
      _updateWidthsWithValue(defaulValue) {
        let pointCount = 0;
        for (const points of this._points) {
          pointCount += points.length;
        }
        const countDiff = pointCount / 3 * 2 - this._widths.length;
        for (let i = 0; i < countDiff; i++) {
          this._widths.push(defaulValue);
        }
      }
      /**
       * Updated a lazy line. Rerenders the line and updates boundinfo as well.
       */
      updateLazy() {
        this._setPoints(this._points);
        if (!this._options.colorPointers) {
          this._updateColorPointers();
        }
        this._createVertexBuffers(this._options.ribbonOptions?.smoothShading);
        !this.doNotSyncBoundingInfo && this.refreshBoundingInfo();
        this.greasedLineMaterial?.updateLazy();
      }
      /**
       * Adds new points to the line. It doesn't rerenders the line if in lazy mode.
       * @param points points table
       * @param options optional options
       */
      addPoints(points, options) {
        for (const p of points) {
          this._points.push(p);
        }
        if (!this._lazy) {
          this.setPoints(this._points, options);
        }
      }
      /**
       * Dispose the line and it's resources
       * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
       * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
       */
      dispose(doNotRecurse, disposeMaterialAndTextures = false) {
        super.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
      /**
       * @returns true if the mesh was created in lazy mode
       */
      isLazy() {
        return this._lazy;
      }
      /**
       * Returns the UVs
       */
      get uvs() {
        return this._uvs;
      }
      /**
       * Sets the UVs
       * @param uvs the UVs
       */
      set uvs(uvs) {
        this._uvs = uvs instanceof Float32Array ? uvs : new Float32Array(uvs);
        this._createVertexBuffers();
      }
      /**
       * Returns the points offsets
       * Return the points offsets
       */
      get offsets() {
        return this._offsets;
      }
      /**
       * Sets point offests
       * @param offsets offset table [x,y,z, x,y,z, ....]
       */
      set offsets(offsets) {
        if (this.material instanceof GreasedLineSimpleMaterial) {
          this.material.setDefine(GreasedLineUseOffsetsSimpleMaterialDefine, offsets?.length > 0);
        }
        this._offsets = offsets;
        if (!this._offsetsBuffer) {
          this._createOffsetsBuffer(offsets);
        } else {
          this._offsetsBuffer.update(offsets);
        }
      }
      /**
       * Gets widths at each line point like [widthLower, widthUpper, widthLower, widthUpper, ...]
       */
      get widths() {
        return this._widths;
      }
      /**
       * Sets widths at each line point
       * @param widths width table [widthLower, widthUpper, widthLower, widthUpper ...]
       */
      set widths(widths) {
        this._widths = widths;
        if (!this._lazy) {
          this._widthsBuffer && this._widthsBuffer.update(widths);
        }
      }
      /**
       * Gets the color pointer. Each vertex need a color pointer. These color pointers points to the colors in the color table @see colors
       */
      get colorPointers() {
        return this._colorPointers;
      }
      /**
       * Sets the color pointer
       * @param colorPointers array of color pointer in the colors array. One pointer for every vertex is needed.
       */
      set colorPointers(colorPointers) {
        this._colorPointers = colorPointers;
        if (!this._lazy) {
          this._colorPointersBuffer && this._colorPointersBuffer.update(colorPointers);
        }
      }
      /**
       * Gets the pluginMaterial associated with line
       */
      get greasedLineMaterial() {
        if (this.material && this.material instanceof GreasedLineSimpleMaterial) {
          return this.material;
        }
        const materialPlugin = this.material?.pluginManager?.getPlugin(GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME);
        if (materialPlugin) {
          return materialPlugin;
        }
        return;
      }
      /**
       * Return copy the points.
       */
      get points() {
        const pointsCopy = [];
        DeepCopier.DeepCopy(this._points, pointsCopy);
        return pointsCopy;
      }
      /**
       * Sets line points and rerenders the line.
       * @param points points table
       * @param options optional options
       */
      setPoints(points, options) {
        this._points = GreasedLineTools.ConvertPoints(points, options?.pointsOptions ?? this._options.pointsOptions);
        this._updateWidths();
        if (!options?.colorPointers) {
          this._updateColorPointers();
        }
        this._setPoints(this._points, options);
      }
      _initGreasedLine() {
        this._vertexPositions = [];
        this._indices = [];
        this._uvs = [];
      }
      _createLineOptions() {
        const lineOptions = {
          points: this._points,
          colorPointers: this._colorPointers,
          lazy: this._lazy,
          updatable: this._updatable,
          uvs: this._uvs,
          widths: this._widths,
          ribbonOptions: this._options.ribbonOptions
        };
        return lineOptions;
      }
      /**
       * Serializes this GreasedLineMesh
       * @param serializationObject object to write serialization to
       */
      serialize(serializationObject) {
        super.serialize(serializationObject);
        serializationObject.type = this.getClassName();
        serializationObject.lineOptions = this._createLineOptions();
      }
      _createVertexBuffers(computeNormals = false) {
        const vertexData = new VertexData();
        vertexData.positions = this._vertexPositions;
        vertexData.indices = this._indices;
        vertexData.uvs = this._uvs;
        if (computeNormals) {
          vertexData.normals = [];
          VertexData.ComputeNormals(this._vertexPositions, this._indices, vertexData.normals);
        }
        vertexData.applyToMesh(this, this._options.updatable);
        return vertexData;
      }
      _createOffsetsBuffer(offsets) {
        const engine = this._scene.getEngine();
        const offsetBuffer = new Buffer(engine, offsets, this._updatable, 3);
        this.setVerticesBuffer(offsetBuffer.createVertexBuffer("grl_offsets", 0, 3));
        this._offsetsBuffer = offsetBuffer;
      }
    };
  }
});

export {
  SpecularPowerToRoughness,
  init_materialConversionHelper,
  MergeTexturesAsync,
  CreateTextureInput,
  CreateConstantInput,
  CreateRGBAConfiguration,
  init_textureMerger,
  GreasedLineMaterialDefaults,
  init_greasedLineMaterialDefaults,
  GreasedLineTools,
  init_greasedLineTools,
  MaterialGreasedLineDefines,
  GreasedLinePluginMaterial,
  init_greasedLinePluginMaterial,
  GreasedLineUseOffsetsSimpleMaterialDefine,
  GreasedLineSimpleMaterial,
  init_greasedLineSimpleMaterial,
  GreasedLineRibbonPointsMode,
  GreasedLineRibbonFacesMode,
  GreasedLineRibbonAutoDirectionMode,
  GreasedLineBaseMesh,
  init_greasedLineBaseMesh
};
//# sourceMappingURL=chunk-U2PPL777.js.map
