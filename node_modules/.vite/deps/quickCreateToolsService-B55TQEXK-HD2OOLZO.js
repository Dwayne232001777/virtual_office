import {
  FlyCamera,
  NodeRenderGraph,
  PBRMaterial,
  UniversalCamera,
  init_flyCamera,
  init_nodeRenderGraph,
  init_pbrMaterial,
  init_universalCamera,
  init_webgl2ParticleSystem
} from "./chunk-2EJYNSOB.js";
import {
  Accordion2 as Accordion,
  AccordionSection,
  Button2 as Button,
  CheckboxPropertyLine,
  CollectionsAdd20Regular,
  MessageBar,
  Popover2 as Popover,
  SceneContextIdentity,
  SettingsRegular,
  ShellServiceIdentity,
  SpinButtonPropertyLine,
  TextInputPropertyLine,
  Vector3PropertyLine,
  makeStyles,
  require_client,
  require_jsx_runtime,
  require_react,
  tokens,
  useObservableState,
  useProperty
} from "./chunk-VIHURK3B.js";
import {
  ArcRotateCamera,
  DefaultRenderingPipeline,
  DirectionalLight,
  FilesInput,
  FollowCamera,
  FreeCamera,
  GPUParticleSystem,
  GeospatialCamera,
  IblShadowsRenderPipeline,
  MeshBuilder,
  NodeMaterial,
  NodeParticleSystemSet,
  ParticleSystem,
  PointLight,
  SSAO2RenderingPipeline,
  SSAORenderingPipeline,
  SSRRenderingPipeline,
  SpotLight,
  SpriteManager,
  init_IPhysicsEnginePlugin,
  init_abstractEngine_timeQuery,
  init_animationPropertiesOverride,
  init_arcRotateCamera,
  init_asyncLock,
  init_attractor,
  init_boundingBoxRenderer,
  init_boxParticleEmitter,
  init_cameraGizmo,
  init_cascadedShadowGenerator,
  init_clusteredLightContainer,
  init_coneParticleEmitter,
  init_cubeTexture,
  init_cylinderParticleEmitter,
  init_dataStorage,
  init_debugLayer,
  init_defaultRenderingPipeline,
  init_deferred,
  init_directionalLight,
  init_directionalLightFrustumViewer,
  init_dynamicTexture,
  init_edgesRenderer,
  init_engineInstrumentation,
  init_engine_query,
  init_equirectangularCapture,
  init_filesInput,
  init_followCamera,
  init_frameGraph,
  init_frameGraphUtils,
  init_freeCamera,
  init_gaussianSplattingMesh,
  init_geospatialCamera,
  init_gizmoManager,
  init_gpuParticleSystem,
  init_gradientBlock,
  init_gradients,
  init_groundBuilder,
  init_hemisphericLight,
  init_hemisphericParticleEmitter,
  init_htmlElementTexture,
  init_iblShadowsRenderPipeline,
  init_lazy,
  init_lensRenderingPipeline,
  init_lightGizmo,
  init_linesBuilder,
  init_meshBuilder,
  init_meshParticleEmitter,
  init_multiRenderTarget,
  init_nodeMaterial,
  init_nodeMaterialBlockConnectionPointTypes,
  init_nodeParticleBlockConnectionPointTypes,
  init_nodeParticleSystemSet,
  init_nodeParticleSystemSet_helper,
  init_outlineRenderer,
  init_particleHelper,
  init_particleInputBlock,
  init_particleSystem,
  init_performanceViewerCollectionStrategies,
  init_performanceViewerCollector,
  init_performanceViewerSceneExtension,
  init_physicsEngineComponent,
  init_physicsViewer,
  init_planeBuilder,
  init_pointLight,
  init_pointParticleEmitter,
  init_postProcessRenderPipeline,
  init_postProcessRenderPipelineManagerSceneComponent,
  init_pressureObserverWrapper,
  init_rectAreaLight,
  init_sceneInstrumentation,
  init_sceneLoader,
  init_sceneRecorder,
  init_sceneSerializer,
  init_screenshotTools,
  init_shadowGenerator,
  init_shadowGeneratorSceneComponent,
  init_shadowLight,
  init_skeleton,
  init_skeletonViewer,
  init_sound,
  init_sphereBuilder,
  init_sphereParticleEmitter,
  init_spotLight,
  init_sprite,
  init_spriteManager,
  init_spriteSceneComponent,
  init_ssao2RenderingPipeline,
  init_ssaoRenderingPipeline,
  init_ssrRenderingPipeline,
  init_updateAttractorBlock,
  init_utilityLayerRenderer,
  init_videoRecorder
} from "./chunk-YERFS6AN.js";
import {
  StandardMaterial,
  init_camera,
  init_constants,
  init_instancedMesh,
  init_light,
  init_math_scalar,
  init_mesh,
  init_multiMaterial,
  init_openpbrMaterial,
  init_pbrBaseMaterial,
  init_shaderMaterial,
  init_standardMaterial,
  init_targetCamera
} from "./chunk-JWLZD23T.js";
import {
  init_material
} from "./chunk-OBADV6JF.js";
import "./chunk-JIO6C5IF.js";
import "./chunk-RJ2RNMIL.js";
import "./chunk-DSLQYMGE.js";
import "./chunk-RQDKNWPQ.js";
import "./chunk-6UQQDTV4.js";
import "./chunk-O363AM3X.js";
import "./chunk-5EPOFQSC.js";
import "./chunk-I4TMRQDB.js";
import "./chunk-IJXTNMZ6.js";
import "./chunk-QJAKFPLU.js";
import "./chunk-TDAMRNXH.js";
import "./chunk-MR4MHZDR.js";
import "./chunk-YQPXPURX.js";
import "./chunk-C62IEWMB.js";
import "./chunk-Q4ATXN7P.js";
import "./chunk-EHPXJH3C.js";
import "./chunk-ND5SZGM6.js";
import "./chunk-KSPXS46C.js";
import {
  init_buffer,
  init_engine_query as init_engine_query2
} from "./chunk-YW3NGYMJ.js";
import {
  init_abstractMesh,
  init_transformNode
} from "./chunk-TMHG26QH.js";
import "./chunk-JTDOLEW4.js";
import {
  init_animationGroup,
  init_bone
} from "./chunk-AF4R4V7O.js";
import {
  init_animation
} from "./chunk-IPODAMC3.js";
import {
  init_node
} from "./chunk-E7XHG63E.js";
import {
  init_materialFlags
} from "./chunk-R3NLUQNA.js";
import "./chunk-Y5XTKMAE.js";
import "./chunk-B4ONFBQP.js";
import "./chunk-NCRPMFYT.js";
import "./chunk-ORGDVUQ5.js";
import "./chunk-UXRSBRXU.js";
import "./chunk-RKJ3OZYD.js";
import "./chunk-GVBFKIFY.js";
import "./chunk-VZPPBK3A.js";
import "./chunk-QF4IVEOO.js";
import "./chunk-3A3RDOQT.js";
import "./chunk-DZQJ4XKI.js";
import "./chunk-4YZDCOVM.js";
import "./chunk-PLE22TB7.js";
import "./chunk-YGF775II.js";
import "./chunk-OYBIGYUP.js";
import "./chunk-BVRUXDHT.js";
import "./chunk-KOTVE4EO.js";
import "./chunk-PLHGDMCI.js";
import "./chunk-72KUQ4IQ.js";
import "./chunk-V3TVNJXE.js";
import "./chunk-IEAIFCDZ.js";
import "./chunk-IHUMVUSL.js";
import "./chunk-24OONKND.js";
import "./chunk-V6FF32RD.js";
import "./chunk-DJVZAM6B.js";
import "./chunk-MRV6TWLW.js";
import "./chunk-SWFW6DYT.js";
import "./chunk-W5UENS42.js";
import "./chunk-QYWTSVQS.js";
import "./chunk-VTWDYKUG.js";
import "./chunk-LZQ2H4AJ.js";
import "./chunk-JSGK7STH.js";
import "./chunk-APSZEATK.js";
import "./chunk-BHPFZKGL.js";
import "./chunk-OIGXU6BI.js";
import "./chunk-GAZYG7IR.js";
import "./chunk-BBDVNNXD.js";
import "./chunk-RY6DX2UY.js";
import "./chunk-RROYVW5G.js";
import "./chunk-ID4ZO5NA.js";
import "./chunk-OYRFMYR3.js";
import "./chunk-UPOV6W65.js";
import "./chunk-ELOH4KJD.js";
import "./chunk-DQLZ7JYN.js";
import "./chunk-WADM34TY.js";
import "./chunk-SA2UQP65.js";
import "./chunk-5S6SXMA4.js";
import "./chunk-VR6S6BQH.js";
import "./chunk-GNRKNFVG.js";
import {
  init_environmentTextureTools
} from "./chunk-O5NT7YNJ.js";
import "./chunk-ESGOHTGL.js";
import {
  init_imageProcessingConfiguration,
  init_keyboardEvents,
  init_scene
} from "./chunk-U45B254N.js";
import {
  init_pointerEvents
} from "./chunk-CCNHJS5Q.js";
import "./chunk-FV6YI4DO.js";
import "./chunk-KEMNSKWR.js";
import {
  init_uniqueIdGenerator
} from "./chunk-3DVETICX.js";
import "./chunk-ETNKJY4V.js";
import "./chunk-RSNSIAVI.js";
import "./chunk-TYUDJDBK.js";
import "./chunk-XXTMV5AV.js";
import {
  init_engine,
  init_postProcess,
  init_renderTargetTexture,
  init_textureTools
} from "./chunk-E2UXTG46.js";
import "./chunk-2EZNXTHP.js";
import {
  init_renderingManager
} from "./chunk-XUMUHFKD.js";
import "./chunk-3V3ZT36M.js";
import "./chunk-TYVCVQQX.js";
import "./chunk-TZ4U7RDF.js";
import "./chunk-WJTQGE6H.js";
import "./chunk-4L5VDV4X.js";
import "./chunk-NER52ESJ.js";
import "./chunk-YEEYUO2W.js";
import "./chunk-BXP5BQWR.js";
import "./chunk-IIY2JHNQ.js";
import "./chunk-LNXOCKX5.js";
import {
  Texture,
  init_baseTexture,
  init_texture,
  init_thinTexture
} from "./chunk-W2Z3EUIE.js";
import "./chunk-6DIPKSGI.js";
import "./chunk-HNJVWIJU.js";
import {
  init_math_color
} from "./chunk-FQA5U7KF.js";
import "./chunk-KU6EWKFQ.js";
import "./chunk-YAQBA6HC.js";
import "./chunk-UOPMYM72.js";
import "./chunk-7BKBHJIC.js";
import {
  init_tools
} from "./chunk-TQMUJQOB.js";
import {
  init_fileTools
} from "./chunk-X7JT3LZV.js";
import "./chunk-T55R2ONV.js";
import "./chunk-PSHGEZXL.js";
import {
  init_abstractEngine
} from "./chunk-WTQMXJ7P.js";
import "./chunk-HCT32MRG.js";
import "./chunk-4OYBTWIA.js";
import "./chunk-EH2LCGGP.js";
import "./chunk-LALEIYHZ.js";
import "./chunk-XZNSM4SR.js";
import "./chunk-ABB2DSSU.js";
import {
  Vector3,
  init_math_vector
} from "./chunk-VQZCJUUR.js";
import {
  init_typeStore
} from "./chunk-7ANHXSNA.js";
import "./chunk-YU3PZQGE.js";
import {
  init_engineStore
} from "./chunk-TS7QJBPS.js";
import {
  init_math_scalar_functions
} from "./chunk-XBFJXXXT.js";
import "./chunk-TUYXUOSZ.js";
import "./chunk-JXJ5SDPH.js";
import {
  init_logger
} from "./chunk-2X44KPCK.js";
import {
  init_observable
} from "./chunk-PY47FUFT.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@babylonjs/inspector/lib/quickCreateToolsService-B55TQEXK.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
init_webgl2ParticleSystem();
init_meshBuilder();
var import_react = __toESM(require_react(), 1);
init_filesInput();
init_nodeMaterial();
init_pbrMaterial();
init_standardMaterial();
init_pointLight();
init_directionalLight();
init_spotLight();
init_math_vector();
init_arcRotateCamera();
init_universalCamera();
init_freeCamera();
init_followCamera();
init_flyCamera();
init_geospatialCamera();
init_particleSystem();
init_gpuParticleSystem();
init_nodeParticleSystemSet();
init_texture();
init_defaultRenderingPipeline();
init_ssaoRenderingPipeline();
init_ssao2RenderingPipeline();
init_ssrRenderingPipeline();
init_iblShadowsRenderPipeline();
init_nodeRenderGraph();
init_spriteManager();
init_math_color();
init_observable();
init_typeStore();
init_asyncLock();
init_deferred();
init_logger();
init_math_scalar_functions();
init_uniqueIdGenerator();
init_physicsViewer();
init_materialFlags();
init_groundBuilder();
init_tools();
init_utilityLayerRenderer();
init_dataStorage();
init_engineInstrumentation();
init_sceneInstrumentation();
init_abstractEngine_timeQuery();
init_engine_query();
init_engine_query2();
init_performanceViewerCollectionStrategies();
init_performanceViewerSceneExtension();
init_pressureObserverWrapper();
init_math_scalar();
init_performanceViewerCollector();
init_abstractEngine();
var import_client = __toESM(require_client(), 1);
init_frameGraphUtils();
init_cameraGizmo();
init_lightGizmo();
init_bone();
init_camera();
init_gizmoManager();
init_light();
init_abstractMesh();
init_node();
init_animationGroup();
init_animation();
init_animationPropertiesOverride();
init_sound();
init_targetCamera();
init_scene();
init_frameGraph();
init_hemisphericLight();
init_rectAreaLight();
init_shadowLight();
init_cascadedShadowGenerator();
init_directionalLightFrustumViewer();
init_shadowGenerator();
init_shadowGeneratorSceneComponent();
init_material();
init_multiMaterial();
init_openpbrMaterial();
init_pbrBaseMaterial();
init_constants();
init_engine();
init_gradientBlock();
init_nodeMaterialBlockConnectionPointTypes();
init_gradients();
init_fileTools();
init_cubeTexture();
init_gaussianSplattingMesh();
init_mesh();
init_skeletonViewer();
init_buffer();
init_linesBuilder();
init_instancedMesh();
init_renderingManager();
init_edgesRenderer();
init_outlineRenderer();
init_nodeParticleSystemSet_helper();
init_particleHelper();
init_boxParticleEmitter();
init_coneParticleEmitter();
init_cylinderParticleEmitter();
init_hemisphericParticleEmitter();
init_meshParticleEmitter();
init_pointParticleEmitter();
init_sphereParticleEmitter();
init_attractor();
init_sphereBuilder();
init_particleInputBlock();
init_updateAttractorBlock();
init_nodeParticleBlockConnectionPointTypes();
init_transformNode();
init_IPhysicsEnginePlugin();
init_physicsEngineComponent();
init_postProcess();
init_postProcessRenderPipeline();
init_lensRenderingPipeline();
init_imageProcessingConfiguration();
init_skeleton();
init_sprite();
init_textureTools();
init_baseTexture();
init_multiRenderTarget();
init_renderTargetTexture();
init_thinTexture();
init_keyboardEvents();
init_pointerEvents();
init_htmlElementTexture();
init_shaderMaterial();
init_planeBuilder();
init_clusteredLightContainer();
init_boundingBoxRenderer();
init_postProcessRenderPipelineManagerSceneComponent();
init_spriteSceneComponent();
init_dynamicTexture();
init_equirectangularCapture();
init_sceneRecorder();
init_screenshotTools();
init_videoRecorder();
init_sceneSerializer();
init_environmentTextureTools();
init_sceneLoader();
init_engineStore();
init_debugLayer();
init_lazy();
var SettingsPopover = (props) => {
  return (0, import_jsx_runtime.jsxs)(Popover, { icon: SettingsRegular, children: [" ", props.children, " "] });
};
var useStyles = makeStyles({
  section: {
    display: "flex",
    flexDirection: "column",
    rowGap: tokens.spacingVerticalM
  },
  row: { display: "flex", alignItems: "center", gap: "4px" }
});
var QuickCreateSection = ({ children }) => {
  const classes = useStyles();
  return (0, import_jsx_runtime.jsx)("div", { className: classes.section, children });
};
var QuickCreateRow = ({ children }) => {
  const classes = useStyles();
  return (0, import_jsx_runtime.jsx)("div", { className: classes.row, children });
};
var SetCamera = function(scene) {
  const camera = scene.activeCamera;
  if (camera && camera.radius !== void 0) {
    camera.radius = 5;
  }
};
var MeshesContent = ({ scene }) => {
  const [sphereParams, setSphereParams] = (0, import_react.useState)({
    name: "Sphere",
    segments: 32,
    diameter: 1,
    diameterX: 1,
    diameterY: 1,
    diameterZ: 1,
    arc: 1,
    slice: 1,
    uniform: true
  });
  const handleSphereParamChange = (key, value) => {
    setSphereParams((prev) => ({
      ...prev,
      [key]: value
    }));
  };
  const [boxParams, setBoxParams] = (0, import_react.useState)({
    name: "Box",
    size: 1,
    width: 1,
    height: 1,
    depth: 1
  });
  const handleBoxParamChange = (key, value) => {
    setBoxParams((prev) => ({
      ...prev,
      [key]: value
    }));
  };
  const [cylinderParams, setCylinderParams] = (0, import_react.useState)({
    name: "Cylinder",
    height: 2,
    diameterTop: 1,
    diameterBottom: 1,
    diameter: 1,
    tessellation: 32,
    subdivisions: 1,
    arc: 1
  });
  const handleCylinderParamChange = (key, value) => {
    setCylinderParams((prev) => ({
      ...prev,
      [key]: value
    }));
  };
  const [coneParams, setConeParams] = (0, import_react.useState)({
    name: "Cone",
    height: 2,
    diameter: 1,
    diameterTop: 0,
    diameterBottom: 1,
    tessellation: 32,
    subdivisions: 1,
    arc: 1
  });
  const [coneUp, setConeUp] = (0, import_react.useState)(true);
  const handleConeParamChange = (key, value) => {
    setConeParams((prev) => ({
      ...prev,
      [key]: value
    }));
  };
  const [groundParams, setGroundParams] = (0, import_react.useState)({
    name: "Ground",
    width: 10,
    height: 10,
    subdivisions: 1,
    subdivisionsX: 1,
    subdivisionsY: 1
  });
  const handleGroundParamChange = (key, value) => {
    setGroundParams((prev) => ({
      ...prev,
      [key]: value
    }));
  };
  const fileInputRef = (0, import_react.useRef)(null);
  const [importMeshName, setImportMeshName] = (0, import_react.useState)("ImportedMesh");
  const handleLocalMeshImport = (event) => {
    const files = event.target.files;
    if (!files || files.length === 0) {
      return;
    }
    const filesArray = Array.from(files);
    if (importMeshName.trim().length > 0 && filesArray.length > 0) {
      const originalFile = filesArray[0];
      const extensionIndex = originalFile.name.lastIndexOf(".");
      const extension = extensionIndex >= 0 ? originalFile.name.substring(extensionIndex) : "";
      const sanitizedName = importMeshName.trim();
      const desiredFileName = sanitizedName.toLowerCase().endsWith(extension.toLowerCase()) ? sanitizedName : `${sanitizedName}${extension}`;
      filesArray[0] = new File([originalFile], desiredFileName, { type: originalFile.type, lastModified: originalFile.lastModified });
    }
    const filesInput = new FilesInput(scene.getEngine(), scene, null, null, null, null, null, null, (_sceneFile, _scene, message) => {
      alert(message ? `Failed to import mesh: ${message}` : "Failed to import mesh.");
    }, true);
    filesInput.displayLoadingUI = false;
    filesInput.loadFiles({ target: { files: filesArray } });
    filesInput.dispose();
    event.target.value = "";
  };
  return (0, import_jsx_runtime.jsxs)(QuickCreateSection, { children: [(0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: () => {
    MeshBuilder.CreateSphere("Sphere", {}, scene);
    SetCamera(scene);
  }, label: "Sphere" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: sphereParams.name, onChange: (val) => handleSphereParamChange("name", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Segments", value: sphereParams.segments, min: 0, onChange: (val) => handleSphereParamChange("segments", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Diameter", value: sphereParams.diameter, min: 0, step: 0.1, onChange: (val) => handleSphereParamChange("diameter", val), disabled: !sphereParams.uniform }), (0, import_jsx_runtime.jsx)(CheckboxPropertyLine, { label: "Uniform", value: sphereParams.uniform, onChange: (checked) => handleSphereParamChange("uniform", checked) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Diameter X", value: sphereParams.diameterX, min: 0, step: 0.1, onChange: (val) => handleSphereParamChange("diameterX", val), disabled: sphereParams.uniform }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Diameter Y", value: sphereParams.diameterY, min: 0, step: 0.1, onChange: (val) => handleSphereParamChange("diameterY", val), disabled: sphereParams.uniform }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Diameter Z", value: sphereParams.diameterZ, min: 0, step: 0.1, onChange: (val) => handleSphereParamChange("diameterZ", val), disabled: sphereParams.uniform }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Arc", value: sphereParams.arc, min: 0, max: 1, step: 0.1, onChange: (val) => handleSphereParamChange("arc", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Slice", value: sphereParams.slice, min: 0, max: 1, step: 0.1, onChange: (val) => handleSphereParamChange("slice", val) }), (0, import_jsx_runtime.jsx)("div", { style: { display: "flex", justifyContent: "flex-end", gap: 8, marginTop: 16 }, children: (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: () => {
    const createParams = {
      segments: sphereParams.segments,
      arc: sphereParams.arc,
      slice: sphereParams.slice
    };
    if (sphereParams.uniform) {
      createParams.diameter = sphereParams.diameter;
    } else {
      createParams.diameterX = sphereParams.diameterX;
      createParams.diameterY = sphereParams.diameterY;
      createParams.diameterZ = sphereParams.diameterZ;
    }
    MeshBuilder.CreateSphere(sphereParams.name, createParams, scene);
    SetCamera(scene);
  }, label: "Create" }) })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: () => {
    MeshBuilder.CreateBox("Box", {}, scene);
    SetCamera(scene);
  }, label: "Box" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: boxParams.name, onChange: (val) => handleBoxParamChange("name", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Size", value: boxParams.size, min: 0, step: 0.1, onChange: (val) => handleBoxParamChange("size", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Width", value: boxParams.width, min: 0, step: 0.1, onChange: (val) => handleBoxParamChange("width", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Height", value: boxParams.height, min: 0, step: 0.1, onChange: (val) => handleBoxParamChange("height", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Depth", value: boxParams.depth, min: 0, step: 0.1, onChange: (val) => handleBoxParamChange("depth", val) }), (0, import_jsx_runtime.jsx)("div", { style: { display: "flex", justifyContent: "flex-end", gap: 8, marginTop: 16 }, children: (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: () => {
    MeshBuilder.CreateBox(boxParams.name, boxParams, scene);
    SetCamera(scene);
  }, label: "Create" }) })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: () => {
    MeshBuilder.CreateCylinder("Cylinder", {}, scene);
    SetCamera(scene);
  }, label: "Cylinder" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: cylinderParams.name, onChange: (val) => handleCylinderParamChange("name", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Height", value: cylinderParams.height, min: 0, step: 0.1, onChange: (val) => handleCylinderParamChange("height", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Diameter Top", value: cylinderParams.diameterTop, min: 0, step: 0.1, onChange: (val) => handleCylinderParamChange("diameterTop", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Diameter Bottom", value: cylinderParams.diameterBottom, min: 0, step: 0.1, onChange: (val) => handleCylinderParamChange("diameterBottom", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Diameter", value: cylinderParams.diameter, min: 0, step: 0.1, onChange: (val) => handleCylinderParamChange("diameter", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Tessellation", value: cylinderParams.tessellation, min: 3, onChange: (val) => handleCylinderParamChange("tessellation", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Subdivisions", value: cylinderParams.subdivisions, min: 1, onChange: (val) => handleCylinderParamChange("subdivisions", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Arc", value: cylinderParams.arc, min: 0, max: 1, step: 0.1, onChange: (val) => handleCylinderParamChange("arc", val) }), (0, import_jsx_runtime.jsx)("div", { style: { display: "flex", justifyContent: "flex-end", gap: 8, marginTop: 16 }, children: (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: () => {
    MeshBuilder.CreateCylinder(cylinderParams.name, cylinderParams, scene);
    SetCamera(scene);
  }, label: "Create" }) })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: () => {
    MeshBuilder.CreateCylinder("Cone", { diameterTop: 0 }, scene);
    SetCamera(scene);
  }, label: "Cone" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: coneParams.name, onChange: (val) => handleConeParamChange("name", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Height", value: coneParams.height, min: 0, step: 0.1, onChange: (val) => handleConeParamChange("height", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Diameter", value: coneParams.diameter, min: 0, step: 0.1, onChange: (val) => handleConeParamChange("diameter", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Tessellation", value: coneParams.tessellation, min: 3, onChange: (val) => handleConeParamChange("tessellation", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Subdivisions", value: coneParams.subdivisions, min: 1, onChange: (val) => handleConeParamChange("subdivisions", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Arc", value: coneParams.arc, min: 0, max: 1, step: 0.1, onChange: (val) => handleConeParamChange("arc", val) }), (0, import_jsx_runtime.jsx)(CheckboxPropertyLine, { label: "Up", value: coneUp, onChange: (val) => setConeUp(val) }), (0, import_jsx_runtime.jsx)("div", { style: { display: "flex", justifyContent: "flex-end", gap: 8, marginTop: 16 }, children: (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: () => {
    const coneParamsToUse = {
      ...coneParams,
      diameterTop: coneUp ? 0 : coneParams.diameterTop,
      diameterBottom: coneUp ? coneParams.diameterBottom : 0
    };
    MeshBuilder.CreateCylinder(coneParams.name, coneParamsToUse, scene);
    SetCamera(scene);
  }, label: "Create" }) })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: () => {
    MeshBuilder.CreateGround("Ground", {}, scene);
    SetCamera(scene);
  }, label: "Ground" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: groundParams.name, onChange: (val) => handleGroundParamChange("name", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Width", value: groundParams.width, min: 0, step: 0.1, onChange: (val) => handleGroundParamChange("width", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Height", value: groundParams.height, min: 0, step: 0.1, onChange: (val) => handleGroundParamChange("height", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Subdivisions", value: groundParams.subdivisions, min: 1, onChange: (val) => handleGroundParamChange("subdivisions", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Subdivisions X", value: groundParams.subdivisionsX, min: 1, onChange: (val) => handleGroundParamChange("subdivisionsX", val) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Subdivisions Y", value: groundParams.subdivisionsY, min: 1, onChange: (val) => handleGroundParamChange("subdivisionsY", val) }), (0, import_jsx_runtime.jsx)("div", { style: { display: "flex", justifyContent: "flex-end", gap: 8, marginTop: 16 }, children: (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: () => {
    MeshBuilder.CreateGround(groundParams.name, groundParams, scene);
    SetCamera(scene);
  }, label: "Create" }) })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: () => {
    fileInputRef.current?.click();
  }, label: "Import Mesh" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: importMeshName, onChange: (val) => setImportMeshName(val) }), (0, import_jsx_runtime.jsx)("div", { style: { display: "flex", justifyContent: "flex-end", gap: 8 }, children: (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: () => {
    fileInputRef.current?.click();
  }, label: "Import" }) })] }), (0, import_jsx_runtime.jsx)("input", { ref: fileInputRef, type: "file", accept: ".babylon,.glb,.gltf,.obj,.stl,.ply,.mesh,.babylonmeshdata", multiple: true, style: { display: "none" }, onChange: handleLocalMeshImport })] })] });
};
var MaterialsContent = ({ scene }) => {
  const [nodeMaterialName, setNodeMaterialName] = (0, import_react.useState)("Node Material");
  const [nodeMaterialSnippetId, setNodeMaterialSnippetId] = (0, import_react.useState)("");
  const [pbrMaterialName, setPbrMaterialName] = (0, import_react.useState)("PBR Material");
  const [standardMaterialName, setStandardMaterialName] = (0, import_react.useState)("Standard Material");
  const handleCreateNodeMaterialAsync = async () => {
    if (nodeMaterialSnippetId) {
      try {
        const nodeMaterial = await NodeMaterial.ParseFromSnippetAsync(nodeMaterialSnippetId, scene);
        nodeMaterial.name = nodeMaterialName;
      } catch (e) {
        alert("Failed to load Node Material from snippet: " + e);
      }
    } else {
      const nodeMaterial = new NodeMaterial(nodeMaterialName, scene);
      nodeMaterial.build();
    }
  };
  const handleCreatePBRMaterial = () => {
    new PBRMaterial(pbrMaterialName, scene);
  };
  const handleCreateStandardMaterial = () => {
    new StandardMaterial(standardMaterialName, scene);
  };
  return (0, import_jsx_runtime.jsxs)(QuickCreateSection, { children: [(0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateNodeMaterialAsync, label: "Node Material" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: nodeMaterialName, onChange: (value) => setNodeMaterialName(value) }), (0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Snippet ID", value: nodeMaterialSnippetId, onChange: (value) => setNodeMaterialSnippetId(value) }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateNodeMaterialAsync, label: "Create" })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreatePBRMaterial, label: "PBR Material" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: pbrMaterialName, onChange: (value) => setPbrMaterialName(value) }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreatePBRMaterial, label: "Create" })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateStandardMaterial, label: "Standard Material" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: standardMaterialName, onChange: (value) => setStandardMaterialName(value) }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateStandardMaterial, label: "Create" })] })] })] });
};
var LightsContent = ({ scene }) => {
  const [pointLightName, setPointLightName] = (0, import_react.useState)("Point Light");
  const [pointLightPosition, setPointLightPosition] = (0, import_react.useState)(new Vector3(0, 5, 0));
  const [directionalLightName, setDirectionalLightName] = (0, import_react.useState)("Directional Light");
  const [directionalLightDirection, setDirectionalLightDirection] = (0, import_react.useState)(new Vector3(1, -1, 0));
  const [spotlightName, setSpotlightName] = (0, import_react.useState)("Spotlight");
  const [spotlightPosition, setSpotlightPosition] = (0, import_react.useState)(new Vector3(0, 5, 0));
  const [spotlightDirection, setSpotlightDirection] = (0, import_react.useState)(new Vector3(0, -1, 0));
  const [spotlightAngle, setSpotlightAngle] = (0, import_react.useState)(1);
  const [spotlightExponent, setSpotlightExponent] = (0, import_react.useState)(1);
  const handleCreatePointLight = () => {
    const light = new PointLight(pointLightName, pointLightPosition, scene);
    light.intensity = 1;
  };
  const handleCreateDirectionalLight = () => {
    const dirLight = new DirectionalLight(directionalLightName, directionalLightDirection, scene);
    dirLight.intensity = 1;
  };
  const handleCreateSpotlight = () => {
    const spotlight = new SpotLight(spotlightName, spotlightPosition, spotlightDirection, spotlightAngle, spotlightExponent, scene);
    spotlight.intensity = 1;
  };
  return (0, import_jsx_runtime.jsxs)(QuickCreateSection, { children: [(0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreatePointLight, label: "Point Light" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: pointLightName, onChange: (value) => setPointLightName(value) }), (0, import_jsx_runtime.jsx)(Vector3PropertyLine, { label: "Position", value: pointLightPosition, onChange: (value) => setPointLightPosition(value) }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreatePointLight, label: "Create" })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateDirectionalLight, label: "Directional Light" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: directionalLightName, onChange: (value) => setDirectionalLightName(value) }), (0, import_jsx_runtime.jsx)(Vector3PropertyLine, { label: "Direction", value: directionalLightDirection, onChange: (value) => setDirectionalLightDirection(value) }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateDirectionalLight, label: "Create" })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateSpotlight, label: "Spotlight" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: spotlightName, onChange: (value) => setSpotlightName(value) }), (0, import_jsx_runtime.jsx)(Vector3PropertyLine, { label: "Position", value: spotlightPosition, onChange: (value) => setSpotlightPosition(value) }), (0, import_jsx_runtime.jsx)(Vector3PropertyLine, { label: "Direction", value: spotlightDirection, onChange: (value) => setSpotlightDirection(value) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Angle", value: spotlightAngle, onChange: (value) => setSpotlightAngle(value), min: 0, max: Math.PI, step: 0.1 }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Exponent", value: spotlightExponent, onChange: (value) => setSpotlightExponent(value), min: 0, max: 10, step: 0.1 }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateSpotlight, label: "Create" })] })] })] });
};
var CamerasContent = ({ scene }) => {
  const [arcRotateCameraName, setArcRotateCameraName] = (0, import_react.useState)("ArcRotate Camera");
  const [arcRotateCameraTarget, setArcRotateCameraTarget] = (0, import_react.useState)(new Vector3(0, 0, 0));
  const [arcRotateCameraRadius, setArcRotateCameraRadius] = (0, import_react.useState)(10);
  const [arcRotateCameraAlpha, setArcRotateCameraAlpha] = (0, import_react.useState)(0);
  const [arcRotateCameraBeta, setArcRotateCameraBeta] = (0, import_react.useState)(45);
  const [arcRotateCameraUseRadians, setArcRotateCameraUseRadians] = (0, import_react.useState)(false);
  const [universalCameraName, setUniversalCameraName] = (0, import_react.useState)("Universal Camera");
  const [universalCameraPosition, setUniversalCameraPosition] = (0, import_react.useState)(new Vector3(0, 1, -10));
  const [freeCameraName, setFreeCameraName] = (0, import_react.useState)("Free Camera");
  const [freeCameraPosition, setFreeCameraPosition] = (0, import_react.useState)(new Vector3(0, 1, -10));
  const [followCameraName, setFollowCameraName] = (0, import_react.useState)("Follow Camera");
  const [followCameraPosition, setFollowCameraPosition] = (0, import_react.useState)(new Vector3(0, 5, -10));
  const [followCameraRadius, setFollowCameraRadius] = (0, import_react.useState)(10);
  const [followCameraHeightOffset, setFollowCameraHeightOffset] = (0, import_react.useState)(4);
  const [followCameraRotationOffset, setFollowCameraRotationOffset] = (0, import_react.useState)(0);
  const [flyCameraName, setFlyCameraName] = (0, import_react.useState)("Fly Camera");
  const [flyCameraPosition, setFlyCameraPosition] = (0, import_react.useState)(new Vector3(0, 1, -10));
  const [geospatialCameraName, setGeospatialCameraName] = (0, import_react.useState)("Geospatial Camera");
  const [geospatialCameraPlanetRadius, setGeospatialCameraPlanetRadius] = (0, import_react.useState)(6371e3);
  const handleCreateArcRotateCamera = () => {
    const alpha = arcRotateCameraUseRadians ? arcRotateCameraAlpha : arcRotateCameraAlpha * Math.PI / 180;
    const beta = arcRotateCameraUseRadians ? arcRotateCameraBeta : arcRotateCameraBeta * Math.PI / 180;
    const camera = new ArcRotateCamera(arcRotateCameraName, alpha, beta, arcRotateCameraRadius, arcRotateCameraTarget, scene);
    camera.attachControl(scene.getEngine().getRenderingCanvas(), true);
    if (!scene.activeCamera) {
      scene.activeCamera = camera;
    }
  };
  const handleCreateUniversalCamera = () => {
    const camera = new UniversalCamera(universalCameraName, universalCameraPosition, scene);
    camera.attachControl(scene.getEngine().getRenderingCanvas(), true);
    if (!scene.activeCamera) {
      scene.activeCamera = camera;
    }
  };
  const handleCreateFreeCamera = () => {
    const camera = new FreeCamera(freeCameraName, freeCameraPosition, scene);
    camera.attachControl(scene.getEngine().getRenderingCanvas(), true);
    if (!scene.activeCamera) {
      scene.activeCamera = camera;
    }
  };
  const handleCreateFollowCamera = () => {
    const camera = new FollowCamera(followCameraName, followCameraPosition, scene);
    camera.radius = followCameraRadius;
    camera.heightOffset = followCameraHeightOffset;
    camera.rotationOffset = followCameraRotationOffset;
    camera.attachControl(true);
    if (!scene.activeCamera) {
      scene.activeCamera = camera;
    }
  };
  const handleCreateFlyCamera = () => {
    const camera = new FlyCamera(flyCameraName, flyCameraPosition, scene);
    camera.attachControl(true);
    if (!scene.activeCamera) {
      scene.activeCamera = camera;
    }
  };
  const handleCreateGeospatialCamera = () => {
    const camera = new GeospatialCamera(geospatialCameraName, scene, { planetRadius: geospatialCameraPlanetRadius });
    camera.attachControl(true);
    if (!scene.activeCamera) {
      scene.activeCamera = camera;
    }
  };
  return (0, import_jsx_runtime.jsxs)(QuickCreateSection, { children: [(0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateArcRotateCamera, label: "ArcRotate Camera" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: arcRotateCameraName, onChange: (value) => setArcRotateCameraName(value) }), (0, import_jsx_runtime.jsx)(Vector3PropertyLine, { label: "Target", value: arcRotateCameraTarget, onChange: (value) => setArcRotateCameraTarget(value) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Radius", value: arcRotateCameraRadius, onChange: (value) => setArcRotateCameraRadius(value), min: 0.1, max: 1e3, step: 0.5 }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: `Alpha ${arcRotateCameraUseRadians ? "(rad)" : "(deg)"}`, value: arcRotateCameraAlpha, onChange: (value) => setArcRotateCameraAlpha(value), min: arcRotateCameraUseRadians ? -Math.PI * 2 : -360, max: arcRotateCameraUseRadians ? Math.PI * 2 : 360, step: arcRotateCameraUseRadians ? 0.1 : 5 }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: `Beta ${arcRotateCameraUseRadians ? "(rad)" : "(deg)"}`, value: arcRotateCameraBeta, onChange: (value) => setArcRotateCameraBeta(value), min: arcRotateCameraUseRadians ? 0 : 0, max: arcRotateCameraUseRadians ? Math.PI : 180, step: arcRotateCameraUseRadians ? 0.1 : 5 }), (0, import_jsx_runtime.jsx)(CheckboxPropertyLine, { label: "Use Radians", value: arcRotateCameraUseRadians, onChange: (value) => setArcRotateCameraUseRadians(value) }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateArcRotateCamera, label: "Create" })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateUniversalCamera, label: "Universal Camera" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: universalCameraName, onChange: (value) => setUniversalCameraName(value) }), (0, import_jsx_runtime.jsx)(Vector3PropertyLine, { label: "Position", value: universalCameraPosition, onChange: (value) => setUniversalCameraPosition(value) }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateUniversalCamera, label: "Create" })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateFreeCamera, label: "Free Camera" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: freeCameraName, onChange: (value) => setFreeCameraName(value) }), (0, import_jsx_runtime.jsx)(Vector3PropertyLine, { label: "Position", value: freeCameraPosition, onChange: (value) => setFreeCameraPosition(value) }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateFreeCamera, label: "Create" })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateFollowCamera, label: "Follow Camera" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: followCameraName, onChange: (value) => setFollowCameraName(value) }), (0, import_jsx_runtime.jsx)(Vector3PropertyLine, { label: "Position", value: followCameraPosition, onChange: (value) => setFollowCameraPosition(value) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Radius", value: followCameraRadius, onChange: (value) => setFollowCameraRadius(value), min: 0.1, max: 1e3, step: 0.5 }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Height Offset", value: followCameraHeightOffset, onChange: (value) => setFollowCameraHeightOffset(value), min: -100, max: 100, step: 0.5 }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Rotation Offset (deg)", value: followCameraRotationOffset, onChange: (value) => setFollowCameraRotationOffset(value), min: -180, max: 180, step: 5 }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateFollowCamera, label: "Create" })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateFlyCamera, label: "Fly Camera" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: flyCameraName, onChange: (value) => setFlyCameraName(value) }), (0, import_jsx_runtime.jsx)(Vector3PropertyLine, { label: "Position", value: flyCameraPosition, onChange: (value) => setFlyCameraPosition(value) }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateFlyCamera, label: "Create" })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateGeospatialCamera, label: "Geospatial Camera" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: geospatialCameraName, onChange: (value) => setGeospatialCameraName(value) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Planet Radius (m)", value: geospatialCameraPlanetRadius, onChange: (value) => setGeospatialCameraPlanetRadius(value), min: 1e3, max: 1e8, step: 1e3 }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateGeospatialCamera, label: "Create" })] })] })] });
};
var ParticlesContent = ({ scene }) => {
  const [cpuParticleSystemName, setCpuParticleSystemName] = (0, import_react.useState)("Particle System");
  const [cpuParticleSystemCapacity, setCpuParticleSystemCapacity] = (0, import_react.useState)(2e3);
  const [gpuParticleSystemName, setGpuParticleSystemName] = (0, import_react.useState)("GPU Particle System");
  const [gpuParticleSystemCapacity, setGpuParticleSystemCapacity] = (0, import_react.useState)(2e3);
  const [nodeParticleSystemName, setNodeParticleSystemName] = (0, import_react.useState)("Node Particle System");
  const [nodeParticleSystemSnippetId, setNodeParticleSystemSnippetId] = (0, import_react.useState)("");
  const handleCreateCPUParticleSystem = () => {
    setTimeout(() => {
      const system = new ParticleSystem(cpuParticleSystemName, cpuParticleSystemCapacity, scene);
      system.particleTexture = new Texture("https://assets.babylonjs.com/textures/flare.png", scene);
      system.start();
    }, 0);
  };
  const handleCreateGPUParticleSystem = () => {
    if (GPUParticleSystem.IsSupported) {
      setTimeout(() => {
        const system = new GPUParticleSystem(gpuParticleSystemName, { capacity: gpuParticleSystemCapacity }, scene);
        system.particleTexture = new Texture("https://assets.babylonjs.com/textures/flare.png", scene);
        system.start();
      }, 0);
    } else {
      alert("GPU Particle System is not supported.");
    }
  };
  const handleCreateNodeParticleSystemAsync = async () => {
    try {
      let nodeParticleSet;
      const snippetId = nodeParticleSystemSnippetId.trim();
      if (snippetId) {
        nodeParticleSet = await NodeParticleSystemSet.ParseFromSnippetAsync(snippetId);
        nodeParticleSet.name = nodeParticleSystemName;
      } else {
        nodeParticleSet = NodeParticleSystemSet.CreateDefault(nodeParticleSystemName);
      }
      const particleSystemSet = await nodeParticleSet.buildAsync(scene);
      for (const system of particleSystemSet.systems) {
        system.name = nodeParticleSystemName;
      }
      particleSystemSet.start();
    } catch (e) {
      global.console.error("Error creating Node Particle System:", e);
      alert("Failed to create Node Particle System: " + e);
    }
  };
  return (0, import_jsx_runtime.jsxs)(QuickCreateSection, { children: [(0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateCPUParticleSystem, label: "CPU Particle System" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: cpuParticleSystemName, onChange: (value) => setCpuParticleSystemName(value) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Capacity", value: cpuParticleSystemCapacity, onChange: (value) => setCpuParticleSystemCapacity(value), min: 1, max: 1e5, step: 100 }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateCPUParticleSystem, label: "Create" })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateGPUParticleSystem, label: "GPU Particle System" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: gpuParticleSystemName, onChange: (value) => setGpuParticleSystemName(value) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Capacity", value: gpuParticleSystemCapacity, onChange: (value) => setGpuParticleSystemCapacity(value), min: 1, max: 1e6, step: 1e3 }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateGPUParticleSystem, label: "Create" })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateNodeParticleSystemAsync, label: "Node Particle System" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: nodeParticleSystemName, onChange: (value) => setNodeParticleSystemName(value) }), (0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Snippet ID", value: nodeParticleSystemSnippetId, onChange: (value) => setNodeParticleSystemSnippetId(value) }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateNodeParticleSystemAsync, label: "Create" })] })] })] });
};
var GetUniquePipelineName = (baseName, scene) => {
  const pipelines = scene.postProcessRenderPipelineManager.supportedPipelines;
  const existingNames = new Set(pipelines.map((p) => p._name));
  if (!existingNames.has(baseName)) {
    return baseName;
  }
  let counter = 1;
  let uniqueName = `${baseName} ${counter}`;
  while (existingNames.has(uniqueName)) {
    counter++;
    uniqueName = `${baseName} ${counter}`;
  }
  return uniqueName;
};
var RenderingPipelinesContent = ({ scene }) => {
  const [defaultPipelineName, setDefaultPipelineName] = (0, import_react.useState)("Default rendering pipeline");
  const [ssaoPipelineName, setSsaoPipelineName] = (0, import_react.useState)("SSAO rendering pipeline");
  const [ssao2PipelineName, setSsao2PipelineName] = (0, import_react.useState)("SSAO2 rendering pipeline");
  const [ssrPipelineName, setSsrPipelineName] = (0, import_react.useState)("SSR rendering pipeline");
  const [iblShadowsPipelineName, setIblShadowsPipelineName] = (0, import_react.useState)("IBL Shadows rendering pipeline");
  const handleCreateDefaultPipeline = () => {
    const name = GetUniquePipelineName(defaultPipelineName, scene);
    new DefaultRenderingPipeline(name, true, scene, scene.cameras);
  };
  const handleCreateSSAOPipeline = () => {
    const name = GetUniquePipelineName(ssaoPipelineName, scene);
    new SSAORenderingPipeline(name, scene, 1, scene.cameras);
  };
  const handleCreateSSAO2Pipeline = () => {
    const name = GetUniquePipelineName(ssao2PipelineName, scene);
    new SSAO2RenderingPipeline(name, scene, 1, scene.cameras);
  };
  const handleCreateSSRPipeline = () => {
    const name = GetUniquePipelineName(ssrPipelineName, scene);
    new SSRRenderingPipeline(name, scene, scene.cameras);
  };
  const handleCreateIBLShadowsPipeline = () => {
    const name = GetUniquePipelineName(iblShadowsPipelineName, scene);
    new IblShadowsRenderPipeline(name, scene, {}, scene.cameras);
  };
  const caps = scene.getEngine().getCaps();
  const hasDrawBuffers = caps.drawBuffersExtension;
  const hasTexelFetch = caps.texelFetch;
  const camera = useProperty(scene, "activeCamera");
  return (0, import_jsx_runtime.jsx)(QuickCreateSection, { children: !camera ? (0, import_jsx_runtime.jsx)(MessageBar, { message: "Cannot create rendering pipeline without an active camera.", title: "No active camera", intent: "info" }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateDefaultPipeline, label: "Default Pipeline" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: defaultPipelineName, onChange: (value) => setDefaultPipelineName(value) }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateDefaultPipeline, label: "Create" })] })] }), (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateSSAOPipeline, label: "SSAO Pipeline" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: ssaoPipelineName, onChange: (value) => setSsaoPipelineName(value) }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateSSAOPipeline, label: "Create" })] })] }), hasDrawBuffers && (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateSSAO2Pipeline, label: "SSAO2 Pipeline" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: ssao2PipelineName, onChange: (value) => setSsao2PipelineName(value) }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateSSAO2Pipeline, label: "Create" })] })] }), hasDrawBuffers && hasTexelFetch && (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateSSRPipeline, label: "SSR Pipeline" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: ssrPipelineName, onChange: (value) => setSsrPipelineName(value) }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateSSRPipeline, label: "Create" })] })] }), hasDrawBuffers && hasTexelFetch && (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateIBLShadowsPipeline, label: "IBL Shadows Pipeline" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: iblShadowsPipelineName, onChange: (value) => setIblShadowsPipelineName(value) }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateIBLShadowsPipeline, label: "Create" })] })] })] }) });
};
function GetUniqueName(baseName, scene) {
  let name = baseName;
  let idSubscript = 1;
  while (scene.getFrameGraphByName(name)) {
    name = baseName + " " + idSubscript++;
  }
  return name;
}
var FrameGraphsContent = ({ scene }) => {
  const [frameGraphName, setFrameGraphName] = (0, import_react.useState)("Frame Graph");
  const handleCreateFrameGraph = () => {
    const uniqueName = GetUniqueName(frameGraphName, scene);
    const newNodeRenderGraph = new NodeRenderGraph(uniqueName, scene);
    newNodeRenderGraph.setToDefault();
    void newNodeRenderGraph.buildAsync();
  };
  return (0, import_jsx_runtime.jsx)(QuickCreateSection, { children: (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateFrameGraph, label: "Frame Graph" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: frameGraphName, onChange: (value) => setFrameGraphName(value) }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateFrameGraph, label: "Create" })] })] }) });
};
var SpriteManagersContent = ({ scene }) => {
  const [spriteManagerName, setSpriteManagerName] = (0, import_react.useState)("Sprite Manager");
  const [spriteManagerCapacity, setSpriteManagerCapacity] = (0, import_react.useState)(500);
  const [spriteManagerCellSize, setSpriteManagerCellSize] = (0, import_react.useState)(64);
  const [spriteManagerTextureUrl, setSpriteManagerTextureUrl] = (0, import_react.useState)("https://assets.babylonjs.com/textures/player.png");
  const handleCreateSpriteManager = () => {
    new SpriteManager(spriteManagerName, spriteManagerTextureUrl, spriteManagerCapacity, spriteManagerCellSize, scene);
  };
  return (0, import_jsx_runtime.jsx)(QuickCreateSection, { children: (0, import_jsx_runtime.jsxs)(QuickCreateRow, { children: [(0, import_jsx_runtime.jsx)(Button, { onClick: handleCreateSpriteManager, label: "Sprite Manager" }), (0, import_jsx_runtime.jsxs)(SettingsPopover, { children: [(0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Name", value: spriteManagerName, onChange: (value) => setSpriteManagerName(value) }), (0, import_jsx_runtime.jsx)(TextInputPropertyLine, { label: "Texture URL", value: spriteManagerTextureUrl, onChange: (value) => setSpriteManagerTextureUrl(value) }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Capacity", value: spriteManagerCapacity, onChange: (value) => setSpriteManagerCapacity(value), min: 1, max: 1e4, step: 100 }), (0, import_jsx_runtime.jsx)(SpinButtonPropertyLine, { label: "Cell Size", value: spriteManagerCellSize, onChange: (value) => setSpriteManagerCellSize(value), min: 1, max: 1024, step: 1 }), (0, import_jsx_runtime.jsx)(Button, { appearance: "primary", onClick: handleCreateSpriteManager, label: "Create" })] })] }) });
};
var CreateToolsServiceDefinition = {
  friendlyName: "Creation Tools",
  consumes: [ShellServiceIdentity, SceneContextIdentity],
  factory: (shellService, sceneContext) => {
    const registration = shellService.addSidePane({
      key: "Create",
      title: "Creation Tools",
      icon: CollectionsAdd20Regular,
      horizontalLocation: "left",
      verticalLocation: "top",
      content: () => {
        const scene = useObservableState(() => sceneContext.currentScene, sceneContext.currentSceneObservable);
        return scene && (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsxs)(Accordion, { children: [(0, import_jsx_runtime.jsx)(AccordionSection, { title: "Meshes", children: (0, import_jsx_runtime.jsx)(MeshesContent, { scene }) }), (0, import_jsx_runtime.jsx)(AccordionSection, { title: "Materials", children: (0, import_jsx_runtime.jsx)(MaterialsContent, { scene }) }), (0, import_jsx_runtime.jsx)(AccordionSection, { title: "Lights", children: (0, import_jsx_runtime.jsx)(LightsContent, { scene }) }), (0, import_jsx_runtime.jsx)(AccordionSection, { title: "Particles", children: (0, import_jsx_runtime.jsx)(ParticlesContent, { scene }) }), (0, import_jsx_runtime.jsx)(AccordionSection, { title: "Cameras", children: (0, import_jsx_runtime.jsx)(CamerasContent, { scene }) }), (0, import_jsx_runtime.jsx)(AccordionSection, { title: "Rendering Pipelines", children: (0, import_jsx_runtime.jsx)(RenderingPipelinesContent, { scene }) }), (0, import_jsx_runtime.jsx)(AccordionSection, { title: "Frame Graphs", children: (0, import_jsx_runtime.jsx)(FrameGraphsContent, { scene }) }), (0, import_jsx_runtime.jsx)(AccordionSection, { title: "Sprite Managers", children: (0, import_jsx_runtime.jsx)(SpriteManagersContent, { scene }) })] }) });
      }
    });
    return {
      dispose: () => registration.dispose()
    };
  }
};
var quickCreateToolsService = {
  serviceDefinitions: [CreateToolsServiceDefinition]
};
export {
  CreateToolsServiceDefinition,
  quickCreateToolsService as default
};
//# sourceMappingURL=quickCreateToolsService-B55TQEXK-HD2OOLZO.js.map
