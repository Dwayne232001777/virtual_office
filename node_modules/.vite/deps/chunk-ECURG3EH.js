import {
  getNumericValue,
  init_utils
} from "./chunk-JZELQRBK.js";
import {
  FlowGraphExecutionBlockWithOutSignal,
  init_flowGraphExecutionBlockWithOutSignal
} from "./chunk-HBEO6KQN.js";
import {
  RichTypeFlowGraphInteger,
  init_flowGraphRichTypes
} from "./chunk-WADD4RBF.js";
import {
  RegisterClass,
  init_typeStore
} from "./chunk-7ANHXSNA.js";
import {
  __esm
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/ControlFlow/flowGraphCancelDelayBlock.js
var FlowGraphCancelDelayBlock;
var init_flowGraphCancelDelayBlock = __esm({
  "node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/ControlFlow/flowGraphCancelDelayBlock.js"() {
    init_typeStore();
    init_flowGraphExecutionBlockWithOutSignal();
    init_flowGraphRichTypes();
    init_utils();
    FlowGraphCancelDelayBlock = class extends FlowGraphExecutionBlockWithOutSignal {
      constructor(config) {
        super(config);
        this.delayIndex = this.registerDataInput("delayIndex", RichTypeFlowGraphInteger);
      }
      _execute(context, _callingSignal) {
        const delayIndex = getNumericValue(this.delayIndex.getValue(context));
        if (delayIndex <= 0 || isNaN(delayIndex) || !isFinite(delayIndex)) {
          return this._reportError(context, "Invalid delay index");
        }
        const timers = context._getGlobalContextVariable("pendingDelays", []);
        const timer = timers[delayIndex];
        if (timer) {
          timer.dispose();
        }
        this.out._activateSignal(context);
      }
      getClassName() {
        return "FlowGraphCancelDelayBlock";
      }
    };
    RegisterClass("FlowGraphCancelDelayBlock", FlowGraphCancelDelayBlock);
  }
});

export {
  FlowGraphCancelDelayBlock,
  init_flowGraphCancelDelayBlock
};
//# sourceMappingURL=chunk-ECURG3EH.js.map
