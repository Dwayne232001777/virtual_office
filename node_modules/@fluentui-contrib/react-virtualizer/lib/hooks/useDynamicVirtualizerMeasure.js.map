{"version":3,"sources":["../../../../../packages/react-virtualizer/src/hooks/useDynamicVirtualizerMeasure.ts"],"sourcesContent":["import {\n  useIsomorphicLayoutEffect,\n  useMergedRefs,\n} from '@fluentui/react-utilities';\nimport * as React from 'react';\nimport { VirtualizerMeasureDynamicProps } from './hooks.types';\nimport { useResizeObserverRef_unstable } from './useResizeObserverRef';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\n\n/**\n * React hook that measures virtualized space dynamically to ensure optimized virtualization length.\n */\nexport const useDynamicVirtualizerMeasure = <TElement extends HTMLElement>(\n  virtualizerProps: VirtualizerMeasureDynamicProps\n): {\n  virtualizerLength: number;\n  bufferItems: number;\n  bufferSize: number;\n  scrollRef: (instance: TElement | null) => void;\n  containerSizeRef: React.RefObject<number>;\n  updateScrollPosition: (scrollPosition: number) => void;\n} => {\n  const {\n    defaultItemSize,\n    direction = 'vertical',\n    numItems,\n    getItemSize,\n    bufferItems,\n    bufferSize,\n    virtualizerContext,\n    gap = 0,\n  } = virtualizerProps;\n\n  const [virtualizerLength, setVirtualizerLength] = React.useState(0);\n  const [virtualizerBufferItems, setVirtualizerBufferItems] = React.useState(0);\n  const [virtualizerBufferSize, setVirtualizerBufferSize] = React.useState(0);\n\n  const scrollPosition = React.useRef(0);\n  const numItemsRef = React.useRef<number>(numItems);\n  const containerSizeRef = React.useRef<number>(0);\n\n  const { targetDocument } = useFluent();\n  const container = React.useRef<HTMLElement | null>(null);\n\n  const handleScrollResize = React.useCallback(\n    (scrollRef: React.MutableRefObject<HTMLElement | null>) => {\n      const hasReachedEnd =\n        virtualizerContext.contextIndex + virtualizerLength >= numItems;\n\n      // Track whether this update was driven by a change in numItems\n      const numItemsChanged = numItemsRef.current !== numItems;\n      numItemsRef.current = numItems;\n\n      if (!scrollRef?.current || (hasReachedEnd && !numItemsChanged)) {\n        return;\n      }\n\n      if (scrollRef.current !== targetDocument?.body) {\n        // We have a local scroll container\n        containerSizeRef.current =\n          direction === 'vertical'\n            ? scrollRef?.current.getBoundingClientRect().height\n            : scrollRef?.current.getBoundingClientRect().width;\n      } else if (targetDocument?.defaultView) {\n        // If our scroll ref is the document body, we should check window height\n        containerSizeRef.current =\n          direction === 'vertical'\n            ? targetDocument?.defaultView?.innerHeight\n            : targetDocument?.defaultView?.innerWidth;\n      }\n\n      const _actualScrollPos =\n        direction === 'vertical'\n          ? scrollRef.current.scrollTop\n          : scrollRef.current.scrollLeft;\n\n      /* If the numItems changed, we're going to calc\n       * a new index based on actual scroll position\n       */\n      const actualScrollPos = numItemsChanged\n        ? _actualScrollPos\n        : scrollPosition.current;\n\n      const sizeToBeat = containerSizeRef.current + virtualizerBufferSize * 2;\n      const startIndex = Math.max(virtualizerContext.contextIndex, 0);\n\n      let indexSizer = 0;\n      let i = 0;\n      let length = 0;\n      let indexMod = 0;\n\n      let currentItemPos =\n        startIndex > 0\n          ? virtualizerContext.childProgressiveSizes.current[startIndex - 1]\n          : 0;\n\n      while (indexSizer <= sizeToBeat && i < numItems - startIndex) {\n        const iItemSize = getItemSize(startIndex + i) + gap;\n        if (actualScrollPos > currentItemPos + iItemSize) {\n          // The item isn't in view, we'll update index to skip it.\n          i++;\n          indexMod++;\n          currentItemPos += iItemSize;\n          continue;\n        } else if (actualScrollPos > currentItemPos) {\n          // The item is partially out of view, ignore the out of bounds portion\n          const variance = currentItemPos + iItemSize - actualScrollPos;\n          indexSizer += variance;\n        } else {\n          // Item is in view\n          indexSizer += iItemSize;\n        }\n        // Increment\n        i++;\n        length++;\n        currentItemPos += iItemSize;\n      }\n\n      /*\n       * Number of items to append at each end, i.e. 'preload' each side before entering view.\n       * Minimum: 2 - we give slightly more buffer for dynamic version.\n       */\n      const newBufferItems = bufferItems ?? Math.max(Math.ceil(length / 3), 1);\n\n      /*\n       * This is how far we deviate into the bufferItems to detect a redraw.\n       */\n      const newBufferSize = bufferSize ?? Math.max(defaultItemSize / 2, 1);\n      const totalLength = length + newBufferItems * 2;\n\n      if (numItemsChanged && indexMod - newBufferItems > 0) {\n        // Virtualizer will recalculate on numItems change, but from the old index\n        // We should get ahead of that update to prevent unnessecary recalculations\n        virtualizerContext.setContextIndex(\n          startIndex + indexMod - newBufferItems\n        );\n      }\n\n      scrollPosition.current = actualScrollPos;\n      setVirtualizerLength(totalLength);\n      setVirtualizerBufferItems(newBufferItems);\n      setVirtualizerBufferSize(newBufferSize);\n    },\n    [\n      bufferItems,\n      bufferSize,\n      defaultItemSize,\n      direction,\n      numItems,\n      targetDocument?.body,\n      targetDocument?.defaultView,\n      virtualizerBufferSize,\n      virtualizerContext.childProgressiveSizes,\n      virtualizerContext.contextIndex,\n      virtualizerLength,\n    ]\n  );\n\n  const resizeCallback = React.useCallback(\n    (\n      _entries: ResizeObserverEntry[],\n      // TODO: exclude types from this lint rule: https://github.com/microsoft/fluentui/issues/31286\n      // eslint-disable-next-line no-restricted-globals\n      _observer: ResizeObserver,\n      scrollRef?: React.MutableRefObject<HTMLElement | null>\n    ) => {\n      if (scrollRef) {\n        handleScrollResize(scrollRef);\n      }\n    },\n    [handleScrollResize]\n  );\n\n  React.useEffect(() => {\n    // Track numItems changes (consumed in handleScrollResize)\n    numItemsRef.current = numItems;\n  }, [numItems]);\n\n  const scrollRef = useMergedRefs(\n    container,\n    useResizeObserverRef_unstable(resizeCallback)\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (virtualizerContext.contextIndex + virtualizerLength < numItems) {\n      // Avoid re-rendering/re-calculating when the end index has already been reached\n      handleScrollResize(container);\n    }\n  }, [\n    handleScrollResize,\n    numItems,\n    virtualizerContext.contextIndex,\n    virtualizerLength,\n  ]);\n\n  const updateScrollPosition = React.useCallback(\n    (_scrollPosition: number) => {\n      scrollPosition.current = _scrollPosition;\n      handleScrollResize(scrollRef);\n    },\n    [handleScrollResize, scrollRef]\n  );\n\n  return {\n    virtualizerLength,\n    bufferItems: virtualizerBufferItems,\n    bufferSize: virtualizerBufferSize,\n    scrollRef,\n    containerSizeRef,\n    updateScrollPosition,\n  };\n};\n"],"names":["useIsomorphicLayoutEffect","useMergedRefs","React","useResizeObserverRef_unstable","useFluent_unstable","useFluent","useDynamicVirtualizerMeasure","virtualizerProps","defaultItemSize","direction","numItems","getItemSize","bufferItems","bufferSize","virtualizerContext","gap","virtualizerLength","setVirtualizerLength","useState","virtualizerBufferItems","setVirtualizerBufferItems","virtualizerBufferSize","setVirtualizerBufferSize","scrollPosition","useRef","numItemsRef","containerSizeRef","targetDocument","container","handleScrollResize","useCallback","scrollRef","hasReachedEnd","contextIndex","numItemsChanged","current","body","getBoundingClientRect","height","width","defaultView","innerHeight","innerWidth","_actualScrollPos","scrollTop","scrollLeft","actualScrollPos","sizeToBeat","startIndex","Math","max","indexSizer","i","length","indexMod","currentItemPos","childProgressiveSizes","iItemSize","variance","newBufferItems","ceil","newBufferSize","totalLength","setContextIndex","resizeCallback","_entries","_observer","useEffect","updateScrollPosition","_scrollPosition"],"mappings":"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"}