{"version":3,"sources":["../../../../../../packages/react-virtualizer/src/components/Virtualizer/useVirtualizer.ts"],"sourcesContent":["import * as React from 'react';\nimport type { VirtualizerProps, VirtualizerState } from './Virtualizer.types';\n\nimport { useIntersectionObserver } from '../../hooks/useIntersectionObserver';\nimport { useVirtualizerContextState_unstable } from '../../Utilities';\nimport { slot, useTimeout } from '@fluentui/react-utilities';\nimport { flushSync } from 'react-dom';\n\nexport function useVirtualizer_unstable(\n  props: VirtualizerProps\n): VirtualizerState {\n  'use no memo';\n\n  const {\n    itemSize,\n    numItems,\n    virtualizerLength,\n    children: renderChild,\n    getItemSize,\n    bufferItems = Math.round(virtualizerLength / 4.0),\n    bufferSize = Math.floor(bufferItems / 2.0) * itemSize,\n    axis = 'vertical',\n    reversed = false,\n    virtualizerContext,\n    onRenderedFlaggedIndex,\n    imperativeVirtualizerRef,\n    containerSizeRef,\n    scrollViewRef,\n    enableScrollLoad,\n    updateScrollPosition,\n    gap = 0,\n  } = props;\n\n  /* The context is optional, it's useful for injecting additional index logic, or performing uniform state updates*/\n  const _virtualizerContext =\n    useVirtualizerContextState_unstable(virtualizerContext);\n\n  // We use this ref as a constant source to access the virtualizer's state imperatively\n  const actualIndexRef = React.useRef<number>(_virtualizerContext.contextIndex);\n\n  // The internal tracking REF for child array (updates often).\n  const childArray = React.useRef<React.ReactNode[]>(\n    new Array(virtualizerLength)\n  );\n\n  const flaggedIndex = React.useRef<number | null>(null);\n  const actualIndex = _virtualizerContext.contextIndex;\n\n  // Initialize the size array before first render.\n  const hasInitialized = React.useRef<boolean>(false);\n  const isFullyInitialized = hasInitialized.current && actualIndex >= 0;\n\n  // Just in case our ref gets out of date vs the context during a re-render\n  if (_virtualizerContext.contextIndex !== actualIndexRef.current) {\n    actualIndexRef.current = _virtualizerContext.contextIndex;\n  }\n\n  React.useEffect(() => {\n    populateSizeArrays();\n  }, [numItems]);\n\n  const setActualIndex = React.useCallback(\n    (index: number) => {\n      actualIndexRef.current = index;\n      _virtualizerContext.setContextIndex(index);\n    },\n    [_virtualizerContext]\n  );\n\n  // Store ref to before padding element\n  const beforeElementRef = React.useRef<HTMLElement | null>(null);\n\n  // Store ref to before padding element\n  const afterElementRef = React.useRef<HTMLElement | null>(null);\n\n  // We need to store an array to track dynamic sizes, we can use this to incrementally update changes\n  const childSizes = React.useRef<number[]>(\n    new Array<number>(getItemSize ? numItems : 0)\n  );\n\n  /* We keep track of the progressive sizing/placement down the list,\n  this helps us skip re-calculations unless children/size changes */\n  const childProgressiveSizes = React.useRef<number[]>(\n    new Array<number>(getItemSize ? numItems : 0)\n  );\n  if (virtualizerContext?.childProgressiveSizes) {\n    virtualizerContext.childProgressiveSizes.current =\n      childProgressiveSizes.current;\n  }\n\n  const populateSizeArrays = React.useCallback(() => {\n    if (!getItemSize) {\n      // Static sizes, never mind!\n      return;\n    }\n\n    if (numItems !== childSizes.current.length) {\n      childSizes.current = new Array<number>(numItems);\n    }\n\n    if (numItems !== childProgressiveSizes.current.length) {\n      // Item added/removed could have been from anywhere in array, reset all.\n      childProgressiveSizes.current = new Array<number>(numItems);\n    }\n\n    for (let index = 0; index < numItems; index++) {\n      const _gap = index < numItems - 1 ? gap : 0;\n      childSizes.current[index] = getItemSize(index) + _gap;\n      if (index === 0) {\n        childProgressiveSizes.current[index] = childSizes.current[index];\n      } else {\n        childProgressiveSizes.current[index] =\n          childProgressiveSizes.current[index - 1] + childSizes.current[index];\n      }\n    }\n\n    if (virtualizerContext?.childProgressiveSizes) {\n      virtualizerContext.childProgressiveSizes.current =\n        childProgressiveSizes.current;\n    }\n  }, [numItems, gap]);\n\n  const [isScrolling, setIsScrolling] = React.useState<boolean>(false);\n  const [setScrollTimer, clearScrollTimer] = useTimeout();\n  const scrollCounter = React.useRef<number>(0);\n\n  const initializeScrollingTimer = React.useCallback(() => {\n    if (!enableScrollLoad) {\n      // Disabled by default for reduction of render callbacks\n      setIsScrolling(false);\n      clearScrollTimer();\n      return;\n    }\n    /*\n     * This can be considered the 'velocity' required to start 'isScrolling'\n     * INIT_SCROLL_FLAG_REQ: Number of renders required to activate isScrolling\n     * INIT_SCROLL_FLAG_DELAY: Amount of time (ms) before current number of renders is reset\n     *  - Maybe we should let users customize these in the future.\n     */\n    const INIT_SCROLL_FLAG_REQ = 10;\n    const INIT_SCROLL_FLAG_DELAY = 100;\n\n    scrollCounter.current++;\n    if (scrollCounter.current >= INIT_SCROLL_FLAG_REQ) {\n      setIsScrolling(true);\n    }\n    clearScrollTimer();\n    setScrollTimer(() => {\n      updateChildArray(false);\n      setIsScrolling(false);\n      scrollCounter.current = 0;\n    }, INIT_SCROLL_FLAG_DELAY);\n  }, [clearScrollTimer, setScrollTimer, enableScrollLoad]);\n\n  React.useEffect(() => {\n    initializeScrollingTimer();\n  }, [actualIndex, initializeScrollingTimer]);\n\n  const renderChildRows = React.useCallback(\n    (_newIndex: number) => {\n      if (numItems === 0) {\n        /* Nothing to virtualize */\n        return [];\n      }\n      const newIndex = Math.max(_newIndex, 0);\n      const arrayLength = Math.min(virtualizerLength, numItems - newIndex);\n\n      // Always create fresh React elements to prevent key reconciliation issues\n      // when items order changes or when re-rendering is needed.\n      // Creating React elements is cheap (just object creation), and React's\n      // reconciliation with proper keys is very efficient.\n      // See: https://github.com/microsoft/fluentui-contrib/issues/526\n      const newChildArray = new Array(arrayLength);\n      for (let i = 0; i < arrayLength; i++) {\n        newChildArray[i] = renderChild(newIndex + i, isScrolling);\n      }\n\n      return newChildArray;\n    },\n    [isScrolling, numItems, renderChild, virtualizerLength]\n  );\n\n  const updateChildArray = (_isScrolling: boolean) => {\n    // Render child changed, regenerate the child array\n    const startIndex = Math.max(actualIndex, 0);\n    const arrayLength = Math.min(\n      virtualizerLength,\n      Math.max(0, numItems - startIndex)\n    );\n    const newChildArray = new Array(arrayLength);\n    for (let i = 0; i < arrayLength; i++) {\n      newChildArray[i] = renderChild(startIndex + i, _isScrolling);\n    }\n    childArray.current = newChildArray;\n  };\n\n  React.useEffect(() => {\n    updateChildArray(isScrolling);\n  }, [renderChild, isScrolling]);\n\n  const updateCurrentItemSizes = React.useCallback(\n    (newIndex: number) => {\n      if (!getItemSize) {\n        // Static sizes, not required.\n        return;\n      }\n      // We should always call our size function on index change (only for the items that will be rendered)\n      // This ensures we request the latest data for incoming items in case sizing has changed.\n      const endIndex = Math.min(newIndex + virtualizerLength, numItems);\n      const startIndex = Math.max(newIndex, 0);\n\n      let didUpdate = false;\n      for (let i = startIndex; i < endIndex; i++) {\n        const _gap = i < numItems - 1 ? gap : 0;\n        const newSize = getItemSize(i) + _gap;\n        if (newSize !== childSizes.current[i]) {\n          childSizes.current[i] = newSize;\n          didUpdate = true;\n        }\n      }\n\n      if (didUpdate) {\n        // Update our progressive size array\n        for (let i = startIndex; i < numItems; i++) {\n          const prevSize = i > 0 ? childProgressiveSizes.current[i - 1] : 0;\n          childProgressiveSizes.current[i] = prevSize + childSizes.current[i];\n        }\n      }\n    },\n    [numItems, virtualizerLength, gap]\n  );\n\n  const batchUpdateNewIndex = React.useCallback(\n    (index: number) => {\n      // Local updates\n      updateCurrentItemSizes(index);\n      // State setters\n      setActualIndex(index);\n    },\n    [setActualIndex, updateCurrentItemSizes]\n  );\n\n  const findIndexRecursive = React.useCallback(\n    (scrollPos: number, lowIndex: number, highIndex: number): number => {\n      if (lowIndex > highIndex) {\n        // We shouldn't get here - but no-op the index if we do.\n        return actualIndex;\n      }\n      const midpoint = Math.floor((lowIndex + highIndex) / 2);\n      const iBefore = Math.max(midpoint - 1, 0);\n      const iAfter = Math.min(\n        midpoint + 1,\n        childProgressiveSizes.current.length - 1\n      );\n      const indexValue = childProgressiveSizes.current[midpoint];\n      const afterIndexValue = childProgressiveSizes.current[iAfter];\n      const beforeIndexValue = childProgressiveSizes.current[iBefore];\n      if (scrollPos <= afterIndexValue && scrollPos >= beforeIndexValue) {\n        /* We've found our index - if we are exactly matching before/after index that's ok,\n      better to reduce checks if it's right on the boundary. */\n        return midpoint;\n      }\n\n      if (indexValue > scrollPos) {\n        return findIndexRecursive(scrollPos, lowIndex, midpoint - 1);\n      } else {\n        return findIndexRecursive(scrollPos, midpoint + 1, highIndex);\n      }\n    },\n    [actualIndex]\n  );\n\n  const getIndexFromSizeArray = React.useCallback(\n    (scrollPos: number): number => {\n      /* Quick searches our progressive height array */\n      if (\n        scrollPos === 0 ||\n        childProgressiveSizes.current.length === 0 ||\n        scrollPos <= childProgressiveSizes.current[0]\n      ) {\n        // Check start\n        return 0;\n      }\n\n      if (\n        scrollPos >=\n        childProgressiveSizes.current[childProgressiveSizes.current.length - 1]\n      ) {\n        // Check end\n        return childProgressiveSizes.current.length - 1;\n      }\n\n      return findIndexRecursive(\n        scrollPos,\n        0,\n        childProgressiveSizes.current.length - 1\n      );\n    },\n    [findIndexRecursive]\n  );\n  const getIndexFromScrollPosition = React.useCallback(\n    (scrollPos: number) => {\n      if (!getItemSize) {\n        return Math.round(scrollPos / (itemSize + gap));\n      }\n\n      return getIndexFromSizeArray(scrollPos);\n    },\n    [getIndexFromSizeArray, itemSize, gap]\n  );\n\n  const calculateTotalSize = React.useCallback(() => {\n    if (!getItemSize) {\n      return (itemSize + gap) * numItems;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[numItems - 1];\n  }, [itemSize, numItems, gap]);\n\n  const calculateBefore = React.useCallback(() => {\n    const currentIndex = Math.min(actualIndex, numItems - 1);\n    if (!getItemSize) {\n      // The missing items from before virtualization starts height\n      return currentIndex * (itemSize + gap);\n    }\n\n    if (currentIndex <= 0) {\n      return 0;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[currentIndex - 1];\n  }, [actualIndex, itemSize, numItems, gap]);\n\n  const calculateAfter = React.useCallback(() => {\n    if (numItems === 0 || actualIndex + virtualizerLength >= numItems) {\n      return 0;\n    }\n\n    const lastItemIndex = Math.min(actualIndex + virtualizerLength, numItems);\n    if (!getItemSize) {\n      // The missing items from after virtualization ends height\n      const remainingItems = numItems - lastItemIndex;\n      return remainingItems * (itemSize + gap) - gap;\n    }\n\n    // Time for custom size calcs\n    return (\n      childProgressiveSizes.current[numItems - 1] -\n      childProgressiveSizes.current[lastItemIndex - 1]\n    );\n  }, [actualIndex, itemSize, numItems, virtualizerLength, gap]);\n\n  // We store the number of items since last render, we will allow an update if the number of items changes\n  const previousNumItems = React.useRef<number>(numItems);\n  // Observe intersections of virtualized components\n  const { setObserverList } = useIntersectionObserver(\n    React.useCallback(\n      // TODO: exclude types from this lint rule: https://github.com/microsoft/fluentui/issues/31286\n      (\n        entries: IntersectionObserverEntry[],\n        // eslint-disable-next-line no-restricted-globals, @typescript-eslint/no-unused-vars\n        _observer: IntersectionObserver\n      ) => {\n        /* Sanity check - do we even need virtualization? */\n        if (virtualizerLength > numItems) {\n          if (actualIndex !== 0) {\n            batchUpdateNewIndex(0);\n          }\n          // No-op\n          return;\n        }\n\n        if (entries.length === 0) {\n          // No entries found, return.\n          return;\n        }\n        // Find the latest entry that is intersecting\n        const sortedEntries = entries.sort(\n          (entry1, entry2) => entry2.time - entry1.time\n        );\n        const latestEntry = sortedEntries.find((entry) => {\n          return entry.isIntersecting;\n        });\n\n        if (!latestEntry) {\n          return;\n        }\n\n        // We have to be sure our item sizes are up to date with current indexed ref before calculation\n        // Check if we still need\n        updateCurrentItemSizes(actualIndexRef.current);\n\n        const calculateOverBuffer = (): number => {\n          /**\n           * We avoid using the scroll ref scrollTop, it may be incorrect\n           * as virtualization may exist within a scroll view with other elements\n           * The benefit of using IO is that we can detect relative scrolls,\n           * so any items can be placed around the virtualizer in the scroll view\n           */\n          let measurementPos = 0;\n          if (latestEntry.target === afterElementRef.current) {\n            // Get after buffers position\n            measurementPos = calculateTotalSize() - calculateAfter();\n\n            // Get exact intersection position based on overflow size (how far into IO did we scroll?)\n            const overflowAmount =\n              axis === 'vertical'\n                ? latestEntry.intersectionRect.height\n                : latestEntry.intersectionRect.width;\n            // Add to original after position\n            measurementPos += overflowAmount;\n            // Ignore buffer size (IO offset)\n            measurementPos -= bufferSize;\n            // we hit the after buffer and detected the end of view, we need to find the start index.\n            measurementPos -= containerSizeRef.current ?? 0;\n\n            // Calculate how far past the window bounds we are (this will be zero if IO is within window)\n            const hOverflow =\n              latestEntry.boundingClientRect.top -\n              latestEntry.intersectionRect.top;\n            const hOverflowReversed =\n              latestEntry.boundingClientRect.bottom -\n              latestEntry.intersectionRect.bottom;\n            const wOverflow =\n              latestEntry.boundingClientRect.left -\n              latestEntry.intersectionRect.left;\n            const wOverflowReversed =\n              latestEntry.boundingClientRect.right -\n              latestEntry.intersectionRect.right;\n            const widthOverflow = reversed ? wOverflowReversed : wOverflow;\n            const heightOverflow = reversed ? hOverflowReversed : hOverflow;\n            const additionalOverflow =\n              axis === 'vertical' ? heightOverflow : widthOverflow;\n\n            if (reversed) {\n              measurementPos += additionalOverflow;\n            } else {\n              measurementPos -= additionalOverflow;\n            }\n          } else if (latestEntry.target === beforeElementRef.current) {\n            // Get before buffers position\n            measurementPos = calculateBefore();\n\n            // Get exact intersection position based on overflow size (how far into window did we scroll IO?)\n            const overflowAmount =\n              axis === 'vertical'\n                ? latestEntry.intersectionRect.height\n                : latestEntry.intersectionRect.width;\n\n            // Minus from original before position\n            measurementPos -= overflowAmount;\n            // Ignore buffer size (IO offset)\n            measurementPos -= bufferSize;\n            // Calculate how far past the window bounds we are (this will be zero if IO is within window)\n            const hOverflow =\n              latestEntry.boundingClientRect.bottom -\n              latestEntry.intersectionRect.bottom;\n            const hOverflowReversed =\n              latestEntry.boundingClientRect.top -\n              latestEntry.intersectionRect.top;\n            const wOverflow =\n              latestEntry.boundingClientRect.right -\n              latestEntry.intersectionRect.right;\n            const wOverflowReversed =\n              latestEntry.boundingClientRect.left -\n              latestEntry.intersectionRect.left;\n            const widthOverflow = reversed ? wOverflowReversed : wOverflow;\n            const heightOverflow = reversed ? hOverflowReversed : hOverflow;\n            const additionalOverflow =\n              axis === 'vertical' ? heightOverflow : widthOverflow;\n\n            if (reversed) {\n              measurementPos += additionalOverflow;\n            } else {\n              measurementPos -= additionalOverflow;\n            }\n          }\n\n          return measurementPos;\n        };\n\n        // Get exact relative 'scrollTop' via IO values\n        const measurementPos = calculateOverBuffer();\n        updateScrollPosition?.(measurementPos);\n\n        const maxIndex = Math.max(\n          numItems + bufferItems - virtualizerLength,\n          0\n        );\n\n        const startIndex =\n          getIndexFromScrollPosition(measurementPos) - bufferItems;\n\n        // Safety limits\n        const newStartIndex = Math.min(Math.max(startIndex, 0), maxIndex);\n        flushSync(() => {\n          // When the number of items change, we DO want to recalc even if at end of list\n          const numItemsChanged = previousNumItems.current !== numItems;\n          previousNumItems.current = numItems;\n          if (\n            newStartIndex + virtualizerLength >= numItems &&\n            actualIndex + virtualizerLength >= numItems &&\n            !numItemsChanged\n          ) {\n            // We've already hit the end, no need to update state.\n            return;\n          }\n          if (actualIndex !== newStartIndex) {\n            batchUpdateNewIndex(newStartIndex);\n          }\n        });\n      },\n      [\n        actualIndex,\n        virtualizerLength,\n        axis,\n        reversed,\n        numItems,\n        bufferSize,\n        bufferItems,\n        containerSizeRef,\n        updateScrollPosition,\n        batchUpdateNewIndex,\n        calculateAfter,\n        calculateBefore,\n        calculateTotalSize,\n        getIndexFromScrollPosition,\n        updateCurrentItemSizes,\n      ]\n    ),\n    {\n      root: scrollViewRef ? scrollViewRef?.current : null,\n      rootMargin: '0px',\n      threshold: 0,\n    }\n  );\n\n  const setBeforeRef = React.useCallback(\n    (element: HTMLDivElement) => {\n      if (!element || beforeElementRef.current === element) {\n        return;\n      }\n      beforeElementRef.current = element;\n      const newList = [];\n\n      newList.push(beforeElementRef.current);\n\n      if (afterElementRef.current) {\n        newList.push(afterElementRef.current);\n      }\n\n      // Ensure we update array if before element changed\n      setObserverList(newList);\n    },\n    [setObserverList]\n  );\n\n  const setAfterRef = React.useCallback(\n    (element: HTMLDivElement) => {\n      if (!element || afterElementRef.current === element) {\n        return;\n      }\n      afterElementRef.current = element;\n      const newList = [];\n\n      if (beforeElementRef.current) {\n        newList.push(beforeElementRef.current);\n      }\n\n      newList.push(afterElementRef.current);\n\n      // Ensure we update array if after element changed\n      setObserverList(newList);\n    },\n    [setObserverList]\n  );\n\n  const initializeSizeArray = () => {\n    if (hasInitialized.current === false) {\n      hasInitialized.current = true;\n      populateSizeArrays();\n    }\n  };\n\n  React.useImperativeHandle(\n    imperativeVirtualizerRef,\n    () => {\n      return {\n        progressiveSizes: childProgressiveSizes,\n        nodeSizes: childSizes,\n        setFlaggedIndex: (index: number | null) =>\n          (flaggedIndex.current = index),\n        currentIndex: actualIndexRef,\n        virtualizerLength,\n      };\n    },\n    [childProgressiveSizes, childSizes, virtualizerLength]\n  );\n\n  // Initialization on mount - update array index to 0 (ready state).\n  // Only fire on mount (no deps).\n  React.useEffect(() => {\n    if (actualIndex < 0) {\n      batchUpdateNewIndex(0);\n    }\n    initializeSizeArray();\n  }, []);\n\n  // Effect to check flag index on updates\n  React.useEffect(() => {\n    if (!onRenderedFlaggedIndex || flaggedIndex.current === null) {\n      return;\n    }\n    if (\n      actualIndex <= flaggedIndex.current &&\n      actualIndex + virtualizerLength >= flaggedIndex.current\n    ) {\n      onRenderedFlaggedIndex(flaggedIndex.current);\n      flaggedIndex.current = null;\n    }\n  }, [actualIndex, onRenderedFlaggedIndex, virtualizerLength]);\n\n  return {\n    components: {\n      before: 'div',\n      after: 'div',\n      beforeContainer: 'div',\n      afterContainer: 'div',\n    },\n    virtualizedChildren: renderChildRows(actualIndex),\n    before: slot.always(props.before, {\n      defaultProps: {\n        ref: setBeforeRef,\n        role: 'none',\n      },\n      elementType: 'div',\n    }),\n    after: slot.always(props.after, {\n      defaultProps: {\n        ref: setAfterRef,\n        role: 'none',\n      },\n      elementType: 'div',\n    }),\n    beforeContainer: slot.always(props.beforeContainer, {\n      defaultProps: {\n        role: 'none',\n      },\n      elementType: 'div',\n    }),\n    afterContainer: slot.always(props.afterContainer, {\n      defaultProps: {\n        role: 'none',\n      },\n      elementType: 'div',\n    }),\n    beforeBufferHeight: isFullyInitialized ? calculateBefore() : 0,\n    afterBufferHeight: isFullyInitialized ? calculateAfter() : 0,\n    totalVirtualizerHeight: isFullyInitialized\n      ? calculateTotalSize()\n      : virtualizerLength * itemSize,\n    virtualizerStartIndex: actualIndex,\n    axis,\n    bufferSize,\n    reversed,\n    childSizes,\n    childProgressiveSizes,\n  };\n}\n"],"names":["React","useIntersectionObserver","useVirtualizerContextState_unstable","slot","useTimeout","flushSync","useVirtualizer_unstable","props","itemSize","numItems","virtualizerLength","children","renderChild","getItemSize","bufferItems","Math","round","bufferSize","floor","axis","reversed","virtualizerContext","onRenderedFlaggedIndex","imperativeVirtualizerRef","containerSizeRef","scrollViewRef","enableScrollLoad","updateScrollPosition","gap","_virtualizerContext","actualIndexRef","useRef","contextIndex","childArray","Array","flaggedIndex","actualIndex","hasInitialized","isFullyInitialized","current","useEffect","populateSizeArrays","setActualIndex","useCallback","index","setContextIndex","beforeElementRef","afterElementRef","childSizes","childProgressiveSizes","length","_gap","isScrolling","setIsScrolling","useState","setScrollTimer","clearScrollTimer","scrollCounter","initializeScrollingTimer","INIT_SCROLL_FLAG_REQ","INIT_SCROLL_FLAG_DELAY","updateChildArray","renderChildRows","_newIndex","newIndex","max","arrayLength","min","newChildArray","i","_isScrolling","startIndex","updateCurrentItemSizes","endIndex","didUpdate","newSize","prevSize","batchUpdateNewIndex","findIndexRecursive","scrollPos","lowIndex","highIndex","midpoint","iBefore","iAfter","indexValue","afterIndexValue","beforeIndexValue","getIndexFromSizeArray","getIndexFromScrollPosition","calculateTotalSize","calculateBefore","currentIndex","calculateAfter","lastItemIndex","remainingItems","previousNumItems","setObserverList","entries","_observer","sortedEntries","sort","entry1","entry2","time","latestEntry","find","entry","isIntersecting","calculateOverBuffer","measurementPos","target","overflowAmount","intersectionRect","height","width","hOverflow","boundingClientRect","top","hOverflowReversed","bottom","wOverflow","left","wOverflowReversed","right","widthOverflow","heightOverflow","additionalOverflow","maxIndex","newStartIndex","numItemsChanged","root","rootMargin","threshold","setBeforeRef","element","newList","push","setAfterRef","initializeSizeArray","useImperativeHandle","progressiveSizes","nodeSizes","setFlaggedIndex","components","before","after","beforeContainer","afterContainer","virtualizedChildren","always","defaultProps","ref","role","elementType","beforeBufferHeight","afterBufferHeight","totalVirtualizerHeight","virtualizerStartIndex"],"mappings":"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"}