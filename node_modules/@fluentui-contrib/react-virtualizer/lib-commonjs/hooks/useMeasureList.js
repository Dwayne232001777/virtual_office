"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get createResizeObserverFromDocument () {
        return createResizeObserverFromDocument;
    },
    get useMeasureList () {
        return useMeasureList;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _reactsharedcontexts = require("@fluentui/react-shared-contexts");
/**
 * Provides a way of automating size in the virtualizer
 * Returns
 * `width` - element width ref (0 by default),
 * `height` - element height ref (0 by default),
 * `measureElementRef` - a ref function to be passed as `ref` to the element you want to measure
 */ const SCROLL_ALLOWANCE = 100;
function useMeasureList(measureParams) {
    const { currentIndex, totalLength, defaultItemSize, sizeTrackingArray, axis, requestScrollBy, virtualizerLength } = measureParams;
    const { targetDocument } = (0, _reactsharedcontexts.useFluent_unstable)();
    // Use ref object to track and delete observed elements
    const refObject = _react.useRef({});
    // the handler for resize observer
    const handleIndexUpdate = _react.useCallback((index)=>{
        var _refObject_current_index_toString;
        const boundClientRect = (_refObject_current_index_toString = refObject.current[index.toString()]) == null ? void 0 : _refObject_current_index_toString.getBoundingClientRect();
        if (!boundClientRect) {
            return;
        }
        var _ref;
        const containerSize = (_ref = axis === 'vertical' ? boundClientRect == null ? void 0 : boundClientRect.height : boundClientRect == null ? void 0 : boundClientRect.width) != null ? _ref : defaultItemSize;
        const sizeDifference = containerSize - sizeTrackingArray.current[index];
        // Todo: Handle reverse setup
        // This requests a scrollBy to offset the new change
        if (sizeDifference !== 0) {
            const itemPosition = boundClientRect.bottom - SCROLL_ALLOWANCE;
            if (axis === 'vertical' && itemPosition <= sizeDifference) {
                requestScrollBy == null ? void 0 : requestScrollBy(sizeDifference);
            } else if (axis === 'horizontal' && itemPosition <= sizeDifference) {
                requestScrollBy == null ? void 0 : requestScrollBy(sizeDifference);
            }
        }
        // Update size tracking array which gets exposed if teams need it
        sizeTrackingArray.current[index] = containerSize;
    }, [
        defaultItemSize,
        requestScrollBy,
        axis,
        sizeTrackingArray
    ]);
    const handleElementResizeCallback = (entries)=>{
        for (const entry of entries){
            const target = entry.target;
            // Call the elements own resize handler (indexed)
            target.handleResize();
        }
    };
    _react.useEffect(()=>{
        const newLength = totalLength - sizeTrackingArray.current.length;
        /* Ensure we grow or truncate arrays with prior properties,
    keeping the existing values is important for whitespace assumptions.
    Even if items in the 'middle' are deleted, we will recalc the whitespace as it is explored.*/ if (newLength > 0) {
            sizeTrackingArray.current = sizeTrackingArray.current.concat(new Array(newLength).fill(defaultItemSize));
        } else if (newLength < 0) {
            sizeTrackingArray.current = sizeTrackingArray.current.slice(0, totalLength);
        }
    }, [
        defaultItemSize,
        totalLength
    ]);
    // Keep the reference of ResizeObserver as a ref, as it should live through renders
    const resizeObserver = _react.useRef(createResizeObserverFromDocument(targetDocument, handleElementResizeCallback));
    /* createIndexedRef provides a dynamic function to create an undefined number of refs at render time
   * these refs then provide an indexed callback via attaching 'handleResize' to the element itself
   * this function is then called on resize by handleElementResize and relies on indexing
   * to track continuous sizes throughout renders while releasing all virtualized element refs each render cycle.
   */ const createIndexedRef = _react.useCallback((index)=>{
        const measureElementRef = (el)=>{
            if (!targetDocument || !resizeObserver.current) {
                return;
            }
            if (el) {
                el.handleResize = ()=>{
                    handleIndexUpdate(currentIndex + index);
                };
            }
            const stringIndex = (index + currentIndex).toString();
            // cleanup previous container
            const prevEl = refObject.current[stringIndex];
            delete refObject.current[stringIndex];
            if (prevEl) {
                // Only remove if it doesn't exist in array now (might have moved index)
                resizeObserver.current.unobserve(prevEl);
            }
            if (el) {
                refObject.current[stringIndex] = el;
                resizeObserver.current.observe(el);
                handleIndexUpdate(currentIndex + index);
            }
        };
        return measureElementRef;
    }, [
        handleIndexUpdate,
        resizeObserver,
        targetDocument,
        currentIndex
    ]);
    _react.useEffect(()=>{
        // Delete and unobserve any removed elements on index change
        Object.keys(refObject.current).forEach((key)=>{
            const intKey = parseInt(key, 10);
            if (intKey < currentIndex || intKey >= currentIndex + virtualizerLength) {
                const el = refObject.current[key];
                delete refObject.current[key];
                if (el) {
                    var _resizeObserver_current;
                    (_resizeObserver_current = resizeObserver.current) == null ? void 0 : _resizeObserver_current.unobserve(el);
                }
            }
        });
    }, [
        virtualizerLength,
        currentIndex
    ]);
    _react.useEffect(()=>{
        const _resizeObserver = resizeObserver;
        return ()=>{
            var _resizeObserver_current;
            return (_resizeObserver_current = _resizeObserver.current) == null ? void 0 : _resizeObserver_current.disconnect();
        };
    }, [
        resizeObserver
    ]);
    return {
        createIndexedRef,
        refObject
    };
}
function createResizeObserverFromDocument(targetDocument, callback) {
    var _targetDocument_defaultView;
    if (!(targetDocument == null ? void 0 : (_targetDocument_defaultView = targetDocument.defaultView) == null ? void 0 : _targetDocument_defaultView.ResizeObserver)) {
        return null;
    }
    return new targetDocument.defaultView.ResizeObserver(callback);
}

//# sourceMappingURL=useMeasureList.js.map