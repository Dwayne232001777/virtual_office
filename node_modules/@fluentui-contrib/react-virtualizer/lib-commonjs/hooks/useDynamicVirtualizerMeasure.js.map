{"version":3,"sources":["../../../../../packages/react-virtualizer/src/hooks/useDynamicVirtualizerMeasure.ts"],"sourcesContent":["import {\n  useIsomorphicLayoutEffect,\n  useMergedRefs,\n} from '@fluentui/react-utilities';\nimport * as React from 'react';\nimport { VirtualizerMeasureDynamicProps } from './hooks.types';\nimport { useResizeObserverRef_unstable } from './useResizeObserverRef';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\n\n/**\n * React hook that measures virtualized space dynamically to ensure optimized virtualization length.\n */\nexport const useDynamicVirtualizerMeasure = <TElement extends HTMLElement>(\n  virtualizerProps: VirtualizerMeasureDynamicProps\n): {\n  virtualizerLength: number;\n  bufferItems: number;\n  bufferSize: number;\n  scrollRef: (instance: TElement | null) => void;\n  containerSizeRef: React.RefObject<number>;\n  updateScrollPosition: (scrollPosition: number) => void;\n} => {\n  const {\n    defaultItemSize,\n    direction = 'vertical',\n    numItems,\n    getItemSize,\n    bufferItems,\n    bufferSize,\n    virtualizerContext,\n    gap = 0,\n  } = virtualizerProps;\n\n  const [virtualizerLength, setVirtualizerLength] = React.useState(0);\n  const [virtualizerBufferItems, setVirtualizerBufferItems] = React.useState(0);\n  const [virtualizerBufferSize, setVirtualizerBufferSize] = React.useState(0);\n\n  const scrollPosition = React.useRef(0);\n  const numItemsRef = React.useRef<number>(numItems);\n  const containerSizeRef = React.useRef<number>(0);\n\n  const { targetDocument } = useFluent();\n  const container = React.useRef<HTMLElement | null>(null);\n\n  const handleScrollResize = React.useCallback(\n    (scrollRef: React.MutableRefObject<HTMLElement | null>) => {\n      const hasReachedEnd =\n        virtualizerContext.contextIndex + virtualizerLength >= numItems;\n\n      // Track whether this update was driven by a change in numItems\n      const numItemsChanged = numItemsRef.current !== numItems;\n      numItemsRef.current = numItems;\n\n      if (!scrollRef?.current || (hasReachedEnd && !numItemsChanged)) {\n        return;\n      }\n\n      if (scrollRef.current !== targetDocument?.body) {\n        // We have a local scroll container\n        containerSizeRef.current =\n          direction === 'vertical'\n            ? scrollRef?.current.getBoundingClientRect().height\n            : scrollRef?.current.getBoundingClientRect().width;\n      } else if (targetDocument?.defaultView) {\n        // If our scroll ref is the document body, we should check window height\n        containerSizeRef.current =\n          direction === 'vertical'\n            ? targetDocument?.defaultView?.innerHeight\n            : targetDocument?.defaultView?.innerWidth;\n      }\n\n      const _actualScrollPos =\n        direction === 'vertical'\n          ? scrollRef.current.scrollTop\n          : scrollRef.current.scrollLeft;\n\n      /* If the numItems changed, we're going to calc\n       * a new index based on actual scroll position\n       */\n      const actualScrollPos = numItemsChanged\n        ? _actualScrollPos\n        : scrollPosition.current;\n\n      const sizeToBeat = containerSizeRef.current + virtualizerBufferSize * 2;\n      const startIndex = Math.max(virtualizerContext.contextIndex, 0);\n\n      let indexSizer = 0;\n      let i = 0;\n      let length = 0;\n      let indexMod = 0;\n\n      let currentItemPos =\n        startIndex > 0\n          ? virtualizerContext.childProgressiveSizes.current[startIndex - 1]\n          : 0;\n\n      while (indexSizer <= sizeToBeat && i < numItems - startIndex) {\n        const iItemSize = getItemSize(startIndex + i) + gap;\n        if (actualScrollPos > currentItemPos + iItemSize) {\n          // The item isn't in view, we'll update index to skip it.\n          i++;\n          indexMod++;\n          currentItemPos += iItemSize;\n          continue;\n        } else if (actualScrollPos > currentItemPos) {\n          // The item is partially out of view, ignore the out of bounds portion\n          const variance = currentItemPos + iItemSize - actualScrollPos;\n          indexSizer += variance;\n        } else {\n          // Item is in view\n          indexSizer += iItemSize;\n        }\n        // Increment\n        i++;\n        length++;\n        currentItemPos += iItemSize;\n      }\n\n      /*\n       * Number of items to append at each end, i.e. 'preload' each side before entering view.\n       * Minimum: 2 - we give slightly more buffer for dynamic version.\n       */\n      const newBufferItems = bufferItems ?? Math.max(Math.ceil(length / 3), 1);\n\n      /*\n       * This is how far we deviate into the bufferItems to detect a redraw.\n       */\n      const newBufferSize = bufferSize ?? Math.max(defaultItemSize / 2, 1);\n      const totalLength = length + newBufferItems * 2;\n\n      if (numItemsChanged && indexMod - newBufferItems > 0) {\n        // Virtualizer will recalculate on numItems change, but from the old index\n        // We should get ahead of that update to prevent unnessecary recalculations\n        virtualizerContext.setContextIndex(\n          startIndex + indexMod - newBufferItems\n        );\n      }\n\n      scrollPosition.current = actualScrollPos;\n      setVirtualizerLength(totalLength);\n      setVirtualizerBufferItems(newBufferItems);\n      setVirtualizerBufferSize(newBufferSize);\n    },\n    [\n      bufferItems,\n      bufferSize,\n      defaultItemSize,\n      direction,\n      numItems,\n      targetDocument?.body,\n      targetDocument?.defaultView,\n      virtualizerBufferSize,\n      virtualizerContext.childProgressiveSizes,\n      virtualizerContext.contextIndex,\n      virtualizerLength,\n    ]\n  );\n\n  const resizeCallback = React.useCallback(\n    (\n      _entries: ResizeObserverEntry[],\n      // TODO: exclude types from this lint rule: https://github.com/microsoft/fluentui/issues/31286\n      // eslint-disable-next-line no-restricted-globals\n      _observer: ResizeObserver,\n      scrollRef?: React.MutableRefObject<HTMLElement | null>\n    ) => {\n      if (scrollRef) {\n        handleScrollResize(scrollRef);\n      }\n    },\n    [handleScrollResize]\n  );\n\n  React.useEffect(() => {\n    // Track numItems changes (consumed in handleScrollResize)\n    numItemsRef.current = numItems;\n  }, [numItems]);\n\n  const scrollRef = useMergedRefs(\n    container,\n    useResizeObserverRef_unstable(resizeCallback)\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (virtualizerContext.contextIndex + virtualizerLength < numItems) {\n      // Avoid re-rendering/re-calculating when the end index has already been reached\n      handleScrollResize(container);\n    }\n  }, [\n    handleScrollResize,\n    numItems,\n    virtualizerContext.contextIndex,\n    virtualizerLength,\n  ]);\n\n  const updateScrollPosition = React.useCallback(\n    (_scrollPosition: number) => {\n      scrollPosition.current = _scrollPosition;\n      handleScrollResize(scrollRef);\n    },\n    [handleScrollResize, scrollRef]\n  );\n\n  return {\n    virtualizerLength,\n    bufferItems: virtualizerBufferItems,\n    bufferSize: virtualizerBufferSize,\n    scrollRef,\n    containerSizeRef,\n    updateScrollPosition,\n  };\n};\n"],"names":["useDynamicVirtualizerMeasure","virtualizerProps","defaultItemSize","direction","numItems","getItemSize","bufferItems","bufferSize","virtualizerContext","gap","virtualizerLength","setVirtualizerLength","React","useState","virtualizerBufferItems","setVirtualizerBufferItems","virtualizerBufferSize","setVirtualizerBufferSize","scrollPosition","useRef","numItemsRef","containerSizeRef","targetDocument","useFluent","container","handleScrollResize","useCallback","scrollRef","hasReachedEnd","contextIndex","numItemsChanged","current","body","getBoundingClientRect","height","width","defaultView","innerHeight","innerWidth","_actualScrollPos","scrollTop","scrollLeft","actualScrollPos","sizeToBeat","startIndex","Math","max","indexSizer","i","length","indexMod","currentItemPos","childProgressiveSizes","iItemSize","variance","newBufferItems","ceil","newBufferSize","totalLength","setContextIndex","resizeCallback","_entries","_observer","useEffect","useMergedRefs","useResizeObserverRef_unstable","useIsomorphicLayoutEffect","updateScrollPosition","_scrollPosition"],"mappings":";;;;+BAYaA;;;eAAAA;;;;gCATN;iEACgB;sCAEuB;qCACE;AAKzC,MAAMA,+BAA+B,CAC1CC;IASA,MAAM,EACJC,eAAe,EACfC,YAAY,UAAU,EACtBC,QAAQ,EACRC,WAAW,EACXC,WAAW,EACXC,UAAU,EACVC,kBAAkB,EAClBC,MAAM,CAAC,EACR,GAAGR;IAEJ,MAAM,CAACS,mBAAmBC,qBAAqB,GAAGC,OAAMC,QAAQ,CAAC;IACjE,MAAM,CAACC,wBAAwBC,0BAA0B,GAAGH,OAAMC,QAAQ,CAAC;IAC3E,MAAM,CAACG,uBAAuBC,yBAAyB,GAAGL,OAAMC,QAAQ,CAAC;IAEzE,MAAMK,iBAAiBN,OAAMO,MAAM,CAAC;IACpC,MAAMC,cAAcR,OAAMO,MAAM,CAASf;IACzC,MAAMiB,mBAAmBT,OAAMO,MAAM,CAAS;IAE9C,MAAM,EAAEG,cAAc,EAAE,GAAGC,IAAAA,uCAAS;IACpC,MAAMC,YAAYZ,OAAMO,MAAM,CAAqB;IAEnD,MAAMM,qBAAqBb,OAAMc,WAAW,CAC1C,CAACC;QACC,MAAMC,gBACJpB,mBAAmBqB,YAAY,GAAGnB,qBAAqBN;QAEzD,+DAA+D;QAC/D,MAAM0B,kBAAkBV,YAAYW,OAAO,KAAK3B;QAChDgB,YAAYW,OAAO,GAAG3B;QAEtB,IAAI,EAACuB,6BAAAA,UAAWI,OAAO,KAAKH,iBAAiB,CAACE,iBAAkB;YAC9D;QACF;QAEA,IAAIH,UAAUI,OAAO,MAAKT,kCAAAA,eAAgBU,IAAI,GAAE;YAC9C,mCAAmC;YACnCX,iBAAiBU,OAAO,GACtB5B,cAAc,aACVwB,6BAAAA,UAAWI,OAAO,CAACE,qBAAqB,GAAGC,MAAM,GACjDP,6BAAAA,UAAWI,OAAO,CAACE,qBAAqB,GAAGE,KAAK;QACxD,OAAO,IAAIb,kCAAAA,eAAgBc,WAAW,EAAE;gBAIhCd,6BACAA;YAJN,wEAAwE;YACxED,iBAAiBU,OAAO,GACtB5B,cAAc,aACVmB,mCAAAA,8BAAAA,eAAgBc,WAAW,qBAA3Bd,4BAA6Be,WAAW,GACxCf,mCAAAA,+BAAAA,eAAgBc,WAAW,qBAA3Bd,6BAA6BgB,UAAU;QAC/C;QAEA,MAAMC,mBACJpC,cAAc,aACVwB,UAAUI,OAAO,CAACS,SAAS,GAC3Bb,UAAUI,OAAO,CAACU,UAAU;QAElC;;OAEC,GACD,MAAMC,kBAAkBZ,kBACpBS,mBACArB,eAAea,OAAO;QAE1B,MAAMY,aAAatB,iBAAiBU,OAAO,GAAGf,wBAAwB;QACtE,MAAM4B,aAAaC,KAAKC,GAAG,CAACtC,mBAAmBqB,YAAY,EAAE;QAE7D,IAAIkB,aAAa;QACjB,IAAIC,IAAI;QACR,IAAIC,SAAS;QACb,IAAIC,WAAW;QAEf,IAAIC,iBACFP,aAAa,IACTpC,mBAAmB4C,qBAAqB,CAACrB,OAAO,CAACa,aAAa,EAAE,GAChE;QAEN,MAAOG,cAAcJ,cAAcK,IAAI5C,WAAWwC,WAAY;YAC5D,MAAMS,YAAYhD,YAAYuC,aAAaI,KAAKvC;YAChD,IAAIiC,kBAAkBS,iBAAiBE,WAAW;gBAChD,yDAAyD;gBACzDL;gBACAE;gBACAC,kBAAkBE;gBAClB;YACF,OAAO,IAAIX,kBAAkBS,gBAAgB;gBAC3C,sEAAsE;gBACtE,MAAMG,WAAWH,iBAAiBE,YAAYX;gBAC9CK,cAAcO;YAChB,OAAO;gBACL,kBAAkB;gBAClBP,cAAcM;YAChB;YACA,YAAY;YACZL;YACAC;YACAE,kBAAkBE;QACpB;QAEA;;;OAGC,GACD,MAAME,iBAAiBjD,sBAAAA,cAAeuC,KAAKC,GAAG,CAACD,KAAKW,IAAI,CAACP,SAAS,IAAI;QAEtE;;OAEC,GACD,MAAMQ,gBAAgBlD,qBAAAA,aAAcsC,KAAKC,GAAG,CAAC5C,kBAAkB,GAAG;QAClE,MAAMwD,cAAcT,SAASM,iBAAiB;QAE9C,IAAIzB,mBAAmBoB,WAAWK,iBAAiB,GAAG;YACpD,0EAA0E;YAC1E,2EAA2E;YAC3E/C,mBAAmBmD,eAAe,CAChCf,aAAaM,WAAWK;QAE5B;QAEArC,eAAea,OAAO,GAAGW;QACzB/B,qBAAqB+C;QACrB3C,0BAA0BwC;QAC1BtC,yBAAyBwC;IAC3B,GACA;QACEnD;QACAC;QACAL;QACAC;QACAC;QACAkB,kCAAAA,eAAgBU,IAAI;QACpBV,kCAAAA,eAAgBc,WAAW;QAC3BpB;QACAR,mBAAmB4C,qBAAqB;QACxC5C,mBAAmBqB,YAAY;QAC/BnB;KACD;IAGH,MAAMkD,iBAAiBhD,OAAMc,WAAW,CACtC,CACEmC,UACA,8FAA8F;IAC9F,iDAAiD;IACjDC,WACAnC;QAEA,IAAIA,WAAW;YACbF,mBAAmBE;QACrB;IACF,GACA;QAACF;KAAmB;IAGtBb,OAAMmD,SAAS,CAAC;QACd,0DAA0D;QAC1D3C,YAAYW,OAAO,GAAG3B;IACxB,GAAG;QAACA;KAAS;IAEb,MAAMuB,YAAYqC,IAAAA,6BAAa,EAC7BxC,WACAyC,IAAAA,mDAA6B,EAACL;IAGhCM,IAAAA,yCAAyB,EAAC;QACxB,IAAI1D,mBAAmBqB,YAAY,GAAGnB,oBAAoBN,UAAU;YAClE,gFAAgF;YAChFqB,mBAAmBD;QACrB;IACF,GAAG;QACDC;QACArB;QACAI,mBAAmBqB,YAAY;QAC/BnB;KACD;IAED,MAAMyD,uBAAuBvD,OAAMc,WAAW,CAC5C,CAAC0C;QACClD,eAAea,OAAO,GAAGqC;QACzB3C,mBAAmBE;IACrB,GACA;QAACF;QAAoBE;KAAU;IAGjC,OAAO;QACLjB;QACAJ,aAAaQ;QACbP,YAAYS;QACZW;QACAN;QACA8C;IACF;AACF"}