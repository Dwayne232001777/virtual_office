import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { createContext, forwardRef, useContext, useState, useCallback, Component, useMemo, useEffect, useRef, isValidElement, cloneElement, Children, useLayoutEffect, useImperativeHandle, createElement, Suspense, memo, Fragment as Fragment$1, useReducer, lazy } from 'react';
import { tokens, makeStyles, Tooltip as Tooltip$1, Button as Button$1, Spinner, Link as Link$1, Caption1, Body1, ToggleButton as ToggleButton$1, useFluent, InfoLabel as InfoLabel$1, mergeClasses, Body1Strong, useId, useToastController, Toast, ToastBody, FluentProvider, Toaster, Checkbox as Checkbox$1, Accordion as Accordion$1, AccordionItem, AccordionHeader, Subtitle2Stronger, AccordionPanel, Divider, createLightTheme, createDarkTheme, TeachingPopover, TeachingPopoverSurface, TeachingPopoverHeader, TeachingPopoverBody, Portal, RendererProvider, createDOMRenderer, Menu, MenuTrigger, SplitButton, MenuPopover, MenuList, MenuItem, Toolbar as Toolbar$1, ToolbarRadioButton, MenuGroup, MenuGroupHeader, treeItemLevelToken, SearchBox as SearchBox$1, FlatTree, FlatTreeItem, TreeItemLayout, MenuDivider, MenuItemCheckbox, Switch as Switch$1, SpinButton as SpinButton$1, Input, Dropdown as Dropdown$1, Option, Popover as Popover$1, PopoverTrigger, PopoverSurface, ColorPicker, ColorArea, ColorSlider, AlphaSlider, ColorSwatch, PresenceBadge, Slider, MenuItemRadio, Dialog, DialogSurface, DialogBody, DialogTitle, DialogContent, DialogActions, List as List$1, ListItem, Badge, Label, MessageBar as MessageBar$1, MessageBarBody, MessageBarTitle, Subtitle2, useComboboxFilter, Combobox, Textarea as Textarea$1, ToolbarButton, ToolbarDivider, Field } from '@fluentui/react-components';
import { ErrorCircleRegular, ChevronCircleRight16Regular, ChevronCircleRight20Regular, ChevronCircleDown16Regular, ChevronCircleDown20Regular, Copy16Regular, CopyRegular, PanelLeftExpandRegular, PanelRightExpandRegular, PanelLeftContractRegular, PanelRightContractRegular, PictureInPictureEnterRegular, MoreHorizontalRegular, LayoutColumnTwoFocusLeftFilled, LayoutColumnTwoSplitLeftFocusTopLeftFilled, LayoutColumnTwoSplitLeftFocusBottomLeftFilled, LayoutColumnTwoFocusRightFilled, LayoutColumnTwoSplitRightFocusTopRightFilled, LayoutColumnTwoSplitRightFocusBottomRightFilled, DocumentTextRegular, createFluentIcon, FilterRegular, TextSortAscendingRegular, GlobeRegular, ArrowExpandAllRegular, ArrowCollapseAllRegular, CubeTreeRegular, BugRegular, SettingsRegular, ArrowUploadRegular, ArrowDownloadRegular, StopRegular, RecordRegular, DataBarHorizontalRegular, WrenchRegular, WeatherSunnyRegular, WeatherMoonRegular, ArrowRotateClockwiseRegular, ArrowExpandRegular, SelectObjectRegular, CubeRegular, AddRegular, DeleteRegular, FullScreenMaximizeRegular, ChevronDownRegular, ChevronRightRegular, CircleSmallFilled, SaveRegular, PreviousRegular, ArrowPreviousRegular, TriangleLeftRegular, RecordStopRegular, PlayRegular, ArrowNextRegular, NextRegular, EditRegular, PauseRegular, LinkDismissRegular, LinkEditRegular, ArrowUndoRegular, BracesRegular, BracesDismiss16Regular, EyeRegular, CloudArrowUpRegular, CloudArrowDownRegular, EyeOffFilled, EyeFilled, ArrowMoveFilled, StopFilled, PlayFilled, EyeOffRegular, LockOpenRegular, LockClosedRegular, ResizeRegular, ChevronUpRegular, ArrowResetRegular, CircleHalfFillRegular, EyedropperRegular, PaintBucketRegular, InkStrokeRegular, StackRegular, FilmstripRegular, PauseFilled, WeatherSunnyLowFilled, LayerRegular, FrameRegular, AppGenericRegular, RectangleLandscapeRegular, BorderOutsideRegular, BorderNoneRegular, MyLocationRegular, CameraRegular, LightbulbRegular, VideoFilled, VideoRegular, FlashlightRegular, FlashlightOffRegular, DropRegular, BlurRegular, PipelineRegular, PersonWalkingRegular, DataLineRegular, SoundWaveCircleRegular, PersonSquareRegular, LayerDiagonalPersonRegular, ImageEditRegular, ImageRegular, TargetRegular, PersonFeedbackRegular, BranchRegular, DeleteFilled } from '@fluentui/react-icons';
import { Color3, Color4 } from '@babylonjs/core/Maths/math.color.js';
import { Vector3, Quaternion, Matrix, Vector2, Vector4, TmpVectors } from '@babylonjs/core/Maths/math.vector.js';
import { Observable } from '@babylonjs/core/Misc/observable.js';
import { GetClassName } from '@babylonjs/core/Misc/typeStore.js';
import { Collapse as Collapse$1, Fade } from '@fluentui/react-motion-components-preview';
import { useLocalStorage, useTernaryDarkMode } from 'usehooks-ts';
import { AsyncLock } from '@babylonjs/core/Misc/asyncLock.js';
import { Deferred } from '@babylonjs/core/Misc/deferred.js';
import { Logger } from '@babylonjs/core/Misc/logger.js';
import { Clamp } from '@babylonjs/core/Maths/math.scalar.functions.js';
import { VirtualizerScrollView } from '@fluentui-contrib/react-virtualizer';
import { UniqueIdGenerator } from '@babylonjs/core/Misc/uniqueIdGenerator.js';
import { FontAsset } from '@babylonjs/addons/msdfText/fontAsset.js';
import { TextRenderer } from '@babylonjs/addons/msdfText/textRenderer.js';
import { PhysicsViewer } from '@babylonjs/core/Debug/physicsViewer.js';
import { Texture } from '@babylonjs/core/Materials/Textures/texture.js';
import { MaterialFlags } from '@babylonjs/core/Materials/materialFlags.js';
import { StandardMaterial } from '@babylonjs/core/Materials/standardMaterial.js';
import { CreateGround } from '@babylonjs/core/Meshes/Builders/groundBuilder.js';
import { Tools } from '@babylonjs/core/Misc/tools.js';
import { UtilityLayerRenderer } from '@babylonjs/core/Rendering/utilityLayerRenderer.js';
import { GridMaterial } from '@babylonjs/materials/grid/gridMaterial.js';
import { DataStorage } from '@babylonjs/core/Misc/dataStorage.js';
import { EngineInstrumentation } from '@babylonjs/core/Instrumentation/engineInstrumentation.js';
import { SceneInstrumentation } from '@babylonjs/core/Instrumentation/sceneInstrumentation.js';
import '@babylonjs/core/Engines/AbstractEngine/abstractEngine.timeQuery.js';
import '@babylonjs/core/Engines/Extensions/engine.query.js';
import '@babylonjs/core/Engines/WebGPU/Extensions/engine.query.js';
import { PerfCollectionStrategy } from '@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollectionStrategies.js';
import '@babylonjs/core/Misc/PerformanceViewer/performanceViewerSceneExtension.js';
import { PressureObserverWrapper } from '@babylonjs/core/Misc/pressureObserverWrapper.js';
import { Scalar } from '@babylonjs/core/Maths/math.scalar.js';
import { PerformanceViewerCollector } from '@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollector.js';
import { AbstractEngine } from '@babylonjs/core/Engines/abstractEngine.js';
import { createRoot } from 'react-dom/client';
import { FrameGraphUtils } from '@babylonjs/core/FrameGraph/frameGraphUtils.js';
import { CameraGizmo } from '@babylonjs/core/Gizmos/cameraGizmo.js';
import { LightGizmo } from '@babylonjs/core/Gizmos/lightGizmo.js';
import { Bone } from '@babylonjs/core/Bones/bone.js';
import { Camera } from '@babylonjs/core/Cameras/camera.js';
import { GizmoManager } from '@babylonjs/core/Gizmos/gizmoManager.js';
import { Light } from '@babylonjs/core/Lights/light.js';
import { AbstractMesh } from '@babylonjs/core/Meshes/abstractMesh.js';
import { Node } from '@babylonjs/core/node.js';
import { AnimationGroup, TargetedAnimation } from '@babylonjs/core/Animations/animationGroup.js';
import { Animation } from '@babylonjs/core/Animations/animation.js';
import { AnimationPropertiesOverride } from '@babylonjs/core/Animations/animationPropertiesOverride.js';
import { Sound } from '@babylonjs/core/Audio/sound.js';
import { ArcRotateCamera } from '@babylonjs/core/Cameras/arcRotateCamera.js';
import { FollowCamera } from '@babylonjs/core/Cameras/followCamera.js';
import { FreeCamera } from '@babylonjs/core/Cameras/freeCamera.js';
import { GeospatialCamera } from '@babylonjs/core/Cameras/geospatialCamera.js';
import { TargetCamera } from '@babylonjs/core/Cameras/targetCamera.js';
import { Scene } from '@babylonjs/core/scene.js';
import { FrameGraph } from '@babylonjs/core/FrameGraph/frameGraph.js';
import { DirectionalLight } from '@babylonjs/core/Lights/directionalLight.js';
import { HemisphericLight } from '@babylonjs/core/Lights/hemisphericLight.js';
import { PointLight } from '@babylonjs/core/Lights/pointLight.js';
import { RectAreaLight } from '@babylonjs/core/Lights/rectAreaLight.js';
import { ShadowLight } from '@babylonjs/core/Lights/shadowLight.js';
import { SpotLight } from '@babylonjs/core/Lights/spotLight.js';
import { CascadedShadowGenerator } from '@babylonjs/core/Lights/Shadows/cascadedShadowGenerator.js';
import { DirectionalLightFrustumViewer } from '@babylonjs/core/Debug/directionalLightFrustumViewer.js';
import { ShadowGenerator } from '@babylonjs/core/Lights/Shadows/shadowGenerator.js';
import '@babylonjs/core/Lights/Shadows/shadowGeneratorSceneComponent.js';
import { Material } from '@babylonjs/core/Materials/material.js';
import { MultiMaterial } from '@babylonjs/core/Materials/multiMaterial.js';
import { NodeMaterial } from '@babylonjs/core/Materials/Node/nodeMaterial.js';
import { OpenPBRMaterial } from '@babylonjs/core/Materials/PBR/openpbrMaterial.js';
import { PBRBaseMaterial } from '@babylonjs/core/Materials/PBR/pbrBaseMaterial.js';
import { SkyMaterial } from '@babylonjs/materials/sky/skyMaterial.js';
import { Constants } from '@babylonjs/core/Engines/constants.js';
import { Engine } from '@babylonjs/core/Engines/engine.js';
import { ParticleSystem } from '@babylonjs/core/Particles/particleSystem.js';
import { GradientBlockColorStep } from '@babylonjs/core/Materials/Node/Blocks/gradientBlock.js';
import { NodeMaterialBlockConnectionPointTypes } from '@babylonjs/core/Materials/Node/Enums/nodeMaterialBlockConnectionPointTypes.js';
import { FactorGradient, Color3Gradient, ColorGradient } from '@babylonjs/core/Misc/gradients.js';
import { ReadFile } from '@babylonjs/core/Misc/fileTools.js';
import { CubeTexture } from '@babylonjs/core/Materials/Textures/cubeTexture.js';
import { GaussianSplattingMesh } from '@babylonjs/core/Meshes/GaussianSplatting/gaussianSplattingMesh.js';
import { Mesh } from '@babylonjs/core/Meshes/mesh.js';
import { SkeletonViewer } from '@babylonjs/core/Debug/skeletonViewer.js';
import { VertexBuffer } from '@babylonjs/core/Meshes/buffer.js';
import { CreateLineSystem } from '@babylonjs/core/Meshes/Builders/linesBuilder.js';
import { InstancedMesh } from '@babylonjs/core/Meshes/instancedMesh.js';
import { RenderingManager } from '@babylonjs/core/Rendering/renderingManager.js';
import '@babylonjs/core/Rendering/edgesRenderer.js';
import '@babylonjs/core/Rendering/outlineRenderer.js';
import { GPUParticleSystem } from '@babylonjs/core/Particles/gpuParticleSystem.js';
import { ConvertToNodeParticleSystemSetAsync } from '@babylonjs/core/Particles/Node/nodeParticleSystemSet.helper.js';
import { ParticleHelper } from '@babylonjs/core/Particles/particleHelper.js';
import { BoxParticleEmitter } from '@babylonjs/core/Particles/EmitterTypes/boxParticleEmitter.js';
import { ConeParticleEmitter } from '@babylonjs/core/Particles/EmitterTypes/coneParticleEmitter.js';
import { CylinderParticleEmitter } from '@babylonjs/core/Particles/EmitterTypes/cylinderParticleEmitter.js';
import { HemisphericParticleEmitter } from '@babylonjs/core/Particles/EmitterTypes/hemisphericParticleEmitter.js';
import { MeshParticleEmitter } from '@babylonjs/core/Particles/EmitterTypes/meshParticleEmitter.js';
import { PointParticleEmitter } from '@babylonjs/core/Particles/EmitterTypes/pointParticleEmitter.js';
import { SphereParticleEmitter } from '@babylonjs/core/Particles/EmitterTypes/sphereParticleEmitter.js';
import { Attractor } from '@babylonjs/core/Particles/attractor.js';
import { CreateSphere } from '@babylonjs/core/Meshes/Builders/sphereBuilder.js';
import { ParticleInputBlock } from '@babylonjs/core/Particles/Node/Blocks/particleInputBlock.js';
import { UpdateAttractorBlock } from '@babylonjs/core/Particles/Node/Blocks/Update/updateAttractorBlock.js';
import { NodeParticleBlockConnectionPointTypes } from '@babylonjs/core/Particles/Node/Enums/nodeParticleBlockConnectionPointTypes.js';
import { TransformNode } from '@babylonjs/core/Meshes/transformNode.js';
import { PhysicsPrestepType } from '@babylonjs/core/Physics/v2/IPhysicsEnginePlugin.js';
import '@babylonjs/core/Physics/v2/physicsEngineComponent.js';
import { PostProcess } from '@babylonjs/core/PostProcesses/postProcess.js';
import { PostProcessRenderPipeline } from '@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipeline.js';
import { DefaultRenderingPipeline } from '@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/defaultRenderingPipeline.js';
import { LensRenderingPipeline } from '@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/lensRenderingPipeline.js';
import { SSAORenderingPipeline } from '@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/ssaoRenderingPipeline.js';
import { SSAO2RenderingPipeline } from '@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/ssao2RenderingPipeline.js';
import { SSRRenderingPipeline } from '@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/ssrRenderingPipeline.js';
import { IblShadowsRenderPipeline } from '@babylonjs/core/Rendering/IBLShadows/iblShadowsRenderPipeline.js';
import { ImageProcessingConfiguration } from '@babylonjs/core/Materials/imageProcessingConfiguration.js';
import { Skeleton } from '@babylonjs/core/Bones/skeleton.js';
import { Sprite } from '@babylonjs/core/Sprites/sprite.js';
import { SpriteManager } from '@babylonjs/core/Sprites/spriteManager.js';
import { GetTextureDataAsync, WhenTextureReadyAsync } from '@babylonjs/core/Misc/textureTools.js';
import { BaseTexture } from '@babylonjs/core/Materials/Textures/baseTexture.js';
import { MultiRenderTarget } from '@babylonjs/core/Materials/Textures/multiRenderTarget.js';
import { RenderTargetTexture } from '@babylonjs/core/Materials/Textures/renderTargetTexture.js';
import { ThinTexture } from '@babylonjs/core/Materials/Textures/thinTexture.js';
import { KeyboardEventTypes } from '@babylonjs/core/Events/keyboardEvents.js';
import { PointerEventTypes } from '@babylonjs/core/Events/pointerEvents.js';
import { HtmlElementTexture } from '@babylonjs/core/Materials/Textures/htmlElementTexture.js';
import { ShaderMaterial } from '@babylonjs/core/Materials/shaderMaterial.js';
import { CreatePlane } from '@babylonjs/core/Meshes/Builders/planeBuilder.js';
import { ClusteredLightContainer } from '@babylonjs/core/Lights/Clustered/clusteredLightContainer.js';
import '@babylonjs/core/Rendering/boundingBoxRenderer.js';
import '@babylonjs/core/PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent.js';
import '@babylonjs/core/Sprites/spriteSceneComponent.js';
import { DynamicTexture } from '@babylonjs/core/Materials/Textures/dynamicTexture.js';
import { captureEquirectangularFromScene } from '@babylonjs/core/Misc/equirectangularCapture.js';
import { SceneRecorder } from '@babylonjs/core/Misc/sceneRecorder.js';
import { CreateScreenshotUsingRenderTargetAsync } from '@babylonjs/core/Misc/screenshotTools.js';
import { VideoRecorder } from '@babylonjs/core/Misc/videoRecorder.js';
import { SceneSerializer } from '@babylonjs/core/Misc/sceneSerializer.js';
import { EnvironmentTextureTools } from '@babylonjs/core/Misc/environmentTextureTools.js';
import { ImportAnimationsAsync, SceneLoader } from '@babylonjs/core/Loading/sceneLoader.js';
import { FilesInput } from '@babylonjs/core/Misc/filesInput.js';
import { GLTFLoaderAnimationStartMode, GLTFLoaderCoordinateSystemMode, GLTFLoaderDefaultOptions } from '@babylonjs/loaders/glTF/glTFFileLoader.js';
import { GLTFValidation } from '@babylonjs/loaders/glTF/glTFValidation.js';
import { EngineStore } from '@babylonjs/core/Engines/engineStore.js';
import { DebugLayer } from '@babylonjs/core/Debug/debugLayer.js';
import { Lazy } from '@babylonjs/core/Misc/lazy.js';

const ToolContext = createContext({ useFluent: false, disableCopy: false, toolName: "", size: undefined });

const TokenMap = {
    px2: tokens.borderRadiusSmall,
    px4: tokens.borderRadiusMedium,
    px6: tokens.borderRadiusLarge,
    px8: tokens.borderRadiusXLarge,
    px10: tokens.fontSizeBase100,
    px12: tokens.fontSizeBase200,
    px14: tokens.fontSizeBase300,
    px16: tokens.fontSizeBase400,
    px20: tokens.fontSizeBase500,
    px24: tokens.fontSizeBase600,
    px28: tokens.lineHeightBase500,
    px32: tokens.lineHeightBase600,
    px36: tokens.lineHeightHero700,
    px40: tokens.lineHeightHero800,
};
const CustomTokens = {
    inputWidth: "150px",
    lineHeight: TokenMap.px36,
    lineHeightSmall: TokenMap.px28,
    dividerGap: TokenMap.px10,
    dividerGapSmall: TokenMap.px4,
    labelMinWidth: "50px",
    rightAlignOffset: `-${TokenMap.px8}`,
};
const UniformWidthStyling = { width: CustomTokens.inputWidth, boxSizing: "border-box" };
const useInputStyles$1 = makeStyles({
    input: UniformWidthStyling,
    inputSlot: { textAlign: "right" },
    invalid: { backgroundColor: tokens.colorPaletteRedBackground2 },
    container: {
        display: "flex",
        flexDirection: "column",
        justifyContent: "center", // align items vertically
        minWidth: 0, // Allow shrinking
    },
});
function HandleOnBlur(event) {
    event.stopPropagation();
    event.preventDefault();
}
function HandleKeyDown(event) {
    event.stopPropagation(); // Prevent event propagation
    // Prevent Enter key from causing form submission or value reversion
    if (event.key === "Enter") {
        event.preventDefault();
    }
}
/**
 * Fluent's CalculatePrecision function
 * https://github.com/microsoft/fluentui/blob/dcbf775d37938eacffa37922fc0b43a3cdd5753f/packages/utilities/src/math.ts#L91C1
 *
 * Calculates a number's precision based on the number of trailing
 * zeros if the number does not have a decimal indicated by a negative
 * precision. Otherwise, it calculates the number of digits after
 * the decimal point indicated by a positive precision.
 *
 * @param value - the value to determine the precision of
 * @returns the calculated precision
 */
function CalculatePrecision(value) {
    /**
     * Group 1:
     * [1-9]([0]+$) matches trailing zeros
     * Group 2:
     * \.([0-9]*) matches all digits after a decimal point.
     */ const groups = /[1-9]([0]+$)|\.([0-9]*)/.exec(String(value));
    if (!groups) {
        return 0;
    }
    if (groups[1]) {
        return -groups[1].length;
    }
    if (groups[2]) {
        return groups[2].length;
    }
    return 0;
}
const HEX_REGEX = RegExp(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3}|[A-Fa-f0-9]{8})$/);
function ValidateColorHex(val) {
    return val != "" && HEX_REGEX.test(val);
}

// forwardRef wrapper to avoid "function components cannot be given refs" warning
// FluentTooltip handles ref forwarding to children internally via applyTriggerPropsToChildren
const Tooltip = forwardRef((props, _ref) => {
    const { content, children } = props;
    if (!content) {
        return children;
    }
    return (jsx(Tooltip$1, { relationship: "description", content: content, children: children }));
});
Tooltip.displayName = "Tooltip";

const useButtonStyles = makeStyles({
    smallIcon: {
        fontSize: TokenMap.px16,
    },
    mediumIcon: {
        fontSize: TokenMap.px20,
    },
});
const Button = forwardRef((props, ref) => {
    const { size } = useContext(ToolContext);
    const classes = useButtonStyles();
    // eslint-disable-next-line @typescript-eslint/naming-convention
    const { icon: Icon, label, onClick, disabled, className, title, ...buttonProps } = props;
    const [isOnClickBusy, setIsOnClickBusy] = useState(false);
    const handleOnClick = useCallback(async (e) => {
        const result = onClick?.(e);
        if (result instanceof Promise) {
            setIsOnClickBusy(true);
            try {
                await result;
            }
            finally {
                setIsOnClickBusy(false);
            }
        }
    }, [onClick]);
    const iconClass = size === "small" ? classes.smallIcon : classes.mediumIcon;
    return (jsx(Tooltip, { content: title ?? "", children: jsx(Button$1, { ref: ref, iconPosition: "after", ...buttonProps, className: className, size: size, icon: isOnClickBusy ? jsx(Spinner, { size: "extra-tiny" }) : Icon && jsx(Icon, { className: iconClass }), onClick: handleOnClick, disabled: disabled || isOnClickBusy, children: label && props.label }) }));
});
Button.displayName = "Button";

const useStyles$T = makeStyles({
    root: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        padding: TokenMap.px20,
        backgroundColor: tokens.colorNeutralBackground1,
        color: tokens.colorNeutralForeground1,
        height: "100%",
        minHeight: "100px",
    },
    icon: {
        fontSize: "48px",
        color: tokens.colorPaletteRedForeground1,
        marginBottom: TokenMap.px12,
    },
    title: {
        fontSize: TokenMap.px16,
        fontWeight: "600",
        marginBottom: TokenMap.px8,
    },
    message: {
        fontSize: TokenMap.px12,
        color: tokens.colorNeutralForeground2,
        marginBottom: TokenMap.px16,
        textAlign: "center",
        maxWidth: "300px",
    },
    details: {
        fontSize: TokenMap.px10,
        color: tokens.colorNeutralForeground3,
        fontFamily: "monospace",
        whiteSpace: "pre-wrap",
        maxHeight: "100px",
        overflow: "auto",
        padding: TokenMap.px8,
        backgroundColor: tokens.colorNeutralBackground3,
        borderRadius: TokenMap.px4,
        marginTop: TokenMap.px8,
        maxWidth: "100%",
    },
});
/**
 * Error boundary component that catches JavaScript errors in child components
 * and displays a fallback UI instead of crashing the entire application.
 */
class ErrorBoundary extends Component {
    constructor(props) {
        super(props);
        this._handleRetry = () => {
            this.setState({ hasError: false, error: null, errorInfo: null });
        };
        this.state = { hasError: false, error: null, errorInfo: null };
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    static getDerivedStateFromError(error) {
        return { hasError: true, error };
    }
    componentDidCatch(error, errorInfo) {
        this.setState({ errorInfo });
        // Log the error
        const boundaryName = this.props.name || "ErrorBoundary";
        // eslint-disable-next-line no-console
        console.error(`[${boundaryName}] Error caught:`, error, errorInfo);
        // Call optional error callback
        this.props.onError?.(error, errorInfo);
    }
    render() {
        if (this.state.hasError) {
            // If a custom fallback is provided, use it
            if (this.props.fallback) {
                return this.props.fallback;
            }
            // Default fallback UI
            return jsx(ErrorFallback, { error: this.state.error, onRetry: this._handleRetry });
        }
        return this.props.children;
    }
}
function ErrorFallback({ error, onRetry }) {
    const styles = useStyles$T();
    return (jsxs("div", { className: styles.root, children: [jsx(ErrorCircleRegular, { className: styles.icon }), jsx("div", { className: styles.title, children: "Something went wrong" }), jsx("div", { className: styles.message, children: "An error occurred in this component. You can try again or continue using other parts of the inspector." }), jsx(Button, { label: "Try Again", appearance: "primary", onClick: onRetry }), error && jsx("div", { className: styles.details, children: error.message })] }));
}

const PropertyContext = createContext(undefined);
function usePropertyChangedNotifier() {
    const propertyContext = useContext(PropertyContext);
    return useCallback((entity, propertyKey, oldValue, newValue) => {
        propertyContext?.onPropertyChanged.notifyObservers({ entity, propertyKey, oldValue, newValue });
    }, [propertyContext]);
}

const InterceptorHooksMaps$1 = new WeakMap();
/** @internal */
function InterceptFunction(target, propertyKey, hooks) {
    if (!hooks.afterCall) {
        throw new Error("At least one hook must be provided.");
    }
    const originalFunction = Reflect.get(target, propertyKey, target);
    if (typeof originalFunction !== "function") {
        throw new Error(`Property "${propertyKey.toString()}" of object "${target}" is not a function.`);
    }
    // Make sure the property is configurable and writable, otherwise it is immutable and cannot be intercepted.
    const propertyDescriptor = Reflect.getOwnPropertyDescriptor(target, propertyKey);
    if (propertyDescriptor) {
        if (!propertyDescriptor.configurable) {
            throw new Error(`Property "${propertyKey.toString()}" of object "${target}" is not configurable.`);
        }
        if (propertyDescriptor.writable === false || (propertyDescriptor.writable === undefined && !propertyDescriptor.set)) {
            throw new Error(`Property "${propertyKey.toString()}" of object "${target}" is readonly.`);
        }
    }
    // Get or create the hooks map for the target object.
    let hooksMap = InterceptorHooksMaps$1.get(target);
    if (!hooksMap) {
        InterceptorHooksMaps$1.set(target, (hooksMap = new Map()));
    }
    // Get or create the hooks array for the property key.
    let hooksForKey = hooksMap.get(propertyKey);
    if (!hooksForKey) {
        hooksMap.set(propertyKey, (hooksForKey = []));
        if (
        // Replace the function with a new one that calls the hooks in addition to the original function.
        !Reflect.set(target, propertyKey, (...args) => {
            const result = Reflect.apply(originalFunction, target, args);
            for (const { afterCall } of hooksForKey) {
                afterCall?.(...args);
            }
            return result;
        })) {
            throw new Error(`Failed to define new function "${propertyKey.toString()}" on object "${target}".`);
        }
    }
    hooksForKey.push(hooks);
    let isDisposed = false;
    return {
        dispose: () => {
            if (!isDisposed) {
                // Remove the hooks from the hooks array for the property key.
                hooksForKey.splice(hooksForKey.indexOf(hooks), 1);
                // If there are no more hooks for the property key, remove the property from the hooks map.
                if (hooksForKey.length === 0) {
                    hooksMap.delete(propertyKey);
                    // If there are no more hooks for the target object, remove the hooks map from the WeakMap.
                    if (hooksMap.size === 0) {
                        InterceptorHooksMaps$1.delete(target);
                    }
                    if (propertyDescriptor) {
                        // If we have a property descriptor, it means the property was defined directly on the target object,
                        // in which case we replaced it and the original property descriptor needs to be restored.
                        if (!Reflect.defineProperty(target, propertyKey, propertyDescriptor)) {
                            throw new Error(`Failed to restore original function "${propertyKey.toString()}" on object "${target}".`);
                        }
                    }
                    else {
                        // Otherwise, the property was inherited through the prototype chain, and so we can simply delete it from
                        // the target object to allow it to fall back to the prototype chain as it did originally.
                        if (!Reflect.deleteProperty(target, propertyKey)) {
                            throw new Error(`Failed to delete transient function "${propertyKey.toString()}" on object "${target}".`);
                        }
                    }
                }
                isDisposed = true;
            }
        },
    };
}

/**
 * Gets the property descriptor for a property on an object, including inherited properties.
 * @param target The object containing the property.
 * @param propertyKey The key of the property to get the descriptor for.
 * @returns The owner of the property (which may be different from the target in the case of inheritance) along with the property descriptor, or null if the property is not found.
 */
function GetPropertyDescriptor(target, propertyKey) {
    let propertyOwner = target;
    let propertyDescriptor;
    while (propertyOwner) {
        if ((propertyDescriptor = Reflect.getOwnPropertyDescriptor(propertyOwner, propertyKey))) {
            break;
        }
        propertyOwner = Reflect.getPrototypeOf(propertyOwner);
    }
    if (propertyOwner && propertyDescriptor) {
        return [propertyOwner, propertyDescriptor];
    }
    return null;
}
/**
 * Checks if a property is readonly.
 * @param propertyDescriptor The property descriptor to check.
 * @returns True if the property is readonly, false otherwise.
 */
function IsPropertyReadonly(propertyDescriptor) {
    // If the property is not writable, it is readonly.
    return propertyDescriptor.writable === false || (propertyDescriptor.writable === undefined && !propertyDescriptor.set);
}
const InterceptorHooksMaps = new WeakMap();
/** @internal */
function InterceptProperty(target, propertyKey, hooks) {
    // Find the property descriptor and note the owning object (might be inherited through the prototype chain).
    const ownerAndDescriptor = GetPropertyDescriptor(target, propertyKey);
    // If the property does not exist, we'll define one transiently directly on the target object.
    const [propertyOwner, propertyDescriptor] = ownerAndDescriptor ?? [
        target,
        {
            configurable: true,
            enumerable: true,
            writable: true,
            value: undefined,
        },
    ];
    if (!ownerAndDescriptor) {
        Reflect.defineProperty(propertyOwner, propertyKey, propertyDescriptor);
    }
    else {
        // If the property is not configurable, it cannot be intercepted.
        if (!propertyDescriptor.configurable) {
            throw new Error(`Property "${propertyKey.toString()}" of object "${target}" is not configurable.`);
        }
        // If the property is not writable, it cannot be intercepted, but it cannot be mutated anyway so there is no need to intercept it.
        if (IsPropertyReadonly(propertyDescriptor)) {
            return {
                dispose: () => { },
            };
        }
    }
    // Get or create the hooks map for the target object.
    let hooksMap = InterceptorHooksMaps.get(target);
    if (!hooksMap) {
        InterceptorHooksMaps.set(target, (hooksMap = new Map()));
    }
    // Get or create the hooks array for the property key.
    let hooksForKey = hooksMap.get(propertyKey);
    if (!hooksForKey) {
        hooksMap.set(propertyKey, (hooksForKey = []));
        let { get: getValue, set: setValue } = propertyDescriptor;
        // We already checked that the property is writable, so if there is no setter, then it must be a value property.
        // In this case, getValue can return the direct value, and setValue can set the direct value.
        if (!setValue) {
            getValue = () => propertyDescriptor.value;
            setValue = (value) => (propertyDescriptor.value = value);
        }
        if (
        // Replace the property with a new one that calls the hooks in addition to the original getter and setter.
        !Reflect.defineProperty(target, propertyKey, {
            configurable: true,
            get: getValue ? () => getValue.call(target) : undefined,
            set: (newValue) => {
                setValue.call(target, newValue);
                for (const { afterSet } of hooksForKey) {
                    afterSet?.(newValue);
                }
            },
        })) {
            throw new Error(`Failed to define new property "${propertyKey.toString()}" on object "${target}".`);
        }
    }
    hooksForKey.push(hooks);
    let isDisposed = false;
    return {
        dispose: () => {
            if (!isDisposed) {
                // Remove the hooks from the hooks array for the property key.
                hooksForKey.splice(hooksForKey.indexOf(hooks), 1);
                // If there are no more hooks for the property key, remove the property from the hooks map.
                if (hooksForKey.length === 0) {
                    hooksMap.delete(propertyKey);
                    // If there are no more hooks for the target object, remove the hooks map from the WeakMap.
                    if (hooksMap.size === 0) {
                        InterceptorHooksMaps.delete(target);
                    }
                    const shouldRestorePropertyDescriptor = 
                    // If the property is owned by the target object, then we may have replaced an original property descriptor that needs to be restore.
                    propertyOwner === target &&
                        // But this is only the case if we found an existing property descriptor on the target object (hence the ownerAndDescriptor check),
                        // or if the property value is not undefined, in which case we still want to retain the value that was set.
                        (ownerAndDescriptor || target[propertyKey] !== undefined);
                    // Otherwise, the property was inherited through the prototype chain, and so we can simply delete it from the target object.
                    if (shouldRestorePropertyDescriptor) {
                        if (!Reflect.defineProperty(target, propertyKey, propertyDescriptor)) {
                            throw new Error(`Failed to restore original property descriptor "${propertyKey.toString()}" on object "${target}".`);
                        }
                    }
                    else {
                        if (!Reflect.deleteProperty(target, propertyKey)) {
                            throw new Error(`Failed to delete transient property descriptor "${propertyKey.toString()}" on object "${target}".`);
                        }
                    }
                }
                isDisposed = true;
            }
        },
    };
}

/**
 * Provides an observable that fires when a specified function/property is called/set.
 * @param type The type of the interceptor, either "function" or "property".
 * @param target The object containing the function/property to intercept.
 * @param propertyKey The key of the function/property to intercept.
 * @returns An observable that fires when the function/property is called/set.
 */
function useInterceptObservable(type, target, propertyKey) {
    // Create a cached observable. It effectively has the lifetime of the component that uses this hook.
    const observable = useMemo(() => new Observable(), []);
    // Whenever the type, target, or property key changes, we need to set up a new interceptor.
    useEffect(() => {
        let interceptToken = null;
        if (target) {
            if (type === "function") {
                interceptToken = InterceptFunction(target, propertyKey, {
                    afterCall: () => {
                        observable.notifyObservers();
                    },
                });
            }
            else if (type === "property") {
                interceptToken = InterceptProperty(target, propertyKey, {
                    afterSet: () => {
                        observable.notifyObservers();
                    },
                });
            }
            else {
                throw new Error(`Unknown interceptor type: ${type}`);
            }
        }
        // When the effect is cleaned up, we need to dispose of the interceptor.
        return () => {
            interceptToken?.dispose();
        };
    }, [type, target, propertyKey, observable]);
    return observable;
}

/**
 * Returns the current value of the accessor and updates it when the specified event is fired on the specified element.
 * @param accessor A function that returns the current value.
 * @param element The element to listen for the event on.
 * @param eventNames The names of the events to listen for.
 * @returns The current value of the accessor.
 *  * @remarks If the accessor function is not idempotent (e.g. it returns a different array or object instance each time it is called),
 * then there is a good chance it should be wrapped in a `useCallback` to prevent unnecessary re-renders or re-render infinite loops.
 */
function useEventfulState(accessor, element, ...eventNames) {
    const [current, setCurrent] = useState(accessor);
    useEffect(() => {
        setCurrent(accessor);
        if (element) {
            const removers = eventNames.map((eventName) => {
                const handler = () => {
                    setCurrent(accessor());
                };
                element.addEventListener(eventName, handler);
                return () => {
                    element.removeEventListener(eventName, handler);
                };
            });
            return () => {
                removers.forEach((remove) => remove());
            };
        }
        return undefined;
    }, [accessor, element, ...eventNames]);
    return current;
}
/**
 * Returns the current value of the accessor and updates it when any of the specified observables change.
 * @param accessor A function that returns the current value.
 * @param observables The observables to listen for changes on.
 * @returns The current value of the accessor.
 * @remarks If the accessor function is not idempotent (e.g. it returns a different array or object instance each time it is called),
 * then there is a good chance it should be wrapped in a `useCallback` to prevent unnecessary re-renders or re-render infinite loops.
 */
function useObservableState(accessor, ...observables) {
    const [current, setCurrent] = useState(accessor);
    useEffect(() => {
        setCurrent(accessor);
        const observers = observables.map((observable) => {
            if (observable) {
                const observer = observable.add(() => {
                    setCurrent(accessor());
                });
                return observer;
            }
            return null;
        });
        return () => {
            observers.forEach((observer) => observer?.remove());
        };
    }, [accessor, ...observables]);
    return current;
}
/**
 * Returns a copy of the items in the collection and updates it when the collection changes.
 * @param collection The collection to observe.
 * @returns A copy of the items in the collection.
 */
function useObservableCollection(collection) {
    const itemsRef = useRef([...collection.items]);
    return useObservableState(useCallback(() => {
        if (itemsRef.current.length !== collection.items.length || !itemsRef.current.every((item, index) => item === collection.items[index])) {
            itemsRef.current = [...collection.items];
        }
        return itemsRef.current;
    }, [collection]), collection.observable);
}
/**
 * Returns a copy of the items in the collection sorted by the order property and updates it when the collection changes.
 * @param collection The collection to observe.
 * @returns A copy of the items in the collection sorted by the order property.
 */
function useOrderedObservableCollection(collection) {
    const items = useObservableCollection(collection);
    const sortedItems = useMemo(() => items.sort((a, b) => (a.order ?? 0) - (b.order ?? 0)), [items]);
    return sortedItems;
}

/**
 * Translates a property value to react state, updating the state whenever the property changes.
 * @param target The object containing the property to observe.
 * @param propertyKey The key of the property to observe.
 * @returns The current value of the property, or null if the target is null or undefined.
 */
function useProperty(target, propertyKey) {
    return useObservableState(useCallback(() => (target ? target[propertyKey] : undefined), [target, propertyKey]), useInterceptObservable("property", target, propertyKey));
}
/**
 * Translates a Vector3 property value to react state, updating the state whenever the property changes or when the x/y/z components of the Vector3 change.
 * @param target The object containing the property to observe.
 * @param propertyKey The key of the property to observe.
 * @returns The current value of the property, or null if the target is null or undefined.
 */
function useVector3Property(target, propertyKey) {
    const vector = useProperty(target, propertyKey);
    useProperty(vector, "_x");
    useProperty(vector, "_y");
    useProperty(vector, "_z");
    return vector;
}
/**
 * Translates a Color3 property value to react state, updating the state whenever the property changes or when the r/g/b components of the Color3 change.
 * @param target The object containing the property to observe.
 * @param propertyKey The key of the property to observe.
 * @returns The current value of the property, or null if the target is null or undefined.
 */
function useColor3Property(target, propertyKey) {
    const color = useProperty(target, propertyKey);
    useProperty(color, "r");
    useProperty(color, "g");
    useProperty(color, "b");
    return color;
}
/**
 * Translates a Color4 property value to react state, updating the state whenever the property changes or when the r/g/b components of the Color4 change.
 * @param target The object containing the property to observe.
 * @param propertyKey The key of the property to observe.
 * @returns The current value of the property, or null if the target is null or undefined.
 */
function useColor4Property(target, propertyKey) {
    const color = useProperty(target, propertyKey);
    useProperty(color, "r");
    useProperty(color, "g");
    useProperty(color, "b");
    useProperty(color, "a");
    return color;
}
/**
 * Translates a Quaternion property value to react state, updating the state whenever the property changes or when the x/y/z/w components of the Quaternion change.
 * @param target The object containing the property to observe.
 * @param propertyKey The key of the property to observe.
 * @returns The current value of the property, or null if the target is null or undefined.
 */
function useQuaternionProperty(target, propertyKey) {
    const quaternion = useProperty(target, propertyKey);
    useProperty(quaternion, "_x");
    useProperty(quaternion, "_y");
    useProperty(quaternion, "_z");
    useProperty(quaternion, "_w");
    return quaternion;
}
/**
 * Creates a hook for a concrete value. For example, if the value is a Vector3,
 * it will return a hook that can intercept a change to the Vector3 property or
 * any of its components (x, y, z).
 * @param value The current value of a property that will be hooked.
 * @returns A hook function that can be used to observe changes to the property.
 */
function MakePropertyHook(value) {
    if (value instanceof Vector3) {
        return useVector3Property;
    }
    else if (value instanceof Quaternion) {
        return useQuaternionProperty;
    }
    else if (value instanceof Color3) {
        return useColor3Property;
    }
    else if (value instanceof Color4) {
        return useColor4Property;
    }
    else {
        return useProperty;
    }
}

// Check if BABYLON namespace exists
let BabylonNamespace = "";
const GlobalObject = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : undefined;
if (typeof GlobalObject !== "undefined") {
    if (typeof GlobalObject.BABYLON !== "undefined") {
        BabylonNamespace = "BABYLON.";
    }
}
// Inspired by previous copyToClipboard() function which was copying Color3
// Copies strCommand to clipboard
// eslint-disable-next-line @typescript-eslint/naming-convention
function copyCommandToClipboard(strCommand) {
    const element = document.createElement("div");
    element.textContent = strCommand;
    document.body.appendChild(element);
    if (window.getSelection) {
        const range = document.createRange();
        range.selectNode(element);
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);
    }
    document.execCommand("copy");
    element.remove();
}
// Return the class name of the considered target
// babylonNamespace is either "" (ES6) or "BABYLON."
// eslint-disable-next-line @typescript-eslint/naming-convention
function getClassNameWithNamespace(obj) {
    let className = GetClassName(obj);
    if (className.includes("BABYLON.")) {
        className = className.split("BABYLON.")[1];
    }
    return { className, babylonNamespace: BabylonNamespace };
}

/**
 * Generates a string representation of a value for clipboard copy.
 * Handles primitives, vectors, colors, quaternions, and other Babylon.js types.
 * @param value - The value to convert to a string
 * @returns A string that can be used to recreate the value
 */
function GenerateCopyString(value) {
    if (value === null) {
        return "null";
    }
    if (value === undefined) {
        return "undefined";
    }
    // Primitives
    if (typeof value === "string") {
        return `"${value}"`;
    }
    if (typeof value === "number" || typeof value === "boolean") {
        return String(value);
    }
    // Objects with getClassName (Babylon types like Vector3, Color3, Quaternion, etc.)
    if (typeof value === "object" && value !== null) {
        const obj = value;
        // Check for Babylon.js types with getClassName
        if (typeof obj.getClassName === "function") {
            const className = obj.getClassName();
            const { babylonNamespace } = getClassNameWithNamespace(value);
            // Vector2, Vector3, Vector4
            if (className === "Vector2") {
                return `new ${babylonNamespace}Vector2(${obj.x}, ${obj.y})`;
            }
            if (className === "Vector3") {
                return `new ${babylonNamespace}Vector3(${obj.x}, ${obj.y}, ${obj.z})`;
            }
            if (className === "Vector4") {
                return `new ${babylonNamespace}Vector4(${obj.x}, ${obj.y}, ${obj.z}, ${obj.w})`;
            }
            // Quaternion
            if (className === "Quaternion") {
                return `new ${babylonNamespace}Quaternion(${obj.x}, ${obj.y}, ${obj.z}, ${obj.w})`;
            }
            // Color3, Color4
            if (className === "Color3") {
                const hexString = ColorToHex(obj.r, obj.g, obj.b, 1);
                return `new ${babylonNamespace}Color3(${obj.r}, ${obj.g}, ${obj.b}) // (HEX: ${hexString})`;
            }
            if (className === "Color4") {
                const hexString = ColorToHex(obj.r, obj.g, obj.b, obj.a);
                return `new ${babylonNamespace}Color4(${obj.r}, ${obj.g}, ${obj.b}, ${obj.a}) // (HEX: ${hexString})`;
            }
            // Matrix - output as array
            if (className === "Matrix" && typeof obj.toArray === "function") {
                const arr = obj.toArray();
                return `${babylonNamespace}Matrix.FromArray([${arr.join(", ")}])`;
            }
            // For other Babylon types with a name property (like nodes, materials, etc.)
            if (typeof obj.name === "string") {
                return `"${obj.name}"`;
            }
            // Fallback: use className
            return `[${className}]`;
        }
        // Plain objects or arrays
        if (Array.isArray(value)) {
            return `[${value.map(GenerateCopyString).join(", ")}]`;
        }
        // Fallback for other objects
        return JSON.stringify(value);
    }
    return String(value);
}
/**
 * Converts linear color values (0-1) to a hex string with alpha.
 * @param r - Red component (0-1, linear)
 * @param g - Green component (0-1, linear)
 * @param b - Blue component (0-1, linear)
 * @param a - Alpha component (0-1)
 * @returns Hex string in format #RRGGBBAA
 */
function ColorToHex(r, g, b, a) {
    // Convert linear to sRGB and then to 0-255 range
    const toSRGB = (c) => Math.round(Math.min(255, Math.max(0, Math.pow(c, 1 / 2.2) * 255)));
    const rHex = toSRGB(r).toString(16).padStart(2, "0").toUpperCase();
    const gHex = toSRGB(g).toString(16).padStart(2, "0").toUpperCase();
    const bHex = toSRGB(b).toString(16).padStart(2, "0").toUpperCase();
    const aHex = Math.round(Math.min(255, Math.max(0, a * 255)))
        .toString(16)
        .padStart(2, "0")
        .toUpperCase();
    return `#${rHex}${gHex}${bHex}${aHex}`;
}

function BoundPropertyCoreImpl(props, ref) {
    const { target, propertyKey } = props;
    // Get the value of the property. If it changes, it will cause a re-render, which is needed to
    // re-evaluate which specific hook will catch all the nested property changes we want to observe.
    const value = useProperty(target, propertyKey);
    // Determine which specific property hook to use based on the value's type.
    const useSpecificProperty = useMemo(() => MakePropertyHook(value), [value]);
    const notifyPropertyChanged = usePropertyChangedNotifier();
    // Create an inline nested component that changes when the desired specific hook type changes (since hooks can't be conditional).
    // eslint-disable-next-line @typescript-eslint/naming-convention
    const SpecificComponent = useMemo(() => {
        return (props) => {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            const { target, propertyKey, propertyPath, convertTo, convertFrom, component: Component, ...rest } = props;
            // Hook the property, using the specific hook that also catches changes to nested properties as well (like x/y/z on a Vector3 for example).
            const value = useSpecificProperty(target, propertyKey);
            const convertedValue = convertTo ? convertTo(value) : value;
            const onChange = useMemo(() => {
                const propertyDescriptor = GetPropertyDescriptor(target, propertyKey)?.[1];
                if (propertyDescriptor && (propertyDescriptor.set || propertyDescriptor.writable)) {
                    return (val) => {
                        const oldValue = target[propertyKey];
                        const newValue = convertFrom ? convertFrom(val) : val;
                        target[propertyKey] = newValue;
                        notifyPropertyChanged(target, propertyKey, oldValue, newValue);
                    };
                }
                return undefined;
            }, [target, propertyKey, convertFrom, notifyPropertyChanged]);
            const propsToSend = {
                // will be overriden if custom onCopy is passed in
                onCopy: () => {
                    if (propertyPath) {
                        return GetOnCopyString(value, propertyPath);
                    }
                    const { className, babylonNamespace } = getClassNameWithNamespace(target);
                    return `${GetOnCopyString(value, String(propertyKey))} // (debugNode as ${babylonNamespace}${className})`;
                },
                ...rest,
                ref,
                value: convertedValue,
                onChange,
            };
            return jsx(Component, { ...propsToSend });
        };
    }, [useSpecificProperty, notifyPropertyChanged]);
    return jsx(SpecificComponent, { ...props });
}
const BoundPropertyCore = CreateGenericForwardRef(BoundPropertyCoreImpl);
function BoundPropertyImpl(props, ref) {
    const { target, ...rest } = props;
    // If target is null, don't render anything.
    if (!target) {
        return null;
    }
    // Target is guaranteed to be non-null here, pass to core implementation.
    return (jsx(ErrorBoundary, { name: `BoundProperty:${String(props.propertyKey)}`, children: jsx(BoundPropertyCore, { ...rest, target: target, ref: ref }) }));
}
// Custom generic forwardRef function (this is needed because using forwardRef with BoundPropertyImpl does not properly resolve Generic types)
function CreateGenericForwardRef(render) {
    return forwardRef(render);
}
/**
 * Intercepts the passed in component's target[propertyKey] with useInterceptObservable and sets component state using useObservableState.
 * Renders the passed in component with value as the new observableState value and onChange as a callback to set the target[propertyKey] value.
 *
 * NOTE: BoundProperty has strict nullable enforcement!
 *
 * If Target[PropertyKey] is Nullable, caller has three options:
 * 1. `nullable: true` + `defaultValue: NonNullable<T>` - Shows enable/disable checkbox UI
 * 2. `ignoreNullable: true` + `defaultValue: NonNullable<T>` - Shows disabled state when null
 * 3. `defaultValue: null` - Skips nullable handling entirely, passes value through as-is
 *
 * @param props BoundPropertyProps with strict nullable validation
 * @returns JSX element
 */
const BoundProperty = CreateGenericForwardRef(BoundPropertyImpl);
function GetOnCopyString(value, propertyPath) {
    const valueStr = GenerateCopyString(value);
    return `globalThis.debugNode.${propertyPath} = ${valueStr};`;
}
function GetOnCopyStringFunc(value, functionPath) {
    const valueStr = GenerateCopyString(value);
    return `globalThis.debugNode.${functionPath}(${valueStr});`;
}
function PropertyImpl(props, ref) {
    const { 
    // eslint-disable-next-line @typescript-eslint/naming-convention
    component: Component, propertyPath, functionPath, value, ...rest } = props;
    const propsToSend = {
        onCopy: () => (functionPath ? GetOnCopyStringFunc(value, functionPath) : GetOnCopyString(value, propertyPath)),
        ...rest,
        ref,
        value,
    };
    return jsx(Component, { ...propsToSend });
}
/**
 * A simpler version of BoundProperty that only provides the onCopy functionality.
 * Does not bind the value/onChange - those must be provided by the caller.
 * Use this when you need copy support but have custom value/onChange handling.
 *
 * @param props PropertyProps with propertyName for copy support
 * @returns JSX element
 */
const Property = CreateGenericForwardRef(PropertyImpl);

const useCollapseStyles = makeStyles({
    collapseContent: {
        overflow: "hidden",
        display: "flex",
    },
    horizontal: {
        flexDirection: "row",
    },
    vertical: {
        flexDirection: "column",
    },
});
/**
 * Wraps the passed in children with a fluent collapse component, handling smooth animation when visible prop changes
 * NOTE: When passing in children, prefer react fragment over empty div to avoid bloating the react tree with an unnecessary div
 * @param props
 * @returns
 */
const Collapse = (props) => {
    Collapse.displayName = "Collapse";
    const classes = useCollapseStyles();
    return (jsx(Collapse$1, { visible: props.visible, orientation: props.orientation, children: jsx("div", { className: `${classes.collapseContent} ${props.orientation === "horizontal" ? classes.horizontal : classes.vertical}`, children: props.children }) }));
};

const Link = forwardRef((props, ref) => {
    const { target, url, onLink, size, ...rest } = props;
    // eslint-disable-next-line @typescript-eslint/naming-convention
    const TextComponent = size === "small" ? Caption1 : Body1;
    return (jsxs(Link$1, { ref: ref, inline: true, target: target === "current" ? "_self" : "_blank", rel: "noopener noreferrer", href: url, onClick: onLink ?? undefined, ...rest, children: [props.children, jsx(TextComponent, { children: props.value })] }));
});
Link.displayName = "Link";

const useStyles$S = makeStyles({
    button: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
    },
});
/**
 * Toggles between two states using a button with icons.
 * If no disabledIcon is provided, the button will toggle between visual enabled/disabled states without an icon change
 *
 * @param props
 * @returns
 */
const ToggleButton = (props) => {
    ToggleButton.displayName = "ToggleButton";
    const { value, onChange, title, appearance = "subtle" } = props;
    const { size } = useContext(ToolContext);
    const classes = useStyles$S();
    const [checked, setChecked] = useState(value);
    const toggle = useCallback(() => {
        setChecked((prev) => {
            const enabled = !prev;
            onChange(enabled);
            return enabled;
        });
    }, [setChecked]);
    useEffect(() => {
        setChecked(props.value);
    }, [props.value]);
    return (jsx(Tooltip, { content: title ?? "", children: jsx(ToggleButton$1, { className: classes.button, size: size, icon: checked ? jsx(props.checkedIcon, {}) : props.uncheckedIcon ? jsx(props.uncheckedIcon, {}) : jsx(props.checkedIcon, {}), appearance: appearance, checked: checked, onClick: toggle }) }));
};

const useInfoLabelStyles = makeStyles({
    infoPopup: {
        whiteSpace: "normal",
        wordBreak: "break-word",
    },
    labelSlot: {
        display: "flex",
        minWidth: 0,
    },
    labelText: {
        whiteSpace: "nowrap",
        overflow: "hidden",
        textOverflow: "ellipsis",
    },
    copyable: {
        cursor: "copy",
    },
});
/**
 * Renders a label with an optional popup containing more info
 * @param props
 * @returns
 */
const InfoLabel = (props) => {
    InfoLabel.displayName = "InfoLabel";
    const classes = useInfoLabelStyles();
    const { targetDocument } = useFluent();
    const [ctrlPressed, setCtrlPressed] = useState(false);
    useEffect(() => {
        const targetWindow = targetDocument?.defaultView ?? window;
        const handleKeyDown = (e) => {
            if (e.ctrlKey) {
                setCtrlPressed(true);
            }
        };
        const handleKeyUp = (e) => {
            if (!e.ctrlKey) {
                setCtrlPressed(false);
            }
        };
        const handleBlur = () => {
            setCtrlPressed(false);
        };
        targetWindow.addEventListener("keydown", handleKeyDown);
        targetWindow.addEventListener("keyup", handleKeyUp);
        targetWindow.addEventListener("blur", handleBlur);
        return () => {
            targetWindow.removeEventListener("keydown", handleKeyDown);
            targetWindow.removeEventListener("keyup", handleKeyUp);
            targetWindow.removeEventListener("blur", handleBlur);
        };
    }, [targetDocument]);
    const infoContent = props.info ? jsx("div", { className: classes.infoPopup, children: props.info }) : undefined;
    const showCopyCursor = ctrlPressed && props.onContextMenu;
    // Handle Ctrl+click as context menu action
    const handleClick = useCallback((e) => {
        if (e.ctrlKey && props.onContextMenu) {
            props.onContextMenu(e);
        }
    }, [props.onContextMenu]);
    return infoContent ? (jsx(InfoLabel$1, { htmlFor: props.htmlFor, info: infoContent, className: mergeClasses(props.className, showCopyCursor ? classes.copyable : undefined), label: props.flexLabel ? { className: classes.labelSlot } : undefined, onContextMenu: props.onContextMenu, onClick: handleClick, children: jsx(Body1Strong, { className: classes.labelText, children: props.label }) })) : (jsx(Body1Strong, { className: mergeClasses(props.className, showCopyCursor ? classes.copyable : undefined), onContextMenu: props.onContextMenu, onClick: handleClick, children: props.label }));
};

const ToastContext = createContext({ showToast: () => { } });
const ToastProvider = ({ children }) => {
    const toasterId = useId("toaster");
    const { dispatchToast } = useToastController(toasterId);
    const { targetDocument } = useFluent();
    const showToast = useCallback((message) => {
        dispatchToast(jsx(Toast, { children: jsx(ToastBody, { children: message }) }), { intent: "success", timeout: 1000 });
    }, [dispatchToast]);
    return (jsxs(ToastContext.Provider, { value: { showToast }, children: [children, jsx(FluentProvider, { applyStylesToPortals: true, targetDocument: targetDocument, children: jsx(Toaster, { toasterId: toasterId, position: "bottom-end" }) })] }));
};
/**
 * Hook to show toast notifications.
 * @returns Object with showToast function that accepts a message string
 */
function useToast() {
    return useContext(ToastContext);
}

const usePropertyLineStyles = makeStyles({
    baseLine: {
        display: "flex",
        alignItems: "center",
        justifyContent: "flex-start",
        width: "100%",
    },
    infoLabel: {
        display: "flex",
        flex: "1 1 0", // grow=1, shrink =1, basis = 0 initial size before
        minWidth: CustomTokens.labelMinWidth,
        textAlign: "left",
    },
    rightContent: {
        flex: "0 1 auto",
        minWidth: 0,
        overflow: "hidden",
        display: "flex",
        alignItems: "center",
        justifyContent: "flex-end",
    },
    childWrapper: {
        minWidth: 0,
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
    },
    infoPopup: {
        whiteSpace: "normal",
        wordBreak: "break-word",
    },
    copy: {
        marginRight: CustomTokens.rightAlignOffset, // Accounts for the padding baked into fluent button / ensures propertyLine looks visually aligned at the right
    },
    expandedContentDiv: {
        overflow: "hidden",
        paddingLeft: tokens.spacingHorizontalM,
    },
    checkbox: {
        display: "flex",
        alignItems: "center",
        marginRight: tokens.spacingHorizontalXS,
    },
    checkboxIndicator: {
        margin: TokenMap.px2,
        width: TokenMap.px12,
        height: TokenMap.px12,
    },
});
/**
 * A reusable component that renders a property line with a label and child content, and an optional description, copy button, and expandable section.
 *
 * @param props - The properties for the PropertyLine component.
 * @returns A React element representing the property line.
 *
 */
const PropertyLine = forwardRef((props, ref) => {
    PropertyLine.displayName = "PropertyLine";
    const { disableCopy, size } = useContext(ToolContext);
    const classes = usePropertyLineStyles();
    const { label, onCopy, expandedContent, children, nullable, ignoreNullable } = props;
    const [expanded, setExpanded] = useState("expandByDefault" in props ? props.expandByDefault : false);
    const cachedVal = useRef(nullable ? props.value : null);
    const { showToast } = useToast();
    const handleCopy = useCallback(() => {
        if (onCopy) {
            copyCommandToClipboard(onCopy());
            showToast("Copied property to clipboard");
        }
    }, [onCopy, showToast]);
    const handleContextMenu = useCallback((e) => {
        e.preventDefault();
        handleCopy();
    }, [handleCopy]);
    const description = props.docLink ? jsx(Link, { url: props.docLink, value: props.description ?? "Docs" }) : props.description ? jsx(Body1, { children: props.description }) : undefined;
    // Process children to handle nullable state -- creating component in disabled state with default value in lieu of null value
    const processedChildren = (nullable || ignoreNullable) && isValidElement(children)
        ? cloneElement(children, {
            ...children.props,
            disabled: children.props.disabled || (nullable && props.value == null),
            value: props.value ?? props.defaultValue,
            defaultValue: undefined, // Don't pass defaultValue to children as there is no guarantee how this will be used and we can't mix controlled + uncontrolled state
        })
        : children;
    return (jsxs(LineContainer, { ref: ref, children: [jsxs("div", { className: classes.baseLine, children: [jsx(InfoLabel, { className: classes.infoLabel, htmlFor: "property", info: description, label: label, flexLabel: true, onContextMenu: onCopy ? handleContextMenu : undefined }), jsxs("div", { className: classes.rightContent, id: "property", children: [expandedContent && (jsx(ToggleButton, { title: "Expand/Collapse property", appearance: "transparent", checkedIcon: size === "small" ? ChevronCircleDown16Regular : ChevronCircleDown20Regular, uncheckedIcon: size === "small" ? ChevronCircleRight16Regular : ChevronCircleRight20Regular, value: expanded === true, onChange: setExpanded })), nullable && !ignoreNullable && (
                            // If this is a nullableProperty and ignoreNullable was not sent, display a checkbox used to toggle null ('checked' means 'non null')
                            jsx(Tooltip, { content: props.value == null ? "Enable property" : "Disable property (set to null)", children: jsx(Checkbox$1, { className: classes.checkbox, indicator: { className: classes.checkboxIndicator }, checked: !(props.value == null), onChange: (_, data) => {
                                        if (data.checked) {
                                            // if checked this means we are returning to non-null, use cached value if exists. If no cached value, use default value
                                            cachedVal.current != null ? props.onChange(cachedVal.current) : props.onChange(props.defaultValue);
                                        }
                                        else {
                                            // if moving to un-checked state, this means moving to null value. Cache the old value and tell props.onChange(null)
                                            cachedVal.current = props.value;
                                            props.onChange(null);
                                        }
                                    } }) })), jsx("div", { className: classes.childWrapper, children: processedChildren }), onCopy && !disableCopy && (jsx(Tooltip, { content: "Copy to Clipboard", children: jsx(Button, { className: classes.copy, appearance: "transparent", icon: size === "small" ? Copy16Regular : CopyRegular, onClick: handleCopy }) }))] })] }), expandedContent && (jsx(Collapse, { visible: !!expanded, children: jsx("div", { className: classes.expandedContentDiv, children: expandedContent }) }))] }));
});
const useLineStyles = makeStyles({
    container: {
        width: "100%",
        display: "flex",
        flexDirection: "column", // Stack line + expanded content
        minHeight: CustomTokens.lineHeight,
        boxSizing: "border-box",
        justifyContent: "center",
        paddingTop: tokens.spacingVerticalXXS,
        paddingBottom: tokens.spacingVerticalXXS,
        borderTop: `1px solid transparent`,
        borderBottom: `1px solid transparent`,
        ":hover": {
            borderTopColor: tokens.colorNeutralStroke2,
            borderBottomColor: tokens.colorNeutralStroke2,
        },
    },
    containerSmall: {
        minHeight: CustomTokens.lineHeightSmall,
    },
});
const LineContainer = forwardRef((props, ref) => {
    const { size } = useContext(ToolContext);
    const classes = useLineStyles();
    return (jsx("div", { ref: ref, className: mergeClasses(classes.container, size == "small" ? classes.containerSmall : undefined), ...props, children: props.children }));
});
const PlaceholderPropertyLine = (props) => {
    return (jsx(PropertyLine, { ...props, children: jsx(Body1, { children: props.value }) }));
};

/**
 * Wraps a link in a property line
 * @param props - PropertyLineProps and LinkProps
 * @returns property-line wrapped link
 */
const LinkPropertyLine = (props) => {
    LinkPropertyLine.displayName = "LinkPropertyLine";
    return (jsx(PropertyLine, { ...props, children: jsx(Link, { ...props }) }));
};

/**
 * A property line that links to a specific entity in the scene.
 * @param props an entity and a selection service
 * @returns A link property line component.
 */
const LinkToEntityPropertyLine = (props) => {
    const { selectionService, entity, ...rest } = props;
    const [linkedEntity, setLinkedEntity] = useState(entity);
    useEffect(() => {
        setLinkedEntity(props.entity);
    }, [props.entity]);
    return (linkedEntity &&
        !linkedEntity.reservedDataStore?.hidden && jsx(LinkPropertyLine, { ...rest, value: linkedEntity.name, onLink: () => (selectionService.selectedEntity = linkedEntity) }));
};

const useStyles$R = makeStyles({
    accordion: {
        overflowX: "hidden",
        overflowY: "auto",
        paddingBottom: tokens.spacingVerticalM, // bottom padding since there is no divider at the bottom
        display: "flex",
        flexDirection: "column",
        height: "100%",
    },
    divider: {
        paddingTop: CustomTokens.dividerGap,
        paddingBottom: CustomTokens.dividerGap,
    },
    dividerSmall: {
        paddingTop: CustomTokens.dividerGapSmall,
        paddingBottom: CustomTokens.dividerGapSmall,
    },
    panelDiv: {
        display: "flex",
        flexDirection: "column",
        overflow: "hidden",
    },
    highlightDiv: {
        borderRadius: tokens.borderRadiusLarge,
        animationDuration: "1s",
        animationTimingFunction: "ease-in-out",
        animationIterationCount: "5",
        animationFillMode: "forwards",
        animationName: {
            from: {
                boxShadow: `inset 0 0 4px ${tokens.colorTransparentBackground}`,
            },
            // eslint-disable-next-line @typescript-eslint/naming-convention
            "50%": {
                boxShadow: `inset 0 0 12px ${tokens.colorBrandBackground}`,
            },
            to: {
                boxShadow: `inset 0 0 4px ${tokens.colorTransparentBackground}`,
            },
        },
    },
});
const AccordionSection = (props) => {
    AccordionSection.displayName = "AccordionSection";
    const classes = useStyles$R();
    return jsx("div", { className: classes.panelDiv, children: props.children });
};
const StringAccordion = Accordion$1;
const Accordion = forwardRef((props, ref) => {
    Accordion.displayName = "Accordion";
    const classes = useStyles$R();
    const { size } = useContext(ToolContext);
    const { children, highlightSections, ...rest } = props;
    const validChildren = useMemo(() => {
        return (Children.map(children, (child) => {
            if (isValidElement(child)) {
                const childProps = child.props;
                if (childProps.title) {
                    return {
                        title: childProps.title,
                        collapseByDefault: childProps.collapseByDefault,
                        content: child,
                    };
                }
            }
            return null;
        })?.filter(Boolean) ?? []);
    }, [children]);
    // Tracks open items, and used to tell the Accordion which sections should be expanded.
    const [openItems, setOpenItems] = useState(validChildren.filter((child) => !child.collapseByDefault).map((child) => child.title));
    // Tracks closed items, which is needed so that when the children change, we only update the open/closed state
    // (depending on the collapseByDefault prop) for items that have not been explicitly opened or closed.
    const [closedItems, setClosedItems] = useState(validChildren.filter((child) => child.collapseByDefault).map((child) => child.title));
    const internalOpenItemsRef = useRef(openItems);
    // When highlight sections is requested, we temporarily override the open items, but if highlight sections is cleared,
    // then we revert back to the normal open items tracking.
    useLayoutEffect(() => {
        if (highlightSections) {
            internalOpenItemsRef.current = [...openItems];
            setOpenItems([...highlightSections]);
        }
        else {
            setOpenItems([...(internalOpenItemsRef.current ?? [])]);
            internalOpenItemsRef.current = undefined;
        }
    }, [highlightSections]);
    useEffect(() => {
        for (const defaultOpenItem of validChildren.filter((child) => !child.collapseByDefault).map((child) => child.title)) {
            // If a child is not marked as collapseByDefault, then it should be opened by default, and
            // it is only "default" if it hasn't already been explicitly added to the opened or closed list.
            if (!closedItems.includes(defaultOpenItem) && !openItems.includes(defaultOpenItem)) {
                setOpenItems((prev) => [...prev, defaultOpenItem]);
            }
        }
    }, [validChildren]);
    const onToggle = useCallback((event, data) => {
        if (data.openItems.includes(data.value)) {
            setOpenItems((prev) => [...prev, data.value]);
            setClosedItems((prev) => prev.filter((item) => item !== data.value));
        }
        else {
            setClosedItems((prev) => [...prev, data.value]);
            setOpenItems((prev) => prev.filter((item) => item !== data.value));
        }
    }, []);
    return (jsx(StringAccordion, { ref: ref, className: classes.accordion, collapsible: true, multiple: true, onToggle: onToggle, openItems: openItems, ...rest, children: validChildren.map((child, index) => {
            const isHighlighted = highlightSections?.includes(child.title);
            return (jsxs(AccordionItem, { value: child.title, children: [jsxs("div", { className: isHighlighted ? classes.highlightDiv : undefined, children: [jsx(AccordionHeader, { size: size, children: jsx(Subtitle2Stronger, { children: child.title }) }), jsx(AccordionPanel, { children: jsx("div", { className: classes.panelDiv, children: child.content }) })] }), index < validChildren.length - 1 && jsx(Divider, { inset: true, className: size === "small" ? classes.dividerSmall : classes.divider })] }, child.content.key ?? child.title));
        }) }));
});

const CompactModeStorageKey = "Babylon/Settings/IsCompactMode";
const SidePaneDockOverridesStorageKey = "Babylon/Settings/SidePaneDockOverrides";
const DisableCopyStorageKey = "Babylon/Settings/DisableCopy";
function useSetting(storageKey, defaultValue) {
    const [value, setValue, resetValue] = useLocalStorage(storageKey, defaultValue);
    if (!localStorage.getItem(storageKey)) {
        localStorage.setItem(storageKey, JSON.stringify(value));
    }
    return [value, setValue, resetValue];
}
/**
 * Gets the compact mode setting.
 * @returns A tuple containing the current compact mode value, a function to update it, and a function to reset it.
 */
function useCompactMode() {
    return useSetting(CompactModeStorageKey, !matchMedia("(pointer: coarse)").matches);
}
/**
 * Gets the disable copy setting.
 * @returns A tuple containing the current disable copy value, a function to update it, and a function to reset it.
 */
function useDisableCopy() {
    return useSetting(DisableCopyStorageKey, false);
}
/**
 * Gets the side pane dock overrides configuration.
 * @returns A record mapping side pane IDs to their dock locations.
 */
function useSidePaneDockOverrides() {
    return useSetting(SidePaneDockOverridesStorageKey, {});
}
const RadiansToDegrees = 180 / Math.PI;
function WrapAngle(angle) {
    angle %= Math.PI * 2;
    if (angle < 0) {
        angle += Math.PI * 2;
    }
    return angle;
}
/**
 * Gets functions used to convert to/from display values for angles based on the current settings.
 * @param settings The settings context to use for determining if angles should be displayed in degrees or radians.
 * @returns A tuple containing the functions to convert to and from display values.
 */
function useAngleConverters(settings) {
    const useDegrees = useObservableState(() => settings.useDegrees, settings.settingsChangedObservable);
    const toDisplayValue = useCallback((angle, wrap = false) => {
        if (wrap) {
            angle = WrapAngle(angle);
        }
        return useDegrees ? angle * RadiansToDegrees : angle;
    }, [useDegrees]);
    const fromDisplayValue = useCallback((angle, wrap = false) => {
        angle = useDegrees ? angle / RadiansToDegrees : angle;
        if (wrap) {
            angle = WrapAngle(angle);
        }
        return angle;
    }, [useDegrees]);
    return [toDisplayValue, fromDisplayValue, useDegrees];
}

const UXContextProvider = (props) => {
    const [compactMode] = useCompactMode();
    const [disableCopy] = useDisableCopy();
    const toolsContext = useMemo(() => {
        return {
            toolName: "",
            size: compactMode ? "small" : "medium",
            disableCopy,
            useFluent: true,
        };
    }, [compactMode, disableCopy]);
    return jsx(ToolContext.Provider, { value: toolsContext, children: props.children });
};

function AsReadonlyArray(array) {
    return array;
}
const useStyles$Q = makeStyles({
    rootDiv: {
        flex: 1,
        overflow: "hidden",
        display: "flex",
        flexDirection: "column",
    },
});
function ExtensibleAccordion(props) {
    const classes = useStyles$Q();
    const { children, sections, sectionContent, context, sectionsRef } = props;
    const defaultSections = useMemo(() => {
        const defaultSections = [];
        if (children) {
            Children.forEach(children, (child) => {
                if (isValidElement(child)) {
                    const childProps = child.props;
                    defaultSections.push({
                        identity: childProps.title,
                        collapseByDefault: childProps.collapseByDefault,
                    });
                }
            });
        }
        return AsReadonlyArray(defaultSections);
    }, [children]);
    const defaultSectionContent = useMemo(() => {
        const defaultSectionContent = [];
        if (children) {
            Children.forEach(children, (child, index) => {
                if (isValidElement(child)) {
                    const childProps = child.props;
                    defaultSectionContent.push({
                        key: child.key ?? childProps.title,
                        section: defaultSections[index].identity,
                        component: () => child,
                    });
                }
            });
        }
        return AsReadonlyArray(defaultSectionContent);
    }, [children, defaultSections]);
    const mergedSectionContent = useMemo(() => {
        return AsReadonlyArray([...defaultSectionContent, ...sectionContent].map((content, index) => {
            return {
                ...content,
                key: `${content.key}-${index}`,
                order: content.order ?? index,
            };
        }));
    }, [defaultSectionContent, sectionContent]);
    const mergedSections = useMemo(() => {
        const mergedSections = [...defaultSections, ...sections];
        // Check for implicit sections (e.g. sections that were not explicitly defined, but referenced by content).
        const implicitSections = [];
        for (const sectionContent of mergedSectionContent) {
            if (!mergedSections.some((s) => s.identity === sectionContent.section) && !implicitSections.some((s) => s.identity === sectionContent.section)) {
                implicitSections.push({ identity: sectionContent.section });
            }
        }
        return AsReadonlyArray([...implicitSections, ...mergedSections].map((section, index) => {
            return {
                ...section,
                order: section.order ?? index,
                collapseByDefault: section.collapseByDefault ?? false,
            };
        }));
    }, [defaultSections, sections, mergedSectionContent]);
    const visibleSections = useMemo(() => {
        if (!context) {
            return [];
        }
        const sortedSections = [...mergedSections].sort((a, b) => a.order - b.order);
        return sortedSections
            .map((section) => {
            // Get a flat list of the section content, preserving the key so it can be used when each component for each section is rendered.
            const contentForSection = mergedSectionContent.filter((content) => content.section === section.identity);
            // If there is no content for this section, we skip it.
            if (contentForSection.length === 0) {
                return null; // No content for this section
            }
            // Sort the content for this section by order, defaulting to 0 if not specified.
            contentForSection.sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
            // Return the section with its identity, collapseByDefault flag, and the content components to render.
            return {
                identity: section.identity,
                collapseByDefault: section.collapseByDefault ?? false,
                components: contentForSection.map((content) => jsx(content.component, { context: context }, content.key)),
            };
        })
            .filter((section) => section !== null);
    }, [mergedSections, mergedSectionContent, context]);
    const [highlightSections, setHighlightSections] = useState();
    // When the context changes, clear any existing highlights.
    useLayoutEffect(() => {
        setHighlightSections(undefined);
    }, [context]);
    // This just assigns the returned object to any type of React ref, whether it is
    // a mutable ref with a 'current' property or whether it is a callback, useImperativeHandle
    // will deal with it.
    useImperativeHandle(sectionsRef, () => {
        return {
            highlightSections: (sectionsToHighlight) => {
                if (sectionsToHighlight.length > 0) {
                    setHighlightSections(sectionsToHighlight);
                }
            },
        };
    }, []);
    return (jsx("div", { className: classes.rootDiv, children: visibleSections.length > -1 && (jsx(UXContextProvider, { children: jsxs(Accordion, { highlightSections: highlightSections, children: [...visibleSections.map((section) => {
                        return (jsx(AccordionSection, { title: section.identity, collapseByDefault: section.collapseByDefault, children: section.components }, section.identity));
                    })] }) })) }));
}

const useStyles$P = makeStyles({
    paneRootDiv: {
        display: "flex",
        flex: 1,
        flexDirection: "column",
        padding: `0 ${tokens.spacingHorizontalM}`,
    },
});
/**
 * Used to apply common styles to panes.
 */
const SidePaneContainer = forwardRef((props, ref) => {
    const { className, ...rest } = props;
    const classes = useStyles$P();
    return (jsx("div", { className: mergeClasses(classes.paneRootDiv, className), ref: ref, ...rest, children: props.children }));
});

const ThemeModeStorageKey = `Babylon/Settings/ThemeMode`;
/**
 * Custom hook to manage the theme mode (system/dark/light).
 * @returns An object containing the theme mode state and helper functions.
 */
function useThemeMode() {
    const { isDarkMode, ternaryDarkMode, setTernaryDarkMode } = useTernaryDarkMode({
        localStorageKey: ThemeModeStorageKey,
    });
    // Make sure there is a stored value initially, even before changing the theme.
    // This way, other usages of this hook will get the correct initial value.
    if (!localStorage.getItem(ThemeModeStorageKey)) {
        SetThemeMode(ternaryDarkMode);
    }
    return { isDarkMode, themeMode: ternaryDarkMode, setThemeMode: setTernaryDarkMode };
}
/**
 * Sets the theme mode.
 * @param mode The desired theme mode (system/dark/light).
 */
function SetThemeMode(mode) {
    localStorage.setItem(ThemeModeStorageKey, JSON.stringify(mode));
}

// Generated from https://react.fluentui.dev/?path=/docs/theme-theme-designer--docs
// Key color: #3A94FC
/* eslint-disable @typescript-eslint/naming-convention */
const BabylonRamp = {
    10: "#020305",
    20: "#121721",
    30: "#1A263A",
    40: "#1F314F",
    50: "#243E64",
    60: "#294B7B",
    70: "#2D5892",
    80: "#3166AA",
    90: "#3473C3",
    100: "#3782DC",
    110: "#3990F6",
    120: "#5A9EFD",
    130: "#7BACFE",
    140: "#96BAFF",
    150: "#AFC9FF",
    160: "#C6D8FF",
};
/* eslint-enable @typescript-eslint/naming-convention */
const LightTheme = {
    ...createLightTheme(BabylonRamp),
    // Reduce the max contrast between foreground and background by just replacing the most intense foreground color with the second most intense one.
    colorNeutralForeground1: tokens.colorNeutralForeground2,
};
const DarkTheme = {
    ...createDarkTheme(BabylonRamp),
    // Reduce the max contrast between foreground and background by just replacing the most intense foreground color with the second most intense one.
    colorNeutralForeground1: tokens.colorNeutralForeground2,
};

const Theme = (props) => {
    // NOTE: We do not want to applyStylesToPortals by default. If makes classes flow into portals
    // (like popovers), and if those styles do things like disable overflow, they can completely
    // break any UI within the portal. Therefore, default to false.
    const { invert = false, applyStylesToPortals = false, ...rest } = props;
    const { isDarkMode } = useThemeMode();
    return (jsx(FluentProvider, { theme: isDarkMode !== invert ? DarkTheme : LightTheme, applyStylesToPortals: applyStylesToPortals, ...rest, children: props.children }));
};

const useStyles$O = makeStyles({
    extensionTeachingPopover: {
        maxWidth: "320px",
    },
});
/**
 * A component that displays a teaching moment popover.
 * @param props Props for the teaching moment popover.
 * @returns The teaching moment popover.
 */
const TeachingMoment = ({ shouldDisplay, positioningRef, onOpenChange, title, description }) => {
    const classes = useStyles$O();
    return (jsx(TeachingPopover, { appearance: "brand", open: shouldDisplay, positioning: { positioningRef }, onOpenChange: onOpenChange, children: jsxs(TeachingPopoverSurface, { className: classes.extensionTeachingPopover, children: [jsx(TeachingPopoverHeader, { children: title }), jsx(TeachingPopoverBody, { children: description })] }) }));
};

/**
 * A simple extension feed implementation that provides a fixed set of "built in" extensions.
 * "Built in" in this context means extensions that are known at bundling time, and included
 * in the bundle. Each extension can be dynamically imported so they are split into separate
 * bundle chunks and downloaded only when first installed.
 */
class BuiltInsExtensionFeed {
    constructor(name, extensions) {
        this.name = name;
        this._extensions = Array.from(extensions);
    }
    async queryExtensionsAsync(filter) {
        const filteredExtensions = filter ? this._extensions.filter((extension) => extension.name.includes(filter)) : this._extensions;
        return {
            totalCount: filteredExtensions.length,
            getExtensionMetadataAsync: async (index, count) => {
                return filteredExtensions.slice(index, index + count);
            },
        };
    }
    async getExtensionModuleAsync(name) {
        const extension = this._extensions.find((ext) => ext.name === name);
        return extension ? await extension.getExtensionModuleAsync() : undefined;
    }
}

/**
 * Creates a polling observable that notifies its observers at a specified interval.
 * @param delay The polling interval in milliseconds.
 * @returns A readonly observable that can be used to subscribe to polling notifications.
 */
function usePollingObservable(delay) {
    const observable = useMemo(() => new Observable(), []);
    useEffect(() => {
        const intervalId = setInterval(() => {
            observable.notifyObservers();
        }, delay);
        return () => {
            clearInterval(intervalId);
        };
    }, [delay, observable]);
    return observable;
}

/**
 * Custom hook to manage a resource with automatic disposal. The resource is created once initially, and recreated
 * if the factory function changes. Whenever the resource is recreated, the previous instance is disposed. The final
 * instance is disposed when the component using this hook unmounts.
 * @param factory A function that creates the resource.
 * @returns The created resource.
 */
function useResource(factory) {
    const resourceRef = useRef();
    const factoryRef = useRef(factory);
    // Initialize resource synchronously on first call or when factory changes
    if (!resourceRef.current || factoryRef.current !== factory) {
        // Dispose old resource if it exists
        resourceRef.current?.dispose();
        // Create new resource
        resourceRef.current = factory();
    }
    // Update refs to capture latest values
    factoryRef.current = factory;
    // Cleanup effect for component unmount
    useEffect(() => {
        return () => {
            resourceRef.current?.dispose();
            resourceRef.current = undefined;
        };
    }, []);
    return resourceRef.current;
}
/**
 * Custom hook to manage an asynchronous resource with automatic disposal. The resource is created once initially, and recreated
 * if the factory function changes. Whenever the resource is recreated, the previous instance is disposed. The final
 * instance is disposed when the component using this hook unmounts.
 * @param factory A function that creates the resource.
 * @returns The created resource.
 */
function useAsyncResource(factory) {
    const [resource, setResource] = useState();
    const factoryRef = useRef(factory);
    // Update refs to capture latest values
    factoryRef.current = factory;
    useEffect(() => {
        const abortController = new AbortController();
        // Dispose old resource if it exists
        resource?.dispose();
        setResource(undefined);
        // Create new resource
        void (async () => {
            try {
                const newVal = await factory(abortController.signal);
                if (!abortController.signal.aborted) {
                    setResource(newVal); // This will trigger a re-render so the new resource is returned to caller
                }
                else {
                    newVal.dispose();
                }
            }
            catch (error) {
                if (error instanceof Error && error.name === "AbortError") {
                    return;
                }
            }
        })();
        return () => {
            abortController.abort();
            resource?.dispose();
            setResource(undefined);
        };
    }, [factory]);
    return resource;
}

const SequencerLock = new AsyncLock();
/**
 * Creates a hook for managing teaching moment state.
 * @param name The unique name of the teaching moment.
 * @returns A hook that returns the teaching moment state.
 */
function MakeTeachingMoment(name) {
    return (suppress) => {
        const [hasDisplayed, setHasDisplayed, resetDisplayed] = useLocalStorage(`Babylon/TeachingMoments/${name}`, false);
        const [shouldDisplay, setShouldDisplay] = useState(false);
        const deferredRef = useRef();
        useEffect(() => {
            if (!hasDisplayed && !suppress && !deferredRef.current) {
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                SequencerLock.lockAsync(async () => {
                    deferredRef.current = new Deferred();
                    setShouldDisplay(true);
                    // Just hold the lock until the hook cleanup, which is effectively component unmount (e.g. the teaching moment is dismissed).
                    await deferredRef.current.promise;
                });
            }
            return () => {
                deferredRef.current?.resolve();
            };
        }, [hasDisplayed, suppress]);
        const onDismissed = useCallback(() => {
            setHasDisplayed(true);
            deferredRef.current?.resolve();
            deferredRef.current = undefined;
            setShouldDisplay(false);
        }, []);
        return {
            shouldDisplay,
            onDismissed,
            reset: resetDisplayed,
        };
    };
}
/**
 * Creates a hook for managing teaching moment state for a dialog.
 * @param name The unique name of the teaching moment.
 * @returns A hook that returns the teaching moment state for a dialog.
 */
function MakeDialogTeachingMoment(name) {
    const useTeachingMoment = MakeTeachingMoment(name);
    return (suppress) => {
        const { shouldDisplay, onDismissed, reset } = useTeachingMoment(suppress);
        const onOpenChange = useCallback((e, data) => {
            if (!data.open) {
                onDismissed();
            }
        }, []);
        return {
            shouldDisplay,
            onOpenChange,
            reset,
        };
    };
}
/**
 * Creates a hook for managing teaching moment state for a popover.
 * @param name The unique name of the teaching moment.
 * @returns A hook that returns the teaching moment state for a popover.
 */
function MakePopoverTeachingMoment(name) {
    const useDialogTeachingMoment = MakeDialogTeachingMoment(name);
    return (suppress) => {
        const [target, setTarget] = useState(null);
        const [positioningRef, setPositioningRef] = useState(null);
        const { shouldDisplay, onOpenChange, reset } = useDialogTeachingMoment(suppress || !target || !positioningRef);
        useEffect(() => {
            if (target && positioningRef) {
                positioningRef.setTarget(target);
            }
        }, [target, positioningRef]);
        return {
            shouldDisplay,
            positioningRef: setPositioningRef,
            targetRef: setTarget,
            onOpenChange,
            reset,
        };
    };
}

/**
 * A collection of items that can be observed for changes.
 */
class ObservableCollection {
    constructor() {
        this._items = [];
        this._keys = [];
        this._observable = new Observable();
    }
    /**
     * An observable that notifies observers when the collection changes.
     */
    get observable() {
        return this._observable;
    }
    /**
     * The items in the collection.
     */
    get items() {
        return this._items;
    }
    /**
     * Adds an item to the collection.
     * @param item The item to add.
     * @returns A disposable that removes the item from the collection when disposed.
     */
    add(item) {
        const key = Symbol();
        this._items.push(item);
        this._keys.push(key);
        this._observable.notifyObservers();
        return {
            dispose: () => {
                const index = this._keys.indexOf(key);
                this._items.splice(index, 1);
                this._keys.splice(index, 1);
                this._observable.notifyObservers();
            },
        };
    }
}

/**
 * A helper to create a service factory function from a class constructor.
 * @param constructor The class to create a factory function for.
 * @returns A factory function that creates an instance of the class.
 */
function ConstructorFactory(constructor) {
    return (...args) => new constructor(...args);
}

const useStyles$N = makeStyles({
    placeholderDiv: {
        padding: `${tokens.spacingVerticalM} ${tokens.spacingHorizontalM}`,
    },
});
const PropertiesPane = (props) => {
    const classes = useStyles$N();
    const entity = props.context;
    return entity != null ? (jsx(ExtensibleAccordion, { ...props })) : (jsx("div", { className: classes.placeholderDiv, children: jsx(Body1Strong, { italic: true, children: "No entity selected." }) }));
};

const SettingsContextIdentity = Symbol("SettingsContext");

function ToFeaturesString(options) {
    const { defaultWidth, defaultHeight, defaultLeft, defaultTop } = options;
    const features = [];
    if (defaultWidth !== undefined) {
        features.push({ key: "width", value: defaultWidth.toString() });
    }
    if (defaultHeight !== undefined) {
        features.push({ key: "height", value: defaultHeight.toString() });
    }
    if (defaultLeft !== undefined) {
        features.push({ key: "left", value: defaultLeft.toString() });
    }
    if (defaultTop !== undefined) {
        features.push({ key: "top", value: defaultTop.toString() });
    }
    features.push({ key: "location", value: "no" });
    return features.map((feature) => `${feature.key}=${feature.value}`).join(",");
}
/**
 * Allows displaying a child window that can contain child components.
 * @param props Props for the child window.
 * @returns The child window component.
 */
const ChildWindow = (props) => {
    const { id, children, onOpenChange, imperativeRef: imperativeRef } = props;
    const [windowState, setWindowState] = useState();
    const [childWindow, setChildWindow] = useState();
    const storageKey = id ? `Babylon/Settings/ChildWindow/${id}/Bounds` : null;
    // This function is just for creating the child window itself. It is a function because
    // it must be called synchronously in response to a user interaction (e.g. button click),
    // otherwise the browser will block it as a scripted popup.
    const createWindow = useCallback((options = {}) => {
        if (storageKey) {
            // If we are persisting window bounds, but the window is already open, just use the existing bounds.
            // Otherwise, try to load bounds from storage.
            if (childWindow) {
                options.defaultLeft = childWindow.screenX;
                options.defaultTop = childWindow.screenY;
                options.defaultWidth = childWindow.innerWidth;
                options.defaultHeight = childWindow.innerHeight;
            }
            else {
                const savedBounds = localStorage.getItem(storageKey);
                if (savedBounds) {
                    try {
                        const bounds = JSON.parse(savedBounds);
                        options.defaultLeft = bounds.left;
                        options.defaultTop = bounds.top;
                        options.defaultWidth = bounds.width;
                        options.defaultHeight = bounds.height;
                    }
                    catch {
                        Logger.Warn(`Could not parse saved bounds for child window with key ${storageKey}`);
                    }
                }
            }
        }
        // Half width by default.
        if (!options.defaultWidth) {
            options.defaultWidth = window.innerWidth * (2 / 3);
        }
        // Half height by default.
        if (!options.defaultHeight) {
            options.defaultHeight = window.innerHeight * (2 / 3);
        }
        // Horizontally centered by default.
        if (!options.defaultLeft) {
            options.defaultLeft = window.screenX + (window.innerWidth - options.defaultWidth) * (2 / 3);
        }
        // Vertically centered by default.
        if (!options.defaultTop) {
            options.defaultTop = window.screenY + (window.innerHeight - options.defaultHeight) * (2 / 3);
        }
        // Try to create the child window (can be null if popups are blocked).
        const newChildWindow = window.open("", "", ToFeaturesString(options));
        if (newChildWindow) {
            // Set the title if provided.
            newChildWindow.document.title = options.title ?? id ?? "";
            // Set the child window state.
            setChildWindow((current) => {
                // But first close any existing child window.
                current?.close();
                return newChildWindow;
            });
        }
    }, [childWindow, storageKey]);
    useImperativeHandle(imperativeRef, () => {
        return {
            open: createWindow,
            close: () => setChildWindow(undefined),
        };
    }, [createWindow]);
    // This side effect runs any time the child window instance changes. It does the rest of the child window
    // setup work, including creating resources and state needed to properly render the content of the child window.
    useEffect(() => {
        const disposeActions = [];
        if (childWindow) {
            const body = childWindow.document.body;
            body.style.width = "100%";
            body.style.height = "100%";
            body.style.margin = "0";
            body.style.padding = "0";
            body.style.display = "flex";
            body.style.overflow = "hidden";
            const applyWindowState = () => {
                // Setup the window state, including creating a Fluent/Griffel "renderer" for managing runtime styles/classes in the child window.
                setWindowState({ mountNode: body, renderer: createDOMRenderer(childWindow.document) });
                onOpenChange?.(true);
            };
            // Once the child window document is ready, setup the window state which will trigger another effect that renders into the child window.
            if (childWindow.document.readyState === "complete") {
                applyWindowState();
            }
            else {
                const onChildWindowLoad = () => {
                    applyWindowState();
                };
                childWindow.addEventListener("load", onChildWindowLoad, { once: true });
                disposeActions.push(() => childWindow.removeEventListener("load", onChildWindowLoad));
            }
            // When the child window is closed for any reason, transition back to a closed state.
            const onChildWindowUnload = () => {
                setWindowState(undefined);
                setChildWindow(undefined);
                onOpenChange?.(false);
            };
            childWindow.addEventListener("unload", onChildWindowUnload, { once: true });
            disposeActions.push(() => childWindow.removeEventListener("unload", onChildWindowUnload));
            // If the main window closes, close any open child windows as well (don't leave them orphaned).
            const onParentWindowUnload = () => {
                childWindow.close();
            };
            window.addEventListener("unload", onParentWindowUnload, { once: true });
            disposeActions.push(() => window.removeEventListener("unload", onParentWindowUnload));
            // On dispose, close the child window.
            disposeActions.push(() => childWindow.close());
            // On dispose, save the window bounds.
            disposeActions.push(() => {
                if (storageKey) {
                    localStorage.setItem(storageKey, JSON.stringify({
                        left: childWindow.screenX,
                        top: childWindow.screenY,
                        width: childWindow.innerWidth,
                        height: childWindow.innerHeight,
                    }));
                }
            });
        }
        return () => {
            disposeActions.reverse().forEach((dispose) => dispose());
        };
    }, [childWindow]);
    if (!windowState) {
        return null;
    }
    const { mountNode, renderer } = windowState;
    return (
    // Portal targets the body of the child window.
    jsx(Portal, { mountNode: mountNode, children: jsx(RendererProvider, { renderer: renderer, targetDocument: mountNode.ownerDocument, children: jsx(FluentProvider, { style: {
                    display: "flex",
                    flexGrow: 1,
                    flexDirection: "column",
                    overflow: "hidden",
                }, applyStylesToPortals: false, targetDocument: mountNode.ownerDocument, children: jsx(ToastProvider, { children: children }) }) }) }));
};

// NOTE: This is basically a super simplified version of https://github.com/microsoft/fluentui-contrib/blob/main/packages/react-resize-handle/src/hooks
// This version does not support keyboard interactions, absolute values, automatically clamping to the actual adjusted size, accessibility, and various other features.
// We can switch back to Fluent's implementation once some known bugs are fixed:
// 1. https://github.com/microsoft/fluentui-contrib/issues/523
// 2. React 19 compatibility
/**
 * A custom hook that helps with element resizing.
 * @param params The parameters for the resize handle.
 * @returns An object containing refs and a function to set the value.
 */
function useResizeHandle(params) {
    const { growDirection, variableName, onChange } = params;
    const valueRef = useRef(0);
    const [elementRef, setElementRef] = useState(null);
    const [handleRef, setHandleRef] = useState(null);
    const updateElementStyle = useCallback((value) => {
        if (elementRef) {
            elementRef.style.setProperty(variableName, `${value}px`);
        }
    }, [elementRef, variableName]);
    const setValue = useCallback((value) => {
        valueRef.current = value;
        updateElementStyle(value);
        onChange?.(value);
    }, [updateElementStyle, onChange]);
    useEffect(() => {
        updateElementStyle(valueRef.current);
    }, [updateElementStyle]);
    useEffect(() => {
        if (handleRef) {
            let delta = 0;
            const coerceDelta = (delta) => Clamp(delta, params.minValue ?? -Infinity, params.maxValue ?? Infinity);
            const onPointerMove = (event) => {
                event.preventDefault();
                switch (growDirection) {
                    case "up":
                        delta -= event.movementY;
                        break;
                    case "down":
                        delta += event.movementY;
                        break;
                    case "start":
                        delta -= event.movementX;
                        break;
                    case "end":
                        delta += event.movementX;
                        break;
                }
                setValue(coerceDelta(delta));
            };
            const onPointerDown = (event) => {
                event.preventDefault();
                delta = valueRef.current;
                handleRef.setPointerCapture(event.pointerId);
                handleRef.addEventListener("pointermove", onPointerMove);
            };
            const onPointerUp = (event) => {
                event.preventDefault();
                handleRef.releasePointerCapture(event.pointerId);
                handleRef.removeEventListener("pointermove", onPointerMove);
                valueRef.current = coerceDelta(valueRef.current);
            };
            handleRef.addEventListener("pointerdown", onPointerDown);
            handleRef.addEventListener("pointerup", onPointerUp);
        }
    }, [handleRef, setValue]);
    return {
        elementRef: setElementRef,
        handleRef: setHandleRef,
        setValue,
    };
}

const RootComponentServiceIdentity = Symbol("RootComponent");
const ShellServiceIdentity = Symbol("ShellService");
const useStyles$M = makeStyles({
    mainView: {
        flex: 1,
        display: "flex",
        flexDirection: "column",
        overflow: "hidden",
        backgroundColor: tokens.colorTransparentBackground,
    },
    verticallyCentralContent: {
        flexGrow: 1,
        display: "flex",
        overflow: "hidden",
        backgroundColor: tokens.colorTransparentBackground,
    },
    barDiv: {
        display: "flex",
        flexDirection: "row",
        flex: "0 0 auto",
        height: "36px",
        backgroundColor: tokens.colorNeutralBackground2,
        pointerEvents: "auto",
    },
    bar: {
        display: "flex",
        flex: "1",
        height: "32px",
        overflow: "hidden",
        padding: `${tokens.spacingVerticalXXS} ${tokens.spacingHorizontalXXS}`,
        border: `1px solid ${tokens.colorNeutralStroke2}`,
        borderBottomWidth: 0,
        backgroundColor: tokens.colorNeutralBackground1,
    },
    barTop: {
        borderTopWidth: 0,
    },
    barLeft: {
        marginRight: "auto",
        display: "flex",
        alignItems: "center",
        flexDirection: "row",
        columnGap: tokens.spacingHorizontalSNudge,
    },
    barRight: {
        marginLeft: "auto",
        display: "flex",
        alignItems: "center",
        flexDirection: "row-reverse",
        columnGap: tokens.spacingHorizontalSNudge,
    },
    barItem: {
        display: "flex",
    },
    paneTabListDiv: {
        backgroundColor: tokens.colorNeutralBackground2,
        flex: "0 0 auto",
        display: "flex",
    },
    paneTabListDivLeft: {
        flexDirection: "row-reverse",
    },
    paneTabListDivRight: {
        flexDirection: "row",
    },
    paneCollapseButton: {
        margin: `0 0 0 ${tokens.spacingHorizontalXS}`,
    },
    collapseMenuPopover: {
        minWidth: 0,
    },
    pane: {
        backgroundColor: tokens.colorNeutralBackground2,
        display: "flex",
        flex: 1,
        alignItems: "stretch",
        overflow: "hidden",
    },
    paneLeft: {
        flexDirection: "row",
    },
    paneRight: {
        flexDirection: "row-reverse",
    },
    paneContainer: {
        display: "flex",
        flexDirection: "column",
        overflowX: "hidden",
        overflowY: "hidden",
        zIndex: 1,
        pointerEvents: "auto",
    },
    paneContent: {
        display: "flex",
        flexGrow: 1,
        flexDirection: "column",
        overflow: "hidden",
    },
    unselectedPane: {
        display: "none",
    },
    paneHeaderDiv: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        height: "36px",
        backgroundColor: tokens.colorNeutralBackground1,
        color: tokens.colorNeutralForeground1,
        border: `1px solid ${tokens.colorNeutralStroke2}`,
    },
    paneHeaderText: {
        flex: 1,
        marginLeft: tokens.spacingHorizontalM,
    },
    paneHeaderButton: {
        color: "inherit",
    },
    paneDivider: {
        flex: "0 0 auto",
        marginTop: tokens.spacingVerticalM,
        margin: "0",
        minHeight: tokens.spacingVerticalM,
        cursor: "ns-resize",
        alignItems: "end",
    },
    tabToolbar: {
        padding: 0,
    },
    tab: {
        display: "flex",
        height: "100%",
        width: "36px",
        justifyContent: "center",
        borderTopLeftRadius: tokens.borderRadiusMedium,
        borderTopRightRadius: tokens.borderRadiusMedium,
    },
    selectedTab: {
        backgroundColor: tokens.colorNeutralBackground1,
        color: tokens.colorNeutralForeground1,
        border: `1px solid ${tokens.colorNeutralStroke2}`,
        borderBottom: "none",
    },
    unselectedTab: {
        backgroundColor: "transparent",
    },
    tabRadioButton: {
        backgroundColor: "transparent",
    },
    selectedTabIcon: {
        color: "inherit",
    },
    resizer: {
        width: "8px",
        cursor: "ew-resize",
        zIndex: 1000,
    },
    resizerLeft: {
        marginRight: "-8px",
        transform: "translateX(-8px)",
    },
    resizerRight: {
        marginLeft: "-8px",
        transform: "translateX(8px)",
    },
    centralContent: {
        position: "relative",
        flexGrow: 1,
        display: "flex",
        overflow: "hidden",
        backgroundColor: tokens.colorTransparentBackground,
        "> *": {
            pointerEvents: "auto",
        },
    },
    expandButtonContainer: {
        position: "absolute",
    },
    expandButtonContainerLeft: {
        left: 0,
    },
    expandButtonContainerRight: {
        right: 0,
    },
    expandButton: {},
});
const DockMenu = (props) => {
    const { openOnContext, sidePaneId, dockOptions, children } = props;
    const dockLeft = dockOptions.get("full-left");
    const dockTopLeft = dockOptions.get("top-left");
    const dockBottomLeft = dockOptions.get("bottom-left");
    const dockRight = dockOptions.get("full-right");
    const dockTopRight = dockOptions.get("top-right");
    const dockBottomRight = dockOptions.get("bottom-right");
    return (jsxs(Menu, { openOnContext: openOnContext, children: [jsx(MenuTrigger, { disableButtonEnhancement: true, children: children }), jsx(Theme, { children: jsx(MenuPopover, { children: jsx(MenuList, { children: jsxs(MenuGroup, { children: [jsx(MenuGroupHeader, { children: "Dock" }), dockLeft && (jsx(MenuItem, { icon: jsx(LayoutColumnTwoFocusLeftFilled, {}), onClick: () => dockLeft(sidePaneId), children: "Left" })), dockTopLeft && (jsx(MenuItem, { icon: jsx(LayoutColumnTwoSplitLeftFocusTopLeftFilled, {}), onClick: () => dockTopLeft(sidePaneId), children: "Top Left" })), dockBottomLeft && (jsx(MenuItem, { icon: jsx(LayoutColumnTwoSplitLeftFocusBottomLeftFilled, {}), onClick: () => dockBottomLeft(sidePaneId), children: "Bottom Left" })), dockRight && (jsx(MenuItem, { icon: jsx(LayoutColumnTwoFocusRightFilled, {}), onClick: () => dockRight(sidePaneId), children: "Right" })), dockTopRight && (jsx(MenuItem, { icon: jsx(LayoutColumnTwoSplitRightFocusTopRightFilled, {}), onClick: () => dockTopRight(sidePaneId), children: "Top Right" })), dockBottomRight && (jsx(MenuItem, { icon: jsx(LayoutColumnTwoSplitRightFocusBottomRightFilled, {}), onClick: () => dockBottomRight(sidePaneId), children: "Bottom Right" }))] }) }) }) })] }));
};
const PaneHeader = (props) => {
    const { id, title, dockOptions } = props;
    const classes = useStyles$M();
    return (jsxs("div", { className: classes.paneHeaderDiv, children: [jsx(Subtitle2Stronger, { className: classes.paneHeaderText, children: title }), jsx(DockMenu, { sidePaneId: id, dockOptions: dockOptions, children: jsx(Button$1, { className: classes.paneHeaderButton, appearance: "transparent", icon: jsx(MoreHorizontalRegular, {}) }) })] }));
};
// This is a wrapper for an item in a toolbar that simply adds a teaching moment, which is useful for dynamically added items, possibly from extensions.
const ToolbarItem = ({ verticalLocation, horizontalLocation, id, component: Component, displayName: displayName, suppressTeachingMoment }) => {
    const classes = useStyles$M();
    const useTeachingMoment = useMemo(() => MakePopoverTeachingMoment(`Bar/${verticalLocation}/${horizontalLocation}/${displayName ?? id}`), [displayName, id]);
    const teachingMoment = useTeachingMoment(suppressTeachingMoment);
    return (jsxs(Fragment, { children: [jsx(TeachingMoment, { ...teachingMoment, shouldDisplay: teachingMoment.shouldDisplay && !suppressTeachingMoment, title: displayName ?? "Extension", description: `The "${displayName ?? id}" extension can be accessed here.` }), jsx("div", { className: classes.barItem, ref: teachingMoment.targetRef, children: jsx(Component, {}) })] }));
};
// TODO: Handle overflow, possibly via https://react.fluentui.dev/?path=/docs/components-overflow--docs with priority.
// This component just renders a toolbar with left aligned toolbar items on the left and right aligned toolbar items on the right.
const Toolbar = ({ location, components }) => {
    const classes = useStyles$M();
    const leftComponents = useMemo(() => components.filter((entry) => entry.horizontalLocation === "left"), [components]);
    const rightComponents = useMemo(() => components.filter((entry) => entry.horizontalLocation === "right"), [components]);
    return (jsx(Fragment, { children: components.length > 0 && (jsxs("div", { className: `${classes.bar} ${location === "top" ? classes.barTop : null}`, children: [jsx("div", { className: classes.barLeft, children: leftComponents.map((entry) => (jsx(ToolbarItem, { verticalLocation: location, horizontalLocation: entry.horizontalLocation, id: entry.key, component: entry.component, displayName: entry.displayName, suppressTeachingMoment: entry.suppressTeachingMoment }, entry.key))) }), jsx("div", { className: classes.barRight, children: rightComponents.map((entry) => (jsx(ToolbarItem, { verticalLocation: location, horizontalLocation: entry.horizontalLocation, id: entry.key, component: entry.component, displayName: entry.displayName, suppressTeachingMoment: entry.suppressTeachingMoment }, entry.key))) })] })) }));
};
// This is a wrapper for a tab in a side pane that simply adds a teaching moment, which is useful for dynamically added items, possibly from extensions.
const SidePaneTab = (props) => {
    const { location, id, isSelected, dockOptions, 
    // eslint-disable-next-line @typescript-eslint/naming-convention
    icon: Icon, title, suppressTeachingMoment, } = props;
    const classes = useStyles$M();
    const useTeachingMoment = useMemo(() => MakePopoverTeachingMoment(`Pane/${location}/${title ?? id}`), [title, id]);
    const teachingMoment = useTeachingMoment(suppressTeachingMoment);
    const tabClass = mergeClasses(classes.tab, isSelected ? classes.selectedTab : classes.unselectedTab);
    return (jsxs(Fragment, { children: [jsx(TeachingMoment, { ...teachingMoment, shouldDisplay: teachingMoment.shouldDisplay && !suppressTeachingMoment, title: title ?? "Extension", description: `The "${title ?? id}" extension can be accessed here.` }), jsx("div", { className: tabClass, children: jsx(DockMenu, { openOnContext: true, sidePaneId: id, dockOptions: dockOptions, children: jsx(Tooltip, { content: title ?? id, children: jsx(ToolbarRadioButton, { ref: teachingMoment.targetRef, appearance: "transparent", className: classes.tabRadioButton, name: "selectedTab", value: id, icon: {
                                className: isSelected ? classes.selectedTabIcon : undefined,
                                children: jsx(Icon, {}),
                            } }) }) }) })] }));
};
// This hook provides a side pane container and the tab list.
// In "compact" mode, the tab list is integrated into the pane itself.
// In "full" mode, the returned tab list is later injected into the toolbar.
function usePane(location, defaultWidth, minWidth, sidePanes, onSelectSidePane, dockOperations, toolbarMode, topBarItems, bottomBarItems) {
    const classes = useStyles$M();
    const [topSelectedTab, setTopSelectedTab] = useState();
    const [bottomSelectedTab, setBottomSelectedTab] = useState();
    const [collapsed, setCollapsed] = useState(false);
    const childWindow = useRef(null);
    const [isChildWindowOpen, setIsChildWindowOpen] = useState(false);
    const paneContainerRef = useRef(null);
    const onExpandCollapseClick = useCallback(() => {
        setCollapsed((collapsed) => !collapsed);
    }, []);
    const widthStorageKey = `Babylon/Settings/${location}Pane/WidthAdjust`;
    const heightStorageKey = `Babylon/Settings/${location}Pane/HeightAdjust`;
    const currentSidePanes = useMemo(() => sidePanes.filter((entry) => entry.horizontalLocation === location), [sidePanes, location]);
    const topPanes = useMemo(() => currentSidePanes.filter((entry) => entry.verticalLocation === "top"), [currentSidePanes]);
    const bottomPanes = useMemo(() => currentSidePanes.filter((entry) => entry.verticalLocation === "bottom"), [currentSidePanes]);
    const getValidDockOperations = useCallback((verticalLocation) => {
        const validDockOperations = new Map(dockOperations);
        // Can't re-dock to the current location.
        validDockOperations.delete(`${verticalLocation}-${location}`);
        // Full would mean there are no bottom panes, so this is also re-docking to the current location.
        validDockOperations.delete(`full-${location}`);
        // If there is only one pane left, it can't be docked to the bottom (as this would leave no top panes).
        if (currentSidePanes.length === 1) {
            validDockOperations.delete(`bottom-${location}`);
        }
        return validDockOperations;
    }, [location, dockOperations, currentSidePanes]);
    const validTopDockOptions = useMemo(() => getValidDockOperations("top"), [getValidDockOperations]);
    const validBottomDockOptions = useMemo(() => getValidDockOperations("bottom"), [getValidDockOperations]);
    // Selects a default top tab (during initialization or if the selected tab is removed).
    useEffect(() => {
        if ((topSelectedTab && !topPanes.includes(topSelectedTab)) || (!topSelectedTab && topPanes.length > 0)) {
            setTopSelectedTab(topPanes[0]);
        }
        else if (topSelectedTab && topPanes.length === 0) {
            setTopSelectedTab(undefined);
        }
    }, [topSelectedTab, topPanes]);
    // Selects a default bottom tab (during initialization or if the selected tab is removed).
    useEffect(() => {
        if ((bottomSelectedTab && !bottomPanes.includes(bottomSelectedTab)) || (!bottomSelectedTab && bottomPanes.length > 0)) {
            setBottomSelectedTab(bottomPanes[0]);
        }
        else if (bottomSelectedTab && bottomPanes.length === 0) {
            setBottomSelectedTab(undefined);
        }
    }, [bottomSelectedTab, bottomPanes]);
    // Selects a tab when explicitly requested.
    useEffect(() => {
        const observer = onSelectSidePane.add((key) => {
            const topPane = topPanes.find((entry) => entry.key === key);
            if (topPane) {
                setTopSelectedTab(topPane);
                setCollapsed(false);
            }
            const bottomPane = bottomPanes.find((entry) => entry.key === key);
            if (bottomPane) {
                setBottomSelectedTab(bottomPane);
                setCollapsed(false);
            }
        });
        return () => observer.remove();
    }, [topPanes, bottomPanes, onSelectSidePane]);
    const setUndocked = useCallback((undocked) => {
        if (!undocked) {
            childWindow.current?.close();
        }
        else {
            const paneContainer = paneContainerRef.current;
            if (!paneContainer) {
                // It shouldn't be possible to get here and have this ref be null, but just in case,
                // bail out of the undock operation.
                childWindow.current?.close();
            }
            else {
                // This is the extra buffer needed on top of minWidth to account for window chrome to avoid a horizontal scrollbar.
                const widthBuffer = 4;
                // This offsets the window's top position to account for window chrome/title bar.
                const topOffset = 100;
                // Create the child window with approximately the same location and size as the side pane.
                const bounds = paneContainer.getBoundingClientRect();
                childWindow.current?.open({
                    defaultWidth: Math.max(bounds.width, minWidth + widthBuffer),
                    defaultHeight: bounds.height - topOffset,
                    defaultTop: bounds.top + window.screenY + topOffset,
                    defaultLeft: bounds.left + window.screenX,
                    title: location === "left" ? "Left" : "Right",
                });
            }
        }
    }, [childWindow, location]);
    const expandCollapseButton = useMemo(() => {
        const expandCollapseIcon = location === "left" ? collapsed ? jsx(PanelLeftExpandRegular, {}) : jsx(PanelLeftContractRegular, {}) : collapsed ? jsx(PanelRightExpandRegular, {}) : jsx(PanelRightContractRegular, {});
        return (jsxs(Menu, { positioning: "below-end", children: [jsx(MenuTrigger, { disableButtonEnhancement: true, children: (triggerProps) => (jsx(Tooltip, { content: collapsed ? "Show Side Pane" : "Hide Side Pane", children: jsx(SplitButton, { className: classes.paneCollapseButton, menuButton: triggerProps, primaryActionButton: { onClick: onExpandCollapseClick }, size: "small", appearance: "transparent", icon: expandCollapseIcon }) })) }), jsx(MenuPopover, { className: classes.collapseMenuPopover, children: jsx(MenuList, { children: jsx(MenuItem, { icon: jsx(PictureInPictureEnterRegular, {}), onClick: () => setUndocked(true), children: "Undock" }) }) })] }));
    }, [collapsed, onExpandCollapseClick, location]);
    const createPaneTabList = useCallback((paneComponents, toolbarMode, selectedTab, setSelectedTab, dockOptions) => {
        return (jsx(Fragment, { children: paneComponents.length > 0 && (jsxs("div", { className: `${classes.paneTabListDiv} ${location === "left" || toolbarMode === "compact" ? classes.paneTabListDivLeft : classes.paneTabListDivRight}`, children: [paneComponents.length > 1 && (jsx(Fragment, { children: jsx(Toolbar$1, { className: classes.tabToolbar, checkedValues: { selectedTab: [selectedTab?.key ?? ""] }, onCheckedValueChange: (event, data) => {
                                const tab = paneComponents.find((entry) => entry.key === data.checkedItems[0]);
                                setSelectedTab(tab);
                                setCollapsed(false);
                            }, children: paneComponents.map((entry) => {
                                const isSelected = selectedTab?.key === entry.key;
                                return (jsx(SidePaneTab, { location: location, id: entry.key, title: entry.title, icon: entry.icon, suppressTeachingMoment: entry.suppressTeachingMoment, isSelected: isSelected && !collapsed, dockOptions: dockOptions }, entry.key));
                            }) }) })), toolbarMode === "full" && (jsxs(Fragment, { children: [paneComponents.length > 1 && (jsxs(Fragment, { children: [jsx(Divider, { vertical: true, inset: true, style: { minHeight: 0 } }), " "] })), jsx(Collapse, { visible: !isChildWindowOpen, orientation: "horizontal", children: expandCollapseButton })] }))] })) }));
    }, [location, collapsed, isChildWindowOpen, expandCollapseButton]);
    // This memos the TabList to make it easy for the JSX to be inserted at the top of the pane (in "compact" mode) or returned to the caller to be used in the toolbar (in "full" mode).
    const topPaneTabList = useMemo(() => createPaneTabList(topPanes, toolbarMode, topSelectedTab, setTopSelectedTab, validTopDockOptions), [createPaneTabList, topPanes, toolbarMode, topSelectedTab]);
    const bottomPaneTabList = useMemo(() => createPaneTabList(bottomPanes, "compact", bottomSelectedTab, setBottomSelectedTab, validBottomDockOptions), [createPaneTabList, bottomPanes, bottomSelectedTab]);
    // This manages the CSS variable that controls the width of the side pane.
    const paneWidthAdjustCSSVar = "--pane-width-adjust";
    const { elementRef: paneHorizontalResizeElementRef, handleRef: paneHorizontalResizeHandleRef, setValue: setPaneWidthAdjust, } = useResizeHandle({
        growDirection: location === "left" ? "end" : "start",
        variableName: paneWidthAdjustCSSVar,
        minValue: minWidth - defaultWidth,
        onChange: (value) => {
            // Whenever the width is adjusted, store the value.
            localStorage.setItem(widthStorageKey, value.toString());
        },
    });
    // This manages the CSS variable that controls the height of the bottom pane.
    const paneHeightAdjustCSSVar = "--pane-height-adjust";
    const { elementRef: paneVerticalResizeElementRef, handleRef: paneVerticalResizeHandleRef, setValue: setPaneHeightAdjust, } = useResizeHandle({
        growDirection: "up",
        variableName: paneHeightAdjustCSSVar,
        onChange: (value) => {
            // Whenever the height is adjusted, store the value.
            localStorage.setItem(heightStorageKey, value.toString());
        },
    });
    // This ensures that when the component is first rendered, the CSS variable is set from storage.
    useLayoutEffect(() => {
        const storedPaneWidthAdjust = localStorage.getItem(widthStorageKey);
        if (storedPaneWidthAdjust) {
            setPaneWidthAdjust(Number.parseInt(storedPaneWidthAdjust));
        }
        const storedPaneHeightAdjust = localStorage.getItem(heightStorageKey);
        if (storedPaneHeightAdjust) {
            setPaneHeightAdjust(Number.parseInt(storedPaneHeightAdjust));
        }
    }, []);
    // This effect closes the window if all panes have been removed.
    useEffect(() => {
        if (isChildWindowOpen && topPanes.length === 0 && bottomPanes.length === 0) {
            childWindow.current?.close();
        }
    }, [childWindow, isChildWindowOpen, topPanes, bottomPanes]);
    // This memoizes the pane itself, which may or may not include the tab list, depending on the toolbar mode.
    const corePane = useMemo(() => {
        return (jsxs(Fragment, { children: [toolbarMode === "compact" && (topPanes.length > 1 || topBarItems.length > 0) && (jsx(Fragment, { children: jsxs("div", { className: classes.barDiv, children: [!isChildWindowOpen && location === "left" && expandCollapseButton, topPaneTabList, jsx(Toolbar, { location: "top", components: topBarItems }), !isChildWindowOpen && location === "right" && expandCollapseButton] }) })), topPanes.length > 0 && (jsx("div", { className: classes.paneContent, children: topSelectedTab && (jsxs(Fragment, { children: [jsx(PaneHeader, { id: topSelectedTab.key, title: topSelectedTab.title, dockOptions: validTopDockOptions }), topPanes.map((pane) => (jsx("div", { className: mergeClasses(classes.paneContent, pane.key !== topSelectedTab.key ? classes.unselectedPane : undefined), children: jsx(ErrorBoundary, { name: pane.title, children: jsx(pane.content, {}) }) }, pane.key)))] })) })), topPanes.length > 0 && bottomPanes.length > 0 && jsx(Divider, { ref: paneVerticalResizeHandleRef, className: classes.paneDivider }), bottomPanes.length > 1 && (jsx(Fragment, { children: jsx("div", { className: classes.barDiv, children: bottomPaneTabList }) })), bottomPanes.length > 0 && (jsx("div", { ref: paneVerticalResizeElementRef, className: classes.paneContent, style: { height: `clamp(200px, calc(45% + var(${paneHeightAdjustCSSVar}, 0px)), 100% - 300px)`, flex: "0 0 auto" }, children: bottomSelectedTab && (jsxs(Fragment, { children: [jsx(PaneHeader, { id: bottomSelectedTab.key, title: bottomSelectedTab.title, dockOptions: validBottomDockOptions }), bottomPanes.map((pane) => (jsx("div", { className: mergeClasses(classes.paneContent, pane.key !== bottomSelectedTab.key ? classes.unselectedPane : undefined), children: jsx(ErrorBoundary, { name: pane.title, children: jsx(pane.content, {}) }) }, pane.key)))] })) })), toolbarMode === "compact" && bottomBarItems.length > 0 && (jsx(Fragment, { children: jsx("div", { className: classes.barDiv, children: jsx(Toolbar, { location: "bottom", components: bottomBarItems }) }) }))] }));
    }, [
        topPanes,
        topSelectedTab,
        validTopDockOptions,
        bottomPanes,
        bottomSelectedTab,
        validBottomDockOptions,
        topBarItems,
        bottomBarItems,
        topPaneTabList,
        bottomPaneTabList,
        isChildWindowOpen,
    ]);
    // This deals with docked vs undocked state, where undocked is rendered into a separate window via a portal.
    const pane = useMemo(() => {
        return (jsxs(Fragment, { children: [!isChildWindowOpen && (jsx("div", { ref: paneContainerRef, className: classes.paneContainer, children: (topPanes.length > 0 || bottomPanes.length > 0) && (jsxs("div", { className: `${classes.pane} ${location === "left" ? classes.paneLeft : classes.paneRight}`, children: [jsx(Collapse, { orientation: "horizontal", visible: !collapsed, children: jsx("div", { ref: paneHorizontalResizeElementRef, className: classes.paneContainer, style: { width: `clamp(${minWidth}px, calc(${defaultWidth}px + var(${paneWidthAdjustCSSVar}, 0px)), 1000px)` }, children: corePane }) }), jsx("div", { ref: paneHorizontalResizeHandleRef, className: `${classes.resizer} ${location === "left" ? classes.resizerLeft : classes.resizerRight}`, style: { pointerEvents: `${collapsed ? "none" : "auto"}` } })] })) })), jsx(ChildWindow, { imperativeRef: childWindow, onOpenChange: (isOpen) => setIsChildWindowOpen(isOpen), children: corePane })] }));
    }, [collapsed, corePane]);
    return [topPaneTabList, pane, collapsed, setCollapsed, isChildWindowOpen, setUndocked];
}
function MakeShellServiceDefinition({ leftPaneDefaultWidth = 350, leftPaneMinWidth = 350, rightPaneDefaultWidth = 350, rightPaneMinWidth = 350, toolbarMode = "full", sidePaneRemapper = undefined, } = {}) {
    return {
        friendlyName: "MainView",
        produces: [ShellServiceIdentity, RootComponentServiceIdentity],
        factory: () => {
            const toolbarItemCollection = new ObservableCollection();
            const sidePaneCollection = new ObservableCollection();
            const centralContentCollection = new ObservableCollection();
            const onSelectSidePane = new Observable(undefined, true);
            const onDockChanged = new Observable(undefined, true);
            const leftSidePaneContainerState = {
                isPresent: false,
                isDocked: true,
                dock: () => onDockChanged.notifyObservers({ location: "left", dock: true }),
                undock: () => onDockChanged.notifyObservers({ location: "left", dock: false }),
            };
            const rightSidePaneContainerState = {
                isPresent: false,
                isDocked: true,
                dock: () => onDockChanged.notifyObservers({ location: "right", dock: true }),
                undock: () => onDockChanged.notifyObservers({ location: "right", dock: false }),
            };
            const rootComponent = () => {
                const classes = useStyles$M();
                const [sidePaneDockOverrides, setSidePaneDockOverrides] = useSidePaneDockOverrides();
                // This function returns a promise that resolves after the dock change takes effect so that
                // we can then select the re-docked pane.
                const pendingPaneReselects = useRef([]);
                const updateSidePaneDockOverride = useCallback((key, horizontalLocation, verticalLocation) => {
                    setSidePaneDockOverrides((current) => ({
                        ...current,
                        [key]: { horizontalLocation, verticalLocation },
                    }));
                    pendingPaneReselects.current.push(key);
                }, [setSidePaneDockOverrides]);
                const toolbarItems = useOrderedObservableCollection(toolbarItemCollection);
                const sidePanes = useOrderedObservableCollection(sidePaneCollection);
                const coercedSidePaneCache = useRef(new Map());
                const coercedSidePanes = useMemo(() => {
                    // First pass - apply overrides and respect the side pane mode.
                    const coercedSidePanes = sidePanes
                        .map((sidePaneDefinition) => {
                        let coercedSidePane = coercedSidePaneCache.current.get(sidePaneDefinition.key);
                        if (!coercedSidePane) {
                            coercedSidePane = { ...sidePaneDefinition };
                            coercedSidePaneCache.current.set(sidePaneDefinition.key, coercedSidePane);
                        }
                        const override = sidePaneDockOverrides[sidePaneDefinition.key];
                        if (override) {
                            // Override (user manually re-docked) has the highest priority.
                            coercedSidePane.horizontalLocation = override.horizontalLocation;
                            coercedSidePane.verticalLocation = override.verticalLocation;
                        }
                        else if (sidePaneRemapper) {
                            // A side pane remapper has the next highest priority.
                            const remapping = sidePaneRemapper(sidePaneDefinition);
                            if (!remapping) {
                                coercedSidePane = undefined;
                            }
                            else {
                                coercedSidePane.horizontalLocation = remapping.horizontalLocation;
                                coercedSidePane.verticalLocation = remapping.verticalLocation;
                            }
                        }
                        else {
                            // Otherwise use the default defined location.
                            coercedSidePane.horizontalLocation = sidePaneDefinition.horizontalLocation;
                            coercedSidePane.verticalLocation = sidePaneDefinition.verticalLocation;
                        }
                        return coercedSidePane;
                    })
                        .filter((sidePane) => !!sidePane);
                    // Second pass - correct any invalid state, specifically if there are only bottom panes, force them to be top panes.
                    for (const side of ["left", "right"]) {
                        const topPanes = coercedSidePanes.filter((entry) => entry.horizontalLocation === side && entry.verticalLocation === "top");
                        const bottomPanes = coercedSidePanes.filter((entry) => entry.horizontalLocation === side && entry.verticalLocation === "bottom");
                        if (bottomPanes.length > 0 && topPanes.length === 0) {
                            for (const pane of bottomPanes) {
                                pane.verticalLocation = "top";
                                updateSidePaneDockOverride(pane.key, side, "top");
                            }
                        }
                    }
                    // Cleanup any cached panes that are no longer present.
                    for (const key of coercedSidePaneCache.current.keys()) {
                        if (!coercedSidePanes.some((entry) => entry.key === key)) {
                            coercedSidePaneCache.current.delete(key);
                        }
                    }
                    return coercedSidePanes;
                }, [sidePanes, sidePaneDockOverrides, updateSidePaneDockOverride, sidePaneRemapper]);
                useEffect(() => {
                    for (const paneKey of pendingPaneReselects.current.splice(0)) {
                        onSelectSidePane.notifyObservers(paneKey);
                    }
                }, [coercedSidePanes]);
                const sidePaneDockOperations = useMemo(() => {
                    const sidePaneDockOperations = new Map();
                    for (const side of ["left", "right"]) {
                        const currentSidePanes = coercedSidePanes.filter((entry) => entry.horizontalLocation === side);
                        const dockTop = (sidePaneKey) => {
                            updateSidePaneDockOverride(sidePaneKey, side, "top");
                        };
                        const dockBottom = (sidePaneKey) => {
                            updateSidePaneDockOverride(sidePaneKey, side, "bottom");
                        };
                        if (currentSidePanes.some((entry) => entry.verticalLocation === "bottom")) {
                            // If there are bottom panes, there must also be top panes, and so top and bottom are valid locations.
                            sidePaneDockOperations.set(`top-${side}`, dockTop);
                            sidePaneDockOperations.set(`bottom-${side}`, dockBottom);
                        }
                        else if (currentSidePanes.length > 0) {
                            // If there are only top panes, then full and bottom are valid locations.
                            sidePaneDockOperations.set(`full-${side}`, dockTop);
                            sidePaneDockOperations.set(`bottom-${side}`, dockBottom);
                        }
                        else {
                            // If there are no panes, then only full is a valid location.
                            sidePaneDockOperations.set(`full-${side}`, dockTop);
                        }
                    }
                    return sidePaneDockOperations;
                }, [coercedSidePanes]);
                const hasLeftPanes = coercedSidePanes.some((entry) => entry.horizontalLocation === "left");
                const hasRightPanes = coercedSidePanes.some((entry) => entry.horizontalLocation === "right");
                useEffect(() => {
                    leftSidePaneContainerState.isPresent = hasLeftPanes;
                    rightSidePaneContainerState.isPresent = hasRightPanes;
                    return () => {
                        leftSidePaneContainerState.isPresent = false;
                        rightSidePaneContainerState.isPresent = false;
                    };
                }, [hasLeftPanes, hasRightPanes]);
                // If we are in compact toolbar mode, we may need to move toolbar items from the left to the right or vice versa,
                // depending on whether there are any side panes on that side.
                const coerceToolBarItemHorizontalLocation = useMemo(() => (item) => {
                    let horizontalLocation = item.horizontalLocation;
                    // Coercion is only needed in compact toolbar mode since there might not be a left or right pane.
                    if (toolbarMode === "compact") {
                        if (horizontalLocation === "left" && !hasLeftPanes) {
                            horizontalLocation = "right";
                        }
                        if (horizontalLocation === "right" && !hasRightPanes) {
                            horizontalLocation = "left";
                        }
                    }
                    return horizontalLocation;
                }, [toolbarMode, hasLeftPanes, hasRightPanes]);
                const topToolBarItems = useMemo(() => toolbarItems.filter((entry) => entry.verticalLocation === "top"), [toolbarItems]);
                const bottomToolBarItems = useMemo(() => toolbarItems.filter((entry) => entry.verticalLocation === "bottom"), [toolbarItems]);
                const topBarLeftItems = useMemo(() => topToolBarItems.filter((entry) => coerceToolBarItemHorizontalLocation(entry) === "left"), [topToolBarItems, coerceToolBarItemHorizontalLocation]);
                const topBarRightItems = useMemo(() => topToolBarItems.filter((entry) => coerceToolBarItemHorizontalLocation(entry) === "right"), [topToolBarItems, coerceToolBarItemHorizontalLocation]);
                const bottomBarLeftItems = useMemo(() => bottomToolBarItems.filter((entry) => coerceToolBarItemHorizontalLocation(entry) === "left"), [bottomToolBarItems, coerceToolBarItemHorizontalLocation]);
                const bottomBarRightItems = useMemo(() => bottomToolBarItems.filter((entry) => coerceToolBarItemHorizontalLocation(entry) === "right"), [bottomToolBarItems, coerceToolBarItemHorizontalLocation]);
                const centralContents = useOrderedObservableCollection(centralContentCollection);
                const [leftPaneTabList, leftPane, leftPaneCollapsed, setLeftPaneCollapsed, leftPaneUndocked, setLeftPaneUndocked] = usePane("left", leftPaneDefaultWidth, leftPaneMinWidth, coercedSidePanes, onSelectSidePane, sidePaneDockOperations, toolbarMode, topBarLeftItems, bottomBarLeftItems);
                useEffect(() => {
                    // Propagate shorter lived React component state out to longer lived service state.
                    leftSidePaneContainerState.isDocked = !leftPaneUndocked;
                }, [leftPaneUndocked]);
                const [rightPaneTabList, rightPane, rightPaneCollapsed, setRightPaneCollapsed, rightPaneUndocked, setRightPaneUndocked] = usePane("right", rightPaneDefaultWidth, rightPaneMinWidth, coercedSidePanes, onSelectSidePane, sidePaneDockOperations, toolbarMode, topBarRightItems, bottomBarRightItems);
                useEffect(() => {
                    // Propagate shorter lived React component state out to longer lived service state.
                    rightSidePaneContainerState.isDocked = !rightPaneUndocked;
                }, [rightPaneUndocked]);
                useEffect(() => {
                    // If at the service level dock state change is requested, propagate to the React component state.
                    const observer = onDockChanged.add(({ location, dock }) => {
                        if (location === "left") {
                            setLeftPaneUndocked(!dock);
                        }
                        else {
                            setRightPaneUndocked(!dock);
                        }
                    });
                    return () => {
                        observer.remove();
                        leftSidePaneContainerState.isDocked = true;
                        rightSidePaneContainerState.isDocked = true;
                    };
                }, [setLeftPaneUndocked, setRightPaneUndocked]);
                return (jsxs("div", { className: classes.mainView, children: [toolbarMode === "full" && (jsx(Fragment, { children: jsxs("div", { className: classes.barDiv, children: [leftPaneTabList, jsx(Toolbar, { location: "top", components: topToolBarItems }), rightPaneTabList] }) })), jsxs("div", { className: classes.verticallyCentralContent, children: [leftPane, jsxs("div", { className: classes.centralContent, children: [centralContents.map((entry) => (jsx(ErrorBoundary, { name: entry.key, children: jsx(entry.component, {}) }, entry.key))), toolbarMode === "compact" && (jsxs(Fragment, { children: [jsx(Fade, { visible: leftPaneCollapsed, delay: 50, duration: 100, unmountOnExit: true, children: jsx("div", { className: mergeClasses(classes.expandButtonContainer, classes.expandButtonContainerLeft), children: jsx(Tooltip, { content: "Show Side Pane", children: jsx(Button$1, { className: classes.expandButton, icon: jsx(PanelLeftExpandRegular, {}), onClick: () => setLeftPaneCollapsed(false) }) }) }) }), jsx(Fade, { visible: rightPaneCollapsed, delay: 50, duration: 100, unmountOnExit: true, children: jsx("div", { className: mergeClasses(classes.expandButtonContainer, classes.expandButtonContainerRight), children: jsx(Tooltip, { content: "Show Side Pane", children: jsx(Button$1, { className: classes.expandButton, icon: jsx(PanelRightExpandRegular, {}), onClick: () => setRightPaneCollapsed(false) }) }) }) })] }))] }), rightPane] }), toolbarMode === "full" && (jsx(Fragment, { children: jsx("div", { className: classes.barDiv, children: jsx(Toolbar, { location: "bottom", components: bottomToolBarItems }) }) }))] }));
            };
            rootComponent.displayName = "Shell Service Root";
            return {
                addToolbarItem: (entry) => {
                    if (!entry.component.displayName) {
                        entry.component.displayName = `${entry.key} | ${entry.verticalLocation} ${entry.horizontalLocation} bar item`;
                    }
                    return toolbarItemCollection.add(entry);
                },
                addSidePane: (entry) => {
                    if (!entry.content.displayName) {
                        entry.content.displayName = `${entry.key} | ${entry.horizontalLocation} pane`;
                    }
                    return sidePaneCollection.add(entry);
                },
                addCentralContent: (entry) => centralContentCollection.add(entry),
                resetSidePaneLayout: () => localStorage.removeItem("Babylon/Settings/SidePaneDockOverrides"),
                get leftSidePaneContainer() {
                    return leftSidePaneContainerState.isPresent ? leftSidePaneContainerState : null;
                },
                get rightSidePaneContainer() {
                    return rightSidePaneContainerState.isPresent ? rightSidePaneContainerState : null;
                },
                onDockChanged,
                get sidePanes() {
                    return [...sidePaneCollection.items].map((sidePaneDefinition) => {
                        return {
                            key: sidePaneDefinition.key,
                            select: () => onSelectSidePane.notifyObservers(sidePaneDefinition.key),
                        };
                    });
                },
                rootComponent,
            };
        },
    };
}

const SelectionServiceIdentity = Symbol("PropertiesService");
const SelectionServiceDefinition = {
    friendlyName: "Selection Service",
    produces: [SelectionServiceIdentity],
    consumes: [ShellServiceIdentity, SettingsContextIdentity],
    factory: (shellService, settingsContext) => {
        let selectedEntityState = null;
        const selectedEntityObservable = new Observable();
        let disposedHook = null;
        const setSelectedItem = (item) => {
            if (item !== selectedEntityState) {
                disposedHook?.dispose();
                disposedHook = null;
                selectedEntityState = item;
                selectedEntityObservable.notifyObservers();
                if (item) {
                    const disposable = item;
                    if (disposable.dispose) {
                        disposedHook = InterceptFunction(disposable, "dispose", { afterCall: () => setSelectedItem(null) });
                    }
                }
                // Expose the selected entity through a global variable. This is an Inspector v1 feature that people have found useful.
                globalThis.debugNode = item;
                // Automatically open the properties pane when an entity is selected.
                if (item && settingsContext.showPropertiesOnEntitySelection) {
                    shellService.sidePanes.find((pane) => pane.key === "Properties")?.select();
                }
            }
        };
        return {
            get selectedEntity() {
                return selectedEntityState;
            },
            set selectedEntity(item) {
                setSelectedItem(item);
            },
            onSelectedEntityChanged: selectedEntityObservable,
            dispose: () => selectedEntityObservable.clear(),
        };
    },
};

const PropertiesServiceIdentity = Symbol("PropertiesService");
/**
 * Provides a properties pane that enables displaying and editing properties of an entity such as a mesh or a texture.
 */
const PropertiesServiceDefinition = {
    friendlyName: "Properties Editor",
    produces: [PropertiesServiceIdentity],
    consumes: [ShellServiceIdentity, SelectionServiceIdentity],
    factory: (shellService, selectionService) => {
        const sectionsCollection = new ObservableCollection();
        const sectionContentCollection = new ObservableCollection();
        const onPropertyChanged = new Observable();
        const onHighlightSectionsRequested = new Observable();
        const registration = shellService.addSidePane({
            key: "Properties",
            title: "Properties",
            icon: DocumentTextRegular,
            horizontalLocation: "right",
            verticalLocation: "top",
            order: 100,
            suppressTeachingMoment: true,
            content: () => {
                const sections = useOrderedObservableCollection(sectionsCollection);
                const sectionContent = useObservableCollection(sectionContentCollection);
                const entity = useObservableState(() => selectionService.selectedEntity, selectionService.onSelectedEntityChanged);
                const applicableContent = useMemo(() => entity
                    ? sectionContent
                        .filter((section) => section.predicate(entity))
                        .flatMap((section) => {
                        return section.content.map((content) => {
                            return {
                                key: section.key,
                                section: content.section,
                                order: content.order,
                                component: content.component,
                            };
                        });
                    })
                    : [], [sectionContent, entity]);
                const sectionsRef = useRef(null);
                // The selected entity may be set at the same time as a highlight is requested.
                // To account for this, we need to wait for one React render to complete before
                // requesting the section highlight.
                const [pendingHighlight, setPendingHighlight] = useState();
                useEffect(() => {
                    const observer = onHighlightSectionsRequested.add(setPendingHighlight);
                    return () => observer.remove();
                }, []);
                useEffect(() => {
                    if (pendingHighlight && sectionsRef.current) {
                        sectionsRef.current.highlightSections(pendingHighlight);
                        setPendingHighlight(undefined);
                    }
                }, [pendingHighlight]);
                return (jsx(PropertyContext.Provider, { value: { onPropertyChanged }, children: jsx(PropertiesPane, { sections: sections, sectionContent: applicableContent, context: entity, sectionsRef: sectionsRef }) }));
            },
        });
        return {
            addSection: (section) => sectionsCollection.add(section),
            addSectionContent: (content) => sectionContentCollection.add(content),
            onPropertyChanged,
            highlightSections: (sectionIds) => onHighlightSectionsRequested.notifyObservers(sectionIds),
            dispose: () => registration.dispose(),
        };
    },
};

/**
 * Performs a topological sort on a graph.
 * @param graph The set of nodes that make up the graph.
 * @param getAdjacentNodes A function that returns the adjacent nodes for a given node.
 * @param onSortedNode A function that is called for each node in the sorted order.
 * @remarks
 * This function allocates. Do not use it in the hot path. Instead use an instance of GraphUtils.
 */
function SortGraph(graph, getAdjacentNodes, onSortedNode) {
    const sorter = new GraphUtils();
    sorter.sort(graph, getAdjacentNodes, onSortedNode);
}
/**
 * Traverses a graph.
 * @param graph The set of nodes that make up the graph.
 * @param getAdjacentNodes A function that returns the adjacent nodes for a given node.
 * @param onBeforeTraverse A function that is called before traversing each node.
 * @param onAfterTraverse A function that is called after traversing each node.
 * @remarks
 * This function allocates. Do not use it in the hot path. Instead use an instance of GraphUtils.
 */
function TraverseGraph(graph, getAdjacentNodes, onBeforeTraverse, onAfterTraverse) {
    const traverser = new GraphUtils();
    traverser.traverse(graph, getAdjacentNodes, onBeforeTraverse, onAfterTraverse);
}
/**
 * A utility class for performing graph operations.
 * @remarks
 * The class allocates new objects, but each operation (e.g. sort, traverse) is allocation free. This is useful when used in the hot path.
 */
class GraphUtils {
    constructor() {
        // Tracks three states:
        // 1. No entry for the node - this means the node has not been encountered yet during any traversal
        // 2. Entry with value false - this means the node is currently being traversed (needed to detect cycles)
        // 3. Entry with value true - this means the node has already been fully traversed (and cycles were not detected)
        this._traversalState = new Map();
        this._isTraversing = false;
    }
    /**
     * Performs a topological sort on a graph.
     * @param graph The set of nodes that make up the graph.
     * @param getAdjacentNodes A function that returns the adjacent nodes for a given node.
     * @param onSortedNode A function that is called for each node in the sorted order.
     */
    sort(graph, getAdjacentNodes, onSortedNode) {
        this.traverse(graph, getAdjacentNodes, undefined, onSortedNode);
    }
    /**
     * Traverses a graph.
     * @param graph The set of nodes that make up the graph.
     * @param getAdjacentNodes A function that returns the adjacent nodes for a given node.
     * @param onBeforeTraverse A function that is called before traversing each node.
     * @param onAfterTraverse A function that is called after traversing each node.
     */
    traverse(graph, getAdjacentNodes, onBeforeTraverse, onAfterTraverse) {
        // Since the traversal state is re-used, disallow re-entrancy through the getAdjacentNodes or onBeforeTraverse or onAfterTraverse callbacks.
        if (this._isTraversing) {
            throw new Error("This TopologicalSorter instance is already traversing.");
        }
        this._isTraversing = true;
        try {
            for (const node of graph) {
                this._traverseCore(node, getAdjacentNodes, onBeforeTraverse, onAfterTraverse);
            }
        }
        finally {
            this._isTraversing = false;
            this._traversalState.clear();
        }
    }
    _traverseCore(node, getAdjacentNodes, onBeforeTraverse, onAfterTraverse) {
        if (this._traversalState.get(node) !== true) {
            if (this._traversalState.get(node) === false) {
                throw new Error("Graph has cycle.");
            }
            this._traversalState.set(node, false);
            onBeforeTraverse?.(node);
            const adjacentNodes = getAdjacentNodes(node);
            if (adjacentNodes) {
                for (const adjacentNode of adjacentNodes) {
                    this._traverseCore(adjacentNode, getAdjacentNodes, onBeforeTraverse, onAfterTraverse);
                }
            }
            this._traversalState.set(node, true);
            onAfterTraverse?.(node);
        }
    }
}

const SyntheticUniqueIds = new WeakMap();
function GetEntityId(entity) {
    if (entity.uniqueId !== undefined) {
        return entity.uniqueId;
    }
    let id = SyntheticUniqueIds.get(entity);
    if (!id) {
        SyntheticUniqueIds.set(entity, (id = UniqueIdGenerator.UniqueId));
    }
    return id;
}
function ExpandOrCollapseAll(treeItem, open, openItems) {
    const addOrRemove = open ? openItems.add.bind(openItems) : openItems.delete.bind(openItems);
    TraverseGraph([treeItem], (treeItem) => treeItem.children, (treeItem) => addOrRemove(treeItem.type === "entity" ? GetEntityId(treeItem.entity) : treeItem.sectionName));
}
function useCommandContextMenuState(commands) {
    const [checkedContextMenuItems, setCheckedContextMenuItems] = useState({ toggleCommands: [] });
    useEffect(() => {
        const updateCheckedItems = () => {
            const checkedItems = [];
            for (const command of commands) {
                if (command.type === "toggle" && command.isEnabled) {
                    checkedItems.push(command.displayName);
                }
            }
            setCheckedContextMenuItems({ toggleCommands: checkedItems });
        };
        updateCheckedItems();
        const observers = commands
            .map((command) => command.onChange)
            .filter((onChange) => !!onChange)
            .map((onChange) => onChange.add(updateCheckedItems));
        return () => {
            for (const observer of observers) {
                observer.remove();
            }
        };
    }, [commands]);
    const onContextMenuCheckedValueChange = useCallback((e, data) => {
        for (const command of commands) {
            if (command.type === "toggle") {
                command.isEnabled = data.checkedItems.includes(command.displayName);
            }
        }
    }, [commands]);
    const contextMenuItems = commands.map((command) => command.type === "action" ? (jsx(MenuItem, { icon: command.icon ? jsx(command.icon, {}) : undefined, onClick: () => command.execute(), children: command.displayName }, command.displayName)) : (jsx(MenuItemCheckbox, { 
        // Don't show both a checkmark and an icon. null means no checkmark, undefined means default (checkmark).
        checkmark: command.icon ? null : undefined, icon: command.icon ? jsx(command.icon, {}) : undefined, name: "toggleCommands", value: command.displayName, children: command.displayName }, command.displayName)));
    return [checkedContextMenuItems, onContextMenuCheckedValueChange, contextMenuItems];
}
function CoerceEntityArray(entities, sort) {
    // If sorting is requested, create a copy of the array and sort it by display name.
    if (sort) {
        entities = [...entities];
        entities.sort((left, right) => {
            const leftDisplayInfo = left.getDisplayInfo();
            const rightDisplayInfo = right.getDisplayInfo();
            const comparison = leftDisplayInfo.name.localeCompare(rightDisplayInfo.name);
            leftDisplayInfo.dispose?.();
            rightDisplayInfo.dispose?.();
            return comparison;
        });
    }
    return entities;
}
const useStyles$L = makeStyles({
    rootDiv: {
        flex: 1,
        overflow: "hidden",
        display: "flex",
        flexDirection: "column",
    },
    toolbarDiv: {
        display: "flex",
        flexDirection: "row",
        paddingLeft: tokens.spacingHorizontalM,
        paddingRight: tokens.spacingHorizontalM,
    },
    searchBox: {
        flex: 1,
        padding: 0,
    },
    tree: {
        rowGap: 0,
        overflow: "hidden",
        flex: 1,
        paddingLeft: tokens.spacingHorizontalM,
        paddingRight: tokens.spacingHorizontalM,
    },
    scrollView: {
        overflowX: "hidden",
        // Create a little padding and negative margin to keep correct alignment but make
        // room for the focus ring so it doesn't get clipped.
        paddingLeft: tokens.spacingHorizontalXXS,
        paddingRight: tokens.spacingHorizontalXXS,
        marginLeft: `calc(-1 * ${tokens.spacingHorizontalXXS})`,
        marginRight: `calc(-1 * ${tokens.spacingHorizontalXXS})`,
    },
    treeItem: {
        // Ensure focused items render their focus ring above adjacent selected/hovered items
        "&:focus": {
            zIndex: 1,
        },
    },
    sceneTreeItemLayout: {
        padding: 0,
    },
    treeItemLayoutAside: {
        gap: 0,
        paddingLeft: tokens.spacingHorizontalS,
        paddingRight: tokens.spacingHorizontalS,
    },
    treeItemLayoutMain: {
        flex: "1 1 0",
        overflow: "hidden",
        textOverflow: "ellipsis",
    },
    treeItemLayoutCompact: {
        minHeight: CustomTokens.lineHeightSmall,
        maxHeight: CustomTokens.lineHeightSmall,
    },
    // Use tighter indentation than the default (16px instead of 24px per level)
    treeItemLayoutBranch: {
        paddingLeft: `calc((var(${treeItemLevelToken}, 1) - 1) * ${tokens.spacingHorizontalL})`,
    },
    treeItemLayoutLeaf: {
        paddingLeft: `calc(var(${treeItemLevelToken}, 1) * ${tokens.spacingHorizontalL} + ${tokens.spacingHorizontalS})`,
    },
});
const ActionCommand = (props) => {
    const { command } = props;
    // eslint-disable-next-line @typescript-eslint/naming-convention
    const [displayName, Icon, execute] = useObservableState(useCallback(() => [command.displayName, command.icon, command.execute], [command]), command.onChange);
    return (jsx(Tooltip$1, { content: displayName, relationship: "label", positioning: "after", children: jsx(Button$1, { icon: jsx(Icon, {}), appearance: "subtle", onClick: () => execute() }) }));
};
const ToggleCommand = (props) => {
    const { command } = props;
    // eslint-disable-next-line @typescript-eslint/naming-convention
    const [displayName, Icon, isEnabled] = useObservableState(useCallback(() => [command.displayName, command.icon, command.isEnabled], [command]), command.onChange);
    // TODO-iv2: Consolidate icon prop passing approach for inspector and shared components
    return jsx(ToggleButton, { appearance: "transparent", title: displayName, checkedIcon: Icon, value: isEnabled, onChange: (val) => (command.isEnabled = val) });
};
// This "placeholder" command has a blank icon and is a no-op. It is used for aside
// alignment when some toggle commands are enabled. See more details on the commands
// for setting the aside state.
const PlaceHolderCommand = {
    type: "action",
    displayName: "",
    icon: createFluentIcon("Placeholder", "1em", ""),
    execute: () => {
        /* No-op */
    },
};
function MakeInlineCommandElement(command, isPlaceholder) {
    if (isPlaceholder) {
        // Placeholders are not visible and not interacted with, so they are always ActionCommand
        // components, just to ensure the exact right amount of space is taken up.
        return jsx(ActionCommand, { command: PlaceHolderCommand }, command.displayName);
    }
    return command.type === "action" ? jsx(ActionCommand, { command: command }, command.displayName) : jsx(ToggleCommand, { command: command }, command.displayName);
}
const SceneTreeItem = (props) => {
    const { isSelected, select } = props;
    const classes = useStyles$L();
    const [compactMode] = useCompactMode();
    const treeItemLayoutClass = mergeClasses(classes.sceneTreeItemLayout, compactMode ? classes.treeItemLayoutCompact : undefined);
    return (jsx(FlatTreeItem, { className: classes.treeItem, value: "scene", itemType: "leaf", parentValue: undefined, "aria-level": 1, "aria-setsize": 1, "aria-posinset": 1, onClick: select, children: jsx(TreeItemLayout, { iconBefore: jsx(GlobeRegular, {}), className: treeItemLayoutClass, style: isSelected ? { backgroundColor: tokens.colorNeutralBackground1Selected } : undefined, children: jsx(Body1Strong, { wrap: false, truncate: true, children: "Scene" }) }) }, "scene"));
};
const SectionTreeItem = (props) => {
    const { section, isFiltering, commandProviders, expandAll, collapseAll } = props;
    const classes = useStyles$L();
    const [compactMode] = useCompactMode();
    // Get the commands that apply to this section.
    const commands = useResource(useCallback(() => {
        const commands = [...commandProviders].filter((provider) => provider.predicate(section.sectionName)).map((provider) => provider.getCommand(section.sectionName));
        return Object.assign(commands, {
            dispose: () => commands.forEach((command) => command.dispose?.()),
        });
    }, [section.sectionName, commandProviders]));
    const hasChildren = section.children.length > 0;
    const [checkedContextMenuItems, onContextMenuCheckedValueChange, contextMenuItems] = useCommandContextMenuState(commands);
    return (jsxs(Menu, { openOnContext: true, checkedValues: checkedContextMenuItems, onCheckedValueChange: onContextMenuCheckedValueChange, children: [jsx(MenuTrigger, { disableButtonEnhancement: true, children: jsx(FlatTreeItem, { className: classes.treeItem, value: section.sectionName, 
                    // Disable manual expand/collapse when a filter is active.
                    itemType: !isFiltering && section.children.length > 0 ? "branch" : "leaf", parentValue: undefined, "aria-level": 1, "aria-setsize": 1, "aria-posinset": 1, children: jsx(TreeItemLayout, { className: mergeClasses(classes.treeItemLayoutBranch, compactMode ? classes.treeItemLayoutCompact : undefined), children: jsx(Body1Strong, { wrap: false, truncate: true, children: section.sectionName.substring(0, 100) }) }) }, section.sectionName) }), jsx(MenuPopover, { hidden: !hasChildren && commands.length === 0, children: jsxs(MenuList, { children: [hasChildren && (jsxs(Fragment, { children: [jsx(MenuItem, { onClick: expandAll, children: jsx(Body1, { children: "Expand All" }) }), jsx(MenuItem, { onClick: collapseAll, children: jsx(Body1, { children: "Collapse All" }) })] })), hasChildren && commands.length > 0 && jsx(MenuDivider, {}), contextMenuItems] }) })] }));
};
const EntityTreeItem = (props) => {
    const { entityItem, isSelected, select, isFiltering, commandProviders, expandAll, collapseAll } = props;
    const classes = useStyles$L();
    const [compactMode] = useCompactMode();
    const hasChildren = !!entityItem.children?.length;
    const displayInfo = useResource(useCallback(() => {
        const displayInfo = entityItem.getDisplayInfo();
        if (!displayInfo.dispose) {
            displayInfo.dispose = () => {
                /* No-op */
            };
        }
        return displayInfo;
    }, [entityItem]));
    const name = useObservableState(() => displayInfo.name, displayInfo.onChange);
    // Get the commands that apply to this entity.
    const commands = useResource(useCallback(() => {
        const commands = [...commandProviders]
            .filter((provider) => provider.predicate(entityItem.entity))
            .map((provider) => {
            return {
                order: provider.order,
                command: provider.getCommand(entityItem.entity),
            };
        })
            .sort((a, b) => {
            // Action commands always come before toggle commands, because toggle commands will remain
            // visible when they are enabled, even when the pointer is not hovering the item, and we
            // don't want a bunch of blank space.
            if (a.command.type !== b.command.type) {
                return a.command.type === "action" ? -1 : 1;
            }
            // Within each group of command types, sort by order (default 0) ascending.
            return (a.order ?? 0) - (b.order ?? 0);
        })
            .map((entry) => entry.command);
        return Object.assign(commands, {
            dispose: () => commands.forEach((command) => command.dispose?.()),
        });
    }, [entityItem.entity, commandProviders]));
    const inlineCommands = useMemo(() => commands.filter((command) => command.mode !== "contextMenu"), [commands]);
    // TreeItemLayout actions (totally unrelated to "Action" type commands) are only visible when the item is focused or has pointer hover.
    const actions = useMemo(() => {
        const defaultCommands = [];
        if (hasChildren) {
            defaultCommands.push({
                type: "action",
                displayName: "Expand All",
                icon: () => jsx(ArrowExpandAllRegular, {}),
                execute: () => expandAll(),
            });
        }
        return [...defaultCommands, ...inlineCommands].map((command) => MakeInlineCommandElement(command, false));
    }, [inlineCommands, hasChildren, expandAll]);
    // TreeItemLayout asides are always visible.
    const [aside, setAside] = useState([]);
    // This useEffect keeps the aside up-to-date. What should always show is any enabled toggle command, along with
    // placeholders to the right to keep the position of the actions consistent.
    useEffect(() => {
        const updateAside = () => {
            let isAnyCommandEnabled = false;
            const aside = [];
            for (const command of inlineCommands) {
                isAnyCommandEnabled || (isAnyCommandEnabled = command.type === "toggle" && command.isEnabled);
                if (isAnyCommandEnabled) {
                    aside.push(MakeInlineCommandElement(command, command.type !== "toggle" || !command.isEnabled));
                }
            }
            setAside(aside);
        };
        updateAside();
        const observers = inlineCommands
            .map((command) => command.onChange)
            .filter((onChange) => !!onChange)
            .map((onChange) => onChange.add(updateAside));
        return () => {
            for (const observer of observers) {
                observer.remove();
            }
        };
    }, [inlineCommands]);
    const contextMenuCommands = useMemo(() => commands.filter((command) => command.mode === "contextMenu"), [commands]);
    const [checkedContextMenuItems, onContextMenuCheckedValueChange, contextMenuItems] = useCommandContextMenuState(contextMenuCommands);
    return (jsxs(Menu, { openOnContext: true, checkedValues: checkedContextMenuItems, onCheckedValueChange: onContextMenuCheckedValueChange, children: [jsx(MenuTrigger, { disableButtonEnhancement: true, children: jsx(FlatTreeItem, { className: classes.treeItem, value: GetEntityId(entityItem.entity), 
                    // Disable manual expand/collapse when a filter is active.
                    itemType: !isFiltering && hasChildren ? "branch" : "leaf", parentValue: entityItem.parent.type === "section" ? entityItem.parent.sectionName : GetEntityId(entityItem.entity), "aria-level": entityItem.depth, "aria-setsize": 1, "aria-posinset": 1, onClick: select, style: { [treeItemLevelToken]: entityItem.depth }, children: jsx(TreeItemLayout, { iconBefore: entityItem.icon ? jsx(entityItem.icon, { entity: entityItem.entity }) : null, className: mergeClasses(hasChildren ? classes.treeItemLayoutBranch : classes.treeItemLayoutLeaf, compactMode ? classes.treeItemLayoutCompact : undefined), style: isSelected ? { backgroundColor: tokens.colorNeutralBackground1Selected } : undefined, actions: actions, aside: {
                            // Match the gap and padding of the actions.
                            className: classes.treeItemLayoutAside,
                            children: aside,
                        }, main: {
                            // Prevent the "main" content (the Body1 below) from growing too large and pushing the actions/aside out of view.
                            className: classes.treeItemLayoutMain,
                        }, children: jsx(Body1, { wrap: false, truncate: true, children: name }) }) }, GetEntityId(entityItem.entity)) }), jsx(MenuPopover, { hidden: !hasChildren && contextMenuCommands.length === 0, children: jsxs(MenuList, { children: [hasChildren && (jsxs(Fragment, { children: [jsx(MenuItem, { icon: jsx(ArrowExpandAllRegular, {}), onClick: expandAll, children: jsx(Body1, { children: "Expand All" }) }), jsx(MenuItem, { icon: jsx(ArrowCollapseAllRegular, {}), onClick: collapseAll, children: jsx(Body1, { children: "Collapse All" }) })] })), hasChildren && contextMenuCommands.length > 0 && jsx(MenuDivider, {}), contextMenuItems] }) })] }));
};
const SceneExplorer = (props) => {
    const classes = useStyles$L();
    const { sections, entityCommandProviders, sectionCommandProviders, scene, selectedEntity } = props;
    const [openItems, setOpenItems] = useState(new Set());
    const [sceneVersion, setSceneVersion] = useState(0);
    const scrollViewRef = useRef(null);
    // We only want to scroll to the selected item if it was externally selected (outside of SceneExplorer).
    const previousSelectedEntity = useRef(selectedEntity);
    const setSelectedEntity = (entity) => {
        previousSelectedEntity.current = entity;
        props.setSelectedEntity?.(entity);
    };
    const [itemsFilter, setItemsFilter] = useState("");
    const [isSorted, setIsSorted] = useLocalStorage("Babylon/Settings/SceneExplorer/IsSorted", false);
    useEffect(() => {
        setSceneVersion((version) => version + 1);
    }, [scene]);
    useEffect(() => {
        const onSceneItemAdded = () => {
            setSceneVersion((version) => version + 1);
        };
        const onSceneItemRemoved = (item) => {
            setSceneVersion((version) => version + 1);
            if (openItems.delete(GetEntityId(item))) {
                setOpenItems(new Set(openItems));
            }
            if (item === selectedEntity) {
                setSelectedEntity?.(null);
            }
        };
        const addObservers = sections.flatMap((section) => section.getEntityAddedObservables().map((observable) => observable.add(onSceneItemAdded)));
        const removeObservers = sections.flatMap((section) => section.getEntityRemovedObservables().map((observable) => observable.add(onSceneItemRemoved)));
        const moveObservers = sections
            .map((section) => section.getEntityMovedObservables)
            .filter((getEntityMovedObservable) => !!getEntityMovedObservable)
            .flatMap((getEntityMovedObservable) => getEntityMovedObservable().map((observable) => observable.add(onSceneItemAdded)));
        return () => {
            for (const observer of addObservers) {
                observer.remove();
            }
            for (const observer of removeObservers) {
                observer.remove();
            }
            for (const observer of moveObservers) {
                observer.remove();
            }
        };
    }, [sections, openItems]);
    const [sceneTreeItem, sectionTreeItems, allTreeItems] = useMemo(() => {
        const sectionTreeItems = [];
        const allTreeItems = new Map();
        const sceneTreeItem = {
            type: "scene",
            scene: scene,
        };
        for (const section of sections) {
            const rootEntities = section.getRootEntities();
            const sectionTreeItem = {
                type: "section",
                sectionName: section.displayName,
                children: [],
            };
            sectionTreeItems.push(sectionTreeItem);
            allTreeItems.set(sectionTreeItem.sectionName, sectionTreeItem);
            let depth = 2;
            const createEntityTreeItemData = (entity, parent) => {
                const treeItemData = {
                    type: "entity",
                    entity,
                    depth,
                    parent,
                    icon: section.entityIcon,
                    getDisplayInfo: () => section.getEntityDisplayInfo(entity),
                };
                if (!parent.children) {
                    parent.children = [];
                }
                parent.children.push(treeItemData);
                allTreeItems.set(GetEntityId(entity), treeItemData);
                return treeItemData;
            };
            const rootEntityTreeItems = rootEntities.map((entity) => createEntityTreeItemData(entity, sectionTreeItem));
            TraverseGraph(rootEntityTreeItems, 
            // Get children
            (treeItem) => {
                if (section.getEntityChildren) {
                    const children = section.getEntityChildren(treeItem.entity);
                    return children.filter((child) => !child.reservedDataStore?.hidden).map((child) => createEntityTreeItemData(child, treeItem));
                }
                return null;
            }, 
            // Before traverse
            () => {
                depth++;
            }, 
            // After traverse
            () => {
                depth--;
            });
        }
        return [sceneTreeItem, sectionTreeItems, allTreeItems];
    }, [scene, sceneVersion, sections]);
    const visibleItems = useMemo(() => {
        // This will track the items in the order they were traversed (which is what the flat tree expects).
        const traversedItems = [];
        // This will track the items that are visible based on either the open state or the filter.
        const visibleItems = new Set();
        const filter = itemsFilter.toLocaleLowerCase();
        traversedItems.push(sceneTreeItem);
        // The scene tree item is always visible.
        visibleItems.add(sceneTreeItem);
        for (const sectionTreeItem of sectionTreeItems) {
            traversedItems.push(sectionTreeItem);
            const children = CoerceEntityArray(sectionTreeItem.children, isSorted);
            if (!children.length) {
                continue;
            }
            // Section tree items are always visible when not filtering.
            if (!filter) {
                visibleItems.add(sectionTreeItem);
            }
            // When an item filter is present, always traverse the full scene graph (e.g. ignore the open item state).
            if (filter || openItems.has(sectionTreeItem.sectionName)) {
                TraverseGraph(children, 
                // Get children
                (treeItem) => {
                    if (filter || openItems.has(GetEntityId(treeItem.entity))) {
                        if (!treeItem.children) {
                            return null;
                        }
                        return CoerceEntityArray(treeItem.children, isSorted);
                    }
                    return null;
                }, 
                // Before traverse
                (treeItem) => {
                    traversedItems.push(treeItem);
                    if (treeItem.entity.reservedDataStore?.hidden) {
                        return; // Don't display the treeItem or its children if reservedDataStore.hidden is true
                    }
                    if (!filter) {
                        // If there is no filter and we made it this far, then the item's parent is in an open state and this item is visible.
                        visibleItems.add(treeItem);
                    }
                    else {
                        // Otherwise we have an item filter and we need to check for a match.
                        const displayInfo = treeItem.getDisplayInfo();
                        if (displayInfo.name.toLocaleLowerCase().includes(filter)) {
                            // The item is a match, add it to the set.
                            visibleItems.add(treeItem);
                            // Also add all ancestors as a match since we want to be able to see the tree structure up to the matched item.
                            let currentItem = treeItem.parent;
                            while (currentItem) {
                                // If this item is already in the matched set, then all its ancestors must also already be in the set.
                                if (visibleItems.has(currentItem)) {
                                    break;
                                }
                                visibleItems.add(currentItem);
                                // If the parent is the section, then there are no more parents to traverse.
                                if (currentItem.type === "section") {
                                    currentItem = null;
                                }
                                else {
                                    currentItem = currentItem.parent;
                                }
                            }
                        }
                        displayInfo.dispose?.();
                    }
                });
            }
        }
        // Filter the traversal ordered items by those that should actually be visible.
        return traversedItems.filter((item) => visibleItems.has(item));
    }, [sceneTreeItem, sectionTreeItems, allTreeItems, openItems, itemsFilter, isSorted]);
    const getParentStack = useCallback((entity) => {
        const parentStack = [];
        for (let treeItem = allTreeItems.get(GetEntityId(entity)); treeItem; treeItem = treeItem?.type === "entity" ? treeItem.parent : undefined) {
            parentStack.push(treeItem.type === "entity" ? GetEntityId(treeItem.entity) : treeItem.sectionName);
        }
        // The first item will be the entity itself, so just remove it.
        parentStack.shift();
        return parentStack;
    }, [allTreeItems]);
    const selectEntity = useCallback((selectedEntity) => {
        const entity = selectedEntity;
        if (entity && entity.uniqueId != undefined) {
            const parentStack = getParentStack(entity);
            if (parentStack.length > 0) {
                const newOpenItems = new Set(openItems);
                for (const parent of parentStack) {
                    newOpenItems.add(parent);
                }
                setOpenItems(newOpenItems);
                setIsScrollToPending(true);
            }
        }
        previousSelectedEntity.current = selectedEntity;
    }, [getParentStack, openItems]);
    const [isScrollToPending, setIsScrollToPending] = useState(false);
    useEffect(() => {
        if (selectedEntity && selectedEntity !== previousSelectedEntity.current) {
            selectEntity(selectedEntity);
        }
    }, [selectedEntity, selectEntity]);
    useEffect(() => {
        // When the component first mounts, select the currently selected entity to ensure it is visible.
        selectEntity(selectedEntity);
    }, []);
    // We need to wait for a render to complete before we can scroll to the item, hence the isScrollToPending.
    useEffect(() => {
        if (isScrollToPending) {
            const selectedItemIndex = visibleItems.findIndex((item) => item.type === "entity" && item.entity === selectedEntity);
            if (selectedItemIndex >= 0 && scrollViewRef.current) {
                scrollViewRef.current.scrollTo(selectedItemIndex, "smooth");
                setIsScrollToPending(false);
            }
        }
    }, [isScrollToPending, selectedEntity, visibleItems]);
    const onOpenChange = useCallback((event, data) => {
        // This makes it so we only consider a click on the chevron to be expanding/collapsing an item, not clicking anywhere on the item.
        if (data.type !== "Click" && data.type !== "Enter") {
            // Shift or Ctrl mean expand/collapse all descendants.
            if (event.shiftKey || event.ctrlKey) {
                const treeItem = allTreeItems.get(data.value);
                if (treeItem) {
                    ExpandOrCollapseAll(treeItem, data.open, data.openItems);
                }
            }
            setOpenItems(data.openItems);
        }
    }, [setOpenItems, allTreeItems]);
    const expandAll = (treeItem) => {
        ExpandOrCollapseAll(treeItem, true, openItems);
        setOpenItems(new Set(openItems));
    };
    const collapseAll = (treeItem) => {
        ExpandOrCollapseAll(treeItem, false, openItems);
        setOpenItems(new Set(openItems));
    };
    return (jsxs("div", { className: classes.rootDiv, children: [jsxs("div", { className: classes.toolbarDiv, children: [jsx(SearchBox$1, { className: classes.searchBox, appearance: "underline", contentBefore: jsx(FilterRegular, {}), placeholder: "Filter", value: itemsFilter, onChange: (_, data) => setItemsFilter(data.value) }), jsx(ToggleButton, { title: "Sort Entities Alphabetically", appearance: "transparent", checkedIcon: TextSortAscendingRegular, value: isSorted, onChange: () => setIsSorted((isSorted) => !isSorted) })] }), jsx(FlatTree, { className: classes.tree, openItems: openItems, onOpenChange: onOpenChange, "aria-label": "Scene Explorer Tree", children: jsx(VirtualizerScrollView, { imperativeRef: scrollViewRef, numItems: visibleItems.length, itemSize: 32, container: { className: classes.scrollView }, children: (index) => {
                        const item = visibleItems[index];
                        if (item.type === "scene") {
                            return (jsx(SceneTreeItem, { scene: scene, isSelected: selectedEntity === scene, select: () => setSelectedEntity?.(scene), isFiltering: !!itemsFilter }, "scene"));
                        }
                        else if (item.type === "section") {
                            return (jsx(SectionTreeItem, { scene: scene, section: item, isFiltering: !!itemsFilter, commandProviders: sectionCommandProviders, expandAll: () => expandAll(item), collapseAll: () => collapseAll(item) }, item.sectionName));
                        }
                        else {
                            return (jsx(EntityTreeItem, { scene: scene, entityItem: item, isSelected: selectedEntity === item.entity, select: () => setSelectedEntity?.(item.entity), isFiltering: !!itemsFilter, commandProviders: entityCommandProviders, expandAll: () => expandAll(item), collapseAll: () => collapseAll(item) }, item.entity.uniqueId));
                        }
                    } }) })] }));
};

const SceneContextIdentity = Symbol("SceneScontext");

const SceneExplorerServiceIdentity = Symbol("SceneExplorer");
/**
 * Provides a scene explorer pane that enables browsing the scene graph and executing commands on entities.
 */
const SceneExplorerServiceDefinition = {
    friendlyName: "Scene Explorer",
    produces: [SceneExplorerServiceIdentity],
    consumes: [SceneContextIdentity, ShellServiceIdentity, SelectionServiceIdentity],
    factory: (sceneContext, shellService, selectionService) => {
        const sectionsCollection = new ObservableCollection();
        const entityCommandsCollection = new ObservableCollection();
        const sectionCommandsCollection = new ObservableCollection();
        const registration = shellService.addSidePane({
            key: "Scene Explorer",
            title: "Scene Explorer",
            icon: CubeTreeRegular,
            horizontalLocation: "left",
            verticalLocation: "top",
            suppressTeachingMoment: true,
            content: () => {
                const sections = useOrderedObservableCollection(sectionsCollection);
                const entityCommands = useOrderedObservableCollection(entityCommandsCollection);
                const sectionCommands = useOrderedObservableCollection(sectionCommandsCollection);
                const scene = useObservableState(() => sceneContext.currentScene, sceneContext.currentSceneObservable);
                const entity = useObservableState(() => selectionService.selectedEntity, selectionService.onSelectedEntityChanged);
                return (jsx(Fragment, { children: scene && (jsx(SceneExplorer, { sections: sections, entityCommandProviders: entityCommands, sectionCommandProviders: sectionCommands, scene: scene, selectedEntity: entity, setSelectedEntity: (entity) => (selectionService.selectedEntity = entity) })) }));
            },
        });
        return {
            addSection: (section) => sectionsCollection.add(section),
            addEntityCommand: (command) => entityCommandsCollection.add(command),
            addSectionCommand: (command) => sectionCommandsCollection.add(command),
            dispose: () => registration.dispose(),
        };
    },
};

const useSwitchStyles = makeStyles({
    switch: {
        marginLeft: "auto",
    },
    switchSmall: {
        transform: `scale(.85)`, // workaround since we cannot resize fluent switch
        transformOrigin: "right",
    },
    indicator: {
        margin: 0, // Remove the default right margin so the switch aligns well on the right side inside panels like the properties pane.
    },
});
/**
 * This is a primitive fluent boolean switch component whose only knowledge is the shared styling across all tools
 * @param props
 * @returns Switch component
 */
const Switch = (props) => {
    Switch.displayName = "Switch";
    const { size } = useContext(ToolContext);
    const classes = useSwitchStyles();
    const [checked, setChecked] = useState(() => props.value ?? false);
    useEffect(() => {
        if (props.value != undefined) {
            setChecked(props.value); // Update local state when props.checked changes
        }
    }, [props.value]);
    const onChange = (event, _) => {
        props.onChange && props.onChange(event.target.checked);
        setChecked(event.target.checked);
    };
    return (jsx(Switch$1, { className: mergeClasses(classes.switch, size === "small" && classes.switchSmall), indicator: { className: classes.indicator }, checked: checked, disabled: props.disabled, onChange: onChange }));
};

/**
 * Wraps a switch in a property line
 * @param props - The properties for the switch and property line
 * @returns A React element representing the property line with a switch
 */
const SwitchPropertyLine = (props) => {
    SwitchPropertyLine.displayName = "SwitchPropertyLine";
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { label, ...switchProps } = props;
    // Ensure the label gets passed to the PropertyLine component and not to the underlying switch
    return (jsx(PropertyLine, { ...props, children: jsx(Switch, { ...switchProps }) }));
};

const SwitchGrid = function (renderScene) {
    const scene = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer.utilityLayerScene;
    if (!renderScene.reservedDataStore.gridMesh) {
        const extend = renderScene.getWorldExtends();
        const width = (extend.max.x - extend.min.x) * 5.0;
        const depth = (extend.max.z - extend.min.z) * 5.0;
        renderScene.reservedDataStore.gridMesh = CreateGround("grid", { width: 1.0, height: 1.0, subdivisions: 1 }, scene);
        const gridMesh = renderScene.reservedDataStore.gridMesh;
        if (!gridMesh.reservedDataStore) {
            gridMesh.reservedDataStore = {};
        }
        gridMesh.scaling.x = Math.max(width, depth);
        gridMesh.scaling.z = gridMesh.scaling.x;
        gridMesh.reservedDataStore.isInspectorGrid = true;
        gridMesh.isPickable = false;
        const groundMaterial = new GridMaterial("GridMaterial", scene);
        groundMaterial.majorUnitFrequency = 10;
        groundMaterial.minorUnitVisibility = 0.3;
        groundMaterial.gridRatio = 0.01;
        groundMaterial.backFaceCulling = false;
        groundMaterial.mainColor = new Color3(1, 1, 1);
        groundMaterial.lineColor = new Color3(1.0, 1.0, 1.0);
        groundMaterial.opacity = 0.8;
        groundMaterial.zOffset = 1.0;
        const textureUrl = Tools.GetAssetUrl("https://assets.babylonjs.com/core/environments/backgroundGround.png");
        groundMaterial.opacityTexture = new Texture(textureUrl, scene);
        gridMesh.material = groundMaterial;
        return;
    }
    const gridMesh = renderScene.reservedDataStore.gridMesh;
    gridMesh.dispose(true, true);
    renderScene.reservedDataStore.gridMesh = null;
};
const SwitchPhysicsViewers = function (scene) {
    if (!scene.reservedDataStore.physicsViewer) {
        const physicsViewer = new PhysicsViewer(scene);
        scene.reservedDataStore.physicsViewer = physicsViewer;
        for (const mesh of scene.meshes) {
            if (mesh.physicsImpostor) {
                const debugMesh = physicsViewer.showImpostor(mesh.physicsImpostor, mesh);
                if (debugMesh) {
                    debugMesh.reservedDataStore = { hidden: true };
                    debugMesh.material.reservedDataStore = { hidden: true };
                }
            }
            else if (mesh.physicsBody) {
                const debugMesh = physicsViewer.showBody(mesh.physicsBody);
                if (debugMesh) {
                    debugMesh.reservedDataStore = { hidden: true };
                    debugMesh.material.reservedDataStore = { hidden: true };
                }
            }
        }
        for (const transformNode of scene.transformNodes) {
            if (transformNode.physicsBody) {
                const debugMesh = physicsViewer.showBody(transformNode.physicsBody);
                if (debugMesh) {
                    debugMesh.reservedDataStore = { hidden: true };
                    debugMesh.material.reservedDataStore = { hidden: true };
                }
            }
        }
    }
    else {
        scene.reservedDataStore.physicsViewer.dispose();
        scene.reservedDataStore.physicsViewer = null;
    }
};
const SwitchNameViewerAsync = async function (scene) {
    if (!scene.reservedDataStore.textRenderersHook) {
        scene.reservedDataStore.textRenderers = [];
        if (!scene.reservedDataStore.fontAsset) {
            const sdfFontDefinition = await (await fetch("https://assets.babylonjs.com/fonts/roboto-regular.json")).text();
            // eslint-disable-next-line require-atomic-updates
            scene.reservedDataStore.fontAsset = new FontAsset(sdfFontDefinition, "https://assets.babylonjs.com/fonts/roboto-regular.png");
        }
        const textRendererPromises = scene.meshes.map(async (mesh) => {
            const textRenderer = await TextRenderer.CreateTextRendererAsync(scene.reservedDataStore.fontAsset, scene.getEngine());
            textRenderer.addParagraph(mesh.name);
            textRenderer.isBillboard = true;
            textRenderer.isBillboardScreenProjected = true;
            textRenderer.parent = mesh;
            textRenderer.ignoreDepthBuffer = true;
            textRenderer.transformMatrix = Matrix.Scaling(0.02, 0.02, 0.02);
            scene.reservedDataStore.textRenderers.push(textRenderer);
        });
        await Promise.all(textRendererPromises);
        scene.reservedDataStore.textRenderersHook = scene.onAfterRenderObservable.add(() => {
            for (const textRenderer of scene.reservedDataStore.textRenderers) {
                if (!textRenderer.parent.isVisible || !textRenderer.parent.isEnabled()) {
                    continue;
                }
                textRenderer.render(scene.getViewMatrix(), scene.getProjectionMatrix());
            }
        });
    }
    else {
        scene.onAfterRenderObservable.remove(scene.reservedDataStore.textRenderersHook);
        for (const textRenderer of scene.reservedDataStore.textRenderers) {
            textRenderer.dispose();
        }
        scene.reservedDataStore.textRenderersHook = null;
        scene.reservedDataStore.textRenderers = null;
    }
};
const DebugPane = (props) => {
    const scene = props.context;
    if (!scene.reservedDataStore) {
        scene.reservedDataStore = {};
    }
    // Making sure we clean up when the scene is disposed
    scene.onDisposeObservable.addOnce(() => {
        if (scene.reservedDataStore.physicsViewer) {
            SwitchPhysicsViewers(scene);
        }
        if (scene.reservedDataStore.textRenderersHook) {
            void SwitchNameViewerAsync(scene);
            scene.reservedDataStore.fontAsset?.dispose();
        }
        if (scene.reservedDataStore.gridMesh) {
            SwitchGrid(scene);
        }
    });
    return (jsxs(ExtensibleAccordion, { ...props, children: [jsxs(AccordionSection, { title: "Helpers", children: [jsx(SwitchPropertyLine, { label: "Grid", description: "Display a ground grid.", value: !!scene.reservedDataStore.gridMesh, onChange: () => SwitchGrid(scene) }), jsx(SwitchPropertyLine, { label: "Physics", description: "Display physic debug info.", value: !!scene.reservedDataStore.physicsViewer, onChange: () => SwitchPhysicsViewers(scene) }), jsx(SwitchPropertyLine, { label: "Names", description: "Display mesh names.", value: !!scene.reservedDataStore.textRenderersHook, onChange: () => void SwitchNameViewerAsync(scene) })] }), jsxs(AccordionSection, { title: "Texture Channels", children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Diffuse", target: StandardMaterial, propertyKey: "DiffuseTextureEnabled" }, "Diffuse"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Ambient", target: StandardMaterial, propertyKey: "AmbientTextureEnabled" }, "Ambient"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Specular", target: StandardMaterial, propertyKey: "SpecularTextureEnabled" }, "Specular"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Emissive", target: StandardMaterial, propertyKey: "EmissiveTextureEnabled" }, "Emissive"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Bump", target: StandardMaterial, propertyKey: "BumpTextureEnabled" }, "Bump"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Opacity", target: StandardMaterial, propertyKey: "OpacityTextureEnabled" }, "Opacity"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Reflection", target: StandardMaterial, propertyKey: "ReflectionTextureEnabled" }, "Reflection"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Refraction", target: StandardMaterial, propertyKey: "RefractionTextureEnabled" }, "Refraction"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Color Grading", target: StandardMaterial, propertyKey: "ColorGradingTextureEnabled" }, "ColorGrading"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Lightmap", target: StandardMaterial, propertyKey: "LightmapTextureEnabled" }, "Lightmap"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Fresnel", target: StandardMaterial, propertyKey: "FresnelEnabled" }, "Fresnel"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Detail", target: MaterialFlags, propertyKey: "DetailTextureEnabled" }, "Detail"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Decal", target: MaterialFlags, propertyKey: "DecalMapEnabled" }, "Decal")] }), jsxs(AccordionSection, { title: "Features", children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Animations", target: scene, propertyKey: "animationsEnabled" }, "Animations"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Physics", target: scene, propertyKey: "physicsEnabled" }, "Physics"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Collisions", target: scene, propertyKey: "collisionsEnabled" }, "Collisions"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Fog", target: scene, propertyKey: "fogEnabled" }, "Fog"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Lens Flares", target: scene, propertyKey: "lensFlaresEnabled" }, "Lens flares"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Lights", target: scene, propertyKey: "lightsEnabled" }, "Lights"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Particles", target: scene, propertyKey: "particlesEnabled" }, "Particles"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Post-processes", target: scene, propertyKey: "postProcessesEnabled" }, "Post-processes"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Probes", target: scene, propertyKey: "probesEnabled" }, "Probes"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Textures", target: scene, propertyKey: "texturesEnabled" }, "Textures"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Procedural Textures", target: scene, propertyKey: "proceduralTexturesEnabled" }, "Procedural textures"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Render Targets", target: scene, propertyKey: "renderTargetsEnabled" }, "Render targets"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Shadows", target: scene, propertyKey: "shadowsEnabled" }, "Shadows"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Skeletons", target: scene, propertyKey: "skeletonsEnabled" }, "Skeletons"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Sprites", target: scene, propertyKey: "spritesEnabled" }, "Sprites")] })] }));
};

const DebugServiceIdentity = Symbol("DebugService");
const DebugServiceDefinition = {
    friendlyName: "Debug",
    produces: [DebugServiceIdentity],
    consumes: [ShellServiceIdentity, SceneContextIdentity],
    factory: (shellService, sceneContext) => {
        const sectionsCollection = new ObservableCollection();
        const sectionContentCollection = new ObservableCollection();
        const registration = shellService.addSidePane({
            key: "Debug",
            title: "Debug",
            icon: BugRegular,
            horizontalLocation: "right",
            verticalLocation: "top",
            order: 200,
            suppressTeachingMoment: true,
            content: () => {
                const sections = useOrderedObservableCollection(sectionsCollection);
                const sectionContent = useObservableCollection(sectionContentCollection);
                const scene = useObservableState(() => sceneContext.currentScene, sceneContext.currentSceneObservable);
                return jsx(Fragment, { children: scene && jsx(DebugPane, { sections: sections, sectionContent: sectionContent, context: scene }) });
            },
        });
        return {
            addSection: (section) => sectionsCollection.add(section),
            addSectionContent: (content) => sectionContentCollection.add(content),
            dispose: () => registration.dispose(),
        };
    },
};

/**
 * Wraps a button with a label in a line container
 * @param props Button props plus a label
 * @returns A button inside a line
 */
const ButtonLine = (props) => {
    ButtonLine.displayName = "ButtonLine";
    return (jsx(LineContainer, { children: jsx(Button, { ...props }) }));
};

const SettingsServiceIdentity = Symbol("SettingsService");
const SettingsServiceDefinition = {
    friendlyName: "Settings",
    consumes: [ShellServiceIdentity, SceneContextIdentity],
    produces: [SettingsContextIdentity, SettingsServiceIdentity],
    factory: (shellService, sceneContext) => {
        const sectionsCollection = new ObservableCollection();
        const sectionContentCollection = new ObservableCollection();
        let useDegrees = DataStorage.ReadBoolean("Babylon/Settings/UseDegrees", false);
        let useEuler = DataStorage.ReadBoolean("Babylon/Settings/UseEuler", false);
        let ignoreBackfacesForPicking = DataStorage.ReadBoolean("Babylon/Settings/IgnoreBackfacesForPicking", false);
        let showPropertiesOnEntitySelection = DataStorage.ReadBoolean("Babylon/Settings/ShowPropertiesOnEntitySelection", true);
        const settings = {
            get useDegrees() {
                return useDegrees;
            },
            set useDegrees(value) {
                if (useDegrees === value) {
                    return; // No change, no need to notify
                }
                useDegrees = value;
                DataStorage.WriteBoolean("Babylon/Settings/UseDegrees", useDegrees);
                this.settingsChangedObservable.notifyObservers(this);
            },
            get ignoreBackfacesForPicking() {
                return ignoreBackfacesForPicking;
            },
            set ignoreBackfacesForPicking(value) {
                if (ignoreBackfacesForPicking === value) {
                    return; // No change, no need to notify
                }
                ignoreBackfacesForPicking = value;
                DataStorage.WriteBoolean("Babylon/Settings/IgnoreBackfacesForPicking", ignoreBackfacesForPicking);
                this.settingsChangedObservable.notifyObservers(this);
            },
            get useEuler() {
                return useEuler;
            },
            set useEuler(value) {
                if (useEuler === value) {
                    return; // No change, no need to notify
                }
                useEuler = value;
                DataStorage.WriteBoolean("Babylon/Settings/UseEuler", useEuler);
                this.settingsChangedObservable.notifyObservers(this);
            },
            get showPropertiesOnEntitySelection() {
                return showPropertiesOnEntitySelection;
            },
            set showPropertiesOnEntitySelection(value) {
                if (showPropertiesOnEntitySelection === value) {
                    return; // No change, no need to notify
                }
                showPropertiesOnEntitySelection = value;
                DataStorage.WriteBoolean("Babylon/Settings/ShowPropertiesOnEntitySelection", showPropertiesOnEntitySelection);
                this.settingsChangedObservable.notifyObservers(this);
            },
            settingsChangedObservable: new Observable(),
            addSection: (section) => sectionsCollection.add(section),
            addSectionContent: (content) => sectionContentCollection.add(content),
            dispose: () => { },
        };
        const registration = shellService.addSidePane({
            key: "Settings",
            title: "Settings",
            icon: SettingsRegular,
            horizontalLocation: "right",
            verticalLocation: "top",
            order: 500,
            suppressTeachingMoment: true,
            content: () => {
                const sections = useOrderedObservableCollection(sectionsCollection);
                const sectionContent = useObservableCollection(sectionContentCollection);
                const scene = useObservableState(() => sceneContext.currentScene, sceneContext.currentSceneObservable);
                const [compactMode, setCompactMode] = useCompactMode();
                const [disableCopy, setDisableCopy] = useDisableCopy();
                const [, , resetSidePaneLayout] = useSidePaneDockOverrides();
                return (jsx(Fragment, { children: scene && (jsx(ExtensibleAccordion, { sections: sections, sectionContent: sectionContent, context: scene, children: jsxs(AccordionSection, { title: "UI", children: [jsx(SwitchPropertyLine, { label: "Compact Mode", description: "Use a more compact UI with less spacing.", value: compactMode, onChange: (checked) => {
                                        setCompactMode(checked);
                                    } }), jsx(SwitchPropertyLine, { label: "Use Degrees", description: "Using degrees instead of radians.", value: settings.useDegrees, onChange: (checked) => {
                                        settings.useDegrees = checked;
                                    } }), jsx(SwitchPropertyLine, { label: "Only Show Euler Angles", description: "Only show Euler angles in rotation properties, rather than quaternions.", value: settings.useEuler, onChange: (checked) => {
                                        settings.useEuler = checked;
                                    } }), jsx(SwitchPropertyLine, { label: "Ignore Backfaces for Picking", description: "Ignore backfaces when picking.", value: settings.ignoreBackfacesForPicking, onChange: (checked) => {
                                        settings.ignoreBackfacesForPicking = checked;
                                    } }), jsx(SwitchPropertyLine, { label: "Show Properties on Selection", description: "Shows the Properties pane when an entity is selected.", value: settings.showPropertiesOnEntitySelection, onChange: (checked) => {
                                        settings.showPropertiesOnEntitySelection = checked;
                                    } }), jsx(SwitchPropertyLine, { label: "Disable Copy Button", description: "Disables the copy to clipboard button on property lines. You can still Ctrl+Click on the label to copy.", value: disableCopy, onChange: (checked) => {
                                        setDisableCopy(checked);
                                    } }), jsx(ButtonLine, { label: "Reset Layout", onClick: resetSidePaneLayout })] }) })) }));
            },
        });
        settings.dispose = () => registration.dispose();
        return settings;
    },
};

/**
 * Expects a numerical value and converts it toFixed(if precision is supplied) or toLocaleString
 * Can pass optional units to be appending to the end of the string
 * @param props
 * @returns
 */
const StringifiedPropertyLine = (props) => {
    StringifiedPropertyLine.displayName = "StringifiedPropertyLine";
    const value = props.precision !== undefined ? props.value?.toFixed(props.precision) : props.value?.toLocaleString();
    const withUnits = props.units ? `${value} ${props.units}` : value;
    return (jsx(PropertyLine, { ...props, children: jsx(Body1, { title: props.title, children: withUnits ?? "" }) }));
};

const CountStats = ({ context: scene }) => {
    const pollingObservable = usePollingObservable(1000);
    const totalMeshes = useObservableState(() => scene.meshes.length, scene.onNewMeshAddedObservable, scene.onMeshRemovedObservable);
    const activeMeshes = useObservableState(() => {
        let activeMeshesCount = scene.getActiveMeshes().length;
        for (const objectRenderer of scene.objectRenderers) {
            activeMeshesCount += objectRenderer.getActiveMeshes().length;
        }
        return activeMeshesCount;
    }, pollingObservable);
    const activeIndices = useObservableState(() => scene.getActiveIndices(), pollingObservable);
    const activeBones = useObservableState(() => scene.getActiveBones(), pollingObservable);
    const activeParticles = useObservableState(() => scene.getActiveParticles(), pollingObservable);
    const drawCalls = useObservableState(() => scene.getEngine()._drawCalls.current, pollingObservable);
    const totalLights = useObservableState(() => scene.lights.length, pollingObservable);
    const totalVertices = useObservableState(() => scene.getTotalVertices(), pollingObservable);
    const totalMaterials = useObservableState(() => scene.materials.length, pollingObservable);
    const totalTextures = useObservableState(() => scene.textures.length, pollingObservable);
    return (jsxs(Fragment, { children: [jsx(StringifiedPropertyLine, { label: "Total Meshes", value: totalMeshes }, "TotalMeshes"), jsx(StringifiedPropertyLine, { label: "Active Meshes", value: activeMeshes }, "ActiveMeshes"), jsx(StringifiedPropertyLine, { label: "Active Indices", value: activeIndices }, "ActiveIndices"), jsx(StringifiedPropertyLine, { label: "Active Faces", value: activeIndices / 3 }, "ActiveFaces"), jsx(StringifiedPropertyLine, { label: "Active Bones", value: activeBones }, "ActiveBones"), jsx(StringifiedPropertyLine, { label: "Active Particles", value: activeParticles }, "ActiveParticles"), jsx(StringifiedPropertyLine, { label: "Draw Calls", value: drawCalls }, "DrawCalls"), jsx(StringifiedPropertyLine, { label: "Total Lights", value: totalLights }, "TotalLights"), jsx(StringifiedPropertyLine, { label: "Total Vertices", value: totalVertices }, "TotalVertices"), jsx(StringifiedPropertyLine, { label: "Total Materials", value: totalMaterials }, "TotalMaterials"), jsx(StringifiedPropertyLine, { label: "Total Textures", value: totalTextures }, "TotalTextures")] }));
};

const FrameStepsStats = ({ context: scene }) => {
    const pollingObservable = usePollingObservable(1000);
    const sceneInstrumentation = useResource(useCallback(() => {
        const sceneInstrumentation = new SceneInstrumentation(scene);
        sceneInstrumentation.captureActiveMeshesEvaluationTime = true;
        sceneInstrumentation.captureRenderTargetsRenderTime = true;
        sceneInstrumentation.captureFrameTime = true;
        sceneInstrumentation.captureRenderTime = true;
        sceneInstrumentation.captureInterFrameTime = true;
        sceneInstrumentation.captureParticlesRenderTime = true;
        sceneInstrumentation.captureSpritesRenderTime = true;
        sceneInstrumentation.capturePhysicsTime = true;
        sceneInstrumentation.captureAnimationsTime = true;
        return sceneInstrumentation;
    }, [scene]));
    const engineInstrumentation = useResource(useCallback(() => {
        const engineInstrumentation = new EngineInstrumentation(scene.getEngine());
        engineInstrumentation.captureGPUFrameTime = true;
        return engineInstrumentation;
    }, [scene.getEngine()]));
    const absoluteFPS = useObservableState(() => Math.floor(1000.0 / sceneInstrumentation.frameTimeCounter.lastSecAverage), pollingObservable);
    const meshesSelection = useObservableState(() => sceneInstrumentation.activeMeshesEvaluationTimeCounter.lastSecAverage, pollingObservable);
    const renderTargets = useObservableState(() => sceneInstrumentation.renderTargetsRenderTimeCounter.lastSecAverage, pollingObservable);
    const particles = useObservableState(() => sceneInstrumentation.particlesRenderTimeCounter.lastSecAverage, pollingObservable);
    const sprites = useObservableState(() => sceneInstrumentation.spritesRenderTimeCounter.lastSecAverage, pollingObservable);
    const animations = useObservableState(() => sceneInstrumentation.animationsTimeCounter.lastSecAverage, pollingObservable);
    const physics = useObservableState(() => sceneInstrumentation.physicsTimeCounter.lastSecAverage, pollingObservable);
    const interFrameTime = useObservableState(() => sceneInstrumentation.interFrameTimeCounter.lastSecAverage, pollingObservable);
    const gpuFrameTime = useObservableState(() => engineInstrumentation.gpuFrameTimeCounter.lastSecAverage * 0.000001, pollingObservable);
    const gpuFrameTimeAverage = useObservableState(() => engineInstrumentation.gpuFrameTimeCounter.average * 0.000001, pollingObservable);
    return (jsxs(Fragment, { children: [jsx(StringifiedPropertyLine, { label: "Absolute FPS", value: absoluteFPS }, "AbsoluteFPS"), jsx(StringifiedPropertyLine, { label: "Meshes Selection", value: meshesSelection, precision: 2, units: "ms" }, "MeshesSelection"), jsx(StringifiedPropertyLine, { label: "Render Targets", value: renderTargets, precision: 2, units: "ms" }, "RenderTargets"), jsx(StringifiedPropertyLine, { label: "Particles", value: particles, precision: 2, units: "ms" }, "Particles"), jsx(StringifiedPropertyLine, { label: "Sprites", value: sprites, precision: 2, units: "ms" }, "Sprites"), jsx(StringifiedPropertyLine, { label: "Animations", value: animations, precision: 2, units: "ms" }, "Animations"), jsx(StringifiedPropertyLine, { label: "Physics", value: physics, precision: 2, units: "ms" }, "Physics"), jsx(StringifiedPropertyLine, { label: "Render", value: sceneInstrumentation.renderTimeCounter.lastSecAverage, precision: 2, units: "ms" }, "Render"), jsx(StringifiedPropertyLine, { label: "Frame", value: sceneInstrumentation.frameTimeCounter.lastSecAverage, precision: 2, units: "ms" }, "Frame"), jsx(StringifiedPropertyLine, { label: "Inter-Frame Time", value: interFrameTime, precision: 2, units: "ms" }, "InterFrameTime"), jsx(StringifiedPropertyLine, { label: "GPU Frame Time", value: gpuFrameTime, precision: 2, units: "ms" }, "GPUFrameTime"), jsx(StringifiedPropertyLine, { label: "GPU Frame Time (Average)", value: gpuFrameTimeAverage, precision: 2, units: "ms" }, "GPUFrameTimeAverage")] }));
};

/**
 * A button that triggers a file upload dialog.
 * Combines a Button with a hidden file input.
 * @param props UploadButtonProps
 * @returns UploadButton component
 */
const UploadButton = (props) => {
    const { onUpload, accept, label, ...buttonProps } = props;
    UploadButton.displayName = "UploadButton";
    const inputRef = useRef(null);
    const handleClick = () => {
        inputRef.current?.click();
    };
    const handleChange = (evt) => {
        const files = evt.target.files;
        if (files && files.length) {
            onUpload(files);
        }
        evt.target.value = "";
    };
    return (jsxs(Fragment, { children: [jsx(Button, { icon: ArrowUploadRegular, title: label ?? "Upload", label: label, onClick: handleClick, ...buttonProps }), jsx("input", { ref: inputRef, type: "file", accept: accept, style: { display: "none" }, onChange: handleChange })] }));
};

/**
 * A full-width line with an upload button.
 * For just the button without the line wrapper, use UploadButton directly.
 * @returns An UploadButton wrapped in a LineContainer
 */
const FileUploadLine = ({ onClick, label, accept, ...buttonProps }) => {
    FileUploadLine.displayName = "FileUploadLine";
    return (jsx(LineContainer, { children: jsx(UploadButton, { onUpload: onClick, accept: accept, label: label, ...buttonProps }) }));
};

/**
 * Defines the supported timestamp units.
 */
var TimestampUnit;
(function (TimestampUnit) {
    TimestampUnit[TimestampUnit["Milliseconds"] = 0] = "Milliseconds";
    TimestampUnit[TimestampUnit["Seconds"] = 1] = "Seconds";
    TimestampUnit[TimestampUnit["Minutes"] = 2] = "Minutes";
    TimestampUnit[TimestampUnit["Hours"] = 3] = "Hours";
})(TimestampUnit || (TimestampUnit = {}));

const DefaultColor = "#000";
const AxisColor = "#c0c4c8";
const FutureBoxColor = "#dfe9ed";
const DividerColor = "#0a3066";
const PlayheadColor = "#b9dbef";
const PositionIndicatorColor = "#4d5960";
const TooltipBackgroundColor = "#566268";
const TooltipForegroundColor = "#fbfbfb";
const TopOfGraphY = 0;
const DefaultAlpha = 1;
const TooltipBackgroundAlpha = 0.8;
const BackgroundLineAlpha = 0.2;
const MaxDistanceForHover = 10;
const TooltipHorizontalPadding = 10;
const SpaceBetweenTextAndBox = 5;
const TooltipPaddingFromBottom = 20;
// height of indicator triangle
const TriangleHeight = 10;
// width of indicator triangle
const TriangleWidth = 20;
// padding to indicate how far below the axis line the triangle should be.
const TrianglePaddingFromAxisLine = 3;
const TickerHorizontalPadding = 10;
// pixels to pad the top and bottom of data so that it doesn't get cut off by the margins.
const DataPadding = 2;
const PlayheadSize = 8;
const DividerSize = 2;
const AxisLineLength = 10;
const AxisPadding = 10;
// Currently the scale factor is a constant but when we add panning this may become formula based.
const ScaleFactor = 0.8;
// This controls the scale factor at which we stop drawing the playhead. Below this value there tends to be flickering of the playhead as data comes in.
const StopDrawingPlayheadThreshold = 0.95;
// Threshold for the ratio at which we go from panning mode to live mode.
const ReturnToLiveThreshold = 0.998;
// Font to use on the addons such as tooltips and tickers!
const GraphAddonFont = "12px Arial";
// A string containing the alphabet, used in line height calculation for the font.
const Alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
// Arbitrary maximum used to make some GC optimizations.
const MaximumDatasetsAllowed = 64;
const MsInSecond = 1000;
const MsInMinute = MsInSecond * 60;
const MsInHour = MsInMinute * 60;
// time in ms to wait between tooltip draws inside the mouse move.
const TooltipDebounceTime = 32;
// time in ms to wait between draws
const DrawThrottleTime = 15;
// What distance percentage in the x axis between two points makes us break the line and draw a "no data" box instead
const MaxXDistancePercBetweenLinePoints = 0.1;
// Color used to draw the rectangle that indicates no collection of data
const NoDataRectangleColor = "#aaaaaa";
const SmoothingFactor = 0.2; // factor to smooth the graph with
const RangeMargin = 0.1; // extra margin to expand the min/max range on the graph
/**
 * This function will debounce calls to functions.
 *
 * @param callback callback to call.
 * @param time time to wait between calls in ms.
 * @returns a function that will call the callback after the time has passed.
 */
function Debounce(callback, time) {
    let timerId;
    return function (...args) {
        clearTimeout(timerId);
        timerId = setTimeout(() => callback(...args), time);
    };
}
/**
 * This function will throttle calls to functions.
 *
 * @param callback callback to call.
 * @param time time to wait between calls in ms.
 * @returns a function that will call the callback after the time has passed.
 */
function Throttle(callback, time) {
    let lastCalledTime = 0;
    return function (...args) {
        const now = Date.now();
        if (now - lastCalledTime < time) {
            return;
        }
        lastCalledTime = now;
        callback(...args);
    };
}
/**
 * This class acts as the main API for graphing. Here is where you will find methods to let the service know new data needs to be drawn,
 * let it know something has been resized, etc!
 */
class CanvasGraphService {
    /**
     * Creates an instance of CanvasGraphService.
     *
     * @param canvas a pointer to the canvas dom element we would like to write to.
     * @param settings settings for our service.
     */
    constructor(canvas, settings) {
        this._sizeOfWindow = 300;
        /**
         * This method lets the service know it should get ready to update what it is displaying.
         */
        this.update = Throttle(() => this._draw(), DrawThrottleTime);
        this._prevPointById = new Map();
        this._prevValueById = new Map();
        /**
         * Handles what to do when we are hovering over the canvas and not panning.
         *
         * @param event A reference to the event to be handled.
         */
        this._handleDataHover = (event) => {
            if (this._panPosition) {
                // we don't want to do anything if we are in the middle of panning
                return;
            }
            this._hoverPosition = { xPos: event.clientX, yPos: event.clientY };
            // process and draw the tooltip.
            this._debouncedTooltip(this._hoverPosition, this._drawableArea);
        };
        /**
         * Debounced processing and drawing of tooltip.
         */
        this._debouncedTooltip = Debounce((pos, drawableArea) => {
            this._preprocessTooltip(pos, drawableArea);
            this._drawTooltip(pos, drawableArea);
        }, TooltipDebounceTime);
        /**
         * Handles what to do when we stop hovering over the canvas.
         */
        this._handleStopHover = () => {
            this._hoverPosition = null;
        };
        /**
         * The handler for when we want to zoom in and out of the graph.
         *
         * @param event a mouse wheel event.
         */
        this._handleZoom = (event) => {
            event.preventDefault();
            if (!event.deltaY) {
                return;
            }
            const amount = ((event.deltaY * -0.01) | 0) * 100;
            const minZoom = 60;
            // The max zoom is the number of slices.
            const maxZoom = this._getNumberOfSlices();
            if (this._shouldBecomeRealtime()) {
                this._position = null;
            }
            // Bind the zoom between [minZoom, maxZoom]
            this._sizeOfWindow = Scalar.Clamp(this._sizeOfWindow - amount, minZoom, maxZoom);
        };
        /**
         * Initializes the panning object and attaches appropriate listener.
         *
         * @param event the mouse event containing positional information.
         */
        this._handlePanStart = (event) => {
            const { _ctx: ctx } = this;
            if (!ctx || !ctx.canvas) {
                return;
            }
            const canvas = ctx.canvas;
            this._panPosition = {
                xPos: event.clientX,
                delta: 0,
            };
            this._hoverPosition = null;
            canvas.addEventListener("mousemove", this._handlePan);
        };
        /**
         * While panning this event will keep track of the delta and update the "positions".
         *
         * @param event The mouse event that contains positional information.
         */
        this._handlePan = (event) => {
            if (!this._panPosition || this._getNumberOfSlices() === 0) {
                return;
            }
            const pixelDelta = this._panPosition.delta + event.clientX - this._panPosition.xPos;
            const pixelsPerItem = (this._drawableArea.right - this._drawableArea.left) / this._sizeOfWindow;
            const itemsDelta = (pixelDelta / pixelsPerItem) | 0;
            const pos = this._position ?? this._getNumberOfSlices() - 1;
            // update our position without allowing the user to pan more than they need to (approximation)
            this._position = Scalar.Clamp(pos - itemsDelta, Math.floor(this._sizeOfWindow * ScaleFactor), this._getNumberOfSlices() - Math.floor(this._sizeOfWindow * (1 - ScaleFactor)));
            if (itemsDelta === 0) {
                this._panPosition.delta += pixelDelta;
            }
            else {
                this._panPosition.delta = 0;
            }
            this._panPosition.xPos = event.clientX;
            this._prevPointById.clear();
            this._prevValueById.clear();
        };
        /**
         * Clears the panning object and removes the appropriate listener.
         */
        this._handlePanStop = () => {
            const { _ctx: ctx } = this;
            if (!ctx || !ctx.canvas) {
                return;
            }
            // check if we should return to realtime.
            if (this._shouldBecomeRealtime()) {
                this._position = null;
            }
            const canvas = ctx.canvas;
            canvas.removeEventListener("mousemove", this._handlePan);
            this._panPosition = null;
        };
        this._ctx = canvas.getContext && canvas.getContext("2d");
        this._width = canvas.width;
        this._height = canvas.height;
        this._ticks = [];
        this._panPosition = null;
        this._hoverPosition = null;
        this._position = null;
        this._datasetBounds = { start: 0, end: 0 };
        this._globalTimeMinMax = { min: Infinity, max: 0 };
        this._drawableArea = { top: 0, left: 0, right: 0, bottom: 0 };
        this._tooltipTextCache = { text: "", width: 0 };
        this._tickerTextCache = { text: "", width: 0 };
        this._tooltipItems = [];
        this._tickerItems = [];
        this._preprocessedTooltipInfo = { focusedId: "", longestText: "", numberOfTooltipItems: 0, xForActualTimestamp: 0 };
        this._numberOfTickers = 0;
        this._onVisibleRangeChangedObservable = settings.onVisibleRangeChangedObservable;
        for (let i = 0; i < MaximumDatasetsAllowed; i++) {
            this._tooltipItems.push({ text: "", color: "" });
            this._tickerItems.push({ text: "", id: "", max: 0, min: 0 });
        }
        if (!this._ctx) {
            throw Error("No canvas context accessible");
        }
        const defaultMetrics = this._ctx.measureText(Alphabet);
        this._defaultLineHeight = defaultMetrics.actualBoundingBoxAscent + defaultMetrics.actualBoundingBoxDescent;
        this._axisHeight = AxisLineLength + AxisPadding + this._defaultLineHeight + AxisPadding;
        this._ctx.save();
        this._ctx.font = GraphAddonFont;
        const fontMetrics = this._ctx.measureText(Alphabet);
        this._addonFontLineHeight = fontMetrics.actualBoundingBoxAscent + fontMetrics.actualBoundingBoxDescent;
        this._ctx.restore();
        this.datasets = settings.datasets;
        this.metadata = new Map();
        this._attachEventListeners(canvas);
    }
    /**
     * Update the canvas graph service with the new height and width of the canvas.
     * @param size The new size of the canvas.
     */
    resize(size) {
        const { _ctx: ctx } = this;
        const { width, height } = size;
        if (!ctx || !ctx.canvas) {
            return;
        }
        this._width = width;
        this._height = height;
        ctx.canvas.width = width;
        ctx.canvas.height = height;
        this.update();
    }
    /**
     * Force resets the position in the data, effectively returning to the most current data.
     */
    resetDataPosition() {
        this._position = null;
    }
    /**
     * This method draws the data and sets up the appropriate scales.
     */
    _draw() {
        const { _ctx: ctx } = this;
        if (!ctx) {
            return;
        }
        const numSlices = this._getNumberOfSlices();
        if (numSlices === 0) {
            return;
        }
        // First we clear the canvas so we can draw our data!
        this.clear();
        // Get global min max of time axis (across all datasets).
        this._globalTimeMinMax.min = Infinity;
        this._globalTimeMinMax.max = 0;
        // First we must get the end positions of our view port.
        const pos = this._position ?? numSlices - 1;
        let start = pos - Math.ceil(this._sizeOfWindow * ScaleFactor);
        let startOverflow = 0;
        // account for overflow from start.
        if (start < 0) {
            startOverflow = 0 - start;
            start = 0;
        }
        let end = Math.ceil(pos + this._sizeOfWindow * (1 - ScaleFactor) + startOverflow);
        // account for overflow from end.
        if (end > numSlices) {
            const endOverflow = end - numSlices;
            end = numSlices;
            start = Math.max(start - endOverflow, 0);
        }
        // update the bounds
        this._datasetBounds.start = start;
        this._datasetBounds.end = end;
        // next we must find the min and max timestamp in bounds. (Timestamps are sorted)
        this._globalTimeMinMax.min = this.datasets.data.at(this.datasets.startingIndices.at(this._datasetBounds.start));
        this._globalTimeMinMax.max = this.datasets.data.at(this.datasets.startingIndices.at(this._datasetBounds.end - 1));
        // set the buffer region maximum by rescaling the max timestamp in bounds.
        const bufferMaximum = Math.ceil((this._globalTimeMinMax.max - this._globalTimeMinMax.min) / ScaleFactor + this._globalTimeMinMax.min);
        // we then need to update the end position based on the maximum for the buffer region
        // binary search to get closest point to the buffer maximum.
        this._datasetBounds.end = this._getClosestPointToTimestamp(bufferMaximum) + 1;
        // keep track of largest timestamp value in view!
        this._globalTimeMinMax.max = Math.max(this.datasets.data.at(this.datasets.startingIndices.at(this._datasetBounds.end - 1)), this._globalTimeMinMax.max);
        const updatedScaleFactor = Scalar.Clamp((this._globalTimeMinMax.max - this._globalTimeMinMax.min) / (bufferMaximum - this._globalTimeMinMax.min), ScaleFactor, 1);
        // we will now set the global maximum to the maximum of the buffer.
        this._globalTimeMinMax.max = bufferMaximum;
        this._drawableArea.top = 0;
        this._drawableArea.left = 0;
        this._drawableArea.bottom = this._height;
        this._drawableArea.right = this._width;
        this._drawTickers(this._drawableArea, this._datasetBounds);
        this._drawTimeAxis(this._globalTimeMinMax, this._drawableArea);
        this._drawPlayheadRegion(this._drawableArea, updatedScaleFactor);
        this._drawableArea.top += DataPadding;
        this._drawableArea.bottom -= DataPadding;
        // pre-process tooltip info so we can use it in determining opacity of lines.
        this._preprocessTooltip(this._hoverPosition, this._drawableArea);
        const { left, right, bottom, top } = this._drawableArea;
        // process, and then draw our points
        for (let idOffset = 0; idOffset < this.datasets.ids.length; idOffset++) {
            const id = this.datasets.ids[idOffset];
            let valueMinMax;
            let prevPoint = this._prevPointById.get(id);
            let prevValue = this._prevValueById.get(id);
            let ticker = false;
            for (let i = 0; i < this._numberOfTickers; i++) {
                if (this._tickerItems[i].id === id) {
                    ticker = true;
                }
            }
            if (!ticker) {
                continue;
            }
            ctx.beginPath();
            ctx.strokeStyle = this.metadata.get(id)?.color ?? DefaultColor;
            // if we are focused on a line and not in live mode handle the opacities appropriately.
            if (this._preprocessedTooltipInfo.focusedId === id) {
                ctx.globalAlpha = DefaultAlpha;
            }
            else if (this._preprocessedTooltipInfo.focusedId !== "") {
                ctx.globalAlpha = BackgroundLineAlpha;
            }
            const values = new Array(this._datasetBounds.end - this._datasetBounds.start);
            for (let pointIndex = this._datasetBounds.start; pointIndex < this._datasetBounds.end; pointIndex++) {
                const numPoints = this.datasets.data.at(this.datasets.startingIndices.at(pointIndex) + PerformanceViewerCollector.NumberOfPointsOffset);
                if (idOffset >= numPoints) {
                    continue;
                }
                const valueIndex = this.datasets.startingIndices.at(pointIndex) + PerformanceViewerCollector.SliceDataOffset + idOffset;
                const value = this.datasets.data.at(valueIndex);
                if (prevValue === undefined) {
                    prevValue = value;
                    this._prevValueById.set(id, prevValue);
                }
                // perform smoothing
                const smoothedValue = SmoothingFactor * value + (1 - SmoothingFactor) * prevValue;
                values[pointIndex - this._datasetBounds.start] = smoothedValue;
                if (!valueMinMax) {
                    valueMinMax = {
                        min: smoothedValue,
                        max: smoothedValue,
                    };
                }
                this._prevValueById.set(id, smoothedValue);
                valueMinMax.min = Math.min(valueMinMax.min, smoothedValue);
                valueMinMax.max = Math.max(valueMinMax.max, smoothedValue);
            }
            const delta = valueMinMax.max - valueMinMax.min;
            valueMinMax.min -= RangeMargin * delta;
            valueMinMax.max += RangeMargin * delta;
            for (let pointIndex = this._datasetBounds.start; pointIndex < this._datasetBounds.end; pointIndex++) {
                const timestamp = this.datasets.data.at(this.datasets.startingIndices.at(pointIndex));
                const smoothedValue = values[pointIndex - this._datasetBounds.start];
                const drawableTime = this._getPixelForNumber(timestamp, this._globalTimeMinMax, left, right - left, false);
                const drawableValue = this._getPixelForNumber(smoothedValue, valueMinMax, top, bottom - top, true);
                if (prevPoint === undefined) {
                    prevPoint = [drawableTime, drawableValue];
                    this._prevPointById.set(id, prevPoint);
                }
                const xDifference = drawableTime - prevPoint[0];
                const skipLine = xDifference > MaxXDistancePercBetweenLinePoints * (right - left);
                if (skipLine) {
                    ctx.fillStyle = NoDataRectangleColor;
                    ctx.fillRect(prevPoint[0], top, xDifference, bottom - top);
                }
                else {
                    if (prevPoint[0] < drawableTime) {
                        ctx.moveTo(prevPoint[0], prevPoint[1]);
                        ctx.lineTo(drawableTime, drawableValue);
                    }
                }
                prevPoint[0] = drawableTime;
                prevPoint[1] = drawableValue;
            }
            ctx.stroke();
        }
        ctx.globalAlpha = DefaultAlpha;
        // then draw the tooltip.
        this._drawTooltip(this._hoverPosition, this._drawableArea);
    }
    _drawTickers(drawableArea, bounds) {
        const { _ctx: ctx } = this;
        if (!ctx) {
            return;
        }
        // create the ticker objects for each of the non hidden items.
        let longestText = "";
        this._numberOfTickers = 0;
        const valueMap = new Map();
        for (let idOffset = 0; idOffset < this.datasets.ids.length; idOffset++) {
            const id = this.datasets.ids[idOffset];
            if (this.metadata.get(id)?.hidden) {
                continue;
            }
            const valueMinMax = this._getMinMax(bounds, idOffset);
            const latestValue = this.datasets.data.at(this.datasets.startingIndices.at(bounds.end - 1) + PerformanceViewerCollector.SliceDataOffset + idOffset);
            const text = `${id}: ${latestValue.toFixed(2)} (max: ${valueMinMax.max.toFixed(2)}, min: ${valueMinMax.min.toFixed(2)})`;
            valueMap.set(id, {
                min: valueMinMax.min,
                max: valueMinMax.max,
                current: latestValue,
            });
            if (text.length > longestText.length) {
                longestText = text;
            }
            this._tickerItems[this._numberOfTickers].id = id;
            this._tickerItems[this._numberOfTickers].max = valueMinMax.max;
            this._tickerItems[this._numberOfTickers].min = valueMinMax.min;
            this._tickerItems[this._numberOfTickers].text = text;
            this._numberOfTickers++;
        }
        this._onVisibleRangeChangedObservable?.notifyObservers({ valueMap });
        ctx.save();
        ctx.font = GraphAddonFont;
        ctx.textBaseline = "middle";
        ctx.textAlign = "left";
        let width;
        // if the lengths are the same the estimate should be good enough given the padding.
        if (this._tickerTextCache.text.length === longestText.length) {
            width = this._tickerTextCache.width;
        }
        else {
            width = ctx.measureText(longestText).width + 2 * TickerHorizontalPadding;
            this._tickerTextCache.text = longestText;
            this._tickerTextCache.width = width;
        }
        ctx.restore();
    }
    /**
     * Returns the index of the closest time for the datasets.
     * Uses a modified binary search to get value.
     *
     * @param targetTime the time we want to get close to.
     * @returns index of the item with the closest time to the targetTime
     */
    _getClosestPointToTimestamp(targetTime) {
        let low = 0;
        let high = this._getNumberOfSlices() - 1;
        let closestIndex = 0;
        while (low <= high) {
            const middle = Math.trunc((low + high) / 2);
            const middleTimestamp = this.datasets.data.at(this.datasets.startingIndices.at(middle));
            if (Math.abs(middleTimestamp - targetTime) < Math.abs(this.datasets.data.at(this.datasets.startingIndices.at(closestIndex)) - targetTime)) {
                closestIndex = middle;
            }
            if (middleTimestamp < targetTime) {
                low = middle + 1;
            }
            else if (middleTimestamp > targetTime) {
                high = middle - 1;
            }
            else {
                break;
            }
        }
        return closestIndex;
    }
    /**
     * This is a convenience method to get the number of collected slices.
     * @returns the total number of collected slices.
     */
    _getNumberOfSlices() {
        return this.datasets.startingIndices.itemLength;
    }
    /**
     * Draws the time axis, adjusts the drawable area for the graph.
     *
     * @param timeMinMax the minimum and maximum for the time axis.
     * @param drawableArea the current allocated drawable area.
     */
    _drawTimeAxis(timeMinMax, drawableArea) {
        const { _ctx: ctx } = this;
        if (!ctx) {
            return;
        }
        const spaceAvailable = drawableArea.right - drawableArea.left;
        this._generateTicks(timeMinMax, spaceAvailable);
        // remove the height of the axis from the available drawable area.
        drawableArea.bottom -= this._axisHeight;
        // draw axis box.
        ctx.save();
        ctx.fillStyle = AxisColor;
        ctx.fillRect(drawableArea.left, drawableArea.bottom, spaceAvailable, this._axisHeight);
        // draw time axis line
        ctx.beginPath();
        ctx.strokeStyle = DefaultColor;
        ctx.moveTo(drawableArea.left, drawableArea.bottom);
        ctx.lineTo(drawableArea.right, drawableArea.bottom);
        // draw ticks and text.
        ctx.fillStyle = DefaultColor;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const timestampUnit = this._getTimestampUnit(this._ticks[this._ticks.length - 1]);
        for (const tick of this._ticks) {
            let position = this._getPixelForNumber(tick, timeMinMax, drawableArea.left, spaceAvailable, false);
            if (position > spaceAvailable) {
                position = spaceAvailable;
            }
            ctx.moveTo(position, drawableArea.bottom);
            ctx.lineTo(position, drawableArea.bottom + 10);
            ctx.fillText(this._parseTimestamp(tick, timestampUnit), position, drawableArea.bottom + 20);
        }
        ctx.stroke();
        ctx.restore();
    }
    /**
     * Given a timestamp (should be the maximum timestamp in view), this function returns the maximum unit the timestamp contains.
     * This information can be used for formatting purposes.
     * @param timestamp the maximum timestamp to find the maximum timestamp unit for.
     * @returns The maximum unit the timestamp has.
     */
    _getTimestampUnit(timestamp) {
        if (timestamp / MsInHour > 1) {
            return TimestampUnit.Hours;
        }
        else if (timestamp / MsInMinute > 1) {
            return TimestampUnit.Minutes;
        }
        else if (timestamp / MsInSecond > 1) {
            return TimestampUnit.Seconds;
        }
        else {
            return TimestampUnit.Milliseconds;
        }
    }
    /**
     * Given a timestamp and the interval unit, this function will parse the timestamp to the appropriate format.
     * @param timestamp The timestamp to parse
     * @param intervalUnit The maximum unit of the maximum timestamp in an interval.
     * @returns a string representing the parsed timestamp.
     */
    _parseTimestamp(timestamp, intervalUnit) {
        let parsedTimestamp = "";
        if (intervalUnit >= TimestampUnit.Hours) {
            const numHours = Math.floor(timestamp / MsInHour);
            timestamp -= numHours * MsInHour;
            parsedTimestamp += `${numHours.toString().padStart(intervalUnit > TimestampUnit.Hours ? 2 : 1, "0")}:`;
        }
        if (intervalUnit >= TimestampUnit.Minutes) {
            const numMinutes = Math.floor(timestamp / MsInMinute);
            timestamp -= numMinutes * MsInMinute;
            parsedTimestamp += `${numMinutes.toString().padStart(intervalUnit > TimestampUnit.Minutes ? 2 : 1, "0")}:`;
        }
        const numSeconds = Math.floor(timestamp / MsInSecond);
        timestamp -= numSeconds * MsInSecond;
        parsedTimestamp += numSeconds.toString().padStart(intervalUnit > TimestampUnit.Seconds ? 2 : 1, "0");
        if (timestamp > 0) {
            if (parsedTimestamp.length > 0) {
                parsedTimestamp += ".";
            }
            parsedTimestamp += Math.round(timestamp).toString().padStart(3, "0");
        }
        return parsedTimestamp;
    }
    /**
     * Generates a list of ticks given the min and max of the axis, and the space available in the axis.
     *
     * @param minMax the minimum and maximum values of the axis
     * @param spaceAvailable the total amount of space we have allocated to our axis
     */
    _generateTicks(minMax, spaceAvailable) {
        const { min, max } = minMax;
        const minTickSpacing = 40;
        this._ticks.length = 0;
        const maxTickCount = Math.ceil(spaceAvailable / minTickSpacing);
        const range = this._niceNumber(max - min, false);
        const spacing = this._niceNumber(range / (maxTickCount - 1), true);
        const niceMin = Math.floor(min / spacing) * spacing;
        const niceMax = Math.floor(max / spacing) * spacing;
        for (let i = niceMin; i <= niceMax + 0.5 * spacing; i += spacing) {
            this._ticks.push(i);
        }
    }
    /**
     * Nice number algorithm based on psueudo code defined in "Graphics Gems" by Andrew S. Glassner.
     * This will find a "nice" number approximately equal to num.
     *
     * @param num The number we want to get close to.
     * @param shouldRound if true we will round the number, otherwise we will get the ceiling.
     * @returns a "nice" number approximately equal to num.
     */
    _niceNumber(num, shouldRound) {
        const exp = Math.floor(Math.log10(num));
        const fraction = num / Math.pow(10, exp);
        let niceFraction;
        if (shouldRound) {
            if (fraction < 1.5) {
                niceFraction = 1;
            }
            else if (fraction < 3) {
                niceFraction = 2;
            }
            else if (fraction < 7) {
                niceFraction = 5;
            }
            else {
                niceFraction = 10;
            }
        }
        else {
            if (fraction <= 1) {
                niceFraction = 1;
            }
            else if (fraction <= 2) {
                niceFraction = 2;
            }
            else if (fraction <= 5) {
                niceFraction = 5;
            }
            else {
                niceFraction = 10;
            }
        }
        return niceFraction * Math.pow(10, exp);
    }
    /**
     * Gets the min and max as a single object from an array of numbers.
     * @param bounds
     * @param offset
     * @returns the min and max of the array.
     */
    _getMinMax(bounds, offset) {
        let min = Infinity, max = 0;
        for (let i = bounds.start; i < bounds.end; i++) {
            const numPoints = this.datasets.data.at(this.datasets.startingIndices.at(i) + PerformanceViewerCollector.NumberOfPointsOffset);
            if (offset >= numPoints) {
                continue;
            }
            const itemIndex = this.datasets.startingIndices.at(i) + PerformanceViewerCollector.SliceDataOffset + offset;
            const item = this.datasets.data.at(itemIndex);
            if (item < min) {
                min = item;
            }
            if (item > max) {
                max = item;
            }
        }
        return {
            min,
            max,
        };
    }
    /**
     * Converts a single number to a pixel coordinate in a single axis by normalizing the data to a [0, 1] scale using the minimum and maximum values.
     *
     * @param num the number we want to get the pixel coordinate for
     * @param minMax the min and max of the dataset in the axis we want the pixel coordinate for.
     * @param startingPixel the starting pixel coordinate (this means it takes account for any offset).
     * @param spaceAvailable the total space available in this axis.
     * @param shouldFlipValue if we should use a [1, 0] scale instead of a [0, 1] scale.
     * @returns the pixel coordinate of the value in a single axis.
     */
    _getPixelForNumber(num, minMax, startingPixel, spaceAvailable, shouldFlipValue) {
        const { min, max } = minMax;
        // Perform a min-max normalization to rescale the value onto a [0, 1] scale given the min and max of the dataset.
        let normalizedValue = Math.abs(max - min) > 0.001 ? (num - min) / (max - min) : 0.5;
        // if we should make this a [1, 0] range instead (higher numbers = smaller pixel value)
        if (shouldFlipValue) {
            normalizedValue = 1 - normalizedValue;
        }
        return startingPixel + normalizedValue * spaceAvailable;
    }
    /**
     * Add in any necessary event listeners.
     *
     * @param canvas The canvas we want to attach listeners to.
     */
    _attachEventListeners(canvas) {
        canvas.addEventListener("wheel", this._handleZoom);
        canvas.addEventListener("mousemove", this._handleDataHover);
        canvas.addEventListener("mousedown", this._handlePanStart);
        canvas.addEventListener("mouseleave", this._handleStopHover);
        // The user may stop panning outside of the canvas size so we should add the event listener to the document.
        canvas.ownerDocument.addEventListener("mouseup", this._handlePanStop);
    }
    /**
     * We remove all event listeners we added.
     *
     * @param canvas The canvas we want to remove listeners from.
     */
    _removeEventListeners(canvas) {
        canvas.removeEventListener("wheel", this._handleZoom);
        canvas.removeEventListener("mousemove", this._handleDataHover);
        canvas.removeEventListener("mousedown", this._handlePanStart);
        canvas.removeEventListener("mouseleave", this._handleStopHover);
        canvas.ownerDocument.removeEventListener("mouseup", this._handlePanStop);
    }
    /**
     * Given a line defined by P1: (x1, y1) and P2: (x2, y2) get the distance of P0 (x0, y0) from the line.
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points
     * @param x1 x position of point P1
     * @param y1 y position of point P1
     * @param x2 x position of point P2
     * @param y2 y position of point P2
     * @param x0 x position of point P0
     * @param y0 y position of point P0
     * @returns distance of P0 from the line defined by P1 and P2
     */
    _getDistanceFromLine(x1, y1, x2, y2, x0, y0) {
        // if P1 and P2 are the same we just get the distance between P1 and P0
        if (x1 === x2 && y1 === y2) {
            return Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));
        }
        // next we want to handle the case where our point is beyond the y position of our line
        let topX = 0;
        let topY = 0;
        let bottomX = 0;
        let bottomY = 0;
        if (y1 >= y2) {
            topX = x1;
            topY = y1;
            bottomX = x2;
            bottomY = y2;
        }
        else {
            topX = x2;
            topY = y2;
            bottomX = x1;
            bottomY = y1;
        }
        if (y0 < bottomY) {
            return Math.sqrt(Math.pow(bottomX - x0, 2) + Math.pow(bottomY - y0, 2));
        }
        if (y0 > topY) {
            return Math.sqrt(Math.pow(topX - x0, 2) + Math.pow(topY - y0, 2));
        }
        // the general case!
        const numerator = Math.abs((x2 - x1) * (y1 - y0) - (x1 - x0) * (y2 - y1));
        const denominator = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        return numerator / denominator;
    }
    /**
     * This method does preprocessing calculations for the tooltip.
     * @param pos the position of our mouse.
     * @param drawableArea the remaining drawable area.
     */
    _preprocessTooltip(pos, drawableArea) {
        const { _ctx: ctx } = this;
        if (pos === null || !ctx || !ctx.canvas || this._getNumberOfSlices() === 0) {
            return;
        }
        const { left, top } = ctx.canvas.getBoundingClientRect();
        const adjustedYPos = pos.yPos - top;
        let adjustedXPos = pos.xPos - left;
        if (adjustedXPos > drawableArea.right) {
            adjustedXPos = drawableArea.right;
        }
        // convert the mouse x position in pixels to a timestamp.
        const inferredTimestamp = this._getNumberFromPixel(adjustedXPos, this._globalTimeMinMax, drawableArea.left, drawableArea.right, false);
        let longestText = "";
        let numberOfTooltipItems = 0;
        // get the closest timestamps to the target timestamp, and store the appropriate meta object.
        const closestIndex = this._getClosestPointToTimestamp(inferredTimestamp);
        let actualTimestamp = 0;
        let closestLineId = "";
        let closestLineValueMinMax = { min: 0, max: 0 };
        let closestLineDistance = Number.POSITIVE_INFINITY;
        for (let idOffset = 0; idOffset < this.datasets.ids.length; idOffset++) {
            const id = this.datasets.ids[idOffset];
            if (this.metadata.get(id)?.hidden) {
                continue;
            }
            const numPoints = this.datasets.data.at(this.datasets.startingIndices.at(closestIndex) + PerformanceViewerCollector.NumberOfPointsOffset);
            if (idOffset >= numPoints) {
                continue;
            }
            const valueAtClosestPointIndex = this.datasets.startingIndices.at(closestIndex) + PerformanceViewerCollector.SliceDataOffset + idOffset;
            const valueAtClosestPoint = this.datasets.data.at(valueAtClosestPointIndex);
            let valueMinMax;
            // we would have already calculated  the min and max while getting the tickers, so use those, and get first one.
            for (let i = 0; i < this._numberOfTickers; i++) {
                if (this._tickerItems[i].id === id) {
                    valueMinMax = this._tickerItems[i];
                }
            }
            if (!valueMinMax) {
                continue;
            }
            actualTimestamp = this.datasets.data.at(this.datasets.startingIndices.at(closestIndex));
            const valueAtClosestPointYPos = this._getPixelForNumber(valueAtClosestPoint, valueMinMax, drawableArea.top, drawableArea.bottom - drawableArea.top, true);
            const xForActualTimestamp = this._getPixelForNumber(actualTimestamp, this._globalTimeMinMax, drawableArea.left, drawableArea.right - drawableArea.left, false);
            const text = `${id}: ${valueAtClosestPoint.toFixed(2)}`;
            if (text.length > longestText.length) {
                longestText = text;
            }
            this._tooltipItems[numberOfTooltipItems].text = text;
            this._tooltipItems[numberOfTooltipItems].color = this.metadata.get(id)?.color ?? DefaultColor;
            numberOfTooltipItems++;
            // don't process rest if we aren't panned.
            if (!this._position) {
                continue;
            }
            // initially distance between closest data point and mouse point.
            let distance = this._getDistanceFromLine(xForActualTimestamp, valueAtClosestPointYPos, xForActualTimestamp, valueAtClosestPointYPos, pos.xPos - left, adjustedYPos);
            // get the shortest distance between the point and the line segment infront, and line segment behind, store the shorter distance (if shorter than distance between closest data point and mouse).
            if (closestIndex + 1 < this.datasets.data.itemLength &&
                this.datasets.data.at(this.datasets.startingIndices.at(closestIndex + 1) + PerformanceViewerCollector.NumberOfPointsOffset) > idOffset) {
                const secondPointTimestamp = this.datasets.data.at(this.datasets.startingIndices.at(closestIndex + 1));
                const secondPointX = this._getPixelForNumber(secondPointTimestamp, this._globalTimeMinMax, drawableArea.left, drawableArea.right - drawableArea.left, false);
                const secondPointValue = this.datasets.data.at(this.datasets.startingIndices.at(closestIndex + 1) + PerformanceViewerCollector.SliceDataOffset + idOffset);
                const secondPointY = this._getPixelForNumber(secondPointValue, valueMinMax, drawableArea.top, drawableArea.bottom - drawableArea.top, true);
                distance = Math.min(this._getDistanceFromLine(xForActualTimestamp, valueAtClosestPointYPos, secondPointX, secondPointY, pos.xPos - left, adjustedYPos), distance);
            }
            if (closestIndex - 1 >= 0 && this.datasets.data.at(this.datasets.startingIndices.at(closestIndex + 1) + PerformanceViewerCollector.NumberOfPointsOffset) > idOffset) {
                const secondPointTimestamp = this.datasets.data.at(this.datasets.startingIndices.at(closestIndex - 1));
                const secondPointX = this._getPixelForNumber(secondPointTimestamp, this._globalTimeMinMax, drawableArea.left, drawableArea.right - drawableArea.left, false);
                const secondPointValue = this.datasets.data.at(this.datasets.startingIndices.at(closestIndex - 1) + PerformanceViewerCollector.SliceDataOffset + idOffset);
                const secondPointY = this._getPixelForNumber(secondPointValue, valueMinMax, drawableArea.top, drawableArea.bottom - drawableArea.top, true);
                distance = Math.min(this._getDistanceFromLine(xForActualTimestamp, valueAtClosestPointYPos, secondPointX, secondPointY, pos.xPos - left, adjustedYPos), distance);
            }
            if (distance < closestLineDistance) {
                closestLineId = id;
                closestLineDistance = distance;
                closestLineValueMinMax = valueMinMax;
            }
        }
        const xForActualTimestamp = this._getPixelForNumber(actualTimestamp, this._globalTimeMinMax, drawableArea.left, drawableArea.right - drawableArea.left, false);
        this._preprocessedTooltipInfo.xForActualTimestamp = xForActualTimestamp;
        // check if hover is within a certain distance, if so it is our only item in our tooltip.
        if (closestLineDistance <= MaxDistanceForHover && this._position) {
            this._preprocessedTooltipInfo.focusedId = closestLineId;
            const inferredValue = this._getNumberFromPixel(adjustedYPos, closestLineValueMinMax, drawableArea.top, drawableArea.bottom, true);
            const closestLineText = `${closestLineId}: ${inferredValue.toFixed(2)}`;
            this._preprocessedTooltipInfo.longestText = closestLineText;
            this._preprocessedTooltipInfo.numberOfTooltipItems = 1;
            this._tooltipItems[0].text = closestLineText;
            this._tooltipItems[0].color = this.metadata.get(closestLineId)?.color ?? DefaultColor;
        }
        else {
            this._preprocessedTooltipInfo.focusedId = "";
            this._preprocessedTooltipInfo.longestText = longestText;
            this._preprocessedTooltipInfo.numberOfTooltipItems = numberOfTooltipItems;
        }
    }
    /**
     * Draws the tooltip given the area it is allowed to draw in and the current pixel position.
     *
     * @param pos the position of the mouse cursor in pixels (x, y).
     * @param drawableArea  the available area we can draw in.
     */
    _drawTooltip(pos, drawableArea) {
        const { _ctx: ctx } = this;
        if (pos === null || !ctx || !ctx.canvas || this._getNumberOfSlices() === 0) {
            return;
        }
        const { left, top } = ctx.canvas.getBoundingClientRect();
        const { numberOfTooltipItems, xForActualTimestamp, longestText } = this._preprocessedTooltipInfo;
        ctx.save();
        // draw pointer triangle
        ctx.fillStyle = PositionIndicatorColor;
        const yTriangle = drawableArea.bottom + TrianglePaddingFromAxisLine;
        ctx.beginPath();
        ctx.moveTo(xForActualTimestamp, yTriangle);
        ctx.lineTo(xForActualTimestamp + TriangleWidth / 2, yTriangle + TriangleHeight);
        ctx.lineTo(xForActualTimestamp - TriangleWidth / 2, yTriangle + TriangleHeight);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = PositionIndicatorColor;
        ctx.beginPath();
        // draw vertical or horizontal line depending on if focused on a point on the line.
        if (this._preprocessedTooltipInfo.focusedId === "") {
            ctx.moveTo(xForActualTimestamp, drawableArea.bottom);
            ctx.lineTo(xForActualTimestamp, TopOfGraphY);
        }
        else {
            const lineY = pos.yPos - top;
            ctx.moveTo(drawableArea.left, lineY);
            ctx.lineTo(drawableArea.right, lineY);
        }
        ctx.stroke();
        // draw the actual tooltip
        ctx.font = GraphAddonFont;
        ctx.textBaseline = "middle";
        ctx.textAlign = "left";
        const boxLength = this._addonFontLineHeight;
        const textHeight = this._addonFontLineHeight + Math.floor(TooltipHorizontalPadding / 2);
        // initialize width with cached value or measure width of longest text and update cache.
        let width;
        if (longestText === this._tooltipTextCache.text) {
            width = this._tooltipTextCache.width;
        }
        else {
            width = ctx.measureText(longestText).width + boxLength + 2 * TooltipHorizontalPadding + SpaceBetweenTextAndBox;
            this._tooltipTextCache.text = longestText;
            this._tooltipTextCache.width = width;
        }
        const tooltipHeight = textHeight * (numberOfTooltipItems + 1);
        let x = pos.xPos - left;
        let y = drawableArea.bottom - TooltipPaddingFromBottom - tooltipHeight;
        // We want the tool tip to always be inside the canvas so we adjust which way it is drawn.
        if (x + width > this._width) {
            x -= width;
        }
        ctx.globalAlpha = TooltipBackgroundAlpha;
        ctx.fillStyle = TooltipBackgroundColor;
        ctx.fillRect(x, y, width, tooltipHeight);
        ctx.globalAlpha = DefaultAlpha;
        x += TooltipHorizontalPadding;
        y += textHeight;
        for (let i = 0; i < numberOfTooltipItems; i++) {
            const tooltipItem = this._tooltipItems[i];
            ctx.fillStyle = tooltipItem.color;
            ctx.fillRect(x, y - Math.floor(boxLength / 2), boxLength, boxLength);
            ctx.fillStyle = TooltipForegroundColor;
            ctx.fillText(tooltipItem.text, x + boxLength + SpaceBetweenTextAndBox, y);
            y += textHeight;
        }
        ctx.restore();
    }
    /**
     * Gets the number from a pixel position given the minimum and maximum value in range, and the starting pixel and the ending pixel.
     *
     * @param pixel current pixel position we want to get the number for.
     * @param minMax the minimum and maximum number in the range.
     * @param startingPixel position of the starting pixel in range.
     * @param endingPixel position of ending pixel in range.
     * @param shouldFlip if we should use a [1, 0] scale instead of a [0, 1] scale.
     * @returns number corresponding to pixel position
     */
    _getNumberFromPixel(pixel, minMax, startingPixel, endingPixel, shouldFlip) {
        // normalize pixel to range [0, 1].
        let normalizedPixelPosition = (pixel - startingPixel) / (endingPixel - startingPixel);
        // we should use a [1, 0] scale instead.
        if (shouldFlip) {
            normalizedPixelPosition = 1 - normalizedPixelPosition;
        }
        return minMax.min + normalizedPixelPosition * (minMax.max - minMax.min);
    }
    /**
     * Method which returns true if the data should become realtime, false otherwise.
     *
     * @returns if the data should become realtime or not.
     */
    _shouldBecomeRealtime() {
        if (this._getNumberOfSlices() === 0) {
            return false;
        }
        // we need to compare our current slice to the latest slice to see if we should return to realtime mode.
        const pos = this._position;
        const latestSlicePos = this._getNumberOfSlices() - 1;
        if (pos === null) {
            return false;
        }
        // account for overflow on the left side only as it will be the one determining if we have sufficiently caught up to the realtime data.
        const overflow = Math.max(0 - (pos - Math.ceil(this._sizeOfWindow * ScaleFactor)), 0);
        const rightmostPos = Math.min(overflow + pos + Math.ceil(this._sizeOfWindow * (1 - ScaleFactor)), latestSlicePos);
        return (this.datasets.data.at(this.datasets.startingIndices.at(rightmostPos)) / this.datasets.data.at(this.datasets.startingIndices.at(latestSlicePos)) > ReturnToLiveThreshold);
    }
    /**
     * Will generate a playhead with a futurebox that takes up (1-scalefactor)*100% of the canvas.
     *
     * @param drawableArea The remaining drawable area.
     * @param scaleFactor The Percentage between 0.0 and 1.0 of the canvas the data gets drawn on.
     */
    _drawPlayheadRegion(drawableArea, scaleFactor) {
        const { _ctx: ctx } = this;
        if (!ctx || scaleFactor >= StopDrawingPlayheadThreshold) {
            return;
        }
        const dividerXPos = Math.ceil(drawableArea.right * scaleFactor);
        const playheadPos = dividerXPos - PlayheadSize;
        const futureBoxPos = dividerXPos + DividerSize;
        const rectangleHeight = drawableArea.bottom - drawableArea.top - 1;
        ctx.save();
        ctx.fillStyle = FutureBoxColor;
        ctx.fillRect(futureBoxPos, drawableArea.top, drawableArea.right - futureBoxPos, rectangleHeight);
        ctx.fillStyle = DividerColor;
        ctx.fillRect(dividerXPos, drawableArea.top, DividerSize, rectangleHeight);
        ctx.fillStyle = PlayheadColor;
        ctx.fillRect(playheadPos, drawableArea.top, PlayheadSize, rectangleHeight);
        ctx.restore();
    }
    /**
     *  Method to do cleanup when the object is done being used.
     *
     */
    destroy() {
        if (!this._ctx || !this._ctx.canvas) {
            return;
        }
        this._removeEventListeners(this._ctx.canvas);
        this._ctx = null;
    }
    /**
     * This method clears the canvas
     */
    clear() {
        const { _ctx: ctx, _width, _height } = this;
        // If we do not have a context we can't really do much here!
        if (!ctx) {
            return;
        }
        // save the transformation matrix, clear the canvas then restore.
        ctx.save();
        ctx.resetTransform();
        ctx.clearRect(0, 0, _width, _height);
        ctx.restore();
    }
}

const useStyles$K = makeStyles({
    canvas: {
        flexGrow: 1,
        width: "100%",
        height: "100%",
    },
});
const CanvasGraph = (props) => {
    const { collector, scene, layoutObservable, returnToPlayheadObservable, onVisibleRangeChangedObservable, initialGraphSize } = props;
    const classes = useStyles$K();
    const canvasRef = useRef(null);
    useEffect(() => {
        if (!canvasRef.current) {
            return;
        }
        if (initialGraphSize) {
            canvasRef.current.width = initialGraphSize.x;
            canvasRef.current.height = initialGraphSize.y;
        }
        let cs;
        try {
            cs = new CanvasGraphService(canvasRef.current, { datasets: collector.datasets, onVisibleRangeChangedObservable });
        }
        catch (error) {
            Logger.Error(error);
            return;
        }
        const layoutUpdated = (newSize) => {
            if (!canvasRef.current) {
                return;
            }
            const { left, top } = canvasRef.current.getBoundingClientRect();
            newSize.width = newSize.width - left;
            newSize.height = newSize.height - top;
            cs?.resize(newSize);
        };
        const dataUpdated = () => {
            cs?.update();
        };
        const metaUpdated = (meta) => {
            if (!cs) {
                return;
            }
            cs.metadata = meta;
            cs.update();
        };
        const resetDataPosition = () => {
            cs?.resetDataPosition();
        };
        scene.onAfterRenderObservable.add(dataUpdated);
        collector.metadataObservable.add(metaUpdated);
        layoutObservable?.add(layoutUpdated);
        returnToPlayheadObservable?.add(resetDataPosition);
        return () => {
            cs?.destroy();
            layoutObservable?.removeCallback(layoutUpdated);
            scene.onAfterRenderObservable.removeCallback(dataUpdated);
            collector.metadataObservable.removeCallback(metaUpdated);
        };
    }, [canvasRef, collector, scene, layoutObservable, returnToPlayheadObservable, onVisibleRangeChangedObservable, initialGraphSize]);
    return jsx("canvas", { className: classes.canvas, ref: canvasRef });
};

const SpinButton = forwardRef((props, ref) => {
    SpinButton.displayName = "SpinButton";
    const classes = useInputStyles$1();
    const { size } = useContext(ToolContext);
    const { min, max } = props;
    const [value, setValue] = useState(props.value);
    const lastCommittedValue = useRef(props.value);
    // step and forceInt are not mutually exclusive since there could be cases where you want to forceInt but have spinButton jump >1 int per spin
    const step = props.step != undefined ? props.step : props.forceInt ? 1 : undefined;
    const precision = Math.min(4, step !== undefined ? Math.max(0, CalculatePrecision(step)) : 2); // If no step, set precision to 2. Regardless, cap precision at 4 to avoid wild numbers
    useEffect(() => {
        if (props.value !== lastCommittedValue.current) {
            lastCommittedValue.current = props.value;
            setValue(props.value); // Update local state when props.value changes
        }
    }, [props.value]);
    const validateValue = (numericValue) => {
        const outOfBounds = (min !== undefined && numericValue < min) || (max !== undefined && numericValue > max);
        const failsValidator = props.validator && !props.validator(numericValue);
        const failsIntCheck = props.forceInt ? !Number.isInteger(numericValue) : false;
        const invalid = !!outOfBounds || !!failsValidator || isNaN(numericValue) || !!failsIntCheck;
        return !invalid;
    };
    const tryCommitValue = (currVal) => {
        // Only commit if valid and different from last committed value
        if (validateValue(currVal) && currVal !== lastCommittedValue.current) {
            lastCommittedValue.current = currVal;
            props.onChange(currVal);
        }
    };
    const handleChange = (event, data) => {
        event.stopPropagation(); // Prevent event propagation
        if (data.value != null && !Number.isNaN(data.value)) {
            setValue(data.value);
            tryCommitValue(data.value);
        }
    };
    const handleKeyUp = (event) => {
        event.stopPropagation(); // Prevent event propagation
        if (event.key !== "Enter") {
            const currVal = parseFloat(event.target.value); // Cannot use currentTarget.value as it won't have the most recently typed value
            setValue(currVal);
            tryCommitValue(currVal);
        }
    };
    const id = useId("spin-button");
    const mergedClassName = mergeClasses(classes.input, !validateValue(value) ? classes.invalid : "", props.className);
    // Build input slot from inputClassName
    const inputSlot = {
        className: mergeClasses(classes.inputSlot, props.inputClassName),
    };
    const spinButton = (jsx(SpinButton$1, { ref: ref, ...props, appearance: "outline", input: inputSlot, step: step, id: id, size: size, precision: precision, displayValue: `${value.toFixed(precision)}${props.unit ? " " + props.unit : ""}`, value: value, onChange: handleChange, onKeyUp: handleKeyUp, onKeyDown: HandleKeyDown, onBlur: HandleOnBlur, className: mergedClassName }));
    return props.infoLabel ? (jsxs("div", { className: classes.container, children: [jsx(InfoLabel, { ...props.infoLabel, htmlFor: id }), spinButton] })) : (spinButton);
});

const TextInput = (props) => {
    TextInput.displayName = "TextInput";
    const classes = useInputStyles$1();
    const [value, setValue] = useState(props.value);
    const lastCommittedValue = useRef(props.value);
    const { size } = useContext(ToolContext);
    useEffect(() => {
        if (props.value !== lastCommittedValue.current) {
            setValue(props.value); // Update local state when props.value changes
            lastCommittedValue.current = props.value;
        }
    }, [props.value]);
    const validateValue = (val) => {
        const failsValidator = props.validator && !props.validator(val);
        return !failsValidator;
    };
    const tryCommitValue = (currVal) => {
        // Only commit if valid and different from last committed value
        if (validateValue(currVal) && currVal !== lastCommittedValue.current) {
            lastCommittedValue.current = currVal;
            props.onChange(currVal);
        }
    };
    const handleChange = (event, data) => {
        event.stopPropagation();
        setValue(data.value);
        if (!props.validateOnlyOnBlur) {
            tryCommitValue(data.value);
        }
    };
    const handleKeyUp = (event) => {
        event.stopPropagation();
        if (!props.validateOnlyOnBlur) {
            tryCommitValue(event.currentTarget.value);
        }
    };
    const handleBlur = (event) => {
        HandleOnBlur(event);
        if (props.validateOnlyOnBlur) {
            tryCommitValue(event.currentTarget.value);
        }
    };
    const mergedClassName = mergeClasses(classes.input, !validateValue(value) ? classes.invalid : "", props.className);
    const id = useId("input-button");
    return (jsxs("div", { className: classes.container, children: [props.infoLabel && jsx(InfoLabel, { ...props.infoLabel, htmlFor: id }), jsx(Input, { ...props, input: { className: classes.inputSlot }, id: id, size: size, value: value, onChange: handleChange, onKeyUp: handleKeyUp, onKeyDown: HandleKeyDown, onBlur: handleBlur, className: mergedClassName })] }));
};

const useDropdownStyles = makeStyles({
    dropdown: {
        minWidth: 0,
        width: "100%",
    },
    container: {
        display: "flex",
        flexDirection: "column",
        justifyContent: "center", // align items vertically
    },
    dropdownText: { textAlign: "end", textOverflow: "ellipsis", whiteSpace: "nowrap", overflowX: "hidden" },
});
/**
 * Renders a fluent UI dropdown component for the options passed in, and an additional 'Not Defined' option if null is set to true
 * This component can handle both null and undefined values
 * @param props
 * @returns dropdown component
 */
const Dropdown = (props) => {
    Dropdown.displayName = "Dropdown";
    const classes = useDropdownStyles();
    const { options, value } = props;
    const [defaultVal, setDefaultVal] = useState(props.value);
    const { size } = useContext(ToolContext);
    useEffect(() => {
        setDefaultVal(value);
    }, [props.value]);
    const id = useId("dropdown");
    const mergedClassName = mergeClasses(classes.container, props.className);
    const optionLabel = options.find((o) => o.value === defaultVal)?.label;
    return (jsxs("div", { className: mergedClassName, children: [props.infoLabel && jsx(InfoLabel, { ...props.infoLabel, htmlFor: id }), jsx(Dropdown$1, { id: id, disabled: props.disabled, size: size, className: classes.dropdown, button: jsx("span", { className: classes.dropdownText, children: optionLabel }), onOptionSelect: (evt, data) => {
                    const value = typeof props.value === "number" ? Number(data.optionValue) : data.optionValue;
                    if (value !== undefined) {
                        setDefaultVal(value);
                        props.onChange(value);
                    }
                }, selectedOptions: [defaultVal.toString()], value: optionLabel, children: options.map((option) => (jsx(Option, { value: option.value.toString(), disabled: false, children: option.label }, option.label))) })] }));
};
const NumberDropdown = Dropdown;
const StringDropdown = Dropdown;

const useStyles$J = makeStyles({
    surface: {
        maxWidth: "400px",
    },
    content: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalM,
        padding: tokens.spacingHorizontalL,
        minWidth: "300px",
    },
});
const Popover = forwardRef((props, ref) => {
    const { children, open: controlledOpen, onOpenChange, positioning, surfaceClassName } = props;
    const [internalOpen, setInternalOpen] = useState(false);
    const classes = useStyles$J();
    const isControlled = controlledOpen !== undefined;
    const popoverOpen = isControlled ? controlledOpen : internalOpen;
    const handleOpenChange = (_, data) => {
        if (!isControlled) {
            setInternalOpen(data.open);
        }
        onOpenChange?.(data.open);
    };
    return (jsxs(Popover$1, { open: popoverOpen, onOpenChange: handleOpenChange, positioning: positioning ?? {
            align: "start",
            overflowBoundary: document.body,
            autoSize: true,
        }, children: [jsx(PopoverTrigger, { disableButtonEnhancement: true, children: props.trigger ?? jsx(Button, { ref: ref, icon: props.icon, onClick: () => handleOpenChange(null, { open: true }) }) }), jsx(PopoverSurface, { className: surfaceClassName ?? classes.surface, children: jsx("div", { className: classes.content, children: children }) })] }));
});
Popover.displayName = "Popover";

const useColorPickerStyles = makeStyles({
    container: {
        width: "350px",
        display: "flex", // becomes a flexbox
        flexDirection: "column", // with children in a column
        alignItems: "center", // centers children horizontally
        justifyContent: "center", // centers children vertically (if height is set)
        gap: tokens.spacingVerticalM,
        overflow: "visible",
    },
    row: {
        flex: 1, // is a row in the container's flex column
        display: "flex", // becomes its own flexbox
        flexDirection: "row", // with children in a row
        gap: tokens.spacingHorizontalXL,
        alignItems: "center", // align items vertically
        width: "100%",
    },
    colorPicker: {
        flex: 1,
        width: "350px",
        height: "350px",
    },
    previewColor: {
        width: "60px",
        height: "60px",
        borderRadius: tokens.borderRadiusMedium, // 4px?
        border: `${tokens.spacingVerticalXXS} solid ${tokens.colorNeutralShadowKeyLighter}`,
        "@media (forced-colors: active)": {
            forcedColorAdjust: "none", // ensures elmement maintains color in high constrast mode
        },
    },
    inputRow: {
        display: "flex",
        flexDirection: "row",
        flex: 1, // grow and fill available space
        justifyContent: "center",
        gap: "10px",
        width: "100%",
    },
    inputField: {
        flex: 1, // grow and fill available space
        width: "auto",
        minWidth: 0,
        gap: tokens.spacingVerticalSNudge, // 6px
    },
    trigger: {
        display: "flex",
        alignItems: "center",
    },
});
const ColorPickerPopup = forwardRef((props, ref) => {
    ColorPickerPopup.displayName = "ColorPickerPopup";
    const { value, onChange, isLinearMode, ...rest } = props;
    const classes = useColorPickerStyles();
    const [color, setColor] = useState(value);
    const [isLinear, setIsLinear] = useState(isLinearMode ?? false);
    const [isFloat, setFloat] = useState(false);
    const { size } = useContext(ToolContext);
    useEffect(() => {
        setColor(value); // Ensures the trigger color updates when props.value changes
    }, [value]);
    const handleColorPickerChange = (_, data) => {
        let color = Color3.FromHSV(data.color.h, data.color.s, data.color.v);
        if (value instanceof Color4) {
            color = Color4.FromColor3(color, data.color.a ?? 1);
        }
        handleChange(color);
    };
    const handleChange = (newColor) => {
        setColor(newColor);
        onChange(newColor); // Ensures the parent is notified when color changes from within colorPicker
    };
    return (jsx(Popover, { trigger: jsx(ColorSwatch, { className: classes.trigger, ref: ref, ...rest, borderColor: tokens.colorNeutralShadowKeyDarker, size: size === "small" ? "extra-small" : "small", shape: "rounded", color: color.toHexString(), value: color.toHexString().slice(1) }), children: jsxs("div", { className: classes.container, children: [jsxs(ColorPicker, { className: classes.colorPicker, color: rgbaToHsv(color), onColorChange: handleColorPickerChange, children: [jsx(ColorArea, { inputX: { "aria-label": "Saturation" }, inputY: { "aria-label": "Brightness" } }), jsx(ColorSlider, { "aria-label": "Hue" }), color instanceof Color4 && jsx(AlphaSlider, { "aria-label": "Alpha" })] }), jsxs("div", { className: classes.row, children: [jsx("div", { className: classes.previewColor, style: { backgroundColor: color.toHexString() } }), jsx(NumberDropdown, { className: classes.inputField, infoLabel: {
                                label: "Color Space",
                                info: jsx(Body1, { children: "Today this is not mutable as the color space is determined by the entity. Soon we will allow swapping" }),
                            }, options: [
                                { label: "Gamma", value: 0 },
                                { label: "Linear", value: 1 },
                            ], disabled: true, value: isLinear ? 1 : 0, onChange: (val) => setIsLinear(val === 1) }), jsx(NumberDropdown, { className: classes.inputField, infoLabel: {
                                label: "Data Type",
                                info: jsx(Body1, { children: "We will introduce this functionality soon!" }),
                            }, options: [
                                { label: "Int", value: 0 },
                                { label: "Float", value: 1 },
                            ], disabled: true, value: isFloat ? 1 : 0, onChange: (val) => setFloat(val === 1) })] }), jsxs("div", { className: classes.inputRow, children: [jsx(InputRgbField, { title: "Red", value: color, rgbKey: "r", onChange: handleChange }), jsx(InputRgbField, { title: "Green", value: color, rgbKey: "g", onChange: handleChange }), jsx(InputRgbField, { title: "Blue", value: color, rgbKey: "b", onChange: handleChange }), jsx(InputAlphaField, { color: color, onChange: handleChange })] }), jsxs("div", { className: classes.inputRow, children: [jsx(InputHsvField, { title: "Hue", value: color, hsvKey: "h", max: 360, onChange: handleChange }), jsx(InputHsvField, { title: "Saturation", value: color, hsvKey: "s", max: 100, scale: 100, onChange: handleChange }), jsx(InputHsvField, { title: "Value", value: color, hsvKey: "v", max: 100, scale: 100, onChange: handleChange })] }), jsx("div", { className: classes.inputRow, children: jsx(InputHexField, { title: "Hexadecimal", linearHex: isLinear, isLinearMode: isLinear, value: color, onChange: handleChange }) })] }) }));
});
/**
 * Component which displays the passed in color's HEX value, either in linearSpace (if linearHex is true) or in gamma space
 * When the hex color is changed by user, component calculates the new Color3/4 value and calls onChange
 *
 * Component uses the isLinearMode boolean to display an informative label regarding linear / gamma space
 * @param props - The properties for the InputHexField component.
 * @returns
 */
const InputHexField = (props) => {
    const classes = useColorPickerStyles();
    const { title, value, onChange, linearHex, isLinearMode } = props;
    return (jsx(TextInput, { disabled: linearHex ? !isLinearMode : false, className: classes.inputField, value: linearHex ? value.toLinearSpace().toHexString() : value.toHexString(), validator: ValidateColorHex, onChange: (val) => (linearHex ? onChange(Color3.FromHexString(val).toGammaSpace()) : onChange(Color3.FromHexString(val))), infoLabel: title
            ? {
                label: title,
                // If not representing a linearHex, no info is needed.
                info: !props.linearHex ? undefined : !isLinearMode ? ( // If representing a linear hex but we are in gammaMode, simple message explaining why linearHex is disabled
                jsx(Fragment, { children: " This color picker is attached to an entity whose color is stored in gamma space, so we are showing linear hex in disabled view " })) : (
                // If representing a linear hex and we are in linearMode, give information about how to use these hex values
                jsxs(Fragment, { children: ["This color picker is attached to an entity whose color is stored in linear space (ex: PBR Material), and Babylon converts the color to gamma space before rendering on screen because the human eye is best at processing colors in gamma space. We thus also want to display the color picker in gamma space so that the color chosen here will match the color seen in your entity.", jsx("br", {}), "If you want to copy/paste the HEX into your code, you can either use", jsx(Body1Strong, { children: "Color3.FromHexString(LINEAR_HEX)" }), jsx("br", {}), "or", jsx("br", {}), jsx(Body1Strong, { children: "Color3.FromHexString(GAMMA_HEX).toLinearSpace()" }), jsx("br", {}), jsx("br", {}), jsx(Link, { url: "https://doc.babylonjs.com/preparingArtForBabylon/controllingColorSpace/", value: "Read more in our docs!" })] })),
            }
            : undefined }));
};
const InputRgbField = (props) => {
    const { value, onChange, title, rgbKey } = props;
    const classes = useColorPickerStyles();
    const handleChange = useCallback((val) => {
        const newColor = value.clone();
        newColor[rgbKey] = val / 255.0; // Convert to 0-1 range
        onChange(newColor);
    }, [value, onChange, rgbKey]);
    return (jsx(SpinButton, { infoLabel: title ? { label: title } : undefined, className: classes.inputField, min: 0, max: 255, value: Math.round(value[rgbKey] * 255), forceInt: true, onChange: handleChange }));
};
function rgbaToHsv(color) {
    const c = new Color3(color.r, color.g, color.b);
    const hsv = c.toHSV();
    return { h: hsv.r, s: hsv.g, v: hsv.b, a: color.a };
}
/**
 * In the HSV (Hue, Saturation, Value) color model, Hue (H) ranges from 0 to 360 degrees, representing the color's position on the color wheel.
 * Saturation (S) ranges from 0 to 100%, indicating the intensity or purity of the color, with 0 being shades of gray and 100 being a fully saturated color.
 * Value (V) ranges from 0 to 100%, representing the brightness of the color, with 0 being black and 100 being the brightest.
 * @param props - The properties for the InputHsvField component.
 */
const InputHsvField = (props) => {
    const { value, title, hsvKey, max, onChange, scale = 1 } = props;
    const classes = useColorPickerStyles();
    const handleChange = useCallback((val) => {
        // Convert current color to HSV, update the new hsv value, then call onChange prop
        const hsv = rgbaToHsv(value);
        hsv[hsvKey] = val / scale;
        let newColor = Color3.FromHSV(hsv.h, hsv.s, hsv.v);
        if (value instanceof Color4) {
            newColor = Color4.FromColor3(newColor, value.a ?? 1);
        }
        props.onChange(newColor);
    }, [value, onChange, hsvKey, scale]);
    return (jsx(SpinButton, { infoLabel: title ? { label: title } : undefined, className: classes.inputField, min: 0, max: max, value: Math.round(rgbaToHsv(value)[hsvKey] * scale), forceInt: true, onChange: handleChange }));
};
/**
 * Displays the alpha value of a color, either in the disabled state (if color is Color3) or as a spin button (if color is Color4).
 * @param props
 * @returns
 */
const InputAlphaField = (props) => {
    const classes = useColorPickerStyles();
    const { color, onChange } = props;
    const handleChange = useCallback((value) => {
        if (Number.isNaN(value) || value < 0 || value > 1) {
            return;
        }
        if (color instanceof Color4) {
            const newColor = color.clone();
            newColor.a = value;
            return newColor;
        }
        else {
            return Color4.FromColor3(color, value);
        }
    }, [onChange]);
    return (jsx(SpinButton, { disabled: color instanceof Color3, min: 0, max: 1, className: classes.inputField, value: color instanceof Color3 ? 1 : color.a, step: 0.01, onChange: handleChange, infoLabel: {
            label: "Alpha",
            info: color instanceof Color3 ? (jsx(Fragment, { children: "Because this color picker is representing a Color3, we do not permit modifying alpha from the color picker. You can however modify the entity's alpha property directly, either in code via entity.alpha OR via inspector's transparency section." })) : undefined,
        } }));
};

const useStyles$I = makeStyles({
    sidebar: {
        display: "flex",
        flexDirection: "column",
        width: "280px",
        minWidth: "280px",
        overflowY: "auto",
        overflowX: "hidden",
        borderRight: `1px solid ${tokens.colorNeutralStroke1}`,
        backgroundColor: tokens.colorNeutralBackground1,
    },
    sidebarItem: {
        display: "grid",
        width: "100%",
        minHeight: "30px",
        padding: `${tokens.spacingVerticalXXS} 0`,
        alignItems: "center",
    },
    header: {
        color: tokens.colorNeutralForeground1,
        backgroundColor: tokens.colorBrandBackground,
        gridTemplateColumns: "10px 9fr 1fr 8px",
    },
    categoryHeader: {
        backgroundColor: tokens.colorNeutralBackground4,
        minHeight: "30px",
    },
    categoryColumn2: {
        gridColumn: "2",
    },
    categoryColumn3: {
        gridColumn: "3",
        display: "flex",
        justifyContent: "end",
    },
    measure: {
        color: tokens.colorNeutralForeground1,
        gridTemplateColumns: "4px 6fr 1fr 10px",
    },
    measureOdd: {
        backgroundColor: tokens.colorNeutralBackground2,
    },
    measureEven: {
        backgroundColor: tokens.colorNeutralBackground1,
    },
    measureCategory: {
        display: "grid",
        gridTemplateColumns: "auto 7px 18px 10px 1fr",
        gridColumn: "2",
        alignItems: "center",
    },
    measureColorPicker: {
        gridColumn: "3",
    },
    measureLabel: {
        gridColumn: "5",
    },
    measureValue: {
        gridColumn: "3",
        textAlign: "right",
    },
});
const PerformanceSidebar = (props) => {
    const { collector, onVisibleRangeChangedObservable } = props;
    const classes = useStyles$I();
    // Map from id to IPerfMetadata information
    const [metadataMap, setMetadataMap] = useState();
    // Map from category to all the ids belonging to that category
    const [metadataCategoryId, setMetadataCategoryId] = useState();
    // Count how many elements are checked for that category
    const [metadataCategoryChecked, setMetadataCategoryChecked] = useState();
    // List of ordered categories
    const [metadataCategories, setMetadataCategories] = useState();
    // Min/Max/Current values of the ids
    const [valueMap, setValueMap] = useState();
    useEffect(() => {
        if (!onVisibleRangeChangedObservable) {
            return;
        }
        const observer = (observedProps) => {
            setValueMap(observedProps.valueMap);
        };
        onVisibleRangeChangedObservable.add(observer);
        return () => {
            onVisibleRangeChangedObservable.removeCallback(observer);
        };
    }, [onVisibleRangeChangedObservable]);
    useEffect(() => {
        const onUpdateMetadata = (metadata) => {
            const newCategoryIdMap = new Map();
            const newCategoryCheckedMap = new Map();
            metadata.forEach((value, id) => {
                const currentCategory = value.category ?? "";
                const currentIds = newCategoryIdMap.get(currentCategory) ?? [];
                let currentChecked = newCategoryCheckedMap.get(currentCategory) ?? 0;
                currentIds.push(id);
                newCategoryIdMap.set(currentCategory, currentIds);
                if (!value.hidden) {
                    currentChecked += 1;
                }
                newCategoryCheckedMap.set(currentCategory, currentChecked);
            });
            const orderedCategories = Array.from(newCategoryIdMap.keys());
            orderedCategories.sort();
            setMetadataCategoryId(newCategoryIdMap);
            setMetadataCategoryChecked(newCategoryCheckedMap);
            setMetadataMap(metadata);
            setMetadataCategories(orderedCategories);
        };
        collector.metadataObservable.add(onUpdateMetadata);
        return () => {
            collector.metadataObservable.removeCallback(onUpdateMetadata);
        };
    }, [collector]);
    const onCheckChange = (id) => (selected) => {
        collector.updateMetadata(id, "hidden", !selected);
    };
    const onCheckAllChange = (category) => (selected) => {
        const categoryIds = metadataCategoryId?.get(category);
        if (!categoryIds) {
            return;
        }
        for (const id of categoryIds) {
            collector.updateMetadata(id, "hidden", !selected);
        }
    };
    const onColorChange = (id) => (color) => {
        collector.updateMetadata(id, "color", color.toHexString());
    };
    return (jsx("div", { className: classes.sidebar, children: metadataCategories &&
            metadataCategories.map((category) => (jsxs("div", { children: [category ? (jsxs("div", { className: mergeClasses(classes.sidebarItem, classes.header, classes.categoryHeader), children: [jsx(Subtitle2Stronger, { className: classes.categoryColumn2, children: category }), jsx("div", { className: classes.categoryColumn3, children: jsx(Switch, { value: metadataCategoryChecked?.get(category) === metadataCategoryId?.get(category)?.length, onChange: onCheckAllChange(category) }) })] }, `header-${category}`)) : null, metadataCategoryId?.get(category)?.map((id, index) => {
                        const metadata = metadataMap?.get(id);
                        const range = valueMap?.get(id);
                        return (metadata && (jsxs("div", { className: mergeClasses(classes.sidebarItem, classes.measure, index % 2 === 0 ? classes.measureEven : classes.measureOdd), children: [jsxs("div", { className: classes.measureCategory, children: [jsx(Switch, { value: !metadata.hidden, onChange: onCheckChange(id) }), jsx("div", { className: classes.measureColorPicker, children: jsx(ColorPickerPopup, { value: Color3.FromHexString(metadata.color ?? "#000"), onChange: onColorChange(id) }) }), jsx(Body1, { className: classes.measureLabel, children: id })] }), range && jsxs("div", { className: classes.measureValue, children: [" ", ((range.min + range.max) / 2).toFixed(2), " "] })] }, `perf-sidebar-item-${id}`)));
                    })] }, `category-${category || "version"}`))) }));
};

const useStyles$H = makeStyles({
    container: {
        display: "flex",
        flexDirection: "row",
        height: "100%",
        width: "100%",
        fontFamily: "system-ui, -apple-system, sans-serif",
        overflow: "hidden",
    },
    returnButton: {
        position: "absolute",
        top: "10px",
        right: "10px",
        zIndex: 10,
    },
    sidebar: {
        flex: "0 0 auto",
        overflowY: "auto",
        overflowX: "hidden",
    },
    graph: {
        flex: "1 1 auto",
        position: "relative",
        backgroundColor: tokens.colorNeutralBackground1,
        overflow: "hidden",
    },
});
const PerformanceViewer = (props) => {
    const { scene, layoutObservable, returnToLiveObservable, performanceCollector, initialGraphSize } = props;
    const classes = useStyles$H();
    const [onVisibleRangeChangedObservable] = useState(() => new Observable());
    const onReturnToPlayheadClick = () => {
        returnToLiveObservable.notifyObservers();
    };
    return (jsxs("div", { className: classes.container, children: [jsx(Button, { className: classes.returnButton, onClick: onReturnToPlayheadClick, label: "Return", title: "Return to Playhead" }), jsx("div", { className: classes.sidebar, children: jsx(PerformanceSidebar, { collector: performanceCollector, onVisibleRangeChangedObservable: onVisibleRangeChangedObservable }) }), jsx("div", { className: classes.graph, children: jsx(CanvasGraph, { returnToPlayheadObservable: returnToLiveObservable, layoutObservable: layoutObservable, scene: scene, collector: performanceCollector, onVisibleRangeChangedObservable: onVisibleRangeChangedObservable, initialGraphSize: initialGraphSize }) })] }));
};

function AddStrategies(perfCollector) {
    perfCollector.addCollectionStrategies(...DefaultStrategiesList);
    if (PressureObserverWrapper.IsAvailable) {
        // Do not enable for now as the Pressure API does not
        // report factors at the moment.
        // perfCollector.addCollectionStrategies({
        //     strategyCallback: PerfCollectionStrategy.ThermalStrategy(),
        //     category: IPerfMetadataCategory.FrameSteps,
        //     hidden: true,
        // });
        // perfCollector.addCollectionStrategies({
        //     strategyCallback: PerfCollectionStrategy.PowerSupplyStrategy(),
        //     category: IPerfMetadataCategory.FrameSteps,
        //     hidden: true,
        // });
        perfCollector.addCollectionStrategies({
            strategyCallback: PerfCollectionStrategy.PressureStrategy(),
            category: "Frame Steps Duration" /* PerfMetadataCategory.FrameSteps */,
            hidden: true,
        });
    }
}
var PerfMetadataCategory;
(function (PerfMetadataCategory) {
    PerfMetadataCategory["Count"] = "Count";
    PerfMetadataCategory["FrameSteps"] = "Frame Steps Duration";
})(PerfMetadataCategory || (PerfMetadataCategory = {}));
// list of strategies to add to perf graph automatically.
const DefaultStrategiesList = [
    { strategyCallback: PerfCollectionStrategy.FpsStrategy() },
    { strategyCallback: PerfCollectionStrategy.TotalMeshesStrategy(), category: "Count" /* PerfMetadataCategory.Count */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.ActiveMeshesStrategy(), category: "Count" /* PerfMetadataCategory.Count */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.ActiveIndicesStrategy(), category: "Count" /* PerfMetadataCategory.Count */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.ActiveBonesStrategy(), category: "Count" /* PerfMetadataCategory.Count */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.ActiveParticlesStrategy(), category: "Count" /* PerfMetadataCategory.Count */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.DrawCallsStrategy(), category: "Count" /* PerfMetadataCategory.Count */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.TotalLightsStrategy(), category: "Count" /* PerfMetadataCategory.Count */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.TotalVerticesStrategy(), category: "Count" /* PerfMetadataCategory.Count */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.TotalMaterialsStrategy(), category: "Count" /* PerfMetadataCategory.Count */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.TotalTexturesStrategy(), category: "Count" /* PerfMetadataCategory.Count */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.AbsoluteFpsStrategy(), category: "Frame Steps Duration" /* PerfMetadataCategory.FrameSteps */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.MeshesSelectionStrategy(), category: "Frame Steps Duration" /* PerfMetadataCategory.FrameSteps */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.RenderTargetsStrategy(), category: "Frame Steps Duration" /* PerfMetadataCategory.FrameSteps */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.ParticlesStrategy(), category: "Frame Steps Duration" /* PerfMetadataCategory.FrameSteps */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.SpritesStrategy(), category: "Frame Steps Duration" /* PerfMetadataCategory.FrameSteps */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.AnimationsStrategy(), category: "Frame Steps Duration" /* PerfMetadataCategory.FrameSteps */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.PhysicsStrategy(), category: "Frame Steps Duration" /* PerfMetadataCategory.FrameSteps */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.RenderStrategy(), category: "Frame Steps Duration" /* PerfMetadataCategory.FrameSteps */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.FrameTotalStrategy(), category: "Frame Steps Duration" /* PerfMetadataCategory.FrameSteps */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.InterFrameStrategy(), category: "Frame Steps Duration" /* PerfMetadataCategory.FrameSteps */, hidden: true },
    { strategyCallback: PerfCollectionStrategy.GpuFrameTimeStrategy(), category: "Frame Steps Duration" /* PerfMetadataCategory.FrameSteps */, hidden: true },
];
// arbitrary window size
const InitialWindowSize = { width: 1024, height: 512 };
const InitialGraphSize = new Vector2(724, 512);
const PerformanceStats = ({ context: scene }) => {
    const [isOpen, setIsOpen] = useState(false);
    const [isRecording, setIsRecording] = useState(false);
    const [isLoadedFromCsv, setIsLoadedFromCsv] = useState(false);
    const [performanceCollector, setPerformanceCollector] = useState();
    const [layoutObservable] = useState(() => new Observable());
    const [returnToLiveObservable] = useState(() => new Observable());
    const childWindowRef = useRef(null);
    useEffect(() => {
        if (!isLoadedFromCsv) {
            if (performanceCollector) {
                setIsRecording(false);
                performanceCollector.stop();
                performanceCollector.clear(false);
                AddStrategies(performanceCollector);
            }
        }
    }, [isLoadedFromCsv, performanceCollector]);
    const onClosePerformanceViewer = useCallback(() => {
        setIsLoadedFromCsv(false);
        setIsOpen(false);
    }, []);
    const onResize = useCallback((childWindow) => {
        const width = childWindow?.innerWidth ?? 0;
        const height = childWindow?.innerHeight ?? 0;
        layoutObservable.notifyObservers({ width, height });
    }, [layoutObservable]);
    const startPerformanceViewerPopup = useCallback(() => {
        if (performanceCollector && childWindowRef.current) {
            childWindowRef.current.open({
                defaultWidth: InitialWindowSize.width,
                defaultHeight: InitialWindowSize.height,
                title: "Realtime Performance Viewer",
            });
        }
    }, [performanceCollector]);
    const onPerformanceButtonClick = () => {
        setIsOpen(true);
        setIsRecording(true);
        performanceCollector?.start(true);
        startPerformanceViewerPopup();
    };
    const onLoadClick = (fileList) => {
        Tools.ReadFile(fileList[0], (data) => {
            // reopen window and load data!
            setIsOpen(false);
            setIsLoadedFromCsv(true);
            setIsRecording(false);
            performanceCollector?.stop();
            const isValid = performanceCollector?.loadFromFileData(data);
            if (!isValid) {
                // if our data isn't valid we close the window.
                setIsOpen(false);
                setIsRecording(true);
                performanceCollector?.start(true);
            }
            else {
                startPerformanceViewerPopup();
            }
        });
    };
    const onExportClick = () => {
        performanceCollector?.exportDataToCsv();
    };
    const onToggleRecording = () => {
        if (performanceCollector) {
            if (!performanceCollector.isStarted) {
                setIsRecording(true);
                performanceCollector.start(true);
            }
            else {
                setIsRecording(false);
                performanceCollector.stop();
            }
        }
    };
    useEffect(() => {
        const perfCollector = scene.getPerfCollector();
        AddStrategies(perfCollector);
        setPerformanceCollector(perfCollector);
    }, [scene]);
    // Handle child window resize
    useEffect(() => {
        const handleResize = () => {
            const win = window;
            if (win) {
                onResize(win);
            }
        };
        window.addEventListener("resize", handleResize);
        return () => window.removeEventListener("resize", handleResize);
    }, [onResize]);
    return (jsxs(Fragment, { children: [!isOpen && jsx(ButtonLine, { label: "Open Realtime Perf Viewer", onClick: onPerformanceButtonClick }), !isOpen && jsx(FileUploadLine, { label: "Load Perf Viewer using CSV", accept: ".csv", onClick: onLoadClick }), jsx(ButtonLine, { label: "Export Perf to CSV", icon: ArrowDownloadRegular, onClick: onExportClick }), !isOpen && jsx(ButtonLine, { label: isRecording ? "Stop Recording" : "Begin Recording", icon: isRecording ? StopRegular : RecordRegular, onClick: onToggleRecording }), jsx(ChildWindow, { id: "performance-viewer", imperativeRef: childWindowRef, onOpenChange: (open) => !open && onClosePerformanceViewer(), children: performanceCollector && (jsx(PerformanceViewer, { scene: scene, layoutObservable: layoutObservable, returnToLiveObservable: returnToLiveObservable, performanceCollector: performanceCollector, initialGraphSize: InitialGraphSize })) })] }));
};

/**
 * Wraps text in a property line
 * @param props - PropertyLineProps and TextProps
 * @returns property-line wrapped text
 */
const TextPropertyLine = (props) => {
    TextPropertyLine.displayName = "TextPropertyLine";
    const { value, title } = props;
    return (jsx(PropertyLine, { ...props, children: jsx(Body1, { title: title, children: value ?? "" }) }));
};

const useStyles$G = makeStyles({
    pinnedStatsPane: {
        flex: "0 1 auto",
        paddingBottom: tokens.spacingHorizontalM,
    },
});
const StatsPane = (props) => {
    const classes = useStyles$G();
    const scene = props.context;
    const engine = scene.getEngine();
    const fps = useObservableState(() => Math.round(engine.getFps()), engine.onBeginFrameObservable);
    return (jsxs(Fragment, { children: [jsxs(SidePaneContainer, { className: classes.pinnedStatsPane, children: [jsx(TextPropertyLine, { label: "Version", description: "The Babylon.js engine version.", value: AbstractEngine.Version }, "EngineVersion"), jsx(StringifiedPropertyLine, { label: "FPS:", description: "The current framerate", value: fps }, "FPS")] }), jsx(ExtensibleAccordion, { ...props })] }));
};

/**
 * Displays an icon indicating enabled (green check) or disabled (red cross) state
 * @param props - The properties for the PropertyLine, including the boolean value to display.
 * @returns A PropertyLine component with a PresenceBadge indicating the boolean state.
 */
const BooleanBadgePropertyLine = (props) => {
    BooleanBadgePropertyLine.displayName = "BooleanBadgePropertyLine";
    // For now assume BooleanBadge is used for readonly properties and disable copy. In future we could enable with a different copy string
    return (jsx(PropertyLine, { ...props, onCopy: undefined, children: jsx(PresenceBadge, { status: props.value ? "available" : "do-not-disturb", outOfOffice: true }) }));
};

const SystemStats = ({ context: scene }) => {
    const engine = scene.getEngine();
    const caps = engine.getCaps();
    const resolution = useObservableState(() => `${engine.getRenderWidth()} x ${engine.getRenderHeight()}`, engine.onResizeObservable);
    const hardwareScalingLevel = useObservableState(() => engine.getHardwareScalingLevel(), engine.onResizeObservable);
    return (jsxs(Fragment, { children: [jsx(TextPropertyLine, { label: "Resolution", value: resolution }, "Resolution"), jsx(StringifiedPropertyLine, { label: "Hardware Scaling Level", value: hardwareScalingLevel }, "HardwareScalingLevel"), jsx(TextPropertyLine, { label: "Engine", value: engine.description }, "Engine"), jsx(BooleanBadgePropertyLine, { label: "StdDerivatives", value: caps.standardDerivatives }, "StdDerivatives"), jsx(BooleanBadgePropertyLine, { label: "Compressed Textures", value: caps.s3tc !== undefined }, "CompressedTextures"), jsx(BooleanBadgePropertyLine, { label: "Hardware Instances", value: caps.instancedArrays }, "HardwareInstances"), jsx(BooleanBadgePropertyLine, { label: "Texture Float", value: caps.textureFloat }, "TextureFloat"), jsx(BooleanBadgePropertyLine, { label: "Texture Half Float", value: caps.textureHalfFloat }, "TextureHalfFloat"), jsx(BooleanBadgePropertyLine, { label: "Render to Texture Float", value: caps.textureFloatRender }, "RenderToTextureFloat"), jsx(BooleanBadgePropertyLine, { label: "Render to Texture Half Float", value: caps.textureHalfFloatRender }, "RenderToTextureHalfFloat"), jsx(BooleanBadgePropertyLine, { label: "32bits Indices", value: caps.uintIndices }, "32bitsIndices"), jsx(BooleanBadgePropertyLine, { label: "Fragment Depth", value: caps.fragmentDepthSupported }, "FragmentDepth"), jsx(BooleanBadgePropertyLine, { label: "High Precision Shaders", value: caps.highPrecisionShaderSupported }, "HighPrecisionShaders"), jsx(BooleanBadgePropertyLine, { label: "Draw Buffers", value: caps.drawBuffersExtension }, "DrawBuffers"), jsx(BooleanBadgePropertyLine, { label: "Vertex Array Object", value: caps.vertexArrayObject }, "VertexArrayObject"), jsx(BooleanBadgePropertyLine, { label: "Timer Query", value: caps.timerQuery !== undefined }, "TimerQuery"), jsx(BooleanBadgePropertyLine, { label: "Stencil", value: engine.isStencilEnable }, "Stencil"), jsx(BooleanBadgePropertyLine, { label: "Parallel Shader Compilation", value: caps.parallelShaderCompile != null }, "ParallelShaderCompilation"), jsx(StringifiedPropertyLine, { label: "Max Textures Units", value: caps.maxTexturesImageUnits }, "MaxTexturesUnits"), jsx(StringifiedPropertyLine, { label: "Max Textures Size", value: caps.maxTextureSize }, "MaxTexturesSize"), jsx(StringifiedPropertyLine, { label: "Max Anisotropy", value: caps.maxAnisotropy }, "MaxAnisotropy"), jsx(TextPropertyLine, { label: "Driver", value: engine.extractDriverInfo() }, "Driver")] }));
};

const StatsServiceIdentity = Symbol("StatsService");
/**
 * Provides a scene stats pane.
 */
const StatsServiceDefinition = {
    friendlyName: "Stats",
    produces: [StatsServiceIdentity],
    consumes: [ShellServiceIdentity, SceneContextIdentity],
    factory: (shellService, sceneContext) => {
        const sectionsCollection = new ObservableCollection();
        const sectionContentCollection = new ObservableCollection();
        const registration = shellService.addSidePane({
            key: "Statistics",
            title: "Statistics",
            icon: DataBarHorizontalRegular,
            horizontalLocation: "right",
            verticalLocation: "top",
            order: 300,
            suppressTeachingMoment: true,
            content: () => {
                const sections = useOrderedObservableCollection(sectionsCollection);
                const sectionContent = useObservableCollection(sectionContentCollection);
                const scene = useObservableState(() => sceneContext.currentScene, sceneContext.currentSceneObservable);
                return jsx(Fragment, { children: scene && jsx(StatsPane, { sections: sections, sectionContent: sectionContent, context: scene }) });
            },
        });
        // Default/built-in sections.
        sectionsCollection.add({
            identity: "Performance",
            order: 0,
        });
        sectionsCollection.add({
            identity: "Count",
            order: 1,
        });
        sectionsCollection.add({
            identity: "Frame Steps Duration",
            order: 2,
        });
        sectionsCollection.add({
            identity: "System Info",
            order: 3,
        });
        // Default/built-in content.
        sectionContentCollection.add({
            key: "DefaultPerfStats",
            section: "Performance",
            order: 0,
            component: PerformanceStats,
        });
        sectionContentCollection.add({
            key: "DefaultCountStats",
            section: "Count",
            order: 1,
            component: CountStats,
        });
        sectionContentCollection.add({
            key: "DefaultFrameStats",
            section: "Frame Steps Duration",
            order: 2,
            component: FrameStepsStats,
        });
        sectionContentCollection.add({
            key: "DefaultSystemStats",
            section: "System Info",
            order: 3,
            component: SystemStats,
        });
        return {
            addSection: (section) => sectionsCollection.add(section),
            addSectionContent: (content) => sectionContentCollection.add(content),
            dispose: () => registration.dispose(),
        };
    },
};

const ToolsPane = (props) => {
    return jsx(ExtensibleAccordion, { ...props });
};

const ToolsServiceIdentity = Symbol("ToolsService");
/**
 * A collection of usually optional, dynamic extensions.
 * Common examples includes importing/exporting, or other general creation tools.
 */
const ToolsServiceDefinition = {
    friendlyName: "Tools Editor",
    produces: [ToolsServiceIdentity],
    consumes: [ShellServiceIdentity, SceneContextIdentity],
    factory: (shellService, sceneContext) => {
        const sectionsCollection = new ObservableCollection();
        const sectionContentCollection = new ObservableCollection();
        // Only show the Tools pane if some tool content has been added.
        let toolsPaneRegistration = null;
        sectionContentCollection.observable.add(() => {
            if (sectionContentCollection.items.length === 0) {
                toolsPaneRegistration?.dispose();
                toolsPaneRegistration = null;
            }
            else if (!toolsPaneRegistration) {
                toolsPaneRegistration = shellService.addSidePane({
                    key: "Tools",
                    title: "Tools",
                    icon: WrenchRegular,
                    horizontalLocation: "right",
                    verticalLocation: "top",
                    order: 400,
                    suppressTeachingMoment: true,
                    content: () => {
                        const sections = useOrderedObservableCollection(sectionsCollection);
                        const sectionContent = useObservableCollection(sectionContentCollection);
                        const scene = useObservableState(() => sceneContext.currentScene, sceneContext.currentSceneObservable);
                        return scene && jsx(ToolsPane, { sections: sections, sectionContent: sectionContent, context: scene });
                    },
                });
            }
        });
        return {
            addSection: (section) => sectionsCollection.add(section),
            addSectionContent: (content) => sectionContentCollection.add(content),
            dispose: () => toolsPaneRegistration?.dispose(),
        };
    },
};

const BabylonWebResources = {
    homepage: "https://www.babylonjs.com",
    repository: "https://github.com/BabylonJS/Babylon.js",
    bugs: "https://github.com/BabylonJS/Babylon.js/issues",
};
/**
 * Well-known default built in extensions for the Inspector.
 */
const DefaultInspectorExtensionFeed = new BuiltInsExtensionFeed("Inspector", [
    {
        name: "Quick Creation Tools (Preview)",
        description: "Adds a new panel for easy creation of various Babylon assets. This is a WIP extension...expect changes!",
        keywords: ["creation", "tools"],
        ...BabylonWebResources,
        author: { name: "Babylon.js", forumUserName: "" },
        getExtensionModuleAsync: async () => await import('./quickCreateToolsService-B55TQEXK.js'),
    },
    {
        name: "Reflector",
        description: "Connects to the Reflector Bridge for real-time scene synchronization with the Babylon.js Sandbox.",
        keywords: ["reflector", "bridge", "sync", "sandbox", "tools"],
        ...BabylonWebResources,
        author: { name: "Babylon.js", forumUserName: "" },
        getExtensionModuleAsync: async () => await import('./reflectorService-BHVk1B6L.js'),
    },
]);

const useSyncedSliderStyles = makeStyles({
    container: { display: "flex", minWidth: 0 },
    syncedSlider: {
        flex: "1 1 0",
        flexDirection: "row",
        display: "flex",
        alignItems: "center",
        minWidth: 0,
    },
    slider: {
        flex: "1 1 auto",
        minWidth: "75px",
        maxWidth: "75px",
    },
    compactSlider: {
        flex: "1 1 auto",
        minWidth: "50px", // Allow shrinking for compact mode
        maxWidth: "75px",
    },
    growSlider: {
        flex: "1 1 auto",
        minWidth: "50px",
        // No maxWidth - slider grows to fill available space
    },
    compactSpinButton: {
        width: "65px",
        minWidth: "65px",
        maxWidth: "65px",
    },
    compactSpinButtonInput: {
        minWidth: "0",
    },
});
/**
 * Component which synchronizes a slider and an input field, allowing the user to change the value using either control
 * @param props
 * @returns SyncedSlider component
 */
const SyncedSliderInput = (props) => {
    SyncedSliderInput.displayName = "SyncedSliderInput";
    const { infoLabel, ...passthroughProps } = props;
    const classes = useSyncedSliderStyles();
    const { size } = useContext(ToolContext);
    const [value, setValue] = useState(props.value ?? 0);
    const pendingValueRef = useRef(undefined);
    const isDraggingRef = useRef(false);
    // NOTE: The Fluent slider will add tick marks if the step prop is anything other than undefined.
    // To avoid this, we scale the min/max based on the step so we can always make step undefined.
    // The actual step size in the Fluent slider is 1 when it is ste to undefined.
    const min = props.min ?? 0;
    const max = props.max ?? 100;
    const step = props.step ?? 1;
    useEffect(() => {
        !isDraggingRef.current && setValue(props.value ?? 0); // Update local state when props.value changes as long as user is not actively dragging
    }, [props.value]);
    const handleSliderChange = (_, data) => {
        const newValue = data.value * step;
        setValue(newValue);
        if (props.notifyOnlyOnRelease) {
            // Store the value but don't notify parent yet
            pendingValueRef.current = newValue;
        }
        else {
            // Notify parent as slider changes
            props.onChange(newValue);
        }
    };
    const handleSliderPointerDown = () => {
        isDraggingRef.current = true;
    };
    const handleSliderPointerUp = () => {
        if (props.notifyOnlyOnRelease && isDraggingRef.current && pendingValueRef.current !== undefined) {
            props.onChange(pendingValueRef.current);
            pendingValueRef.current = undefined;
        }
        isDraggingRef.current = false;
    };
    const handleInputChange = (value) => {
        setValue(value);
        props.onChange(value); // Input always updates immediately
    };
    const hasSlider = props.min !== undefined && props.max !== undefined;
    // Determine Slider className based on props
    const getSliderClassName = () => {
        if (props.growSlider) {
            return classes.growSlider;
        }
        if (props.compact) {
            return classes.compactSlider;
        }
        return classes.slider;
    };
    return (jsxs("div", { className: classes.container, children: [infoLabel && jsx(InfoLabel, { ...infoLabel, htmlFor: "syncedSlider" }), jsxs("div", { id: "syncedSlider", className: classes.syncedSlider, children: [hasSlider && (jsx(Slider, { ...passthroughProps, className: getSliderClassName(), size: size, min: min / step, max: max / step, step: undefined, value: value / step, onChange: handleSliderChange, onPointerDown: handleSliderPointerDown, onPointerUp: handleSliderPointerUp })), jsx(SpinButton, { ...passthroughProps, className: hasSlider || props.compact ? classes.compactSpinButton : undefined, inputClassName: hasSlider || props.compact ? classes.compactSpinButtonInput : undefined, value: value, onChange: handleInputChange, step: props.step })] })] }));
};

/**
 * Renders a simple wrapper around the SyncedSliderInput
 * @param props
 * @returns
 */
const SyncedSliderPropertyLine = forwardRef((props, ref) => {
    SyncedSliderPropertyLine.displayName = "SyncedSliderPropertyLine";
    const { label, description, ...sliderProps } = props;
    return (jsx(PropertyLine, { ref: ref, ...props, children: jsx(SyncedSliderInput, { ...sliderProps }) }));
});

/**
 * Reusable component which renders a color property line containing a label, colorPicker popout, and expandable RGBA values
 * The expandable RGBA values are synced sliders that allow the user to modify the color's RGBA values directly
 * @param props - PropertyLine props, replacing children with a color object so that we can properly display the color
 * @returns Component wrapping a colorPicker component with a property line
 */
const ColorPropertyLine = forwardRef((props, ref) => {
    ColorPropertyLine.displayName = "ColorPropertyLine";
    const [color, setColor] = useState(props.value);
    useEffect(() => {
        setColor(props.value);
    }, [props.value]);
    const onSliderChange = (value, key) => {
        let newColor;
        if (key === "a") {
            newColor = Color4.FromColor3(color, value);
        }
        else {
            newColor = color.clone();
            newColor[key] = value / 255;
        }
        setColor(newColor); // Create a new object to trigger re-render
        props.onChange(newColor);
    };
    const onColorPickerChange = (newColor) => {
        setColor(newColor);
        props.onChange(newColor);
    };
    return (jsx(PropertyLine, { ref: ref, ...props, expandedContent: color ? jsx(ColorSliders, { color: color, onSliderChange: onSliderChange }) : undefined, children: jsx(ColorPickerPopup, { ...props, onChange: onColorPickerChange, value: color }) }));
});
const ColorSliders = ({ color, onSliderChange }) => (jsxs(Fragment, { children: [jsx(SyncedSliderPropertyLine, { label: "R", value: color.r * 255, min: 0, max: 255, onChange: (value) => onSliderChange(value, "r") }), jsx(SyncedSliderPropertyLine, { label: "G", value: color.g * 255, min: 0, max: 255, onChange: (value) => onSliderChange(value, "g") }), jsx(SyncedSliderPropertyLine, { label: "B", value: color.b * 255, min: 0, max: 255, onChange: (value) => onSliderChange(value, "b") }), color instanceof Color4 && jsx(SyncedSliderPropertyLine, { label: "A", value: color.a, min: 0, max: 1, step: 0.01, onChange: (value) => onSliderChange(value, "a") })] }));
const Color3PropertyLine = ColorPropertyLine;
const Color4PropertyLine = ColorPropertyLine;

const useStyles$F = makeStyles({
    dropdown: {
        ...UniformWidthStyling,
    },
});
/**
 * Wraps a dropdown in a property line
 * @param props - PropertyLineProps and DropdownProps
 * @returns property-line wrapped dropdown
 */
const DropdownPropertyLine = forwardRef((props, ref) => {
    DropdownPropertyLine.displayName = "DropdownPropertyLine";
    const classes = useStyles$F();
    return (jsx(PropertyLine, { ...props, ref: ref, children: jsx(Dropdown, { ...props, className: classes.dropdown }) }));
});
/**
 * Dropdown component for number values.
 */
const NumberDropdownPropertyLine = DropdownPropertyLine;
/**
 * Dropdown component for string values
 */
const StringDropdownPropertyLine = DropdownPropertyLine;

/**
 * Wraps a text input in a property line
 * @param props - PropertyLineProps and InputProps
 * @returns property-line wrapped input component
 */
const TextInputPropertyLine = (props) => {
    TextInputPropertyLine.displayName = "TextInputPropertyLine";
    return (jsx(PropertyLine, { ...props, children: jsx(TextInput, { ...props }) }));
};
/**
 * Wraps a number input in a property line
 * To force integer values, use forceInt param (this is distinct from the 'step' param, which will still allow submitting an integer value. forceInt will not)
 * @param props - PropertyLineProps and InputProps
 * @returns property-line wrapped input component
 */
const NumberInputPropertyLine = (props) => {
    NumberInputPropertyLine.displayName = "NumberInputPropertyLine";
    return (jsx(PropertyLine, { ...props, children: jsx(SpinButton, { ...props }) }));
};

const HasZ = (vector) => !(vector instanceof Vector2);
const HasW = (vector) => vector instanceof Vector4 || vector instanceof Quaternion;
/**
 * Reusable component which renders a vector property line containing a label, vector value, and expandable XYZW values
 * The expanded section contains a slider/input box for each component of the vector (x, y, z, w)
 * @param props
 * @returns
 */
const TensorPropertyLine = (props) => {
    TensorPropertyLine.displayName = "TensorPropertyLine";
    const converted = (val) => (props.valueConverter ? props.valueConverter.from(val) : val);
    const formatted = (val) => converted(val).toFixed(props.step !== undefined ? Math.max(0, CalculatePrecision(props.step)) : 2);
    const [vector, setVector] = useState(props.value);
    const { min, max } = props;
    const onChange = (val, key) => {
        const value = props.valueConverter ? props.valueConverter.to(val) : val;
        const newVector = vector.clone();
        newVector[key] = value; // The syncedSlider for 'w' is only rendered when vector is a Vector4, so this is safe
        setVector(newVector);
        props.onChange(newVector);
    };
    useEffect(() => {
        setVector(props.value);
    }, [props.value, props.expandedContent]);
    return (jsx(PropertyLine, { ...props, expandedContent: vector ? jsx(VectorSliders, { vector: vector, min: min, max: max, unit: props.unit, step: props.step, converted: converted, onChange: onChange }) : undefined, children: jsx(Body1, { children: `[${formatted(props.value.x)}, ${formatted(props.value.y)}${HasZ(props.value) ? `, ${formatted(props.value.z)}` : ""}${HasW(props.value) ? `, ${formatted(props.value.w)}` : ""}]` }) }));
};
const VectorSliders = ({ vector, min, max, unit, step, converted, onChange }) => (jsxs(Fragment, { children: [jsx(SyncedSliderPropertyLine, { label: "X", value: converted(vector.x), min: min, max: max, onChange: (val) => onChange(val, "x"), unit: unit, step: step }), jsx(SyncedSliderPropertyLine, { label: "Y", value: converted(vector.y), min: min, max: max, onChange: (val) => onChange(val, "y"), unit: unit, step: step }), HasZ(vector) && jsx(SyncedSliderPropertyLine, { label: "Z", value: converted(vector.z), min: min, max: max, onChange: (val) => onChange(val, "z"), unit: unit, step: step }), HasW(vector) && jsx(SyncedSliderPropertyLine, { label: "W", value: converted(vector.w), min: min, max: max, onChange: (val) => onChange(val, "w"), unit: unit, step: step })] }));
const ToDegreesConverter = { from: Tools.ToDegrees, to: Tools.ToRadians };
const RotationVectorPropertyLine = (props) => {
    RotationVectorPropertyLine.displayName = "RotationVectorPropertyLine";
    const min = props.useDegrees ? 0 : undefined;
    const max = props.useDegrees ? 360 : undefined;
    return (jsx(Vector3PropertyLine, { ...props, unit: props.useDegrees ? "deg" : "rad", valueConverter: props.useDegrees ? ToDegreesConverter : undefined, min: min, max: max, step: 0.001 }));
};
const QuaternionPropertyLineInternal = TensorPropertyLine;
const QuaternionPropertyLine = (props) => {
    QuaternionPropertyLine.displayName = "QuaternionPropertyLine";
    const min = props.useDegrees ? 0 : undefined;
    const max = props.useDegrees ? 360 : undefined;
    const [quat, setQuat] = useState(props.value);
    useEffect(() => {
        setQuat(props.value);
    }, [props.value]);
    // Extract only the properties that exist on QuaternionPropertyLineProps
    const { useEuler, ...restProps } = props;
    const onQuatChange = (val) => {
        setQuat(val);
        props.onChange(val);
    };
    const onEulerChange = (val) => {
        const quat = Quaternion.FromEulerAngles(val.x, val.y, val.z);
        onQuatChange(quat);
    };
    return useEuler ? (jsx(Vector3PropertyLine, { ...restProps, nullable: false, ignoreNullable: false, value: quat.toEulerAngles(), valueConverter: ToDegreesConverter, min: min, max: max, onChange: onEulerChange, unit: props.useDegrees ? "deg" : "rad" })) : (jsx(QuaternionPropertyLineInternal, { ...props, nullable: false, value: quat, min: min, max: max, onChange: onQuatChange, unit: props.useDegrees ? "deg" : "rad" }));
};
const Vector2PropertyLine = TensorPropertyLine;
const Vector3PropertyLine = TensorPropertyLine;
const Vector4PropertyLine = TensorPropertyLine;

function IsInspectableObject(entity) {
    return !!entity.inspectableCustomProperties;
}
const LegacyInspectableObjectPropertiesServiceDefinition = {
    friendlyName: "Additional Nodes",
    consumes: [PropertiesServiceIdentity],
    factory: (propertiesService) => {
        const propertiesSectionRegistration = propertiesService.addSection({
            identity: "Custom",
            order: Number.MAX_SAFE_INTEGER,
        });
        const propertiesContentRegistration = propertiesService.addSectionContent({
            key: "Additional Nodes Properties",
            predicate: (entity) => IsInspectableObject(entity),
            content: [
                {
                    section: "Custom",
                    component: ({ context }) => {
                        return (jsx(Fragment, { children: (context.inspectableCustomProperties ?? []).map((prop) => {
                                const commonProps = {
                                    target: context,
                                    propertyKey: prop.propertyName,
                                    label: prop.label,
                                    ignoreNullable: true,
                                    defaultValue: undefined,
                                };
                                switch (prop.type) {
                                    case 0 /* InspectableType.Checkbox */:
                                        return jsx(BoundProperty, { ...commonProps, component: SwitchPropertyLine }, prop.propertyName);
                                    case 1 /* InspectableType.Slider */:
                                        return (jsx(BoundProperty, { ...commonProps, min: prop.min, max: prop.max, step: prop.step, component: SyncedSliderPropertyLine }, prop.propertyName));
                                    case 2 /* InspectableType.Vector3 */:
                                        return jsx(BoundProperty, { ...commonProps, component: Vector3PropertyLine }, prop.propertyName);
                                    case 3 /* InspectableType.Quaternion */:
                                        return jsx(BoundProperty, { ...commonProps, component: QuaternionPropertyLine }, prop.propertyName);
                                    case 4 /* InspectableType.Color3 */:
                                        return jsx(BoundProperty, { ...commonProps, component: Color3PropertyLine }, prop.propertyName);
                                    case 5 /* InspectableType.String */:
                                        return jsx(BoundProperty, { ...commonProps, component: TextInputPropertyLine }, prop.propertyName);
                                    case 6 /* InspectableType.Button */:
                                        return jsx(ButtonLine, { label: prop.label, onClick: () => prop.callback?.() }, prop.propertyName);
                                    case 7 /* InspectableType.Options */:
                                        return jsx(BoundProperty, { ...commonProps, component: DropdownPropertyLine, options: prop.options ?? [] }, prop.propertyName);
                                    case 8 /* InspectableType.Tab */:
                                        return jsx(BoundProperty, { ...commonProps, component: TextPropertyLine }, prop.propertyName);
                                    case 9 /* InspectableType.FileButton */:
                                        return (jsx(FileUploadLine, { label: prop.label, accept: prop.accept ?? "", onClick: (files) => {
                                                if (files.length > 0 && prop.fileCallback) {
                                                    prop.fileCallback(files[0]);
                                                }
                                            } }, prop.propertyName));
                                    case 10 /* InspectableType.Vector2 */:
                                        return jsx(BoundProperty, { ...commonProps, component: Vector2PropertyLine }, prop.propertyName);
                                }
                            }) }));
                    },
                },
            ],
        });
        return {
            dispose: () => {
                propertiesSectionRegistration.dispose();
                propertiesContentRegistration.dispose();
            },
        };
    },
};

const ExtensionManagerContext = createContext(undefined);
function useExtensionManager() {
    return useContext(ExtensionManagerContext)?.extensionManager;
}

const InstalledExtensionsKey = "Babylon/Extensions/InstalledExtensions";
const ExtensionInstalledKeyPrefix = "Babylon/Extensions/IsExtensionInstalled";
function GetExtensionInstalledKey(name) {
    return `${ExtensionInstalledKeyPrefix}/${name}`;
}
function GetExtensionIdentity(feed, name) {
    return `${feed}|${name}`;
}
/**
 * Manages the installation, uninstallation, enabling, and disabling of extensions.
 */
class ExtensionManager {
    constructor(_serviceContainer, _feeds, _onInstallFailed) {
        this._serviceContainer = _serviceContainer;
        this._feeds = _feeds;
        this._onInstallFailed = _onInstallFailed;
        this._installedExtensions = new Map();
        this._stateChangedHandlers = new Map();
    }
    /**
     * Creates a new instance of the ExtensionManager.
     * This will automatically rehydrate previously installed and enabled extensions.
     * @param serviceContainer The service container to use.
     * @param feeds The extension feeds to include.
     * @param onInstallFailed A callback that is called when an extension installation fails.
     * @returns A promise that resolves to the new instance of the ExtensionManager.
     */
    static async CreateAsync(serviceContainer, feeds, onInstallFailed) {
        const extensionManager = new ExtensionManager(serviceContainer, feeds, onInstallFailed);
        // Rehydrate installed extensions.
        const installedExtensionNames = JSON.parse(localStorage.getItem(InstalledExtensionsKey) ?? "[]");
        for (const installedExtensionName of installedExtensionNames) {
            const installedExtensionRaw = localStorage.getItem(GetExtensionInstalledKey(installedExtensionName));
            if (installedExtensionRaw) {
                const installedExtensionData = JSON.parse(installedExtensionRaw);
                const feed = feeds.find((feed) => feed.name === installedExtensionData.feed);
                if (feed) {
                    const installedExtension = extensionManager._createInstalledExtension(installedExtensionData.metadata, feed);
                    extensionManager._installedExtensions.set(installedExtension.metadata.name, installedExtension);
                }
            }
        }
        // Load installed and enabled extensions.
        const enablePromises = [];
        for (const extension of extensionManager._installedExtensions.values()) {
            enablePromises.push((async () => {
                try {
                    await extensionManager._enableAsync(extension.metadata, false, false);
                }
                catch {
                    // If enabling the extension fails, uninstall it. The extension install fail callback will still be called,
                    // so the owner of the ExtensionManager instance can decide what to do with the error.
                    await extensionManager._uninstallAsync(extension.metadata, false);
                }
            })());
        }
        await Promise.all(enablePromises);
        return extensionManager;
    }
    /**
     * Gets the names of the feeds that are included in the extension manager.
     * @returns The names of the feeds.
     */
    get feedNames() {
        return this._feeds.map((feed) => feed.name);
    }
    /**
     * Queries the extension manager for extensions.
     * @param filter The filter to apply to the query.
     * @param feeds The feeds to include in the query.
     * @param installedOnly Whether to only include installed extensions.
     * @returns A promise that resolves to the extension query.
     */
    async queryExtensionsAsync(filter = "", feeds = this.feedNames, installedOnly = false) {
        if (installedOnly) {
            const installedExtensions = Array.from(this._installedExtensions.values()).filter((installedExtension) => feeds.includes(installedExtension.feed.name));
            return {
                totalCount: installedExtensions.length,
                getExtensionsAsync: async (index, count) => {
                    return installedExtensions.slice(index, index + count).map((installedExtension) => this._createExtension(installedExtension.metadata, installedExtension.feed));
                },
            };
        }
        const queries = await Promise.all(this._feeds.filter((feed) => feeds.includes(feed.name)).map(async (feed) => Object.assign(await feed.queryExtensionsAsync(filter), { feed })));
        const totalCount = queries.reduce((sum, query) => sum + query.totalCount, 0);
        return {
            totalCount,
            getExtensionsAsync: async (index, count) => {
                const extensions = new Array();
                let remaining = count;
                for (const query of queries) {
                    if (remaining <= 0) {
                        break;
                    }
                    if (index >= query.totalCount) {
                        index -= query.totalCount;
                        continue;
                    }
                    // This is intentionally sequential as we are querying for results until the count of results is met.
                    // eslint-disable-next-line no-await-in-loop
                    const metadataSlice = await query.getExtensionMetadataAsync(index, remaining);
                    extensions.push(...metadataSlice.map((metadata) => this._createExtension(metadata, query.feed)));
                    remaining -= metadataSlice.length;
                    index = 0;
                }
                return extensions;
            },
        };
    }
    /**
     * Disposes the extension manager.
     */
    dispose() {
        for (const installedExtension of this._installedExtensions.values()) {
            // eslint-disable-next-line github/no-then
            this._disableAsync(installedExtension.metadata, false).catch((error) => {
                Logger.Warn(`Failed to disable extension ${installedExtension.metadata.name}: ${error}`);
            });
        }
        this._stateChangedHandlers.clear();
    }
    async _installAsync(metadata, feed, isNestedStateChange) {
        let installedExtension = this._installedExtensions.get(metadata.name);
        if (!installedExtension) {
            installedExtension = this._createInstalledExtension(metadata, feed);
            installedExtension.isStateChanging = true;
            this._installedExtensions.set(metadata.name, installedExtension);
            try {
                // Enable the extension.
                await this._enableAsync(metadata, true, true);
            }
            catch (error) {
                this._installedExtensions.delete(metadata.name);
                throw error;
            }
            finally {
                !isNestedStateChange && (installedExtension.isStateChanging = false);
            }
            // Mark the extension as being installed.
            localStorage.setItem(GetExtensionInstalledKey(GetExtensionIdentity(feed.name, metadata.name)), JSON.stringify({
                feed: feed.name,
                metadata,
            }));
            localStorage.setItem(InstalledExtensionsKey, JSON.stringify(Array.from(this._installedExtensions.values()).map((extension) => GetExtensionIdentity(extension.feed.name, extension.metadata.name))));
        }
        return installedExtension;
    }
    async _uninstallAsync(metadata, isNestedStateChange) {
        const installedExtension = this._installedExtensions.get(metadata.name);
        if (installedExtension && (isNestedStateChange || !installedExtension.isStateChanging)) {
            try {
                !isNestedStateChange && (installedExtension.isStateChanging = true);
                // Disable the extension.
                await this._disableAsync(metadata, true);
                // Remove the extension from in memory.
                this._installedExtensions.delete(metadata.name);
                // Mark the extension as being uninstalled.
                localStorage.removeItem(GetExtensionInstalledKey(GetExtensionIdentity(installedExtension.feed.name, metadata.name)));
                localStorage.setItem(InstalledExtensionsKey, JSON.stringify(Array.from(this._installedExtensions.keys())));
            }
            finally {
                !isNestedStateChange && (installedExtension.isStateChanging = false);
            }
        }
    }
    async _enableAsync(metadata, isInitialInstall, isNestedStateChange) {
        const installedExtension = this._installedExtensions.get(metadata.name);
        if (installedExtension && (isNestedStateChange || !installedExtension.isStateChanging)) {
            try {
                !isNestedStateChange && (installedExtension.isStateChanging = true);
                // If we haven't done so already, load the extension module.
                if (!installedExtension.extensionModule) {
                    installedExtension.extensionModule = await installedExtension.feed.getExtensionModuleAsync(metadata.name);
                }
                if (!installedExtension.extensionModule) {
                    throw new Error(`Unable to load extension module for "${metadata.name}" from feed "${installedExtension.feed.name}".`);
                }
                // Register the ServiceDefinitions.
                let servicesRegistrationToken = null;
                if (installedExtension.extensionModule.default.serviceDefinitions) {
                    servicesRegistrationToken = await this._serviceContainer.addServicesAsync(...installedExtension.extensionModule.default.serviceDefinitions);
                }
                // Create a registration token to for dispose.
                installedExtension.registrationToken = {
                    dispose: () => {
                        servicesRegistrationToken?.dispose();
                    },
                };
            }
            catch (error) {
                this._onInstallFailed({
                    extension: metadata,
                    error,
                });
                throw error;
            }
            finally {
                !isNestedStateChange && (installedExtension.isStateChanging = false);
            }
        }
    }
    async _disableAsync(metadata, isNestedStateChange) {
        const installedExtension = this._installedExtensions.get(metadata.name);
        if (installedExtension && (isNestedStateChange || !installedExtension.isStateChanging)) {
            try {
                !isNestedStateChange && (installedExtension.isStateChanging = true);
                // Unregister the service registrations.
                installedExtension.registrationToken?.dispose();
            }
            finally {
                !isNestedStateChange && (installedExtension.isStateChanging = false);
            }
        }
    }
    _addStateChangedHandler(metadata, handler) {
        let stateChangedHandlers = this._stateChangedHandlers.get(metadata.name);
        if (!stateChangedHandlers) {
            this._stateChangedHandlers.set(metadata.name, (stateChangedHandlers = new Set()));
        }
        stateChangedHandlers.add(handler);
        return {
            dispose: () => {
                stateChangedHandlers.delete(handler);
                if (stateChangedHandlers.size === 0) {
                    this._stateChangedHandlers.delete(metadata.name);
                }
            },
        };
    }
    _createExtension(metadata, feed) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const extensionManager = this;
        return {
            metadata,
            get isStateChanging() {
                return extensionManager._installedExtensions.get(metadata.name)?.isStateChanging ?? false;
            },
            get isInstalled() {
                return extensionManager._installedExtensions.has(metadata.name);
            },
            installAsync: async () => {
                await extensionManager._installAsync(metadata, feed, false);
            },
            uninstallAsync: async () => await extensionManager._uninstallAsync(metadata, false),
            addStateChangedHandler: (handler) => extensionManager._addStateChangedHandler(metadata, handler),
        };
    }
    _createInstalledExtension(metadata, feed) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const extensionManager = this;
        let isStateChanging = false;
        return {
            metadata,
            feed,
            get isStateChanging() {
                return isStateChanging;
            },
            set isStateChanging(value) {
                if (value !== isStateChanging) {
                    isStateChanging = value;
                    extensionManager._stateChangedHandlers.get(this.metadata.name)?.forEach((handler) => handler());
                }
            },
        };
    }
}

// This sorts a set of service definitions based on their dependencies (e.g. a topological sort).
function SortServiceDefinitions(serviceDefinitions) {
    const sortedServiceDefinitions = [];
    SortGraph(serviceDefinitions, function* (serviceDefinition) {
        // Check each dependency.
        for (const contractIdentity of serviceDefinition.consumes ?? []) {
            // If another service definition produces the dependency contract, return it as an adjacent node for the purpose of sorting.
            yield* serviceDefinitions.filter((otherServiceDefinition) => (otherServiceDefinition.produces ?? []).includes(contractIdentity));
        }
    }, sortedServiceDefinitions.push.bind(sortedServiceDefinitions));
    return sortedServiceDefinitions;
}
/**
 * A service container manages the lifetimes of a set of services.
 * It takes care of instantiating the services in the correct order based on their dependencies,
 * passing dependencies through to services, and disposing of services when the container is disposed.
 */
class ServiceContainer {
    constructor(_friendlyName) {
        this._friendlyName = _friendlyName;
        this._isDisposed = false;
        this._serviceDefinitions = new Map();
        this._serviceDependents = new Map();
        this._serviceInstances = new Map();
    }
    /**
     * Adds a set of service definitions in the service container.
     * The services are sorted based on their dependencies.
     * @param args The service definitions to register, and optionally an abort signal.
     * @returns A disposable that will remove the service definition from the service container.
     */
    async addServicesAsync(...args) {
        if (this._isDisposed) {
            throw new Error("ServiceContainer is disposed.");
        }
        const abortSignal = args[args.length - 1] instanceof AbortSignal ? args.pop() : undefined;
        const serviceDefinitions = args;
        const sortedServiceDefinitions = SortServiceDefinitions(serviceDefinitions);
        const dispose = () => {
            for (const serviceDefinition of sortedServiceDefinitions.reverse()) {
                this._removeService(serviceDefinition);
            }
        };
        try {
            for (const serviceDefinition of sortedServiceDefinitions) {
                // We could possibly optimize this by allowing some parallel initialization of services, but this would be way more complex, so let's wait and see if it's needed.
                // eslint-disable-next-line no-await-in-loop
                await this._addServiceAsync(serviceDefinition, abortSignal);
            }
        }
        catch (error) {
            dispose();
            throw error;
        }
        return {
            dispose,
        };
    }
    /**
     * Registers a service definition in the service container.
     * @param serviceDefinition The service definition to register.
     * @param abortSignal An optional abort signal.
     * @returns A disposable that will remove the service definition from the service container.
     */
    async addServiceAsync(serviceDefinition, abortSignal) {
        if (abortSignal) {
            return await this.addServicesAsync(serviceDefinition, abortSignal);
        }
        else {
            return await this.addServicesAsync(serviceDefinition);
        }
    }
    async _addServiceAsync(service, abortSignal) {
        if (this._isDisposed) {
            throw new Error(`'${this._friendlyName}' container is disposed.`);
        }
        service.produces?.forEach((contract) => {
            if (this._serviceDefinitions.has(contract)) {
                throw new Error(`A service producing the contract '${contract.toString()}' has already been added to this '${this._friendlyName}' container.`);
            }
        });
        service.produces?.forEach((contract) => {
            this._serviceDefinitions.set(contract, service);
        });
        const dependencies = service.consumes?.map((dependency) => {
            const dependencyDefinition = this._serviceDefinitions.get(dependency);
            if (!dependencyDefinition) {
                throw new Error(`Service '${dependency.toString()}' has not been registered in the '${this._friendlyName}' container.`);
            }
            let dependentDefinitions = this._serviceDependents.get(dependencyDefinition);
            if (!dependentDefinitions) {
                this._serviceDependents.set(dependencyDefinition, (dependentDefinitions = new Set()));
            }
            dependentDefinitions.add(service);
            const dependencyInstance = this._serviceInstances.get(dependencyDefinition);
            if (!dependencyInstance) {
                throw new Error(`Service '${dependency.toString()}' has not been instantiated in the '${this._friendlyName}' container.`);
            }
            return dependencyInstance;
        }) ?? [];
        this._serviceInstances.set(service, await service.factory(...dependencies, abortSignal));
    }
    _removeService(service) {
        if (this._isDisposed) {
            throw new Error(`'${this._friendlyName}' container is disposed.`);
        }
        const serviceDependents = this._serviceDependents.get(service);
        if (serviceDependents) {
            throw new Error(`Service '${service.friendlyName}' has dependents: ${Array.from(serviceDependents)
                .map((dependent) => dependent.friendlyName)
                .join(", ")}`);
        }
        // NOTE: The service instance could be undefined, as the service factory for a service that does not produce any contracts is not required to return an actual service instance.
        const serviceInstance = this._serviceInstances.get(service);
        this._serviceInstances.delete(service);
        serviceInstance?.dispose?.();
        service.produces?.forEach((contract) => {
            this._serviceDefinitions.delete(contract);
        });
        service.consumes?.forEach((dependency) => {
            const dependencyDefinition = this._serviceDefinitions.get(dependency);
            if (dependencyDefinition) {
                const dependentDefinitions = this._serviceDependents.get(dependencyDefinition);
                if (dependentDefinitions) {
                    dependentDefinitions.delete(service);
                    if (dependentDefinitions.size === 0) {
                        this._serviceDependents.delete(dependencyDefinition);
                    }
                }
            }
        });
    }
    /**
     * Disposes the service container and all contained services.
     */
    dispose() {
        Array.from(this._serviceInstances.keys()).reverse().forEach(this._removeService.bind(this));
        this._serviceInstances.clear();
        this._serviceDependents.clear();
        this._serviceDefinitions.clear();
        this._isDisposed = true;
    }
}

const useStyles$E = makeStyles({
    themeButton: {
        margin: 0,
    },
    themeMenuPopover: {
        minWidth: 0,
    },
});
const ThemeSelectorServiceDefinition = {
    friendlyName: "ThemeSelector",
    consumes: [ShellServiceIdentity],
    factory: (shellService) => {
        const registration = shellService.addToolbarItem({
            key: "ThemeSelector",
            horizontalLocation: "right",
            verticalLocation: "top",
            suppressTeachingMoment: true,
            order: -300,
            component: () => {
                const classes = useStyles$E();
                const { isDarkMode, themeMode, setThemeMode } = useThemeMode();
                const onSelectedThemeChange = useCallback((e, data) => {
                    setThemeMode(data.checkedItems.includes("System") ? "system" : data.checkedItems[0].toLocaleLowerCase());
                }, []);
                const toggleTheme = useCallback(() => {
                    setThemeMode(isDarkMode ? "light" : "dark");
                }, [isDarkMode]);
                return (jsxs(Menu, { positioning: "below-end", checkedValues: { theme: [themeMode] }, onCheckedValueChange: onSelectedThemeChange, children: [jsx(MenuTrigger, { disableButtonEnhancement: true, children: (triggerProps) => (jsx(Tooltip$1, { content: "Select Theme", relationship: "label", children: jsx(SplitButton, { className: classes.themeButton, menuButton: triggerProps, primaryActionButton: { onClick: toggleTheme }, size: "small", appearance: "transparent", shape: "circular", icon: isDarkMode ? jsx(WeatherSunnyRegular, {}) : jsx(WeatherMoonRegular, {}) }) })) }), jsx(MenuPopover, { className: classes.themeMenuPopover, children: jsxs(MenuList, { children: [jsx(MenuItemRadio, { name: "theme", value: "system", children: "System" }), jsx(MenuItemRadio, { name: "theme", value: "light", children: "Light" }), jsx(MenuItemRadio, { name: "theme", value: "dark", children: "Dark" })] }) })] }));
            },
        });
        return {
            dispose: () => registration.dispose(),
        };
    },
};

const useStyles$D = makeStyles({
    app: {
        colorScheme: "light dark",
        flexGrow: 1,
        display: "flex",
        flexDirection: "column",
        backgroundColor: tokens.colorTransparentBackground,
    },
    spinner: {
        flexGrow: 1,
        animationDuration: "1s",
        animationName: {
            from: { opacity: 0 },
            to: { opacity: 1 },
        },
    },
    extensionErrorTitleDiv: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        gap: tokens.spacingHorizontalS,
    },
    extensionErrorIcon: {
        color: tokens.colorPaletteRedForeground1,
    },
});
/**
 * Creates a modular tool with a base set of common tool services, including the toolbar/side pane basic UI layout.
 * @param options The options for the tool.
 * @returns A token that can be used to dispose of the tool.
 */
function MakeModularTool(options) {
    const { containerElement, serviceDefinitions, themeMode, showThemeSelector = true, extensionFeeds = [] } = options;
    if (themeMode) {
        SetThemeMode(themeMode);
    }
    const modularToolRootComponent = () => {
        const classes = useStyles$D();
        const [extensionManagerContext, setExtensionManagerContext] = useState();
        const [requiredExtensions, setRequiredExtensions] = useState();
        const [requiredExtensionsDeferred, setRequiredExtensionsDeferred] = useState();
        const [extensionInstallError, setExtensionInstallError] = useState();
        const [rootComponent, setRootComponent] = useState();
        // This is the main async initialization.
        useEffect(() => {
            const initializeExtensionManagerAsync = async () => {
                const serviceContainer = new ServiceContainer("ModularToolContainer");
                // Register the shell service (top level toolbar/side pane UI layout).
                await serviceContainer.addServiceAsync(MakeShellServiceDefinition(options));
                // Register a service that simply consumes the IRootComponentService and sets the root component as state so it can be rendered.
                await serviceContainer.addServiceAsync({
                    friendlyName: "Root Component Bootstrapper",
                    consumes: [RootComponentServiceIdentity],
                    factory: (rootComponentService) => {
                        // Use function syntax for the state setter since the root component may be a function component.
                        setRootComponent(() => rootComponentService.rootComponent);
                        return {
                            dispose: () => setRootComponent(undefined),
                        };
                    },
                });
                // Register the extension list service (for browsing/installing extensions) if extension feeds are provided.
                if (extensionFeeds.length > 0) {
                    const { ExtensionListServiceDefinition } = await import('./extensionsListService-1OhC4MZF.js');
                    await serviceContainer.addServiceAsync(ExtensionListServiceDefinition);
                }
                // Register the theme selector service (for selecting the theme) if theming is configured.
                if (showThemeSelector) {
                    await serviceContainer.addServiceAsync(ThemeSelectorServiceDefinition);
                }
                // Register all external services (that make up a unique tool).
                await serviceContainer.addServicesAsync(...serviceDefinitions);
                // Create the extension manager, passing along the registry for runtime changes to the registered services.
                const extensionManager = await ExtensionManager.CreateAsync(serviceContainer, extensionFeeds, setExtensionInstallError);
                // Check query params for required extensions. This lets users share links with sets of extensions.
                const queryParams = new URLSearchParams(window.location.search);
                const requiredExtensions = queryParams.getAll("babylon.requiredExtension");
                const uninstalledExtensions = [];
                for (const requiredExtension of requiredExtensions) {
                    // These could possibly be parallelized to speed things up, but it's more complex so let's wait and see if we need it.
                    // eslint-disable-next-line no-await-in-loop
                    const query = await extensionManager.queryExtensionsAsync(requiredExtension);
                    // eslint-disable-next-line no-await-in-loop
                    const extensions = await query.getExtensionsAsync(0, query.totalCount);
                    for (const extension of extensions) {
                        if (!extension.isInstalled) {
                            uninstalledExtensions.push(extension);
                        }
                    }
                }
                // Check if any required extensions are uninstalled or disabled. If so, show a dialog to the user.
                if (uninstalledExtensions.length > 0) {
                    setRequiredExtensions(uninstalledExtensions.map((extension) => extension.metadata.name));
                    const deferred = new Deferred();
                    setRequiredExtensionsDeferred(deferred);
                    if (await deferred.promise) {
                        for (const extension of uninstalledExtensions) {
                            // This could possibly be parallelized to speed things up, but it's more complex so let's wait and see if we need it.
                            // eslint-disable-next-line no-await-in-loop
                            await extension.installAsync();
                        }
                    }
                }
                // Set the contexts.
                setExtensionManagerContext({ extensionManager });
                return () => {
                    extensionManager.dispose();
                    serviceContainer.dispose();
                    serviceContainer.dispose();
                };
            };
            const disposePromise = initializeExtensionManagerAsync();
            return () => {
                disposePromise
                    // eslint-disable-next-line github/no-then
                    .then((dispose) => dispose())
                    // eslint-disable-next-line github/no-then
                    .catch((error) => {
                    Logger.Error(`Failed to dispose of the modular tool: ${error}`);
                });
            };
        }, []);
        const onAcceptRequiredExtensions = useCallback(() => {
            setRequiredExtensions(undefined);
            requiredExtensionsDeferred?.resolve(true);
        }, [setRequiredExtensions, requiredExtensionsDeferred]);
        const onRejectRequiredExtensions = useCallback(() => {
            setRequiredExtensions(undefined);
            requiredExtensionsDeferred?.resolve(false);
        }, [setRequiredExtensions, requiredExtensionsDeferred]);
        const onAcknowledgedExtensionInstallError = useCallback(() => {
            setExtensionInstallError(undefined);
        }, [setExtensionInstallError]);
        // Show a spinner until a main view has been set.
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const Content = rootComponent ?? (() => jsx(Spinner, { className: classes.spinner }));
        return (jsx(ExtensionManagerContext.Provider, { value: extensionManagerContext, children: jsx(Theme, { className: classes.app, children: jsxs(ToastProvider, { children: [jsx(Dialog, { open: !!requiredExtensions, modalType: "alert", children: jsx(DialogSurface, { children: jsxs(DialogBody, { children: [jsx(DialogTitle, { children: "Required Extensions" }), jsxs(DialogContent, { children: ["Opening this URL requires the following extensions to be installed and enabled:", jsx("ul", { children: requiredExtensions?.map((name) => jsx("li", { children: name }, name)) })] }), jsxs(DialogActions, { children: [jsx(Button$1, { appearance: "primary", onClick: onAcceptRequiredExtensions, children: "Install & Enable" }), jsx(Button$1, { appearance: "secondary", onClick: onRejectRequiredExtensions, children: "No Thanks" })] })] }) }) }), jsx(Dialog, { open: !!extensionInstallError, modalType: "alert", children: jsx(DialogSurface, { children: jsxs(DialogBody, { children: [jsx(DialogTitle, { children: jsxs("div", { className: classes.extensionErrorTitleDiv, children: ["Extension Install Error", jsx(ErrorCircleRegular, { className: classes.extensionErrorIcon })] }) }), jsx(DialogContent, { children: jsxs(List$1, { children: [jsx(ListItem, { children: jsx(Body1, { children: `Extension "${extensionInstallError?.extension.name}" failed to install and was removed.` }) }), jsx(ListItem, { children: jsx(Body1, { children: `${extensionInstallError?.error}` }) })] }) }), jsx(DialogActions, { children: jsx(Button$1, { appearance: "primary", onClick: onAcknowledgedExtensionInstallError, children: "Close" }) })] }) }) }), jsx(Suspense, { fallback: jsx(Spinner, { className: classes.spinner }), children: jsx(Content, {}) })] }) }) }));
    };
    // Set the container element to be a flex container so that the tool can be displayed properly.
    const originalContainerElementDisplay = containerElement.style.display;
    containerElement.style.display = "flex";
    // Create and render the react root component.
    const reactRoot = createRoot(containerElement);
    reactRoot.render(createElement(modularToolRootComponent));
    let disposed = false;
    return {
        dispose: () => {
            // Unmount and restore the original container element display.
            if (!disposed) {
                disposed = true;
                reactRoot.unmount();
                containerElement.style.display = originalContainerElementDisplay;
            }
        },
    };
}

const GizmoServiceIdentity = Symbol("GizmoService");
const GizmoServiceDefinition = {
    friendlyName: "Gizmo Service",
    produces: [GizmoServiceIdentity],
    factory: () => {
        const utilityLayers = new WeakMap();
        const getUtilityLayer = (scene, layer = "default") => {
            let utilityLayerInfoForScene = utilityLayers.get(scene);
            if (!utilityLayerInfoForScene) {
                utilityLayerInfoForScene = new Map();
                utilityLayers.set(scene, utilityLayerInfoForScene);
            }
            let utilityLayerInfo = utilityLayerInfoForScene.get(layer);
            if (!utilityLayerInfo) {
                const utilityLayer = scene.frameGraph ? FrameGraphUtils.CreateUtilityLayerRenderer(scene.frameGraph) : new UtilityLayerRenderer(scene);
                utilityLayerInfo = { utilityLayer, refCount: 0 };
                utilityLayerInfoForScene.set(layer, utilityLayerInfo);
            }
            utilityLayerInfo.refCount++;
            let disposed = false;
            return {
                value: utilityLayerInfo.utilityLayer,
                dispose: () => {
                    if (!disposed) {
                        disposed = true;
                        utilityLayerInfo.refCount--;
                        if (utilityLayerInfo.refCount === 0) {
                            utilityLayerInfo.utilityLayer.dispose();
                            utilityLayerInfoForScene.delete(layer);
                            if (utilityLayerInfoForScene.size === 0) {
                                utilityLayers.delete(scene);
                            }
                        }
                    }
                },
            };
        };
        function getGizmo(node, scene, gizmoClass, gizmoMap, onGizmoCreated) {
            let refCountedGizmo = gizmoMap.get(node);
            if (!refCountedGizmo) {
                const utilityLayerRef = getUtilityLayer(scene);
                const gizmo = new gizmoClass(utilityLayerRef.value);
                onGizmoCreated(node, gizmo);
                const nodeDisposedObserver = node.onDisposeObservable.addOnce(() => gizmo.dispose());
                const disposeGizmo = gizmo.dispose.bind(gizmo);
                gizmo.dispose = () => {
                    nodeDisposedObserver.remove();
                    disposeGizmo();
                    utilityLayerRef.dispose();
                };
                refCountedGizmo = { gizmo, refCount: 0 };
                gizmoMap.set(node, refCountedGizmo);
                onGizmoCreated(node, gizmo);
            }
            refCountedGizmo.refCount++;
            let disposed = false;
            return {
                value: refCountedGizmo.gizmo,
                dispose: () => {
                    if (!disposed) {
                        disposed = true;
                        refCountedGizmo.refCount--;
                        if (refCountedGizmo.refCount === 0) {
                            refCountedGizmo.gizmo.dispose();
                            gizmoMap.delete(node);
                        }
                    }
                },
            };
        }
        const cameraGizmos = new WeakMap();
        const getCameraGizmo = (camera) => getGizmo(camera, camera.getScene(), CameraGizmo, cameraGizmos, (camera, gizmo) => (gizmo.camera = camera));
        const lightGizmos = new WeakMap();
        const getLightGizmo = (light) => getGizmo(light, light.getScene(), LightGizmo, lightGizmos, (light, gizmo) => (gizmo.light = light));
        return {
            getUtilityLayer,
            getCameraGizmo,
            getLightGizmo,
            getCameraGizmos: (scene) => scene.cameras.map((camera) => cameraGizmos.get(camera)?.gizmo).filter(Boolean),
            getLightGizmos: (scene) => scene.lights.map((light) => lightGizmos.get(light)?.gizmo).filter(Boolean),
        };
    },
};

const MeshIcon = createFluentIcon("Mesh", "16", '<path d="M14.03,3.54l-5.11-2.07c-.61-.25-1.27-.25-1.88,0L1.93,3.54c-.57.23-.94.78-.94,1.39v6.15c0,.61.37,1.16.94,1.39l5.11,2.07c.3.12.62.18.94.18s.64-.06.94-.18l5.12-2.07c.57-.23.94-.78.94-1.39v-6.15c0-.61-.37-1.16-.94-1.39ZM13.97,7.71l-2.11.86v-2.71l2.11-.86v2.71ZM1.99,5l2.11.86v2.71l-2.11-.86v-2.71ZM11.35,4.98l-2.04-.83,1.78-.72,2.04.83-1.78.72ZM10.02,5.52l-2.04.83-2.04-.83,2.04-.83,2.04.83ZM4.6,4.98l-1.78-.72,2.04-.83,1.78.72-2.04.83ZM5.1,6.26l2.38.96v2.71l-2.38-.96v-2.71ZM8.48,7.22l2.38-.96v2.71l-2.38.96v-2.71ZM7.41,2.39c.18-.07.37-.11.56-.11s.38.04.56.11l1.22.49-1.78.72-1.79-.72,1.22-.49ZM1.99,11.07v-2.29l2.11.86v2.62l-1.8-.73c-.19-.08-.31-.26-.31-.46ZM5.1,12.67v-2.62l2.38.96v2.61s-.04,0-.06-.01l-2.31-.94ZM8.54,13.61s-.04,0-.06.01v-2.61l2.38-.96v2.62l-2.31.94ZM13.66,11.54l-1.8.73v-2.62l2.11-.86v2.29c0,.2-.12.39-.31.46Z"/>');
const TranslateIcon = createFluentIcon("Translate", "24", '<path d="M20.16,12.98l-2.75-2.75c-.29-.29-.77-.29-1.06,0-.29.29-.29.77,0,1.06l1.47,1.47h-6.69v-6.69l1.47,1.47c.29.29.77.29,1.06,0,.29-.29.29-.77,0-1.06l-2.75-2.75c-.14-.14-.33-.22-.53-.22s-.39.08-.53.22l-2.75,2.75c-.29.29-.29.77,0,1.06.29.29.77.29,1.06,0l1.47-1.47v7.13l-3.52,3.52v-2.08c0-.41-.34-.75-.75-.75s-.75.34-.75.75v3.89c0,.2.08.39.22.53.14.14.33.22.53.22h3.89c.41,0,.75-.34.75-.75s-.34-.75-.75-.75h-2.08s3.52-3.52,3.52-3.52h7.13l-1.47,1.47c-.29.29-.29.77,0,1.06s.77.29,1.06,0l2.75-2.75c.14-.14.22-.33.22-.53s-.08-.39-.22-.53Z" />');
const MaterialIcon = createFluentIcon("Material", "16", '<path d="M14.74,6.3c-.09-.36-.38-.64-.75-.72-.04-.09-.08-.18-.12-.27.1-.15.16-.32.16-.51,0-.18-.05-.34-.13-.48-1.23-1.97-3.41-3.28-5.9-3.28C4.16,1.04,1.04,4.16,1.04,7.99c0,.39.23.72.57.88.02.12.03.25.06.37-.18.18-.3.42-.3.7,0,.11.02.21.06.31.94,2.74,3.53,4.71,6.58,4.71,3.84,0,6.96-3.12,6.96-6.96,0-.59-.08-1.16-.22-1.7ZM2.07,8.58c-.02-.19-.03-.39-.03-.58,0-3.29,2.67-5.96,5.96-5.96,2.23,0,4.17,1.23,5.2,3.05.05.18-.07.45-.3.75-.57-.73-1.45-1.21-2.45-1.21-1.72,0-3.12,1.4-3.12,3.11,0,.33.07.65.16.95-3.05.82-5.17.52-5.42-.11ZM12.56,7.75c0,1.17-.95,2.11-2.11,2.11s-2.12-.95-2.12-2.11.95-2.11,2.12-2.11,2.11.95,2.11,2.11ZM8,13.96c-2.6,0-4.81-1.68-5.62-4.01.5.16,1.11.24,1.79.24,1.15,0,2.49-.22,3.79-.59.57.76,1.47,1.26,2.49,1.26,1.72,0,3.11-1.4,3.11-3.11,0-.34-.07-.65-.17-.96.13-.13.24-.26.34-.39.14.51.22,1.04.22,1.6,0,3.29-2.67,5.96-5.96,5.96Z"/>');
const FlatTangentIcon = createFluentIcon("FlatTangent", "20", '<g transform="scale(0.5)"><path d="M28,18.5a1.51,1.51,0,0,0-1.41,1H11.5v1H26.59a1.5,1.5,0,1,0,1.41-2Z"/></g>');
const LinearTangentIcon = createFluentIcon("LinearTangent", "20", '<g transform="scale(0.5)"><path d="M26,14a1.49,1.49,0,0,0-2.4,1.69l-10,10,.71.71,10-10A1.49,1.49,0,0,0,26,14Z"/></g>');
const BreakTangentIcon = createFluentIcon("BreakTangent", "20", '<g transform="scale(0.5)"><path d="M27.11,13.05a1.49,1.49,0,0,0-2.05.53,1.47,1.47,0,0,0,.14,1.72l-4.78,8L20,22.92l-.42.42-4.78-8a1.47,1.47,0,0,0,.14-1.72,1.49,1.49,0,0,0-2-.53,1.5,1.5,0,0,0,1,2.76l4.91,8.26-1,1L20,27.16,22.12,25l-1-1,4.91-8.26a1.5,1.5,0,0,0,1.05-2.76Z"/></g>');
const UnifyTangentIcon = createFluentIcon("UnifyTangent", "20", '<g transform="scale(0.5)"><path d="M27.94,18.28a1.49,1.49,0,0,0-1.41,1h-5l-1.62-1.63-1.62,1.63h-5a1.5,1.5,0,1,0,0,1h5l1.62,1.62,1.62-1.62h5a1.5,1.5,0,1,0,1.41-2Z"/></g>');
const StepTangentIcon = createFluentIcon("StepTangent", "20", '<g transform="scale(0.5)"><path d="M29,16.71a1.5,1.5,0,1,0-2,1.41v5.67H11v1H28V18.12A1.51,1.51,0,0,0,29,16.71Z"/></g>');

const useStyles$C = makeStyles({
    coordinatesModeButton: {
        margin: `0 0 0 ${tokens.spacingHorizontalXS}`,
    },
    coordinatesModeMenu: {
        minWidth: 0,
    },
});
const GizmoToolbar = (props) => {
    const { scene, entity, gizmoService } = props;
    const classes = useStyles$C();
    const gizmoManager = useResource(useCallback(() => {
        const utilityLayerRef = gizmoService.getUtilityLayer(scene);
        const keepDepthUtilityLayerRef = gizmoService.getUtilityLayer(scene, "keepDepth");
        const gizmoManager = new GizmoManager(scene, undefined, utilityLayerRef.value, keepDepthUtilityLayerRef.value);
        gizmoManager.usePointerToAttachGizmos = false;
        const disposeGizmoManager = gizmoManager.dispose.bind(gizmoManager);
        gizmoManager.dispose = () => {
            disposeGizmoManager();
            utilityLayerRef.dispose();
            keepDepthUtilityLayerRef.dispose();
        };
        return gizmoManager;
    }, [scene]));
    const coordinatesMode = useProperty(gizmoManager, "coordinatesMode");
    const [gizmoMode, setGizmoMode] = useState();
    useEffect(() => {
        let visualizationGizmoRef = null;
        let resolvedEntity = entity;
        if (gizmoMode) {
            if (entity instanceof Camera) {
                const cameraGizmoRef = gizmoService.getCameraGizmo(entity);
                visualizationGizmoRef = cameraGizmoRef;
                resolvedEntity = cameraGizmoRef.value.attachedNode;
            }
            else if (entity instanceof Light) {
                const lightGizmoRef = gizmoService.getLightGizmo(entity);
                visualizationGizmoRef = lightGizmoRef;
                resolvedEntity = lightGizmoRef.value.attachedNode;
            }
            else if (entity instanceof Bone) {
                resolvedEntity = entity.getTransformNode() ?? entity;
            }
        }
        let resolvedGizmoMode = gizmoMode;
        if (!resolvedEntity) {
            resolvedGizmoMode = undefined;
        }
        else {
            if (resolvedGizmoMode === "translate") {
                if (!resolvedEntity.position) {
                    resolvedGizmoMode = undefined;
                }
            }
            else if (resolvedGizmoMode === "rotate") {
                if (!resolvedEntity.rotation) {
                    resolvedGizmoMode = undefined;
                }
            }
            else if (resolvedGizmoMode === "scale") {
                if (!resolvedEntity.scaling) {
                    resolvedGizmoMode = undefined;
                }
            }
            else {
                if (!(resolvedEntity instanceof AbstractMesh)) {
                    resolvedGizmoMode = undefined;
                }
            }
        }
        gizmoManager.positionGizmoEnabled = resolvedGizmoMode === "translate";
        gizmoManager.rotationGizmoEnabled = resolvedGizmoMode === "rotate";
        gizmoManager.scaleGizmoEnabled = resolvedGizmoMode === "scale";
        gizmoManager.boundingBoxGizmoEnabled = resolvedGizmoMode === "boundingBox";
        if (gizmoManager.gizmos.boundingBoxGizmo) {
            gizmoManager.gizmos.boundingBoxGizmo.fixedDragMeshScreenSize = true;
        }
        if (!resolvedGizmoMode) {
            gizmoManager.attachToNode(null);
        }
        else {
            if (resolvedEntity instanceof AbstractMesh) {
                gizmoManager.attachToMesh(resolvedEntity);
            }
            else if (resolvedEntity instanceof Node) {
                gizmoManager.attachToNode(resolvedEntity);
            }
        }
        return () => {
            gizmoManager.attachToNode(null);
            visualizationGizmoRef?.dispose();
        };
    }, [gizmoManager, gizmoMode, entity]);
    const updateGizmoMode = useCallback((mode) => {
        setGizmoMode((currentMode) => (currentMode === mode ? undefined : mode));
    }, []);
    const onCoordinatesModeChange = useCallback((e, data) => {
        gizmoManager.coordinatesMode = Number(data.checkedItems[0]);
    }, []);
    const toggleCoordinatesMode = useCallback(() => {
        gizmoManager.coordinatesMode = coordinatesMode === 1 /* GizmoCoordinatesMode.Local */ ? 0 /* GizmoCoordinatesMode.World */ : 1 /* GizmoCoordinatesMode.Local */;
    }, [gizmoManager, coordinatesMode]);
    return (jsxs(Fragment, { children: [jsx(ToggleButton, { title: "Translate", checkedIcon: TranslateIcon, value: gizmoMode === "translate", onChange: () => updateGizmoMode("translate") }), jsx(ToggleButton, { title: "Rotate", checkedIcon: ArrowRotateClockwiseRegular, value: gizmoMode === "rotate", onChange: () => updateGizmoMode("rotate") }), jsx(ToggleButton, { title: "Scale", checkedIcon: ArrowExpandRegular, value: gizmoMode === "scale", onChange: () => updateGizmoMode("scale") }), jsx(ToggleButton, { title: "Bounding Box", checkedIcon: SelectObjectRegular, value: gizmoMode === "boundingBox", onChange: () => updateGizmoMode("boundingBox") }), jsx(Collapse, { visible: !!gizmoMode, orientation: "horizontal", children: jsxs(Menu, { positioning: "below-end", checkedValues: { coordinatesMode: [coordinatesMode.toString()] }, onCheckedValueChange: onCoordinatesModeChange, children: [jsx(MenuTrigger, { disableButtonEnhancement: true, children: (triggerProps) => (jsx(Tooltip$1, { content: "Coordinates Mode", relationship: "label", children: jsx(SplitButton, { className: classes.coordinatesModeButton, menuButton: triggerProps, primaryActionButton: {
                                        onClick: toggleCoordinatesMode,
                                    }, size: "small", appearance: "transparent", shape: "rounded", icon: coordinatesMode === 1 /* GizmoCoordinatesMode.Local */ ? jsx(CubeRegular, {}) : jsx(GlobeRegular, {}) }) })) }), jsx(MenuPopover, { className: classes.coordinatesModeMenu, children: jsxs(MenuList, { children: [jsx(MenuItemRadio, { name: "coordinatesMode", value: 1 /* GizmoCoordinatesMode.Local */.toString(), children: "Local" }), jsx(MenuItemRadio, { name: "coordinatesMode", value: 0 /* GizmoCoordinatesMode.World */.toString(), children: "World" })] }) })] }) })] }));
};

const GizmoToolbarServiceDefinition = {
    friendlyName: "Gizmo Toolbar",
    consumes: [SceneContextIdentity, ShellServiceIdentity, SelectionServiceIdentity, GizmoServiceIdentity],
    factory: (sceneContext, shellService, selectionService, gizmoService) => {
        shellService.addToolbarItem({
            key: "Gizmo Toolbar",
            verticalLocation: "top",
            horizontalLocation: "left",
            suppressTeachingMoment: true,
            component: () => {
                const scene = useObservableState(() => sceneContext.currentScene, sceneContext.currentSceneObservable);
                const selectedEntity = useObservableState(() => selectionService.selectedEntity, selectionService.onSelectedEntityChanged);
                return scene ? jsx(GizmoToolbar, { scene: scene, entity: selectedEntity, gizmoService: gizmoService }) : null;
            },
        });
    },
};

const useStyles$B = makeStyles({
    badge: {
        margin: tokens.spacingHorizontalXXS,
        fontFamily: "monospace",
    },
});
const MiniStatsServiceDefinition = {
    friendlyName: "Mini Stats",
    consumes: [SceneContextIdentity, ShellServiceIdentity],
    factory: (sceneContext, shellService) => {
        shellService.addToolbarItem({
            key: "Mini Stats",
            verticalLocation: "bottom",
            horizontalLocation: "right",
            suppressTeachingMoment: true,
            component: () => {
                const classes = useStyles$B();
                const scene = useObservableState(useCallback(() => sceneContext.currentScene, [sceneContext.currentScene]), sceneContext.currentSceneObservable);
                const engine = scene?.getEngine();
                const fps = useObservableState(useCallback(() => (engine ? Math.round(engine.getFps()) : null), [engine]), engine?.onBeginFrameObservable);
                return fps != null ? jsx(Badge, { appearance: "outline", className: classes.badge, children: `${fps} fps` }) : null;
            },
        });
    },
};

const TargetedAnimationGeneralProperties = (props) => {
    const { selectionService } = props;
    return (jsx(Fragment, { children: jsx(LinkToEntityPropertyLine, { label: "Target", description: "The entity animated by this animation.", entity: props.targetedAnimation.target, selectionService: selectionService }) }));
};

const CurveEditorContext = createContext(null);
/**
 * Provider component for curve editor context
 * @param props - Provider props including scene, target, and animations
 * @returns The provider component with context
 */
const CurveEditorProvider = (props) => {
    const { scene, target, animations, rootAnimationGroup = null, title = "Animation", useTargetAnimations = false, children } = props;
    // State
    const [activeAnimations, setActiveAnimations] = useState([]);
    const [activeChannels, setActiveChannels] = useState({});
    const [activeKeyPoints, setActiveKeyPoints] = useState(null);
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const [mainKeyPoint, _setMainKeyPoint] = useState(null);
    const [activeFrame, setActiveFrame] = useState(0);
    const [fromKey, setFromKey] = useState(0);
    const [toKey, setToKey] = useState(100);
    const [isPlaying, setIsPlaying] = useState(false);
    const [clipLength, setClipLength] = useState(100);
    const [referenceMinFrame, setReferenceMinFrame] = useState(0);
    const [referenceMaxFrame, setReferenceMaxFrame] = useState(100);
    const [focusedInput, setFocusedInput] = useState(false);
    const [snippetId, setSnippetId] = useState("");
    const [forwardAnimation, setForwardAnimation] = useState(true);
    // Observables - created once
    const observables = useRef({
        onActiveAnimationChanged: new Observable(),
        onActiveKeyPointChanged: new Observable(),
        onHostWindowResized: new Observable(),
        onSelectAllKeys: new Observable(),
        onActiveKeyFrameChanged: new Observable(),
        onFrameSet: new Observable(),
        onFrameManuallyEntered: new Observable(),
        onMainKeyPointSet: new Observable(),
        onMainKeyPointMoved: new Observable(),
        onValueSet: new Observable(),
        onValueManuallyEntered: new Observable(),
        onFrameRequired: new Observable(),
        onCreateOrUpdateKeyPointRequired: new Observable(),
        onFlattenTangentRequired: new Observable(),
        onLinearTangentRequired: new Observable(),
        onBreakTangentRequired: new Observable(),
        onUnifyTangentRequired: new Observable(),
        onStepTangentRequired: new Observable(),
        onDeleteAnimation: new Observable(),
        onGraphMoved: new Observable(),
        onGraphScaled: new Observable(),
        onRangeUpdated: new Observable(),
        onMoveToFrameRequired: new Observable(),
        onAnimationStateChanged: new Observable(),
        onDeleteKeyActiveKeyPoints: new Observable(),
        onSelectionRectangleMoved: new Observable(),
        onAnimationsLoaded: new Observable(),
        onClipLengthIncreased: new Observable(),
        onClipLengthDecreased: new Observable(),
        onInterpolationModeSet: new Observable(),
        onSelectToActivated: new Observable(),
        onRangeFrameBarResized: new Observable(),
        onPlayheadMoved: new Observable(),
        onActiveKeyDataChanged: new Observable(),
    });
    // Actions
    const prepare = useCallback(() => {
        setIsPlaying(false);
        if (!animations || !animations.length) {
            return;
        }
        const animation = useTargetAnimations ? animations[0].animation : animations[0];
        const keys = animation.getKeys();
        setReferenceMinFrame(0);
        setReferenceMaxFrame(keys[keys.length - 1].frame);
        setFromKey(0);
        setToKey(keys[keys.length - 1].frame);
        setSnippetId(animation.snippetId);
        setClipLength(keys[keys.length - 1].frame);
        // Auto-select the first animation
        setActiveAnimations([animation]);
        if (animation && animation.hasRunningRuntimeAnimations) {
            setIsPlaying(true);
        }
    }, [animations, useTargetAnimations]);
    const play = useCallback((forward) => {
        setIsPlaying(true);
        scene.stopAnimation(target);
        if (forward) {
            if (rootAnimationGroup) {
                rootAnimationGroup.start(true, 1.0, fromKey, toKey);
            }
            else {
                scene.beginAnimation(target, fromKey, toKey, true);
            }
        }
        else {
            if (rootAnimationGroup) {
                rootAnimationGroup.start(true, 1.0, toKey, fromKey);
            }
            else {
                scene.beginAnimation(target, toKey, fromKey, true);
            }
        }
        setForwardAnimation(forward);
        // Move to active frame
        if (rootAnimationGroup) {
            rootAnimationGroup.goToFrame(activeFrame);
        }
        observables.current.onAnimationStateChanged.notifyObservers();
    }, [scene, target, rootAnimationGroup, fromKey, toKey, activeFrame]);
    const stop = useCallback(() => {
        setIsPlaying(false);
        if (rootAnimationGroup) {
            rootAnimationGroup.stop();
        }
        else {
            scene.stopAnimation(target);
        }
        observables.current.onAnimationStateChanged.notifyObservers();
    }, [scene, target, rootAnimationGroup]);
    const moveToFrame = useCallback((frame) => {
        if (!animations || !animations.length) {
            return;
        }
        setActiveFrame(frame);
        observables.current.onPlayheadMoved.notifyObservers(frame);
        if (!isPlaying) {
            if (rootAnimationGroup) {
                rootAnimationGroup.start(false, 1.0, fromKey, toKey);
            }
            else {
                scene.beginAnimation(target, fromKey, toKey, false);
            }
        }
        for (const animationEntry of animations) {
            const animation = useTargetAnimations ? animationEntry.animation : animationEntry;
            if (!animation.hasRunningRuntimeAnimations) {
                return;
            }
            for (const runtimeAnimation of animation.runtimeAnimations) {
                runtimeAnimation.goToFrame(frame);
            }
        }
        stop();
    }, [animations, useTargetAnimations, isPlaying, rootAnimationGroup, scene, target, fromKey, toKey, stop]);
    const refreshTarget = useCallback(() => {
        if (!animations || !animations.length || isPlaying) {
            return;
        }
        moveToFrame(activeFrame);
    }, [animations, isPlaying, moveToFrame, activeFrame]);
    const clearSelection = useCallback(() => {
        setActiveKeyPoints([]);
        observables.current.onActiveKeyPointChanged.notifyObservers();
    }, []);
    const enableChannel = useCallback((animation, color) => {
        setActiveChannels((prev) => ({ ...prev, [animation.uniqueId]: color }));
    }, []);
    const disableChannel = useCallback((animation) => {
        setActiveChannels((prev) => {
            const newChannels = { ...prev };
            delete newChannels[animation.uniqueId];
            return newChannels;
        });
    }, []);
    const isChannelEnabled = useCallback((animation, color) => {
        return activeChannels[animation.uniqueId] === undefined || activeChannels[animation.uniqueId] === color;
    }, [activeChannels]);
    const getActiveChannel = useCallback((animation) => {
        return activeChannels[animation.uniqueId];
    }, [activeChannels]);
    const resetAllActiveChannels = useCallback(() => {
        clearSelection();
        setActiveChannels({});
    }, [clearSelection]);
    const getPrevKey = useCallback(() => {
        if (!animations || !animations.length || activeAnimations.length === 0) {
            return null;
        }
        let prevKey = -Number.MAX_VALUE;
        for (const animation of activeAnimations) {
            const keys = animation.getKeys();
            for (const key of keys) {
                if (key.frame < activeFrame && key.frame > prevKey) {
                    prevKey = key.frame;
                }
            }
        }
        if (prevKey === -Number.MAX_VALUE) {
            prevKey = fromKey;
        }
        return prevKey;
    }, [animations, activeAnimations, activeFrame, fromKey]);
    const getNextKey = useCallback(() => {
        if (!animations || !animations.length) {
            return null;
        }
        let nextKey = Number.MAX_VALUE;
        for (const animation of activeAnimations) {
            const keys = animation.getKeys();
            for (const key of keys) {
                if (key.frame > activeFrame && key.frame < nextKey) {
                    nextKey = key.frame;
                }
            }
        }
        if (nextKey === Number.MAX_VALUE) {
            nextKey = toKey;
        }
        return nextKey;
    }, [animations, activeAnimations, activeFrame, toKey]);
    // Build context value
    const state = useMemo(() => ({
        title,
        animations,
        scene,
        target,
        rootAnimationGroup,
        activeAnimations,
        activeChannels,
        activeKeyPoints,
        mainKeyPoint,
        snippetId,
        useTargetAnimations,
        activeFrame,
        fromKey,
        toKey,
        useExistingPlayRange: false,
        forwardAnimation,
        isPlaying,
        clipLength,
        referenceMinFrame,
        referenceMaxFrame,
        focusedInput,
        lockLastFrameValue: false,
        lockLastFrameFrame: false,
    }), [
        title,
        animations,
        scene,
        target,
        rootAnimationGroup,
        activeAnimations,
        activeChannels,
        activeKeyPoints,
        mainKeyPoint,
        snippetId,
        useTargetAnimations,
        activeFrame,
        fromKey,
        toKey,
        forwardAnimation,
        isPlaying,
        clipLength,
        referenceMinFrame,
        referenceMaxFrame,
        focusedInput,
    ]);
    const actions = useMemo(() => ({
        setActiveAnimations,
        setActiveFrame,
        setFromKey,
        setToKey,
        setIsPlaying,
        setClipLength,
        setReferenceMaxFrame,
        setFocusedInput,
        setActiveKeyPoints,
        setActiveChannels,
        play,
        stop,
        moveToFrame,
        refreshTarget,
        clearSelection,
        enableChannel,
        disableChannel,
        isChannelEnabled,
        getActiveChannel,
        resetAllActiveChannels,
        getPrevKey,
        getNextKey,
        prepare,
    }), [
        play,
        stop,
        moveToFrame,
        refreshTarget,
        clearSelection,
        enableChannel,
        disableChannel,
        isChannelEnabled,
        getActiveChannel,
        resetAllActiveChannels,
        getPrevKey,
        getNextKey,
        prepare,
    ]);
    const contextValue = useMemo(() => ({
        state,
        actions,
        observables: observables.current,
    }), [state, actions]);
    return jsx(CurveEditorContext.Provider, { value: contextValue, children: children });
};
/**
 * Hook to access the curve editor context
 * @returns The curve editor context value
 */
function useCurveEditor() {
    const context = useContext(CurveEditorContext);
    if (!context) {
        throw new Error("useCurveEditor must be used within a CurveEditorProvider");
    }
    return context;
}

const useStyles$A = makeStyles({
    root: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        gap: tokens.spacingHorizontalS,
        padding: `${tokens.spacingVerticalS} ${tokens.spacingHorizontalM}`,
        backgroundColor: tokens.colorNeutralBackground3,
        height: "40px",
        boxSizing: "border-box",
    },
    title: {
        fontWeight: tokens.fontWeightSemibold,
        fontSize: tokens.fontSizeBase300,
        marginRight: tokens.spacingHorizontalM,
    },
    inputGroup: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        gap: tokens.spacingHorizontalXS,
    },
    inputLabel: {
        fontSize: tokens.fontSizeBase200,
        color: tokens.colorNeutralForeground3,
    },
    spinButton: {
        width: "80px",
    },
    buttonGroup: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        gap: tokens.spacingHorizontalXXS,
    },
    divider: {
        height: "24px",
    },
});
/**
 * Top toolbar for the curve editor with frame/value inputs and action buttons
 * @returns The top bar component
 */
const TopBar = () => {
    const styles = useStyles$A();
    const { state, observables } = useCurveEditor();
    const [keyFrameValue, setKeyFrameValue] = useState(null);
    const [keyValue, setKeyValue] = useState(null);
    const [frameControlEnabled, setFrameControlEnabled] = useState(false);
    const [valueControlEnabled, setValueControlEnabled] = useState(false);
    const hasActiveAnimations = state.activeAnimations.length > 0;
    const hasActiveKeyPoints = state.activeKeyPoints && state.activeKeyPoints.length > 0;
    // Subscribe to observables
    useEffect(() => {
        const onFrameSetObserver = observables.onFrameSet.add((newFrameValue) => {
            setKeyFrameValue(Math.round(newFrameValue));
        });
        const onValueSetObserver = observables.onValueSet.add((newValue) => {
            setKeyValue(parseFloat(newValue.toFixed(2)));
        });
        const onActiveAnimationChangedObserver = observables.onActiveAnimationChanged.add(() => {
            // Only reset values if there are no active key points selected
            // This prevents values from being cleared during drag operations
            if (!state.activeKeyPoints || state.activeKeyPoints.length === 0) {
                setKeyFrameValue(null);
                setKeyValue(null);
            }
        });
        const onActiveKeyPointChangedObserver = observables.onActiveKeyPointChanged.add(() => {
            const numKeys = state.activeKeyPoints?.length || 0;
            // TODO: Properly type KeyPointComponent to access curve.animation
            const numAnims = numKeys;
            const frameEnabled = (numKeys === 1 && numAnims === 1) || (numKeys > 1 && numAnims > 1);
            setFrameControlEnabled(frameEnabled);
            setValueControlEnabled(numKeys > 0);
            // Don't reset values here - they are set by onFrameSet/onValueSet observers
        });
        return () => {
            observables.onFrameSet.remove(onFrameSetObserver);
            observables.onValueSet.remove(onValueSetObserver);
            observables.onActiveAnimationChanged.remove(onActiveAnimationChangedObserver);
            observables.onActiveKeyPointChanged.remove(onActiveKeyPointChangedObserver);
        };
    }, [observables, state.activeKeyPoints]);
    const handleFrameChange = useCallback((value) => {
        if (value !== 0) {
            observables.onFrameManuallyEntered.notifyObservers(value);
        }
    }, [observables]);
    const handleValueChange = useCallback((value) => {
        observables.onValueManuallyEntered.notifyObservers(value);
    }, [observables]);
    return (jsxs("div", { className: styles.root, children: [jsx("div", { className: styles.title, children: state.title }), jsx(Divider, { vertical: true, className: styles.divider }), jsxs("div", { className: styles.inputGroup, children: [jsx("div", { className: styles.inputLabel, children: "Frame:" }), jsx(SpinButton, { className: styles.spinButton, value: keyFrameValue ?? 0, onChange: handleFrameChange, disabled: !hasActiveAnimations || !frameControlEnabled })] }), jsxs("div", { className: styles.inputGroup, children: [jsx("div", { className: styles.inputLabel, children: "Value:" }), jsx(SpinButton, { className: styles.spinButton, value: keyValue ?? 0, onChange: handleValueChange, disabled: !hasActiveAnimations || !valueControlEnabled, step: 0.1 })] }), jsx(Divider, { vertical: true, className: styles.divider }), jsxs("div", { className: styles.buttonGroup, children: [jsx(Button, { icon: AddRegular, appearance: "subtle", disabled: !hasActiveAnimations, onClick: () => observables.onCreateOrUpdateKeyPointRequired.notifyObservers(), title: "New key" }), jsx(Button, { icon: DeleteRegular, appearance: "subtle", disabled: !hasActiveKeyPoints, onClick: () => observables.onDeleteKeyActiveKeyPoints.notifyObservers(), title: "Delete key" }), jsx(Button, { icon: FullScreenMaximizeRegular, appearance: "subtle", onClick: () => observables.onFrameRequired.notifyObservers(), title: "Frame canvas" })] }), jsx(Divider, { vertical: true, className: styles.divider }), jsxs("div", { className: styles.buttonGroup, children: [jsx(Button, { icon: FlatTangentIcon, appearance: "subtle", disabled: !hasActiveKeyPoints, onClick: () => observables.onFlattenTangentRequired.notifyObservers(), title: "Flatten tangent" }), jsx(Button, { icon: LinearTangentIcon, appearance: "subtle", disabled: !hasActiveKeyPoints, onClick: () => observables.onLinearTangentRequired.notifyObservers(), title: "Linear tangent" }), jsx(Button, { icon: BreakTangentIcon, appearance: "subtle", disabled: !hasActiveKeyPoints, onClick: () => observables.onBreakTangentRequired.notifyObservers(), title: "Break tangent" }), jsx(Button, { icon: UnifyTangentIcon, appearance: "subtle", disabled: !hasActiveKeyPoints, onClick: () => observables.onUnifyTangentRequired.notifyObservers(), title: "Unify tangent" }), jsx(Button, { icon: StepTangentIcon, appearance: "subtle", disabled: !hasActiveKeyPoints, onClick: () => observables.onStepTangentRequired.notifyObservers(), title: "Step tangent" })] })] }));
};

/**
 * Color constants for the curve editor
 * These colors are used consistently across the curve editor UI for
 * representing different animation channels and UI elements.
 */
/**
 * Channel colors for multi-component animations (vectors, colors, quaternions)
 */
const ChannelColors = {
    /** Red channel / X component */
    X: "#DB3E3E",
    /** Green channel / Y component */
    Y: "#51E22D",
    /** Blue channel / Z component */
    Z: "#00A3FF",
    /** W component (quaternions) */
    W: "#8700FF",
    /** Alpha channel */
    ALPHA: "#FFFFFF",
};
/**
 * Aliases for color channels (R, G, B map to X, Y, Z)
 */
const ColorChannelColors = {
    /** Red channel */
    R: ChannelColors.X,
    /** Green channel */
    G: ChannelColors.Y,
    /** Blue channel */
    B: ChannelColors.Z,
    /** Alpha channel */
    A: ChannelColors.ALPHA,
};
/**
 * Default curve color for single-component (float) animations
 */
const DefaultCurveColor = "#ffffff";

const useStyles$z = makeStyles({
    root: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalM,
    },
    header: {
        display: "flex",
        alignItems: "center",
        gap: tokens.spacingHorizontalS,
    },
    title: {
        fontSize: tokens.fontSizeBase400,
        fontWeight: tokens.fontWeightSemibold,
    },
    form: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalS,
    },
    row: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalXS,
    },
    buttons: {
        display: "flex",
        gap: tokens.spacingHorizontalS,
        marginTop: tokens.spacingVerticalM,
    },
});
const LOOP_MODES$1 = [
    { label: "Cycle", value: 1 },
    { label: "Constant", value: 0 },
    { label: "Relative", value: 2 },
    { label: "Relative from current", value: 4 },
];
/**
 * Panel for editing animation properties
 * @returns The edit animation panel component
 */
const EditAnimationPanel = ({ animation, onClose }) => {
    const styles = useStyles$z();
    const { observables } = useCurveEditor();
    const [name, setName] = useState(animation.name);
    const [property, setProperty] = useState(animation.targetProperty);
    const [loopMode, setLoopMode] = useState(animation.loopMode ?? 1);
    // Update state when animation changes
    useEffect(() => {
        setName(animation.name);
        setProperty(animation.targetProperty);
        setLoopMode(animation.loopMode ?? 1);
    }, [animation]);
    const isValid = name.trim().length > 0 && property.trim().length > 0;
    const saveChanges = useCallback(() => {
        if (!isValid) {
            return;
        }
        // Update animation properties
        animation.name = name;
        animation.targetProperty = property;
        animation.loopMode = loopMode;
        // Notify observers
        observables.onAnimationsLoaded.notifyObservers();
        onClose();
    }, [isValid, name, property, loopMode, animation, observables, onClose]);
    const getLoopModeLabel = (value) => {
        const mode = LOOP_MODES$1.find((m) => m.value === value);
        return mode?.label ?? "Cycle";
    };
    return (jsxs("div", { className: styles.root, children: [jsxs("div", { className: styles.form, children: [jsxs("div", { className: styles.row, children: [jsx(Label, { children: "Display Name" }), jsx(Input, { value: name, onChange: (_, data) => setName(data.value), placeholder: "Animation name" })] }), jsxs("div", { className: styles.row, children: [jsx(Label, { children: "Property" }), jsx(Input, { value: property, onChange: (_, data) => setProperty(data.value), placeholder: "e.g., position, rotation, scaling" })] }), jsxs("div", { className: styles.row, children: [jsx(Label, { children: "Loop Mode" }), jsx(Dropdown$1, { value: getLoopModeLabel(loopMode), selectedOptions: [loopMode.toString()], onOptionSelect: (_, data) => setLoopMode(Number(data.optionValue)), positioning: "below", inlinePopup: true, children: LOOP_MODES$1.map((mode) => (jsx(Option, { value: mode.value.toString(), children: mode.label }, mode.value))) })] })] }), jsxs("div", { className: styles.buttons, children: [jsx(Button, { appearance: "primary", onClick: saveChanges, label: "Save", disabled: !isValid }), jsx(Button, { appearance: "subtle", onClick: onClose, label: "Cancel" })] })] }));
};

const useStyles$y = makeStyles({
    root: {
        display: "flex",
        flexDirection: "column",
    },
    entry: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        padding: `${tokens.spacingVerticalXS} ${tokens.spacingHorizontalS}`,
        cursor: "pointer",
        borderRadius: tokens.borderRadiusMedium,
        color: tokens.colorNeutralForeground1,
        "&:hover": {
            backgroundColor: tokens.colorSubtleBackgroundHover,
        },
    },
    entryActive: {
        backgroundColor: tokens.colorSubtleBackgroundSelected,
        color: tokens.colorNeutralForeground1,
        "&:hover": {
            backgroundColor: tokens.colorSubtleBackgroundSelected,
        },
    },
    chevron: {
        width: "20px",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        flexShrink: 0,
    },
    name: {
        flex: 1,
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        fontSize: tokens.fontSizeBase200,
        color: "inherit",
    },
    actions: {
        display: "flex",
        flexDirection: "row",
        gap: tokens.spacingHorizontalXXS,
        opacity: 0,
    },
    actionsVisible: {
        opacity: 1,
    },
    subEntry: {
        paddingLeft: tokens.spacingHorizontalL,
    },
    subEntryDisabled: {
        opacity: 0.5,
    },
    colorDot: {
        width: "8px",
        height: "8px",
        borderRadius: "50%",
        marginRight: tokens.spacingHorizontalXS,
    },
});
/**
 * Single animation entry in the list
 * @returns Animation entry component
 */
const AnimationEntry = ({ animation }) => {
    const styles = useStyles$y();
    const { state, actions, observables } = useCurveEditor();
    const [isExpanded, setIsExpanded] = useState(false);
    const [isHovered, setIsHovered] = useState(false);
    const [isEditOpen, setIsEditOpen] = useState(false);
    const isActive = state.activeAnimations.indexOf(animation) !== -1;
    const isExpandable = animation.dataType !== Animation.ANIMATIONTYPE_FLOAT;
    const handleClick = useCallback((evt) => {
        if (!evt.ctrlKey) {
            actions.setActiveAnimations([animation]);
            actions.resetAllActiveChannels();
        }
        else {
            const index = state.activeAnimations.indexOf(animation);
            if (index !== -1) {
                actions.setActiveAnimations((prev) => prev.filter((a) => a !== animation));
            }
            else {
                actions.setActiveAnimations((prev) => [...prev, animation]);
            }
        }
        actions.disableChannel(animation);
        observables.onActiveAnimationChanged.notifyObservers({});
    }, [animation, actions, observables, state.activeAnimations]);
    const handleExpandClick = useCallback((evt) => {
        evt?.stopPropagation();
        setIsExpanded((prev) => !prev);
    }, []);
    const handleEditOpenChange = useCallback((open) => {
        setIsEditOpen(open);
    }, []);
    const handleDelete = useCallback((evt) => {
        evt?.stopPropagation();
        observables.onDeleteAnimation.notifyObservers(animation);
    }, [animation, observables]);
    const getSubEntries = () => {
        switch (animation.dataType) {
            case Animation.ANIMATIONTYPE_COLOR3:
                return [
                    { name: "Red", color: ColorChannelColors.R },
                    { name: "Green", color: ColorChannelColors.G },
                    { name: "Blue", color: ColorChannelColors.B },
                ];
            case Animation.ANIMATIONTYPE_COLOR4:
                return [
                    { name: "Red", color: ColorChannelColors.R },
                    { name: "Green", color: ColorChannelColors.G },
                    { name: "Blue", color: ColorChannelColors.B },
                    { name: "Alpha", color: ColorChannelColors.A },
                ];
            case Animation.ANIMATIONTYPE_VECTOR2:
                return [
                    { name: "X", color: ChannelColors.X },
                    { name: "Y", color: ChannelColors.Y },
                ];
            case Animation.ANIMATIONTYPE_VECTOR3:
                return [
                    { name: "X", color: ChannelColors.X },
                    { name: "Y", color: ChannelColors.Y },
                    { name: "Z", color: ChannelColors.Z },
                ];
            case Animation.ANIMATIONTYPE_QUATERNION:
                return [
                    { name: "X", color: ChannelColors.X },
                    { name: "Y", color: ChannelColors.Y },
                    { name: "Z", color: ChannelColors.Z },
                    { name: "W", color: ChannelColors.W },
                ];
            default:
                return [];
        }
    };
    return (jsxs("div", { className: styles.root, children: [jsxs("div", { className: `${styles.entry} ${isActive ? styles.entryActive : ""}`, onClick: handleClick, onMouseEnter: () => setIsHovered(true), onMouseLeave: () => setIsHovered(false), children: [jsx("div", { className: styles.chevron, children: isExpandable ? (jsx(Button, { icon: isExpanded ? ChevronDownRegular : ChevronRightRegular, appearance: "transparent", onClick: handleExpandClick })) : (jsx(CircleSmallFilled, {})) }), jsx("div", { className: styles.name, title: animation.name, children: animation.name }), jsxs("div", { className: `${styles.actions} ${isHovered || isEditOpen ? styles.actionsVisible : ""}`, children: [jsx(Popover, { open: isEditOpen, onOpenChange: handleEditOpenChange, positioning: "after", trigger: jsx(Button, { icon: SettingsRegular, appearance: "transparent", title: "Edit animation" }), children: jsx(EditAnimationPanel, { animation: animation, onClose: () => setIsEditOpen(false) }) }), jsx(Button, { icon: DeleteRegular, appearance: "transparent", onClick: handleDelete, title: "Delete animation" })] })] }), isExpanded && getSubEntries().map((sub) => jsx(AnimationSubEntry, { animation: animation, subName: sub.name, color: sub.color }, sub.name))] }));
};
/**
 * Sub-entry for vector/color animations (X, Y, Z, R, G, B, etc.)
 * @returns Animation sub-entry component
 */
const AnimationSubEntry = ({ animation, subName, color }) => {
    const styles = useStyles$y();
    const { actions, observables } = useCurveEditor();
    const activeChannel = actions.getActiveChannel(animation);
    const isThisChannelActive = activeChannel === color;
    const isEnabled = activeChannel === undefined || isThisChannelActive;
    const handleClick = useCallback(() => {
        if (isThisChannelActive) {
            // Clicking on the already-active channel disables filtering (shows all)
            actions.disableChannel(animation);
        }
        else {
            // Clicking on a channel enables only that channel
            actions.enableChannel(animation, color);
        }
        observables.onActiveAnimationChanged.notifyObservers({});
    }, [animation, color, isThisChannelActive, actions, observables]);
    return (jsxs("div", { className: `${styles.entry} ${styles.subEntry} ${!isEnabled ? styles.subEntryDisabled : ""}`, onClick: handleClick, children: [jsx("div", { className: styles.colorDot, style: { backgroundColor: color } }), jsx("div", { className: styles.name, children: subName })] }));
};
/**
 * Animation list component showing all animations
 * @returns Animation list component
 */
const AnimationList = () => {
    const styles = useStyles$y();
    const { state, observables } = useCurveEditor();
    // Re-render when animations are loaded or changed (e.g. animation deleted)
    // useCallback stabilizes the accessor to prevent infinite re-render loops
    useObservableState(useCallback(() => ({}), []), observables.onAnimationsLoaded, observables.onActiveAnimationChanged);
    // Get animations from target if available (for dynamically added animations), otherwise from state
    const animations = state.target?.animations ?? state.animations;
    return (jsx("div", { className: styles.root, children: animations?.map((a, i) => {
            const animation = state.useTargetAnimations ? a.animation : a;
            return jsx(AnimationEntry, { animation: animation }, animation.uniqueId ?? i);
        }) }));
};

const useStyles$x = makeStyles({
    root: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalM,
    },
    header: {
        display: "flex",
        alignItems: "center",
        gap: tokens.spacingHorizontalS,
    },
    title: {
        fontSize: tokens.fontSizeBase400,
        fontWeight: tokens.fontWeightSemibold,
    },
    form: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalS,
    },
    row: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalXS,
    },
    buttons: {
        display: "flex",
        gap: tokens.spacingHorizontalS,
        marginTop: tokens.spacingVerticalM,
    },
    typeDisplay: {
        padding: `${tokens.spacingVerticalS} ${tokens.spacingHorizontalM}`,
        backgroundColor: tokens.colorNeutralBackground3,
        borderRadius: tokens.borderRadiusMedium,
        fontSize: tokens.fontSizeBase300,
    },
});
const ANIMATION_TYPES = ["Float", "Vector2", "Vector3", "Quaternion", "Color3", "Color4"];
const LOOP_MODES = ["Cycle", "Relative", "Relative from current", "Constant"];
const MODES = ["List", "Custom"];
/**
 * Panel for adding new animations
 * @returns The add animation panel component
 */
const AddAnimationPanel = ({ onClose }) => {
    const styles = useStyles$x();
    const { state, observables } = useCurveEditor();
    const [name, setName] = useState("");
    const [mode, setMode] = useState("List");
    const [customProperty, setCustomProperty] = useState("");
    const [selectedProperty, setSelectedProperty] = useState("");
    const [animationType, setAnimationType] = useState("Float");
    const [loopMode, setLoopMode] = useState("Cycle");
    // Get animatable properties from target
    const properties = useMemo(() => {
        const result = [];
        if (!state.target) {
            return result;
        }
        let target = state.target;
        const source = state.target;
        while (target !== null) {
            const descriptors = Object.getOwnPropertyDescriptors(target);
            for (const property in descriptors) {
                const descriptor = descriptors[property];
                // Skip private properties and null/undefined values
                if (property[0] === "_" || source[property] === null || source[property] === undefined) {
                    continue;
                }
                const value = source[property];
                // Skip non-animatable values (must be number, vector, quaternion, or color)
                if (value.r === undefined && value.x === undefined && isNaN(parseFloat(value))) {
                    continue;
                }
                // Skip duplicates
                if (result.indexOf(property) !== -1) {
                    continue;
                }
                // Skip read-only properties
                if (!descriptor.writable && !descriptor.set) {
                    continue;
                }
                result.push(property);
            }
            target = Object.getPrototypeOf(target);
        }
        result.sort();
        // Move common properties to the top
        const main = ["scaling", "rotation", "position"];
        for (const mainProperty of main) {
            const index = result.indexOf(mainProperty);
            if (index !== -1) {
                result.splice(index, 1);
                result.unshift(mainProperty);
            }
        }
        return result;
    }, [state.target]);
    // Set initial selected property when properties change
    useEffect(() => {
        if (properties.length > 0 && !selectedProperty) {
            setSelectedProperty(properties[0]);
        }
    }, [properties, selectedProperty]);
    // Infer type from selected property value
    const inferredType = useMemo(() => {
        if (mode === "Custom" || !state.target || !selectedProperty) {
            return animationType;
        }
        const source = state.target;
        const value = source[selectedProperty];
        if (value === null || value === undefined) {
            return "Float";
        }
        if (!isNaN(parseFloat(value))) {
            return "Float";
        }
        const valueObj = value;
        if (valueObj.getClassName) {
            const className = valueObj.getClassName();
            if (ANIMATION_TYPES.includes(className)) {
                return className;
            }
        }
        return "Float";
    }, [mode, state.target, selectedProperty, animationType]);
    const isCustomMode = mode === "Custom" || properties.length === 0;
    const currentProperty = isCustomMode ? customProperty : selectedProperty;
    const currentType = isCustomMode ? animationType : inferredType;
    // Get FPS from existing animations or default to 60
    const fps = useMemo(() => {
        if (state.animations && state.animations.length) {
            const anim = state.useTargetAnimations ? state.animations[0].animation : state.animations[0];
            return anim.framePerSecond;
        }
        return 60;
    }, [state.animations, state.useTargetAnimations]);
    // Get min/max frame from existing animations
    const { minFrame, maxFrame } = useMemo(() => {
        let min = 0;
        let max = 100;
        if (state.animations) {
            for (const anim of state.animations) {
                const innerAnim = state.useTargetAnimations ? anim.animation : anim;
                const keys = innerAnim.getKeys();
                if (keys.length) {
                    min = Math.min(min, keys[0].frame);
                    max = Math.max(max, keys[keys.length - 1].frame);
                }
            }
        }
        return { minFrame: min, maxFrame: max };
    }, [state.animations, state.useTargetAnimations]);
    // Validation for the create button
    const isValid = name.trim() !== "" && currentProperty.trim() !== "";
    const createAnimation = useCallback(() => {
        if (!name || !currentProperty) {
            return;
        }
        let dataType = 0;
        let loopModeValue = 0;
        let defaultValue0;
        let defaultValue1;
        let defaultTangent0;
        let defaultTangent1;
        // Set data type and default values
        switch (currentType) {
            case "Float":
                dataType = Animation.ANIMATIONTYPE_FLOAT;
                defaultValue0 = 0;
                defaultValue1 = 1;
                defaultTangent0 = 0;
                defaultTangent1 = 0;
                break;
            case "Vector2":
                dataType = Animation.ANIMATIONTYPE_VECTOR2;
                defaultValue0 = Vector2.Zero();
                defaultValue1 = new Vector2(1, 1);
                defaultTangent0 = new Vector2(0, 0);
                defaultTangent1 = new Vector2(0, 0);
                break;
            case "Vector3":
                dataType = Animation.ANIMATIONTYPE_VECTOR3;
                defaultValue0 = Vector3.Zero();
                defaultValue1 = new Vector3(1, 1, 1);
                defaultTangent0 = new Vector3(0, 0, 0);
                defaultTangent1 = new Vector3(0, 0, 0);
                break;
            case "Quaternion":
                dataType = Animation.ANIMATIONTYPE_QUATERNION;
                defaultValue0 = Quaternion.Zero();
                defaultValue1 = new Quaternion(1, 1, 1, 0);
                defaultTangent0 = new Quaternion(0, 0, 0, 0);
                defaultTangent1 = new Quaternion(0, 0, 0, 0);
                break;
            case "Color3":
                dataType = Animation.ANIMATIONTYPE_COLOR3;
                defaultValue0 = Color3.Black();
                defaultValue1 = Color3.White();
                defaultTangent0 = new Color3(0, 0, 0);
                defaultTangent1 = new Color3(0, 0, 0);
                break;
            case "Color4":
                dataType = Animation.ANIMATIONTYPE_COLOR4;
                defaultValue0 = new Color4(0, 0, 0, 0);
                defaultValue1 = new Color4(1, 1, 1, 1);
                defaultTangent0 = new Color4(0, 0, 0, 0);
                defaultTangent1 = new Color4(0, 0, 0, 0);
                break;
        }
        // Set loop mode
        switch (loopMode) {
            case "Cycle":
                loopModeValue = Animation.ANIMATIONLOOPMODE_CYCLE;
                break;
            case "Relative":
                loopModeValue = Animation.ANIMATIONLOOPMODE_RELATIVE;
                break;
            case "Relative from current":
                loopModeValue = Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;
                break;
            case "Constant":
                loopModeValue = Animation.ANIMATIONLOOPMODE_CONSTANT;
                break;
        }
        // Create the animation
        const animation = new Animation(name, currentProperty, fps, dataType, loopModeValue);
        const keys = [
            {
                frame: minFrame,
                value: defaultValue0,
                inTangent: defaultTangent0,
                outTangent: defaultTangent0,
            },
            {
                frame: maxFrame,
                value: defaultValue1,
                inTangent: defaultTangent1,
                outTangent: defaultTangent1,
            },
        ];
        animation.setKeys(keys);
        // Add to target animations
        if (state.target) {
            if (!state.target.animations || state.target.animations.length === 0) {
                state.target.animations = [animation];
            }
            else {
                state.target.animations = [...state.target.animations, animation];
            }
        }
        // Close first so AnimationList mounts, then notify
        onClose();
        observables.onAnimationsLoaded.notifyObservers();
    }, [name, currentProperty, currentType, loopMode, fps, minFrame, maxFrame, state, observables, onClose]);
    return (jsxs("div", { className: styles.root, children: [jsx("div", { className: styles.header, children: jsx("div", { className: styles.title, children: "Add Animation" }) }), jsxs("div", { className: styles.form, children: [jsxs("div", { className: styles.row, children: [jsx(Label, { children: "Display Name" }), jsx(Input, { value: name, onChange: (_, data) => setName(data.value), placeholder: "Animation name" })] }), jsxs("div", { className: styles.row, children: [jsx(Label, { children: "Mode" }), jsx(Dropdown$1, { value: mode, selectedOptions: [mode], onOptionSelect: (_, data) => setMode(data.optionValue), disabled: properties.length === 0, children: MODES.map((m) => (jsx(Option, { value: m, children: m }, m))) })] }), jsxs("div", { className: styles.row, children: [jsx(Label, { children: "Property" }), isCustomMode ? (jsx(Input, { value: customProperty, onChange: (_, data) => setCustomProperty(data.value), placeholder: "e.g., position, rotation, scaling" })) : (jsx(Dropdown$1, { value: selectedProperty, selectedOptions: [selectedProperty], onOptionSelect: (_, data) => setSelectedProperty(data.optionValue), children: properties.map((prop) => (jsx(Option, { value: prop, children: prop }, prop))) }))] }), jsxs("div", { className: styles.row, children: [jsx(Label, { children: "Type" }), isCustomMode ? (jsx(Dropdown$1, { value: animationType, selectedOptions: [animationType], onOptionSelect: (_, data) => setAnimationType(data.optionValue), children: ANIMATION_TYPES.map((type) => (jsx(Option, { value: type, children: type }, type))) })) : (jsx("div", { className: styles.typeDisplay, children: inferredType }))] }), jsxs("div", { className: styles.row, children: [jsx(Label, { children: "Loop Mode" }), jsx(Dropdown$1, { value: loopMode, selectedOptions: [loopMode], onOptionSelect: (_, data) => setLoopMode(data.optionValue), children: LOOP_MODES.map((lm) => (jsx(Option, { value: lm, children: lm }, lm))) })] })] }), jsxs("div", { className: styles.buttons, children: [jsx(Button, { appearance: "primary", onClick: createAnimation, disabled: !isValid, label: "Create" }), jsx(Button, { appearance: "subtle", onClick: onClose, label: "Cancel" })] })] }));
};

const useStyles$w = makeStyles({
    root: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalM,
    },
    header: {
        display: "flex",
        alignItems: "center",
        gap: tokens.spacingHorizontalS,
    },
    title: {
        fontSize: tokens.fontSizeBase400,
        fontWeight: tokens.fontWeightSemibold,
    },
    section: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalS,
    },
    row: {
        display: "flex",
        alignItems: "center",
        gap: tokens.spacingHorizontalS,
    },
    input: {
        flex: 1,
    },
    snippetId: {
        fontSize: tokens.fontSizeBase200,
        color: tokens.colorNeutralForeground3,
        marginTop: tokens.spacingVerticalS,
    },
    errorText: {
        color: tokens.colorPaletteRedForeground1,
        fontSize: tokens.fontSizeBase200,
    },
});
/**
 * Panel for loading animations from file or snippet server
 * @returns The load animation panel component
 */
const LoadAnimationPanel = ({ onClose }) => {
    const styles = useStyles$w();
    const { state, actions, observables } = useCurveEditor();
    const [snippetIdInput, setSnippetIdInput] = useState("");
    const [loadedSnippetId, setLoadedSnippetId] = useState(null);
    const [loadError, setLoadError] = useState(null);
    const loadAnimations = useCallback((animations) => {
        // Update target
        if (state.target) {
            state.target.animations = animations;
        }
        // Update active animations
        actions.setActiveAnimations(animations.length ? animations : []);
        // Close first so AnimationList mounts, then notify
        onClose();
        observables.onAnimationsLoaded.notifyObservers();
        observables.onActiveAnimationChanged.notifyObservers({});
    }, [state.target, actions, observables, onClose]);
    const loadFromFile = useCallback((files) => {
        if (!files.length) {
            return;
        }
        const file = files[0];
        Tools.ReadFile(file, (data) => {
            const decoder = new TextDecoder("utf-8");
            const parsedAnimations = JSON.parse(decoder.decode(data)).animations;
            const animations = [];
            for (const parsedAnimation of parsedAnimations) {
                animations.push(Animation.Parse(parsedAnimation));
            }
            loadAnimations(animations);
        }, undefined, true);
    }, [loadAnimations]);
    const loadFromSnippetServer = useCallback(async () => {
        if (!snippetIdInput) {
            return;
        }
        setLoadError(null);
        try {
            const result = await Animation.ParseFromSnippetAsync(snippetIdInput);
            const animations = Array.isArray(result) ? result : [result];
            setLoadedSnippetId(snippetIdInput);
            loadAnimations(animations);
        }
        catch (err) {
            setLoadError("Unable to load animations: " + err);
        }
    }, [snippetIdInput, loadAnimations]);
    return (jsxs("div", { className: styles.root, children: [jsx("div", { className: styles.header, children: jsx("div", { className: styles.title, children: "Load Animations" }) }), jsxs("div", { className: styles.section, children: [jsx(Label, { children: "From Snippet Server" }), jsxs("div", { className: styles.row, children: [jsx(Input, { className: styles.input, placeholder: "Snippet ID", value: snippetIdInput, onChange: (_, data) => setSnippetIdInput(data.value) }), jsx(Button, { appearance: "primary", onClick: loadFromSnippetServer, disabled: !snippetIdInput.trim(), label: "Load" })] }), loadError && jsx("div", { className: styles.errorText, children: loadError })] }), jsxs("div", { className: styles.section, children: [jsx(Label, { children: "From File" }), jsx(UploadButton, { appearance: "subtle", onUpload: loadFromFile, accept: ".json", label: "Browse..." })] }), loadedSnippetId && jsxs("div", { className: styles.snippetId, children: ["Loaded Snippet ID: ", loadedSnippetId] })] }));
};

class StringTools {
    /*
     * Based on FileSaver.js
     * A saveAs() FileSaver implementation.
     *
     * By Eli Grey, http://eligrey.com
     *
     * License : https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md (MIT)
     * source  : http://purl.eligrey.com/github/FileSaver.js
     */
    static _SaveAs(blob, name, document) {
        if ("download" in HTMLAnchorElement.prototype) {
            const url = window.URL || window.webkitURL;
            const a = document.createElement("a");
            a.download = name;
            a.rel = "noopener"; // tabnabbing
            a.href = url.createObjectURL(blob);
            setTimeout(() => {
                url.revokeObjectURL(a.href);
            }, 4e4); // 40s
            setTimeout(() => {
                this._Click(a, document);
            }, 0);
            return;
        }
        // Open a popup immediately do go around popup blocker
        // Mostly only available on user interaction and the fileReader is async so...
        let popup = open("", "_blank");
        if (popup) {
            popup.document.title = popup.document.body.innerText = "downloading...";
        }
        const force = blob.type === "application/octet-stream";
        const isSafari = /constructor/i.test(window.HTMLElement) || window.safari;
        const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((isChromeIOS || (force && isSafari)) && typeof FileReader !== "undefined") {
            // Safari doesn't allow downloading of blob URLs
            const reader = new FileReader();
            reader.onloadend = () => {
                let url = reader.result;
                url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, "data:attachment/file;");
                if (popup) {
                    popup.location.href = url;
                }
                else {
                    location.href = url;
                }
                popup = null;
            };
            reader.readAsDataURL(blob);
        }
        else {
            const windowUrl = window.URL || window.webkitURL;
            const url = windowUrl.createObjectURL(blob);
            if (popup) {
                popup.location.href = url;
            }
            else {
                location.href = url;
            }
            popup = null;
            setTimeout(function () {
                windowUrl.revokeObjectURL(url);
            }, 4e4);
        }
    }
    static _Click(node, document) {
        try {
            node.dispatchEvent(new MouseEvent("click"));
        }
        catch (e) {
            const evt = document.createEvent("MouseEvents");
            evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
            node.dispatchEvent(evt);
        }
    }
    /**
     * Download a string into a file that will be saved locally by the browser
     * @param document
     * @param content defines the string to download locally as a file
     * @param filename
     */
    static DownloadAsFile(document, content, filename) {
        const blob = new Blob([content], {
            type: "application/octet-stream",
        });
        this._SaveAs(blob, filename, document);
    }
}

const useStyles$v = makeStyles({
    root: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalM,
    },
    header: {
        display: "flex",
        alignItems: "center",
        gap: tokens.spacingHorizontalS,
    },
    title: {
        fontSize: tokens.fontSizeBase400,
        fontWeight: tokens.fontWeightSemibold,
    },
    list: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalXS,
        maxHeight: "200px",
        overflow: "auto",
        padding: tokens.spacingVerticalS,
        backgroundColor: tokens.colorNeutralBackground2,
        borderRadius: tokens.borderRadiusMedium,
    },
    buttons: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalS,
    },
    snippetId: {
        fontSize: tokens.fontSizeBase200,
        color: tokens.colorNeutralForeground3,
        marginTop: tokens.spacingVerticalS,
    },
    errorText: {
        color: tokens.colorPaletteRedForeground1,
        fontSize: tokens.fontSizeBase200,
    },
});
/**
 * Panel for saving animations to file or snippet server
 * @returns The save animation panel component
 */
const SaveAnimationPanel = ({ onClose: _onClose }) => {
    const styles = useStyles$v();
    const { state } = useCurveEditor();
    const [selectedAnimations, setSelectedAnimations] = useState(() => {
        if (!state.animations) {
            return [];
        }
        if (state.useTargetAnimations) {
            return state.animations.map((ta) => ta.animation);
        }
        return [...state.animations];
    });
    const [snippetId, setSnippetId] = useState(null);
    const [saveError, setSaveError] = useState(null);
    const [isSaving, setIsSaving] = useState(false);
    const getAnimation = useCallback((anim) => {
        return state.useTargetAnimations ? anim.animation : anim;
    }, [state.useTargetAnimations]);
    const toggleAnimation = useCallback((animation, checked) => {
        setSelectedAnimations((prev) => {
            if (checked) {
                return [...prev, animation];
            }
            return prev.filter((a) => a !== animation);
        });
    }, []);
    const getJson = useCallback(() => {
        const json = { animations: [] };
        for (const animation of selectedAnimations) {
            json.animations.push(animation.serialize());
        }
        return JSON.stringify(json);
    }, [selectedAnimations]);
    const saveToFile = useCallback(() => {
        StringTools.DownloadAsFile(document, getJson(), "animations.json");
    }, [getJson]);
    const saveToSnippetServer = useCallback(() => {
        const xmlHttp = new XMLHttpRequest();
        const json = getJson();
        setIsSaving(true);
        setSaveError(null);
        xmlHttp.onreadystatechange = () => {
            if (xmlHttp.readyState === 4) {
                setIsSaving(false);
                if (xmlHttp.status === 200) {
                    const snippet = JSON.parse(xmlHttp.responseText);
                    let newSnippetId = snippet.id;
                    if (snippet.version && snippet.version !== "0") {
                        newSnippetId += "#" + snippet.version;
                    }
                    setSnippetId(newSnippetId);
                }
                else {
                    setSaveError("Unable to save your animations. Please try again.");
                }
            }
        };
        xmlHttp.open("POST", Animation.SnippetUrl + (snippetId ? "/" + snippetId : ""), true);
        xmlHttp.setRequestHeader("Content-Type", "application/json");
        const dataToSend = {
            payload: JSON.stringify({ animations: json }),
            name: "",
            description: "",
            tags: "",
        };
        xmlHttp.send(JSON.stringify(dataToSend));
    }, [getJson, snippetId]);
    return (jsxs("div", { className: styles.root, children: [jsx("div", { className: styles.header, children: jsx("div", { className: styles.title, children: "Save Animations" }) }), jsx("div", { className: styles.list, children: state.animations?.map((anim, i) => {
                    const animation = getAnimation(anim);
                    const isChecked = selectedAnimations.includes(animation);
                    return jsx(Checkbox$1, { label: animation.name, checked: isChecked, onChange: (_, data) => toggleAnimation(animation, !!data.checked) }, i);
                }) }), jsxs("div", { className: styles.buttons, children: [jsx(Button, { appearance: "primary", onClick: saveToSnippetServer, disabled: selectedAnimations.length === 0 || isSaving, label: isSaving ? "Saving..." : "Save to Snippet Server" }), jsx(Button, { appearance: "secondary", onClick: saveToFile, disabled: selectedAnimations.length === 0, label: "Save to File" })] }), saveError && jsx("div", { className: styles.errorText, children: saveError }), snippetId && jsxs("div", { className: styles.snippetId, children: ["Saved! Snippet ID: ", snippetId] })] }));
};

const useStyles$u = makeStyles({
    root: {
        display: "flex",
        flexDirection: "column",
        width: "100%",
        height: "100%",
        minHeight: 0,
        backgroundColor: tokens.colorNeutralBackground1,
        overflow: "hidden",
    },
    menuBar: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        gap: tokens.spacingHorizontalXS,
        padding: `0 ${tokens.spacingHorizontalS}`,
        backgroundColor: tokens.colorNeutralBackground2,
        height: "30px",
        flexShrink: 0,
    },
    fpsInput: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        gap: tokens.spacingHorizontalXS,
        marginLeft: "auto",
    },
    fpsLabel: {
        fontSize: tokens.fontSizeBase200,
        color: tokens.colorNeutralForeground3,
    },
    spinButton: {
        width: "60px",
    },
    tabList: {
        padding: `0 ${tokens.spacingHorizontalS}`,
    },
    content: {
        flex: 1,
        minHeight: 0,
        overflow: "auto",
        padding: tokens.spacingHorizontalS,
    },
    popoverSurface: {
        padding: tokens.spacingHorizontalM,
        maxHeight: "500px",
        overflow: "auto",
    },
});
/**
 * Sidebar component for the curve editor with animation list and controls
 * @returns The sidebar component
 */
const SideBar = () => {
    const styles = useStyles$u();
    const { state, actions, observables } = useCurveEditor();
    const [openPopover, setOpenPopover] = useState(null);
    const [fps, setFps] = useState(60);
    // Get FPS from animations
    useEffect(() => {
        if (state.animations && state.animations.length) {
            const animation = state.useTargetAnimations ? state.animations[0].animation : state.animations[0];
            setFps(animation.framePerSecond);
        }
    }, [state.animations, state.useTargetAnimations]);
    // Subscribe to animations loaded
    useEffect(() => {
        const observer = observables.onAnimationsLoaded.add(() => {
            setOpenPopover(null);
        });
        return () => {
            observables.onAnimationsLoaded.remove(observer);
        };
    }, [observables]);
    // Subscribe to delete animation request - use ref to access current state.target
    const targetRef = useRef(state.target);
    targetRef.current = state.target;
    useEffect(() => {
        const observer = observables.onDeleteAnimation.add((animation) => {
            // Remove from active animations
            actions.setActiveAnimations((prev) => prev.filter((a) => a !== animation));
            // Update target if exists
            const target = targetRef.current;
            if (target && target.animations) {
                target.animations = target.animations.filter((a) => a !== animation);
            }
            // Also update state.animations if it's an array we can filter
            // This mutates the array in place since we can't setState on a prop
            if (state.animations) {
                const index = state.animations.findIndex((a) => {
                    const anim = state.useTargetAnimations ? a.animation : a;
                    return anim === animation;
                });
                if (index !== -1) {
                    state.animations.splice(index, 1);
                }
            }
            observables.onAnimationsLoaded.notifyObservers();
            observables.onActiveAnimationChanged.notifyObservers({});
        });
        return () => {
            observables.onDeleteAnimation.remove(observer);
        };
        // Note: We intentionally don't include actions in deps because setActiveAnimations is stable
    }, [observables]);
    const handleFpsChange = useCallback((value) => {
        if (state.animations) {
            setFps(value);
            for (const anim of state.animations) {
                if (state.useTargetAnimations) {
                    anim.animation.framePerSecond = value;
                }
                else {
                    anim.framePerSecond = value;
                }
            }
        }
    }, [state.animations, state.useTargetAnimations]);
    return (jsxs("div", { className: styles.root, children: [jsxs("div", { className: styles.menuBar, children: [!state.useTargetAnimations && (jsxs(Fragment, { children: [jsx(Popover, { open: openPopover === "add", onOpenChange: (open) => setOpenPopover(open ? "add" : null), positioning: "below-start", trigger: jsx(Button, { icon: AddRegular, appearance: openPopover === "add" ? "primary" : "subtle", title: "Add new animation" }), children: jsx(AddAnimationPanel, { onClose: () => setOpenPopover(null) }) }), jsx(Popover, { open: openPopover === "load", onOpenChange: (open) => setOpenPopover(open ? "load" : null), positioning: "below-start", trigger: jsx(Button, { icon: ArrowDownloadRegular, appearance: openPopover === "load" ? "primary" : "subtle", title: "Load animations" }), children: jsx(LoadAnimationPanel, { onClose: () => setOpenPopover(null) }) })] })), jsx(Popover, { open: openPopover === "save", onOpenChange: (open) => setOpenPopover(open ? "save" : null), positioning: "below-start", trigger: jsx(Button, { icon: SaveRegular, appearance: openPopover === "save" ? "primary" : "subtle", title: "Save current animations" }), children: jsx(SaveAnimationPanel, { onClose: () => setOpenPopover(null) }) }), jsxs("div", { className: styles.fpsInput, children: [jsx(SpinButton, { className: styles.spinButton, value: fps, onChange: handleFpsChange, min: 1, max: 120 }), jsx("div", { className: styles.fpsLabel, children: "fps" })] })] }), jsx("div", { className: styles.content, children: jsx(AnimationList, {}) })] }));
};

class CurveData {
    constructor(color, animation, property, tangentBuilder, setDefaultInTangent, setDefaultOutTangent) {
        this.keys = [];
        this.onDataUpdatedObservable = new Observable();
        this.color = color;
        this.animation = animation;
        this.property = property;
        this.tangentBuilder = tangentBuilder;
        this.setDefaultInTangent = setDefaultInTangent;
        this.setDefaultOutTangent = setDefaultOutTangent;
    }
    getPathData(convertX, convertY) {
        const keys = this.keys;
        if (keys.length < 2) {
            return "";
        }
        let pathData = `M${convertX(keys[0].frame)} ${convertY(keys[0].value)}`;
        const dataType = this.animation.dataType;
        for (let keyIndex = 1; keyIndex < keys.length; keyIndex++) {
            const outTangent = keys[keyIndex - 1].outTangent;
            const inTangent = keys[keyIndex].inTangent;
            const currentFrame = keys[keyIndex].frame;
            const currentValue = keys[keyIndex].value;
            const prevFrame = keys[keyIndex - 1].frame;
            const prevValue = keys[keyIndex - 1].value;
            const frameDist = currentFrame - prevFrame;
            const prevInterpolation = keys[keyIndex - 1].interpolation;
            if (prevInterpolation === 1 /* AnimationKeyInterpolation.STEP */) {
                // Draw a stepped curve
                pathData += `L ${convertX(currentFrame)} ${convertY(prevValue)}`;
                pathData += `L ${convertX(currentFrame)} ${convertY(currentValue)}`;
                continue;
            }
            if (outTangent === undefined && inTangent === undefined && dataType !== Animation.ANIMATIONTYPE_QUATERNION) {
                // Draw a straight line
                pathData += ` L${convertX(currentFrame)} ${convertY(currentValue)}`;
                continue;
            }
            // Let's sample the curve else
            for (let frame = prevFrame; frame < currentFrame; frame += frameDist / CurveData.SampleRate) {
                const keyValue = this.animation.evaluate(frame);
                const value = this.property ? keyValue[this.property] : keyValue;
                pathData += ` L${convertX(frame)} ${convertY(value)}`;
            }
            pathData += ` L${convertX(currentFrame)} ${convertY(currentValue)}`;
        }
        return pathData;
    }
    updateLockedTangentMode(keyIndex, enabled) {
        const keys = this.keys;
        keys[keyIndex].lockedTangent = enabled;
        const animationKeys = this.animation.getKeys();
        animationKeys[keyIndex].lockedTangent = enabled;
    }
    updateInterpolationMode(keyIndex, interpolationMode) {
        const keys = this.keys;
        keys[keyIndex].interpolation = interpolationMode;
        const animationKeys = this.animation.getKeys();
        animationKeys[keyIndex].interpolation = interpolationMode;
        this.onDataUpdatedObservable.notifyObservers();
    }
    getInControlPoint(keyIndex) {
        if (keyIndex === 0) {
            return 0;
        }
        const keys = this.keys;
        let inTangent = keys[keyIndex].inTangent;
        if (inTangent === undefined && this.hasDefinedInTangent(keyIndex)) {
            inTangent = this.evaluateInTangent(keyIndex);
        }
        return inTangent;
    }
    getOutControlPoint(keyIndex) {
        const keys = this.keys;
        if (keyIndex === keys.length - 1) {
            return 0;
        }
        let outTangent = keys[keyIndex].outTangent;
        if (outTangent === undefined && this.hasDefinedOutTangent(keyIndex)) {
            outTangent = this.evaluateOutTangent(keyIndex);
        }
        return outTangent;
    }
    hasDefinedOutTangent(keyIndex) {
        const keys = this.keys;
        if (keyIndex === this.keys.length - 1) {
            return false;
        }
        const prevFrame = keys[keyIndex].frame;
        const currentFrame = keys[keyIndex + 1].frame;
        return prevFrame !== currentFrame;
    }
    evaluateOutTangent(keyIndex) {
        const keys = this.keys;
        const prevFrame = keys[keyIndex].frame;
        const currentFrame = keys[keyIndex + 1].frame;
        return (keys[keyIndex + 1].value - keys[keyIndex].value) / (currentFrame - prevFrame);
    }
    hasDefinedInTangent(keyIndex) {
        if (keyIndex === 0) {
            return false;
        }
        const keys = this.keys;
        const prevFrame = keys[keyIndex - 1].frame;
        const currentFrame = keys[keyIndex].frame;
        return prevFrame !== currentFrame;
    }
    evaluateInTangent(keyIndex) {
        const keys = this.keys;
        const prevFrame = keys[keyIndex - 1].frame;
        const currentFrame = keys[keyIndex].frame;
        return (keys[keyIndex].value - keys[keyIndex - 1].value) / (currentFrame - prevFrame);
    }
    storeDefaultInTangent(keyIndex) {
        const keys = this.keys;
        const animationKeys = this.animation.getKeys();
        if (this.hasDefinedInTangent(keyIndex)) {
            keys[keyIndex].inTangent = this.evaluateInTangent(keyIndex);
        }
        if (this.property) {
            if (!animationKeys[keyIndex].inTangent) {
                animationKeys[keyIndex].inTangent = this.tangentBuilder();
                this.setDefaultInTangent(keyIndex);
            }
            animationKeys[keyIndex].inTangent[this.property] = keys[keyIndex].inTangent;
        }
        else {
            animationKeys[keyIndex].inTangent = keys[keyIndex].inTangent;
        }
    }
    storeDefaultOutTangent(keyIndex) {
        const keys = this.keys;
        const animationKeys = this.animation.getKeys();
        if (this.hasDefinedOutTangent(keyIndex)) {
            keys[keyIndex].outTangent = this.evaluateOutTangent(keyIndex);
        }
        if (this.property) {
            if (!animationKeys[keyIndex].outTangent) {
                animationKeys[keyIndex].outTangent = this.tangentBuilder();
                this.setDefaultOutTangent(keyIndex);
            }
            animationKeys[keyIndex].outTangent[this.property] = keys[keyIndex].outTangent;
        }
        else {
            animationKeys[keyIndex].outTangent = keys[keyIndex].outTangent;
        }
    }
    updateInTangentFromControlPoint(keyId, slope) {
        const keys = this.keys;
        keys[keyId].inTangent = slope;
        const animationKeys = this.animation.getKeys();
        if (this.property) {
            if (!animationKeys[keyId].inTangent) {
                animationKeys[keyId].inTangent = this.tangentBuilder();
                this.setDefaultInTangent(keyId);
            }
            if (!animationKeys[keyId - 1].outTangent) {
                animationKeys[keyId - 1].outTangent = this.tangentBuilder();
                this.setDefaultOutTangent(keyId - 1);
            }
            animationKeys[keyId].inTangent[this.property] = keys[keyId].inTangent;
        }
        else {
            animationKeys[keyId].inTangent = keys[keyId].inTangent;
            if (animationKeys[keyId - 1].outTangent === undefined) {
                this.storeDefaultOutTangent(keyId - 1);
            }
        }
        this.onDataUpdatedObservable.notifyObservers();
    }
    updateOutTangentFromControlPoint(keyId, slope) {
        const keys = this.keys;
        keys[keyId].outTangent = slope;
        const animationKeys = this.animation.getKeys();
        if (this.property) {
            if (!animationKeys[keyId + 1].inTangent) {
                animationKeys[keyId + 1].inTangent = this.tangentBuilder();
                this.setDefaultInTangent(keyId + 1);
            }
            if (!animationKeys[keyId].outTangent) {
                animationKeys[keyId].outTangent = this.tangentBuilder();
                this.setDefaultOutTangent(keyId);
            }
            animationKeys[keyId].outTangent[this.property] = keys[keyId].outTangent;
        }
        else {
            animationKeys[keyId].outTangent = keys[keyId].outTangent;
            if (animationKeys[keyId + 1].inTangent === undefined) {
                this.storeDefaultInTangent(keyId + 1);
            }
        }
        this.onDataUpdatedObservable.notifyObservers();
    }
    updateKeyFrame(keyId, frame) {
        const originalKey = this.animation.getKeys()[keyId];
        originalKey.frame = frame;
        this.keys[keyId].frame = frame;
        this.onDataUpdatedObservable.notifyObservers();
    }
    updateKeyValue(keyId, value) {
        this.keys[keyId].value = value;
        const sourceKey = this.animation.getKeys()[keyId];
        if (this.property) {
            sourceKey.value[this.property] = value;
        }
        else {
            sourceKey.value = value;
        }
        this.onDataUpdatedObservable.notifyObservers();
    }
}
CurveData.SampleRate = 50;
CurveData.TangentLength = 50;

/**
 * Curve component that renders an animation curve path
 * @param props - The curve props
 * @returns The rendered curve SVG element
 */
const Curve = ({ curve, convertX, convertY }) => {
    const isQuaternion = curve.animation.dataType === Animation.ANIMATIONTYPE_QUATERNION;
    // Path style - same as v1
    const pathStyle = {
        stroke: curve.color,
        fill: "none",
        strokeWidth: "2",
    };
    if (isQuaternion) {
        pathStyle["strokeDasharray"] = "5";
        pathStyle["strokeOpacity"] = "0.5";
    }
    return (jsx("svg", { style: { cursor: "pointer", overflow: "auto" }, children: jsx("path", { d: curve.getPathData(convertX, convertY), style: pathStyle }) }));
};

// Inline SVG data URIs for key point icons
const KEY_INACTIVE = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 10 10'%3E%3Crect width='10' height='10' style='fill:none'/%3E%3Cpath d='M5,1.41a1,1,0,0,0-.71.3L1.71,4.29a1,1,0,0,0,0,1.41h0L4.29,8.29a1,1,0,0,0,1.41,0h0L8.29,5.71a1,1,0,0,0,0-1.41h0L5.71,1.71A1,1,0,0,0,5,1.41Z' style='fill:%23aaa'/%3E%3Cpolyline points='5 2.41 5 2.41 7.59 5 5 7.59 2.41 5 5 2.41 5 2.41' style='fill:%23111'/%3E%3C/svg%3E";
const KEY_SELECTED = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 10 10'%3E%3Crect width='10' height='10' style='fill:none'/%3E%3Crect x='2.17' y='2.17' width='5.66' height='5.66' rx='1' transform='translate(-2.07 5) rotate(-45)' style='fill:%23ffc017'/%3E%3C/svg%3E";
const KEY_ACTIVE = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 10 10'%3E%3Cpath d='M5,1.41a1,1,0,0,0-.71.3L1.71,4.29a1,1,0,0,0,0,1.41h0L4.29,8.29a1,1,0,0,0,1.41,0h0L8.29,5.71a1,1,0,0,0,0-1.41h0L5.71,1.71A1,1,0,0,0,5,1.41Z' style='fill:%23ffc017'/%3E%3Crect width='10' height='10' style='fill:none'/%3E%3Cpolyline points='5 2.41 5 2.41 7.59 5 5 7.59 2.41 5 5 2.41 5 2.41' style='fill:%23111'/%3E%3C/svg%3E";
/** Selection state for key points */
var SelectionState;
(function (SelectionState) {
    SelectionState[SelectionState["None"] = 0] = "None";
    SelectionState[SelectionState["Selected"] = 1] = "Selected";
    SelectionState[SelectionState["Siblings"] = 2] = "Siblings";
})(SelectionState || (SelectionState = {}));
/** Control mode for pointer interactions */
var ControlMode;
(function (ControlMode) {
    ControlMode[ControlMode["None"] = 0] = "None";
    ControlMode[ControlMode["Key"] = 1] = "Key";
    ControlMode[ControlMode["TangentLeft"] = 2] = "TangentLeft";
    ControlMode[ControlMode["TangentRight"] = 3] = "TangentRight";
})(ControlMode || (ControlMode = {}));
/**
 * KeyPointComponent - Renders a single key point on the curve editor
 * Handles selection, dragging, and tangent manipulation
 * @param props - The component props
 * @returns The rendered key point SVG element
 */
const KeyPointComponent = (props) => {
    const { x: initialX, y: initialY, getPreviousX, getNextX, invertX, invertY, convertX, convertY, scale, keyId, curve, channel, onFrameValueChanged, onKeyValueChanged } = props;
    const { state, actions, observables } = useCurveEditor();
    // Local state
    const [selectedState, setSelectedState] = useState(SelectionState.None);
    const [tangentSelectedIndex, setTangentSelectedIndex] = useState(-1);
    const [currentX, setCurrentX] = useState(initialX);
    const [currentY, setCurrentY] = useState(initialY);
    const [, setForceUpdate] = useState(0);
    // Refs
    const svgHostRef = useRef(null);
    const keyPointRef = useRef(null);
    const pointerIsDown = useRef(false);
    const sourcePointerX = useRef(0);
    const sourcePointerY = useRef(0);
    const controlMode = useRef(ControlMode.None);
    const lockX = useRef(false);
    const lockY = useRef(false);
    const accumulatedX = useRef(0);
    const accumulatedY = useRef(0);
    // Tangent vectors (mutable refs for performance)
    const inVec = useRef(new Vector2());
    const outVec = useRef(new Vector2());
    const storedLengthIn = useRef(0);
    const storedLengthOut = useRef(0);
    // Track current position in refs to avoid stale closure issues during drag
    const currentXRef = useRef(initialX);
    const currentYRef = useRef(initialY);
    // Update position when props change
    useEffect(() => {
        setCurrentX(initialX);
        setCurrentY(initialY);
        currentXRef.current = initialX;
        currentYRef.current = initialY;
    }, [initialX, initialY]);
    // Helper to compare curves by identity (animation + property) rather than reference
    const curvesMatch = useCallback((c1, c2) => {
        return c1.animation.uniqueId === c2.animation.uniqueId && c1.property === c2.property;
    }, []);
    // Check if this key point is selected
    const isSelected = useCallback(() => {
        return state.activeKeyPoints?.some((kp) => curvesMatch(kp.curve, curve) && kp.keyId === keyId) ?? false;
    }, [state.activeKeyPoints, curve, keyId, curvesMatch]);
    // Update selection state
    // v1 logic: "Selected" means this keypoint is in activeKeyPoints
    // "Siblings" means another keypoint with same keyId but different curve (same animation) is selected
    useEffect(() => {
        if (isSelected()) {
            // This keypoint is directly selected
            setSelectedState(SelectionState.Selected);
        }
        else if (state.activeKeyPoints) {
            // Check if a sibling (same keyId, different curve, same animation) is selected
            let isSibling = false;
            for (const activeKeyPoint of state.activeKeyPoints) {
                if (activeKeyPoint.keyId === keyId && !curvesMatch(activeKeyPoint.curve, curve) && activeKeyPoint.curve.animation.uniqueId === curve.animation.uniqueId) {
                    isSibling = true;
                    break;
                }
            }
            if (isSibling) {
                setSelectedState(SelectionState.Siblings);
            }
            else {
                setSelectedState(SelectionState.None);
                setTangentSelectedIndex(-1);
            }
        }
        else {
            setSelectedState(SelectionState.None);
            setTangentSelectedIndex(-1);
        }
    }, [state.activeKeyPoints, state.mainKeyPoint, curve, keyId, isSelected, curvesMatch]);
    // Extract slope from a tangent vector (matches v1's _extractSlope)
    const extractSlope = useCallback((vec, storedLength, isIn) => {
        const keys = curve.keys;
        const keyValue = keys[keyId].value;
        const keyFrame = keys[keyId].frame;
        // Ensure vector points in the correct direction (modifies vec directly like v1)
        if (isIn && vec.x >= 0) {
            vec.x = -0.01;
        }
        else if (!isIn && vec.x <= 0) {
            vec.x = 0.01;
        }
        // Clone AFTER direction correction (like v1)
        const currentPosition = vec.clone();
        currentPosition.normalize();
        currentPosition.scaleInPlace(storedLength);
        const value = isIn ? keyValue - invertY(currentPosition.y + currentY) : invertY(currentPosition.y + currentY) - keyValue;
        const frame = isIn ? keyFrame - invertX(currentPosition.x + currentX) : invertX(currentPosition.x + currentX) - keyFrame;
        return value / frame;
    }, [curve, keyId, invertX, invertY, currentX, currentY]);
    // Tangent operations
    const flattenTangent = useCallback(() => {
        // First update the interpolation mode to NONE without triggering observers
        const keys = curve.keys;
        const animationKeys = curve.animation.getKeys();
        keys[keyId].interpolation = 0 /* AnimationKeyInterpolation.NONE */;
        animationKeys[keyId].interpolation = 0 /* AnimationKeyInterpolation.NONE */;
        // Then update the tangents
        if (tangentSelectedIndex === -1 || tangentSelectedIndex === 0) {
            if (keyId !== 0) {
                curve.updateInTangentFromControlPoint(keyId, 0);
            }
        }
        if (tangentSelectedIndex === -1 || tangentSelectedIndex === 1) {
            if (keyId !== curve.keys.length - 1) {
                curve.updateOutTangentFromControlPoint(keyId, 0);
            }
        }
        setForceUpdate((v) => v + 1);
    }, [keyId, tangentSelectedIndex, curve]);
    const linearTangent = useCallback(() => {
        // First update the interpolation mode to NONE without triggering observers
        const keys = curve.keys;
        const animationKeys = curve.animation.getKeys();
        keys[keyId].interpolation = 0 /* AnimationKeyInterpolation.NONE */;
        animationKeys[keyId].interpolation = 0 /* AnimationKeyInterpolation.NONE */;
        // Then update the tangents
        if (tangentSelectedIndex === -1 || tangentSelectedIndex === 0) {
            if (keyId !== 0) {
                curve.storeDefaultInTangent(keyId);
            }
        }
        if (tangentSelectedIndex === -1 || tangentSelectedIndex === 1) {
            if (keyId !== curve.keys.length - 1) {
                curve.storeDefaultOutTangent(keyId);
            }
        }
        // Notify once after all changes are done
        curve.onDataUpdatedObservable.notifyObservers();
        setForceUpdate((v) => v + 1);
    }, [keyId, tangentSelectedIndex, curve]);
    const breakTangent = useCallback(() => {
        // Update interpolation without triggering intermediate observers
        const keys = curve.keys;
        const animationKeys = curve.animation.getKeys();
        keys[keyId].interpolation = 0 /* AnimationKeyInterpolation.NONE */;
        animationKeys[keyId].interpolation = 0 /* AnimationKeyInterpolation.NONE */;
        curve.updateLockedTangentMode(keyId, false);
        curve.onDataUpdatedObservable.notifyObservers();
        setForceUpdate((v) => v + 1);
    }, [keyId, curve]);
    const unifyTangent = useCallback(() => {
        // Update interpolation without triggering intermediate observers
        const keys = curve.keys;
        const animationKeys = curve.animation.getKeys();
        keys[keyId].interpolation = 0 /* AnimationKeyInterpolation.NONE */;
        animationKeys[keyId].interpolation = 0 /* AnimationKeyInterpolation.NONE */;
        curve.updateLockedTangentMode(keyId, true);
        curve.onDataUpdatedObservable.notifyObservers();
        setForceUpdate((v) => v + 1);
    }, [keyId, curve]);
    const stepTangent = useCallback(() => {
        curve.updateInterpolationMode(keyId, 1 /* AnimationKeyInterpolation.STEP */);
        setForceUpdate((v) => v + 1);
    }, [keyId, curve]);
    // Subscribe to tangent operation observables
    useEffect(() => {
        const flattenObserver = observables.onFlattenTangentRequired.add(() => {
            if (isSelected()) {
                flattenTangent();
            }
        });
        const linearObserver = observables.onLinearTangentRequired.add(() => {
            if (isSelected()) {
                linearTangent();
            }
        });
        const breakObserver = observables.onBreakTangentRequired.add(() => {
            if (isSelected()) {
                breakTangent();
            }
        });
        const unifyObserver = observables.onUnifyTangentRequired.add(() => {
            if (isSelected()) {
                unifyTangent();
            }
        });
        const stepObserver = observables.onStepTangentRequired.add(() => {
            if (isSelected()) {
                stepTangent();
            }
        });
        return () => {
            observables.onFlattenTangentRequired.remove(flattenObserver);
            observables.onLinearTangentRequired.remove(linearObserver);
            observables.onBreakTangentRequired.remove(breakObserver);
            observables.onUnifyTangentRequired.remove(unifyObserver);
            observables.onStepTangentRequired.remove(stepObserver);
        };
    }, [observables, isSelected, flattenTangent, linearTangent, breakTangent, unifyTangent, stepTangent]);
    // Handle selection rectangle
    useEffect(() => {
        const observer = observables.onSelectionRectangleMoved.add((rect1) => {
            if (!keyPointRef.current) {
                return;
            }
            const animationType = curve.animation.dataType;
            const isQuaternionAnimation = animationType === Animation.ANIMATIONTYPE_QUATERNION;
            if (isQuaternionAnimation) {
                return;
            }
            const rect2 = keyPointRef.current.getBoundingClientRect();
            const overlap = !(rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom);
            // Update activeKeyPoints based on overlap
            actions.setActiveKeyPoints((prev) => {
                const current = prev || [];
                const matchesCurve = (kp) => kp.curve.animation.uniqueId === curve.animation.uniqueId && kp.curve.property === curve.property && kp.keyId === keyId;
                const isCurrentlySelected = current.some(matchesCurve);
                if (overlap && !isCurrentlySelected) {
                    return [...current, { curve, keyId }];
                }
                else if (!overlap && isCurrentlySelected) {
                    return current.filter((kp) => !matchesCurve(kp));
                }
                return prev;
            });
        });
        return () => {
            observables.onSelectionRectangleMoved.remove(observer);
        };
    }, [observables, curve, keyId, actions]);
    // Handle select all keys
    useEffect(() => {
        const observer = observables.onSelectAllKeys.add(() => {
            actions.setActiveKeyPoints((prev) => {
                const current = prev || [];
                const matchesCurve = (kp) => kp.curve.animation.uniqueId === curve.animation.uniqueId && kp.curve.property === curve.property && kp.keyId === keyId;
                const isCurrentlySelected = current.some(matchesCurve);
                if (!isCurrentlySelected) {
                    return [...current, { curve, keyId }];
                }
                return prev;
            });
        });
        return () => {
            observables.onSelectAllKeys.remove(observer);
        };
    }, [observables, actions, curve, keyId]);
    // Mouse/pointer handlers
    const handlePointerDown = useCallback((evt) => {
        const animationType = curve.animation.dataType;
        const isQuaternionAnimation = animationType === Animation.ANIMATIONTYPE_QUATERNION;
        if (isQuaternionAnimation) {
            return;
        }
        evt.preventDefault();
        evt.stopPropagation();
        pointerIsDown.current = true;
        sourcePointerX.current = evt.nativeEvent.offsetX;
        sourcePointerY.current = evt.nativeEvent.offsetY;
        // Determine control mode based on target
        const target = evt.nativeEvent.target;
        if (target.tagName === "image") {
            controlMode.current = ControlMode.Key;
            setTangentSelectedIndex(-1);
        }
        else if (target.classList.contains("left-tangent")) {
            controlMode.current = ControlMode.TangentLeft;
            setTangentSelectedIndex(0);
        }
        else if (target.classList.contains("right-tangent")) {
            controlMode.current = ControlMode.TangentRight;
            setTangentSelectedIndex(1);
        }
        // Reset lock state
        lockX.current = false;
        lockY.current = false;
        accumulatedX.current = 0;
        accumulatedY.current = 0;
        // Handle selection
        if (!evt.ctrlKey) {
            if (!isSelected()) {
                actions.setActiveKeyPoints([{ curve, keyId }]);
            }
        }
        else {
            actions.setActiveKeyPoints((prev) => {
                const current = prev || [];
                const matchesCurve = (kp) => kp.curve.animation.uniqueId === curve.animation.uniqueId && kp.curve.property === curve.property && kp.keyId === keyId;
                const isCurrentlySelected = current.some(matchesCurve);
                if (isCurrentlySelected) {
                    return current.filter((kp) => !matchesCurve(kp));
                }
                else {
                    return [...current, { curve, keyId }];
                }
            });
        }
        observables.onActiveKeyPointChanged.notifyObservers();
        // Capture pointer for drag
        evt.target.setPointerCapture(evt.pointerId);
    }, [curve, keyId, actions, observables, isSelected]);
    const handlePointerMove = useCallback((evt) => {
        if (!pointerIsDown.current || selectedState !== SelectionState.Selected) {
            return;
        }
        const diffX = evt.nativeEvent.offsetX - sourcePointerX.current;
        const diffY = evt.nativeEvent.offsetY - sourcePointerY.current;
        if (controlMode.current === ControlMode.Key) {
            // Handle shift-lock for constrained movement
            if (evt.shiftKey) {
                if (!lockX.current && !lockY.current) {
                    accumulatedX.current += Math.abs(diffX);
                    accumulatedY.current += Math.abs(diffY);
                    if (accumulatedX.current > 5 || accumulatedY.current > 5) {
                        if (accumulatedX.current > accumulatedY.current) {
                            lockY.current = true;
                        }
                        else {
                            lockX.current = true;
                        }
                    }
                }
            }
            else {
                lockX.current = false;
                lockY.current = false;
            }
            // Calculate new position using refs to avoid stale closure
            let newX = currentXRef.current + (lockX.current ? 0 : diffX * scale);
            let newY = currentYRef.current + (lockY.current ? 0 : diffY * scale);
            // Constrain to valid frame range
            const previousX = getPreviousX();
            const nextX = getNextX();
            const epsilon = 0.01;
            if (previousX !== null) {
                newX = Math.max(previousX + epsilon, newX);
            }
            if (nextX !== null) {
                newX = Math.min(nextX - epsilon, newX);
            }
            // Check frame lock constraints
            if (keyId !== 0 && !(state.lockLastFrameFrame && keyId === curve.keys.length - 1)) {
                const frame = invertX(newX);
                onFrameValueChanged(frame);
                observables.onFrameSet.notifyObservers(frame);
            }
            else {
                newX = currentXRef.current;
            }
            // Check value lock constraints
            if (state.lockLastFrameValue && keyId === curve.keys.length - 1) {
                newY = currentYRef.current;
            }
            const value = invertY(newY);
            onKeyValueChanged(value);
            observables.onValueSet.notifyObservers(value);
            // Update both ref and state
            currentXRef.current = newX;
            currentYRef.current = newY;
            setCurrentX(newX);
            setCurrentY(newY);
        }
        else {
            // Tangent manipulation
            const keys = curve.keys;
            const isLockedTangent = keys[keyId].lockedTangent && keyId !== 0 && keyId !== keys.length - 1;
            // Calculate angle diff BEFORE modifying the tangent (like v1 does)
            let angleDiff = 0;
            if (isLockedTangent) {
                const va = inVec.current.clone().normalize();
                const vb = outVec.current.clone().normalize();
                angleDiff = Math.acos(Math.min(1.0, Math.max(-1, Vector2.Dot(va, vb))));
                // Determine direction of angle
                const tmpCheck = new Vector2();
                va.rotateToRef(-angleDiff, tmpCheck);
                if (Vector2.Distance(tmpCheck, vb) > 0.01) {
                    angleDiff = -angleDiff;
                }
            }
            if (controlMode.current === ControlMode.TangentLeft) {
                // Update the vector in place - multiply by scale to match v1 behavior
                inVec.current.x += diffX * scale;
                inVec.current.y += diffY * scale;
                const newSlope = extractSlope(inVec.current, storedLengthIn.current, true);
                curve.updateInTangentFromControlPoint(keyId, newSlope);
                if (isLockedTangent) {
                    // Rotate the moved inVec by -angleDiff to get the outVec direction
                    const tmpVector = new Vector2();
                    inVec.current.rotateToRef(-angleDiff, tmpVector);
                    tmpVector.x = Math.abs(tmpVector.x); // Ensure out tangent points right
                    const outSlope = extractSlope(tmpVector, storedLengthOut.current, false);
                    curve.updateOutTangentFromControlPoint(keyId, outSlope);
                    // Update outVec visually to match the rotated position
                    outVec.current.copyFrom(tmpVector);
                    outVec.current.normalize();
                    outVec.current.scaleInPlace(100 * scale);
                }
            }
            else if (controlMode.current === ControlMode.TangentRight) {
                // Update the vector in place - multiply by scale to match v1 behavior
                outVec.current.x += diffX * scale;
                outVec.current.y += diffY * scale;
                const newSlope = extractSlope(outVec.current, storedLengthOut.current, false);
                curve.updateOutTangentFromControlPoint(keyId, newSlope);
                if (isLockedTangent) {
                    // Rotate the moved outVec by angleDiff to get the inVec direction
                    const tmpVector = new Vector2();
                    outVec.current.rotateToRef(angleDiff, tmpVector);
                    tmpVector.x = -Math.abs(tmpVector.x); // Ensure in tangent points left
                    const inSlope = extractSlope(tmpVector, storedLengthIn.current, true);
                    curve.updateInTangentFromControlPoint(keyId, inSlope);
                    // Update inVec visually to match the rotated position
                    inVec.current.copyFrom(tmpVector);
                    inVec.current.normalize();
                    inVec.current.scaleInPlace(100 * scale);
                }
            }
            actions.refreshTarget();
            setForceUpdate((v) => v + 1);
        }
        observables.onActiveKeyDataChanged.notifyObservers(keyId);
        sourcePointerX.current = evt.nativeEvent.offsetX;
        sourcePointerY.current = evt.nativeEvent.offsetY;
    }, [
        selectedState,
        getPreviousX,
        getNextX,
        invertX,
        invertY,
        scale,
        onFrameValueChanged,
        onKeyValueChanged,
        curve,
        keyId,
        state.lockLastFrameFrame,
        state.lockLastFrameValue,
        observables,
        actions,
        extractSlope,
    ]);
    const handlePointerUp = useCallback((evt) => {
        pointerIsDown.current = false;
        controlMode.current = ControlMode.None;
        evt.target.releasePointerCapture(evt.pointerId);
        evt.stopPropagation();
    }, []);
    // Get the key data
    const keys = curve.keys;
    const key = keys[keyId];
    if (!key) {
        return null;
    }
    const animationType = curve.animation.dataType;
    const isColorAnimation = animationType === Animation.ANIMATIONTYPE_COLOR3 || animationType === Animation.ANIMATIONTYPE_COLOR4;
    const isQuaternionAnimation = animationType === Animation.ANIMATIONTYPE_QUATERNION;
    // Determine icon based on selection state
    let icon;
    switch (selectedState) {
        case SelectionState.Selected:
            icon = KEY_SELECTED;
            break;
        case SelectionState.Siblings:
            icon = KEY_ACTIVE;
            break;
        default:
            icon = KEY_INACTIVE;
            break;
    }
    // Get tangent information
    const isLockedTangent = key.lockedTangent ?? true;
    const hasStepTangentIn = keys[keyId - 1]?.interpolation ?? false;
    const hasStepTangentOut = key.interpolation ?? false;
    const hasDefinedInTangent = curve.hasDefinedInTangent(keyId);
    const hasDefinedOutTangent = curve.hasDefinedOutTangent(keyId);
    // Calculate tangent vectors from curve data (like v1's render method)
    // This recalculates on every render, including after tangent updates
    const convertedX = invertX(currentX);
    const convertedY = invertY(currentY);
    if (hasDefinedInTangent) {
        const inControlPointValue = convertedY - curve.getInControlPoint(keyId);
        inVec.current = new Vector2(convertX(convertedX - 1) - currentX, convertY(inControlPointValue) - currentY);
    }
    else {
        inVec.current = new Vector2();
    }
    if (hasDefinedOutTangent) {
        const outControlPointValue = convertedY + curve.getOutControlPoint(keyId);
        outVec.current = new Vector2(convertX(convertedX + 1) - currentX, convertY(outControlPointValue) - currentY);
    }
    else {
        outVec.current = new Vector2();
    }
    storedLengthIn.current = inVec.current.length();
    storedLengthOut.current = outVec.current.length();
    // Normalize and scale for display
    inVec.current.normalize();
    inVec.current.scaleInPlace(100 * scale);
    outVec.current.normalize();
    outVec.current.scaleInPlace(100 * scale);
    return (jsxs("svg", { ref: svgHostRef, onPointerDown: handlePointerDown, onPointerMove: handlePointerMove, onPointerUp: handlePointerUp, x: currentX, y: currentY, style: { cursor: isQuaternionAnimation ? "auto" : "pointer", overflow: "auto", opacity: isQuaternionAnimation ? "25%" : "100%" }, children: [jsx("image", { ref: keyPointRef, x: `-${8 * scale}`, y: `-${8 * scale}`, width: `${16 * scale}`, height: `${16 * scale}`, href: icon }), selectedState === SelectionState.Selected && (jsxs("g", { children: [keyId !== 0 && !hasStepTangentIn && !isColorAnimation && !isQuaternionAnimation && hasDefinedInTangent && (jsxs(Fragment, { children: [jsx("line", { x1: 0, y1: 0, x2: `${inVec.current.x}px`, y2: `${inVec.current.y}px`, style: {
                                    stroke: tangentSelectedIndex === 0 || tangentSelectedIndex === -1 ? "#F9BF00" : "#AAAAAA",
                                    strokeWidth: `${1 * scale}`,
                                    strokeDasharray: isLockedTangent ? "" : "2, 2",
                                } }), jsx("circle", { className: "left-tangent", cx: `${inVec.current.x}px`, cy: `${inVec.current.y}px`, r: `${4 * scale}`, style: {
                                    fill: tangentSelectedIndex === 0 || tangentSelectedIndex === -1 ? "#F9BF00" : "#AAAAAA",
                                } })] })), keyId !== keys.length - 1 && !hasStepTangentOut && !isColorAnimation && !isQuaternionAnimation && hasDefinedOutTangent && (jsxs(Fragment, { children: [jsx("line", { x1: 0, y1: 0, x2: `${outVec.current.x}px`, y2: `${outVec.current.y}px`, style: {
                                    stroke: tangentSelectedIndex === 1 || tangentSelectedIndex === -1 ? "#F9BF00" : "#AAAAAA",
                                    strokeWidth: `${1 * scale}`,
                                    strokeDasharray: isLockedTangent ? "" : "2, 2",
                                } }), jsx("circle", { className: "right-tangent", cx: `${outVec.current.x}px`, cy: `${outVec.current.y}px`, r: `${4 * scale}`, style: {
                                    fill: tangentSelectedIndex === 1 || tangentSelectedIndex === -1 ? "#F9BF00" : "#AAAAAA",
                                } })] }))] }))] }));
};

const useStyles$t = makeStyles({
    root: {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        overflow: "hidden",
        backgroundColor: tokens.colorNeutralBackground2,
    },
    svg: {
        position: "absolute",
        top: 0,
        left: 0,
    },
    gridLine: {
        stroke: tokens.colorNeutralStroke2,
        strokeWidth: "1px",
        strokeDasharray: "4 4",
    },
    zeroLine: {
        stroke: tokens.colorNeutralStroke1,
        strokeWidth: "1px",
    },
    selectionRect: {
        fill: "rgba(255, 255, 255, 0.1)",
        stroke: tokens.colorNeutralForeground1,
        strokeWidth: "1px",
        strokeDasharray: "4 4",
    },
    valueAxisLabel: {
        fill: tokens.colorNeutralForeground3,
        fontSize: "10px",
        fontFamily: "acumin-pro-condensed, sans-serif",
        userSelect: "none",
    },
    valueAxisBackground: {
        fill: tokens.colorNeutralBackground1,
    },
    activeRangeOverlay: {
        position: "absolute",
        top: 0,
        height: "100%",
        backgroundColor: tokens.colorBrandBackground2,
        opacity: 0.3,
        pointerEvents: "none",
    },
    inactiveRangeOverlay: {
        position: "absolute",
        top: 0,
        height: "100%",
        backgroundColor: tokens.colorNeutralBackgroundStatic,
        opacity: 0.6,
        pointerEvents: "none",
    },
});
/**
 * Main graph area for displaying and editing animation curves
 * @returns The graph component
 */
const Graph = ({ width, height }) => {
    const styles = useStyles$t();
    const { state, actions, observables } = useCurveEditor();
    const svgRef = useRef(null);
    const [scale, setScale] = useState(1);
    const [offsetX, setOffsetX] = useState(0);
    const [offsetY, setOffsetY] = useState(0);
    const [isPointerDown, setIsPointerDown] = useState(false);
    const [pointerStart, setPointerStart] = useState({ x: 0, y: 0 });
    // Re-render when active animation or range changes
    // useCallback stabilizes the accessor to prevent infinite re-render loops
    useObservableState(useCallback(() => ({}), []), observables.onActiveAnimationChanged, observables.onRangeUpdated);
    // Ensure dimensions are valid
    const safeWidth = Math.max(1, width);
    const safeHeight = Math.max(1, height);
    const graphOffsetX = 30;
    const viewWidth = safeWidth - graphOffsetX;
    // Subscribe to action observables
    useEffect(() => {
        // Handle create or update key point
        const onCreateOrUpdateKeyPointRequired = observables.onCreateOrUpdateKeyPointRequired.add(() => {
            if (state.activeAnimations.length === 0) {
                return;
            }
            for (const currentAnimation of state.activeAnimations) {
                if (currentAnimation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {
                    continue;
                }
                const keys = currentAnimation.getKeys();
                const currentFrame = state.activeFrame;
                // Find where to insert the new key
                let indexToAdd = -1;
                for (const key of keys) {
                    if (key.frame < currentFrame) {
                        indexToAdd++;
                    }
                    else {
                        break;
                    }
                }
                // Get the value at the current frame
                const value = currentAnimation.evaluate(currentFrame);
                const leftKey = keys[indexToAdd];
                const rightKey = keys[indexToAdd + 1];
                if (leftKey && Math.floor(currentFrame - leftKey.frame) === 0) {
                    // Key already exists at this frame, update it
                    leftKey.value = value;
                }
                else if (rightKey && Math.floor(rightKey.frame - currentFrame) === 0) {
                    // Key already exists at this frame, update it
                    rightKey.value = value;
                }
                else {
                    // Create new key
                    const newKey = {
                        frame: currentFrame,
                        value: value,
                        lockedTangent: true,
                    };
                    keys.splice(indexToAdd + 1, 0, newKey);
                }
                currentAnimation.setKeys(keys);
            }
            // Clear selection and refresh
            actions.setActiveKeyPoints([]);
            observables.onActiveKeyPointChanged.notifyObservers();
            observables.onActiveAnimationChanged.notifyObservers({});
        });
        // Handle frame canvas - reset view to fit all content
        const onFrameRequired = observables.onFrameRequired.add(() => {
            setScale(1);
            setOffsetX(0);
            setOffsetY(0);
        });
        // Handle delete active key points
        const onDeleteKeyActiveKeyPoints = observables.onDeleteKeyActiveKeyPoints.add(() => {
            if (!state.activeKeyPoints || state.activeKeyPoints.length === 0) {
                return;
            }
            // Group key points by animation
            const keysByAnimation = new Map();
            for (const keyPoint of state.activeKeyPoints) {
                const animation = keyPoint.curve.animation;
                if (!keysByAnimation.has(animation)) {
                    keysByAnimation.set(animation, new Set());
                }
                keysByAnimation.get(animation).add(keyPoint.keyId);
            }
            // Delete keys from each animation (in reverse order to maintain indices)
            for (const [animation, keyIndices] of keysByAnimation) {
                const keys = animation.getKeys();
                const sortedIndices = Array.from(keyIndices).sort((a, b) => b - a); // Sort descending
                for (const index of sortedIndices) {
                    if (index >= 0 && index < keys.length) {
                        keys.splice(index, 1);
                    }
                }
                animation.setKeys(keys);
            }
            // Clear selection and refresh
            actions.setActiveKeyPoints([]);
            observables.onActiveKeyPointChanged.notifyObservers();
            observables.onActiveAnimationChanged.notifyObservers({});
        });
        // Note: Tangent operations (flatten, linear, break, unify, step) are handled by KeyPointComponent
        // Each selected keypoint subscribes to the observables and handles its own tangent updates (like v1)
        return () => {
            observables.onCreateOrUpdateKeyPointRequired.remove(onCreateOrUpdateKeyPointRequired);
            observables.onFrameRequired.remove(onFrameRequired);
            observables.onDeleteKeyActiveKeyPoints.remove(onDeleteKeyActiveKeyPoints);
        };
    }, [observables, state.activeAnimations, state.activeFrame, state.activeKeyPoints, actions]);
    const curves = useMemo(() => {
        const result = [];
        // Helper to set default tangents across all curves (like v1)
        const setDefaultInTangent = (keyId) => {
            for (const curve of result) {
                curve.storeDefaultInTangent(keyId);
            }
        };
        const setDefaultOutTangent = (keyId) => {
            for (const curve of result) {
                curve.storeDefaultOutTangent(keyId);
            }
        };
        for (const animation of state.activeAnimations) {
            const keys = animation.getKeys();
            if (keys.length === 0) {
                continue;
            }
            const channelColor = state.activeChannels[animation.uniqueId];
            const curvesToAdd = [];
            // Create curves based on data type (like v1's _evaluateKeys)
            switch (animation.dataType) {
                case Animation.ANIMATIONTYPE_FLOAT:
                    curvesToAdd.push(new CurveData(channelColor || DefaultCurveColor, animation));
                    break;
                case Animation.ANIMATIONTYPE_VECTOR2:
                    if (!channelColor || channelColor === ChannelColors.X) {
                        curvesToAdd.push(new CurveData(ChannelColors.X, animation, "x", () => Vector2.Zero(), setDefaultInTangent, setDefaultOutTangent));
                    }
                    if (!channelColor || channelColor === ChannelColors.Y) {
                        curvesToAdd.push(new CurveData(ChannelColors.Y, animation, "y", () => Vector2.Zero(), setDefaultInTangent, setDefaultOutTangent));
                    }
                    break;
                case Animation.ANIMATIONTYPE_VECTOR3:
                    if (!channelColor || channelColor === ChannelColors.X) {
                        curvesToAdd.push(new CurveData(ChannelColors.X, animation, "x", () => Vector3.Zero(), setDefaultInTangent, setDefaultOutTangent));
                    }
                    if (!channelColor || channelColor === ChannelColors.Y) {
                        curvesToAdd.push(new CurveData(ChannelColors.Y, animation, "y", () => Vector3.Zero(), setDefaultInTangent, setDefaultOutTangent));
                    }
                    if (!channelColor || channelColor === ChannelColors.Z) {
                        curvesToAdd.push(new CurveData(ChannelColors.Z, animation, "z", () => Vector3.Zero(), setDefaultInTangent, setDefaultOutTangent));
                    }
                    break;
                case Animation.ANIMATIONTYPE_COLOR3:
                    if (!channelColor || channelColor === ColorChannelColors.R) {
                        curvesToAdd.push(new CurveData(ColorChannelColors.R, animation, "r", () => Color3.Black(), setDefaultInTangent, setDefaultOutTangent));
                    }
                    if (!channelColor || channelColor === ColorChannelColors.G) {
                        curvesToAdd.push(new CurveData(ColorChannelColors.G, animation, "g", () => Color3.Black(), setDefaultInTangent, setDefaultOutTangent));
                    }
                    if (!channelColor || channelColor === ColorChannelColors.B) {
                        curvesToAdd.push(new CurveData(ColorChannelColors.B, animation, "b", () => Color3.Black(), setDefaultInTangent, setDefaultOutTangent));
                    }
                    break;
                case Animation.ANIMATIONTYPE_COLOR4:
                    if (!channelColor || channelColor === ColorChannelColors.R) {
                        curvesToAdd.push(new CurveData(ColorChannelColors.R, animation, "r", () => new Color4(), setDefaultInTangent, setDefaultOutTangent));
                    }
                    if (!channelColor || channelColor === ColorChannelColors.G) {
                        curvesToAdd.push(new CurveData(ColorChannelColors.G, animation, "g", () => new Color4(), setDefaultInTangent, setDefaultOutTangent));
                    }
                    if (!channelColor || channelColor === ColorChannelColors.B) {
                        curvesToAdd.push(new CurveData(ColorChannelColors.B, animation, "b", () => new Color4(), setDefaultInTangent, setDefaultOutTangent));
                    }
                    if (!channelColor || channelColor === ColorChannelColors.A) {
                        curvesToAdd.push(new CurveData(ColorChannelColors.A, animation, "a", () => new Color4(), setDefaultInTangent, setDefaultOutTangent));
                    }
                    break;
                case Animation.ANIMATIONTYPE_QUATERNION:
                    if (!channelColor || channelColor === ChannelColors.X) {
                        curvesToAdd.push(new CurveData(ChannelColors.X, animation, "x", () => new Quaternion(), setDefaultInTangent, setDefaultOutTangent));
                    }
                    if (!channelColor || channelColor === ChannelColors.Y) {
                        curvesToAdd.push(new CurveData(ChannelColors.Y, animation, "y", () => new Quaternion(), setDefaultInTangent, setDefaultOutTangent));
                    }
                    if (!channelColor || channelColor === ChannelColors.Z) {
                        curvesToAdd.push(new CurveData(ChannelColors.Z, animation, "z", () => new Quaternion(), setDefaultInTangent, setDefaultOutTangent));
                    }
                    if (!channelColor || channelColor === ChannelColors.W) {
                        curvesToAdd.push(new CurveData(ChannelColors.W, animation, "w", () => new Quaternion(), setDefaultInTangent, setDefaultOutTangent));
                    }
                    break;
            }
            // Populate keys for each curve (like v1's _extractValuesFromKeys)
            for (const key of keys) {
                const lockedTangent = key.lockedTangent ?? true;
                for (const curve of curvesToAdd) {
                    const prop = curve.property;
                    const value = prop ? key.value[prop] : key.value;
                    const inTangent = prop ? key.inTangent?.[prop] : key.inTangent;
                    const outTangent = prop ? key.outTangent?.[prop] : key.outTangent;
                    curve.keys.push({
                        frame: key.frame,
                        value,
                        inTangent,
                        outTangent,
                        lockedTangent,
                        interpolation: key.interpolation,
                    });
                }
            }
            result.push(...curvesToAdd);
        }
        return result;
    }, [state.activeAnimations, state.activeChannels]);
    // Calculate value range
    const valueRange = useMemo(() => {
        let minValue = 0;
        let maxValue = 1;
        for (const curve of curves) {
            for (const key of curve.keys) {
                if (key.value < minValue) {
                    minValue = key.value;
                }
                if (key.value > maxValue) {
                    maxValue = key.value;
                }
            }
        }
        // Add padding
        const padding = (maxValue - minValue) * 0.1 || 1;
        return { min: minValue - padding, max: maxValue + padding };
    }, [curves]);
    // Convert frame to x position (uses reference frames for full visible range)
    const frameToX = useCallback((frame) => {
        const { referenceMinFrame, referenceMaxFrame } = state;
        const range = referenceMaxFrame - referenceMinFrame;
        if (range <= 0) {
            return graphOffsetX;
        }
        return graphOffsetX + ((frame - referenceMinFrame) / range) * viewWidth * scale + offsetX;
    }, [state, viewWidth, scale, offsetX]);
    // Convert value to y position
    const valueToY = useCallback((value) => {
        const range = valueRange.max - valueRange.min;
        if (range <= 0) {
            return safeHeight / 2;
        }
        return safeHeight - ((value - valueRange.min) / range) * safeHeight * scale + offsetY;
    }, [valueRange, safeHeight, scale, offsetY]);
    // Convert x position to frame (uses reference frames for full visible range)
    const xToFrame = useCallback((x) => {
        const { referenceMinFrame, referenceMaxFrame } = state;
        const range = referenceMaxFrame - referenceMinFrame;
        if (range <= 0) {
            return referenceMinFrame;
        }
        return referenceMinFrame + ((x - graphOffsetX - offsetX) / (viewWidth * scale)) * range;
    }, [state, viewWidth, scale, offsetX]);
    // Convert y position to value
    const yToValue = useCallback((y) => {
        const range = valueRange.max - valueRange.min;
        if (range <= 0) {
            return valueRange.min;
        }
        return valueRange.min + ((safeHeight - y + offsetY) / (safeHeight * scale)) * range;
    }, [valueRange, safeHeight, scale, offsetY]);
    // Note: Key frame/value changes are now handled directly via curve.updateKeyFrame/updateKeyValue
    // in the KeyPoint component
    // Handle pointer events for panning
    const handlePointerDown = useCallback((e) => {
        if (e.button === 1 || (e.button === 0 && e.altKey)) {
            // Middle click or Alt+left click for panning
            setIsPointerDown(true);
            setPointerStart({ x: e.clientX, y: e.clientY });
            e.currentTarget.setPointerCapture(e.pointerId);
        }
    }, []);
    const handlePointerMove = useCallback((e) => {
        if (!isPointerDown) {
            return;
        }
        const dx = e.clientX - pointerStart.x;
        const dy = e.clientY - pointerStart.y;
        setOffsetX((prev) => prev + dx);
        setOffsetY((prev) => prev + dy);
        setPointerStart({ x: e.clientX, y: e.clientY });
        observables.onGraphMoved.notifyObservers(offsetX + dx);
    }, [isPointerDown, pointerStart, offsetX, observables]);
    const handlePointerUp = useCallback((e) => {
        setIsPointerDown(false);
        e.currentTarget.releasePointerCapture(e.pointerId);
    }, []);
    // Handle wheel for zooming
    const handleWheel = useCallback((e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        const newScale = Math.max(0.5, Math.min(5, scale * delta));
        setScale(newScale);
        observables.onGraphScaled.notifyObservers(newScale);
    }, [scale, observables]);
    // Calculate nice step size for grid lines
    const calculateNiceStep = useCallback((range, targetLines) => {
        const roughStep = range / targetLines;
        const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
        const residual = roughStep / magnitude;
        let niceStep;
        if (residual <= 1.5) {
            niceStep = magnitude;
        }
        else if (residual <= 3) {
            niceStep = 2 * magnitude;
        }
        else if (residual <= 7) {
            niceStep = 5 * magnitude;
        }
        else {
            niceStep = 10 * magnitude;
        }
        return niceStep;
    }, []);
    // Render grid lines
    const renderGrid = useCallback(() => {
        const lines = [];
        const range = valueRange.max - valueRange.min;
        // Calculate nice step for horizontal grid lines
        const valueStep = calculateNiceStep(range, 5);
        // Find the first nice value above min
        const startValue = Math.ceil(valueRange.min / valueStep) * valueStep;
        // Draw horizontal grid lines at nice values
        for (let value = startValue; value <= valueRange.max; value += valueStep) {
            const y = valueToY(value);
            const isZero = Math.abs(value) < valueStep * 0.001;
            lines.push(jsx("line", { className: isZero ? styles.zeroLine : styles.gridLine, x1: graphOffsetX, y1: y, x2: width, y2: y }, `h-${value}`));
        }
        // Always draw zero line if in range (in case it wasn't hit by the loop)
        if (valueRange.min < 0 && valueRange.max > 0) {
            const zeroInLoop = Math.abs(startValue % valueStep) < valueStep * 0.001 || Math.abs((startValue - valueStep) % valueStep) < valueStep * 0.001;
            if (!zeroInLoop) {
                const y = valueToY(0);
                lines.push(jsx("line", { className: styles.zeroLine, x1: graphOffsetX, y1: y, x2: safeWidth, y2: y }, "zero"));
            }
        }
        // Vertical grid lines (frame) - use reference frames for full range
        const { referenceMinFrame, referenceMaxFrame } = state;
        const frameRange = referenceMaxFrame - referenceMinFrame;
        const frameStep = calculateNiceStep(frameRange, 10);
        const startFrame = Math.ceil(referenceMinFrame / frameStep) * frameStep;
        for (let frame = startFrame; frame <= referenceMaxFrame; frame += frameStep) {
            const x = frameToX(frame);
            lines.push(jsx("line", { className: styles.gridLine, x1: x, y1: 0, x2: x, y2: safeHeight }, `v-${frame}`));
        }
        return lines;
    }, [valueRange, frameToX, valueToY, state, safeWidth, safeHeight, styles, calculateNiceStep]);
    // Render value axis labels
    const renderValueAxis = useCallback(() => {
        const elements = [];
        // Background for value axis
        elements.push(jsx("rect", { className: styles.valueAxisBackground, x: 0, y: 0, width: graphOffsetX, height: safeHeight }, "axis-bg"));
        // Value labels at nice step values (matching grid)
        const range = valueRange.max - valueRange.min;
        const valueStep = calculateNiceStep(range, 5);
        const startValue = Math.ceil(valueRange.min / valueStep) * valueStep;
        for (let value = startValue; value <= valueRange.max; value += valueStep) {
            const y = valueToY(value);
            // Format the value nicely
            let displayValue;
            if (Math.abs(value) < 0.0001 && value !== 0) {
                displayValue = value.toExponential(1);
            }
            else if (Math.abs(value) < 1) {
                displayValue = value.toFixed(Math.max(0, -Math.floor(Math.log10(valueStep))));
            }
            else {
                displayValue = value.toFixed(Math.min(2, Math.max(0, -Math.floor(Math.log10(valueStep)))));
            }
            elements.push(jsx("text", { className: styles.valueAxisLabel, x: graphOffsetX - 4, y: y, textAnchor: "end", dominantBaseline: "middle", children: displayValue }, `label-${value}`));
        }
        return elements;
    }, [valueRange, valueToY, safeHeight, styles, calculateNiceStep]);
    // Calculate active range overlay position
    const activeRangeLeft = frameToX(state.fromKey);
    const activeRangeRight = frameToX(state.toKey);
    const activeRangeWidth = activeRangeRight - activeRangeLeft;
    // Calculate inactive (outside range) overlay positions
    const leftInactiveWidth = Math.max(0, activeRangeLeft - graphOffsetX);
    const rightInactiveLeft = Math.min(activeRangeRight, safeWidth);
    const rightInactiveWidth = Math.max(0, safeWidth - rightInactiveLeft);
    return (jsxs("div", { className: styles.root, children: [state.activeAnimations.length > 0 && leftInactiveWidth > 0 && (jsx("div", { className: styles.inactiveRangeOverlay, style: {
                    left: graphOffsetX,
                    width: leftInactiveWidth,
                } })), state.activeAnimations.length > 0 && rightInactiveWidth > 0 && (jsx("div", { className: styles.inactiveRangeOverlay, style: {
                    left: rightInactiveLeft,
                    width: rightInactiveWidth,
                } })), state.activeAnimations.length > 0 && activeRangeWidth > 0 && (jsx("div", { className: styles.activeRangeOverlay, style: {
                    left: Math.max(graphOffsetX, activeRangeLeft),
                    width: Math.min(activeRangeWidth, safeWidth - Math.max(graphOffsetX, activeRangeLeft)),
                } })), jsxs("svg", { ref: svgRef, className: styles.svg, width: safeWidth, height: safeHeight, onPointerDown: handlePointerDown, onPointerMove: handlePointerMove, onPointerUp: handlePointerUp, onWheel: handleWheel, children: [renderGrid(), curves.map((curve) => {
                        const curveId = `${curve.animation.uniqueId}-${curve.property || "value"}`;
                        return jsx(Curve, { curve: curve, convertX: frameToX, convertY: valueToY }, curveId);
                    }), curves.map((curve) => {
                        const curveId = `${curve.animation.uniqueId}-${curve.property || "value"}`;
                        return curve.keys.map((key, keyIndex) => {
                            const x = frameToX(key.frame);
                            const y = valueToY(key.value);
                            if (!Number.isFinite(x) || !Number.isFinite(y)) {
                                return null;
                            }
                            return (jsx(KeyPointComponent, { x: x, y: y, getPreviousX: () => (keyIndex > 0 ? frameToX(curve.keys[keyIndex - 1].frame) : null), getNextX: () => (keyIndex < curve.keys.length - 1 ? frameToX(curve.keys[keyIndex + 1].frame) : null), invertX: xToFrame, invertY: yToValue, convertX: frameToX, convertY: valueToY, scale: scale, keyId: keyIndex, curve: curve, channel: curve.color, onFrameValueChanged: (frame) => {
                                    curve.updateKeyFrame(keyIndex, frame);
                                    actions.refreshTarget();
                                }, onKeyValueChanged: (value) => {
                                    curve.updateKeyValue(keyIndex, value);
                                    actions.refreshTarget();
                                } }, `${curveId}-key-${keyIndex}`));
                        });
                    }), renderValueAxis()] })] }));
};

const useStyles$s = makeStyles({
    root: {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        pointerEvents: "none",
    },
    line: {
        position: "absolute",
        width: "2px",
        height: "100%",
        backgroundColor: tokens.colorBrandForeground1,
        pointerEvents: "auto",
        cursor: "ew-resize",
    },
    handle: {
        position: "absolute",
        top: 0,
        width: "20px",
        height: "20px",
        backgroundColor: tokens.colorBrandBackground,
        borderRadius: "50%",
        border: `2px solid ${tokens.colorNeutralBackground1}`,
        pointerEvents: "auto",
        cursor: "pointer",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        color: tokens.colorNeutralForegroundOnBrand,
        fontSize: "9px",
        fontWeight: "bold",
        userSelect: "none",
        transform: "translateX(-50%)",
    },
});
/**
 * Playhead component showing current frame position
 * Uses direct DOM manipulation (like v1) to avoid render cycle flashing during animation
 * @returns The playhead component
 */
const PlayHead = ({ width, height: _height }) => {
    const styles = useStyles$s();
    const { state, actions, observables } = useCurveEditor();
    const [isDragging, setIsDragging] = useState(false);
    // Use refs for all mutable values to avoid render cycles
    const scaleRef = useRef(1);
    const offsetXRef = useRef(0);
    const currentFrameRef = useRef(state.activeFrame);
    const animationFrameRef = useRef(null);
    const isPlayingRef = useRef(state.isPlaying);
    // Cache state values that we need for calculations
    const referenceMinFrameRef = useRef(state.referenceMinFrame);
    const referenceMaxFrameRef = useRef(state.referenceMaxFrame);
    const fromKeyRef = useRef(state.fromKey);
    const toKeyRef = useRef(state.toKey);
    const activeAnimationsRef = useRef(state.activeAnimations);
    // DOM refs for direct manipulation (avoids flash during playback)
    const lineRef = useRef(null);
    const handleRef = useRef(null);
    const graphOffsetX = 30;
    const viewWidth = width - graphOffsetX;
    // Update cached refs when state changes (but don't trigger re-renders for playhead position)
    useEffect(() => {
        referenceMinFrameRef.current = state.referenceMinFrame;
        referenceMaxFrameRef.current = state.referenceMaxFrame;
        fromKeyRef.current = state.fromKey;
        toKeyRef.current = state.toKey;
        activeAnimationsRef.current = state.activeAnimations;
    }, [state.referenceMinFrame, state.referenceMaxFrame, state.fromKey, state.toKey, state.activeAnimations]);
    // Calculate and apply playhead position directly to DOM
    const moveHead = useCallback((frame) => {
        if (!lineRef.current || !handleRef.current) {
            return;
        }
        const range = referenceMaxFrameRef.current - referenceMinFrameRef.current;
        if (range <= 0) {
            return;
        }
        const x = graphOffsetX + ((frame - referenceMinFrameRef.current) / range) * viewWidth * scaleRef.current + offsetXRef.current;
        // Hide if out of view
        if (x < graphOffsetX || x > width) {
            lineRef.current.style.display = "none";
            handleRef.current.style.display = "none";
        }
        else {
            lineRef.current.style.display = "";
            handleRef.current.style.display = "";
            lineRef.current.style.left = `${x}px`;
            handleRef.current.style.left = `${x}px`;
            handleRef.current.textContent = Math.round(frame).toString();
        }
        currentFrameRef.current = frame;
    }, [viewWidth, width]);
    // Subscribe to all observables in a single effect
    useEffect(() => {
        const onMoved = observables.onGraphMoved.add((newOffset) => {
            offsetXRef.current = newOffset;
            moveHead(currentFrameRef.current);
        });
        const onScaled = observables.onGraphScaled.add((newScale) => {
            scaleRef.current = newScale;
            moveHead(currentFrameRef.current);
        });
        const onPlayheadMoved = observables.onPlayheadMoved.add((frame) => {
            // Skip during playback - we update ourselves via requestAnimationFrame
            if (!isPlayingRef.current) {
                moveHead(frame);
            }
        });
        const onMoveToFrame = observables.onMoveToFrameRequired.add((frame) => {
            moveHead(frame);
        });
        // Initial position
        moveHead(currentFrameRef.current);
        return () => {
            observables.onGraphMoved.remove(onMoved);
            observables.onGraphScaled.remove(onScaled);
            observables.onPlayheadMoved.remove(onPlayheadMoved);
            observables.onMoveToFrameRequired.remove(onMoveToFrame);
        };
    }, [observables, moveHead]);
    // Track animation playback using requestAnimationFrame - separate from render cycle
    useEffect(() => {
        isPlayingRef.current = state.isPlaying;
        const trackAnimation = () => {
            if (!isPlayingRef.current) {
                return;
            }
            const animations = activeAnimationsRef.current;
            if (animations.length > 0) {
                const animation = animations[0];
                if (animation && animation.runtimeAnimations && animation.runtimeAnimations.length > 0) {
                    const runtimeAnimation = animation.runtimeAnimations[0];
                    if (runtimeAnimation && runtimeAnimation.currentFrame !== undefined) {
                        const frame = runtimeAnimation.currentFrame;
                        moveHead(frame);
                        // Notify other components (like RangeFrameBar) about the playhead position
                        observables.onPlayheadMoved.notifyObservers(frame);
                    }
                }
            }
            animationFrameRef.current = requestAnimationFrame(trackAnimation);
        };
        if (state.isPlaying) {
            animationFrameRef.current = requestAnimationFrame(trackAnimation);
        }
        else {
            // When playback stops, sync the context's activeFrame
            if (animationFrameRef.current !== null) {
                cancelAnimationFrame(animationFrameRef.current);
                animationFrameRef.current = null;
            }
            // Only update if the frame actually changed
            if (currentFrameRef.current !== state.activeFrame) {
                actions.setActiveFrame(currentFrameRef.current);
            }
        }
        return () => {
            if (animationFrameRef.current !== null) {
                cancelAnimationFrame(animationFrameRef.current);
                animationFrameRef.current = null;
            }
        };
    }, [state.isPlaying, actions, moveHead, state.activeFrame]);
    // Convert x to frame
    const xToFrame = useCallback((x) => {
        const range = referenceMaxFrameRef.current - referenceMinFrameRef.current;
        const frame = referenceMinFrameRef.current + ((x - graphOffsetX - offsetXRef.current) / (viewWidth * scaleRef.current)) * range;
        // Clamp to the active playback range
        return Math.max(fromKeyRef.current, Math.min(toKeyRef.current, Math.round(frame)));
    }, [viewWidth]);
    const handlePointerDown = useCallback((e) => {
        setIsDragging(true);
        e.currentTarget.setPointerCapture(e.pointerId);
    }, []);
    const handlePointerMove = useCallback((e) => {
        if (!isDragging) {
            return;
        }
        const rect = e.currentTarget.parentElement.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const frame = xToFrame(x);
        moveHead(frame);
        actions.moveToFrame(frame);
    }, [isDragging, xToFrame, actions, moveHead]);
    const handlePointerUp = useCallback((e) => {
        setIsDragging(false);
        e.currentTarget.releasePointerCapture(e.pointerId);
    }, []);
    return (jsxs("div", { className: styles.root, children: [jsx("div", { ref: lineRef, className: styles.line, onPointerDown: handlePointerDown, onPointerMove: handlePointerMove, onPointerUp: handlePointerUp }), jsx("div", { ref: handleRef, className: styles.handle, onPointerDown: handlePointerDown, onPointerMove: handlePointerMove, onPointerUp: handlePointerUp })] }));
};

const useStyles$r = makeStyles({
    root: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        height: "30px",
        backgroundColor: tokens.colorNeutralBackground3,
        borderBottom: `1px solid ${tokens.colorNeutralStroke1}`,
        userSelect: "none",
        overflow: "hidden",
        position: "relative",
    },
    tick: {
        position: "absolute",
        height: "8px",
        width: "1px",
        backgroundColor: tokens.colorNeutralStroke1,
        bottom: 0,
    },
    label: {
        position: "absolute",
        fontSize: tokens.fontSizeBase100,
        color: tokens.colorNeutralForeground3,
        bottom: "10px",
    },
});
/**
 * Frame bar showing frame numbers along the top of the graph
 * @param props - The component props
 * @returns The frame bar component
 */
const FrameBar = ({ width }) => {
    const styles = useStyles$r();
    const { state, observables } = useCurveEditor();
    const containerRef = useRef(null);
    const [scale, setScale] = useState(1);
    const [offsetX, setOffsetX] = useState(0);
    const graphOffsetX = 30;
    const viewWidth = width - graphOffsetX;
    // Subscribe to graph moved/scaled events
    useEffect(() => {
        const onMoved = observables.onGraphMoved.add((newOffset) => {
            setOffsetX(newOffset);
        });
        const onScaled = observables.onGraphScaled.add((newScale) => {
            setScale(newScale);
        });
        return () => {
            observables.onGraphMoved.remove(onMoved);
            observables.onGraphScaled.remove(onScaled);
        };
    }, [observables]);
    // Generate tick marks - use reference frames for full visible range
    const renderTicks = useCallback(() => {
        const ticks = [];
        const { referenceMinFrame, referenceMaxFrame } = state;
        const range = referenceMaxFrame - referenceMinFrame;
        if (range <= 0 || viewWidth <= 0) {
            return ticks;
        }
        // Determine tick spacing based on zoom level
        let tickSpacing = 10;
        if (range > 500) {
            tickSpacing = 100;
        }
        else if (range > 200) {
            tickSpacing = 50;
        }
        else if (range > 100) {
            tickSpacing = 20;
        }
        else if (range > 50) {
            tickSpacing = 10;
        }
        else {
            tickSpacing = 5;
        }
        const startFrame = Math.floor(referenceMinFrame / tickSpacing) * tickSpacing;
        const endFrame = Math.ceil(referenceMaxFrame / tickSpacing) * tickSpacing;
        for (let frame = startFrame; frame <= endFrame; frame += tickSpacing) {
            const x = graphOffsetX + ((frame - referenceMinFrame) / range) * viewWidth * scale + offsetX;
            if (x >= graphOffsetX && x <= width) {
                ticks.push(jsx("div", { className: styles.tick, style: { left: x } }, `tick-${frame}`), jsx("div", { className: styles.label, style: { left: x - 10 }, children: frame }, `label-${frame}`));
            }
        }
        return ticks;
    }, [state.referenceMinFrame, state.referenceMaxFrame, viewWidth, width, scale, offsetX, styles]);
    return (jsx("div", { className: styles.root, ref: containerRef, children: renderTicks() }));
};

const useStyles$q = makeStyles({
    root: {
        display: "flex",
        flexDirection: "column",
        height: "100%",
        backgroundColor: tokens.colorNeutralBackground2,
        overflow: "hidden",
        userSelect: "none",
        pointerEvents: "none",
    },
    svg: {
        width: "100%",
        height: "100%",
    },
    tickLabel: {
        fill: tokens.colorNeutralForeground3,
        fontSize: "12px",
        fontFamily: "acumin-pro-condensed, sans-serif",
        textAnchor: "middle",
    },
    tickLine: {
        stroke: tokens.colorNeutralStroke2,
        strokeWidth: "0.5px",
    },
    keyframeLine: {
        stroke: "#ffc017",
        strokeWidth: "0.5px",
    },
    activeFrameLine: {
        stroke: tokens.colorBrandForeground1,
        strokeWidth: "1px",
    },
});
const TICK_DISTANCE = 25;
const OFFSET_X = 10;
/**
 * Range frame bar showing frame tick marks and keyframe indicators
 * @returns The range frame bar component
 */
const RangeFrameBar = ({ width }) => {
    const styles = useStyles$q();
    const { state, observables } = useCurveEditor();
    const svgRef = useRef(null);
    const [viewWidth, setViewWidth] = useState(width);
    const [displayFrame, setDisplayFrame] = useState(state.activeFrame);
    // Re-render when range updates
    // useCallback stabilizes the accessor to prevent infinite re-render loops
    useObservableState(useCallback(() => ({}), []), observables.onRangeUpdated);
    // Update view width on resize
    useEffect(() => {
        const updateWidth = () => {
            if (svgRef.current) {
                setViewWidth(svgRef.current.clientWidth);
            }
        };
        updateWidth();
        const onResize = observables.onHostWindowResized.add(updateWidth);
        // Track playhead position during playback using local state to avoid full context re-renders
        const onPlayheadMoved = observables.onPlayheadMoved.add((frame) => setDisplayFrame(frame));
        return () => {
            observables.onHostWindowResized.remove(onResize);
            observables.onPlayheadMoved.remove(onPlayheadMoved);
        };
    }, [observables]);
    // Sync display frame with state.activeFrame when not playing
    useEffect(() => {
        if (!state.isPlaying) {
            setDisplayFrame(state.activeFrame);
        }
    }, [state.activeFrame, state.isPlaying]);
    // Compute frame ticks
    const frameTicks = useMemo(() => {
        if (state.activeAnimations.length === 0) {
            return [];
        }
        const { fromKey, toKey } = state;
        const range = toKey - fromKey;
        if (range <= 0) {
            return [];
        }
        const convertRatio = range / viewWidth;
        const offset = Math.max(Math.floor(TICK_DISTANCE * convertRatio), 1);
        const steps = [];
        const start = fromKey;
        const end = start + range;
        for (let step = start; step <= end; step += offset) {
            steps.push(step);
        }
        // Ensure end is included if not already
        if (steps.length > 0 && steps[steps.length - 1] < end - offset / 2) {
            steps.push(end);
        }
        return steps;
    }, [state.fromKey, state.toKey, state.activeAnimations.length, viewWidth]);
    // Frame to X position
    const frameToX = useCallback((frame) => {
        const { fromKey, toKey } = state;
        const range = toKey - fromKey;
        if (range <= 0) {
            return 0;
        }
        return ((frame - fromKey) / range) * viewWidth;
    }, [state.fromKey, state.toKey, viewWidth]);
    // Render keyframe markers for active animations
    const renderKeyframes = useMemo(() => {
        const lines = [];
        for (const animation of state.activeAnimations) {
            const keys = animation.getKeys();
            for (let i = 0; i < keys.length; i++) {
                const x = frameToX(keys[i].frame);
                lines.push(jsx("line", { className: styles.keyframeLine, x1: x, y1: 0, x2: x, y2: 40 }, `keyframe-${animation.uniqueId}-${i}`));
            }
        }
        return lines;
    }, [state.activeAnimations, frameToX, styles.keyframeLine]);
    // Render active frame marker - uses displayFrame for smooth updates during playback
    const renderActiveFrame = useMemo(() => {
        if (displayFrame === null || displayFrame === undefined) {
            return null;
        }
        const x = frameToX(displayFrame);
        return jsx("line", { className: styles.activeFrameLine, x1: x, y1: 0, x2: x, y2: 40 });
    }, [displayFrame, frameToX, styles.activeFrameLine]);
    const viewBox = `${ -10} 0 ${viewWidth + OFFSET_X * 4} 40`;
    return (jsx("div", { className: styles.root, children: jsxs("svg", { ref: svgRef, className: styles.svg, viewBox: viewBox, children: [frameTicks.map((frame, i) => {
                    const x = frameToX(frame);
                    return (jsxs("g", { children: [jsx("line", { className: styles.tickLine, x1: x, y1: 22, x2: x, y2: 40 }), jsx("text", { className: styles.tickLabel, x: x, y: 14, children: Math.round(frame) })] }, `tick-${frame}-${i}`));
                }), renderKeyframes, renderActiveFrame] }) }));
};

const useStyles$p = makeStyles({
    root: {
        display: "flex",
        flexDirection: "column",
        flex: 1,
        minHeight: 0,
        position: "relative",
        backgroundColor: tokens.colorNeutralBackground3,
        overflow: "hidden",
    },
    frameBar: {
        flexShrink: 0,
        height: "30px",
        backgroundColor: tokens.colorNeutralBackground2,
    },
    canvasArea: {
        flex: 1,
        minHeight: 0,
        position: "relative",
        overflow: "hidden",
    },
    rangeFrameBar: {
        flexShrink: 0,
        height: "40px",
        backgroundColor: tokens.colorNeutralBackground2,
    },
});
/**
 * Main canvas area containing the graph, playhead, and frame bars
 * @returns The canvas component
 */
const Canvas = () => {
    const styles = useStyles$p();
    const { observables } = useCurveEditor();
    const containerRef = useRef(null);
    const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
    // Note: Child components (Graph, PlayHead, etc.) handle their own observable subscriptions
    // No need for canvas to re-render on animation changes
    // Update dimensions on resize
    useEffect(() => {
        const updateDimensions = () => {
            if (containerRef.current) {
                setDimensions({
                    width: containerRef.current.clientWidth,
                    height: containerRef.current.clientHeight,
                });
            }
        };
        updateDimensions();
        const observer = new ResizeObserver(updateDimensions);
        if (containerRef.current) {
            observer.observe(containerRef.current);
        }
        const onResize = observables.onHostWindowResized.add(updateDimensions);
        return () => {
            observer.disconnect();
            observables.onHostWindowResized.remove(onResize);
        };
    }, [observables]);
    return (jsxs("div", { className: styles.root, ref: containerRef, children: [jsx("div", { className: styles.frameBar, children: jsx(FrameBar, { width: dimensions.width }) }), jsxs("div", { className: styles.canvasArea, children: [jsx(Graph, { width: dimensions.width, height: dimensions.height - 70 }), jsx(PlayHead, { width: dimensions.width, height: dimensions.height - 70 })] }), jsx("div", { className: styles.rangeFrameBar, children: jsx(RangeFrameBar, { width: dimensions.width }) })] }));
};

const useStyles$o = makeStyles({
    root: {
        flex: 1,
        height: "25px",
        backgroundColor: tokens.colorNeutralBackground1,
        position: "relative",
        margin: "5px 0",
        minWidth: "100px",
        touchAction: "none",
    },
    scrollbar: {
        position: "absolute",
        top: "2px",
        bottom: "2px",
        backgroundColor: tokens.colorNeutralBackground3,
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        minWidth: "70px",
        cursor: "grab",
        touchAction: "none",
        "&:active": {
            cursor: "grabbing",
        },
    },
    handle: {
        width: "20px",
        height: "100%",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        cursor: "ew-resize",
        flexShrink: 0,
        touchAction: "none",
    },
    handleIcon: {
        width: "10px",
        height: "12px",
        display: "flex",
        flexDirection: "column",
        justifyContent: "space-between",
        "& div": {
            height: "2px",
            width: "100%",
            backgroundColor: tokens.colorNeutralForeground3,
        },
    },
    label: {
        flex: 1,
        textAlign: "center",
        fontSize: "12px",
        fontFamily: "acumin-pro-condensed, sans-serif",
        color: tokens.colorNeutralForeground3,
        userSelect: "none",
        pointerEvents: "none",
    },
});
/**
 * Range selector component - a draggable scrollbar for selecting frame range
 * @returns The range selector component
 */
const RangeSelector = () => {
    const styles = useStyles$o();
    const { state, actions, observables } = useCurveEditor();
    const containerRef = useRef(null);
    const scrollbarRef = useRef(null);
    const [viewWidth, setViewWidth] = useState(200);
    // Use refs to avoid stale closures in pointer handlers
    const dragStateRef = useRef({
        isPointerDown: false,
        dragMode: null,
        startX: 0,
        startFrom: 0,
        startTo: 0,
    });
    // Store current state values in refs for event handlers
    const stateRef = useRef({ fromKey: state.fromKey, toKey: state.toKey });
    stateRef.current = { fromKey: state.fromKey, toKey: state.toKey };
    // Get frame limits from animations
    const minFrame = state.referenceMinFrame;
    const maxFrame = state.clipLength;
    const minFrameRef = useRef(minFrame);
    const maxFrameRef = useRef(maxFrame);
    const viewWidthRef = useRef(viewWidth);
    minFrameRef.current = minFrame;
    maxFrameRef.current = maxFrame;
    viewWidthRef.current = viewWidth;
    // Update view width on resize
    useEffect(() => {
        const updateWidth = () => {
            if (containerRef.current) {
                setViewWidth(containerRef.current.clientWidth - 4);
            }
        };
        updateWidth();
        const resizeObserver = new ResizeObserver(updateWidth);
        if (containerRef.current) {
            resizeObserver.observe(containerRef.current);
        }
        const hostResizeObserver = observables.onHostWindowResized.add(updateWidth);
        return () => {
            resizeObserver.disconnect();
            observables.onHostWindowResized.remove(hostResizeObserver);
        };
    }, [observables]);
    // Calculate scrollbar position
    const range = maxFrame - minFrame;
    const leftPos = range > 0 ? 2 + ((state.fromKey - minFrame) / range) * viewWidth : 2;
    const rightPos = range > 0 ? 2 + ((maxFrame - state.toKey) / range) * viewWidth : 2;
    const handlePointerDown = useCallback((evt) => {
        // Check if we clicked on a handle
        const target = evt.target;
        let mode = "both";
        // Check target and its parent (for the nested handleIcon div)
        if (target.id === "left-handle" || target.parentElement?.id === "left-handle") {
            mode = "left";
        }
        else if (target.id === "right-handle" || target.parentElement?.id === "right-handle") {
            mode = "right";
        }
        dragStateRef.current = {
            isPointerDown: true,
            dragMode: mode,
            startX: evt.clientX,
            startFrom: stateRef.current.fromKey,
            startTo: stateRef.current.toKey,
        };
        evt.currentTarget.setPointerCapture(evt.pointerId);
        evt.preventDefault();
    }, []);
    const handlePointerMove = useCallback((evt) => {
        const drag = dragStateRef.current;
        if (!drag.isPointerDown || !drag.dragMode) {
            return;
        }
        evt.preventDefault();
        const currentMinFrame = minFrameRef.current;
        const currentMaxFrame = maxFrameRef.current;
        const currentRange = currentMaxFrame - currentMinFrame;
        const currentViewWidth = viewWidthRef.current;
        const dx = evt.clientX - drag.startX;
        const frameOffset = currentRange > 0 ? (dx / currentViewWidth) * currentRange : 0;
        if (drag.dragMode === "both") {
            let newFrom = Math.round(drag.startFrom + frameOffset);
            let newTo = Math.round(drag.startTo + frameOffset);
            // Keep within bounds
            if (newTo > currentMaxFrame) {
                const adjust = newTo - currentMaxFrame;
                newTo = currentMaxFrame;
                newFrom -= adjust;
            }
            if (newFrom < currentMinFrame) {
                const adjust = currentMinFrame - newFrom;
                newFrom = currentMinFrame;
                newTo += adjust;
            }
            // Clamp
            newFrom = Math.max(currentMinFrame, Math.min(currentMaxFrame, newFrom));
            newTo = Math.max(currentMinFrame, Math.min(currentMaxFrame, newTo));
            actions.setFromKey(newFrom);
            actions.setToKey(newTo);
        }
        else if (drag.dragMode === "left") {
            let newFrom = Math.round(drag.startFrom + frameOffset);
            newFrom = Math.max(currentMinFrame, Math.min(stateRef.current.toKey - 1, newFrom));
            actions.setFromKey(newFrom);
        }
        else if (drag.dragMode === "right") {
            let newTo = Math.round(drag.startTo + frameOffset);
            newTo = Math.max(stateRef.current.fromKey + 1, Math.min(currentMaxFrame, newTo));
            actions.setToKey(newTo);
        }
        observables.onRangeUpdated.notifyObservers();
        actions.stop();
    }, [actions, observables]);
    const handlePointerUp = useCallback((evt) => {
        dragStateRef.current.isPointerDown = false;
        dragStateRef.current.dragMode = null;
        evt.currentTarget.releasePointerCapture(evt.pointerId);
    }, []);
    const handlePointerCancel = useCallback((evt) => {
        dragStateRef.current.isPointerDown = false;
        dragStateRef.current.dragMode = null;
        evt.currentTarget.releasePointerCapture(evt.pointerId);
    }, []);
    return (jsx("div", { ref: containerRef, className: styles.root, children: jsxs("div", { ref: scrollbarRef, className: styles.scrollbar, style: {
                left: `${leftPos}px`,
                right: `${rightPos}px`,
            }, onPointerDown: handlePointerDown, onPointerMove: handlePointerMove, onPointerUp: handlePointerUp, onPointerCancel: handlePointerCancel, children: [jsx("div", { id: "left-handle", className: styles.handle, children: jsxs("div", { className: styles.handleIcon, children: [jsx("div", {}), jsx("div", {}), jsx("div", {})] }) }), jsx("div", { className: styles.label, children: Math.floor(state.fromKey) }), jsx("div", { className: styles.label, children: Math.floor(state.toKey) }), jsx("div", { id: "right-handle", className: styles.handle, children: jsxs("div", { className: styles.handleIcon, children: [jsx("div", {}), jsx("div", {}), jsx("div", {})] }) })] }) }));
};

const useStyles$n = makeStyles({
    root: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        gap: tokens.spacingHorizontalM,
        padding: `0 ${tokens.spacingHorizontalM}`,
        backgroundColor: tokens.colorNeutralBackground3,
        height: "100%",
        boxSizing: "border-box",
    },
    mediaControls: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        gap: tokens.spacingHorizontalXXS,
    },
    frameDisplay: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        gap: tokens.spacingHorizontalXS,
    },
    frameLabel: {
        fontSize: tokens.fontSizeBase200,
        color: tokens.colorNeutralForeground3,
    },
    spinButton: {
        width: "70px",
    },
    rangeSection: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        gap: tokens.spacingHorizontalS,
        flex: 1,
    },
    clipLengthSection: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        gap: tokens.spacingHorizontalXS,
        marginLeft: "auto",
    },
});
/**
 * Memoized media controls component to prevent re-renders during playback
 */
const MediaControls = memo(({ hasActiveAnimations, isPlaying, forwardAnimation, onPlayForward, onPlayBackward, onStop, onPrevKey, onNextKey, onFirstFrame, onLastFrame }) => {
    return (jsxs(Fragment, { children: [jsx(Button, { icon: PreviousRegular, appearance: "subtle", disabled: !hasActiveAnimations, onClick: onFirstFrame, title: "First frame" }), jsx(Button, { icon: ArrowPreviousRegular, appearance: "subtle", disabled: !hasActiveAnimations, onClick: onPrevKey, title: "Previous key" }), jsx(Button, { icon: TriangleLeftRegular, appearance: isPlaying && !forwardAnimation ? "primary" : "subtle", disabled: !hasActiveAnimations, onClick: onPlayBackward, title: "Play backward" }), jsx(Button, { icon: RecordStopRegular, appearance: "subtle", disabled: !hasActiveAnimations || !isPlaying, onClick: onStop, title: "Stop" }), jsx(Button, { icon: PlayRegular, appearance: isPlaying && forwardAnimation ? "primary" : "subtle", disabled: !hasActiveAnimations, onClick: onPlayForward, title: "Play forward" }), jsx(Button, { icon: ArrowNextRegular, appearance: "subtle", disabled: !hasActiveAnimations, onClick: onNextKey, title: "Next key" }), jsx(Button, { icon: NextRegular, appearance: "subtle", disabled: !hasActiveAnimations, onClick: onLastFrame, title: "Last frame" })] }));
});
MediaControls.displayName = "MediaControls";
/**
 * Bottom bar component with playback controls and frame navigation.
 * @returns The BottomBar component.
 */
const BottomBar = () => {
    const styles = useStyles$n();
    const { state, actions, observables } = useCurveEditor();
    // Track display frame separately for smooth updates during playback
    const [displayFrame, setDisplayFrame] = useState(state.activeFrame);
    // Use clipLength from state, with referenceMaxFrame as fallback
    const effectiveClipLength = state.clipLength > 0 ? state.clipLength : state.referenceMaxFrame;
    const [clipLength, setClipLength] = useState(effectiveClipLength);
    // Keep a ref to current toKey for use in observers
    const toKeyRef = useRef(state.toKey);
    toKeyRef.current = state.toKey;
    // Subscribe to playhead moved for display updates during playback
    useEffect(() => {
        const onPlayheadMoved = observables.onPlayheadMoved.add((frame) => {
            setDisplayFrame(frame);
        });
        return () => {
            observables.onPlayheadMoved.remove(onPlayheadMoved);
        };
    }, [observables]);
    // Sync display frame with state.activeFrame when not playing
    useEffect(() => {
        if (!state.isPlaying) {
            setDisplayFrame(state.activeFrame);
        }
    }, [state.activeFrame, state.isPlaying]);
    // Sync clip length with state
    useEffect(() => {
        const newClipLength = state.clipLength > 0 ? state.clipLength : state.referenceMaxFrame;
        setClipLength(newClipLength);
    }, [state.clipLength, state.referenceMaxFrame]);
    // Subscribe to clip length change observables
    useEffect(() => {
        const onClipLengthIncreased = observables.onClipLengthIncreased.add((newLength) => {
            setClipLength(newLength);
            actions.setClipLength(newLength);
            actions.setReferenceMaxFrame(newLength);
        });
        const onClipLengthDecreased = observables.onClipLengthDecreased.add((newLength) => {
            setClipLength(newLength);
            actions.setClipLength(newLength);
            actions.setReferenceMaxFrame(newLength);
            // Clamp toKey to new clip length
            if (toKeyRef.current > newLength) {
                actions.setToKey(newLength);
            }
        });
        return () => {
            observables.onClipLengthIncreased.remove(onClipLengthIncreased);
            observables.onClipLengthDecreased.remove(onClipLengthDecreased);
        };
    }, [observables, actions]);
    const handlePlayForward = useCallback(() => {
        actions.play(true);
    }, [actions]);
    const handlePlayBackward = useCallback(() => {
        actions.play(false);
    }, [actions]);
    const handleStop = useCallback(() => {
        actions.stop();
    }, [actions]);
    const handlePrevKey = useCallback(() => {
        const prevFrame = actions.getPrevKey();
        if (prevFrame !== null) {
            actions.moveToFrame(prevFrame);
        }
    }, [actions]);
    const handleNextKey = useCallback(() => {
        const nextFrame = actions.getNextKey();
        if (nextFrame !== null) {
            actions.moveToFrame(nextFrame);
        }
    }, [actions]);
    const handleFirstFrame = useCallback(() => {
        actions.moveToFrame(state.fromKey);
    }, [actions, state.fromKey]);
    const handleLastFrame = useCallback(() => {
        actions.moveToFrame(state.toKey);
    }, [actions, state.toKey]);
    /**
     * Handler for frame input change.
     * @param value - The new frame value.
     */
    const handleFrameChange = useCallback((value) => {
        actions.moveToFrame(value);
    }, [actions]);
    /**
     * Handler for clip length change.
     * @param value - The new clip length value.
     */
    const handleClipLengthChange = useCallback((value) => {
        const newLength = Math.max(1, value);
        if (newLength > state.clipLength) {
            observables.onClipLengthIncreased.notifyObservers(newLength);
        }
        else if (newLength < state.clipLength) {
            observables.onClipLengthDecreased.notifyObservers(newLength);
        }
    }, [state.clipLength, observables]);
    const hasActiveAnimations = state.activeAnimations.length > 0;
    return (jsxs("div", { className: styles.root, children: [jsx("div", { className: styles.mediaControls, children: jsx(MediaControls, { hasActiveAnimations: hasActiveAnimations, isPlaying: state.isPlaying, forwardAnimation: state.forwardAnimation, onPlayForward: handlePlayForward, onPlayBackward: handlePlayBackward, onStop: handleStop, onPrevKey: handlePrevKey, onNextKey: handleNextKey, onFirstFrame: handleFirstFrame, onLastFrame: handleLastFrame }) }), jsxs("div", { className: styles.frameDisplay, children: [jsx("div", { className: styles.frameLabel, children: "Frame:" }), jsx(SpinButton, { className: styles.spinButton, value: displayFrame, onChange: handleFrameChange, min: state.fromKey, max: state.toKey, disabled: !hasActiveAnimations })] }), jsx(RangeSelector, {}), jsxs("div", { className: styles.clipLengthSection, children: [jsx("div", { className: styles.frameLabel, children: "Clip Length:" }), jsx(SpinButton, { className: styles.spinButton, value: clipLength, onChange: handleClipLengthChange, min: 1, disabled: !hasActiveAnimations })] })] }));
};

const useStyles$m = makeStyles({
    root: {
        display: "flex",
        flexDirection: "column",
        width: "100%",
        height: "100%",
        minHeight: 0,
        flex: 1,
        backgroundColor: tokens.colorNeutralBackground3,
        color: tokens.colorNeutralForeground1,
        overflow: "hidden",
        fontFamily: "'acumin-pro-condensed', 'Segoe UI', sans-serif",
        outline: "none", // Remove focus outline for keyboard shortcuts
    },
    topBar: {
        flexShrink: 0,
        height: "40px",
    },
    mainContent: {
        display: "flex",
        flexDirection: "row",
        flex: 1,
        minHeight: 0,
        overflow: "hidden",
    },
    sideBar: {
        width: "220px",
        flexShrink: 0,
        marginLeft: "10px",
    },
    canvasArea: {
        display: "flex",
        flexDirection: "column",
        flex: 1,
        minHeight: 0,
        marginLeft: "10px",
        marginRight: "10px",
        overflow: "hidden",
    },
    bottomBar: {
        flexShrink: 0,
        height: "45px",
    },
});
/**
 * Internal component that uses the curve editor context
 * @returns The curve editor content
 */
const CurveEditorContent = () => {
    const styles = useStyles$m();
    const { state, actions, observables } = useCurveEditor();
    const rootRef = useRef(null);
    const prepareRef = useRef(() => actions.prepare());
    prepareRef.current = () => actions.prepare();
    useEffect(() => {
        // Only run prepare once on mount
        prepareRef.current();
    }, []);
    // Keyboard handler for hotkeys
    const handleKeyDown = useCallback((evt) => {
        switch (evt.key) {
            case "Delete":
            case "Backspace":
                if (state.activeKeyPoints?.length && !state.focusedInput) {
                    observables.onDeleteKeyActiveKeyPoints.notifyObservers();
                }
                break;
            case " ":
                evt.preventDefault();
                if (state.isPlaying) {
                    actions.stop();
                }
                else {
                    actions.play(true);
                }
                break;
            case "a":
                if (evt.ctrlKey) {
                    observables.onSelectAllKeys.notifyObservers();
                    observables.onActiveKeyPointChanged.notifyObservers();
                    evt.preventDefault();
                }
                break;
            case "ArrowLeft":
                if (!state.focusedInput) {
                    const newFrame = Math.max(0, state.activeFrame - 1);
                    actions.moveToFrame(newFrame);
                    evt.preventDefault();
                }
                break;
            case "ArrowRight":
                if (!state.focusedInput) {
                    const newFrame = Math.min(state.clipLength, state.activeFrame + 1);
                    actions.moveToFrame(newFrame);
                    evt.preventDefault();
                }
                break;
            case "ArrowDown": {
                if (!state.focusedInput) {
                    const prevKey = actions.getPrevKey();
                    if (prevKey !== null) {
                        actions.moveToFrame(prevKey);
                    }
                    evt.preventDefault();
                }
                break;
            }
            case "ArrowUp": {
                if (!state.focusedInput) {
                    const nextKey = actions.getNextKey();
                    if (nextKey !== null) {
                        actions.moveToFrame(nextKey);
                    }
                    evt.preventDefault();
                }
                break;
            }
        }
    }, [state.activeKeyPoints, state.focusedInput, state.isPlaying, state.activeFrame, state.clipLength, observables, actions]);
    // Handle window resize
    useEffect(() => {
        const handleResize = () => {
            // Notify observers about resize
        };
        window.addEventListener("resize", handleResize);
        return () => window.removeEventListener("resize", handleResize);
    }, []);
    // Focus the root element on mount to enable keyboard shortcuts
    useEffect(() => {
        rootRef.current?.focus();
    }, []);
    return (jsxs("div", { ref: rootRef, className: styles.root, tabIndex: 0, onKeyDown: handleKeyDown, children: [jsx("div", { className: styles.topBar, children: jsx(TopBar, {}) }), jsxs("div", { className: styles.mainContent, children: [jsx("div", { className: styles.sideBar, children: jsx(SideBar, {}) }), jsx("div", { className: styles.canvasArea, children: jsx(Canvas, {}) })] }), jsx("div", { className: styles.bottomBar, children: jsx(BottomBar, {}) })] }));
};
/**
 * Animation Curve Editor component for editing animation keyframes and curves
 * @param props - The component props
 * @returns The curve editor component
 */
const CurveEditor = (props) => {
    const { scene, target, animations, rootAnimationGroup, title, useTargetAnimations } = props;
    return (jsx(CurveEditorProvider, { scene: scene, target: target, animations: animations, rootAnimationGroup: rootAnimationGroup, title: title, useTargetAnimations: useTargetAnimations, children: jsx(CurveEditorContent, {}) }));
};

/**
 * Button component that opens the Animation Curve Editor in a popup window
 * @param props - The component props
 * @returns The button component
 */
const CurveEditorButton = (props) => {
    const { scene, target, animations, rootAnimationGroup, title, useTargetAnimations, label = "Open Animation Curve Editor" } = props;
    const childWindow = useRef(null);
    return (jsxs(Fragment, { children: [jsx(ButtonLine, { label: label, onClick: () => childWindow.current?.open({
                    defaultWidth: 1024,
                    defaultHeight: 512,
                    title: title ?? "Animation Curve Editor",
                }), icon: EditRegular }), jsx(ChildWindow, { id: "Animation Curve Editor", imperativeRef: childWindow, children: jsx(CurveEditor, { scene: scene, target: target, animations: animations, rootAnimationGroup: rootAnimationGroup, title: title, useTargetAnimations: useTargetAnimations }) })] }));
};

const AnimationGroupControlProperties = (props) => {
    const { animationGroup } = props;
    const targetedAnimations = animationGroup.targetedAnimations;
    const scene = animationGroup.getScene();
    let currentFrameHolder = undefined;
    if (targetedAnimations.length > 0) {
        currentFrameHolder = targetedAnimations[0].animation.runtimeAnimations.find((rA) => rA.target === targetedAnimations[0].target);
    }
    const isPlaying = useObservableState(useCallback(() => {
        return animationGroup.isPlaying;
    }, [animationGroup]), animationGroup.onAnimationGroupPlayObservable, animationGroup.onAnimationGroupPauseObservable, animationGroup.onAnimationGroupEndObservable);
    const currentFrame = useObservableState(useCallback(() => {
        return currentFrameHolder ? currentFrameHolder.currentFrame : undefined;
    }, [currentFrameHolder]), isPlaying ? animationGroup.getScene().onBeforeRenderObservable : null);
    const enableBlending = useProperty(animationGroup, "enableBlending");
    return (jsxs(Fragment, { children: [jsx(ButtonLine, { label: isPlaying ? "Pause" : "Play", onClick: () => (isPlaying ? animationGroup.pause() : animationGroup.play(true)) }), jsx(ButtonLine, { label: "Stop", onClick: () => animationGroup.stop() }), jsx(CurveEditorButton, { scene: scene, target: null, animations: targetedAnimations, rootAnimationGroup: animationGroup, title: animationGroup.name, useTargetAnimations: true }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Speed Ratio", min: 0, max: 10, step: 0.1, target: animationGroup, propertyKey: "speedRatio" }), currentFrameHolder && currentFrame !== undefined ? (jsx(SyncedSliderPropertyLine, { label: "Current Frame", min: animationGroup.from, max: animationGroup.to, step: (animationGroup.to - animationGroup.from) / 1000.0, value: currentFrame, onChange: (value) => {
                    if (!animationGroup.isPlaying) {
                        animationGroup.play(true);
                        animationGroup.goToFrame(value);
                        animationGroup.pause();
                    }
                    else {
                        animationGroup.goToFrame(value);
                    }
                } })) : null, jsx(BoundProperty, { component: SwitchPropertyLine, label: "Blending", target: animationGroup, propertyKey: "enableBlending", ignoreNullable: true, defaultValue: false }), jsx(Collapse, { visible: !!enableBlending, children: jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Blending Speed", min: 0, max: 1, step: 0.01, target: animationGroup, propertyKey: "blendingSpeed", ignoreNullable: true, defaultValue: 0 }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Is Additive", target: animationGroup, propertyKey: "isAdditive" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Weight", target: animationGroup, propertyKey: "weight", step: 0.1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Play order", target: animationGroup, propertyKey: "playOrder", forceInt: true })] }) })] }));
};
const AnimationGroupInfoProperties = (props) => {
    const { animationGroup } = props;
    return (jsxs(Fragment, { children: [jsx(StringifiedPropertyLine, { label: "Animation Count", value: animationGroup.targetedAnimations.length }), jsx(StringifiedPropertyLine, { label: "From", value: animationGroup.from, precision: 2 }), jsx(StringifiedPropertyLine, { label: "To", value: animationGroup.to, precision: 2 }), jsx(StringifiedPropertyLine, { label: "Unique ID", value: animationGroup.uniqueId })] }));
};

const AnimationGroupPropertiesServiceDefinition = {
    friendlyName: "Animation Group Properties",
    consumes: [PropertiesServiceIdentity, SelectionServiceIdentity],
    factory: (propertiesService, selectionService) => {
        const animationGroupContentRegistration = propertiesService.addSectionContent({
            key: "Animation Group Properties",
            predicate: (entity) => entity instanceof AnimationGroup,
            content: [
                {
                    section: "Control",
                    component: ({ context }) => jsx(AnimationGroupControlProperties, { animationGroup: context }),
                },
                {
                    section: "Info",
                    component: ({ context }) => jsx(AnimationGroupInfoProperties, { animationGroup: context }),
                },
            ],
        });
        const targetedAnimationContentRegistration = propertiesService.addSectionContent({
            key: "Targeted Animation Properties",
            predicate: (entity) => entity instanceof TargetedAnimation,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(TargetedAnimationGeneralProperties, { targetedAnimation: context, selectionService: selectionService }),
                },
            ],
        });
        return {
            dispose: () => {
                animationGroupContentRegistration.dispose();
                targetedAnimationContentRegistration.dispose();
            },
        };
    },
};

const useClasses = makeStyles({
    container: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalS, // 8px
    },
});
const MessageBar = (props) => {
    MessageBar.displayName = "MessageBar";
    const { message, title, intent, docLink } = props;
    const classes = useClasses();
    return (jsx("div", { className: classes.container, children: jsx(MessageBar$1, { intent: intent, layout: "multiline", children: jsxs(MessageBarBody, { children: [title && jsx(MessageBarTitle, { children: title }), message, docLink && (jsxs(Fragment, { children: [" - ", jsx(Link, { url: docLink, value: "Learn More" })] }))] }) }) }));
};

const AnimationsProperties = (props) => {
    const { scene, entity } = props;
    // Track animations array changes via property interception
    const trackedAnimations = useProperty(entity, "animations");
    const animations = trackedAnimations ?? [];
    const ranges = entity.getAnimationRanges?.()?.filter((range) => !!range) ?? [];
    const childAnimatablesAnimations = entity.getAnimatables?.().flatMap((animatable) => animatable.animations ?? []) ?? [];
    animations.concat(childAnimatablesAnimations);
    const lastFrom = useRef(0);
    const lastTo = useRef(0);
    const lastLoop = useRef(false);
    const animatablesForTarget = scene.getAllAnimatablesByTarget(entity);
    const isPlaying = animatablesForTarget.length > 0;
    const mainAnimatable = isPlaying ? animatablesForTarget[0] : undefined;
    const animationPropertiesOverride = useProperty(mainAnimatable, "animationPropertiesOverride");
    if (mainAnimatable) {
        lastFrom.current = mainAnimatable.fromFrame;
        lastTo.current = mainAnimatable.toFrame;
        lastLoop.current = mainAnimatable.loopAnimation;
    }
    const hasAnimations = animations.length > 0 || ranges.length > 0;
    const currentFrame = useObservableState(useCallback(() => {
        return mainAnimatable ? mainAnimatable.masterFrame : (scene.getAllAnimatablesByTarget(entity)[0]?.masterFrame ?? 0);
    }, [scene, entity, mainAnimatable]), hasAnimations ? scene.onAfterAnimationsObservable : undefined);
    return (jsxs(Fragment, { children: [!hasAnimations && (jsx(MessageBar, { intent: "info", title: "No Animations", message: "To modify animations, attach an animation to this node.", docLink: "https://doc.babylonjs.com/features/featuresDeepDive/animation/" })), ranges.length > 0 && (jsx(PropertyLine, { label: "Ranges", expandedContent: jsx(Fragment, { children: ranges.map((range) => {
                        return (jsx(ButtonLine, { label: range.name, onClick: () => {
                                scene.beginAnimation(entity, range.from, range.to, true);
                            } }, range.name));
                    }) }), children: jsx(Badge, { appearance: "filled", children: ranges.length }) })), animations.length > 0 && (jsx(PropertyLine, { label: "Animations", expandedContent: jsx(Fragment, { children: animations.map((animation, index) => {
                        return jsx(TextPropertyLine, { label: `${index}: ${animation.name}`, value: animation.targetProperty }, animation.uniqueId);
                    }) }), children: jsx(Badge, { appearance: "filled", children: animations.length }) })), jsx(CurveEditorButton, { scene: scene, target: entity, animations: animations, title: entity.name ?? "Animation Curve Editor" }), mainAnimatable && (jsx(Fragment, { children: jsx(PropertyLine, { label: "Animation Controls", expandedContent: jsxs(Fragment, { children: [jsx(NumberInputPropertyLine, { label: "From", value: mainAnimatable.fromFrame, onChange: (value) => {
                                    scene.stopAnimation(entity);
                                    scene.beginAnimation(entity, value, mainAnimatable.toFrame, true);
                                } }), jsx(NumberInputPropertyLine, { label: "To", value: mainAnimatable.toFrame, onChange: (value) => {
                                    scene.stopAnimation(entity);
                                    scene.beginAnimation(entity, mainAnimatable.fromFrame, value, true);
                                } }), jsx(SwitchPropertyLine, { label: "Loop", value: mainAnimatable.loopAnimation, onChange: (value) => {
                                    for (const animatable of animatablesForTarget) {
                                        animatable.loopAnimation = value;
                                    }
                                } }), jsx(SyncedSliderPropertyLine, { label: "Current Frame", value: currentFrame, min: mainAnimatable.fromFrame, max: mainAnimatable.toFrame, step: (mainAnimatable.toFrame - mainAnimatable.fromFrame) / 1000, onChange: (value) => {
                                    mainAnimatable.goToFrame(value);
                                } })] }), expandByDefault: true }) })), hasAnimations && (jsx(ButtonLine, { label: isPlaying ? "Stop Animation" : "Play Animation", onClick: () => {
                    if (isPlaying) {
                        scene.stopAnimation(entity);
                    }
                    else {
                        scene.beginAnimation(entity, lastFrom.current, lastTo.current, lastLoop.current);
                    }
                } })), mainAnimatable && (ranges.length > 0 || animations.length > 0) ? (jsxs(Fragment, { children: [jsx(SwitchPropertyLine, { label: "Enable Override", value: animationPropertiesOverride != null, onChange: (value) => {
                            if (value) {
                                mainAnimatable.animationPropertiesOverride = new AnimationPropertiesOverride();
                                mainAnimatable.animationPropertiesOverride.blendingSpeed = 0.05;
                            }
                            else {
                                mainAnimatable.animationPropertiesOverride = undefined;
                            }
                        } }), jsx(Collapse, { visible: animationPropertiesOverride != null, children: jsxs("div", { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Enable Blending", target: animationPropertiesOverride, propertyKey: "enableBlending" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Blending Speed", target: animationPropertiesOverride, propertyKey: "blendingSpeed", min: 0, max: 0.1, step: 0.01 })] }) })] })) : null] }));
};

function IsAnimatable(entity) {
    return entity.animations !== undefined;
}
function IsAnimationRangeContainer(entity) {
    return entity.getAnimationRanges !== undefined;
}
function IsAnimatableContainer(entity) {
    return entity.getAnimatables !== undefined;
}
const AnimationPropertiesServiceDefinition = {
    friendlyName: "Animation Properties",
    consumes: [PropertiesServiceIdentity, SelectionServiceIdentity, SceneContextIdentity],
    factory: (propertiesService, selectionService, sceneContext) => {
        const scene = sceneContext.currentScene;
        if (!scene) {
            return undefined;
        }
        const animationContentRegistration = propertiesService.addSectionContent({
            key: "Animation Properties",
            predicate: (entity) => IsAnimatable(entity) || IsAnimationRangeContainer(entity) || IsAnimatableContainer(entity),
            content: [
                {
                    section: "Animation",
                    component: ({ context }) => jsx(AnimationsProperties, { scene: scene, entity: context }),
                },
            ],
        });
        return {
            dispose: () => {
                animationContentRegistration.dispose();
            },
        };
    },
};

const GeneralAtmosphereProperties = (props) => {
    const { entity: atmosphere } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { label: "Planet Radius (km)", component: SyncedSliderPropertyLine, target: atmosphere.physicalProperties, propertyKey: "planetRadius", propertyPath: "physicalProperties.planetRadius", min: 1000.0, max: 10000.0, step: 1 }), jsx(BoundProperty, { label: "Atmosphere Thickness (km)", component: SyncedSliderPropertyLine, target: atmosphere.physicalProperties, propertyKey: "atmosphereThickness", propertyPath: "physicalProperties.atmosphereThickness", min: 1.0, max: 200.0, step: 1 })] }));
};
const ScatteringAndAbsorptionProperties = (props) => {
    const { entity: atmosphere } = props;
    return (jsxs(Fragment, { children: [jsx(PropertyLine, { label: "Rayleigh Scattering", expandByDefault: true, description: "Rayleigh scattering is the scattering of light off of the molecules of the atmosphere. It is the main reason why the sky is blue. Increasing the Rayleigh scattering coefficient will result in a bluer sky.", expandedContent: jsxs(Fragment, { children: [jsx(BoundProperty, { label: "Scale", component: SyncedSliderPropertyLine, target: atmosphere.physicalProperties, propertyKey: "rayleighScatteringScale", propertyPath: "physicalProperties.rayleighScatteringScale", min: 0.0, max: 5.0, step: 0.01 }), jsx(BoundProperty, { label: "Coefficient", component: Vector3PropertyLine, target: atmosphere.physicalProperties, propertyKey: "peakRayleighScattering", propertyPath: "physicalProperties.peakRayleighScattering", convertTo: (value) => value.scale(1000), convertFrom: (value) => value.scale(0.001), min: 0, step: 0.01, unit: "Mm" })] }) }), jsx(PropertyLine, { label: "Mie Scattering", description: "Mie scattering is the scattering of light off of the larger particles in the atmosphere, such as dust and water droplets. It is responsible for the white appearance of clouds and the haziness of the sky. Increasing the Mie scattering coefficient will result in a whiter sky.", expandByDefault: true, expandedContent: jsxs(Fragment, { children: [jsx(BoundProperty, { label: "Scale", component: SyncedSliderPropertyLine, target: atmosphere.physicalProperties, propertyKey: "mieScatteringScale", propertyPath: "physicalProperties.mieScatteringScale", min: 0.0, max: 5.0, step: 0.01 }), jsx(BoundProperty, { label: "Coefficient", component: Vector3PropertyLine, target: atmosphere.physicalProperties, propertyKey: "peakMieScattering", propertyPath: "physicalProperties.peakMieScattering", convertTo: (value) => value.scale(1000), convertFrom: (value) => value.scale(0.001), min: 0, step: 0.01, unit: "Mm" })] }) }), jsx(PropertyLine, { label: "Mie Absorption", description: "Mie absorption is the absorption of light by the larger particles in the atmosphere, such as dust and water droplets. It is responsible for the dimming of the sun during haze and fog. Increasing mie absorption coefficient will result in visually darker skies.", expandByDefault: true, expandedContent: jsxs(Fragment, { children: [jsx(BoundProperty, { label: "Scale", component: SyncedSliderPropertyLine, target: atmosphere.physicalProperties, propertyKey: "mieAbsorptionScale", propertyPath: "physicalProperties.mieAbsorptionScale", min: 0.0, max: 5.0, step: 0.01 }), jsx(BoundProperty, { label: "Coefficient", component: Vector3PropertyLine, target: atmosphere.physicalProperties, propertyKey: "peakMieAbsorption", propertyPath: "physicalProperties.peakMieAbsorption", convertTo: (value) => value.scale(1000), convertFrom: (value) => value.scale(0.001), min: 0, step: 0.01, unit: "Mm" })] }) }), jsx(PropertyLine, { label: "Ozone Absorption", expandByDefault: true, description: "Ozone absorption is the absorption of light by ozone molecules in the atmosphere. Increasing ozone absorption coefficient will result in visually darker skies.", expandedContent: jsxs(Fragment, { children: [jsx(BoundProperty, { label: "Scale", component: SyncedSliderPropertyLine, target: atmosphere.physicalProperties, propertyKey: "ozoneAbsorptionScale", propertyPath: "physicalProperties.ozoneAbsorptionScale", min: 0.0, max: 5.0, step: 0.01 }), jsx(BoundProperty, { label: "Coefficient", component: Vector3PropertyLine, target: atmosphere.physicalProperties, propertyKey: "peakOzoneAbsorption", propertyPath: "physicalProperties.peakOzoneAbsorption", convertTo: (value) => value.scale(1000), convertFrom: (value) => value.scale(0.001), min: 0, step: 0.01 })] }) })] }));
};
const MultipleScatteringProperties = (props) => {
    const { entity: atmosphere } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { label: "Intensity", component: SyncedSliderPropertyLine, target: atmosphere, propertyKey: "multiScatteringIntensity", min: 0, max: 5.0, step: 0.1 }), jsx(BoundProperty, { label: "Minimum Intensity", component: SyncedSliderPropertyLine, target: atmosphere, propertyKey: "minimumMultiScatteringIntensity", min: 0.0, max: 0.1, step: 0.0001 }), jsx(BoundProperty, { label: "Minimum Color", component: Color3PropertyLine, target: atmosphere, propertyKey: "minimumMultiScatteringColor" }), jsx(BoundProperty, { label: "Ground Albedo", component: Color3PropertyLine, target: atmosphere, propertyKey: "groundAlbedo" })] }));
};
const AerialPerspectiveProperties = (props) => {
    const { entity: atmosphere } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { label: "Intensity", component: SyncedSliderPropertyLine, target: atmosphere, propertyKey: "aerialPerspectiveIntensity", min: 0, max: 5.0, step: 0.1 }), jsx(BoundProperty, { label: "Transmittance Scale", component: SyncedSliderPropertyLine, target: atmosphere, propertyKey: "aerialPerspectiveTransmittanceScale", min: 0, max: 2.0, step: 0.01 }), jsx(BoundProperty, { label: "Saturation", component: SyncedSliderPropertyLine, target: atmosphere, propertyKey: "aerialPerspectiveSaturation", min: 0, max: 2.0, step: 0.01 })] }));
};
const DiffuseIrradianceProperties = (props) => {
    const { entity: atmosphere } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { label: "Intensity", component: SyncedSliderPropertyLine, target: atmosphere, propertyKey: "diffuseSkyIrradianceIntensity", min: 0, max: 5.0, step: 0.001 }), jsx(BoundProperty, { label: "Desaturation", component: SyncedSliderPropertyLine, target: atmosphere, propertyKey: "diffuseSkyIrradianceDesaturationFactor", min: 0, max: 1.0, step: 0.01 }), jsx(BoundProperty, { label: "Additional Intensity", component: SyncedSliderPropertyLine, target: atmosphere, propertyKey: "additionalDiffuseSkyIrradianceIntensity", min: 0, max: 100000.0, step: 1 }), jsx(BoundProperty, { label: "Additional Color", component: Color3PropertyLine, target: atmosphere, propertyKey: "additionalDiffuseSkyIrradianceColor" })] }));
};
const RenderingOptionsProperties = (props) => {
    const { entity: atmosphere } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { label: "Linear Space Output", component: SwitchPropertyLine, target: atmosphere, propertyKey: "isLinearSpaceComposition" }), jsx(BoundProperty, { label: "Linear Space Light", component: SwitchPropertyLine, target: atmosphere, propertyKey: "isLinearSpaceLight" }), jsx(BoundProperty, { label: "Use LUT for Sky (Optimization)", component: SwitchPropertyLine, target: atmosphere, propertyKey: "isSkyViewLutEnabled" }), jsx(BoundProperty, { label: "Use LUT for Aerial Perspective (Optimization)", component: SwitchPropertyLine, target: atmosphere, propertyKey: "isAerialPerspectiveLutEnabled" })] }));
};

const AtmospherePropertiesServiceDefinition = {
    friendlyName: "Atmosphere Properties",
    consumes: [PropertiesServiceIdentity, SelectionServiceIdentity, SceneContextIdentity],
    factory: (propertiesService, selectionService, sceneContext) => {
        const scene = sceneContext.currentScene;
        if (!scene) {
            return undefined;
        }
        const atmosphereContentRegistration = propertiesService.addSectionContent({
            key: "Atmosphere Properties",
            predicate: (entity) => entity.getClassName?.() === "Atmosphere",
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(GeneralAtmosphereProperties, { entity: context }),
                },
                {
                    section: "Scattering and Absorption",
                    component: ({ context }) => jsx(ScatteringAndAbsorptionProperties, { entity: context }),
                },
                {
                    section: "Multiple Scattering",
                    component: ({ context }) => jsx(MultipleScatteringProperties, { entity: context }),
                },
                {
                    section: "Aerial Perspective",
                    component: ({ context }) => jsx(AerialPerspectiveProperties, { entity: context }),
                },
                {
                    section: "Diffuse Sky Irradiance",
                    component: ({ context }) => jsx(DiffuseIrradianceProperties, { entity: context }),
                },
                {
                    section: "Rendering Options",
                    component: ({ context }) => jsx(RenderingOptionsProperties, { entity: context }),
                },
            ],
        });
        return {
            dispose: () => {
                atmosphereContentRegistration.dispose();
            },
        };
    },
};

function useSoundState(sound) {
    const stateChangedObservables = [
        useInterceptObservable("function", sound, "play"),
        useInterceptObservable("function", sound, "pause"),
        useInterceptObservable("function", sound, "stop"),
    ];
    const isPaused = useObservableState(useCallback(() => sound.isPaused, [sound]), ...stateChangedObservables);
    const isPlaying = useObservableState(useCallback(() => sound.isPlaying, [sound]), ...stateChangedObservables);
    return isPaused ? "Paused" : isPlaying ? "Playing" : "Stopped";
}
const SoundGeneralProperties = (props) => {
    const { sound } = props;
    const soundState = useSoundState(sound);
    return (jsx(Fragment, { children: jsx(TextPropertyLine, { label: "Status", value: soundState }) }));
};
const SoundCommandProperties = (props) => {
    const { sound } = props;
    const soundState = useSoundState(sound);
    const volume = useObservableState(useCallback(() => sound.getVolume(), [sound]), useInterceptObservable("function", sound, "setVolume"));
    return (jsxs(Fragment, { children: [jsx(ButtonLine, { label: soundState === "Playing" ? "Pause" : "Play", icon: soundState === "Playing" ? PauseRegular : PlayRegular, onClick: () => {
                    if (soundState === "Playing") {
                        sound.pause();
                    }
                    else {
                        sound.play();
                    }
                } }), jsx(Property, { component: SyncedSliderPropertyLine, label: "Volume", functionPath: "setVolume", value: volume, min: 0, max: 5, step: 0.1, onChange: (value) => {
                    sound.setVolume(value);
                } }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Loop", target: sound, propertyKey: "loop" })] }));
};

const AudioPropertiesServiceDefinition = {
    friendlyName: "Audio Properties",
    consumes: [PropertiesServiceIdentity],
    factory: (propertiesService) => {
        const soundContentRegistration = propertiesService.addSectionContent({
            key: "Sound General Properties",
            predicate: (entity) => entity instanceof Sound,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(SoundGeneralProperties, { sound: context }),
                },
                {
                    section: "Commands",
                    component: ({ context }) => jsx(SoundCommandProperties, { sound: context }),
                },
            ],
        });
        return {
            dispose: () => {
                soundContentRegistration.dispose();
            },
        };
    },
};

const ArcRotateCameraTransformProperties = (props) => {
    const { camera, settings } = props;
    const [toDisplayAngle, fromDisplayAngle, useDegrees] = useAngleConverters(settings);
    const lowerAlphaLimit = useProperty(camera, "lowerAlphaLimit") ?? 0;
    const upperAlphaLimit = useProperty(camera, "upperAlphaLimit") ?? Math.PI * 2;
    const lowerBetaLimit = useProperty(camera, "lowerBetaLimit") ?? -Math.PI;
    const upperBetaLimit = useProperty(camera, "upperBetaLimit") ?? Math.PI;
    const lowerRadiusLimit = useProperty(camera, "lowerRadiusLimit");
    const upperRadiusLimit = useProperty(camera, "upperRadiusLimit");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Alpha", description: `Horizontal angle in ${useDegrees ? "degrees" : "radians"}`, target: camera, propertyKey: "alpha", min: toDisplayAngle(lowerAlphaLimit), max: toDisplayAngle(upperAlphaLimit), step: toDisplayAngle(0.01), convertTo: (value) => toDisplayAngle(value, true), convertFrom: fromDisplayAngle }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Beta", description: `Vertical angle in ${useDegrees ? "degrees" : "radians"}`, target: camera, propertyKey: "beta", min: toDisplayAngle(lowerBetaLimit), max: toDisplayAngle(upperBetaLimit), step: toDisplayAngle(0.01), convertTo: (value) => toDisplayAngle(value, true), convertFrom: fromDisplayAngle }), lowerRadiusLimit != null && upperRadiusLimit != null ? (jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Radius", description: "Distance from the target point.", target: camera, propertyKey: "radius", min: lowerRadiusLimit, max: upperRadiusLimit, step: 0.01 })) : (jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Radius", description: "Distance from the target point.", target: camera, propertyKey: "radius", min: 0, step: 0.01 }))] }));
};
const ArcRotateCameraControlProperties = (props) => {
    const { camera } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Angular Sensitivity X", target: camera, propertyKey: "angularSensibilityX" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Angular Sensitivity Y", target: camera, propertyKey: "angularSensibilityY" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Panning Sensitivity", target: camera, propertyKey: "panningSensibility" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Pinch Delta Percentage", target: camera, propertyKey: "pinchDeltaPercentage" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Wheel Delta Percentage", target: camera, propertyKey: "wheelDeltaPercentage" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Natural Pinch Zoom", target: camera, propertyKey: "useNaturalPinchZoom" })] }));
};
const ArcRotateCameraCollisionProperties = (props) => {
    const { camera } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Check Collisions", target: camera, propertyKey: "checkCollisions" }), jsx(BoundProperty, { component: Vector3PropertyLine, label: "Collision Radius", target: camera, propertyKey: "collisionRadius" })] }));
};
const ArcRotateCameraLimitsProperties = (props) => {
    const { camera } = props;
    // TODO-Iv2: Update defaultValues
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Lower Alpha Limit", target: camera, propertyKey: "lowerAlphaLimit", nullable: true, defaultValue: 0 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Upper Alpha Limit", target: camera, propertyKey: "upperAlphaLimit", nullable: true, defaultValue: Infinity }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Lower Beta Limit", target: camera, propertyKey: "lowerBetaLimit", nullable: true, defaultValue: -Math.PI }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Upper Beta Limit", target: camera, propertyKey: "upperBetaLimit", nullable: true, defaultValue: Math.PI }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Lower Radius Limit", target: camera, propertyKey: "lowerRadiusLimit", nullable: true, defaultValue: 0 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Upper Radius Limit", target: camera, propertyKey: "upperRadiusLimit", nullable: true, defaultValue: 100 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Lower Target Y Limit", target: camera, propertyKey: "lowerTargetYLimit" })] }));
};
const ArcRotateCameraBehaviorsProperties = (props) => {
    const { camera } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Auto Rotation", target: camera, propertyKey: "useAutoRotationBehavior" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Bouncing", target: camera, propertyKey: "useBouncingBehavior" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Framing", target: camera, propertyKey: "useFramingBehavior" })] }));
};

const GeospatialCameraTransformProperties = (props) => {
    const { camera, settings } = props;
    const [toDisplayAngle, fromDisplayAngle, useDegrees] = useAngleConverters(settings);
    const limits = useProperty(camera, "limits");
    const yawMin = limits?.yawMin ?? -Math.PI;
    const yawMax = limits?.yawMax ?? Math.PI;
    const pitchMin = limits?.pitchMin ?? 0;
    const pitchMax = limits?.pitchMax ?? Math.PI / 2;
    const radiusMin = limits?.radiusMin ?? 0;
    const radiusMax = limits?.radiusMax ?? Infinity;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Yaw", description: `Horizontal rotation in ${useDegrees ? "degrees" : "radians"} (0 = north)`, target: camera, propertyKey: "yaw", min: toDisplayAngle(yawMin), max: toDisplayAngle(yawMax), step: toDisplayAngle(0.01), convertTo: (value) => toDisplayAngle(value, true), convertFrom: fromDisplayAngle }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Pitch", description: `Vertical angle in ${useDegrees ? "degrees" : "radians"} (0 = looking down, /2 = horizon)`, target: camera, propertyKey: "pitch", min: toDisplayAngle(pitchMin), max: toDisplayAngle(pitchMax), step: toDisplayAngle(0.01), convertTo: (value) => toDisplayAngle(value, true), convertFrom: fromDisplayAngle }), radiusMax !== Infinity ? (jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Radius", description: "Distance from the center point.", target: camera, propertyKey: "radius", min: radiusMin, max: radiusMax, step: 0.01 })) : (jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Radius", description: "Distance from the center point.", target: camera, propertyKey: "radius", min: 0, step: 0.01 })), jsx(BoundProperty, { component: Vector3PropertyLine, label: "Center", description: "The point on the globe the camera orbits around.", target: camera, propertyKey: "center" }), jsx(BoundProperty, { component: Vector3PropertyLine, label: "Position", description: "The camera's position.", target: camera, propertyKey: "position" })] }));
};
const GeospatialCameraCollisionProperties = (props) => {
    const { camera } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Check Collisions", target: camera, propertyKey: "checkCollisions" }), jsx(BoundProperty, { component: Vector3PropertyLine, label: "Collision Offset", target: camera, propertyKey: "perFrameCollisionOffset" })] }));
};
const GeospatialCameraLimitsProperties = (props) => {
    const { camera } = props;
    const limits = useProperty(camera, "limits");
    if (!limits) {
        return null;
    }
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Pitch Min", description: "Minimum pitch angle (0 = looking straight down)", target: limits, propertyKey: "pitchMin", propertyPath: "limits.pitchMin" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Pitch Max", description: "Maximum pitch angle (\u03C0/2 = horizon)", target: limits, propertyKey: "pitchMax", propertyPath: "limits.pitchMax" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Yaw Min", description: "Minimum yaw angle", target: limits, propertyKey: "yawMin", propertyPath: "limits.yawMin" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Yaw Max", description: "Maximum yaw angle", target: limits, propertyKey: "yawMax", propertyPath: "limits.yawMax" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Radius Min", description: "Minimum distance from center", target: limits, propertyKey: "radiusMin", propertyPath: "limits.radiusMin" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Radius Max", description: "Maximum distance from center", target: limits, propertyKey: "radiusMax", propertyPath: "limits.radiusMax" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Pinch to Pan Max", description: "Distance threshold for pinch vs pan mode", target: limits, propertyKey: "pinchToPanMax", propertyPath: "limits.pinchToPanMax" })] }));
};

const MaskValidatorFn = (valueString) => {
    if (valueString.substring(0, 2) != "0x") {
        if (valueString.substring(0, 1) != "0") {
            valueString = "0x" + valueString;
        }
        else {
            valueString = "0x" + valueString.substring(1);
        }
    }
    const valueSubstr = valueString.substring(2);
    if (valueSubstr != "" && /^[0-9A-Fa-f]+$/g.test(valueSubstr) == false) {
        return false;
    }
    if (valueString.length > 10) {
        return false;
    }
    return true;
};
const GetHexValFromNumber = (val, numBits) => {
    const numDigits = (numBits ?? 32) >> 2;
    let valueAsHex = val.toString(16);
    let hex0String = "";
    for (let i = 0; i < numDigits - valueAsHex.length; i++) {
        // padding the '0's
        hex0String = "0" + hex0String;
    }
    const finalHexValue = hex0String + valueAsHex;
    valueAsHex = "0x" + finalHexValue.substring(finalHexValue.length - numDigits);
    return valueAsHex;
};
/**
 * Takes a number representing a Hex value and converts it to a hex string then wraps the TextInput in a PropertyLine
 * @param props - PropertyLineProps
 * @returns property-line wrapped textbox that converts to/from hex number representation
 */
const HexPropertyLine = (props) => {
    HexPropertyLine.displayName = "HexPropertyLine";
    const [hexVal, setHexVal] = useState(GetHexValFromNumber(props.value, props.numBits));
    const onStrValChange = (val) => {
        const numBits = props.numBits ?? 32;
        setHexVal(val);
        props.onChange(parseInt(val) & (2 ** numBits - 1));
    };
    useEffect(() => {
        setHexVal(GetHexValFromNumber(props.value, props.numBits));
    }, []);
    return (jsx(PropertyLine, { ...props, children: jsx(TextInput, { ...props, validator: MaskValidatorFn, value: hexVal, onChange: onStrValChange, validateOnlyOnBlur: true }) }));
};

const CameraModes = [
    { label: "Perspective", value: Camera.PERSPECTIVE_CAMERA },
    { label: "Orthographic", value: Camera.ORTHOGRAPHIC_CAMERA },
];
/**
 * The general properties component for a camera.
 * @param props - The component props containing the camera and settings context.
 * @returns JSX.Element
 */
const CameraGeneralProperties = (props) => {
    const { camera, settings } = props;
    const [toDisplayAngle, fromDisplayAngle, useDegrees] = useAngleConverters(settings);
    const mode = useProperty(camera, "mode");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Near Plane", description: "Anything closer than this will not be drawn.", target: camera, propertyKey: "minZ" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Far Plane", description: "Anything further than this will not be drawn.", target: camera, propertyKey: "maxZ" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Inertia", target: camera, propertyKey: "inertia", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: HexPropertyLine, label: "Layer Mask", target: camera, propertyKey: "layerMask" }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Mode", options: CameraModes, target: camera, propertyKey: "mode" }), jsx(Collapse, { visible: mode === Camera.PERSPECTIVE_CAMERA, children: jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "FOV", description: `Field of view in ${useDegrees ? "degrees" : "radians"}`, target: camera, propertyKey: "fov", min: toDisplayAngle(0.1), max: toDisplayAngle(Math.PI), step: toDisplayAngle(0.01), convertTo: toDisplayAngle, convertFrom: fromDisplayAngle }) }), jsx(Collapse, { visible: mode === Camera.ORTHOGRAPHIC_CAMERA, children: jsxs("div", { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Left", target: camera, step: 0.1, propertyKey: "orthoLeft", nullable: true, defaultValue: 0 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Right", target: camera, step: 0.1, propertyKey: "orthoRight", nullable: true, defaultValue: 0 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Top", target: camera, step: 0.1, propertyKey: "orthoTop", nullable: true, defaultValue: 0 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Bottom", target: camera, step: 0.1, propertyKey: "orthoBottom", nullable: true, defaultValue: 0 })] }) })] }));
};

const FollowCameraTransformProperties = (props) => {
    const { camera } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Radius", target: camera, propertyKey: "radius" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Rotation Offset", target: camera, propertyKey: "rotationOffset" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Height Offset", target: camera, propertyKey: "heightOffset" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Camera Acceleration", target: camera, propertyKey: "cameraAcceleration" })] }));
};
const FollowCameraLimitsProperties = (props) => {
    const { camera } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Lower Radius Limit", target: camera, propertyKey: "lowerRadiusLimit", nullable: true, defaultValue: 0 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Upper Radius Limit", target: camera, propertyKey: "upperRadiusLimit", nullable: true, defaultValue: 0 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Lower Rotation Offset Limit", target: camera, propertyKey: "lowerRotationOffsetLimit", nullable: true, defaultValue: 0 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Upper Rotation Offset Limit", target: camera, propertyKey: "upperRotationOffsetLimit", nullable: true, defaultValue: 0 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Lower Height Offset Limit", target: camera, propertyKey: "lowerHeightOffsetLimit", nullable: true, defaultValue: 0 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Upper Height Offset Limit", target: camera, propertyKey: "upperHeightOffsetLimit", nullable: true, defaultValue: 0 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Max Camera Speed", target: camera, propertyKey: "maxCameraSpeed" })] }));
};

const FreeCameraTransformProperties = (props) => {
    const { camera, settings } = props;
    const useDegrees = useObservableState(() => settings.useDegrees, settings.settingsChangedObservable);
    const useEuler = useObservableState(() => settings.useEuler, settings.settingsChangedObservable);
    const quatRotation = useProperty(camera, "rotationQuaternion");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: Vector3PropertyLine, label: "Position", target: camera, propertyKey: "position" }), quatRotation ? (jsx(Property, { component: QuaternionPropertyLine, propertyPath: "rotationQuaternion", label: "Rotation (Quat)", value: quatRotation, onChange: (val) => (camera.rotationQuaternion = val), useDegrees: useDegrees, useEuler: useEuler })) : (jsx(BoundProperty, { component: RotationVectorPropertyLine, label: "Rotation", target: camera, propertyKey: "rotation", useDegrees: useDegrees }))] }));
};
const FreeCameraControlProperties = (props) => {
    const { camera } = props;
    return (jsx(Fragment, { children: jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Angular Sensitivity ", target: camera, propertyKey: "angularSensibility" }) }));
};
const FreeCameraCollisionProperties = (props) => {
    const { camera } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Check Collisions", target: camera, propertyKey: "checkCollisions" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Apply Gravity", target: camera, propertyKey: "applyGravity" }), jsx(BoundProperty, { component: Vector3PropertyLine, label: "Ellipsoid", target: camera, propertyKey: "ellipsoid" }), jsx(BoundProperty, { component: Vector3PropertyLine, label: "Ellipsoid Offset", target: camera, propertyKey: "ellipsoidOffset" })] }));
};

const TargetCameraTransformProperties = (props) => {
    const { camera } = props;
    return (jsx(Fragment, { children: jsx(BoundProperty, { component: Vector3PropertyLine, label: "Target", description: "The point the camera looks at.", target: camera, propertyKey: "target" }) }));
};
const TargetCameraControlProperties = (props) => {
    const { camera } = props;
    return (jsx(Fragment, { children: jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Speed", target: camera, propertyKey: "speed" }) }));
};

const CameraPropertiesServiceDefinition = {
    friendlyName: "Camera Properties",
    consumes: [PropertiesServiceIdentity, SettingsContextIdentity],
    factory: (propertiesService, settingsContext) => {
        const cameraContentRegistration = propertiesService.addSectionContent({
            key: "Camera Properties",
            predicate: (entity) => entity instanceof Camera,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(CameraGeneralProperties, { camera: context, settings: settingsContext }),
                },
            ],
        });
        const targetCameraContentRegistration = propertiesService.addSectionContent({
            key: "Target Camera Properties",
            predicate: (entity) => entity instanceof TargetCamera,
            content: [
                {
                    section: "Transform",
                    component: ({ context }) => jsx(TargetCameraTransformProperties, { camera: context }),
                },
                {
                    section: "Control",
                    component: ({ context }) => jsx(TargetCameraControlProperties, { camera: context }),
                },
            ],
        });
        const arcRotateCameraContentRegistration = propertiesService.addSectionContent({
            key: "Arc Rotate Camera Properties",
            predicate: (entity) => entity instanceof ArcRotateCamera,
            content: [
                {
                    section: "Transform",
                    component: ({ context }) => jsx(ArcRotateCameraTransformProperties, { camera: context, settings: settingsContext }),
                },
                {
                    section: "Control",
                    component: ({ context }) => jsx(ArcRotateCameraControlProperties, { camera: context }),
                },
                {
                    section: "Collision",
                    component: ({ context }) => jsx(ArcRotateCameraCollisionProperties, { camera: context }),
                },
                {
                    section: "Limits",
                    component: ({ context }) => jsx(ArcRotateCameraLimitsProperties, { camera: context }),
                },
                {
                    section: "Behaviors",
                    component: ({ context }) => jsx(ArcRotateCameraBehaviorsProperties, { camera: context }),
                },
            ],
        });
        const freeCameraContentRegistration = propertiesService.addSectionContent({
            key: "Free Camera Properties",
            predicate: (entity) => entity instanceof FreeCamera,
            content: [
                {
                    section: "Transform",
                    component: ({ context }) => jsx(FreeCameraTransformProperties, { camera: context, settings: settingsContext }),
                },
                {
                    section: "Control",
                    component: ({ context }) => jsx(FreeCameraControlProperties, { camera: context }),
                },
                {
                    section: "Collision",
                    component: ({ context }) => jsx(FreeCameraCollisionProperties, { camera: context }),
                },
            ],
        });
        const followCameraContentRegistration = propertiesService.addSectionContent({
            key: "Follow Camera Properties",
            predicate: (entity) => entity instanceof FollowCamera,
            content: [
                {
                    section: "Transform",
                    component: ({ context }) => jsx(FollowCameraTransformProperties, { camera: context }),
                },
                {
                    section: "Limits",
                    component: ({ context }) => jsx(FollowCameraLimitsProperties, { camera: context }),
                },
            ],
        });
        const geospatialCameraContentRegistration = propertiesService.addSectionContent({
            key: "Geospatial Camera Properties",
            predicate: (entity) => entity instanceof GeospatialCamera,
            content: [
                {
                    section: "Transform",
                    component: ({ context }) => jsx(GeospatialCameraTransformProperties, { camera: context, settings: settingsContext }),
                },
                {
                    section: "Collision",
                    component: ({ context }) => jsx(GeospatialCameraCollisionProperties, { camera: context }),
                },
                {
                    section: "Limits",
                    component: ({ context }) => jsx(GeospatialCameraLimitsProperties, { camera: context }),
                },
            ],
        });
        return {
            dispose: () => {
                cameraContentRegistration.dispose();
                targetCameraContentRegistration.dispose();
                arcRotateCameraContentRegistration.dispose();
                freeCameraContentRegistration.dispose();
                followCameraContentRegistration.dispose();
                geospatialCameraContentRegistration.dispose();
            },
        };
    },
};

function IsEntityWithProperty(entity, property) {
    return !!entity && typeof entity === "object" && property in entity && entity[property] !== undefined;
}
function IsCommonEntity(entity) {
    return (IsEntityWithProperty(entity, "id") ||
        IsEntityWithProperty(entity, "uniqueId") ||
        IsEntityWithProperty(entity, "name") ||
        IsEntityWithProperty(entity, "getClassName"));
}
const CommonGeneralProperties = (props) => {
    const { commonEntity } = props;
    const namePropertyDescriptor = useMemo(() => GetPropertyDescriptor(commonEntity, "name")?.[1], [commonEntity]);
    const isNameReadonly = !namePropertyDescriptor || IsPropertyReadonly(namePropertyDescriptor);
    const className = commonEntity.getClassName?.();
    return (jsxs(Fragment, { children: [IsEntityWithProperty(commonEntity, "id") && (jsx(BoundProperty, { component: StringifiedPropertyLine, label: "ID", description: "The id of the node.", target: commonEntity, propertyKey: "id" })), IsEntityWithProperty(commonEntity, "name") && (jsx(BoundProperty, { component: isNameReadonly ? TextPropertyLine : TextInputPropertyLine, label: "Name", description: "The name of the node.", target: commonEntity, propertyKey: "name" })), IsEntityWithProperty(commonEntity, "uniqueId") && (jsx(BoundProperty, { component: StringifiedPropertyLine, label: "Unique ID", description: "The unique id of the node.", target: commonEntity, propertyKey: "uniqueId" })), className !== undefined && jsx(TextPropertyLine, { label: "Class", description: "The class of the node.", value: className })] }));
};
const DisposableGeneralProperties = (props) => {
    const { disposableEntity } = props;
    return (jsx(Fragment, { children: jsx(ButtonLine, { label: "Dispose", icon: DeleteRegular, onClick: () => disposableEntity.dispose() }) }));
};

const CommonPropertiesServiceDefinition = {
    friendlyName: "Common Properties",
    consumes: [PropertiesServiceIdentity],
    factory: (propertiesService) => {
        const commonContentRegistration = propertiesService.addSectionContent({
            key: "Common Properties",
            predicate: (entity) => {
                // Common properties are not useful for the scene.
                if (entity instanceof Scene) {
                    return false;
                }
                return IsCommonEntity(entity);
            },
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(CommonGeneralProperties, { commonEntity: context }),
                },
            ],
        });
        const disposableContentRegistration = propertiesService.addSectionContent({
            key: "Disposable Properties",
            predicate: (entity) => {
                const disposable = entity;
                return typeof disposable.dispose === "function";
            },
            content: [
                {
                    section: "General",
                    order: 100000,
                    component: ({ context }) => jsx(DisposableGeneralProperties, { disposableEntity: context }),
                },
            ],
        });
        return {
            dispose: () => {
                commonContentRegistration.dispose();
                disposableContentRegistration.dispose();
            },
        };
    },
};

const EffectLayerPropertiesServiceDefinition = {
    friendlyName: "Effect Layer Properties",
    consumes: [PropertiesServiceIdentity],
    factory: (propertiesService) => {
        // TODO: Add content registrations for each section and for each type in the EffectLayer class hierarchy.
        return {
            dispose: () => {
                // TODO: Dispose content registrations.
            },
        };
    },
};

const FrameGraphTaskProperties = (props) => {
    const { frameGraph } = props;
    const tasks = frameGraph.tasks;
    return (jsx(Fragment, { children: tasks.length > 0 &&
            tasks.map((task, i) => {
                return (jsx(BoundProperty, { component: SwitchPropertyLine, label: i + 1 + ". " + task.name, target: frameGraph.tasks[i], propertyKey: "disabled", convertTo: (v) => !v, convertFrom: (v) => !v }, "task" + i));
            }) }));
};
const FrameGraphGeneralProperties = (props) => {
    const { frameGraph } = props;
    const isSceneFrameGraph = useProperty(frameGraph.scene, "frameGraph");
    const renderGraph = frameGraph.getLinkedNodeRenderGraph();
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Optimize Texture Allocation", description: "Whether to optimize texture allocation.", target: frameGraph, propertyKey: "optimizeTextureAllocation" }), isSceneFrameGraph !== frameGraph && jsx(ButtonLine, { onClick: () => (frameGraph.scene.frameGraph = frameGraph), label: "Make Active", icon: PlayRegular }), renderGraph && (jsx(ButtonLine, { label: "Edit Graph", icon: EditRegular, onClick: async () => {
                    // TODO: Figure out how to get all the various build steps to work with this.
                    //       See the initial attempt here: https://github.com/BabylonJS/Babylon.js/pull/17646
                    // const { NodeRenderGraphEditor } = await import("node-render-graph-editor/nodeRenderGraphEditor");
                    // NodeRenderGraphEditor.Show({ nodeRenderGraph: renderGraph, hostScene: frameGraph.scene });
                    await renderGraph.edit({ nodeRenderGraphEditorConfig: { hostScene: frameGraph.scene } });
                } }))] }));
};

const FrameGraphPropertiesServiceDefinition = {
    friendlyName: "Frame Graph Properties",
    consumes: [PropertiesServiceIdentity],
    factory: (propertiesService) => {
        const frameGraphContentRegistration = propertiesService.addSectionContent({
            key: "Frame Graph General Properties",
            predicate: (entity) => entity instanceof FrameGraph,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(FrameGraphGeneralProperties, { frameGraph: context }),
                },
                {
                    section: "Tasks",
                    component: ({ context }) => jsx(FrameGraphTaskProperties, { frameGraph: context }),
                },
            ],
        });
        return {
            dispose: () => {
                frameGraphContentRegistration.dispose();
            },
        };
    },
};

const AreaLightSetupProperties = ({ context: areaLight }) => {
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { label: "Diffuse", component: Color3PropertyLine, target: areaLight, propertyKey: "diffuse" }), jsx(BoundProperty, { label: "Specular", component: Color3PropertyLine, target: areaLight, propertyKey: "specular" }), jsx(BoundProperty, { label: "Position", component: Vector3PropertyLine, target: areaLight, propertyKey: "position" }), jsx(BoundProperty, { label: "Width", component: NumberInputPropertyLine, target: areaLight, propertyKey: "width" }), jsx(BoundProperty, { label: "Height", component: NumberInputPropertyLine, target: areaLight, propertyKey: "height" }), jsx(BoundProperty, { label: "Intensity", component: NumberInputPropertyLine, target: areaLight, propertyKey: "intensity" })] }));
};

const DirectionalLightSetupProperties = ({ context: directionalLight }) => {
    const scene = directionalLight.getScene();
    const camera = scene.activeCamera;
    // Check if using CascadedShadowGenerator to hide autoCalcShadowZBounds
    let generator = directionalLight.getShadowGenerator(camera) ?? null;
    if (generator === null) {
        const shadowGenerators = directionalLight.getShadowGenerators();
        if (shadowGenerators && shadowGenerators.size > 0) {
            generator = shadowGenerators.values().next().value ?? null;
        }
    }
    const hideAutoCalcShadowZBounds = generator instanceof CascadedShadowGenerator;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { label: "Position", component: Vector3PropertyLine, target: directionalLight, propertyKey: "position" }), jsx(BoundProperty, { label: "Direction", component: Vector3PropertyLine, target: directionalLight, propertyKey: "direction" }), jsx(BoundProperty, { label: "Diffuse", component: Color3PropertyLine, target: directionalLight, propertyKey: "diffuse" }), jsx(BoundProperty, { label: "Specular", component: Color3PropertyLine, target: directionalLight, propertyKey: "specular" }), jsx(BoundProperty, { label: "Intensity", component: NumberInputPropertyLine, target: directionalLight, propertyKey: "intensity" }), jsx(BoundProperty, { label: "Auto Update Extends", description: "Automatically compute the projection matrix to fit the light's shadow frustum to the scene.", component: SwitchPropertyLine, target: directionalLight, propertyKey: "autoUpdateExtends" }), !hideAutoCalcShadowZBounds && (jsx(BoundProperty, { label: "Auto Calc Shadow ZBounds", description: "Automatically compute the shadow min/max z values.", component: SwitchPropertyLine, target: directionalLight, propertyKey: "autoCalcShadowZBounds" })), jsx(BoundProperty, { label: "Ortho Left", component: NumberInputPropertyLine, target: directionalLight, propertyKey: "orthoLeft" }), jsx(BoundProperty, { label: "Ortho Right", component: NumberInputPropertyLine, target: directionalLight, propertyKey: "orthoRight" }), jsx(BoundProperty, { label: "Ortho Bottom", component: NumberInputPropertyLine, target: directionalLight, propertyKey: "orthoBottom" }), jsx(BoundProperty, { label: "Ortho Top", component: NumberInputPropertyLine, target: directionalLight, propertyKey: "orthoTop" })] }));
};
const FrustumViewerMap = new WeakMap();
const DirectionalLightDebugProperties = ({ context: directionalLight }) => {
    const [displayFrustum, setDisplayFrustum] = useState(FrustumViewerMap.has(directionalLight));
    const toggleDisplayFrustum = () => {
        const light = directionalLight;
        const camera = light.getScene().activeCamera;
        const existingState = FrustumViewerMap.get(light);
        if (existingState) {
            // Clean up existing frustum viewer
            light.getScene().onAfterRenderObservable.remove(existingState.observer);
            existingState.viewer.dispose();
            FrustumViewerMap.delete(light);
            setDisplayFrustum(false);
        }
        else {
            // Create new frustum viewer
            const viewer = new DirectionalLightFrustumViewer(light, camera);
            const observer = light.getScene().onAfterRenderObservable.add(() => {
                viewer.update();
            });
            FrustumViewerMap.set(light, { viewer, observer });
            setDisplayFrustum(true);
        }
    };
    return (jsx(Fragment, { children: jsx(SwitchPropertyLine, { label: "Display Frustum", value: displayFrustum, onChange: toggleDisplayFrustum }) }));
};

const HemisphericLightSetupProperties = ({ context: hemisphericLight }) => {
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { label: "Direction", component: Vector3PropertyLine, target: hemisphericLight, propertyKey: "direction" }), jsx(BoundProperty, { label: "Diffuse", component: Color3PropertyLine, target: hemisphericLight, propertyKey: "diffuse" }), jsx(BoundProperty, { label: "Ground", component: Color3PropertyLine, target: hemisphericLight, propertyKey: "groundColor" }), jsx(BoundProperty, { label: "Intensity", component: NumberInputPropertyLine, target: hemisphericLight, propertyKey: "intensity" })] }));
};

const PointLightSetupProperties = ({ context: pointLight }) => {
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { label: "Diffuse", component: Color3PropertyLine, target: pointLight, propertyKey: "diffuse" }), jsx(BoundProperty, { label: "Specular", component: Color3PropertyLine, target: pointLight, propertyKey: "specular" }), jsx(BoundProperty, { label: "Position", component: Vector3PropertyLine, target: pointLight, propertyKey: "position" }), jsx(BoundProperty, { label: "Intensity", component: NumberInputPropertyLine, target: pointLight, propertyKey: "intensity" })] }));
};

const DefaultShadowGeneratorOptions = [{ label: "Shadow Generator", value: "Default" }];
const DirectionalLightGeneratorOptions = [
    ...DefaultShadowGeneratorOptions,
    { label: "Cascaded Shadow Generator", value: "Cascade" },
];
const MapSizeOptions = [
    { label: "4096 x 4096", value: 4096 },
    { label: "2048 x 2048", value: 2048 },
    { label: "1024 x 1024", value: 1024 },
    { label: "512 x 512", value: 512 },
    { label: "256 x 256", value: 256 },
];
const BlurModeOptions = [
    { label: "None", value: ShadowGenerator.FILTER_NONE },
    { label: "PCF", value: ShadowGenerator.FILTER_PCF },
    { label: "PCSS", value: ShadowGenerator.FILTER_PCSS },
    { label: "Poisson", value: ShadowGenerator.FILTER_POISSONSAMPLING },
    { label: "Exponential", value: ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP },
    { label: "Blurred Exponential", value: ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP },
    { label: "Close Exponential", value: ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP },
    { label: "Blurred Close Exponential", value: ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP },
];
const CSMBlurModeOptions = [
    { label: "None", value: ShadowGenerator.FILTER_NONE },
    { label: "PCF", value: ShadowGenerator.FILTER_PCF },
    { label: "PCSS", value: ShadowGenerator.FILTER_PCSS },
];
const FilteringQualityOptions = [
    { label: "Low", value: ShadowGenerator.QUALITY_LOW },
    { label: "Medium", value: ShadowGenerator.QUALITY_MEDIUM },
    { label: "High", value: ShadowGenerator.QUALITY_HIGH },
];
const NumCascadesOptions = [
    { label: "2", value: 2 },
    { label: "3", value: 3 },
    { label: "4", value: 4 },
];
function GetShadowGenerator(camera, shadowLight) {
    return shadowLight.getShadowGenerator(camera) ?? shadowLight.getShadowGenerators()?.values().next().value ?? null;
}
function CreateShadowGenerator(shadowLight, settings) {
    const light = shadowLight;
    const scene = light.getScene();
    const internals = settings;
    const generatorType = internals.generatorType;
    const mapSize = internals.mapSize;
    const generator = generatorType === "Default" ? new ShadowGenerator(mapSize, light) : new CascadedShadowGenerator(mapSize, light);
    for (const m of scene.meshes) {
        if (m.infiniteDistance) {
            continue;
        }
        generator.addShadowCaster(m);
        if (!m.isAnInstance) {
            m.receiveShadows = true;
        }
    }
}
function DisposeShadowGenerator(camera, shadowLight) {
    GetShadowGenerator(camera, shadowLight)?.dispose();
}
const ShadowGeneratorSetupProperties = ({ context: shadowLight }) => {
    const defaultGeneratorType = DefaultShadowGeneratorOptions[0].value;
    const defaultMapSize = MapSizeOptions[0].value;
    const [shadowGeneratorSettings, setShadowGeneratorSettings] = useState({ generatorType: defaultGeneratorType, mapSize: defaultMapSize });
    const shadowGeneratorOptions = shadowLight instanceof DirectionalLight ? DirectionalLightGeneratorOptions : DefaultShadowGeneratorOptions;
    const camera = useObservableState(() => shadowLight.getScene().activeCamera, shadowLight.getScene().onActiveCameraChanged);
    const shadowGenerator = GetShadowGenerator(camera, shadowLight);
    const [hasShadowGenerator, setHasShadowGenerator] = useState(!!shadowGenerator);
    useEffect(() => {
        setHasShadowGenerator(!!shadowGenerator);
    }, [shadowGenerator]);
    const isCascaded = shadowGenerator instanceof CascadedShadowGenerator;
    const isStandardGenerator = shadowGenerator instanceof ShadowGenerator && !isCascaded;
    // Use useProperty to track filter changes and trigger re-renders for conditional UI
    const filter = useProperty(shadowGenerator, "filter") ?? ShadowGenerator.FILTER_NONE;
    const useKernelBlur = useProperty(shadowGenerator, "useKernelBlur");
    const blurModeOptions = isCascaded ? CSMBlurModeOptions : BlurModeOptions;
    const near = camera?.minZ ?? 0;
    const far = camera?.maxZ ?? 10000;
    const isPCFOrPCSS = filter === ShadowGenerator.FILTER_PCF || filter === ShadowGenerator.FILTER_PCSS;
    const isPCSS = filter === ShadowGenerator.FILTER_PCSS;
    const isBlurExponential = filter === ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP || filter === ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;
    const isExponential = filter === ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP || filter === ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP;
    return (jsxs(Fragment, { children: [!hasShadowGenerator && (jsxs(Fragment, { children: [jsx(StringDropdownPropertyLine, { label: "Type", options: shadowGeneratorOptions, value: shadowGeneratorSettings.generatorType, onChange: (value) => setShadowGeneratorSettings((prev) => ({ ...prev, generatorType: value })) }), jsx(NumberDropdownPropertyLine, { label: "Map Size", options: MapSizeOptions, value: shadowGeneratorSettings.mapSize, onChange: (value) => setShadowGeneratorSettings((prev) => ({ ...prev, mapSize: value })) }), jsx(ButtonLine, { label: "Create Generator", onClick: () => {
                            CreateShadowGenerator(shadowLight, shadowGeneratorSettings);
                            setHasShadowGenerator(true);
                        } })] })), shadowGenerator && (jsxs(Fragment, { children: [isCascaded && jsx(CascadedShadowGeneratorProperties, { generator: shadowGenerator, near: near, far: far, isPCSS: isPCSS }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Bias", description: "Bias to apply to the shadow map to avoid shadow acne.", target: shadowGenerator, propertyKey: "bias", propertyPath: "getShadowGenerator().bias", step: 0.0001 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Normal Bias", description: "Normal bias to apply to avoid shadow acne.", target: shadowGenerator, propertyKey: "normalBias", propertyPath: "getShadowGenerator().normalBias" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Darkness", description: "Darkness of the shadow (0 = no shadow, 1 = full shadow).", target: shadowGenerator, propertyKey: "darkness", propertyPath: "getShadowGenerator().darkness", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Transparent Shadows", description: "Allow transparent objects to cast shadows.", target: shadowGenerator, propertyKey: "transparencyShadow", propertyPath: "getShadowGenerator().transparencyShadow" }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Filter", description: "Shadow filtering mode.", target: shadowGenerator, propertyKey: "filter", propertyPath: "getShadowGenerator().filter", options: blurModeOptions }), jsx(Collapse, { visible: isPCFOrPCSS, children: jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Filtering Quality", target: shadowGenerator, propertyKey: "filteringQuality", propertyPath: "getShadowGenerator().filteringQuality", options: FilteringQualityOptions }) }), jsx(Collapse, { visible: isPCSS, children: jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Penumbra Ratio", description: "Light size UV ratio for PCSS.", target: shadowGenerator, propertyKey: "contactHardeningLightSizeUVRatio", propertyPath: "getShadowGenerator().contactHardeningLightSizeUVRatio", min: 0, max: 0.5, step: 0.001 }) }), isStandardGenerator && (jsxs(Fragment, { children: [jsx(Collapse, { visible: isBlurExponential, children: jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Kernel Blur", description: "Use kernel-based blur instead of box blur.", target: shadowGenerator, propertyKey: "useKernelBlur", propertyPath: "getShadowGenerator().useKernelBlur" }), useKernelBlur ? (jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Blur Kernel", target: shadowGenerator, propertyKey: "blurKernel", propertyPath: "getShadowGenerator().blurKernel", min: 1, max: 64, step: 1 })) : (jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Blur Box Offset", target: shadowGenerator, propertyKey: "blurBoxOffset", propertyPath: "getShadowGenerator().blurBoxOffset", min: 1, max: 64, step: 1 }))] }) }), jsx(Collapse, { visible: isExponential, children: jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Depth Scale", target: shadowGenerator, propertyKey: "depthScale", propertyPath: "getShadowGenerator().depthScale" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Blur Scale", target: shadowGenerator, propertyKey: "blurScale", propertyPath: "getShadowGenerator().blurScale", min: 1, max: 4, step: 1 })] }) })] })), jsx(ButtonLine, { label: "Dispose Generator", onClick: () => {
                            DisposeShadowGenerator(camera, shadowLight);
                            setHasShadowGenerator(false);
                        } })] }))] }));
};
const CascadedShadowGeneratorProperties = ({ generator, near, far, isPCSS, }) => {
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Num Cascades", description: "Number of cascades for the cascaded shadow map.", target: generator, propertyKey: "numCascades", propertyPath: "getShadowGenerator().numCascades", options: NumCascadesOptions }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Debug Mode", description: "Colorize cascades for debugging.", target: generator, propertyKey: "debug", propertyPath: "getShadowGenerator().debug" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Stabilize Cascades", description: "Stabilize the cascade splits to avoid shimmering.", target: generator, propertyKey: "stabilizeCascades", propertyPath: "getShadowGenerator().stabilizeCascades" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Lambda", description: "Balance between logarithmic and uniform cascade splits.", target: generator, propertyKey: "lambda", propertyPath: "getShadowGenerator().lambda", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Cascade Blend", description: "Percentage of blending between cascades.", target: generator, propertyKey: "cascadeBlendPercentage", propertyPath: "getShadowGenerator().cascadeBlendPercentage", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Depth Clamp", target: generator, propertyKey: "depthClamp", propertyPath: "getShadowGenerator().depthClamp" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Auto-Calc Depth Bounds", target: generator, propertyKey: "autoCalcDepthBounds", propertyPath: "getShadowGenerator().autoCalcDepthBounds" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Shadow MaxZ", target: generator, propertyKey: "shadowMaxZ", propertyPath: "getShadowGenerator().shadowMaxZ", min: near, max: far, step: 0.5 }), jsx(Collapse, { visible: isPCSS, children: jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Penumbra Darkness", description: "Darkness of the penumbra for PCSS in CSM.", target: generator, propertyKey: "penumbraDarkness", propertyPath: "getShadowGenerator().penumbraDarkness", min: 0, max: 1, step: 0.01 }) })] }));
};

const ShadowsSetupProperties = ({ context: shadowLight }) => {
    const shadowsEnabled = useProperty(shadowLight, "shadowEnabled");
    const shadowsMinZ = useProperty(shadowLight, "shadowMinZ");
    const shadowsMaxZ = useProperty(shadowLight, "shadowMaxZ");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Shadows Enabled", target: shadowLight, propertyKey: "shadowEnabled" }), jsx(Collapse, { visible: shadowsEnabled, children: jsxs(Fragment, { children: [jsx(Property, { component: NumberInputPropertyLine, label: "Shadows Near Plane", propertyPath: "shadowMinZ", value: shadowsMinZ ?? 0, onChange: (value) => (shadowLight.shadowMinZ = value) }), jsx(Property, { component: NumberInputPropertyLine, label: "Shadows Far Plane", propertyPath: "shadowMaxZ", value: shadowsMaxZ ?? 0, onChange: (value) => (shadowLight.shadowMaxZ = value) })] }) })] }));
};

const SpotLightSetupProperties = ({ context: spotLight }) => {
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { label: "Diffuse", component: Color3PropertyLine, target: spotLight, propertyKey: "diffuse" }), jsx(BoundProperty, { label: "Specular", component: Color3PropertyLine, target: spotLight, propertyKey: "specular" }), jsx(BoundProperty, { label: "Direction", component: Vector3PropertyLine, target: spotLight, propertyKey: "direction" }), jsx(BoundProperty, { label: "Position", component: Vector3PropertyLine, target: spotLight, propertyKey: "position" }), jsx(BoundProperty, { label: "Angle", component: SyncedSliderPropertyLine, target: spotLight, propertyKey: "angle", convertTo: Tools.ToDegrees, convertFrom: Tools.ToRadians, min: 0, max: 90, step: 0.1 }), jsx(BoundProperty, { label: "InnerAngle", component: SyncedSliderPropertyLine, target: spotLight, propertyKey: "innerAngle", convertTo: Tools.ToDegrees, convertFrom: Tools.ToRadians, min: 0, max: 90, step: 0.1 }), jsx(BoundProperty, { label: "Exponent", component: NumberInputPropertyLine, target: spotLight, propertyKey: "exponent" })] }));
};

const LightPropertiesServiceDefinition = {
    friendlyName: "Light Properties",
    consumes: [PropertiesServiceIdentity],
    factory: (propertiesService) => {
        const directionalLightContentRegistration = propertiesService.addSectionContent({
            key: "Directional Light Properties",
            predicate: (entity) => entity instanceof DirectionalLight,
            content: [
                {
                    section: "Setup",
                    component: DirectionalLightSetupProperties,
                },
                {
                    section: "Debug",
                    component: DirectionalLightDebugProperties,
                },
            ],
        });
        const pointLightContentRegistration = propertiesService.addSectionContent({
            key: "Point Light Properties",
            predicate: (entity) => entity instanceof PointLight,
            content: [
                {
                    section: "Setup",
                    component: PointLightSetupProperties,
                },
            ],
        });
        const hemisphericLightContentRegistration = propertiesService.addSectionContent({
            key: "Hemispheric Light Properties",
            predicate: (entity) => entity instanceof HemisphericLight,
            content: [
                {
                    section: "Setup",
                    component: HemisphericLightSetupProperties,
                },
            ],
        });
        const spotLightContentRegistration = propertiesService.addSectionContent({
            key: "Spot Light Properties",
            predicate: (entity) => entity instanceof SpotLight,
            content: [
                {
                    section: "Setup",
                    component: SpotLightSetupProperties,
                },
            ],
        });
        const shadowLightContentRegistration = propertiesService.addSectionContent({
            key: "Shadow Light Properties",
            predicate: (entity) => entity instanceof ShadowLight,
            content: [
                {
                    section: "Shadows",
                    component: ShadowsSetupProperties,
                },
                {
                    section: "Shadow Generator",
                    component: ShadowGeneratorSetupProperties,
                },
            ],
        });
        const areaLightContentRegistration = propertiesService.addSectionContent({
            key: "Area Light Properties",
            predicate: (entity) => entity instanceof RectAreaLight,
            content: [
                {
                    section: "Setup",
                    component: AreaLightSetupProperties,
                },
            ],
        });
        return {
            dispose: () => {
                areaLightContentRegistration.dispose();
                shadowLightContentRegistration.dispose();
                spotLightContentRegistration.dispose();
                hemisphericLightContentRegistration.dispose();
                pointLightContentRegistration.dispose();
                directionalLightContentRegistration.dispose();
            },
        };
    },
};

/**
 * Used by both particleSystem and alphaBlendModes
 */
const CommonBlendModes = [
    { label: "Maximized", value: Constants.ALPHA_MAXIMIZED },
    { label: "Pre-multiplied", value: Constants.ALPHA_PREMULTIPLIED },
    { label: "Pre-multiplied Porter Duff", value: Constants.ALPHA_PREMULTIPLIED_PORTERDUFF },
    { label: "Screen Mode", value: Constants.ALPHA_SCREENMODE },
    { label: "OneOne OneOne", value: Constants.ALPHA_ONEONE_ONEONE },
    { label: "Alpha to Color", value: Constants.ALPHA_ALPHATOCOLOR },
    { label: "Reverse One Minus", value: Constants.ALPHA_REVERSEONEMINUS },
    { label: "Source+Dest * (1 - SourceAlpha)", value: Constants.ALPHA_SRC_DSTONEMINUSSRCALPHA },
    { label: "OneOne OneZero", value: Constants.ALPHA_ONEONE_ONEZERO },
    { label: "Exclusion", value: Constants.ALPHA_EXCLUSION },
    { label: "Layer Accumulate", value: Constants.ALPHA_LAYER_ACCUMULATE },
];
/**
 * Used to populated the blendMode dropdown in our various tools (Node Editor, Inspector, etc.)
 * The below ParticleSystem consts were defined before new Engine alpha blend modes were added, so we have to reference
 * the ParticleSystem.FOO consts explicitly (as the underlying const values are different - they get mapped to engine consts within baseParticleSystem.ts)
 */
const BlendModeOptions = [
    { label: "Add", value: ParticleSystem.BLENDMODE_ADD },
    { label: "Multiply", value: ParticleSystem.BLENDMODE_MULTIPLY },
    { label: "Multiply Add", value: ParticleSystem.BLENDMODE_MULTIPLYADD },
    { label: "One One", value: ParticleSystem.BLENDMODE_ONEONE },
    { label: "Standard", value: ParticleSystem.BLENDMODE_STANDARD },
    { label: "Subtract", value: ParticleSystem.BLENDMODE_SUBTRACT },
].concat(CommonBlendModes);
/**
 * Used to populated the alphaMode dropdown in our various tools (Node Editor, Inspector, etc.)
 */
const AlphaModeOptions = [
    { label: "Combine", value: Constants.ALPHA_COMBINE },
    { label: "One One", value: Constants.ALPHA_ONEONE },
    { label: "Add", value: Constants.ALPHA_ADD },
    { label: "Subtract", value: Constants.ALPHA_SUBTRACT },
    { label: "Multiply", value: Constants.ALPHA_MULTIPLY },
].concat(CommonBlendModes);
/**
 * Used to populate the billboardMode dropdown for particle systems.
 */
const ParticleBillboardModeOptions = [
    { label: "All", value: ParticleSystem.BILLBOARDMODE_ALL },
    { label: "Y", value: ParticleSystem.BILLBOARDMODE_Y },
    { label: "Stretched", value: ParticleSystem.BILLBOARDMODE_STRETCHED },
    { label: "Stretched Local", value: ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL },
];

const OrientationOptions = [
    { label: "Clockwise", value: Material.ClockWiseSideOrientation },
    { label: "Counterclockwise", value: Material.CounterClockWiseSideOrientation },
];
const TransparencyModeOptions = [
    { label: "Opaque", value: Material.MATERIAL_OPAQUE },
    { label: "Alpha test", value: Material.MATERIAL_ALPHATEST },
    { label: "Alpha blend", value: Material.MATERIAL_ALPHABLEND },
    { label: "Alpha blend and test", value: Material.MATERIAL_ALPHATESTANDBLEND },
];
const DepthFunctionOptions = [
    { label: "<Engine Default>", value: 0 },
    { label: "Never", value: Engine.NEVER },
    { label: "Always", value: Engine.ALWAYS },
    { label: "Equal", value: Engine.EQUAL },
    { label: "Less", value: Engine.LESS },
    { label: "Less or equal", value: Engine.LEQUAL },
    { label: "Greater", value: Engine.GREATER },
    { label: "Greater or equal", value: Engine.GEQUAL },
    { label: "Not equal", value: Engine.NOTEQUAL },
];
const StencilFunctionOptions = [
    { label: "Never", value: Constants.NEVER },
    { label: "Always", value: Constants.ALWAYS },
    { label: "Equal", value: Constants.EQUAL },
    { label: "Less", value: Constants.LESS },
    { label: "Less or equal", value: Constants.LEQUAL },
    { label: "Greater", value: Constants.GREATER },
    { label: "Greater or equal", value: Constants.GEQUAL },
    { label: "Not equal", value: Constants.NOTEQUAL },
];
const StencilOperationOptions = [
    { label: "Keep", value: Constants.KEEP },
    { label: "Zero", value: Constants.ZERO },
    { label: "Replace", value: Constants.REPLACE },
    { label: "Incr", value: Constants.INCR },
    { label: "Decr", value: Constants.DECR },
    { label: "Invert", value: Constants.INVERT },
    { label: "Incr wrap", value: Constants.INCR_WRAP },
    { label: "Decr wrap", value: Constants.DECR_WRAP },
];
const MaterialGeneralProperties = (props) => {
    const { material } = props;
    const pointsCloud = useProperty(material, "pointsCloud");
    const faceCulling = useProperty(material, "backFaceCulling");
    const isWebGPU = material.getScene().getEngine().isWebGPU;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Face Culling", description: "Enabling this will enable culling, default is to cull backfaces. To enable front face culling instead, you can disable 'cullBackfaces' using the below option", docLink: "https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#back-face-culling", target: material, propertyKey: "backFaceCulling" }), jsx(Collapse, { visible: faceCulling, children: jsx(BoundProperty, { component: SwitchPropertyLine, label: "Cull Back Faces", description: "Culls back faces. If false, front faces are culled.", target: material, propertyKey: "cullBackFaces" }) }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Orientation", description: "The front face side. Overrides mesh's orientation.", options: OrientationOptions, target: material, propertyKey: "sideOrientation", nullable: true, defaultValue: material.getScene().useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Disable Color Write", target: material, propertyKey: "disableColorWrite" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Disable Depth Write", target: material, propertyKey: "disableDepthWrite" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Force Depth Write", target: material, propertyKey: "forceDepthWrite" }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Depth Function", options: DepthFunctionOptions, target: material, propertyKey: "depthFunction" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Need Depth Pre-pass", docLink: "https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering/#depth-pre-pass-meshes", target: material, propertyKey: "needDepthPrePass" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Z-offset Factor", target: material, propertyKey: "zOffset", min: -10, max: 10, step: 0.1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Z-offset Units", target: material, propertyKey: "zOffsetUnits", min: -10, max: 10, step: 0.1 }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Wireframe", target: material, propertyKey: "wireframe" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Point Cloud", target: material, propertyKey: "pointsCloud" }), pointsCloud && jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Point Size", target: material, propertyKey: "pointSize", min: 0, max: 100, step: 0.1 }), isWebGPU && jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Vertex Pulling", target: material, propertyKey: "useVertexPulling" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Support Fog", target: material, propertyKey: "fogEnabled", description: "Indicates whether the material supports fog (however, fog must be enabled at the scene level to be effective)." }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Logarithmic Depth", target: material, propertyKey: "useLogarithmicDepth", docLink: "https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/logarithmicDepthBuffer" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Set Vertex Output Invariant", target: material, propertyKey: "isVertexOutputInvariant", description: "Setting this property to true will force the shader compiler to disable some optimization to make sure the vertex output is always calculated the same way across different compilation units." })] }));
};
const MaterialTransparencyProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Alpha", target: material, propertyKey: "alpha", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Transparency Mode", docLink: "https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering/#the-transparencymode-property", target: material, propertyKey: "transparencyMode", options: TransparencyModeOptions, nullable: true, defaultValue: Material.MATERIAL_OPAQUE }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Alpha Mode", docLink: "https://doc.babylonjs.com/features/featuresDeepDive/materials/using/blendModes/#available-blend-modes", target: material, propertyKey: "alphaMode", options: AlphaModeOptions }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Separate Culling Pass", target: material, propertyKey: "separateCullingPass" })] }));
};
const MaterialStencilProperties = (props) => {
    const { material } = props;
    const stencilEnabled = useProperty(material.stencil, "enabled");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Enabled", target: material.stencil, propertyKey: "enabled", propertyPath: "stencil.enabled" }), jsx(Collapse, { visible: stencilEnabled, children: jsxs(Fragment, { children: [jsx(BoundProperty, { component: HexPropertyLine, label: "Write Mask", target: material.stencil, propertyKey: "mask", propertyPath: "stencil.mask", numBits: 8 }), jsx(BoundProperty, { component: HexPropertyLine, label: "Read Mask", target: material.stencil, propertyKey: "funcMask", propertyPath: "stencil.funcMask", numBits: 8 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Reference Value", target: material.stencil, propertyKey: "funcRef", propertyPath: "stencil.funcRef", step: 1, forceInt: true, min: 0, max: 255 }), jsx(PropertyLine, { label: "Front", expandByDefault: true, expandedContent: jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Function", target: material.stencil, propertyKey: "func", propertyPath: "stencil.func", options: StencilFunctionOptions }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Stencil Fail Operation", target: material.stencil, propertyKey: "opStencilFail", propertyPath: "stencil.opStencilFail", options: StencilOperationOptions }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Depth Fail Operation", target: material.stencil, propertyKey: "opDepthFail", propertyPath: "stencil.opDepthFail", options: StencilOperationOptions }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Stencil & Depth Pass Operation", target: material.stencil, propertyKey: "opStencilDepthPass", propertyPath: "stencil.opStencilDepthPass", options: StencilOperationOptions })] }) }), jsx(PropertyLine, { label: "Back", expandByDefault: true, expandedContent: jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Function", target: material.stencil, propertyKey: "backFunc", propertyPath: "stencil.backFunc", options: StencilFunctionOptions }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Stencil Fail Operation", target: material.stencil, propertyKey: "backOpStencilFail", propertyPath: "stencil.backOpStencilFail", options: StencilOperationOptions }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Depth Fail Operation", target: material.stencil, propertyKey: "backOpDepthFail", propertyPath: "stencil.backOpDepthFail", options: StencilOperationOptions }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Stencil & Depth Pass Operation", target: material.stencil, propertyKey: "backOpStencilDepthPass", propertyPath: "stencil.backOpStencilDepthPass", options: StencilOperationOptions })] }) })] }) })] }));
};

const MultiMaterialChildrenProperties = (props) => {
    const { multiMaterial, selectionService } = props;
    return (jsx(Fragment, { children: multiMaterial.subMaterials
            .filter((material) => !!material)
            .map((material, index) => (jsx(LinkToEntityPropertyLine, { label: `Material #${index + 1}`, entity: material, selectionService: selectionService }, material.uniqueId))) }));
};

const useListStyles = makeStyles({
    item: {
        width: "100%",
        display: "flex",
        flexDirection: "row", // Arrange items horizontally
        alignItems: "center", // Center items vertically
        gap: tokens.spacingHorizontalS, // Add space between elements
        borderBottom: `${tokens.strokeWidthThin} solid ${tokens.colorNeutralStroke1}`,
    },
    itemId: {
        width: tokens.spacingHorizontalM,
    },
    itemContent: {
        flex: 1, // Take up remaining space
        minWidth: 0, // Prevent flex item from overflowing
    },
    iconContainer: {
        display: "flex",
        gap: tokens.spacingHorizontalXS, // Small gap between icons
        alignItems: "center",
        flexShrink: 0, // Prevent shrinking
    },
    list: {
        padding: tokens.spacingVerticalS,
    },
});
/**
 * For cases where you may want to add / remove items from a list via a trash can button / copy button, this HOC can be used
 * @returns A React component that renders a list of items with add/delete functionality
 * @param props - The properties for the List component
 */
function List(props) {
    const { items, renderItem, onDelete, onAdd, addButtonLabel = "Add new item" } = props;
    const classes = useListStyles();
    const sortedItems = useMemo(() => [...items].sort((a, b) => a.sortBy - b.sortBy), [items]);
    return (jsxs("div", { children: [onAdd && jsx(ButtonLine, { label: addButtonLabel, icon: AddRegular, onClick: () => onAdd() }), jsx("div", { className: classes.list, children: sortedItems.map((item, index) => (jsxs("div", { className: classes.item, children: [jsxs(Body1Strong, { className: classes.itemId, children: ["#", index] }), jsx("div", { className: classes.itemContent, children: renderItem(item, items.indexOf(sortedItems[index])) }), (onAdd || onDelete) && (jsxs("div", { className: classes.iconContainer, children: [onAdd && jsx(CopyRegular, { onClick: () => onAdd(item) }), onDelete && jsx(DeleteRegular, { onClick: () => onDelete(item, items.indexOf(sortedItems[index])) })] }))] }, item.id))) })] }));
}

const useGradientStyles = makeStyles({
    container: {
        display: "flex",
        alignItems: "center",
        gap: tokens.spacingHorizontalXS, // Reduced gap
        width: "100%",
        minWidth: 0,
        overflow: "hidden",
    },
    // Wrapper for factor spin buttons - fixed width, doesn't grow
    valueWrapper: {
        flex: "0 0 auto", // Fixed size, no grow, no shrink
    },
    // Wrapper for color pickers - fixed size since they're just swatches
    colorWrapper: {
        flex: "0 0 auto",
        alignContent: "center",
    },
    // Wrapper for the step slider - takes remaining space and can shrink
    stepSliderWrapper: {
        flex: "1 1 0", // Grow to fill available space
        minWidth: "100px", // Minimum to fit slider + spinbutton
    },
});
/**
 * Gradient component that displays 1 or 2 color or number inputs next to a slider
 * @param props - Component props containing gradient value and change handlers
 * @returns A React component
 */
const Gradient = (props) => {
    Gradient.displayName = "Gradient";
    const [gradient, setGradient] = useState(props.value);
    const classes = useGradientStyles();
    useEffect(() => {
        setGradient(props.value); // Re-render if props.value changes
    }, [props.value]);
    const gradientChange = (newGradient) => {
        setGradient(newGradient);
        props.onChange(newGradient);
    };
    // Only use compact mode when there are numeric values (spinbuttons) taking up space
    const hasNumericValues = !(gradient.value1 instanceof Color3 || gradient.value1 instanceof Color4) ||
        (gradient.value2 !== undefined && !(gradient.value2 instanceof Color3 || gradient.value2 instanceof Color4));
    return (jsxs("div", { id: "gradientContainer", className: classes.container, children: [jsx("div", { className: gradient.value1 instanceof Color3 || gradient.value1 instanceof Color4 ? classes.colorWrapper : classes.valueWrapper, children: gradient.value1 instanceof Color3 || gradient.value1 instanceof Color4 ? (jsx(ColorPickerPopup, { value: gradient.value1, onChange: (color) => gradientChange({ ...gradient, value1: color }) })) : (jsx(SyncedSliderInput, { step: 0.01, value: gradient.value1, onChange: (val) => gradientChange({ ...gradient, value1: val }), compact: true })) }), gradient.value2 !== undefined && (jsx("div", { className: gradient.value2 instanceof Color3 || gradient.value2 instanceof Color4 ? classes.colorWrapper : classes.valueWrapper, children: gradient.value2 instanceof Color3 || gradient.value2 instanceof Color4 ? (jsx(ColorPickerPopup, { value: gradient.value2, onChange: (color) => gradientChange({ ...gradient, value2: color }) })) : (jsx(SyncedSliderInput, { step: 0.01, value: gradient.value2, onChange: (val) => gradientChange({ ...gradient, value2: val }), compact: true })) })), jsx("div", { className: classes.stepSliderWrapper, children: jsx(SyncedSliderInput, { notifyOnlyOnRelease: true, min: 0, max: 1, step: 0.01, value: gradient.step, onChange: (val) => gradientChange({ ...gradient, step: val }), compact: hasNumericValues, growSlider: !hasNumericValues }) })] }));
};
const FactorGradientCast = Gradient;
const Color3GradientCast = Gradient;
const Color4GradientCast = Gradient;
/**
 * Component wrapper for FactorGradient that provides slider inputs for factor1, factor2, and gradient step
 * @param props - Component props containing FactorGradient value and change handler
 * @returns A React component
 */
const FactorGradientComponent = (props) => {
    return (jsx(FactorGradientCast, { ...props, value: { value1: props.value.factor1, value2: props.value.factor2, step: props.value.gradient }, onChange: (gradient) => props.onChange(new FactorGradient(gradient.step, gradient.value1, gradient.value2)) }));
};
/**
 * Component wrapper for Color3Gradient that provides color picker and gradient step slider
 * @param props - Component props containing Color3Gradient value and change handler
 * @returns A React component
 */
const Color3GradientComponent = (props) => {
    return (jsx(Color3GradientCast, { ...props, value: { value1: props.value.color, step: props.value.gradient }, onChange: (gradient) => props.onChange(new Color3Gradient(gradient.step, gradient.value1)) }));
};
/**
 * Component wrapper for Color4Gradient that provides color pickers for color1, color2, and gradient step slider
 * @param props - Component props containing Color4Gradient value and change handler
 * @returns A React component
 */
const Color4GradientComponent = (props) => {
    return (jsx(Color4GradientCast, { ...props, value: { value1: props.value.color1, value2: props.value.color2, step: props.value.gradient }, onChange: (gradient) => props.onChange(new ColorGradient(gradient.step, gradient.value1, gradient.value2)) }));
};
/**
 * Component wrapper for GradientBlockColorStep that provides color picker and step slider
 * @param props - Component props containing GradientBlockColorStep value and change handler
 * @returns A React component
 */
const ColorStepGradientComponent = (props) => {
    return (jsx(Color3GradientCast, { ...props, value: { value1: props.value.color, step: props.value.step }, onChange: (gradient) => props.onChange(new GradientBlockColorStep(gradient.step, gradient.value1)) }));
};

// Convert gradients to LineList items and sort by gradient value
function GradientsToListItems(gradients) {
    return (gradients?.map((gradient, index) => ({
        id: index,
        data: gradient,
        sortBy: gradient.gradient,
    })) ?? []);
}
const FactorGradientList = (props) => {
    FactorGradientList.displayName = "FactorGradientList";
    const { gradients } = props;
    const items = useMemo(() => GradientsToListItems(gradients), [gradients]);
    return (jsx(List, { addButtonLabel: items.length > 0 ? `Add new ${props.label}` : `Use ${props.label}s`, items: items, onDelete: (item, index) => props.removeGradient(item.data, index), onAdd: () => {
            if (items.length === 0) {
                props.addGradient(); // Default
            }
            else {
                props.addGradient(new FactorGradient(1, 1, 1));
            }
        }, renderItem: (item, index) => {
            return (jsx(FactorGradientComponent, { value: item.data, onChange: (newGradient) => {
                    item.data.gradient = newGradient.gradient;
                    item.data.factor1 = newGradient.factor1;
                    item.data.factor2 = newGradient.factor2;
                    props.onChange(newGradient, index);
                } }));
        } }, "Factor"));
};
const Color3GradientList = (props) => {
    Color3GradientList.displayName = "Color3GradientList";
    const { gradients } = props;
    const items = useMemo(() => GradientsToListItems(gradients), [gradients]);
    return (jsx(List, { addButtonLabel: items.length > 0 ? `Add new ${props.label}` : `Use ${props.label}s`, items: items, onDelete: (item, index) => props.removeGradient(item.data, index), onAdd: () => {
            if (items.length === 0) {
                props.addGradient(); // Default
            }
            else {
                props.addGradient(new Color3Gradient(1, Color3.White()));
            }
        }, renderItem: (item, index) => {
            return (jsx(Color3GradientComponent, { value: item.data, onChange: (newGradient) => {
                    item.data.gradient = newGradient.gradient;
                    item.data.color = newGradient.color;
                    props.onChange(newGradient, index);
                } }));
        } }, "Color3"));
};
const Color4GradientList = (props) => {
    Color4GradientList.displayName = "Color4GradientList";
    const { gradients } = props;
    const items = useMemo(() => GradientsToListItems(gradients), [gradients]);
    return (jsx(List, { addButtonLabel: items.length > 0 ? `Add new ${props.label}` : `Use ${props.label}s`, items: items, onDelete: (item, index) => props.removeGradient(item.data, index), onAdd: () => {
            if (items.length === 0) {
                props.addGradient(); // Default
            }
            else {
                props.addGradient(new ColorGradient(1, new Color4(1, 1, 1, 1), new Color4(1, 1, 1, 1)));
            }
        }, renderItem: (item, index) => {
            return (jsx(Color4GradientComponent, { value: item.data, onChange: (newGradient) => {
                    item.data.gradient = newGradient.gradient;
                    item.data.color1 = newGradient.color1;
                    item.data.color2 = newGradient.color2;
                    props.onChange(newGradient, index);
                } }));
        } }, "Color4"));
};

function GroupBy(items, getKey) {
    const map = items.reduce((map, item) => {
        const key = getKey(item);
        let group = map.get(key);
        if (!group) {
            map.set(key, (group = []));
        }
        group.push(item);
        return map;
    }, new Map());
    return Array.from(map, ([key, items]) => ({ key, items }));
}

const useStyles$l = makeStyles({
    subsection: {
        marginTop: tokens.spacingVerticalM,
    },
});
const NodeMaterialGeneralProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Ignore Alpha", target: material, propertyKey: "ignoreAlpha" }), jsx(ButtonLine, { label: "Edit", icon: EditRegular, onClick: async () => {
                    // TODO: Figure out how to get all the various build steps to work with this.
                    //       See the initial attempt here: https://github.com/BabylonJS/Babylon.js/pull/17646
                    // const { NodeEditor } = await import("node-editor/nodeEditor");
                    // NodeEditor.Show({ nodeMaterial: material });
                    await material.edit();
                } })] }));
};
const InputBlockPropertyLine$1 = (props) => {
    const { block } = props;
    // We need to re-evaluate this outer component when type/isBoolean/min/max change since that determines what type of property line we render.
    const type = useProperty(block, "type");
    const isBoolean = useProperty(block, "isBoolean");
    const min = useProperty(block, "min");
    const max = useProperty(block, "max");
    const commonProps = {
        label: block.name,
        target: block,
        propertyKey: "value",
    };
    if (type === NodeMaterialBlockConnectionPointTypes.Float) {
        if (isBoolean) {
            return jsx(BoundProperty, { component: SwitchPropertyLine, ...commonProps }, `${block.uniqueId} (Switch)`);
        }
        else {
            const hasMinMax = !isNaN(min) && !isNaN(max) && min !== max;
            if (hasMinMax) {
                return jsx(BoundProperty, { component: SyncedSliderPropertyLine, ...commonProps, min: min, max: max, step: (max - min) / 100.0 }, `${block.uniqueId} (Slider)`);
            }
            else {
                return jsx(BoundProperty, { component: NumberInputPropertyLine, ...commonProps }, `${block.uniqueId} (Number)`);
            }
        }
    }
    else if (type === NodeMaterialBlockConnectionPointTypes.Color3) {
        return jsx(BoundProperty, { component: Color3PropertyLine, ...commonProps }, `${block.uniqueId} (Color3)`);
    }
    else if (type === NodeMaterialBlockConnectionPointTypes.Color4) {
        return jsx(BoundProperty, { component: Color4PropertyLine, ...commonProps }, `${block.uniqueId} (Color4)`);
    }
    else if (type === NodeMaterialBlockConnectionPointTypes.Vector2) {
        return jsx(BoundProperty, { component: Vector2PropertyLine, ...commonProps }, `${block.uniqueId} (Vector2)`);
    }
    else if (type === NodeMaterialBlockConnectionPointTypes.Vector3) {
        return jsx(BoundProperty, { component: Vector3PropertyLine, ...commonProps }, `${block.uniqueId} (Vector3)`);
    }
    else if (type === NodeMaterialBlockConnectionPointTypes.Vector4) {
        return jsx(BoundProperty, { component: Vector4PropertyLine, ...commonProps }, `${block.uniqueId} (Vector4)`);
    }
    else {
        return null;
    }
};
const GradientBlockPropertyLine = (props) => {
    const { material, block } = props;
    const gradients = useObservableState(useCallback(() => block.colorSteps.map((step) => new Color3Gradient(step.step, step.color)), [block.colorSteps]), block.onValueChangedObservable);
    return (jsx(Color3GradientList, { label: "step", gradients: gradients, addGradient: (gradient) => {
            block.colorSteps.push(gradient ? new GradientBlockColorStep(gradient.gradient, gradient.color) : new GradientBlockColorStep(1.0, Color3.White()));
            block.colorStepsUpdated();
            material.build();
        }, removeGradient: (_, index) => {
            block.colorSteps.splice(index, 1);
            block.colorStepsUpdated();
            material.build();
        }, onChange: (gradient, index) => {
            block.colorSteps[index].step = gradient.gradient;
            block.colorSteps[index].color = gradient.color;
            block.colorStepsUpdated();
            material.build();
        } }));
};
const NodeMaterialInputProperties = (props) => {
    const { material } = props;
    const classes = useStyles$l();
    const inputBlocks = useObservableState(useCallback(() => {
        const inspectorVisibleInputBlocks = material
            .getInputBlocks()
            .filter((block) => block.visibleInInspector)
            .map((block) => block);
        const groupedInputBlocks = GroupBy(inspectorVisibleInputBlocks, (block) => block.groupInInspector);
        return groupedInputBlocks.sort((a, b) => a.key.localeCompare(b.key));
    }, [material]), material.onBuildObservable, material.onBuildErrorObservable);
    const gradientBlocks = useObservableState(useCallback(() => material.attachedBlocks.filter((block) => block.visibleInInspector && block.getClassName() === "GradientBlock").map((block) => block), [material]), material.onBuildObservable, material.onBuildErrorObservable);
    return (jsx(Fragment, { children: inputBlocks.length === 0 && gradientBlocks.length === 0 ? (jsx(MessageBar, { intent: "info", title: "No Visible Input Blocks", message: "To see input blocks, mark them as visibleInInspector.", docLink: "https://doc.babylonjs.com/features/featuresDeepDive/materials/node_material/nodeMaterial/#adding-blocks" }, "no-visible-input-blocks")) : (jsxs(Fragment, { children: [inputBlocks.map((group) => (jsxs(Fragment$1, { children: [group.key && jsx(Subtitle2, { className: classes.subsection, children: group.key }), group.items.map((block) => (jsx(InputBlockPropertyLine$1, { block: block }, block.uniqueId)))] }, `${group.key || "default"} (Group)`))), gradientBlocks.map((block) => (jsxs(Fragment$1, { children: [jsx(Subtitle2, { className: classes.subsection, children: block.name }), jsx(GradientBlockPropertyLine, { material: material, block: block })] }, `${block.uniqueId} (Gradient)`)))] })) }));
};

function IsMaterialWithPublicNormalMaps(mat) {
    return mat.invertNormalMapX !== undefined;
}
/**
 * Displays the normal map properties of a standard material.
 * @param props - The required properties
 * @returns A JSX element representing the normal map properties.
 */
const NormalMapProperties = (props) => {
    const { material } = props;
    return (jsx(Fragment, { children: IsMaterialWithPublicNormalMaps(material) ? (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Invert X Axis", target: material, propertyKey: "invertNormalMapX" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Invert Y Axis", target: material, propertyKey: "invertNormalMapY" })] })) : (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Invert X Axis", target: material, propertyKey: "_invertNormalMapX" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Invert Y Axis", target: material, propertyKey: "_invertNormalMapY" })] })) }));
};

// TODO: ryamtrem / gehalper This function is temporal until there is a line control to handle texture links (similar to the old TextureLinkLineComponent)
const UpdateTexture = (file, material, textureSetter) => {
    ReadFile(file, (data) => {
        const blob = new Blob([data], { type: "octet/stream" });
        const url = URL.createObjectURL(blob);
        textureSetter(new Texture(url, material.getScene(), false, false));
    }, undefined, true);
};
/**
 * Displays the base layer properties of an OpenPBR material.
 * @param props - The required properties
 * @returns A JSX element representing the base layer properties.
 */
const OpenPBRMaterialBaseProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Base Weight", target: material, propertyKey: "baseWeight", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Base Weight", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.baseWeightTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Base Color", target: material, propertyKey: "baseColor", isLinearMode: true }), jsx(FileUploadLine, { label: "Base Color", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.baseColorTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Base Metalness", target: material, propertyKey: "baseMetalness", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Base Metalness", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.baseMetalnessTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Base Diffuse Roughness", target: material, propertyKey: "baseDiffuseRoughness", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Base Diffuse Roughness", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.baseDiffuseRoughnessTexture = texture));
                    }
                } })] }));
};
/**
 * Displays the specular layer properties of an OpenPBR material.
 * @param props - The required properties
 * @returns A JSX element representing the specular layer properties.
 */
const OpenPBRMaterialSpecularProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Specular Weight", target: material, propertyKey: "specularWeight", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Specular Weight", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.specularWeightTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Specular Color", target: material, propertyKey: "specularColor", isLinearMode: true }), jsx(FileUploadLine, { label: "Specular Color", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.specularColorTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Specular Roughness", target: material, propertyKey: "specularRoughness", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Specular Roughness", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.specularRoughnessTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Specular Roughness Anisotropy", target: material, propertyKey: "specularRoughnessAnisotropy", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Specular Roughness Anisotropy", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.specularRoughnessAnisotropyTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Specular IOR", target: material, propertyKey: "specularIor", min: 1, max: 3, step: 0.01 })] }));
};
const OpenPBRMaterialTransmissionProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Transmission Weight", target: material, propertyKey: "transmissionWeight", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Transmission Weight", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.transmissionWeightTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Transmission Color", target: material, propertyKey: "transmissionColor", isLinearMode: true }), jsx(FileUploadLine, { label: "Transmission Color", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.transmissionColorTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Transmission Depth", target: material, propertyKey: "transmissionDepth", min: 0, step: 0.01 }), jsx(FileUploadLine, { label: "Transmission Depth", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.transmissionDepthTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Transmission Scatter", target: material, propertyKey: "transmissionScatter", isLinearMode: true }), jsx(FileUploadLine, { label: "Transmission Scatter", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.transmissionScatterTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Transmission Scatter Anisotropy", target: material, propertyKey: "transmissionScatterAnisotropy", min: -1, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Transmission Dispersion Abbe Number", target: material, propertyKey: "transmissionDispersionAbbeNumber", min: 1, max: 100, step: 1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Transmission Dispersion Scale", target: material, propertyKey: "transmissionDispersionScale", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Transmission Dispersion Scale", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.transmissionDispersionScaleTexture = texture));
                    }
                } })] }));
};
/**
 * Displays the coat layer properties of an OpenPBR material.
 * @param props - The required properties
 * @returns A JSX element representing the coat layer properties.
 */
const OpenPBRMaterialCoatProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Coat Weight", target: material, propertyKey: "coatWeight", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Coat Weight", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.coatWeightTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Coat Color", target: material, propertyKey: "coatColor", isLinearMode: true }), jsx(FileUploadLine, { label: "Coat Color", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.coatColorTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Coat Roughness", target: material, propertyKey: "coatRoughness", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Coat Roughness", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.coatRoughnessTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Coat Roughness Anisotropy", target: material, propertyKey: "coatRoughnessAnisotropy", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Coat Roughness Anisotropy", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.coatRoughnessAnisotropyTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Coat IOR", target: material, propertyKey: "coatIor", min: 1, max: 3, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Coat Darkening", target: material, propertyKey: "coatDarkening", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Coat Darkening", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.coatDarkeningTexture = texture));
                    }
                } })] }));
};
/**
 * Displays the fuzz layer properties of an OpenPBR material.
 * @param props - The required properties
 * @returns A JSX element representing the fuzz layer properties.
 */
const OpenPBRMaterialFuzzProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Fuzz Weight", target: material, propertyKey: "fuzzWeight", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Fuzz Weight", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.fuzzWeightTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Fuzz Color", target: material, propertyKey: "fuzzColor", isLinearMode: true }), jsx(FileUploadLine, { label: "Fuzz Color", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.fuzzColorTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Fuzz Roughness", target: material, propertyKey: "fuzzRoughness", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Fuzz Roughness", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.fuzzRoughnessTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Number of Samples", target: material, propertyKey: "fuzzSampleNumber", min: 4, max: 64, step: 1 })] }));
};
/**
 * Displays the emission properties of an OpenPBR material.
 * @param props - The required properties
 * @returns A JSX element representing the emission properties.
 */
const OpenPBRMaterialEmissionProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: Color3PropertyLine, label: "Emission Color", target: material, propertyKey: "emissionColor", isLinearMode: true }), jsx(FileUploadLine, { label: "Emission Color", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.emissionColorTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Emission Luminance", target: material, propertyKey: "emissionLuminance", min: 0, max: 10, step: 0.01 })] }));
};
/**
 * Displays the thin film properties of an OpenPBR material.
 * @param props - The required properties
 * @returns A JSX element representing the thin film properties.
 */
const OpenPBRMaterialThinFilmProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Thin Film Weight", target: material, propertyKey: "thinFilmWeight", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Thin Film Weight", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.thinFilmWeightTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Thin Film Thickness", target: material, propertyKey: "thinFilmThickness", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Thin Film Thickness", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.thinFilmThicknessTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Thin Film IOR", target: material, propertyKey: "thinFilmIor", min: 1, max: 3, step: 0.01 })] }));
};
/**
 * Displays the geometry properties of an OpenPBR material.
 * @param props - The required properties
 * @returns A JSX element representing the geometry properties.
 */
const OpenPBRMaterialGeometryProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Opacity", target: material, propertyKey: "geometryOpacity", min: 0, max: 1, step: 0.01 }), jsx(FileUploadLine, { label: "Geometry Opacity", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.geometryOpacityTexture = texture));
                    }
                } }), jsx(FileUploadLine, { label: "Geometry Normal", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.geometryNormalTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Tangent Angle", target: material, propertyKey: "geometryTangentAngle", min: 0, max: Math.PI, step: 0.01 }), jsx(FileUploadLine, { label: "Geometry Tangent", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.geometryTangentTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Coat Tangent Angle", target: material, propertyKey: "geometryCoatTangentAngle", min: 0, max: Math.PI, step: 0.01 }), jsx(FileUploadLine, { label: "Geometry Coat Normal", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.geometryCoatNormalTexture = texture));
                    }
                } }), jsx(FileUploadLine, { label: "Geometry Coat Tangent", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.geometryCoatTangentTexture = texture));
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Geometry Thickness", target: material, propertyKey: "geometryThickness", min: 0, step: 0.1 }), jsx(FileUploadLine, { label: "Geometry Thickness", accept: ".jpg, .png, .tga, .dds, .env, .exr", onClick: (files) => {
                    if (files.length > 0) {
                        UpdateTexture(files[0], material, (texture) => (material.geometryThicknessTexture = texture));
                    }
                } })] }));
};

const useStyles$k = makeStyles({
    root: {
        display: "grid",
        gridTemplateRows: "repeat(1fr)",
        justifyItems: "start",
        gap: "2px",
        maxWidth: "400px",
    },
    comboBox: {
        width: CustomTokens.inputWidth,
        minWidth: CustomTokens.inputWidth,
        boxSizing: "border-box",
    },
    input: {
        minWidth: 0,
    },
    listbox: {
        width: "fit-content",
        minWidth: "fit-content",
        maxWidth: "350px",
    },
});
/**
 * Wrapper around a Fluent ComboBox that allows for filtering options.
 * @param props
 * @returns
 */
const ComboBox = (props) => {
    ComboBox.displayName = "ComboBox";
    const comboId = useId();
    const styles = useStyles$k();
    const { size } = useContext(ToolContext);
    // Find the label for the current value
    const getLabel = (value) => props.options.find((opt) => opt.value === value)?.label ?? "";
    const [query, setQuery] = useState(getLabel(props.value ?? ""));
    useEffect(() => {
        setQuery(getLabel(props.value ?? ""));
    }, [props.value, props.options]);
    // Convert to Fluent's { children, value } format
    const normalizedOptions = props.options.map((opt) => ({ children: opt.label, value: opt.value }));
    const children = useComboboxFilter(query, normalizedOptions, {
        noOptionsMessage: "No items match your search.",
        optionToReactKey: (option) => option.value,
        optionToText: (option) => option.children,
        renderOption: (option) => (jsx(Option, { value: option.value, text: option.children, children: option.children }, option.value)),
    });
    const onOptionSelect = (_e, data) => {
        setQuery(data.optionText ?? "");
        data.optionValue && props.onChange(data.optionValue);
    };
    return (jsxs("div", { className: styles.root, children: [jsx("label", { id: comboId, children: props.label }), jsx(Combobox, { size: size, root: { className: styles.comboBox }, input: { className: styles.input }, listbox: { className: styles.listbox }, onOptionSelect: onOptionSelect, "aria-labelledby": comboId, placeholder: "Search..", onChange: (ev) => setQuery(ev.target.value), value: query, children: children })] }));
};

const useStyles$j = makeStyles({
    linkDiv: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        gap: tokens.spacingHorizontalS,
        minWidth: 0,
        overflow: "hidden",
    },
    link: {
        minWidth: 0,
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
    },
});
/**
 * A generic primitive component with a ComboBox for selecting from a list of entities.
 * Supports entities with duplicate names by using uniqueId for identity.
 * @param props ChooseEntityProps
 * @returns EntitySelector component
 */
function EntitySelector(props) {
    const { value, onLink, getEntities, getName, filter, defaultValue } = props;
    const onChange = props.onChange;
    const classes = useStyles$j();
    // Build options with uniqueId as key
    const options = useMemo(() => {
        return getEntities()
            .filter((e) => e.uniqueId !== undefined && (!filter || filter(e)))
            .map((entity) => ({
            label: getName(entity)?.toString() || "",
            value: entity.uniqueId.toString(),
        }))
            .sort((a, b) => a.label.localeCompare(b.label));
    }, [getEntities, getName, filter]);
    const [isEditing, setIsEditing] = useState(false);
    const handleEntitySelect = (key) => {
        const entity = getEntities().find((e) => e.uniqueId.toString() === key);
        onChange?.(entity ?? null);
        setIsEditing(false);
    };
    // Get current entity key for display
    const currentKey = value ? value.uniqueId.toString() : "";
    if (value && !isEditing) {
        // If there is a value and we are not editing, show the link view
        return (jsxs("div", { className: classes.linkDiv, children: [jsx(Tooltip$1, { content: getName(value), relationship: "label", children: jsx(Link, { className: classes.link, value: getName(value), onLink: () => onLink(value) }) }), onChange &&
                    (defaultValue !== undefined ? (
                    // If the defaultValue is specified, then allow resetting to the default
                    jsx(Tooltip$1, { content: "Unlink", relationship: "label", children: jsx(Button, { icon: LinkDismissRegular, onClick: () => onChange(defaultValue) }) })) : (
                    // Otherwise, just allow editing to a new value
                    jsx(Tooltip$1, { content: "Edit Link", relationship: "label", children: jsx(Button, { icon: LinkEditRegular, onClick: () => setIsEditing(true) }) })))] }));
    }
    else {
        // Otherwise, show the ComboBox for selection
        return jsx(ComboBox, { label: "", options: options, value: currentKey, onChange: handleEntitySelect });
    }
}
EntitySelector.displayName = "EntitySelector";

/**
 * A primitive component with a ComboBox for selecting from existing scene materials.
 * @param props MaterialSelectorProps
 * @returns MaterialSelector component
 */
const MaterialSelector = (props) => {
    MaterialSelector.displayName = "MaterialSelector";
    const { scene, ...rest } = props;
    const getMaterials = useCallback(() => scene.materials, [scene.materials]);
    const getName = useCallback((material) => material.name, []);
    return jsx(EntitySelector, { ...rest, getEntities: getMaterials, getName: getName });
};

/**
 * A primitive component with a ComboBox for selecting from existing scene nodes.
 * @param props NodeSelectorProps
 * @returns NodeSelector component
 */
const NodeSelector = (props) => {
    NodeSelector.displayName = "NodeSelector";
    const { scene, ...rest } = props;
    const getNodes = useCallback(() => scene.getNodes(), [scene]);
    const getName = useCallback((node) => node.name, []);
    return jsx(EntitySelector, { ...rest, getEntities: getNodes, getName: getName });
};

/**
 * A button that uploads a file and either:
 * - Updates an existing Texture or CubeTexture via updateURL (if texture prop is provided)
 * - Creates a new Texture or CubeTexture (if scene/onChange props are provided)
 * @param props TextureUploadProps
 * @returns UploadButton component that handles texture upload
 */
const TextureUpload = (props) => {
    TextureUpload.displayName = "TextureUpload";
    const label = props.texture ? "Upload Texture" : undefined;
    // TODO: This should probably be dynamically fetching a list of supported texture extensions
    const accept = ".jpg, .png, .tga, .dds, .env, .exr";
    const handleUpload = useCallback((files) => {
        const file = files[0];
        if (!file) {
            return;
        }
        ReadFile(file, (data) => {
            const blob = new Blob([data], { type: "octet/stream" });
            // Update existing texture
            if (props.texture) {
                const { texture, onChange } = props;
                const reader = new FileReader();
                reader.readAsDataURL(blob);
                reader.onloadend = () => {
                    const base64data = reader.result;
                    if (texture instanceof CubeTexture) {
                        let extension = undefined;
                        if (file.name.toLowerCase().indexOf(".dds") > 0) {
                            extension = ".dds";
                        }
                        else if (file.name.toLowerCase().indexOf(".env") > 0) {
                            extension = ".env";
                        }
                        texture.updateURL(base64data, extension, () => onChange?.(texture));
                    }
                    else if (texture instanceof Texture) {
                        texture.updateURL(base64data, null, () => onChange?.(texture));
                    }
                };
            }
            else {
                // Create new texture
                const { scene, cubeOnly, onChange } = props;
                const url = URL.createObjectURL(blob);
                const extension = file.name.split(".").pop()?.toLowerCase();
                // Revoke the object URL after texture loads to prevent memory leak
                const revokeUrl = () => URL.revokeObjectURL(url);
                const newTexture = cubeOnly
                    ? new CubeTexture(url, scene, [], false, undefined, revokeUrl, undefined, undefined, false, extension ? "." + extension : undefined)
                    : new Texture(url, scene, false, false, undefined, revokeUrl);
                onChange(newTexture);
            }
        }, undefined, true);
    }, [props]);
    return jsx(UploadButton, { onUpload: handleUpload, accept: accept, title: "Upload Texture", label: label });
};

const useStyles$i = makeStyles({
    container: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        gap: tokens.spacingHorizontalS,
    },
});
/**
 * A primitive component with a ComboBox for selecting from existing scene textures
 * and a button for uploading new texture files.
 * @param props TextureSelectorProps
 * @returns TextureSelector component
 */
const TextureSelector = (props) => {
    TextureSelector.displayName = "TextureSelector";
    const { scene, cubeOnly, value, onChange, onLink, defaultValue } = props;
    const classes = useStyles$i();
    const getTextures = useCallback(() => scene.textures, [scene.textures]);
    const getName = useCallback((texture) => texture.displayName || texture.name || `${texture.getClassName() || "Unnamed Texture"} (${texture.uniqueId})`, []);
    const filter = useCallback((texture) => !cubeOnly || texture.isCube, [cubeOnly]);
    return (jsxs("div", { className: classes.container, children: [jsx(EntitySelector, { value: value, onChange: onChange, onLink: onLink, defaultValue: defaultValue, getEntities: getTextures, getName: getName, filter: filter }), !value && jsx(TextureUpload, { scene: scene, onChange: onChange, cubeOnly: cubeOnly })] }));
};

/**
 * A primitive component with a ComboBox for selecting from existing scene skeletons.
 * @param props SkeletonSelectorProps
 * @returns SkeletonSelector component
 */
const SkeletonSelector = (props) => {
    SkeletonSelector.displayName = "SkeletonSelector";
    const { scene, ...rest } = props;
    const getSkeletons = useCallback(() => scene.skeletons, [scene.skeletons]);
    const getName = useCallback((skeleton) => skeleton.name, []);
    return jsx(EntitySelector, { ...rest, getEntities: getSkeletons, getName: getName });
};

const NodeSelectorPropertyLine = (props) => jsx(PropertyLine, { ...props, children: jsx(NodeSelector, { ...props }) });
const MaterialSelectorPropertyLine = (props) => jsx(PropertyLine, { ...props, children: jsx(MaterialSelector, { ...props }) });
const TextureSelectorPropertyLine = (props) => jsx(PropertyLine, { ...props, children: jsx(TextureSelector, { ...props }) });
const SkeletonSelectorPropertyLine = (props) => jsx(PropertyLine, { ...props, children: jsx(SkeletonSelector, { ...props }) });

const LightFalloffOptions = [
    { label: "Physical", value: PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL },
    { label: "glTF", value: PBRBaseMaterial.LIGHTFALLOFF_GLTF },
    { label: "Standard", value: PBRBaseMaterial.LIGHTFALLOFF_STANDARD },
];
const RealTimeFilteringQualityOptions = [
    { label: "Low", value: Constants.TEXTURE_FILTERING_QUALITY_LOW },
    { label: "Medium", value: Constants.TEXTURE_FILTERING_QUALITY_MEDIUM },
    { label: "High", value: Constants.TEXTURE_FILTERING_QUALITY_HIGH },
];
const BaseDiffuseModelOptions = [
    { label: "Lambert", value: Constants.MATERIAL_DIFFUSE_MODEL_LAMBERT },
    { label: "Burley", value: Constants.MATERIAL_DIFFUSE_MODEL_BURLEY },
    { label: "OpenPBR", value: Constants.MATERIAL_DIFFUSE_MODEL_E_OREN_NAYAR },
];
const DielectricSpecularModelOptions = [
    { label: "glTF", value: Constants.MATERIAL_DIELECTRIC_SPECULAR_MODEL_GLTF },
    { label: "OpenPBR", value: Constants.MATERIAL_DIELECTRIC_SPECULAR_MODEL_OPENPBR },
];
const ConductorSpecularModelOptions = [
    { label: "glTF", value: Constants.MATERIAL_CONDUCTOR_SPECULAR_MODEL_GLTF },
    { label: "OpenPBR", value: Constants.MATERIAL_CONDUCTOR_SPECULAR_MODEL_OPENPBR },
];
const DebugMode = [
    { label: "None", value: 0 },
    // Geometry
    { label: "Normalized position", value: 1 },
    { label: "Normals", value: 2 },
    { label: "Tangents", value: 3 },
    { label: "Bitangents", value: 4 },
    { label: "Bump Normals", value: 5 },
    { label: "UV1", value: 6 },
    { label: "UV2", value: 7 },
    { label: "ClearCoat Normals", value: 8 },
    { label: "ClearCoat Tangents", value: 9 },
    { label: "ClearCoat Bitangents", value: 10 },
    { label: "Anisotropic Normals", value: 11 },
    { label: "Anisotropic Tangents", value: 12 },
    { label: "Anisotropic Bitangents", value: 13 },
    // Maps
    { label: "Albedo Map", value: 20 },
    { label: "Ambient Map", value: 21 },
    { label: "Opacity Map", value: 22 },
    { label: "Emissive Map", value: 23 },
    { label: "Light Map", value: 24 },
    { label: "Metallic Map", value: 25 },
    { label: "Reflectivity Map", value: 26 },
    { label: "ClearCoat Map", value: 27 },
    { label: "ClearCoat Tint Map", value: 28 },
    { label: "Sheen Map", value: 29 },
    { label: "Anisotropic Map", value: 30 },
    { label: "Thickness Map", value: 31 },
    { label: "Bump Map", value: 32 },
    // Env
    { label: "Env Refraction", value: 40 },
    { label: "Env Reflection", value: 41 },
    { label: "Env Clear Coat", value: 42 },
    // Lighting
    { label: "Direct Diffuse", value: 50 },
    { label: "Direct Specular", value: 51 },
    { label: "Direct Clear Coat", value: 52 },
    { label: "Direct Sheen", value: 53 },
    { label: "Env Irradiance", value: 54 },
    // Lighting Params
    { label: "Surface Albedo", value: 60 },
    { label: "Reflectance 0", value: 61 },
    { label: "Metallic", value: 62 },
    { label: "Metallic F0", value: 71 },
    { label: "Roughness", value: 63 },
    { label: "AlphaG", value: 64 },
    { label: "NdotV", value: 65 },
    { label: "ClearCoat Color", value: 66 },
    { label: "ClearCoat Roughness", value: 67 },
    { label: "ClearCoat NdotV", value: 68 },
    { label: "Transmittance", value: 69 },
    { label: "Refraction Transmittance", value: 70 },
    { label: "Glossiness", value: 72 },
    { label: "Base Color", value: 73 },
    { label: "Specular Color", value: 74 },
    { label: "Emissive Color", value: 75 },
    // Misc
    { label: "SEO", value: 80 },
    { label: "EHO", value: 81 },
    { label: "Energy Factor", value: 82 },
    { label: "Specular Reflectance", value: 83 },
    { label: "Clear Coat Reflectance", value: 84 },
    { label: "Sheen Reflectance", value: 85 },
    { label: "Luminance Over Alpha", value: 86 },
    { label: "Alpha", value: 87 },
    { label: "Albedo Alpha", value: 88 },
    { label: "Ambient occlusion color", value: 89 },
];
const PBRBaseMaterialGeneralProperties = (props) => {
    const { material } = props;
    return (jsx(Fragment, { children: jsx(BoundProperty, { component: SwitchPropertyLine, label: "Disable Lighting", target: material, propertyKey: "_disableLighting" }) }));
};
const PBRBaseMaterialTransparencyProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [material._albedoTexture && (jsx(Fragment, { children: jsx(BoundProperty, { component: SwitchPropertyLine, label: "Albedo texture has alpha", target: material._albedoTexture, propertyKey: "hasAlpha", propertyPath: "_albedoTexture.hasAlpha" }) })), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use alpha from albedo texture", target: material, propertyKey: "_useAlphaFromAlbedoTexture" })] }));
};
const PBRBaseMaterialChannelsProperties = (props) => {
    const { material, selectionService } = props;
    const scene = material.getScene();
    const selectEntity = (entity) => (selectionService.selectedEntity = entity);
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Albedo", target: material, propertyKey: "_albedoTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Base Weight", target: material, propertyKey: "_baseWeightTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Base Diffuse Roughness", target: material, propertyKey: "_baseDiffuseRoughnessTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Metallic Roughness", target: material, propertyKey: "_metallicTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Reflection", target: material, propertyKey: "_reflectionTexture", scene: scene, cubeOnly: true, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Refraction", target: material.subSurface, propertyKey: "refractionTexture", propertyPath: "subSurface.refractionTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Reflectivity", target: material, propertyKey: "_reflectivityTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Micro Surface", target: material, propertyKey: "_microSurfaceTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Bump", target: material, propertyKey: "_bumpTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Emissive", target: material, propertyKey: "_emissiveTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Opacity", target: material, propertyKey: "_opacityTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Ambient", target: material, propertyKey: "_ambientTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Lightmap", target: material, propertyKey: "_lightmapTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Detailmap", target: material.detailMap, propertyKey: "texture", propertyPath: "detailMap.texture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Lightmap as Shadowmap", target: material, propertyKey: "_useLightmapAsShadowmap" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Detailmap", target: material.detailMap, propertyKey: "isEnabled", propertyPath: "detailMap.isEnabled" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Decalmap", target: material.decalMap, propertyKey: "isEnabled", propertyPath: "decalMap.isEnabled" })] }));
};
const PBRBaseMaterialLightingAndColorProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: Color3PropertyLine, label: "Albedo", target: material, propertyKey: "_albedoColor", isLinearMode: true }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Base Weight", target: material, propertyKey: "_baseWeight", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Reflectivity", target: material, propertyKey: "_reflectivityColor", isLinearMode: true }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Micro Surface", target: material, propertyKey: "_microSurface", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Emissive", target: material, propertyKey: "_emissiveColor", isLinearMode: true }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Ambient", target: material, propertyKey: "_ambientColor", isLinearMode: true }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Light Falloff", target: material, propertyKey: "_lightFalloff", options: LightFalloffOptions })] }));
};
const PBRBaseMaterialMetallicWorkflowProperties = (props) => {
    const { material, selectionService } = props;
    const scene = material.getScene();
    const selectEntity = (entity) => (selectionService.selectedEntity = entity);
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Metallic", target: material, propertyKey: "_metallic", min: 0, max: 1, step: 0.01, nullable: true, defaultValue: 0 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Roughness", target: material, propertyKey: "_roughness", min: 0, max: 1, step: 0.01, nullable: true, defaultValue: 0 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Base Diffuse Roughness", target: material, propertyKey: "_baseDiffuseRoughness", min: 0, max: 1, step: 0.01, nullable: true, defaultValue: 0 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Index of Refraction", target: material.subSurface, propertyKey: "indexOfRefraction", propertyPath: "subSurface.indexOfRefraction", min: 1, max: 3, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "F0 Factor", target: material, propertyKey: "_metallicF0Factor", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Reflectance Color", target: material, propertyKey: "_metallicReflectanceColor", isLinearMode: true }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Metallic Only", description: "Use only metallic from MetallicReflectance texture", target: material, propertyKey: "_useOnlyMetallicFromMetallicReflectanceTexture" }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Metallic Reflectance", target: material, propertyKey: "_metallicReflectanceTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Reflectance", target: material, propertyKey: "_reflectanceTexture", scene: scene, onLink: selectEntity, defaultValue: null })] }));
};
const PBRBaseMaterialClearCoatProperties = (props) => {
    const { material, selectionService } = props;
    const scene = material.getScene();
    const selectEntity = (entity) => (selectionService.selectedEntity = entity);
    const isEnabled = useProperty(material.clearCoat, "isEnabled");
    const isTintEnabled = useProperty(material.clearCoat, "isTintEnabled");
    const bumpTexture = useProperty(material.clearCoat, "bumpTexture");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Enabled", target: material.clearCoat, propertyKey: "isEnabled", propertyPath: "clearCoat.isEnabled" }), jsxs(Collapse, { visible: isEnabled, children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Intensity", target: material.clearCoat, propertyKey: "intensity", propertyPath: "clearCoat.intensity", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Roughness", target: material.clearCoat, propertyKey: "roughness", propertyPath: "clearCoat.roughness", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "IOR", description: "Index of Refraction", target: material.clearCoat, propertyKey: "indexOfRefraction", propertyPath: "clearCoat.indexOfRefraction", min: 1, max: 3, step: 0.01 }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Remap F0", target: material.clearCoat, propertyKey: "remapF0OnInterfaceChange", propertyPath: "clearCoat.remapF0OnInterfaceChange" }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Clear Coat", target: material.clearCoat, propertyKey: "texture", propertyPath: "clearCoat.texture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Roughness", target: material.clearCoat, propertyKey: "textureRoughness", propertyPath: "clearCoat.textureRoughness", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Bump", target: material.clearCoat, propertyKey: "bumpTexture", propertyPath: "clearCoat.bumpTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(Collapse, { visible: bumpTexture !== null, children: jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Bump Strength", target: bumpTexture, propertyKey: "level", propertyPath: "clearCoat.bumpTexture.level", min: 0, max: 2, step: 0.01 }) }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Roughness from Main Texture", target: material.clearCoat, propertyKey: "useRoughnessFromMainTexture", propertyPath: "clearCoat.useRoughnessFromMainTexture" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Tint", target: material.clearCoat, propertyKey: "isTintEnabled", propertyPath: "clearCoat.isTintEnabled" }), jsxs(Collapse, { visible: isTintEnabled, children: [jsx(BoundProperty, { component: Color3PropertyLine, label: "Tint Color", target: material.clearCoat, propertyKey: "tintColor", propertyPath: "clearCoat.tintColor", isLinearMode: true }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "At Distance", target: material.clearCoat, propertyKey: "tintColorAtDistance", propertyPath: "clearCoat.tintColorAtDistance", min: 0, max: 20, step: 0.1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Tint Thickness", target: material.clearCoat, propertyKey: "tintThickness", propertyPath: "clearCoat.tintThickness", min: 0, max: 20, step: 0.1 }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Tint", target: material.clearCoat, propertyKey: "tintTexture", propertyPath: "clearCoat.tintTexture", scene: scene, onLink: selectEntity, defaultValue: null })] })] })] }));
};
const PBRBaseMaterialIridescenceProperties = (props) => {
    const { material, selectionService } = props;
    const scene = material.getScene();
    const selectEntity = (entity) => (selectionService.selectedEntity = entity);
    const isEnabled = useProperty(material.iridescence, "isEnabled");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Enabled", target: material.iridescence, propertyKey: "isEnabled", propertyPath: "iridescence.isEnabled" }), jsxs(Collapse, { visible: isEnabled, children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Intensity", target: material.iridescence, propertyKey: "intensity", propertyPath: "iridescence.intensity", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "IOR", description: "Index of Refraction", target: material.iridescence, propertyKey: "indexOfRefraction", propertyPath: "iridescence.indexOfRefraction", min: 1, max: 3, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Min Thickness", target: material.iridescence, propertyKey: "minimumThickness", propertyPath: "iridescence.minimumThickness", min: 0, max: 1000, step: 10 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Max Thickness", target: material.iridescence, propertyKey: "maximumThickness", propertyPath: "iridescence.maximumThickness", min: 0, max: 1000, step: 10 }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Iridescence", target: material.iridescence, propertyKey: "texture", propertyPath: "iridescence.texture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Thickness", target: material.iridescence, propertyKey: "thicknessTexture", propertyPath: "iridescence.thicknessTexture", scene: scene, onLink: selectEntity, defaultValue: null })] })] }));
};
const PBRBaseMaterialAnisotropicProperties = (props) => {
    const { material, selectionService } = props;
    const scene = material.getScene();
    const selectEntity = (entity) => (selectionService.selectedEntity = entity);
    const isEnabled = useProperty(material.anisotropy, "isEnabled");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Enabled", target: material.anisotropy, propertyKey: "isEnabled", propertyPath: "anisotropy.isEnabled" }), jsxs(Collapse, { visible: isEnabled, children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Legacy Mode", target: material.anisotropy, propertyKey: "legacy", propertyPath: "anisotropy.legacy" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Intensity", target: material.anisotropy, propertyKey: "intensity", propertyPath: "anisotropy.intensity", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: Vector2PropertyLine, label: "Direction", target: material.anisotropy, propertyKey: "direction", propertyPath: "anisotropy.direction" }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Anisotropic", target: material.anisotropy, propertyKey: "texture", propertyPath: "anisotropy.texture", scene: scene, onLink: selectEntity, defaultValue: null })] })] }));
};
const PBRBaseMaterialSheenProperties = (props) => {
    const { material, selectionService } = props;
    const scene = material.getScene();
    const selectEntity = (entity) => (selectionService.selectedEntity = entity);
    const isEnabled = useProperty(material.sheen, "isEnabled");
    const useRoughness = useProperty(material.sheen, "_useRoughness");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Enabled", target: material.sheen, propertyKey: "isEnabled", propertyPath: "sheen.isEnabled" }), jsxs(Collapse, { visible: isEnabled, children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Link to Albedo", target: material.sheen, propertyKey: "linkSheenWithAlbedo", propertyPath: "sheen.linkSheenWithAlbedo" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Intensity", target: material.sheen, propertyKey: "intensity", propertyPath: "sheen.intensity", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Color", target: material.sheen, propertyKey: "color", propertyPath: "sheen.color", isLinearMode: true }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Sheen", target: material.sheen, propertyKey: "texture", propertyPath: "sheen.texture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Roughness", target: material.sheen, propertyKey: "textureRoughness", propertyPath: "sheen.textureRoughness", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Roughness", target: material.sheen, propertyKey: "_useRoughness", propertyPath: "sheen._useRoughness" }), jsx(Collapse, { visible: useRoughness, children: jsx(BoundProperty, { nullable: true, component: SyncedSliderPropertyLine, label: "Roughness", target: material.sheen, propertyKey: "roughness", propertyPath: "sheen.roughness", defaultValue: 0, min: 0, max: 1, step: 0.01 }) }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Roughness from Main Texture", target: material.sheen, propertyKey: "useRoughnessFromMainTexture", propertyPath: "sheen.useRoughnessFromMainTexture" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Albedo Scaling", target: material.sheen, propertyKey: "albedoScaling", propertyPath: "sheen.albedoScaling" })] })] }));
};
const PBRBaseMaterialSubSurfaceProperties = (props) => {
    const { material, selectionService } = props;
    const scene = material.getScene();
    const selectEntity = (entity) => (selectionService.selectedEntity = entity);
    const useScattering = useProperty(material.subSurface, "isScatteringEnabled") && !!material.getScene().prePassRenderer && !!material.getScene().subSurfaceConfiguration;
    const useRefraction = useProperty(material.subSurface, "isRefractionEnabled");
    const useDispersion = useProperty(material.subSurface, "isDispersionEnabled");
    const useTranslucency = useProperty(material.subSurface, "isTranslucencyEnabled");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Thickness", target: material.subSurface, propertyKey: "thicknessTexture", propertyPath: "subSurface.thicknessTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Min Thickness", target: material.subSurface, propertyKey: "minimumThickness", propertyPath: "subSurface.minimumThickness", min: 0, max: 10, step: 0.1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Max Thickness", target: material.subSurface, propertyKey: "maximumThickness", propertyPath: "subSurface.maximumThickness", min: 0, max: 10, step: 0.1 }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Mask From Thickness", target: material.subSurface, propertyKey: "useMaskFromThicknessTexture", propertyPath: "subSurface.useMaskFromThicknessTexture" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "glTF-Style Textures", target: material.subSurface, propertyKey: "useGltfStyleTextures", propertyPath: "subSurface.useGltfStyleTextures" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Thickness as Depth", target: material.subSurface, propertyKey: "useThicknessAsDepth", propertyPath: "subSurface.useThicknessAsDepth" }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Tint Color", target: material.subSurface, propertyKey: "tintColor", propertyPath: "subSurface.tintColor", isLinearMode: true }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Scattering Enabled", target: material.subSurface, propertyKey: "isScatteringEnabled", propertyPath: "subSurface.isScatteringEnabled" }), jsx(Collapse, { visible: useScattering, children: jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Meters Per Unit", target: material.getScene().subSurfaceConfiguration, propertyKey: "metersPerUnit", propertyPath: "getScene().subSurfaceConfiguration.metersPerUnit", min: 0.01, max: 2, step: 0.01 }) }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Refraction Enabled", target: material.subSurface, propertyKey: "isRefractionEnabled", propertyPath: "subSurface.isRefractionEnabled" }), jsxs(Collapse, { visible: useRefraction, children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Intensity", target: material.subSurface, propertyKey: "refractionIntensity", propertyPath: "subSurface.refractionIntensity", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Refraction Intensity", target: material.subSurface, propertyKey: "refractionIntensityTexture", propertyPath: "subSurface.refractionIntensityTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Refraction", target: material.subSurface, propertyKey: "refractionTexture", propertyPath: "subSurface.refractionTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Volume Index of Refraction", target: material.subSurface, propertyKey: "volumeIndexOfRefraction", propertyPath: "subSurface.volumeIndexOfRefraction", min: 1, max: 3, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Tint at Distance", target: material.subSurface, propertyKey: "tintColorAtDistance", propertyPath: "subSurface.tintColorAtDistance", min: 0, max: 10, step: 0.1 }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Link Refraction with Transparency", target: material.subSurface, propertyKey: "linkRefractionWithTransparency", propertyPath: "subSurface.linkRefractionWithTransparency" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Albedo to Tint Surface Transparency", target: material.subSurface, propertyKey: "useAlbedoToTintRefraction", propertyPath: "subSurface.useAlbedoToTintRefraction" })] }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Dispersion Enabled", target: material.subSurface, propertyKey: "isDispersionEnabled", propertyPath: "subSurface.isDispersionEnabled" }), jsx(Collapse, { visible: useDispersion, children: jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Intensity", target: material.subSurface, propertyKey: "dispersion", propertyPath: "subSurface.dispersion", min: 0, max: 5, step: 0.01 }) }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Translucency Enabled", target: material.subSurface, propertyKey: "isTranslucencyEnabled", propertyPath: "subSurface.isTranslucencyEnabled" }), jsxs(Collapse, { visible: useTranslucency, children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Intensity", target: material.subSurface, propertyKey: "translucencyIntensity", propertyPath: "subSurface.translucencyIntensity", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Intensity Texture", target: material.subSurface, propertyKey: "translucencyIntensityTexture", propertyPath: "subSurface.translucencyIntensityTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Diffusion Distance", target: material.subSurface, propertyKey: "diffusionDistance", propertyPath: "subSurface.diffusionDistance", isLinearMode: true }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Albedo to Tint Surface Translucency", target: material.subSurface, propertyKey: "useAlbedoToTintTranslucency", propertyPath: "subSurface.useAlbedoToTintTranslucency" }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Translucency Tint", target: material.subSurface, propertyKey: "translucencyColor", propertyPath: "subSurface.translucencyColor", isLinearMode: true, nullable: true, defaultValue: Color3.White() }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Translucency Tint Texture", target: material.subSurface, propertyKey: "translucencyColorTexture", propertyPath: "subSurface.translucencyColorTexture", scene: scene, onLink: selectEntity, defaultValue: null })] })] }));
};
const PBRBaseMaterialLevelProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Environment", target: material, propertyKey: "_environmentIntensity", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Specular", target: material, propertyKey: "_specularIntensity", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Emissive", target: material, propertyKey: "_emissiveIntensity", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Direct", target: material, propertyKey: "_directIntensity", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Bump Strength", target: material._bumpTexture, propertyKey: "level", propertyPath: "_bumpTexture.level", min: 0, max: 2, step: 0.01 }), jsx(Collapse, { visible: !!material._ambientTexture, children: jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Ambient Strength", target: material, propertyKey: "_ambientTextureStrength", min: 0, max: 1, step: 0.01 }) }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Reflection Strength", target: material._reflectionTexture, propertyKey: "level", propertyPath: "_reflectionTexture.level", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Clear Coat", target: material.clearCoat.texture, propertyKey: "level", propertyPath: "clearCoat.texture.level", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Clear Coat Bump", target: material.clearCoat.bumpTexture, propertyKey: "level", propertyPath: "clearCoat.bumpTexture.level", min: 0, max: 2, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Anisotropic", target: material.anisotropy.texture, propertyKey: "level", propertyPath: "anisotropy.texture.level", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Sheen", target: material.sheen.texture, propertyKey: "level", propertyPath: "sheen.texture.level", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Thickness", target: material.subSurface.thicknessTexture, propertyKey: "level", propertyPath: "subSurface.thicknessTexture.level", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Refraction", target: material.subSurface.refractionTexture, propertyKey: "level", propertyPath: "subSurface.refractionTexture.level", min: 0, max: 1, step: 0.01 }), jsxs(Collapse, { visible: material.detailMap.isEnabled, children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Detailmap Diffuse", target: material.detailMap, propertyKey: "diffuseBlendLevel", propertyPath: "detailMap.diffuseBlendLevel", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Detailmap Bump", target: material.detailMap, propertyKey: "bumpLevel", propertyPath: "detailMap.bumpLevel", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Detailmap Roughness", target: material.detailMap, propertyKey: "roughnessBlendLevel", propertyPath: "detailMap.roughnessBlendLevel", min: 0, max: 1, step: 0.01 })] })] }));
};
const PBRBaseMaterialRenderingProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Alpha from Albedo", target: material, propertyKey: "_useAlphaFromAlbedoTexture" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Ambient in Grayscale", target: material, propertyKey: "_useAmbientInGrayScale" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Radiance over Alpha", target: material, propertyKey: "_useRadianceOverAlpha" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Micro-surface from Ref. Map Alpha", target: material, propertyKey: "_useMicroSurfaceFromReflectivityMapAlpha" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Specular over Alpha", target: material, propertyKey: "_useSpecularOverAlpha" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Specular Anti-aliasing", target: material, propertyKey: "_enableSpecularAntiAliasing" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Realtime Filtering", target: material, propertyKey: "realTimeFiltering" }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Realtime Filtering Quality", target: material, propertyKey: "realTimeFilteringQuality", options: RealTimeFilteringQualityOptions }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Base Diffuse Model", target: material.brdf, propertyKey: "baseDiffuseModel", propertyPath: "brdf.baseDiffuseModel", options: BaseDiffuseModelOptions }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Dielectric Specular Model", target: material.brdf, propertyKey: "dielectricSpecularModel", propertyPath: "brdf.dielectricSpecularModel", options: DielectricSpecularModelOptions }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Conductor Specular Model", target: material.brdf, propertyKey: "conductorSpecularModel", propertyPath: "brdf.conductorSpecularModel", options: ConductorSpecularModelOptions })] }));
};
const PBRBaseMaterialAdvancedProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Energy Conservation", target: material.brdf, propertyKey: "useEnergyConservation", propertyPath: "brdf.useEnergyConservation" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Spherical Harmonics", target: material.brdf, propertyKey: "useSphericalHarmonics", propertyPath: "brdf.useSphericalHarmonics" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Radiance Occlusion", target: material, propertyKey: "_useRadianceOcclusion" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Horizon Occlusion", target: material, propertyKey: "_useHorizonOcclusion" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Mix Irradiance with Rough Radiance", target: material.brdf, propertyKey: "mixIblRadianceWithIrradiance", propertyPath: "brdf.mixIblRadianceWithIrradiance" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Legacy Specular Energy Conservation", target: material.brdf, propertyKey: "useLegacySpecularEnergyConservation", propertyPath: "brdf.useLegacySpecularEnergyConservation" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Unlit", target: material, propertyKey: "_unlit" })] }));
};
const PBRBaseMaterialDebugProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Debug Mode", target: material, propertyKey: "debugMode", options: DebugMode }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Split Position", target: material, propertyKey: "debugLimit", min: -1, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Output Factor", target: material, propertyKey: "debugFactor", min: 0, max: 5, step: 0.01 })] }));
};

const SkyMaterialProperties = (props) => {
    const { material, settings } = props;
    const [toDisplayAngle, fromDisplayAngle, useDegrees] = useAngleConverters(settings);
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Azimuth", description: `Azimuth angle in ${useDegrees ? "degrees" : "radians"}`, target: material, propertyKey: "azimuth", min: toDisplayAngle(0), max: toDisplayAngle(Math.PI * 2), step: toDisplayAngle(0.001), convertTo: toDisplayAngle, convertFrom: fromDisplayAngle, docLink: "https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat/#configuring-the-sky-material" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Inclination", description: `Inclination angle in ${useDegrees ? "degrees" : "radians"}`, target: material, propertyKey: "inclination", min: toDisplayAngle(0), max: toDisplayAngle(Math.PI / 2), step: toDisplayAngle(0.001), convertTo: toDisplayAngle, convertFrom: fromDisplayAngle, docLink: "https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat/#configuring-the-sky-material" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Turbidity", description: "Atmospheric turbidity.", target: material, propertyKey: "turbidity", min: 0, max: 100, step: 0.1, docLink: "https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat/#configuring-the-sky-material" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Luminance", description: "Brightness of the sky (0 to 1).", target: material, propertyKey: "luminance", min: 0, max: 1, step: 0.001, docLink: "https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat/#configuring-the-sky-material" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Rayleigh", description: "Rayleigh scattering coefficient (0 to 4).", target: material, propertyKey: "rayleigh", min: 0, max: 4, step: 0.001, docLink: "https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat/#configuring-the-sky-material" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Mie Directional G", description: "Mie directional scattering (0 to 1).", target: material, propertyKey: "mieDirectionalG", min: 0, max: 1, step: 0.001, docLink: "https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat/#configuring-the-sky-material" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Mie Coefficient", description: "Mie scattering coefficient (0 to 1).", target: material, propertyKey: "mieCoefficient", min: 0, max: 1, step: 0.001, docLink: "https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat/#configuring-the-sky-material" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Distance", description: "Distance to the sky dome (0 to 1000 units).", target: material, propertyKey: "distance", min: 0, max: 1000, step: 0.1, docLink: "https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat/#configuring-the-sky-material" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Sun Pos", description: "Enable custom sun position.", target: material, propertyKey: "useSunPosition", docLink: "https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat/#configuring-the-sky-material" }), jsx(BoundProperty, { component: Vector3PropertyLine, label: "Sun Position", description: "Custom sun position (Vector3).", target: material, propertyKey: "sunPosition", docLink: "https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat/#configuring-the-sky-material" }), jsx(BoundProperty, { component: Vector3PropertyLine, label: "Camera Offset", description: "Offset for the camera (Vector3).", target: material, propertyKey: "cameraOffset", docLink: "https://doc.babylonjs.com/toolsAndResources/assetLibraries/materialsLibrary/skyMat/#keeping-the-horizon-relative-to-the-camera-elevation" })] }));
};

const StandardMaterialGeneralProperties = (props) => {
    const { material } = props;
    return (jsx(Fragment, { children: jsx(BoundProperty, { component: SwitchPropertyLine, label: "Disable Lighting", target: material, propertyKey: "disableLighting" }) }));
};
const StandardMaterialTransparencyProperties = (props) => {
    const { material } = props;
    return (jsxs(Fragment, { children: [material.diffuseTexture && (jsx(Fragment, { children: jsx(BoundProperty, { component: SwitchPropertyLine, label: "Diffuse Texture has Alpha", target: material.diffuseTexture, propertyKey: "hasAlpha", propertyPath: "diffuseTexture.hasAlpha" }) })), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Alpha from Diffuse Texture", target: material, propertyKey: "useAlphaFromDiffuseTexture" })] }));
};
const StandardMaterialTexturesProperties = (props) => {
    const { material, selectionService } = props;
    const scene = material.getScene();
    const selectEntity = (entity) => (selectionService.selectedEntity = entity);
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Diffuse", target: material, propertyKey: "diffuseTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Specular", target: material, propertyKey: "specularTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Reflection", target: material, propertyKey: "reflectionTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Refraction", target: material, propertyKey: "refractionTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Emissive", target: material, propertyKey: "emissiveTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Bump", target: material, propertyKey: "bumpTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Opacity", target: material, propertyKey: "opacityTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Ambient", target: material, propertyKey: "ambientTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Lightmap", target: material, propertyKey: "lightmapTexture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Detailmap", target: material.detailMap, propertyKey: "texture", propertyPath: "detailMap.texture", scene: scene, onLink: selectEntity, defaultValue: null }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Lightmap as Shadowmap", target: material, propertyKey: "useLightmapAsShadowmap" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Detailmap", target: material.detailMap, propertyKey: "isEnabled", propertyPath: "detailMap.isEnabled" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Decalmap", target: material.decalMap, propertyKey: "isEnabled", propertyPath: "decalMap.isEnabled" })] }));
};
/**
 * Displays the levels properties of a standard material.
 * @param props - The required properties
 * @returns A JSX element representing the levels properties.
 */
const StandardMaterialLevelsProperties = (props) => {
    const { standardMaterial } = props;
    const isDetailMapEnabled = useProperty(standardMaterial.detailMap, "isEnabled");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Diffuse Level", target: standardMaterial.diffuseTexture, propertyKey: "level", propertyPath: "diffuseTexture.level", min: 0, max: 2, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Specular Level", target: standardMaterial.specularTexture, propertyKey: "level", propertyPath: "specularTexture.level", min: 0, max: 2, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Reflection Level", target: standardMaterial.reflectionTexture, propertyKey: "level", propertyPath: "reflectionTexture.level", min: 0, max: 2, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Refraction Level", target: standardMaterial.refractionTexture, propertyKey: "level", propertyPath: "refractionTexture.level", min: 0, max: 2, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Emissive Level", target: standardMaterial.emissiveTexture, propertyKey: "level", propertyPath: "emissiveTexture.level", min: 0, max: 2, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Bump Level", target: standardMaterial.bumpTexture, propertyKey: "level", propertyPath: "bumpTexture.level", min: 0, max: 2, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Opacity Level", target: standardMaterial.opacityTexture, propertyKey: "level", propertyPath: "opacityTexture.level", min: 0, max: 2, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Ambient Level", target: standardMaterial.ambientTexture, propertyKey: "level", propertyPath: "ambientTexture.level", min: 0, max: 2, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Lightmap Level", target: standardMaterial.lightmapTexture, propertyKey: "level", propertyPath: "lightmapTexture.level", min: 0, max: 2, step: 0.01 }), jsxs(Collapse, { visible: isDetailMapEnabled, children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Detailmap Diffuse", target: standardMaterial.detailMap, propertyKey: "diffuseBlendLevel", propertyPath: "detailMap.diffuseBlendLevel", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Detailmap Bump", target: standardMaterial.detailMap, propertyKey: "bumpLevel", propertyPath: "detailMap.bumpLevel", min: 0, max: 1, step: 0.01 })] })] }));
};
/**
 * Displays the lighting and color properties of a standard material.
 * @param props - The required properties
 * @returns A JSX element representing the lighting and color properties.
 */
const StandardMaterialLightingAndColorProperties = (props) => {
    const { standardMaterial } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: Color3PropertyLine, label: "Diffuse Color", target: standardMaterial, propertyKey: "diffuseColor" }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Specular Color", target: standardMaterial, propertyKey: "specularColor" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Specular Power", target: standardMaterial, propertyKey: "specularPower", min: 0, max: 128, step: 0.1 }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Emissive Color", target: standardMaterial, propertyKey: "emissiveColor" }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Ambient Color", target: standardMaterial, propertyKey: "ambientColor" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Specular Over Alpha", target: standardMaterial, propertyKey: "useSpecularOverAlpha" })] }));
};

const MaterialPropertiesServiceDefinition = {
    friendlyName: "Material Properties",
    consumes: [PropertiesServiceIdentity, SelectionServiceIdentity, SettingsContextIdentity],
    factory: (propertiesService, selectionService, settingsContext) => {
        const materialContentRegistration = propertiesService.addSectionContent({
            key: "Material Properties",
            predicate: (entity) => entity instanceof Material,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(MaterialGeneralProperties, { material: context }),
                },
                {
                    section: "Transparency",
                    component: ({ context }) => jsx(MaterialTransparencyProperties, { material: context }),
                },
                {
                    section: "Stencil",
                    component: ({ context }) => jsx(MaterialStencilProperties, { material: context }),
                },
            ],
        });
        const standardMaterialContentRegistration = propertiesService.addSectionContent({
            key: "Standard Material Properties",
            predicate: (entity) => entity instanceof StandardMaterial,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(StandardMaterialGeneralProperties, { material: context }),
                },
                {
                    section: "Transparency",
                    component: ({ context }) => jsx(StandardMaterialTransparencyProperties, { material: context }),
                },
                {
                    section: "Textures",
                    component: ({ context }) => jsx(StandardMaterialTexturesProperties, { material: context, selectionService: selectionService }),
                },
                {
                    section: "Lighting & Colors",
                    component: ({ context }) => jsx(StandardMaterialLightingAndColorProperties, { standardMaterial: context }),
                },
                {
                    section: "Levels",
                    component: ({ context }) => jsx(StandardMaterialLevelsProperties, { standardMaterial: context }),
                },
                {
                    section: "Normal Map",
                    component: ({ context }) => jsx(NormalMapProperties, { material: context }),
                },
            ],
        });
        const pbrMaterialPropertyChangedObserver = propertiesService.onPropertyChanged.add((changeInfo) => {
            /**
             * In Inspector V2, all PBR materials (PBRMaterial, PBRMetallicRoughnessMaterial, PBRSpecularGlossinessMaterial) are edited using the PBRBaseMaterial properties.
             * Therefore, when a property of PBRBaseMaterial is changed, we need to mark the material as dirty to ensure the changes are reflected correctly because none of the properties
             * of PBRBaseMaterial are tagged with a decorator that would automatically mark the material as dirty.
             */
            if (changeInfo.entity instanceof PBRBaseMaterial) {
                changeInfo.entity.markAsDirty(Material.AllDirtyFlag);
            }
        });
        const pbrBaseMaterialPropertiesRegistration = propertiesService.addSectionContent({
            key: "PBR Base Material Properties",
            predicate: (entity) => entity instanceof PBRBaseMaterial,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(PBRBaseMaterialGeneralProperties, { material: context }),
                },
                {
                    section: "Transparency",
                    component: ({ context }) => jsx(PBRBaseMaterialTransparencyProperties, { material: context }),
                },
                {
                    section: "Textures",
                    component: ({ context }) => jsx(PBRBaseMaterialChannelsProperties, { material: context, selectionService: selectionService }),
                },
                {
                    section: "Lighting & Colors",
                    component: ({ context }) => jsx(PBRBaseMaterialLightingAndColorProperties, { material: context }),
                },
                {
                    section: "Metallic Workflow",
                    component: ({ context }) => jsx(PBRBaseMaterialMetallicWorkflowProperties, { material: context, selectionService: selectionService }),
                },
                {
                    section: "Clear Coat",
                    component: ({ context }) => jsx(PBRBaseMaterialClearCoatProperties, { material: context, selectionService: selectionService }),
                },
                {
                    section: "Iridescence",
                    component: ({ context }) => jsx(PBRBaseMaterialIridescenceProperties, { material: context, selectionService: selectionService }),
                },
                {
                    section: "Anisotropic",
                    component: ({ context }) => jsx(PBRBaseMaterialAnisotropicProperties, { material: context, selectionService: selectionService }),
                },
                {
                    section: "Sheen",
                    component: ({ context }) => jsx(PBRBaseMaterialSheenProperties, { material: context, selectionService: selectionService }),
                },
                {
                    section: "SubSurface",
                    component: ({ context }) => jsx(PBRBaseMaterialSubSurfaceProperties, { material: context, selectionService: selectionService }),
                },
                {
                    section: "Levels",
                    component: ({ context }) => jsx(PBRBaseMaterialLevelProperties, { material: context }),
                },
                {
                    section: "Rendering",
                    component: ({ context }) => jsx(PBRBaseMaterialRenderingProperties, { material: context }),
                },
                {
                    section: "Normal Map",
                    component: ({ context }) => jsx(NormalMapProperties, { material: context }),
                },
                {
                    section: "Advanced",
                    component: ({ context }) => jsx(PBRBaseMaterialAdvancedProperties, { material: context }),
                },
                {
                    section: "Debug",
                    component: ({ context }) => jsx(PBRBaseMaterialDebugProperties, { material: context }),
                },
            ],
        });
        const openPBRMaterialPropertiesRegistration = propertiesService.addSectionContent({
            key: "OpenPBR Material Properties",
            predicate: (entity) => entity instanceof OpenPBRMaterial,
            content: [
                {
                    section: "Base",
                    component: ({ context }) => jsx(OpenPBRMaterialBaseProperties, { material: context }),
                },
                {
                    section: "Specular",
                    component: ({ context }) => jsx(OpenPBRMaterialSpecularProperties, { material: context }),
                },
                {
                    section: "Transmission",
                    component: ({ context }) => jsx(OpenPBRMaterialTransmissionProperties, { material: context }),
                },
                {
                    section: "Coat",
                    component: ({ context }) => jsx(OpenPBRMaterialCoatProperties, { material: context }),
                },
                {
                    section: "Fuzz",
                    component: ({ context }) => jsx(OpenPBRMaterialFuzzProperties, { material: context }),
                },
                {
                    section: "Emission",
                    component: ({ context }) => jsx(OpenPBRMaterialEmissionProperties, { material: context }),
                },
                {
                    section: "Thin Film",
                    component: ({ context }) => jsx(OpenPBRMaterialThinFilmProperties, { material: context }),
                },
                {
                    section: "Geometry",
                    component: ({ context }) => jsx(OpenPBRMaterialGeometryProperties, { material: context }),
                },
            ],
        });
        const skyMaterialRegistration = propertiesService.addSectionContent({
            key: "Sky Material Properties",
            predicate: (entity) => entity instanceof SkyMaterial,
            content: [
                {
                    section: "Sky",
                    component: ({ context }) => jsx(SkyMaterialProperties, { material: context, settings: settingsContext }),
                },
            ],
        });
        const multiMaterialContentRegistration = propertiesService.addSectionContent({
            key: "Multi Material Properties",
            predicate: (entity) => entity instanceof MultiMaterial,
            content: [
                {
                    section: "Children",
                    component: ({ context }) => jsx(MultiMaterialChildrenProperties, { multiMaterial: context, selectionService: selectionService }),
                },
            ],
        });
        const nodeMaterialContentRegistration = propertiesService.addSectionContent({
            key: "Node Material Properties",
            predicate: (entity) => entity instanceof NodeMaterial,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(NodeMaterialGeneralProperties, { material: context }),
                },
                {
                    section: "Inputs",
                    component: ({ context }) => jsx(NodeMaterialInputProperties, { material: context }),
                },
            ],
        });
        return {
            dispose: () => {
                pbrMaterialPropertyChangedObserver.remove();
                materialContentRegistration.dispose();
                standardMaterialContentRegistration.dispose();
                pbrBaseMaterialPropertiesRegistration.dispose();
                openPBRMaterialPropertiesRegistration.dispose();
                skyMaterialRegistration.dispose();
                multiMaterialContentRegistration.dispose();
                nodeMaterialContentRegistration.dispose();
            },
        };
    },
};

const useInputStyles = makeStyles({
    textarea: {
        minHeight: "100px",
        maxHeight: "500px",
    },
});
/**
 * This is a texarea box that stops propagation of change/keydown events
 * @param props
 * @returns
 */
const Textarea = (props) => {
    Textarea.displayName = "Textarea";
    const classes = useInputStyles();
    const handleChange = (event, _data) => {
        event.stopPropagation(); // Prevent event propagation
        if (props.onChange) {
            props.onChange(event.target.value); // Call the original onChange handler passed as prop
        }
    };
    const handleKeyDown = (event) => {
        event.stopPropagation(); // Prevent event propagation
    };
    return jsx(Textarea$1, { ...props, textarea: { className: classes.textarea }, onChange: handleChange, onKeyDown: handleKeyDown });
};

const PrettyJSONIndent = 2;
function IsParsable(metadata) {
    try {
        const parsed = JSON.parse(metadata);
        return !!parsed && !IsString(parsed);
    }
    catch {
        return false;
    }
}
/**
 * Checks if the input is a string.
 * @param input - any input to check
 * @returns boolean - true if the input is a string, false otherwise
 */
function IsString(input) {
    return typeof input === "string" || input instanceof String;
}
/**
 * Checks recursively for functions on an object and returns `false` if any are found.
 * @param o any object, string or number
 * @returns boolean
 */
function ObjectCanSafelyStringify(o) {
    if (typeof o === "function") {
        return false;
    }
    if (o === null || o === true || o === false || typeof o === "number" || IsString(o)) {
        return true;
    }
    if (typeof o === "object") {
        if (Object.values(o).length === 0) {
            return true;
        }
        return Object.values(o).every((value) => ObjectCanSafelyStringify(value));
    }
    if (Array.isArray(o)) {
        return o.every((value) => ObjectCanSafelyStringify(value));
    }
    return false;
}
function GetMetadataEntityType(metadata) {
    if (metadata == null) {
        return "null";
    }
    else if (IsString(metadata)) {
        return "string";
    }
    else if (!ObjectCanSafelyStringify(metadata)) {
        return "object";
    }
    else {
        return "JSON";
    }
}
function HasGltfExtras(metadata) {
    return IsParsable(metadata) && !!JSON.parse(metadata).gltf;
}
function StringifyMetadata(metadata, format) {
    if (IsString(metadata)) {
        return metadata;
    }
    if (metadata) {
        if (ObjectCanSafelyStringify(metadata)) {
            return JSON.stringify(metadata, undefined, undefined);
        }
        else {
            return String(metadata);
        }
    }
    return null;
}
function Restringify(value, format) {
    return IsParsable(value) ? JSON.stringify(JSON.parse(value), undefined, format ? PrettyJSONIndent : undefined) : value;
}
function PopulateGLTFExtras(metadata) {
    if (!metadata) {
        metadata = "{}";
    }
    if (!IsParsable(metadata)) {
        return metadata;
    }
    try {
        const parsedJson = JSON.parse(metadata);
        if (parsedJson) {
            if (Reflect.has(parsedJson, "gltf")) {
                if (!Reflect.has(parsedJson.gltf, "extras")) {
                    parsedJson.gltf.extras = {};
                }
            }
            else {
                parsedJson.gltf = { extras: {} };
            }
        }
        return JSON.stringify(parsedJson);
    }
    catch {
        return metadata;
    }
}
function SaveMetadata(entity, metadata) {
    if (IsParsable(metadata)) {
        entity.metadata = JSON.parse(metadata);
    }
    else {
        entity.metadata = metadata;
    }
}
const useStyles$h = makeStyles({
    mainDiv: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalXS,
    },
    buttonDiv: {
        display: "grid",
        gridAutoFlow: "column",
        gridTemplateColumns: "1fr auto auto auto",
        gap: tokens.spacingHorizontalXS,
    },
});
/**
 * Component to display metadata properties of an entity.
 * @param props - The properties for the component.
 * @returns A React component that displays metadata properties.
 */
const MetadataProperties = (props) => {
    const { entity } = props;
    const classes = useStyles$h();
    const { size } = useContext(ToolContext);
    const metadata = useProperty(entity, "metadata");
    const stringifiedMetadata = useMemo(() => StringifyMetadata(metadata) ?? "", [metadata]);
    const metadataType = useMemo(() => GetMetadataEntityType(metadata), [metadata]);
    const canPreventObjectCorruption = metadataType === "object";
    const [preventObjectCorruption, setPreventObjectCorruption] = useState(false);
    const isReadonly = canPreventObjectCorruption && preventObjectCorruption;
    const [editedMetadata, setEditedMetadata] = useState(stringifiedMetadata);
    const isEditedMetadataJSON = useMemo(() => IsParsable(editedMetadata), [editedMetadata]);
    const unformattedEditedMetadata = useMemo(() => Restringify(editedMetadata, false), [editedMetadata]);
    return (jsxs(Fragment, { children: [jsx(TextPropertyLine, { label: "Property Type", value: metadataType }), jsx(Collapse, { visible: canPreventObjectCorruption, children: jsx(SwitchPropertyLine, { label: "Prevent Object Corruption", value: isReadonly, onChange: setPreventObjectCorruption }) }), jsx(LineContainer, { children: jsx(Textarea, { disabled: isReadonly, value: editedMetadata, onChange: setEditedMetadata }) }), jsx(ButtonLine, { label: "Populate glTF extras", disabled: !!editedMetadata && (!IsParsable(editedMetadata) || HasGltfExtras(editedMetadata)), onClick: () => {
                    const isFormatted = Restringify(editedMetadata, true) === editedMetadata;
                    let withGLTFExtras = PopulateGLTFExtras(editedMetadata);
                    if (isFormatted) {
                        withGLTFExtras = Restringify(withGLTFExtras, true);
                    }
                    setEditedMetadata(withGLTFExtras);
                } }), jsx(LineContainer, { children: jsxs("div", { className: classes.buttonDiv, children: [jsx(Button$1, { size: size, icon: jsx(SaveRegular, {}), disabled: stringifiedMetadata === unformattedEditedMetadata, onClick: () => SaveMetadata(entity, editedMetadata), children: jsx(Body1, { children: "Save" }) }), jsx(Tooltip$1, { content: "Undo Changes", relationship: "label", children: jsx(Button$1, { size: size, icon: jsx(ArrowUndoRegular, {}), disabled: stringifiedMetadata === unformattedEditedMetadata, onClick: () => setEditedMetadata(stringifiedMetadata) }) }), jsx(Tooltip$1, { content: "Format (Pretty Print)", relationship: "label", children: jsx(Button$1, { size: size, icon: jsx(BracesRegular, {}), disabled: !isEditedMetadataJSON, onClick: () => setEditedMetadata(Restringify(editedMetadata, true)) }) }), jsx(Tooltip$1, { content: "Clear Formatting (Undo Pretty Print)", relationship: "label", children: jsx(Button$1, { size: size, icon: jsx(BracesDismiss16Regular, {}), disabled: !isEditedMetadataJSON, onClick: () => setEditedMetadata(Restringify(editedMetadata, false)) }) })] }) })] }));
};

function IsMetadataContainer(entity) {
    return entity.metadata !== undefined;
}
const MetadataPropertiesServiceDefinition = {
    friendlyName: "Metadata Properties",
    consumes: [PropertiesServiceIdentity],
    factory: (propertiesService) => {
        const contentRegistration = propertiesService.addSectionContent({
            key: "Metadata Properties",
            // TransformNode and Bone don't share a common base class, but both have the same transform related properties.
            predicate: (entity) => IsMetadataContainer(entity),
            content: [
                {
                    section: "Metadata",
                    component: ({ context }) => jsx(MetadataProperties, { entity: context }),
                },
            ],
        });
        return {
            dispose: () => {
                contentRegistration.dispose();
            },
        };
    },
};

const AbstractMeshGeneralProperties = (props) => {
    const { mesh, selectionService } = props;
    // Use the observable to keep keep state up-to-date and re-render the component when it changes.
    const isAnInstance = useProperty(mesh, "isAnInstance");
    // TODO: Handle case where array is mutated
    const subMeshes = useProperty(mesh, "subMeshes");
    return (jsxs(Fragment, { children: [jsx(StringifiedPropertyLine, { label: "Vertices", value: mesh.getTotalVertices() }), jsx(StringifiedPropertyLine, { label: "Faces", value: mesh.getTotalIndices() / 3 }), jsx(StringifiedPropertyLine, { label: "Sub-Meshes", value: subMeshes.length }), jsx(BoundProperty, { defaultValue: null, component: SkeletonSelectorPropertyLine, label: "Skeleton", description: "The skeleton associated with the mesh.", target: mesh, propertyKey: "skeleton", scene: mesh.getScene(), onLink: (skeleton) => (selectionService.selectedEntity = skeleton) }), !mesh.isAnInstance && (jsx(BoundProperty, { defaultValue: null, component: MaterialSelectorPropertyLine, label: "Material", description: "The material used by the mesh.", target: mesh, propertyKey: "material", scene: mesh.getScene(), onLink: (material) => (selectionService.selectedEntity = material) })), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Is Pickable", target: mesh, propertyKey: "isPickable" }), isAnInstance && mesh instanceof InstancedMesh && (jsx(BoundProperty, { component: NodeSelectorPropertyLine, label: "Source", description: "The source mesh from which this instance was created.", target: mesh, propertyKey: "sourceMesh", scene: mesh.getScene(), onLink: (node) => (selectionService.selectedEntity = node) }))] }));
};
const AbstractMeshDisplayProperties = (props) => {
    const { mesh } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Alpha Index", target: mesh, propertyKey: "alphaIndex" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Receive Shadows", target: mesh, propertyKey: "receiveShadows" }), mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && (jsxs(Fragment, { children: [jsx(BoundProperty, { label: "Use Vertex Colors", component: SwitchPropertyLine, target: mesh, propertyKey: "useVertexColors" }), jsx(BoundProperty, { label: "Has Vertex Alpha", component: SwitchPropertyLine, target: mesh, propertyKey: "hasVertexAlpha" })] })), mesh.getScene().fogMode !== Constants.FOGMODE_NONE && jsx(BoundProperty, { label: "Apply Fog", component: SwitchPropertyLine, target: mesh, propertyKey: "applyFog" }), !mesh.parent && jsx(BoundProperty, { component: SwitchPropertyLine, label: "Infinite distance", target: mesh, propertyKey: "infiniteDistance" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Rendering Group Id", target: mesh, propertyKey: "renderingGroupId", min: RenderingManager.MIN_RENDERINGGROUPS, max: RenderingManager.MAX_RENDERINGGROUPS - 1, step: 1 }), jsx(BoundProperty, { component: HexPropertyLine, label: "Layer Mask", target: mesh, propertyKey: "layerMask" })] }));
};
const AbstractMeshAdvancedProperties = (props) => {
    const { mesh } = props;
    return (jsxs(Fragment, { children: [mesh.useBones && (jsx(BoundProperty, { component: SwitchPropertyLine, label: "Compute Bones Using Shaders", description: "Whether to compute bones using shaders.", target: mesh, propertyKey: "computeBonesUsingShaders" })), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Check Collisions", description: "Whether to check for collisions.", target: mesh, propertyKey: "checkCollisions" }), jsx(TextPropertyLine, { label: "Geometry ID", value: mesh.geometry?.uniqueId.toString() ?? "N/A" }), jsx(BooleanBadgePropertyLine, { label: "Has Normals", value: mesh.isVerticesDataPresent(VertexBuffer.NormalKind) }), jsx(BooleanBadgePropertyLine, { label: "Has Vertex Colors", value: mesh.isVerticesDataPresent(VertexBuffer.ColorKind) }), jsx(BooleanBadgePropertyLine, { label: "Has UV Set 0", value: mesh.isVerticesDataPresent(VertexBuffer.UVKind) }), jsx(BooleanBadgePropertyLine, { label: "Has UV Set 1", value: mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) }), jsx(BooleanBadgePropertyLine, { label: "Has UV Set 2", value: mesh.isVerticesDataPresent(VertexBuffer.UV3Kind) }), jsx(BooleanBadgePropertyLine, { label: "Has UV Set 3", value: mesh.isVerticesDataPresent(VertexBuffer.UV4Kind) }), jsx(BooleanBadgePropertyLine, { label: "Has Tangents", value: mesh.isVerticesDataPresent(VertexBuffer.TangentKind) }), jsx(BooleanBadgePropertyLine, { label: "Has Matrix Weights", value: mesh.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind) }), jsx(BooleanBadgePropertyLine, { label: "Has Matrix Indices", value: mesh.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) })] }));
};
const AbstractMeshOutlineOverlayProperties = (props) => {
    const { mesh } = props;
    const renderOverlay = useProperty(mesh, "renderOverlay");
    const renderOutline = useProperty(mesh, "renderOutline");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Render Overlay", target: mesh, propertyKey: "renderOverlay" }), jsx(Collapse, { visible: renderOverlay, children: jsx(BoundProperty, { label: "Overlay Color", component: Color3PropertyLine, target: mesh, propertyKey: "overlayColor" }) }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Render Outline", target: mesh, propertyKey: "renderOutline" }), jsxs(Collapse, { visible: renderOutline, children: [jsx(BoundProperty, { label: "Outline Color", component: Color3PropertyLine, target: mesh, propertyKey: "outlineColor" }), jsx(BoundProperty, { label: "Outline Width", component: NumberInputPropertyLine, target: mesh, propertyKey: "outlineWidth", step: 0.001 })] })] }));
};
const OcclusionTypes = [
    { label: "None", value: 0 },
    { label: "Optimistic", value: 1 },
    { label: "Strict", value: 2 },
];
const OcclusionQueryAlgorithmTypes = [
    { label: "Conservative", value: 0 },
    { label: "Accurate", value: 1 },
];
const AbstractMeshOcclusionsProperties = ({ mesh }) => {
    const occlusionType = useProperty(mesh, "occlusionType");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Type", description: "Occlusion type for the mesh.", target: mesh, propertyKey: "occlusionType", options: OcclusionTypes }), jsx(Collapse, { visible: occlusionType !== 0, children: jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Occlusion Retry Count", description: "Number of retries for occlusion (-1 disables retries).", target: mesh, propertyKey: "occlusionRetryCount", min: -1, max: 10, step: 1 }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Algorithm", description: "Occlusion query algorithm type.", target: mesh, propertyKey: "occlusionQueryAlgorithmType", options: OcclusionQueryAlgorithmTypes })] }) })] }));
};
const AbstractMeshEdgeRenderingProperties = ({ mesh }) => {
    const edgesRenderer = useProperty(mesh, "_edgesRenderer");
    return (jsxs(Fragment, { children: [jsx(SwitchPropertyLine, { label: "Enable", value: !!edgesRenderer, onChange: (isEnabled) => {
                    if (isEnabled) {
                        mesh.enableEdgesRendering();
                    }
                    else {
                        mesh.disableEdgesRendering();
                    }
                } }), jsxs(Collapse, { visible: !!edgesRenderer, children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Edges Width", description: "Width of the rendered edges (0 to 10).", target: mesh, propertyKey: "edgesWidth", min: 0, max: 10, step: 0.1 }), jsx(BoundProperty, { component: Color4PropertyLine, label: "Edge Color", target: mesh, propertyKey: "edgesColor" })] })] }));
};
const AbstractMeshDebugProperties = (props) => {
    const { mesh } = props;
    const skeleton = useProperty(mesh, "skeleton");
    const [displayNormals, setDisplayNormals] = useState(mesh.material?.getClassName() === "NormalMaterial");
    const [displayVertexColors, setDisplayVertexColors] = useState(mesh.material?.reservedDataStore?.isVertexColorMaterial ? true : false);
    const [renderNormalVectors] = useState(mesh.reservedDataStore?.normalLines ? true : false);
    const [renderWireframeOver] = useState(mesh.reservedDataStore?.wireframeOver ? true : false);
    const [displayBoneWeights, setDisplayBoneWeights] = useState(mesh.material?.getClassName() === "BoneWeightShader");
    const [displaySkeletonMap, setDisplaySkeletonMap] = useState(mesh.material?.getClassName() === "SkeletonMapShader");
    const [displayBoneIndex, setDisplayBoneIndex] = useState(mesh.reservedDataStore?.displayBoneIndex ?? 0);
    const [targetBoneOptions] = useState(mesh.skeleton
        ? mesh.skeleton.bones
            .filter((bone) => bone.getIndex() >= 0)
            .sort((bone1, bone2) => bone1.getIndex() - bone2.getIndex())
            .map((bone) => {
            return {
                label: bone.name,
                value: bone.getIndex(),
            };
        })
        : []);
    const displayNormalsHandlerAsync = async function () {
        const scene = mesh.getScene();
        if (mesh.material?.getClassName() === "NormalMaterial") {
            mesh.material.dispose();
            mesh.material = mesh.reservedDataStore.originalMaterial;
            mesh.reservedDataStore.originalMaterial = null;
            setDisplayNormals(false);
        }
        else {
            try {
                const { NormalMaterial } = await import('@babylonjs/materials/normal/normalMaterial.js');
                if (!mesh.reservedDataStore) {
                    mesh.reservedDataStore = {};
                }
                if (!mesh.reservedDataStore.originalMaterial) {
                    mesh.reservedDataStore.originalMaterial = mesh.material;
                }
                const normalMaterial = new NormalMaterial("normalMaterial", scene);
                normalMaterial.disableLighting = true;
                if (mesh.material) {
                    normalMaterial.sideOrientation = mesh.material.sideOrientation;
                }
                normalMaterial.reservedDataStore = { hidden: true };
                mesh.material = normalMaterial;
                setDisplayVertexColors(false);
                setDisplayBoneWeights(false);
                setDisplaySkeletonMap(false);
                setDisplayNormals(true);
            }
            catch {
                Tools.Warn("NormalMaterial could not be loaded.");
            }
        }
    };
    const displayVertexColorsHandler = function () {
        const scene = mesh.getScene();
        if (mesh.material?.reservedDataStore?.isVertexColorMaterial) {
            mesh.material.dispose();
            mesh.material = mesh.reservedDataStore.originalMaterial;
            mesh.reservedDataStore.originalMaterial = null;
            setDisplayVertexColors(false);
        }
        else {
            if (!mesh.reservedDataStore) {
                mesh.reservedDataStore = {};
            }
            if (!mesh.reservedDataStore.originalMaterial) {
                mesh.reservedDataStore.originalMaterial = mesh.material;
            }
            const vertexColorMaterial = new StandardMaterial("vertex colors", scene);
            vertexColorMaterial.disableLighting = true;
            vertexColorMaterial.emissiveColor = Color3.White();
            if (mesh.material) {
                vertexColorMaterial.sideOrientation = mesh.material.sideOrientation;
            }
            vertexColorMaterial.reservedDataStore = { hidden: true, isVertexColorMaterial: true };
            mesh.useVertexColors = true;
            mesh.material = vertexColorMaterial;
            setDisplayNormals(false);
            setDisplayBoneWeights(false);
            setDisplaySkeletonMap(false);
            setDisplayVertexColors(true);
        }
    };
    const renderNormalVectorsHandler = function () {
        const scene = mesh.getScene();
        if (mesh.reservedDataStore && mesh.reservedDataStore.normalLines) {
            mesh.reservedDataStore.normalLines.dispose();
            mesh.reservedDataStore.normalLines = null;
            return;
        }
        const normals = mesh.getVerticesData(VertexBuffer.NormalKind);
        const positions = mesh.getVerticesData(VertexBuffer.PositionKind);
        const color = Color3.White();
        const bbox = mesh.getBoundingInfo();
        const diag = bbox.maximum.subtractToRef(bbox.minimum, TmpVectors.Vector3[0]);
        const size = diag.length() * 0.05;
        const lines = [];
        for (let i = 0; i < normals.length; i += 3) {
            const v1 = Vector3.FromArray(positions, i);
            const v2 = v1.add(Vector3.FromArray(normals, i).scaleInPlace(size));
            lines.push([v1, v2]);
        }
        const normalLines = CreateLineSystem("normalLines", { lines: lines }, scene);
        normalLines.color = color;
        normalLines.parent = mesh;
        normalLines.reservedDataStore = { hidden: true };
        if (!mesh.reservedDataStore) {
            mesh.reservedDataStore = {};
        }
        mesh.reservedDataStore.normalLines = normalLines;
    };
    const renderWireframeOverHandler = function () {
        const scene = mesh.getScene();
        if (mesh.reservedDataStore?.wireframeOver) {
            const frameGraph = scene.frameGraph;
            if (frameGraph) {
                const objectRenderer = FrameGraphUtils.FindMainObjectRenderer(frameGraph);
                if (objectRenderer && objectRenderer.objectList.meshes) {
                    const idx = objectRenderer.objectList.meshes.indexOf(mesh.reservedDataStore.wireframeOver);
                    if (idx !== -1) {
                        objectRenderer.objectList.meshes.splice(idx, 1);
                    }
                }
            }
            mesh.reservedDataStore.wireframeOver.dispose(false, true);
            mesh.reservedDataStore.wireframeOver = null;
            return;
        }
        const wireframeOver = mesh.clone(mesh.name + "_wireframeover", null, true);
        if (wireframeOver === null) {
            return;
        }
        wireframeOver.reservedDataStore = { hidden: true };
        // Sets up the mesh to be attached to the parent.
        // So all neutral in local space.
        wireframeOver.parent = mesh;
        wireframeOver.position = Vector3.Zero();
        wireframeOver.scaling = new Vector3(1, 1, 1);
        wireframeOver.rotation = Vector3.Zero();
        wireframeOver.rotationQuaternion = null;
        const material = new StandardMaterial("wireframeOver", scene);
        material.reservedDataStore = { hidden: true };
        wireframeOver.material = material;
        material.disableLighting = true;
        material.backFaceCulling = false;
        material.emissiveColor = Color3.White();
        material.wireframe = true;
        if (!mesh.reservedDataStore) {
            mesh.reservedDataStore = {};
        }
        mesh.reservedDataStore.wireframeOver = wireframeOver;
        const frameGraph = scene.frameGraph;
        if (frameGraph) {
            const objectRenderer = FrameGraphUtils.FindMainObjectRenderer(frameGraph);
            if (objectRenderer && objectRenderer.objectList.meshes) {
                objectRenderer.objectList.meshes.push(wireframeOver);
            }
        }
    };
    const displayBoneWeightsHandler = function () {
        const scene = mesh.getScene();
        if (mesh.material?.getClassName() === "BoneWeightShader") {
            mesh.material.dispose();
            mesh.material = mesh.reservedDataStore.originalMaterial;
            mesh.reservedDataStore.originalMaterial = null;
            setDisplayBoneWeights(false);
        }
        else {
            if (!mesh.reservedDataStore) {
                mesh.reservedDataStore = {};
            }
            if (!mesh.reservedDataStore.originalMaterial) {
                mesh.reservedDataStore.originalMaterial = mesh.material;
            }
            if (!mesh.reservedDataStore.displayBoneIndex) ;
            if (mesh.skeleton) {
                const boneWeightsShader = SkeletonViewer.CreateBoneWeightShader({ skeleton: mesh.skeleton }, scene);
                boneWeightsShader.reservedDataStore = { hidden: true };
                mesh.material = boneWeightsShader;
            }
            setDisplayNormals(false);
            setDisplayVertexColors(false);
            setDisplaySkeletonMap(false);
            setDisplayBoneWeights(true);
        }
    };
    const displaySkeletonMapHandler = function () {
        const scene = mesh.getScene();
        if (mesh.material?.getClassName() === "SkeletonMapShader") {
            mesh.material.dispose();
            mesh.material = mesh.reservedDataStore.originalMaterial;
            mesh.reservedDataStore.originalMaterial = null;
            setDisplaySkeletonMap(false);
        }
        else {
            if (!mesh.reservedDataStore) {
                mesh.reservedDataStore = {};
            }
            if (!mesh.reservedDataStore.originalMaterial) {
                mesh.reservedDataStore.originalMaterial = mesh.material;
            }
            if (mesh.skeleton) {
                const skeletonMapShader = SkeletonViewer.CreateSkeletonMapShader({ skeleton: mesh.skeleton }, scene);
                skeletonMapShader.reservedDataStore = { hidden: true };
                mesh.material = skeletonMapShader;
            }
            setDisplayNormals(false);
            setDisplayVertexColors(false);
            setDisplayBoneWeights(false);
            setDisplaySkeletonMap(true);
        }
    };
    const onBoneDisplayIndexChangeHandler = function (value) {
        mesh.reservedDataStore.displayBoneIndex = value;
        setDisplayBoneIndex(value);
        if (mesh.material && mesh.material.getClassName() === "BoneWeightShader") {
            mesh.material.setFloat("targetBoneIndex", value);
        }
    };
    return (jsxs(Fragment, { children: [jsx(SwitchPropertyLine, { label: "Display Normals", value: displayNormals, onChange: async () => await displayNormalsHandlerAsync() }), jsx(SwitchPropertyLine, { label: "Display Vertex Colors", value: displayVertexColors, onChange: () => displayVertexColorsHandler() }), jsx(SwitchPropertyLine, { label: "Render Vertex Normals", value: renderNormalVectors, onChange: () => renderNormalVectorsHandler() }), jsx(SwitchPropertyLine, { label: "Render Wireframe over Mesh", value: renderWireframeOver, onChange: () => renderWireframeOverHandler() }), skeleton && jsx(SwitchPropertyLine, { label: "Display Bone Weights", value: displayBoneWeights, onChange: () => displayBoneWeightsHandler() }), jsx(Collapse, { visible: displayBoneWeights, children: jsxs("div", { children: [jsx(NumberDropdownPropertyLine, { label: "Target Bone Name", options: targetBoneOptions, value: displayBoneIndex, onChange: (value) => {
                                onBoneDisplayIndexChangeHandler(value);
                            } }), jsx(SyncedSliderPropertyLine, { label: "Target Bone", value: displayBoneIndex, min: 0, max: targetBoneOptions.length - 1, step: 1, onChange: (value) => onBoneDisplayIndexChangeHandler(value) })] }) }), skeleton && jsx(SwitchPropertyLine, { label: "Display Skeleton Map", value: displaySkeletonMap, onChange: () => displaySkeletonMapHandler() })] }));
};

const GaussianSplattingDisplayProperties = (props) => {
    const { mesh } = props;
    return (jsxs(Fragment, { children: [jsx(StringifiedPropertyLine, { label: "Splat Count", value: mesh.splatCount ?? 0 }), jsx(StringifiedPropertyLine, { label: "SH Parameter Count", value: (mesh.shDegree + 1) * (mesh.shDegree + 1) - 1 }), jsx(BooleanBadgePropertyLine, { label: "Has Compensation", value: mesh.compensation }), jsx(StringifiedPropertyLine, { label: "Kernel Size", value: mesh.kernelSize })] }));
};

const MeshGeneralProperties = (props) => {
    const { mesh } = props;
    const nodeGeometry = mesh._internalMetadata?.nodeGeometry;
    return (jsx(Fragment, { children: nodeGeometry && (jsx(ButtonLine, { label: "Edit", icon: EditRegular, onClick: async () => {
                // TODO: Figure out how to get all the various build steps to work with this.
                //       See the initial attempt here: https://github.com/BabylonJS/Babylon.js/pull/17646
                // const { NodeGeometryEditor } = await import("node-geometry-editor/nodeGeometryEditor");
                // NodeGeometryEditor.Show({ nodeGeometry: nodeGeometry, hostScene: mesh.getScene() });
                await nodeGeometry.edit({ nodeGeometryEditorConfig: { hostScene: mesh.getScene() } });
            } })) }));
};
const MeshDisplayProperties = (props) => {
    const { mesh } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Visibility", description: "Controls the visibility of the mesh. 0 is invisible, 1 is fully visible.", target: mesh, propertyKey: "visibility", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Orientation", description: "Controls the side orientation or winding order of the mesh.", target: mesh, propertyKey: "sideOrientation", options: [
                    { value: Constants.MATERIAL_ClockWiseSideOrientation, label: "Clockwise" },
                    { value: Constants.MATERIAL_CounterClockWiseSideOrientation, label: "CounterClockwise" },
                ] })] }));
};
const MeshMorphTargetsProperties = (props) => {
    const { mesh } = props;
    if (!mesh.morphTargetManager) {
        return null;
    }
    const morphTargets = [];
    for (let index = 0; index < mesh.morphTargetManager.numTargets; index++) {
        const target = mesh.morphTargetManager.getTarget(index);
        if (target.hasPositions) {
            morphTargets.push(target);
        }
    }
    if (morphTargets.length === 0) {
        return null;
    }
    return (jsx(Fragment, { children: morphTargets.map((target, index) => (jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: target.name || `Target ${index}`, description: `Influence of morph target "${target.name || `Target ${index}`}"`, target: target, propertyKey: "influence", min: 0, max: 1, step: 0.01 }, index))) }));
};

const NodeGeneralProperties = (props) => {
    const { node, selectionService } = props;
    const isEnabled = useObservableState(() => node.isEnabled(false), node.onEnabledStateChangedObservable);
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NodeSelectorPropertyLine, label: "Parent", target: node, propertyKey: "parent", scene: node.getScene(), defaultValue: null, onLink: (parentNode) => (selectionService.selectedEntity = parentNode) }), jsx(Property, { component: SwitchPropertyLine, label: "Is Enabled", description: "Whether the node is enabled or not.", value: isEnabled, onChange: (checked) => node.setEnabled(checked), functionPath: "setEnabled" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Inherit Visibility", description: "Whether the node inherits visibility from its parent.", target: node, propertyKey: "inheritVisibility" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Is Visible", description: "Whether the node is visible or not.", target: node, propertyKey: "isVisible" })] }));
};

const NodePropertiesServiceDefinition = {
    friendlyName: "Mesh Properties",
    consumes: [PropertiesServiceIdentity, SelectionServiceIdentity],
    factory: (propertiesService, selectionService) => {
        const nodeContentRegistration = propertiesService.addSectionContent({
            key: "Node Properties",
            predicate: (entity) => entity instanceof Node,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(NodeGeneralProperties, { node: context, selectionService: selectionService }),
                },
            ],
        });
        const abstractMeshContentRegistration = propertiesService.addSectionContent({
            key: "Abstract Mesh Properties",
            // Meshes without vertices are effectively TransformNodes, so don't add mesh properties for them.
            predicate: (entity) => entity instanceof AbstractMesh && entity.getTotalVertices() > 0,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(AbstractMeshGeneralProperties, { mesh: context, selectionService: selectionService }),
                },
                {
                    section: "Display",
                    component: ({ context }) => jsx(AbstractMeshDisplayProperties, { mesh: context }),
                },
                {
                    section: "Advanced",
                    component: ({ context }) => jsx(AbstractMeshAdvancedProperties, { mesh: context }),
                },
                {
                    section: "Outlines & Overlays",
                    component: ({ context }) => jsx(AbstractMeshOutlineOverlayProperties, { mesh: context }),
                },
                {
                    section: "Occlusions",
                    component: ({ context }) => jsx(AbstractMeshOcclusionsProperties, { mesh: context }),
                },
                {
                    section: "Edge Rendering",
                    component: ({ context }) => jsx(AbstractMeshEdgeRenderingProperties, { mesh: context }),
                },
                {
                    section: "Debug",
                    component: ({ context }) => jsx(AbstractMeshDebugProperties, { mesh: context }),
                },
            ],
        });
        const meshContentRegistration = propertiesService.addSectionContent({
            key: "Mesh Properties",
            predicate: (entity) => entity instanceof Mesh && entity.getTotalVertices() > 0,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(MeshGeneralProperties, { mesh: context }),
                },
                {
                    section: "Display",
                    component: ({ context }) => jsx(MeshDisplayProperties, { mesh: context }),
                },
                {
                    section: "Morph Targets",
                    component: ({ context }) => jsx(MeshMorphTargetsProperties, { mesh: context }),
                },
            ],
        });
        const gaussianSplattingContentRegistration = propertiesService.addSectionContent({
            key: "Gaussian Splatting Properties",
            predicate: (entity) => entity instanceof GaussianSplattingMesh && entity.getTotalVertices() > 0,
            content: [
                {
                    section: "Gaussian Splatting",
                    component: ({ context }) => jsx(GaussianSplattingDisplayProperties, { mesh: context }),
                },
            ],
        });
        return {
            dispose: () => {
                nodeContentRegistration.dispose();
                abstractMeshContentRegistration.dispose();
                meshContentRegistration.dispose();
                gaussianSplattingContentRegistration.dispose();
            },
        };
    },
};

/**
 * Display general (high-level) information about a particle system.
 * @param props Component props.
 * @returns Render property lines.
 */
const ParticleSystemSystemProperties = (props) => {
    const { particleSystem: system, selectionService } = props;
    const isCpuParticleSystem = system instanceof ParticleSystem;
    const isNodeGenerated = isCpuParticleSystem && system.isNodeGenerated;
    const scene = system.getScene();
    const isBillboardBased = useProperty(system, "isBillboardBased");
    const capacity = useObservableState(() => system.getCapacity());
    const activeCount = useObservableState(() => system.getActiveCount(), scene?.onBeforeRenderObservable);
    const selectEntity = (entity) => (selectionService.selectedEntity = entity);
    return (jsxs(Fragment, { children: [isCpuParticleSystem && (jsx(TextPropertyLine, { label: "Is Node Generated", description: "Indicates if the particle system was created from a node-based particle system.", value: String(isNodeGenerated) })), jsx(StringifiedPropertyLine, { label: "Capacity", description: "Maximum number of particles in the system.", value: capacity }), jsx(StringifiedPropertyLine, { label: "Active Particles", description: "Current number of active particles.", value: activeCount }), scene && !isNodeGenerated && (jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Particle Texture", target: system, propertyKey: "particleTexture", scene: scene, onLink: selectEntity, defaultValue: null })), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Blend Mode", target: system, propertyKey: "blendMode", options: BlendModeOptions }), jsx(BoundProperty, { component: Vector3PropertyLine, label: "World Offset", target: system, propertyKey: "worldOffset" }), jsx(BoundProperty, { component: Vector3PropertyLine, label: "Gravity", target: system, propertyKey: "gravity" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Is Billboard", target: system, propertyKey: "isBillboardBased" }), isBillboardBased && (jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Billboard Mode", target: system, propertyKey: "billboardMode", options: ParticleBillboardModeOptions })), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Is Local", target: system, propertyKey: "isLocal" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Force Depth Write", target: system, propertyKey: "forceDepthWrite" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Update Speed", target: system, propertyKey: "updateSpeed", min: 0, step: 0.01 }), isCpuParticleSystem && (jsx(ButtonLine, { label: isNodeGenerated ? "Edit" : "View as Node-Based Particle System", icon: isNodeGenerated ? EditRegular : EyeRegular, onClick: async () => {
                    const scene = system.getScene();
                    if (!scene) {
                        return;
                    }
                    const systemSet = isNodeGenerated ? system.source : await ConvertToNodeParticleSystemSetAsync("source", [system]);
                    if (systemSet) {
                        await systemSet.editAsync({ nodeEditorConfig: { backgroundColor: scene.clearColor, disposeOnClose: !isNodeGenerated } });
                    }
                } }))] }));
};

/**
 * Shared utilities for snippet server operations (save/load).
 */
/**
 * Persist a snippet ID to local storage for quick reuse.
 * @param storageKey The local storage key to use.
 * @param snippetId The snippet ID to persist.
 * @param maxItems Maximum number of items to store (default 50).
 */
function PersistSnippetId(storageKey, snippetId, maxItems = 50) {
    try {
        const existing = JSON.parse(localStorage.getItem(storageKey) || "[]");
        const list = Array.isArray(existing) ? existing : [];
        if (!list.includes(snippetId)) {
            list.unshift(snippetId);
        }
        localStorage.setItem(storageKey, JSON.stringify(list.slice(0, maxItems)));
    }
    catch {
        // Ignore storage failures.
    }
}
/**
 * Save content to the snippet server.
 * @param config Configuration for the save operation.
 * @returns Promise resolving to the save result.
 */
async function SaveToSnippetServer(config) {
    const { snippetUrl, currentSnippetId, content, payloadKey, storageKey, entityName } = config;
    const dataToSend = {
        payload: JSON.stringify({
            [payloadKey]: content,
        }),
        name: "",
        description: "",
        tags: "",
    };
    const headers = new Headers();
    headers.append("Content-Type", "application/json");
    let response;
    try {
        response = await fetch(snippetUrl + (currentSnippetId ? "/" + currentSnippetId : ""), {
            method: "POST",
            headers,
            body: JSON.stringify(dataToSend),
        });
    }
    catch (e) {
        const errorMsg = `Unable to save your ${entityName ?? "content"}: ${e}`;
        alert(errorMsg);
        throw new Error(errorMsg);
    }
    if (!response.ok) {
        const errorMsg = `Unable to save your ${entityName ?? "content"}`;
        alert(errorMsg);
        throw new Error(errorMsg);
    }
    const snippet = await response.json();
    const oldSnippetId = currentSnippetId || "_BLANK";
    let newSnippetId = snippet.id;
    if (snippet.version && snippet.version !== "0") {
        newSnippetId += "#" + snippet.version;
    }
    // Copy to clipboard when available.
    if (navigator.clipboard) {
        await navigator.clipboard.writeText(newSnippetId);
    }
    // Persist to local storage if configured.
    if (storageKey) {
        PersistSnippetId(storageKey, newSnippetId);
    }
    // Show success alert
    alert(`${entityName ?? "Content"} saved with ID: ${newSnippetId} (the id was also saved to your clipboard)`);
    return {
        snippetId: newSnippetId,
        oldSnippetId,
    };
}
/**
 * Prompt the user for a snippet ID.
 * @param message The prompt message.
 * @returns The trimmed snippet ID, or null if cancelled/empty.
 */
function PromptForSnippetId(message = "Please enter the snippet ID to use") {
    const requestedSnippetId = window.prompt(message);
    const trimmed = requestedSnippetId?.trim();
    return trimmed || null;
}
/**
 * Notify the playground about a snippet ID change (for code replacement).
 * NOTE this is an anti-pattern, instead playground should hook in and observe changes / update its own code
 * This is a legacy approach and should not be copied elsewhere
 * @param oldSnippetId The previous snippet ID.
 * @param newSnippetId The new snippet ID.
 * @param parseMethodName The name of the parse method (e.g., "SpriteManager.ParseFromSnippetAsync").
 */
function NotifyPlaygroundOfSnippetChange(oldSnippetId, newSnippetId, parseMethodName) {
    const windowAsAny = window;
    if (windowAsAny.Playground && oldSnippetId) {
        windowAsAny.Playground.onRequestCodeChangeObservable.notifyObservers({
            regex: new RegExp(`${parseMethodName}\\("${oldSnippetId}`, "g"),
            replace: `${parseMethodName}("${newSnippetId}`,
        });
    }
}

const SnippetDashboardStorageKey$1 = "Babylon/InspectorV2/SnippetDashboard/ParticleSystems";
function TryParseJsonString(value) {
    if (!value) {
        return undefined;
    }
    try {
        return JSON.parse(value);
    }
    catch {
        return undefined;
    }
}
function ParseJsonLoadContents(contents) {
    if (contents instanceof ArrayBuffer) {
        const decoder = new TextDecoder("utf-8");
        return TryParseJsonString(decoder.decode(contents)) ?? undefined;
    }
    if (typeof contents === "string") {
        return TryParseJsonString(contents) ?? undefined;
    }
    return undefined;
}
function NormalizeParticleSystemSerialization(rawData) {
    const jsonPayload = TryParseJsonString(rawData?.jsonPayload);
    const particleSystem = TryParseJsonString(jsonPayload?.particleSystem);
    return particleSystem ?? rawData;
}
/**
 * Display commands that can be applied to a particle system inside Inspector.
 * @param props Component props.
 * @returns Render property lines.
 */
const ParticleSystemCommandProperties = (props) => {
    const { particleSystem: system, selectionService } = props;
    const scene = system.getScene();
    const isCpuParticleSystem = system instanceof ParticleSystem;
    const isAlive = useObservableState(() => (isCpuParticleSystem ? system.isAlive() : system.isStarted()), scene?.onBeforeRenderObservable);
    const isStopping = useObservableState(() => system.isStopping(), scene?.onBeforeRenderObservable);
    const snippetId = useProperty(system, "snippetId");
    const [stopRequested, setStopRequested] = useState(false);
    useEffect(() => {
        if (!stopRequested) {
            return;
        }
        // Clear stop flag once the system fully stops.
        if (!isAlive && !isStopping) {
            setStopRequested(false);
        }
    }, [stopRequested, isAlive, isStopping]);
    const applyParticleSystemJsonToSystem = useCallback((jsonObject) => {
        if (!scene) {
            alert("No scene available.");
            return;
        }
        const candidate = NormalizeParticleSystemSerialization(jsonObject);
        try {
            let newSystem;
            if (isCpuParticleSystem) {
                newSystem = ParticleSystem.Parse(candidate, scene, "");
            }
            else {
                newSystem = GPUParticleSystem.Parse(candidate, scene, "");
            }
            system.dispose();
            selectionService.selectedEntity = newSystem;
        }
        catch (e) {
            alert("Failed to load particle system: " + e);
        }
    }, [scene, system, isCpuParticleSystem, selectionService]);
    const loadFromSnippetServer = useCallback(async () => {
        if (!scene) {
            alert("No scene available.");
            return;
        }
        const snippetId = PromptForSnippetId();
        if (!snippetId) {
            return;
        }
        const oldSnippetId = system.snippetId;
        // Dispose the old system and clear selection (v1 behavior)
        system.dispose();
        selectionService.selectedEntity = null;
        try {
            const newSystem = await ParticleHelper.ParseFromSnippetAsync(snippetId, scene, !isCpuParticleSystem);
            selectionService.selectedEntity = newSystem;
            // Notify the playground to update its code with the new snippet ID.
            NotifyPlaygroundOfSnippetChange(oldSnippetId, snippetId, "ParticleHelper.ParseFromSnippetAsync");
        }
        catch (err) {
            alert("Unable to load your particle system: " + err);
        }
    }, [scene, selectionService, system]);
    const saveToSnippetServer = useCallback(async () => {
        try {
            const content = JSON.stringify(system.serialize(true));
            const currentSnippetId = system.snippetId;
            const result = await SaveToSnippetServer({
                snippetUrl: ParticleHelper.SnippetUrl,
                currentSnippetId,
                content,
                payloadKey: "particleSystem",
                storageKey: SnippetDashboardStorageKey$1,
                entityName: "particle system",
            });
            // eslint-disable-next-line require-atomic-updates
            system.snippetId = result.snippetId;
            PersistSnippetId(SnippetDashboardStorageKey$1, result.snippetId);
            NotifyPlaygroundOfSnippetChange(result.oldSnippetId, result.snippetId, "ParticleSystem.ParseFromSnippetAsync");
        }
        catch {
            // Alert already shown by SaveToSnippetServer
        }
    }, [system]);
    return (jsxs(Fragment, { children: [isStopping ? (jsx(TextPropertyLine, { label: "System is stopping...", value: "" })) : isAlive ? (jsx(ButtonLine, { label: "Stop", icon: StopRegular, onClick: () => {
                    setStopRequested(true);
                    system.stop();
                    if (!isCpuParticleSystem) {
                        system.reset();
                    }
                } })) : (jsx(ButtonLine, { label: "Start", icon: PlayRegular, onClick: () => {
                    setStopRequested(false);
                    system.start();
                } })), jsx(FileUploadLine, { label: "Load from File", accept: ".json", onClick: (files) => {
                    if (files.length === 0) {
                        return;
                    }
                    const file = files[0];
                    Tools.ReadFile(file, (data) => {
                        const jsonObject = ParseJsonLoadContents(data);
                        if (!jsonObject) {
                            alert("Unable to load particle system from file.");
                            return;
                        }
                        applyParticleSystemJsonToSystem(jsonObject);
                    }, undefined, true);
                } }), jsx(ButtonLine, { label: "Save to File", icon: ArrowDownloadRegular, onClick: () => {
                    // Download serialization as a JSON file.
                    const data = JSON.stringify(system.serialize(true), null, 2);
                    const blob = new Blob([data], { type: "application/json" });
                    const name = (system.name && system.name.trim().length > 0 ? system.name.trim() : "particleSystem") + ".json";
                    Tools.Download(blob, name);
                } }), snippetId && jsx(TextPropertyLine, { label: "Snippet ID", value: snippetId }), jsx(ButtonLine, { label: "Load from Snippet Server", onClick: loadFromSnippetServer, icon: CloudArrowUpRegular }), jsx(ButtonLine, { label: "Save to Snippet Server", onClick: saveToSnippetServer, icon: CloudArrowDownRegular })] }));
};

/**
 * Display emitter-related properties for a particle system.
 * @param props Component props.
 * @returns Render property lines.
 */
const ParticleSystemEmitterProperties = (props) => {
    const { particleSystem: system, selectionService } = props;
    const scene = system.getScene();
    // Node-generated particle systems don't expose emitter type configuration
    const isNodeGenerated = system instanceof ParticleSystem && system.isNodeGenerated;
    const emitter = useProperty(system, "emitter");
    const emitterObject = emitter && !(emitter instanceof Vector3) ? emitter : undefined;
    const [sceneNodesVersion, setSceneNodesVersion] = useState(0);
    useEffect(() => {
        if (!scene) {
            return;
        }
        // Bump a local version counter whenever nodes change to keep emitter options up-to-date.
        const bump = () => setSceneNodesVersion((value) => value + 1);
        const newMeshToken = scene.onNewMeshAddedObservable.add(bump);
        const meshRemovedToken = scene.onMeshRemovedObservable.add(bump);
        const newTransformNodeToken = scene.onNewTransformNodeAddedObservable.add(bump);
        const transformNodeRemovedToken = scene.onTransformNodeRemovedObservable.add(bump);
        return () => {
            scene.onNewMeshAddedObservable.remove(newMeshToken);
            scene.onMeshRemovedObservable.remove(meshRemovedToken);
            scene.onNewTransformNodeAddedObservable.remove(newTransformNodeToken);
            scene.onTransformNodeRemovedObservable.remove(transformNodeRemovedToken);
        };
    }, [scene]);
    const sceneNodes = useMemo(() => {
        if (!scene) {
            return [];
        }
        const seenUniqueIds = new Set();
        const unique = [];
        for (const mesh of scene.meshes) {
            const uniqueId = mesh.uniqueId;
            if (typeof uniqueId === "number") {
                if (seenUniqueIds.has(uniqueId)) {
                    continue;
                }
                seenUniqueIds.add(uniqueId);
            }
            unique.push(mesh);
        }
        const emitterUniqueId = emitterObject?.uniqueId;
        if (emitterObject && emitterUniqueId !== undefined && !seenUniqueIds.has(emitterUniqueId)) {
            // Keep the current emitter visible even if it isn't present in the scene arrays for any reason.
            unique.unshift(emitterObject);
        }
        return unique;
    }, [scene, sceneNodesVersion, emitterObject]);
    const emitterSelectionValue = !emitter ? "none" : emitter instanceof Vector3 ? "position" : `node:${emitter.uniqueId}`;
    const emitterVector = emitter instanceof Vector3 ? emitter : undefined;
    // Subscribe to Vector3 internal components to re-render on in-place mutations.
    useProperty(emitterVector, "_x");
    useProperty(emitterVector, "_y");
    useProperty(emitterVector, "_z");
    const particleEmitterType = useProperty(system, "particleEmitterType");
    // Derive the current dropdown value from the current instance to stay in sync with external changes.
    const derivedEmitterTypeKey = (() => {
        if (particleEmitterType instanceof SphereParticleEmitter) {
            return "sphere";
        }
        if (particleEmitterType instanceof ConeParticleEmitter) {
            return "cone";
        }
        if (particleEmitterType instanceof CylinderParticleEmitter) {
            return "cylinder";
        }
        if (particleEmitterType instanceof HemisphericParticleEmitter) {
            return "hemispheric";
        }
        if (particleEmitterType instanceof PointParticleEmitter) {
            return "point";
        }
        if (particleEmitterType instanceof MeshParticleEmitter) {
            return "mesh";
        }
        // Fall back to "box" for unknown emitter types to keep the dropdown valid.
        return "box";
    })();
    const [emitterTypeKey, setEmitterTypeKey] = useState(derivedEmitterTypeKey);
    useEffect(() => {
        // Keep local dropdown state aligned with the derived key when the engine changes underneath.
        setEmitterTypeKey(derivedEmitterTypeKey);
    }, [derivedEmitterTypeKey]);
    return (jsxs(Fragment, { children: [jsx(Property, { component: StringDropdownPropertyLine, label: "Emitter", propertyPath: "emitter", value: emitterSelectionValue, options: [
                    { label: "None", value: "none" },
                    { label: "Position", value: "position" },
                    ...sceneNodes.map((node) => {
                        const uniqueId = node.uniqueId;
                        const name = node.name ?? "(unnamed)";
                        const label = `${name} (#${uniqueId})`;
                        return {
                            label,
                            value: `node:${uniqueId}`,
                        };
                    }),
                ], onChange: (value) => {
                    const next = value;
                    if (next === "none") {
                        system.emitter = null;
                        return;
                    }
                    if (next === "position") {
                        if (!(system.emitter instanceof Vector3)) {
                            system.emitter = Vector3.Zero();
                        }
                        return;
                    }
                    const uniqueIdText = next.replace("node:", "");
                    const uniqueId = Number(uniqueIdText);
                    const node = sceneNodes.find((candidate) => candidate.uniqueId === uniqueId);
                    if (node) {
                        system.emitter = node;
                    }
                } }), emitterSelectionValue === "position" && emitterVector && (jsx(Property, { component: Vector3PropertyLine, label: "Position", propertyPath: "emitter", value: emitterVector, onChange: (value) => {
                    if (system.emitter instanceof Vector3) {
                        system.emitter.copyFrom(value);
                    }
                    else {
                        system.emitter = value;
                    }
                } })), emitterSelectionValue !== "none" && emitter && !(emitter instanceof Vector3) && (jsx(Property, { component: LinkToEntityPropertyLine, label: "Entity", propertyPath: "emitter", entity: emitter, selectionService: selectionService })), !isNodeGenerated && (jsxs(Fragment, { children: [jsx(Property, { component: StringDropdownPropertyLine, label: "Type", propertyPath: "emitterType", value: emitterTypeKey, options: [
                            { label: "Box", value: "box" },
                            { label: "Cone", value: "cone" },
                            { label: "Cylinder", value: "cylinder" },
                            { label: "Hemispheric", value: "hemispheric" },
                            { label: "Point", value: "point" },
                            { label: "Mesh", value: "mesh" },
                            { label: "Sphere", value: "sphere" },
                        ], onChange: (value) => {
                            const next = value;
                            setEmitterTypeKey(next);
                            // Update the engine by swapping the particleEmitterType instance to match the selected key.
                            switch (next) {
                                case "box":
                                    system.createBoxEmitter(new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(-0.5, -0.5, -0.5), new Vector3(0.5, 0.5, 0.5));
                                    break;
                                case "sphere":
                                    system.createSphereEmitter(1, 1);
                                    break;
                                case "cone":
                                    system.createConeEmitter(1, Math.PI / 4);
                                    break;
                                case "cylinder":
                                    system.createCylinderEmitter(1, 1, 1, 0);
                                    break;
                                case "hemispheric":
                                    system.createHemisphericEmitter(1, 1);
                                    break;
                                case "point":
                                    system.createPointEmitter(new Vector3(0, 1, 0), new Vector3(0, 1, 0));
                                    break;
                                case "mesh": {
                                    // Default to the first mesh in the scene when available, then allow changes via "Source".
                                    const defaultMesh = scene?.meshes?.[0] ?? null;
                                    system.particleEmitterType = new MeshParticleEmitter(defaultMesh);
                                    break;
                                }
                            }
                        } }), particleEmitterType instanceof MeshParticleEmitter && (jsx(Fragment, { children: scene && scene.meshes.length > 0 ? (jsx(Property, { component: StringDropdownPropertyLine, propertyPath: "source", label: "Source", value: particleEmitterType.mesh ? `mesh:${particleEmitterType.mesh.uniqueId}` : `mesh:${scene.meshes[0].uniqueId}`, options: scene.meshes.map((mesh) => {
                                const uniqueId = mesh.uniqueId;
                                const name = mesh.name ?? "(unnamed)";
                                const label = `${name} (#${uniqueId})`;
                                return {
                                    label,
                                    value: `mesh:${uniqueId}`,
                                };
                            }), onChange: (value) => {
                                const next = String(value);
                                const uniqueIdText = next.replace("mesh:", "");
                                const uniqueId = Number(uniqueIdText);
                                const mesh = scene.meshes.find((candidate) => candidate.uniqueId === uniqueId) ?? null;
                                particleEmitterType.mesh = mesh;
                            } })) : (jsx(Property, { component: TextPropertyLine, propertyPath: "source", label: "Source", value: "No meshes in scene." })) })), particleEmitterType instanceof BoxParticleEmitter && (jsxs(Fragment, { children: [jsx(BoundProperty, { component: Vector3PropertyLine, label: "Direction1", target: particleEmitterType, propertyKey: "direction1" }), jsx(BoundProperty, { component: Vector3PropertyLine, label: "Direction2", target: particleEmitterType, propertyKey: "direction2" }), jsx(BoundProperty, { component: Vector3PropertyLine, label: "Min emit box", target: particleEmitterType, propertyKey: "minEmitBox" }), jsx(BoundProperty, { component: Vector3PropertyLine, label: "Max emit box", target: particleEmitterType, propertyKey: "maxEmitBox" })] })), particleEmitterType instanceof ConeParticleEmitter && (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Radius range", target: particleEmitterType, propertyKey: "radiusRange", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Height range", target: particleEmitterType, propertyKey: "heightRange", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Emit from spawn point only", target: particleEmitterType, propertyKey: "emitFromSpawnPointOnly" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Direction randomizer", target: particleEmitterType, propertyKey: "directionRandomizer", min: 0, max: 1, step: 0.01 })] })), particleEmitterType instanceof SphereParticleEmitter && (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Radius", target: particleEmitterType, propertyKey: "radius", min: 0, step: 0.1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Radius range", target: particleEmitterType, propertyKey: "radiusRange", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Direction randomizer", target: particleEmitterType, propertyKey: "directionRandomizer", min: 0, max: 1, step: 0.01 })] })), particleEmitterType instanceof CylinderParticleEmitter && (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Radius", target: particleEmitterType, propertyKey: "radius", min: 0, step: 0.1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Height", target: particleEmitterType, propertyKey: "height", min: 0, step: 0.1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Radius range", target: particleEmitterType, propertyKey: "radiusRange", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Direction randomizer", target: particleEmitterType, propertyKey: "directionRandomizer", min: 0, max: 1, step: 0.01 })] })), particleEmitterType instanceof HemisphericParticleEmitter && (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Radius", target: particleEmitterType, propertyKey: "radius", min: 0, step: 0.1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Radius range", target: particleEmitterType, propertyKey: "radiusRange", min: 0, max: 1, step: 0.01 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Direction randomizer", target: particleEmitterType, propertyKey: "directionRandomizer", min: 0, max: 1, step: 0.01 })] })), particleEmitterType instanceof PointParticleEmitter && (jsxs(Fragment, { children: [jsx(BoundProperty, { component: Vector3PropertyLine, label: "Direction1", target: particleEmitterType, propertyKey: "direction1" }), jsx(BoundProperty, { component: Vector3PropertyLine, label: "Direction2", target: particleEmitterType, propertyKey: "direction2" })] }))] })), !scene && jsx(TextPropertyLine, { label: "Emitter", value: "No scene available." })] }));
};

/**
 * Return a copied array and re-render when array mutators run.
 * Intercept add/remove/change functions because the underlying APIs update internal arrays in-place.
 * @param target The target object containing the observable array, or null if the array is not applicable.
 * @param getItems A function to get the current items in the array.
 * @param addFn The name of the function to add an item to the array.
 * @param removeFn The name of the function to remove an item from the array.
 * @param changeFn The name of the function to change an item in the array.
 * @returns A copied array that re-renders when array mutators run.
 */
function useObservableArray(target, getItems, addFn, removeFn, changeFn) {
    return useObservableState(useCallback(() => {
        const value = getItems();
        return [...(value ?? [])];
    }, [getItems]), useInterceptObservable("function", target, addFn), useInterceptObservable("function", target, removeFn), changeFn ? useInterceptObservable("function", target, changeFn) : undefined);
}

const useStyles$g = makeStyles({
    subsection: {
        marginTop: tokens.spacingVerticalM,
    },
});
/**
 * Display size-related properties for a particle system.
 * @param props Component props.
 * @returns Render property lines.
 */
const ParticleSystemSizeProperties = (props) => {
    const { particleSystem: system } = props;
    const isCpuParticleSystem = system instanceof ParticleSystem;
    // Start size gradient is not supported in GPU particle systems, so the UI will be hidden below
    const starSizeGradientGetter = useCallback(() => system.getStartSizeGradients(), [system]);
    const startSizeGradient = useObservableArray(system, starSizeGradientGetter, "addStartSizeGradient", "removeStartSizeGradient", "forceRefreshGradients");
    const useStartSizeGradients = (startSizeGradient?.length ?? 0) > 0;
    const sizeGradientGetter = useCallback(() => system.getSizeGradients(), [system]);
    const sizeGradient = useObservableArray(system, sizeGradientGetter, "addSizeGradient", "removeSizeGradient", "forceRefreshGradients");
    const useSizeGradients = (sizeGradient?.length ?? 0) > 0;
    const classes = useStyles$g();
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Min size", target: system, propertyKey: "minSize", min: 0, step: 0.1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Max size", target: system, propertyKey: "maxSize", min: 0, step: 0.1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Min scale x", target: system, propertyKey: "minScaleX", min: 0, step: 0.1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Max scale x", target: system, propertyKey: "maxScaleX", min: 0, step: 0.1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Min scale y", target: system, propertyKey: "minScaleY", min: 0, step: 0.1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Max scale y", target: system, propertyKey: "maxScaleY", min: 0, step: 0.1 }), isCpuParticleSystem && !useStartSizeGradients && (jsx(ButtonLine, { label: "Use Start Size gradients", onClick: () => {
                    system.addStartSizeGradient(0, system.minSize, system.maxSize);
                    system.forceRefreshGradients();
                } })), useStartSizeGradients && (jsxs(Fragment, { children: [jsx(Subtitle2, { className: classes.subsection, children: "Start Size Gradients" }), jsx(FactorGradientList, { gradients: startSizeGradient, label: "Start Size Gradient", removeGradient: (gradient) => {
                            system.removeStartSizeGradient(gradient.gradient);
                            system.forceRefreshGradients();
                        }, addGradient: (gradient) => {
                            if (gradient) {
                                system.addStartSizeGradient(gradient.gradient, gradient.factor1, gradient.factor2);
                            }
                            else {
                                system.addStartSizeGradient(0, system.minSize, system.maxSize);
                            }
                            system.forceRefreshGradients();
                        }, onChange: (_gradient) => {
                            system.forceRefreshGradients();
                        } })] })), !useSizeGradients && (jsx(ButtonLine, { label: "Use Size gradients", onClick: () => {
                    system.addSizeGradient(0, system.minSize, system.maxSize);
                    system.forceRefreshGradients();
                } })), useSizeGradients && (jsxs(Fragment, { children: [jsx(Subtitle2, { className: classes.subsection, children: "Size Gradients" }), jsx(FactorGradientList, { gradients: sizeGradient, label: "Size Gradient", removeGradient: (gradient) => {
                            system.removeSizeGradient(gradient.gradient);
                            system.forceRefreshGradients();
                        }, addGradient: (gradient) => {
                            if (gradient) {
                                system.addSizeGradient(gradient.gradient, gradient.factor1, gradient.factor2);
                            }
                            else {
                                system.addSizeGradient(0, system.minSize, system.maxSize);
                            }
                            system.forceRefreshGradients();
                        }, onChange: (_gradient) => {
                            system.forceRefreshGradients();
                        } })] }))] }));
};

const useStyles$f = makeStyles({
    subsection: {
        marginTop: tokens.spacingVerticalM,
    },
});
/**
 * Display emission-related properties for a particle system.
 * @param props Component props.
 * @returns Render property lines.
 */
const ParticleSystemEmissionProperties = (props) => {
    const { particleSystem: system } = props;
    const isCpuParticleSystem = system instanceof ParticleSystem;
    // Emit rate gradient is not supported in GPU particle systems, so the UI will be hidden below
    const emitRateGradientsGetter = useCallback(() => system.getEmitRateGradients(), [system]);
    const emitRateGradients = useObservableArray(system, emitRateGradientsGetter, "addEmitRateGradient", "removeEmitRateGradient", "forceRefreshGradients");
    const velocityGradientsGetter = useCallback(() => system.getVelocityGradients(), [system]);
    const velocityGradients = useObservableArray(system, velocityGradientsGetter, "addVelocityGradient", "removeVelocityGradient", "forceRefreshGradients");
    const limitVelocityGradientsGetter = useCallback(() => system.getLimitVelocityGradients(), [system]);
    const limitVelocityGradients = useObservableArray(system, limitVelocityGradientsGetter, "addLimitVelocityGradient", "removeLimitVelocityGradient", "forceRefreshGradients");
    const dragGradientsGetter = useCallback(() => system.getDragGradients(), [system]);
    const dragGradients = useObservableArray(system, dragGradientsGetter, "addDragGradient", "removeDragGradient", "forceRefreshGradients");
    const useEmitRateGradients = (emitRateGradients?.length ?? 0) > 0;
    const useVelocityGradients = (velocityGradients?.length ?? 0) > 0;
    const useLimitVelocityGradients = (limitVelocityGradients?.length ?? 0) > 0;
    const useDragGradients = (dragGradients?.length ?? 0) > 0;
    const classes = useStyles$f();
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Emit rate", target: system, propertyKey: "emitRate", min: 0, step: 1 }), isCpuParticleSystem && !useEmitRateGradients && (jsx(ButtonLine, { label: "Use Emit rate gradients", onClick: () => {
                    system.addEmitRateGradient(0, system.emitRate, system.emitRate);
                    system.forceRefreshGradients();
                } })), useEmitRateGradients && (jsxs(Fragment, { children: [jsx(Subtitle2, { className: classes.subsection, children: "Emit Rate Gradients" }), jsx(FactorGradientList, { gradients: emitRateGradients, label: "Emit Rate Gradient", removeGradient: (gradient) => {
                            system.removeEmitRateGradient(gradient.gradient);
                            system.forceRefreshGradients();
                        }, addGradient: (gradient) => {
                            if (gradient) {
                                system.addEmitRateGradient(gradient.gradient, gradient.factor1, gradient.factor2);
                            }
                            else {
                                system.addEmitRateGradient(0, system.emitRate, system.emitRate);
                            }
                            system.forceRefreshGradients();
                        }, onChange: (_gradient) => {
                            system.forceRefreshGradients();
                        } })] })), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Min Emit Power", target: system, propertyKey: "minEmitPower", min: 0, step: 0.1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Max Emit Power", target: system, propertyKey: "maxEmitPower", min: 0, step: 0.1 }), !useVelocityGradients && (jsx(ButtonLine, { label: "Use Velocity gradients", onClick: () => {
                    system.addVelocityGradient(0, 1, 1);
                    system.forceRefreshGradients();
                } })), useVelocityGradients && (jsxs(Fragment, { children: [jsx(Subtitle2, { className: classes.subsection, children: "Velocity Gradients" }), jsx(FactorGradientList, { gradients: velocityGradients, label: "Velocity Gradient", removeGradient: (gradient) => {
                            system.removeVelocityGradient(gradient.gradient);
                            system.forceRefreshGradients();
                        }, addGradient: (gradient) => {
                            if (gradient) {
                                system.addVelocityGradient(gradient.gradient, gradient.factor1, gradient.factor2);
                            }
                            else {
                                system.addVelocityGradient(0, 1, 1);
                            }
                            system.forceRefreshGradients();
                        }, onChange: (_gradient) => {
                            system.forceRefreshGradients();
                        } })] })), !useLimitVelocityGradients && (jsx(ButtonLine, { label: "Use Limit Velocity gradients", onClick: () => {
                    system.addLimitVelocityGradient(0, 1, 1);
                    system.forceRefreshGradients();
                } })), useLimitVelocityGradients && (jsxs(Fragment, { children: [jsx(Subtitle2, { className: classes.subsection, children: "Limit Velocity Gradients" }), jsx(FactorGradientList, { gradients: limitVelocityGradients, label: "Limit Velocity Gradient", removeGradient: (gradient) => {
                            system.removeLimitVelocityGradient(gradient.gradient);
                            system.forceRefreshGradients();
                        }, addGradient: (gradient) => {
                            if (gradient) {
                                system.addLimitVelocityGradient(gradient.gradient, gradient.factor1, gradient.factor2);
                            }
                            else {
                                system.addLimitVelocityGradient(0, 1, 1);
                            }
                            system.forceRefreshGradients();
                        }, onChange: (_gradient) => {
                            system.forceRefreshGradients();
                        } })] })), !useDragGradients && (jsx(ButtonLine, { label: "Use Drag gradients", onClick: () => {
                    system.addDragGradient(0, 1, 1);
                    system.forceRefreshGradients();
                } })), useDragGradients && (jsxs(Fragment, { children: [jsx(Subtitle2, { className: classes.subsection, children: "Drag Gradients" }), jsx(FactorGradientList, { gradients: dragGradients, label: "Drag Gradient", removeGradient: (gradient) => {
                            system.removeDragGradient(gradient.gradient);
                            system.forceRefreshGradients();
                        }, addGradient: (gradient) => {
                            if (gradient) {
                                system.addDragGradient(gradient.gradient, gradient.factor1, gradient.factor2);
                            }
                            else {
                                system.addDragGradient(0, 1, 1);
                            }
                            system.forceRefreshGradients();
                        }, onChange: (_gradient) => {
                            system.forceRefreshGradients();
                        } })] }))] }));
};

const useStyles$e = makeStyles({
    subsection: {
        marginTop: tokens.spacingVerticalM,
    },
});
/**
 * Display lifetime-related properties for a particle system.
 * @param props Component props.
 * @returns Render property lines.
 */
const ParticleSystemLifetimeProperties = (props) => {
    const { particleSystem: system } = props;
    const isCpuParticleSystem = system instanceof ParticleSystem;
    // Lifetime gradient is not supported in GPU particle systems, so the UI will be hidden below
    const lifeTimeGradientsGetter = useCallback(() => system.getLifeTimeGradients(), [system]);
    const lifeTimeGradients = useObservableArray(system, lifeTimeGradientsGetter, "addLifeTimeGradient", "removeLifeTimeGradient", "forceRefreshGradients");
    const useLifeTimeGradients = (lifeTimeGradients?.length ?? 0) > 0;
    const classes = useStyles$e();
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Min lifetime", target: system, propertyKey: "minLifeTime", min: 0, step: 0.1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Max lifetime", target: system, propertyKey: "maxLifeTime", min: 0, step: 0.1 }), isCpuParticleSystem && !useLifeTimeGradients && (jsx(ButtonLine, { label: "Use Lifetime gradients", onClick: () => {
                    system.addLifeTimeGradient(0, system.minLifeTime, system.maxLifeTime);
                    system.forceRefreshGradients();
                } })), useLifeTimeGradients && (jsxs(Fragment, { children: [jsx(Subtitle2, { className: classes.subsection, children: "Lifetime Gradients" }), jsx(FactorGradientList, { gradients: lifeTimeGradients, label: "Lifetime Gradient", removeGradient: (gradient) => {
                            system.removeLifeTimeGradient(gradient.gradient);
                            system.forceRefreshGradients();
                        }, addGradient: (gradient) => {
                            if (gradient) {
                                system.addLifeTimeGradient(gradient.gradient, gradient.factor1, gradient.factor2);
                            }
                            else {
                                system.addLifeTimeGradient(0, system.minLifeTime, system.maxLifeTime);
                            }
                            system.forceRefreshGradients();
                        }, onChange: (_gradient) => {
                            system.forceRefreshGradients();
                        } })] })), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Target stop duration", target: system, propertyKey: "targetStopDuration", min: 0, step: 0.1 })] }));
};

const useStyles$d = makeStyles({
    subsection: {
        marginTop: tokens.spacingVerticalM,
    },
});
/**
 * Display color-related properties for a particle system.
 * @param props Component props.
 * @returns Render property lines.
 */
const ParticleSystemColorProperties = (props) => {
    const { particleSystem: system } = props;
    const isCpuParticleSystem = system instanceof ParticleSystem;
    const useRampGradients = useProperty(system, "useRampGradients");
    const colorGradientsGetter = useCallback(() => system.getColorGradients(), [system]);
    const colorGradients = useObservableArray(system, colorGradientsGetter, "addColorGradient", "removeColorGradient", "forceRefreshGradients");
    // Ramp, Color Remap, and Alpha Remap gradients are only supported in CPU particle systems, they will be hidden in the UI for GPU particle systems
    const rampGradientsGetter = useCallback(() => system.getRampGradients(), [system]);
    const rampGradients = useObservableArray(system, rampGradientsGetter, "addRampGradient", "removeRampGradient", "forceRefreshGradients");
    const colorRemapGradientsGetter = useCallback(() => system.getColorRemapGradients(), [system]);
    const colorRemapGradients = useObservableArray(system, colorRemapGradientsGetter, "addColorRemapGradient", "removeColorRemapGradient", "forceRefreshGradients");
    const alphaRemapGradientsGetter = useCallback(() => system.getAlphaRemapGradients(), [system]);
    const alphaRemapGradients = useObservableArray(system, alphaRemapGradientsGetter, "addAlphaRemapGradient", "removeAlphaRemapGradient", "forceRefreshGradients");
    const hasColorGradients = (colorGradients?.length ?? 0) > 0;
    const hasRampGradients = (rampGradients?.length ?? 0) > 0;
    const hasColorRemapGradients = (colorRemapGradients?.length ?? 0) > 0;
    const hasAlphaRemapGradients = (alphaRemapGradients?.length ?? 0) > 0;
    const classes = useStyles$d();
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: Color4PropertyLine, label: "Color 1", target: system, propertyKey: "color1" }), jsx(BoundProperty, { component: Color4PropertyLine, label: "Color 2", target: system, propertyKey: "color2" }), jsx(BoundProperty, { component: Color4PropertyLine, label: "Color dead", target: system, propertyKey: "colorDead" }), !hasColorGradients && (jsx(ButtonLine, { label: "Use Color gradients", onClick: () => {
                    system.addColorGradient(0, system.color1, system.color1);
                    system.addColorGradient(1, system.color2, system.color2);
                    system.forceRefreshGradients();
                } })), hasColorGradients && (jsxs(Fragment, { children: [jsx(Subtitle2, { className: classes.subsection, children: "Color Gradients" }), jsx(Color4GradientList, { gradients: colorGradients, label: "Color Gradient", removeGradient: (gradient) => {
                            system.removeColorGradient(gradient.gradient);
                            system.forceRefreshGradients();
                        }, addGradient: (gradient) => {
                            if (gradient) {
                                system.addColorGradient(gradient.gradient, gradient.color1, gradient.color2);
                            }
                            else {
                                system.addColorGradient(0, system.color1, system.color1);
                                system.addColorGradient(1, system.color2, system.color2);
                            }
                            system.forceRefreshGradients();
                        }, onChange: (_gradient) => {
                            system.forceRefreshGradients();
                        } })] })), isCpuParticleSystem && jsx(BoundProperty, { component: SwitchPropertyLine, label: "Enable Ramp gradients", target: system, propertyKey: "useRampGradients" }), useRampGradients && (jsxs(Fragment, { children: [!hasRampGradients && (jsx(ButtonLine, { label: "Use Ramp gradients", onClick: () => {
                            system.addRampGradient(0, Color3.Black());
                            system.addRampGradient(1, Color3.White());
                            system.forceRefreshGradients();
                        } })), hasRampGradients && (jsxs(Fragment, { children: [jsx(Subtitle2, { className: classes.subsection, children: "Ramp Gradients" }), jsx(Color3GradientList, { gradients: rampGradients, label: "Ramp Gradient", removeGradient: (gradient) => {
                                    system.removeRampGradient(gradient.gradient);
                                    system.forceRefreshGradients();
                                }, addGradient: (gradient) => {
                                    if (gradient) {
                                        system.addRampGradient(gradient.gradient, gradient.color);
                                    }
                                    else {
                                        system.addRampGradient(0, Color3.Black());
                                        system.addRampGradient(1, Color3.White());
                                    }
                                    system.forceRefreshGradients();
                                }, onChange: () => {
                                    system.forceRefreshGradients();
                                } })] })), !hasColorRemapGradients && (jsx(ButtonLine, { label: "Use Color remap gradients", onClick: () => {
                            system.addColorRemapGradient(0, 0, 1);
                            system.forceRefreshGradients();
                        } })), hasColorRemapGradients && (jsxs(Fragment, { children: [jsx(Subtitle2, { className: classes.subsection, children: "Color Remap Gradients" }), jsx(FactorGradientList, { gradients: colorRemapGradients, label: "Color Remap Gradient", removeGradient: (gradient) => {
                                    system.removeColorRemapGradient(gradient.gradient);
                                    system.forceRefreshGradients();
                                }, addGradient: (gradient) => {
                                    if (gradient) {
                                        system.addColorRemapGradient(gradient.gradient, gradient.factor1 ?? 0, gradient.factor2 ?? 1);
                                    }
                                    else {
                                        system.addColorRemapGradient(0, 0, 1);
                                    }
                                    system.forceRefreshGradients();
                                }, onChange: (_gradient) => {
                                    system.forceRefreshGradients();
                                } })] })), !hasAlphaRemapGradients && (jsx(ButtonLine, { label: "Use Alpha remap gradients", onClick: () => {
                            system.addAlphaRemapGradient(0, 0, 1);
                            system.forceRefreshGradients();
                        } })), hasAlphaRemapGradients && (jsxs(Fragment, { children: [jsx(Subtitle2, { className: classes.subsection, children: "Alpha Remap Gradients" }), jsx(FactorGradientList, { gradients: alphaRemapGradients, label: "Alpha Remap Gradient", removeGradient: (gradient) => {
                                    system.removeAlphaRemapGradient(gradient.gradient);
                                    system.forceRefreshGradients();
                                }, addGradient: (gradient) => {
                                    if (gradient) {
                                        system.addAlphaRemapGradient(gradient.gradient, gradient.factor1 ?? 0, gradient.factor2 ?? 1);
                                    }
                                    else {
                                        system.addAlphaRemapGradient(0, 0, 1);
                                    }
                                    system.forceRefreshGradients();
                                }, onChange: (_gradient) => {
                                    system.forceRefreshGradients();
                                } })] }))] }))] }));
};

const useStyles$c = makeStyles({
    subsection: {
        marginTop: tokens.spacingVerticalM,
    },
});
/**
 * Display rotation-related properties for a particle system.
 * @param props Component props.
 * @returns Render property lines.
 */
const ParticleSystemRotationProperties = (props) => {
    const { particleSystem: system } = props;
    const angularSpeedGradientsGetter = useCallback(() => system.getAngularSpeedGradients(), [system]);
    const angularSpeedGradients = useObservableArray(system, angularSpeedGradientsGetter, "addAngularSpeedGradient", "removeAngularSpeedGradient", "forceRefreshGradients");
    const useAngularSpeedGradients = (angularSpeedGradients?.length ?? 0) > 0;
    const classes = useStyles$c();
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Min Angular speed", target: system, propertyKey: "minAngularSpeed", step: 0.01 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Max Angular speed", target: system, propertyKey: "maxAngularSpeed", step: 0.01 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Min initial rotation", target: system, propertyKey: "minInitialRotation", step: 0.01 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Max initial rotation", target: system, propertyKey: "maxInitialRotation", step: 0.01 }), !useAngularSpeedGradients && (jsx(ButtonLine, { label: "Use Angular speed gradients", onClick: () => {
                    system.addAngularSpeedGradient(0, system.minAngularSpeed, system.maxAngularSpeed);
                    system.forceRefreshGradients();
                } })), useAngularSpeedGradients && (jsxs(Fragment, { children: [jsx(Subtitle2, { className: classes.subsection, children: "Angular Speed Gradients" }), jsx(FactorGradientList, { gradients: angularSpeedGradients, label: "Angular Speed Gradient", removeGradient: (gradient) => {
                            system.removeAngularSpeedGradient(gradient.gradient);
                            system.forceRefreshGradients();
                        }, addGradient: (gradient) => {
                            if (gradient) {
                                system.addAngularSpeedGradient(gradient.gradient, gradient.factor1 ?? 0, gradient.factor2);
                            }
                            else {
                                system.addAngularSpeedGradient(0, system.minAngularSpeed, system.maxAngularSpeed);
                            }
                            system.forceRefreshGradients();
                        }, onChange: (_gradient) => {
                            system.forceRefreshGradients();
                        } })] }))] }));
};

/**
 * Display spritesheet-related properties for a particle system.
 * @param props Component props.
 * @returns Render property lines.
 */
const ParticleSystemSpritesheetProperties = (props) => {
    const { particleSystem: system } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Animation sheet enabled", target: system, propertyKey: "isAnimationSheetEnabled" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "First sprite index", target: system, propertyKey: "startSpriteCellID", min: 0, step: 1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Last sprite index", target: system, propertyKey: "endSpriteCellID", min: 0, step: 1 }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Animation loop", target: system, propertyKey: "spriteCellLoop" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Random cell start index", target: system, propertyKey: "spriteRandomStartCell" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Cell width", target: system, propertyKey: "spriteCellWidth", min: 0, step: 1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Cell height", target: system, propertyKey: "spriteCellHeight", min: 0, step: 1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Cell change speed", target: system, propertyKey: "spriteCellChangeSpeed", min: 0, step: 0.01 })] }));
};

const useAttractorStyles = makeStyles({
    container: {
        // top-level div used for lineContainer, in UI overhaul update to just use linecontainer
        width: "100%",
        display: "flex", // Makes this a flex container
        flexDirection: "row", // Arranges children horizontally, main-axis=horizontal
        padding: `${tokens.spacingVerticalXS} 0px`,
        borderBottom: `${tokens.strokeWidthThin} solid ${tokens.colorNeutralStroke1}`,
    },
    strengthLabel: {
        flex: 1,
        display: "flex",
        alignItems: "center",
    },
});
const CreateImpostor = (id, scene, attractorData, initialScale, initialMaterial) => {
    const impostor = CreateSphere("Attractor impostor #" + id, { diameter: 1 }, scene);
    impostor.scaling.setAll(initialScale);
    impostor.position.copyFrom(attractorData.position);
    impostor.material = initialMaterial;
    impostor.reservedDataStore = { hidden: true };
    return impostor;
};
async function CreateTextRendererAsync(id, scene, impostor, color) {
    const sdfFontDefinition = await (await fetch("https://assets.babylonjs.com/fonts/roboto-regular.json")).text();
    const fontAsset = new FontAsset(sdfFontDefinition, "https://assets.babylonjs.com/fonts/roboto-regular.png");
    const textRenderer = await TextRenderer.CreateTextRendererAsync(fontAsset, scene.getEngine());
    textRenderer.addParagraph("#" + id, {}, Matrix.Scaling(0.5, 0.5, 0.5).multiply(Matrix.Translation(0, 1, 0)));
    textRenderer.isBillboard = true;
    textRenderer.color = Color4.FromColor3(color, 1.0);
    textRenderer.parent = impostor;
    return textRenderer;
}
/**
 * Represents the UX of an attractor, a sphere with a color/size whose position matches that of the underlying attractor
 * @param props
 * @returns
 */
const AttractorComponent = (props) => {
    const { attractorData, id, impostorScale, impostorMaterial, impostorColor, scene, onControl, isControlled } = props;
    const classes = useAttractorStyles();
    // For read-only attractors (Node particles), start hidden by default
    const [shown, setShown] = useState(!attractorData.isReadOnly);
    // We only want to recreate the impostor mesh and associated if id, scene, or attractor/impostor changes
    const impostor = useResource(useCallback(() => CreateImpostor(id, scene, attractorData, impostorScale, impostorMaterial), [id, scene, attractorData]));
    const label = useAsyncResource(useCallback(async () => await CreateTextRendererAsync(id, scene, impostor, impostorColor), [id, scene, impostor]));
    // Set initial visibility based on whether it should be shown
    useEffect(() => {
        impostor.visibility = shown ? 1 : 0;
    }, [impostor, shown]);
    // If impostor, color, or label change, recreate the observer function so that it isnt hooked to old state
    // For read-only attractors, don't sync position back (it can't be moved)
    useEffect(() => {
        const onAfterRender = scene.onAfterRenderObservable.add(() => {
            if (!attractorData.isReadOnly) {
                attractorData.position.copyFrom(impostor.position);
            }
            if (label) {
                label.color = Color4.FromColor3(impostorColor);
                label.render(scene.getViewMatrix(), scene.getProjectionMatrix());
            }
        });
        return () => {
            onAfterRender.remove();
        };
    }, [impostor, scene, label, impostorColor, attractorData]);
    // If impostor or impostorScale change, update impostor scaling
    useEffect(() => {
        impostor.scaling.setAll(impostorScale);
    }, [impostor, impostorScale]);
    return (jsxs("div", { className: classes.container, children: [attractorData.isReadOnly ? (jsxs(Body1, { className: classes.strengthLabel, children: ["Strength: ", attractorData.strength !== null ? attractorData.strength : "Dynamic"] })) : (jsx(SyncedSliderInput, { value: attractorData.strength, onChange: (value) => attractorData.setStrength(value), min: -10, max: 10, step: 0.1 })), jsx(ToggleButton, { title: "Show / hide particle attractor.", checkedIcon: EyeFilled, uncheckedIcon: EyeOffFilled, value: shown, onChange: (show) => {
                    impostor.visibility = show ? 1 : 0;
                    setShown(show);
                } }), !attractorData.isReadOnly && (jsx(ToggleButton, { title: "Add / remove position gizmo from particle attractor", checkedIcon: ArrowMoveFilled, value: isControlled(impostor), onChange: (control) => onControl(control ? impostor : undefined) }))] }));
};

const useStyles$b = makeStyles({
    subsection: {
        marginTop: tokens.spacingVerticalM,
    },
});
// For each IAttractorData, create a listItem
function AttractorsToListItems(attractors) {
    return attractors.map((attractor, index) => {
        return {
            id: index,
            data: attractor,
            sortBy: 0,
        };
    });
}
const CreateGizmoManager = (scene) => {
    const gizmoManager = new GizmoManager(scene, 1, UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(scene), UtilityLayerRenderer._CreateDefaultKeepUtilityLayerFromScene(scene));
    gizmoManager.positionGizmoEnabled = true;
    gizmoManager.attachableMeshes = [];
    return gizmoManager;
};
const CreateSharedMaterial = (scene, impostorColor) => {
    const material = new StandardMaterial("Attractor impostor material", scene);
    material.diffuseColor = impostorColor;
    material.reservedDataStore = { hidden: true }; // Ensure scene explorer doesn't show the material
    return material;
};
/**
 * Component that displays a list of attractors with debug visualization and editing controls.
 * Supports both CPU particle systems (editable) and Node particle systems (read-only).
 * @param props The component props containing the scene and attractor source.
 * @returns The rendered AttractorList component.
 */
const AttractorList = (props) => {
    const { scene, attractorSource } = props;
    const [items, setItems] = useState([]);
    // All impostors share a scale and material/color (for now!)
    const [impostorScale, setImpostorScale] = useState(1);
    const [impostorColor, setImpostorColor] = useState(() => Color3.White());
    const impostorMaterial = useResource(useCallback(() => CreateSharedMaterial(scene, impostorColor), [scene]));
    // All impostors share a gizmoManager. controlledImpostor state ensures re-render of children so that their gizmoEnabled toggle is accurate
    const gizmoManager = useResource(useCallback(() => CreateGizmoManager(scene), [scene]));
    const [controlledImpostor, setControlledImpostor] = useState(null);
    // If attractors change, recreate the items to re-render attractor components
    useEffect(() => {
        setItems(AttractorsToListItems(attractorSource.attractors));
    }, [attractorSource.attractors]);
    // If color changes, update shared material to ensure children reflect new color
    useEffect(() => {
        impostorMaterial.diffuseColor = impostorColor;
    }, [impostorColor]);
    const onControlImpostor = (impostor) => {
        // If an impostor is passed, attach the gizmo to the current impostor, otherwise it will detach (i.e. set to null)
        const attached = impostor ?? null;
        gizmoManager.attachToMesh(attached);
        setControlledImpostor(attached);
    };
    const classes = useStyles$b();
    return (jsxs(Fragment, { children: [items.length > 0 && (jsxs(Fragment, { children: [jsx(Color3PropertyLine, { label: "Attractor Debug Color", value: impostorColor, onChange: setImpostorColor }), jsx(SyncedSliderPropertyLine, { label: "Attractor Debug Size", value: impostorScale, onChange: setImpostorScale, min: 0, max: 10, step: 0.1 }), jsx(Subtitle2, { className: classes.subsection, children: "Attractors list" })] })), jsx(List, { addButtonLabel: `Add New Attractor`, items: items, onDelete: attractorSource.removeAttractor
                    ? (item, _index) => {
                        // Only CPU attractors (Attractor instances) can be removed
                        if (item.data.source instanceof Attractor) {
                            attractorSource.removeAttractor(item.data.source);
                        }
                    }
                    : undefined, onAdd: attractorSource.addAttractor
                    ? (item) => {
                        // Only CPU attractors can be added
                        if (!item || item.data.source instanceof Attractor) {
                            attractorSource.addAttractor(item?.data.source instanceof Attractor ? item.data.source : new Attractor());
                        }
                    }
                    : undefined, renderItem: (item) => {
                    return (jsx(AttractorComponent, { attractorData: item.data, id: item.id, scene: scene, impostorColor: impostorColor, impostorScale: impostorScale, impostorMaterial: impostorMaterial, isControlled: (impostor) => impostor === controlledImpostor, onControl: onControlImpostor }));
                } })] }));
};

/**
 * Creates an IAttractorData adapter from a CPU particle system Attractor.
 * @param attractor The CPU particle system attractor
 * @returns The IAttractorData adapter
 */
function CreateCPUAttractorData(attractor) {
    return {
        position: attractor.position,
        strength: attractor.strength,
        setStrength: (value) => {
            attractor.strength = value;
        },
        source: attractor,
        isReadOnly: false,
    };
}
/**
 * Creates an IAttractorData adapter from a Node particle system UpdateAttractorBlock.
 * @param block The UpdateAttractorBlock from a Node particle system
 * @returns The IAttractorData adapter
 */
function CreateNodeAttractorData(block) {
    // Get the connected blocks - only use values if they are InputBlocks (constant values)
    // If the value is a dynamic calculation, fall back to the block's default values
    const attractorConnected = block.attractor.connectedPoint?.ownerBlock;
    const strengthConnected = block.strength.connectedPoint?.ownerBlock;
    const attractorInput = attractorConnected instanceof ParticleInputBlock ? attractorConnected : undefined;
    const strengthInput = strengthConnected instanceof ParticleInputBlock ? strengthConnected : undefined;
    // Use InputBlock values if available, null if dynamic, otherwise use the block's default values
    const position = attractorInput?.value ?? block.attractor.value;
    const strength = strengthInput?.value ?? (strengthConnected ? null : block.strength.value);
    return {
        position: position,
        strength: strength,
        setStrength: (value) => {
            if (strengthInput) {
                strengthInput.value = value;
            }
        },
        source: block,
        isReadOnly: true,
    };
}
/**
 * Creates an IAttractorSource for a CPU particle system.
 * @param system The CPU particle system
 * @param attractors The current attractors array (from useObservableArray hook)
 * @returns The IAttractorSource adapter
 */
function CreateCPUAttractorSource(system, attractors) {
    return {
        attractors: attractors.map(CreateCPUAttractorData),
        addAttractor: (attractor) => system.addAttractor(attractor ?? new Attractor()),
        removeAttractor: (attractor) => system.removeAttractor(attractor),
    };
}
/**
 * Creates an IAttractorSource for a Node particle system.
 * @param nodeSet The NodeParticleSystemSet
 * @returns The IAttractorSource adapter
 */
function CreateNodeAttractorSource(nodeSet) {
    const attractorBlocks = nodeSet.attachedBlocks.filter((block) => block instanceof UpdateAttractorBlock);
    return {
        attractors: attractorBlocks.map(CreateNodeAttractorData),
    };
}

/**
 * Display attractor-related properties for a particle system.
 * Supports both CPU particle systems (editable) and Node particle systems (read-only).
 * @param props Component props.
 * @returns Render property lines.
 */
const ParticleSystemAttractorProperties = (props) => {
    const { particleSystem: system } = props;
    const scene = system.getScene();
    const isNodeGenerated = system.isNodeGenerated;
    // For non-node systems - Hook is called but inactive for Node systems
    const attractorsGetter = useCallback(() => system.attractors ?? [], [system]);
    const attractors = useObservableArray(isNodeGenerated ? null : system, attractorsGetter, "addAttractor", "removeAttractor");
    // Create appropriate source based on the particle system type
    const attractorSource = isNodeGenerated ? CreateNodeAttractorSource(system.source) : CreateCPUAttractorSource(system, attractors);
    // Show message for Node systems with no attractors
    if (isNodeGenerated && attractorSource.attractors.length === 0) {
        return jsx(MessageBar, { intent: "info", title: "No Attractors", message: "No attractor blocks found. Add them in the Node Particle Editor." });
    }
    return (jsx(Fragment, { children: scene ? (jsx(AttractorList, { attractorSource: attractorSource, scene: scene })) : (jsx(MessageBar, { intent: "info", title: "No Scene Available", message: "Cannot display attractors without a scene" })) }));
};

const useStyles$a = makeStyles({
    subsection: {
        marginTop: tokens.spacingVerticalM,
    },
});
const InputBlockPropertyLine = (props) => {
    const { block } = props;
    // We need to re-evaluate this outer component when type/min/max change since that determines what type of property line we render.
    const type = useProperty(block, "type");
    const min = useProperty(block, "min");
    const max = useProperty(block, "max");
    const commonProps = {
        label: block.name,
        target: block,
        propertyKey: "value",
    };
    if (type === NodeParticleBlockConnectionPointTypes.Int) {
        const hasMinMax = !isNaN(min) && !isNaN(max) && min !== max;
        if (hasMinMax) {
            return jsx(BoundProperty, { component: SyncedSliderPropertyLine, ...commonProps, min: min, max: max, step: 1 }, `${block.uniqueId} (Slider)`);
        }
        else {
            return jsx(BoundProperty, { component: NumberInputPropertyLine, ...commonProps, step: 1 }, `${block.uniqueId} (Number)`);
        }
    }
    else if (type === NodeParticleBlockConnectionPointTypes.Float) {
        const hasMinMax = !isNaN(min) && !isNaN(max) && min !== max;
        if (hasMinMax) {
            return jsx(BoundProperty, { component: SyncedSliderPropertyLine, ...commonProps, min: min, max: max, step: (max - min) / 100.0 }, `${block.uniqueId} (Slider)`);
        }
        else {
            return jsx(BoundProperty, { component: NumberInputPropertyLine, ...commonProps }, `${block.uniqueId} (Number)`);
        }
    }
    else if (type === NodeParticleBlockConnectionPointTypes.Color4) {
        return jsx(BoundProperty, { component: Color4PropertyLine, ...commonProps }, `${block.uniqueId} (Color4)`);
    }
    else if (type === NodeParticleBlockConnectionPointTypes.Vector2) {
        return jsx(BoundProperty, { component: Vector2PropertyLine, ...commonProps }, `${block.uniqueId} (Vector2)`);
    }
    else if (type === NodeParticleBlockConnectionPointTypes.Vector3) {
        return jsx(BoundProperty, { component: Vector3PropertyLine, ...commonProps }, `${block.uniqueId} (Vector3)`);
    }
    else {
        return null;
    }
};
/**
 * Display the NPE blocks that are marked as visible in the inspector.
 * @param props Component props.
 * @returns Render property lines.
 */
const ParticleSystemNodeEditorProperties = (props) => {
    const { particleSystem: system } = props;
    const classes = useStyles$a();
    const source = system.source;
    const inputBlocks = useObservableState(useCallback(() => {
        if (!source) {
            return [];
        }
        const inspectorVisibleInputBlocks = source.inputBlocks
            .filter((block) => block.displayInInspector && !block.isContextual && !block.isSystemSource && block.name)
            .map((block) => block);
        const groupedInputBlocks = GroupBy(inspectorVisibleInputBlocks, (block) => block.groupInInspector);
        return groupedInputBlocks.sort((a, b) => a.key.localeCompare(b.key));
    }, [source]), source?.onBuildObservable);
    if (!source) {
        return null;
    }
    return (jsx(Fragment, { children: inputBlocks.length === 0 ? (jsx(MessageBar, { intent: "info", title: "No Visible Input Blocks", message: "To see input blocks, mark them as displayInInspector in the Node Particle Editor.", docLink: "https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/node_particle" }, "no-visible-input-blocks")) : (jsx(Fragment, { children: inputBlocks.map((group) => (jsxs(Fragment$1, { children: [group.key && jsx(Subtitle2, { className: classes.subsection, children: group.key }), group.items.map((block) => (jsx(InputBlockPropertyLine, { block: block }, block.uniqueId)))] }, `${group.key || "default"} (Group)`))) })) }));
};

function IsParticleSystem(entity) {
    return entity instanceof ParticleSystem || entity instanceof GPUParticleSystem;
}
function IsNodeParticleSystem(entity) {
    return entity instanceof ParticleSystem && entity.isNodeGenerated;
}
function IsCPUParticleSystem(entity) {
    return entity instanceof ParticleSystem;
}
function IsNonNodeParticleSystem(entity) {
    return (entity instanceof ParticleSystem && !entity.isNodeGenerated) || entity instanceof GPUParticleSystem;
}
const ParticleSystemPropertiesServiceDefinition = {
    friendlyName: "Particle System Properties",
    consumes: [PropertiesServiceIdentity, SelectionServiceIdentity],
    factory: (propertiesService, selectionService) => {
        // Register each section in its own call to keep ordering predictable across registrations.
        // Note: section `order` is not globally sorted across different registrations, so call order matters.
        // Register sections for non-node-generated particle systems.
        const particleSystemSystemContent = propertiesService.addSectionContent({
            key: "Particle System System Properties",
            predicate: IsParticleSystem,
            content: [
                {
                    section: "System",
                    order: 1,
                    component: ({ context }) => jsx(ParticleSystemSystemProperties, { particleSystem: context, selectionService: selectionService }),
                },
            ],
        });
        // Register sections for non-node-generated particle systems.
        const particleSystemCommandsContent = propertiesService.addSectionContent({
            key: "Particle System Commands Properties",
            predicate: IsParticleSystem,
            content: [
                {
                    section: "Commands",
                    order: 2,
                    component: ({ context }) => jsx(ParticleSystemCommandProperties, { particleSystem: context, selectionService: selectionService }),
                },
            ],
        });
        // The Attractors section must not be visible at all (including the accordion entry) for CPU systems.
        const particleSystemAttractorsContent = propertiesService.addSectionContent({
            key: "Particle System Attractors Properties",
            predicate: IsCPUParticleSystem,
            content: [
                {
                    section: "Attractors",
                    order: 3,
                    component: ({ context }) => jsx(ParticleSystemAttractorProperties, { particleSystem: context }),
                },
            ],
        });
        const particleSystemEmitterContent = propertiesService.addSectionContent({
            key: "Particle System Emitter Properties",
            predicate: IsParticleSystem,
            content: [
                {
                    section: "Emitter",
                    order: 4,
                    component: ({ context }) => jsx(ParticleSystemEmitterProperties, { particleSystem: context, selectionService: selectionService }),
                },
            ],
        });
        const particleSystemEmissionContent = propertiesService.addSectionContent({
            key: "Particle System Emission Properties",
            predicate: IsNonNodeParticleSystem,
            content: [
                {
                    section: "Emission",
                    order: 5,
                    component: ({ context }) => jsx(ParticleSystemEmissionProperties, { particleSystem: context }),
                },
            ],
        });
        // The Size section must not be visible at all (including the accordion entry) for node-generated systems.
        const particleSystemSizeContent = propertiesService.addSectionContent({
            key: "Particle System Size Properties",
            predicate: IsNonNodeParticleSystem,
            content: [
                {
                    section: "Size",
                    order: 6,
                    component: ({ context }) => jsx(ParticleSystemSizeProperties, { particleSystem: context }),
                },
            ],
        });
        // Lifetime is registered for all systems; the component limits the visible fields for node-generated systems.
        const particleSystemLifetimeContent = propertiesService.addSectionContent({
            key: "Particle System Lifetime Properties",
            predicate: IsNonNodeParticleSystem,
            content: [
                {
                    section: "Lifetime",
                    order: 7,
                    component: ({ context }) => jsx(ParticleSystemLifetimeProperties, { particleSystem: context }),
                },
            ],
        });
        // Register Color after Lifetime.
        const particleSystemColorContent = propertiesService.addSectionContent({
            key: "Particle System Color Properties",
            predicate: IsNonNodeParticleSystem,
            content: [
                {
                    section: "Colors",
                    order: 8,
                    component: ({ context }) => jsx(ParticleSystemColorProperties, { particleSystem: context }),
                },
            ],
        });
        // Register Rotation after Colors.
        const particleSystemRotationContent = propertiesService.addSectionContent({
            key: "Particle System Rotation Properties",
            predicate: IsNonNodeParticleSystem,
            content: [
                {
                    section: "Rotation",
                    order: 9,
                    component: ({ context }) => jsx(ParticleSystemRotationProperties, { particleSystem: context }),
                },
            ],
        });
        // Register Spritesheet after Rotation.
        const particleSystemSpritesheetContent = propertiesService.addSectionContent({
            key: "Particle System Spritesheet Properties",
            predicate: IsNonNodeParticleSystem,
            content: [
                {
                    section: "Spritesheet",
                    order: 10,
                    component: ({ context }) => jsx(ParticleSystemSpritesheetProperties, { particleSystem: context }),
                },
            ],
        });
        const particleSystemNodeEditorContent = propertiesService.addSectionContent({
            key: "Node Particle System Inputs Properties",
            predicate: IsNodeParticleSystem,
            content: [
                {
                    section: "Inputs",
                    order: 12,
                    component: ({ context }) => jsx(ParticleSystemNodeEditorProperties, { particleSystem: context, selectionService: selectionService }),
                },
            ],
        });
        return {
            dispose: () => {
                particleSystemSystemContent.dispose();
                particleSystemCommandsContent.dispose();
                particleSystemAttractorsContent.dispose();
                particleSystemEmitterContent.dispose();
                particleSystemEmissionContent.dispose();
                particleSystemSizeContent.dispose();
                particleSystemLifetimeContent.dispose();
                particleSystemColorContent.dispose();
                particleSystemRotationContent.dispose();
                particleSystemSpritesheetContent.dispose();
                particleSystemNodeEditorContent.dispose();
            },
        };
    },
};

const MotionOptions = [
    { label: "Static", value: 0 /* PhysicsMotionType.STATIC */ },
    { label: "Animated", value: 1 /* PhysicsMotionType.ANIMATED */ },
    { label: "Dynamic", value: 2 /* PhysicsMotionType.DYNAMIC */ },
];
const PrestepOptions = [
    { label: "Disabled", value: PhysicsPrestepType.DISABLED },
    { label: "Teleport", value: PhysicsPrestepType.TELEPORT },
    { label: "Action", value: PhysicsPrestepType.ACTION },
];
/**
 * Convert physics shape type to a human-readable string.
 * @param type The physics shape type.
 * @returns The human-readable string.
 */
function GetShapeTypeString(type) {
    switch (type) {
        case 3 /* PhysicsShapeType.BOX */:
            return "Box";
        case 0 /* PhysicsShapeType.SPHERE */:
            return "Sphere";
        case 2 /* PhysicsShapeType.CYLINDER */:
            return "Cylinder";
        case 1 /* PhysicsShapeType.CAPSULE */:
            return "Capsule";
        case 5 /* PhysicsShapeType.CONTAINER */:
            return "Container";
        case 4 /* PhysicsShapeType.CONVEX_HULL */:
            return "Convex Hull";
        case 6 /* PhysicsShapeType.MESH */:
            return "Mesh";
        case 7 /* PhysicsShapeType.HEIGHTFIELD */:
            return "Heightfield";
        default:
            return "Unknown";
    }
}
const TransformNodePhysicsProperties = (props) => {
    const { node } = props;
    const physicsBody = useProperty(node, "physicsBody");
    if (!physicsBody) {
        return (jsx(MessageBar, { intent: "info", title: "No Physics Body", message: "To modify physics properties, attach a physics body to this node.", docLink: "https://doc.babylonjs.com/features/featuresDeepDive/physics/rigidBodies" }));
    }
    return jsx(PhysicsBodyProperties, { physicsBody: physicsBody });
};
/**
 * Physics properties
 * @param props transform node
 * @returns controls
 */
const PhysicsBodyProperties = (props) => {
    const { physicsBody } = props;
    const massProperties = useObservableState(useCallback(() => physicsBody.getMassProperties(), [physicsBody]), useInterceptObservable("function", physicsBody, "setMassProperties"));
    const centerOfMass = useVector3Property(massProperties, "centerOfMass") ?? Vector3.Zero();
    const inertia = useVector3Property(massProperties, "inertia") ?? Vector3.Zero();
    // Get current damping values
    const linearDamping = useObservableState(() => physicsBody.getLinearDamping(), useInterceptObservable("function", physicsBody, "setLinearDamping"));
    const angularDamping = useObservableState(() => physicsBody.getAngularDamping(), useInterceptObservable("function", physicsBody, "setAngularDamping"));
    // Get motion and prestep types
    const motionType = useObservableState(() => physicsBody.getMotionType(), useInterceptObservable("function", physicsBody, "setMotionType"));
    const prestepType = useObservableState(() => physicsBody.getPrestepType(), useInterceptObservable("function", physicsBody, "setPrestepType"));
    // Get current velocities
    const linearVelocity = useObservableState(useCallback(() => physicsBody.getLinearVelocity(), [physicsBody]), useInterceptObservable("function", physicsBody, "setLinearVelocity"));
    const angularVelocity = useObservableState(useCallback(() => physicsBody.getAngularVelocity(), [physicsBody]), useInterceptObservable("function", physicsBody, "setAngularVelocity"));
    // Get shape and material properties
    const shape = useProperty(physicsBody, "shape");
    const type = useProperty(shape, "type");
    const material = useProperty(shape, "material");
    return (jsxs(Fragment, { children: [jsx(NumberDropdownPropertyLine, { label: "Motion Type", options: MotionOptions, value: motionType, onChange: (value) => physicsBody.setMotionType(value) }, "MotionType"), jsx(NumberDropdownPropertyLine, { label: "Prestep Type", options: PrestepOptions, value: prestepType, onChange: (value) => physicsBody.setPrestepType(value) }), shape && jsx(TextPropertyLine, { label: "Shape Type", value: GetShapeTypeString(type) }), jsx(NumberInputPropertyLine, { label: "Linear Damping", min: 0, max: 1, step: 0.01, value: linearDamping, onChange: (value) => physicsBody.setLinearDamping(value) }), jsx(NumberInputPropertyLine, { label: "Angular Damping", min: 0, max: 1, step: 0.01, value: angularDamping, onChange: (value) => physicsBody.setAngularDamping(value) }), shape && (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Dynamic Friction", min: 0, max: 1, step: 0.01, target: material, propertyKey: "friction", nullable: true, defaultValue: 0.5 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Static Friction", min: 0, max: 1, step: 0.01, target: material, propertyKey: "staticFriction", nullable: true, defaultValue: material?.friction ?? 0.5 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Restitution", min: 0, max: 1, step: 0.01, target: material, propertyKey: "restitution", nullable: true, defaultValue: 0 })] })), jsx(Vector3PropertyLine, { label: "Linear Velocity", value: linearVelocity, onChange: (value) => physicsBody.setLinearVelocity(value) }), jsx(Vector3PropertyLine, { label: "Angular Velocity", value: angularVelocity, onChange: (value) => physicsBody.setAngularVelocity(value) }), massProperties && (jsxs(Fragment, { children: [jsx(NumberInputPropertyLine, { label: "Mass", value: massProperties.mass ?? 0, min: 0, step: 0.01, onChange: (value) => {
                            physicsBody.setMassProperties({ ...massProperties, mass: value });
                        } }), jsx(Vector3PropertyLine, { label: "Center of Mass", value: centerOfMass, onChange: (value) => {
                            physicsBody.setMassProperties({ ...massProperties, centerOfMass: value });
                        } }), jsx(Vector3PropertyLine, { label: "Inertia", value: inertia, onChange: (value) => {
                            physicsBody.setMassProperties({ ...massProperties, inertia: value });
                        } })] }))] }));
};

const PhysicsPropertiesServiceDefinition = {
    friendlyName: "Physics Properties",
    consumes: [PropertiesServiceIdentity],
    factory: (propertiesService) => {
        const contentRegistration = propertiesService.addSectionContent({
            key: "Physics Properties",
            predicate: (entity) => entity instanceof TransformNode,
            content: [
                {
                    section: "Physics",
                    component: ({ context: node }) => jsx(TransformNodePhysicsProperties, { node: node }),
                },
            ],
        });
        return {
            dispose: () => {
                contentRegistration.dispose();
            },
        };
    },
};

const useCheckboxStyles = makeStyles({
    indicator: {
        margin: 0,
    },
});
/**
 * This is a primitive fluent checkbox that can both read and write checked state
 * @param props
 * @returns Checkbox component
 */
const Checkbox = (props) => {
    Checkbox.displayName = "Checkbox";
    const [checked, setChecked] = useState(() => props.value ?? false);
    const classes = useCheckboxStyles();
    useEffect(() => {
        if (props.value != undefined) {
            setChecked(props.value); // Update local state when props.checked changes
        }
    }, [props.value]);
    const onChange = (ev, _) => {
        props.onChange(ev.target.checked);
        setChecked(ev.target.checked);
    };
    return jsx(Checkbox$1, { checked: checked, onChange: onChange, indicator: { className: classes.indicator } });
};

/**
 * Wraps a checkbox in a property line
 * @param props - PropertyLineProps and CheckboxProps
 * @returns property-line wrapped checkbox
 */
const CheckboxPropertyLine = (props) => {
    CheckboxPropertyLine.displayName = "CheckboxPropertyLine";
    return (jsx(PropertyLine, { ...props, children: jsx(Checkbox, { ...props }) }));
};

/**
 * The properties component for a post process.
 * @param props - The properties component props containing the post process.
 * @returns JSX.Element
 */
const PostProcessProperties = (props) => {
    const { postProcess } = props;
    return (jsxs(Fragment, { children: [jsx(StringifiedPropertyLine, { label: "Width", description: "The width of the post process", value: postProcess.width, units: "px" }), jsx(StringifiedPropertyLine, { label: "Height", description: "The height of the post process", value: postProcess.height, units: "px" }), jsx(BoundProperty, { component: CheckboxPropertyLine, label: "Auto Clear", target: postProcess, propertyKey: "autoClear" }), postProcess.clearColor && jsx(BoundProperty, { component: Color4PropertyLine, label: "Clear Color", target: postProcess, propertyKey: "clearColor" }), jsx(BoundProperty, { component: CheckboxPropertyLine, label: "Pixel Perfect", target: postProcess, propertyKey: "enablePixelPerfectMode" }), jsx(BoundProperty, { component: CheckboxPropertyLine, label: "Fullscreen Viewport", target: postProcess, propertyKey: "forceFullscreenViewport" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Samples", target: postProcess, propertyKey: "samples", min: 1, max: 8, step: 1 })] }));
};

const PostProcessPropertiesServiceDefinition = {
    friendlyName: "Post Process Properties",
    consumes: [PropertiesServiceIdentity],
    factory: (propertiesService) => {
        const postProcessContentRegistration = propertiesService.addSectionContent({
            key: "Post Process Properties",
            predicate: (entity) => entity instanceof PostProcess,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(PostProcessProperties, { postProcess: context }),
                },
            ],
        });
        return {
            dispose: () => {
                postProcessContentRegistration.dispose();
            },
        };
    },
};

const PostProcessRenderPipelineSamplesProperties = (props) => {
    const { pipeline } = props;
    const hasSamples = "samples" in pipeline;
    if (!hasSamples) {
        return null;
    }
    return (jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Samples", description: "MSAA sample count", target: pipeline, propertyKey: "samples", min: 1, step: 1 }));
};

const DepthOfFieldBlurLevelOptions = [
    { label: "Low", value: 0 /* DepthOfFieldEffectBlurLevel.Low */ },
    { label: "Medium", value: 1 /* DepthOfFieldEffectBlurLevel.Medium */ },
    { label: "High", value: 2 /* DepthOfFieldEffectBlurLevel.High */ },
];
const ToneMappingTypeOptions = [
    { label: "Standard", value: ImageProcessingConfiguration.TONEMAPPING_STANDARD },
    { label: "ACES", value: ImageProcessingConfiguration.TONEMAPPING_ACES },
    { label: "Khronos PBR Neutral", value: ImageProcessingConfiguration.TONEMAPPING_KHR_PBR_NEUTRAL },
];
const VignetteBlendModeOptions = [
    { label: "Multiply", value: ImageProcessingConfiguration.VIGNETTEMODE_MULTIPLY },
    { label: "Opaque", value: ImageProcessingConfiguration.VIGNETTEMODE_OPAQUE },
];
const DefaultRenderingPipelineBloomProperties = (props) => {
    const { pipeline } = props;
    const bloomEnabled = useProperty(pipeline, "bloomEnabled");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Bloom Enabled", target: pipeline, propertyKey: "bloomEnabled" }), jsxs(Collapse, { visible: !!bloomEnabled, children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Threshold", target: pipeline, propertyKey: "bloomThreshold", min: 0, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Weight", target: pipeline, propertyKey: "bloomWeight", min: 0, step: 0.05 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Kernel", target: pipeline, propertyKey: "bloomKernel", min: 0, step: 1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Scale", target: pipeline, propertyKey: "bloomScale", min: 0, step: 0.25 })] })] }));
};
const DefaultRenderingPipelineChromaticAberrationProperties = (props) => {
    const { pipeline } = props;
    const chromaticAberrationEnabled = useProperty(pipeline, "chromaticAberrationEnabled");
    const chromaticAberration = pipeline.chromaticAberration;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Chromatic Aberration Enabled", target: pipeline, propertyKey: "chromaticAberrationEnabled" }), jsxs(Collapse, { visible: !!chromaticAberrationEnabled && !!chromaticAberration, children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Aberration Amount", target: chromaticAberration, propertyKey: "aberrationAmount", propertyPath: "chromaticAberration.aberrationAmount", min: 0, step: 0.1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Radial Intensity", target: chromaticAberration, propertyKey: "radialIntensity", propertyPath: "chromaticAberration.radialIntensity", min: 0, step: 0.01 }), jsx(BoundProperty, { component: Vector2PropertyLine, label: "Center Position", target: chromaticAberration, propertyKey: "centerPosition", propertyPath: "chromaticAberration.centerPosition" }), jsx(BoundProperty, { component: Vector2PropertyLine, label: "Direction", target: chromaticAberration, propertyKey: "direction", propertyPath: "chromaticAberration.direction" })] })] }));
};
const DefaultRenderingPipelineDepthOfFieldProperties = (props) => {
    const { pipeline } = props;
    const depthOfFieldEnabled = useProperty(pipeline, "depthOfFieldEnabled");
    const depthOfField = pipeline.depthOfField;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Depth of Field Enabled", target: pipeline, propertyKey: "depthOfFieldEnabled" }), jsxs(Collapse, { visible: !!depthOfFieldEnabled && !!depthOfField, children: [jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Blur Level", target: pipeline, propertyKey: "depthOfFieldBlurLevel", options: DepthOfFieldBlurLevelOptions }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Focal Length", target: depthOfField, propertyKey: "focalLength", propertyPath: "depthOfField.focalLength", min: 0, step: 0.1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "F-Stop", target: depthOfField, propertyKey: "fStop", propertyPath: "depthOfField.fStop", min: 0, step: 0.1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Focus Distance", target: depthOfField, propertyKey: "focusDistance", propertyPath: "depthOfField.focusDistance", min: 0, step: 0.1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Lens Size", target: depthOfField, propertyKey: "lensSize", propertyPath: "depthOfField.lensSize", min: 0, step: 1 })] })] }));
};
const DefaultRenderingPipelineFxaaGlowProperties = (props) => {
    const { pipeline } = props;
    const glowLayerEnabled = useProperty(pipeline, "glowLayerEnabled");
    const glowLayer = pipeline.glowLayer;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "FXAA Enabled", target: pipeline, propertyKey: "fxaaEnabled" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Glow Layer Enabled", target: pipeline, propertyKey: "glowLayerEnabled" }), jsxs(Collapse, { visible: !!glowLayerEnabled && !!glowLayer, children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Blur Kernel Size", target: glowLayer, propertyKey: "blurKernelSize", propertyPath: "glowLayer.blurKernelSize", min: 1, step: 1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Intensity", target: glowLayer, propertyKey: "intensity", propertyPath: "glowLayer.intensity", min: 0, step: 0.1 })] })] }));
};
const DefaultRenderingPipelineGrainProperties = (props) => {
    const { pipeline } = props;
    const grainEnabled = useProperty(pipeline, "grainEnabled");
    const grain = pipeline.grain;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Grain Enabled", target: pipeline, propertyKey: "grainEnabled" }), jsxs(Collapse, { visible: !!grainEnabled && !!grain, children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Animated", target: grain, propertyKey: "animated", propertyPath: "grain.animated" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Intensity", target: grain, propertyKey: "intensity", propertyPath: "grain.intensity", min: 0, step: 0.1 })] })] }));
};
const DefaultRenderingPipelineImageProcessingProperties = (props) => {
    const { pipeline } = props;
    const imageProcessingEnabled = useProperty(pipeline, "imageProcessingEnabled");
    const imageProcessing = pipeline.imageProcessing;
    const vignetteEnabled = useProperty(imageProcessing, "vignetteEnabled");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Image Processing Enabled", target: pipeline, propertyKey: "imageProcessingEnabled" }), jsxs(Collapse, { visible: !!imageProcessingEnabled && !!imageProcessing, children: [jsx(ButtonLine, { label: "Convert Clear Color to Linear", onClick: () => {
                            pipeline.scene.clearColor = pipeline.scene.clearColor.toLinearSpace(pipeline.scene.getEngine().useExactSrgbConversions);
                        } }), jsx(ButtonLine, { label: "Convert Clear Color to Gamma", onClick: () => {
                            pipeline.scene.clearColor = pipeline.scene.clearColor.toGammaSpace(pipeline.scene.getEngine().useExactSrgbConversions);
                        } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Contrast", target: imageProcessing, propertyKey: "contrast", propertyPath: "imageProcessing.contrast", min: 0, step: 0.1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Exposure", target: imageProcessing, propertyKey: "exposure", propertyPath: "imageProcessing.exposure", min: 0, step: 0.1 }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Tone Mapping Enabled", target: imageProcessing, propertyKey: "toneMappingEnabled", propertyPath: "imageProcessing.toneMappingEnabled" }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Tone Mapping Type", target: imageProcessing, propertyKey: "toneMappingType", propertyPath: "imageProcessing.toneMappingType", options: ToneMappingTypeOptions }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Vignette Enabled", target: imageProcessing, propertyKey: "vignetteEnabled", propertyPath: "imageProcessing.vignetteEnabled" }), jsxs(Collapse, { visible: !!vignetteEnabled, children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Vignette Weight", target: imageProcessing, propertyKey: "vignetteWeight", propertyPath: "imageProcessing.vignetteWeight", min: 0, step: 0.1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Vignette Stretch", target: imageProcessing, propertyKey: "vignetteStretch", propertyPath: "imageProcessing.vignetteStretch", min: 0, step: 0.1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Vignette Camera FOV", target: imageProcessing, propertyKey: "vignetteCameraFov", propertyPath: "imageProcessing.vignetteCameraFov", min: 0, step: 0.1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Vignette Center X", target: imageProcessing, propertyKey: "vignetteCenterX", propertyPath: "imageProcessing.vignetteCenterX", step: 0.1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Vignette Center Y", target: imageProcessing, propertyKey: "vignetteCenterY", propertyPath: "imageProcessing.vignetteCenterY", step: 0.1 }), jsx(BoundProperty, { component: Color4PropertyLine, label: "Vignette Color", target: imageProcessing, propertyKey: "vignetteColor", propertyPath: "imageProcessing.vignetteColor" }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Vignette Blend Mode", target: imageProcessing, propertyKey: "vignetteBlendMode", propertyPath: "imageProcessing.vignetteBlendMode", options: VignetteBlendModeOptions })] }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Dithering Enabled", target: imageProcessing, propertyKey: "ditheringEnabled", propertyPath: "imageProcessing.ditheringEnabled" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Dithering Intensity", target: imageProcessing, propertyKey: "ditheringIntensity", propertyPath: "imageProcessing.ditheringIntensity", min: 0, step: 0.5 / 255 })] })] }));
};
const DefaultRenderingPipelineSharpenProperties = (props) => {
    const { pipeline } = props;
    const sharpenEnabled = useProperty(pipeline, "sharpenEnabled");
    const sharpen = pipeline.sharpen;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Sharpen Enabled", target: pipeline, propertyKey: "sharpenEnabled" }), jsxs(Collapse, { visible: !!sharpenEnabled && !!sharpen, children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Color Amount", target: sharpen, propertyKey: "colorAmount", propertyPath: "sharpen.colorAmount", min: 0, step: 0.05 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Edge Amount", target: sharpen, propertyKey: "edgeAmount", propertyPath: "sharpen.edgeAmount", min: 0, step: 0.05 })] })] }));
};

const LensRenderingPipelineOptionsProperties = (props) => {
    const { pipeline } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Edge Blur", target: pipeline, propertyKey: "edgeBlur", min: 0, step: 0.1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Edge Distortion", target: pipeline, propertyKey: "edgeDistortion", min: 0, step: 0.1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Grain Amount", target: pipeline, propertyKey: "grainAmount", min: 0, step: 0.1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Chromatic Aberration", target: pipeline, propertyKey: "chromaticAberration", min: 0, step: 0.1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Darken Out of Focus", target: pipeline, propertyKey: "darkenOutOfFocus", min: 0, step: 0.1 }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Blur Noise", target: pipeline, propertyKey: "blurNoise" })] }));
};
const LensRenderingPipelineDepthOfFieldProperties = (props) => {
    const { pipeline } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "DOF Aperture", target: pipeline, propertyKey: "dofAperture", min: 0, step: 0.1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "DOF Distortion", target: pipeline, propertyKey: "dofDistortion", min: 0, step: 0.1 }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Pentagon Bokeh", target: pipeline, propertyKey: "pentagonBokeh" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Highlights Gain", target: pipeline, propertyKey: "highlightsGain", min: 0, step: 0.1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Highlights Threshold", target: pipeline, propertyKey: "highlightsThreshold", min: 0, step: 0.1 })] }));
};

const SSAORenderingPipelineProperties = (props) => {
    const { pipeline } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Total Strength", target: pipeline, propertyKey: "totalStrength", min: 0, step: 0.05 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Base", target: pipeline, propertyKey: "base", min: 0, step: 0.05 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Radius", target: pipeline, propertyKey: "radius", min: 0.0001, step: 0.0001 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Area", target: pipeline, propertyKey: "area", min: 0.0001, step: 0.0001 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Fall Off", target: pipeline, propertyKey: "fallOff", min: 0, step: 0.000001 })] }));
};

const SSAO2RenderingPipelineSSAOProperties = (props) => {
    const { pipeline } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Total Strength", target: pipeline, propertyKey: "totalStrength", min: 0, step: 0.05 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Base", target: pipeline, propertyKey: "base", min: 0, step: 0.05 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Max Z", target: pipeline, propertyKey: "maxZ", min: 0, step: 1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Min Z Aspect", target: pipeline, propertyKey: "minZAspect", min: 0, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Radius", target: pipeline, propertyKey: "radius", min: 0, step: 0.05 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Epsilon", target: pipeline, propertyKey: "epsilon", min: 0, step: 0.001 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Samples", target: pipeline, propertyKey: "samples", min: 1, step: 1 })] }));
};
const SSAO2RenderingPipelineDenoiserProperties = (props) => {
    const { pipeline } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Bypass Blur", target: pipeline, propertyKey: "bypassBlur" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Expensive Blur", target: pipeline, propertyKey: "expensiveBlur" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Bilateral Samples", target: pipeline, propertyKey: "bilateralSamples", min: 2, step: 1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Bilateral Soften", target: pipeline, propertyKey: "bilateralSoften", min: 0, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Bilateral Tolerance", target: pipeline, propertyKey: "bilateralTolerance", min: 0, step: 0.01 })] }));
};

const SSRRenderingPipelineSSRProperties = (props) => {
    const { pipeline } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Enabled", target: pipeline, propertyKey: "isEnabled" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Debug", target: pipeline, propertyKey: "debug" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Strength", target: pipeline, propertyKey: "strength", min: 0, step: 0.05 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Reflection Specular Falloff", target: pipeline, propertyKey: "reflectionSpecularFalloffExponent", min: 0, step: 0.05 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Reflectivity Threshold", target: pipeline, propertyKey: "reflectivityThreshold", min: 0, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Thickness", target: pipeline, propertyKey: "thickness", min: 0, step: 0.01 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Step", target: pipeline, propertyKey: "step", min: 1, step: 1, forceInt: true }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Enable Smooth Reflections", target: pipeline, propertyKey: "enableSmoothReflections" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Max Steps", target: pipeline, propertyKey: "maxSteps", min: 1, step: 10, forceInt: true }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Max Distance", target: pipeline, propertyKey: "maxDistance", min: 1, step: 10 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Roughness Factor", target: pipeline, propertyKey: "roughnessFactor", min: 0, step: 0.01 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Self Collision Skip", target: pipeline, propertyKey: "selfCollisionNumSkip", min: 1, step: 1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "SSR Downsample", target: pipeline, propertyKey: "ssrDownsample", min: 0, step: 1 }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Clip to Frustum", target: pipeline, propertyKey: "clipToFrustum" })] }));
};
const SSRRenderingPipelineThicknessProperties = (props) => {
    const { pipeline } = props;
    const enableAutomaticThicknessComputation = useProperty(pipeline, "enableAutomaticThicknessComputation");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Enable Automatic Thickness Computation", target: pipeline, propertyKey: "enableAutomaticThicknessComputation" }), jsxs(Collapse, { visible: !!enableAutomaticThicknessComputation, children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Backface Force Depth Write Transparent Meshes", target: pipeline, propertyKey: "backfaceForceDepthWriteTransparentMeshes" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Backface Depth Texture Downsample", target: pipeline, propertyKey: "backfaceDepthTextureDownsample", min: 0, step: 1 })] })] }));
};
const SSRRenderingPipelineBlurProperties = (props) => {
    const { pipeline } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Blur Dispersion Strength", target: pipeline, propertyKey: "blurDispersionStrength", min: 0, step: 0.001 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Blur Downsample", target: pipeline, propertyKey: "blurDownsample", min: 0, step: 1 })] }));
};
const SSRRenderingPipelineAttenuationProperties = (props) => {
    const { pipeline } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Attenuate Screen Borders", target: pipeline, propertyKey: "attenuateScreenBorders" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Attenuate Intersection Distance", target: pipeline, propertyKey: "attenuateIntersectionDistance" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Attenuate Intersection Iterations", target: pipeline, propertyKey: "attenuateIntersectionIterations" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Attenuate Facing Camera", target: pipeline, propertyKey: "attenuateFacingCamera" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Attenuate Backface Reflection", target: pipeline, propertyKey: "attenuateBackfaceReflection" })] }));
};
const SSRRenderingPipelineColorSpaceProperties = (props) => {
    const { pipeline } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Input Texture Color Is In Gamma Space", target: pipeline, propertyKey: "inputTextureColorIsInGammaSpace" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Generate Output In Gamma Space", target: pipeline, propertyKey: "generateOutputInGammaSpace" })] }));
};

const IblShadowsRenderPipelineVoxelProperties = (props) => {
    const { pipeline } = props;
    return (jsxs(Fragment, { children: [jsx(ButtonLine, { label: "Update Scene Bounds", onClick: () => pipeline.updateSceneBounds() }), jsx(ButtonLine, { label: "Revoxelize", onClick: () => pipeline.updateVoxelization() }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Shadow Opacity", target: pipeline, propertyKey: "shadowOpacity", min: 0, step: 0.05 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Sample Directions", target: pipeline, propertyKey: "sampleDirections", min: 0, step: 1 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Resolution Exp", target: pipeline, propertyKey: "resolutionExp", min: 4, step: 1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Shadow Remanence", target: pipeline, propertyKey: "shadowRemanence", min: 0, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Voxel Shadow Opacity", target: pipeline, propertyKey: "voxelShadowOpacity", min: 0, step: 0.05 })] }));
};
const IblShadowsRenderPipelineScreenspaceProperties = (props) => {
    const { pipeline } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "SS Shadow Opacity", target: pipeline, propertyKey: "ssShadowOpacity", min: 0, step: 0.01 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "SS Shadow Sample Count", target: pipeline, propertyKey: "ssShadowSampleCount", min: 0, step: 1 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "SS Shadow Stride", target: pipeline, propertyKey: "ssShadowStride", min: 0, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "SS Shadow Distance Scale", target: pipeline, propertyKey: "ssShadowDistanceScale", min: 0.01, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "SS Shadow Thickness Scale", target: pipeline, propertyKey: "ssShadowThicknessScale", min: 0.005, step: 0.001 })] }));
};
const IblShadowsRenderPipelineDebugProperties = (props) => {
    const { pipeline } = props;
    const allowDebugPasses = useProperty(pipeline, "allowDebugPasses");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Allow Debug Passes", target: pipeline, propertyKey: "allowDebugPasses" }), allowDebugPasses && (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Voxel Debug Enabled", target: pipeline, propertyKey: "voxelDebugEnabled" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "CDF Debug Enabled", target: pipeline, propertyKey: "cdfDebugEnabled" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Voxel Tracing Debug Enabled", target: pipeline, propertyKey: "voxelTracingDebugEnabled" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Spatial Blur Debug Enabled", target: pipeline, propertyKey: "spatialBlurPassDebugEnabled" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Accumulation Pass Debug Enabled", target: pipeline, propertyKey: "accumulationPassDebugEnabled" })] }))] }));
};

const RenderingPipelinePropertiesServiceDefinition = {
    friendlyName: "Rendering Pipeline Properties",
    consumes: [PropertiesServiceIdentity],
    factory: (propertiesService) => {
        // Base PostProcessRenderPipeline properties (Samples slider)
        const baseRegistration = propertiesService.addSectionContent({
            key: "PostProcessRenderPipeline Properties",
            predicate: (entity) => entity instanceof PostProcessRenderPipeline,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(PostProcessRenderPipelineSamplesProperties, { pipeline: context }),
                },
            ],
        });
        // DefaultRenderingPipeline properties
        const defaultRegistration = propertiesService.addSectionContent({
            key: "DefaultRenderingPipeline Properties",
            predicate: (entity) => entity instanceof DefaultRenderingPipeline,
            content: [
                {
                    section: "Bloom",
                    component: ({ context }) => jsx(DefaultRenderingPipelineBloomProperties, { pipeline: context }),
                },
                {
                    section: "Chromatic Aberration",
                    component: ({ context }) => jsx(DefaultRenderingPipelineChromaticAberrationProperties, { pipeline: context }),
                },
                {
                    section: "Depth of Field",
                    component: ({ context }) => jsx(DefaultRenderingPipelineDepthOfFieldProperties, { pipeline: context }),
                },
                {
                    section: "FXAA & Glow",
                    component: ({ context }) => jsx(DefaultRenderingPipelineFxaaGlowProperties, { pipeline: context }),
                },
                {
                    section: "Grain",
                    component: ({ context }) => jsx(DefaultRenderingPipelineGrainProperties, { pipeline: context }),
                },
                {
                    section: "Image Processing",
                    component: ({ context }) => jsx(DefaultRenderingPipelineImageProcessingProperties, { pipeline: context }),
                },
                {
                    section: "Sharpen",
                    component: ({ context }) => jsx(DefaultRenderingPipelineSharpenProperties, { pipeline: context }),
                },
            ],
        });
        // LensRenderingPipeline properties
        const lensRegistration = propertiesService.addSectionContent({
            key: "LensRenderingPipeline Properties",
            predicate: (entity) => entity instanceof LensRenderingPipeline,
            content: [
                {
                    section: "Options",
                    component: ({ context }) => jsx(LensRenderingPipelineOptionsProperties, { pipeline: context }),
                },
                {
                    section: "Depth of Field",
                    component: ({ context }) => jsx(LensRenderingPipelineDepthOfFieldProperties, { pipeline: context }),
                },
            ],
        });
        // SSAORenderingPipeline properties
        const ssaoRegistration = propertiesService.addSectionContent({
            key: "SSAORenderingPipeline Properties",
            predicate: (entity) => entity instanceof SSAORenderingPipeline,
            content: [
                {
                    section: "SSAO",
                    component: ({ context }) => jsx(SSAORenderingPipelineProperties, { pipeline: context }),
                },
            ],
        });
        // SSAO2RenderingPipeline properties
        const ssao2Registration = propertiesService.addSectionContent({
            key: "SSAO2RenderingPipeline Properties",
            predicate: (entity) => entity instanceof SSAO2RenderingPipeline,
            content: [
                {
                    section: "SSAO",
                    component: ({ context }) => jsx(SSAO2RenderingPipelineSSAOProperties, { pipeline: context }),
                },
                {
                    section: "Denoiser",
                    component: ({ context }) => jsx(SSAO2RenderingPipelineDenoiserProperties, { pipeline: context }),
                },
            ],
        });
        // SSRRenderingPipeline properties
        const ssrRegistration = propertiesService.addSectionContent({
            key: "SSRRenderingPipeline Properties",
            predicate: (entity) => entity instanceof SSRRenderingPipeline,
            content: [
                {
                    section: "SSR",
                    component: ({ context }) => jsx(SSRRenderingPipelineSSRProperties, { pipeline: context }),
                },
                {
                    section: "Automatic Thickness",
                    component: ({ context }) => jsx(SSRRenderingPipelineThicknessProperties, { pipeline: context }),
                },
                {
                    section: "Blur",
                    component: ({ context }) => jsx(SSRRenderingPipelineBlurProperties, { pipeline: context }),
                },
                {
                    section: "Attenuations",
                    component: ({ context }) => jsx(SSRRenderingPipelineAttenuationProperties, { pipeline: context }),
                },
                {
                    section: "Color Space",
                    component: ({ context }) => jsx(SSRRenderingPipelineColorSpaceProperties, { pipeline: context }),
                },
            ],
        });
        // IblShadowsRenderPipeline properties
        const iblShadowsRegistration = propertiesService.addSectionContent({
            key: "IblShadowsRenderPipeline Properties",
            predicate: (entity) => entity instanceof IblShadowsRenderPipeline,
            content: [
                {
                    section: "Voxel Shadows",
                    component: ({ context }) => jsx(IblShadowsRenderPipelineVoxelProperties, { pipeline: context }),
                },
                {
                    section: "Screenspace Shadows",
                    component: ({ context }) => jsx(IblShadowsRenderPipelineScreenspaceProperties, { pipeline: context }),
                },
                {
                    section: "Debug",
                    component: ({ context }) => jsx(IblShadowsRenderPipelineDebugProperties, { pipeline: context }),
                },
            ],
        });
        return {
            dispose: () => {
                baseRegistration.dispose();
                defaultRegistration.dispose();
                lensRegistration.dispose();
                ssaoRegistration.dispose();
                ssao2Registration.dispose();
                ssrRegistration.dispose();
                iblShadowsRegistration.dispose();
            },
        };
    },
};

let StoredEnvironmentTexture;
const SceneMaterialImageProcessingProperties = (props) => {
    const { scene } = props;
    const imageProcessing = scene.imageProcessingConfiguration;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Contrast", min: 0, max: 4, step: 0.1, target: imageProcessing, propertyKey: "contrast", propertyPath: "imageProcessingConfiguration.contrast" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Exposure", min: 0, max: 4, step: 0.1, target: imageProcessing, propertyKey: "exposure", propertyPath: "imageProcessingConfiguration.exposure" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Tone Mapping", target: imageProcessing, propertyKey: "toneMappingEnabled", propertyPath: "imageProcessingConfiguration.toneMappingEnabled" }), jsx(Collapse, { visible: imageProcessing.toneMappingEnabled, children: jsx(BoundProperty, { component: NumberDropdownPropertyLine, options: [
                        { label: "Standard", value: ImageProcessingConfiguration.TONEMAPPING_STANDARD },
                        { label: "ACES", value: ImageProcessingConfiguration.TONEMAPPING_ACES },
                        { label: "Khronos PBR Neutral", value: ImageProcessingConfiguration.TONEMAPPING_KHR_PBR_NEUTRAL },
                    ], label: "Tone Mapping Type", target: imageProcessing, propertyKey: "toneMappingType", propertyPath: "imageProcessingConfiguration.toneMappingType" }) }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Vignette", target: imageProcessing, propertyKey: "vignetteEnabled", propertyPath: "imageProcessingConfiguration.vignetteEnabled" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Vignette FOV", min: 0, max: Math.PI, step: 0.1, target: imageProcessing, propertyKey: "vignetteCameraFov", propertyPath: "imageProcessingConfiguration.vignetteCameraFov" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Vignette Center X", min: 0, max: 1, step: 0.1, target: imageProcessing, propertyKey: "vignetteCenterX", propertyPath: "imageProcessingConfiguration.vignetteCenterX" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Vignette Center Y", min: 0, max: 1, step: 0.1, target: imageProcessing, propertyKey: "vignetteCenterY", propertyPath: "imageProcessingConfiguration.vignetteCenterY" }), jsx(BoundProperty, { component: Color4PropertyLine, label: "Vignette Color", target: imageProcessing, propertyKey: "vignetteColor", propertyPath: "imageProcessingConfiguration.vignetteColor" }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, options: [
                    { label: "Multiply", value: ImageProcessingConfiguration.VIGNETTEMODE_MULTIPLY },
                    { label: "Opaque", value: ImageProcessingConfiguration.VIGNETTEMODE_OPAQUE },
                ], label: "Vignette Blend Mode", target: imageProcessing, propertyKey: "vignetteBlendMode", propertyPath: "imageProcessingConfiguration.vignetteBlendMode" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Dithering", target: imageProcessing, propertyKey: "ditheringEnabled", propertyPath: "imageProcessingConfiguration.ditheringEnabled" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Dithering Intensity", min: 0, max: 1, step: 0.5 / 255.0, target: imageProcessing, propertyKey: "ditheringIntensity", propertyPath: "imageProcessingConfiguration.ditheringIntensity" })] }));
};
const ScenePhysicsProperties = (props) => {
    const { scene } = props;
    const physicsEngine = scene.getPhysicsEngine();
    return (jsx(Fragment, { children: physicsEngine ? (jsxs(Fragment, { children: [jsx(NumberInputPropertyLine, { label: "Time Step", value: physicsEngine.getTimeStep(), onChange: (value) => {
                        physicsEngine.setTimeStep(value);
                    } }), jsx(Vector3PropertyLine, { label: "Gravity", value: physicsEngine.gravity, onChange: (value) => {
                        physicsEngine.setGravity(value);
                    } })] })) : (jsx(MessageBar, { intent: "info", title: "No physics engine", message: "There is no physics engine enabled on this scene.", docLink: "https://doc.babylonjs.com/communityExtensions/editor/physics/usingPhysics/" })) }));
};
const SceneCollisionsProperties = (props) => {
    const { scene } = props;
    return (jsx(Fragment, { children: jsx(BoundProperty, { component: Vector3PropertyLine, label: "Gravity", target: scene, propertyKey: "gravity" }) }));
};
const SceneShadowsProperties = (props) => {
    const { scene } = props;
    return (jsx(Fragment, { children: jsx(ButtonLine, { label: "Normalize scene", onClick: () => {
                for (const mesh of scene.meshes) {
                    mesh.normalizeToUnitCube(true);
                    mesh.computeWorldMatrix(true);
                }
            } }) }));
};
const SceneRenderingProperties = (props) => {
    const { scene, selectionService } = props;
    const envTexture = useProperty(scene, "environmentTexture");
    const fogMode = useProperty(scene, "fogMode");
    return (jsxs(Fragment, { children: [jsx(NumberDropdownPropertyLine, { options: [
                    { label: "Point", value: 0 },
                    { label: "Wireframe", value: 1 },
                    { label: "Solid", value: 2 },
                ], label: "Rendering Mode", value: scene.forcePointsCloud ? 0 : scene.forceWireframe ? 1 : 2, onChange: (value) => {
                    switch (value) {
                        case 0:
                            scene.forcePointsCloud = true;
                            scene.forceWireframe = false;
                            break;
                        case 1:
                            scene.forcePointsCloud = false;
                            scene.forceWireframe = true;
                            break;
                        case 2:
                            scene.forcePointsCloud = false;
                            scene.forceWireframe = false;
                            break;
                    }
                } }), jsx(BoundProperty, { component: Color4PropertyLine, label: "Clear Color", target: scene, propertyKey: "clearColor" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Clear Color Enabled", target: scene, propertyKey: "autoClear" }), jsx(BoundProperty, { component: Color3PropertyLine, label: "Ambient Color", target: scene, propertyKey: "ambientColor" }), jsx(SwitchPropertyLine, { label: "Environment Texture (IBL)", value: envTexture ? true : false, onChange: () => {
                    if (envTexture) {
                        StoredEnvironmentTexture = envTexture;
                        scene.environmentTexture = null;
                    }
                    else {
                        scene.environmentTexture = StoredEnvironmentTexture;
                        StoredEnvironmentTexture = null;
                    }
                } }), scene.environmentTexture && (jsx(LinkPropertyLine, { label: "Env. texture", value: scene.environmentTexture.name, onLink: () => (selectionService.selectedEntity = scene.environmentTexture) })), jsx(FileUploadLine, { label: "Update Environment Texture", accept: ".dds, .env", onClick: (files) => {
                    if (files.length > 0) {
                        const file = files[0];
                        const isFileDDS = file.name.toLowerCase().indexOf(".dds") > 0;
                        const isFileEnv = file.name.toLowerCase().indexOf(".env") > 0;
                        if (!isFileDDS && !isFileEnv) {
                            Logger.Error("Unable to update environment texture. Please select a dds or env file.");
                            return;
                        }
                        Tools.ReadFile(file, (data) => {
                            const blob = new Blob([data], { type: "octet/stream" });
                            const url = URL.createObjectURL(blob);
                            if (isFileDDS) {
                                scene.environmentTexture = CubeTexture.CreateFromPrefilteredData(url, scene, ".dds");
                            }
                            else {
                                scene.environmentTexture = new CubeTexture(url, scene, undefined, undefined, undefined, () => { }, (message) => {
                                    if (message) {
                                        Logger.Error(message);
                                    }
                                }, undefined, undefined, ".env");
                            }
                        }, undefined, true);
                    }
                } }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "IBL Intensity", min: 0, max: 2, step: 0.01, target: scene, propertyKey: "iblIntensity" }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, options: [
                    { label: "None", value: Scene.FOGMODE_NONE },
                    { label: "Linear", value: Scene.FOGMODE_LINEAR },
                    { label: "Exp", value: Scene.FOGMODE_EXP },
                    { label: "Exp2", value: Scene.FOGMODE_EXP2 },
                ], label: "Fog Mode", target: scene, propertyKey: "fogMode" }), jsx(Collapse, { visible: fogMode !== Scene.FOGMODE_NONE, children: jsxs(Fragment, { children: [fogMode !== Scene.FOGMODE_NONE && jsx(BoundProperty, { component: Color3PropertyLine, label: "Fog Color", target: scene, propertyKey: "fogColor" }), (fogMode === Scene.FOGMODE_EXP || fogMode === Scene.FOGMODE_EXP2) && (jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Fog Density", target: scene, propertyKey: "fogDensity", step: 0.1 })), fogMode === Scene.FOGMODE_LINEAR && jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Fog Start", target: scene, propertyKey: "fogStart", step: 0.1 }), fogMode === Scene.FOGMODE_LINEAR && jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Fog End", target: scene, propertyKey: "fogEnd", step: 0.1 })] }) })] }));
};

const ScenePropertiesServiceDefinition = {
    friendlyName: "Scene Properties",
    consumes: [PropertiesServiceIdentity, SelectionServiceIdentity],
    factory: (propertiesService, selectionService) => {
        const sceneContentRegistration = propertiesService.addSectionContent({
            key: "Scene Properties",
            predicate: (entity) => entity instanceof Scene,
            content: [
                {
                    section: "Rendering",
                    component: ({ context }) => jsx(SceneRenderingProperties, { scene: context, selectionService: selectionService }),
                },
                {
                    section: "Material Image Processing",
                    component: ({ context }) => jsx(SceneMaterialImageProcessingProperties, { scene: context }),
                },
                {
                    section: "Physics",
                    component: ({ context }) => jsx(ScenePhysicsProperties, { scene: context }),
                },
                {
                    section: "Collisions",
                    component: ({ context }) => jsx(SceneCollisionsProperties, { scene: context }),
                },
                {
                    section: "Shadows",
                    component: ({ context }) => jsx(SceneShadowsProperties, { scene: context }),
                },
            ],
        });
        return {
            dispose: () => {
                sceneContentRegistration.dispose();
            },
        };
    },
};

const BoneGeneralProperties = (props) => {
    const { bone } = props;
    return (jsx(Fragment, { children: jsx(LinkToEntityPropertyLine, { label: "Linked Node", description: "The transform node linked to this bone.", entity: bone.getTransformNode(), selectionService: props.selectionService }, "Linked Transform Node") }));
};

const SkeletonGeneralProperties = (props) => {
    const { skeleton } = props;
    return (jsxs(Fragment, { children: [jsx(StringifiedPropertyLine, { label: "Bone Count", description: "The number of bones of the skeleton.", value: skeleton.bones.length }, "SkeletonBoneCount"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Texture to Store Bone Matrices", target: skeleton, propertyKey: "useTextureToStoreBoneMatrices" }, "SkeletonUseTextureToStoreBoneMatrices2"), jsx(ButtonLine, { label: "Return to Rest", onClick: () => skeleton.returnToRest() }, "SkeletonReturnToRest")] }));
};
const ViewerDisplayModes = [
    { label: "Lines", value: SkeletonViewer.DISPLAY_LINES },
    { label: "Spheres", value: SkeletonViewer.DISPLAY_SPHERES },
    { label: "Sphere and Spurs", value: SkeletonViewer.DISPLAY_SPHERE_AND_SPURS },
];
const SkeletonViewerProperties = (props) => {
    const { skeleton } = props;
    const scene = skeleton.getScene();
    const viewers = scene.meshes
        .filter((mesh) => mesh.skeleton === skeleton && mesh.reservedDataStore?.skeletonViewer)
        .map((mesh) => mesh.reservedDataStore.skeletonViewer);
    const [enabled, setEnabled] = useState(viewers.length > 0);
    const initialState = {
        displayMode: SkeletonViewer.DISPLAY_LINES,
        midStep: 0.235,
        midStepFactor: 0.155,
        sphereBaseSize: 0.15,
        sphereScaleUnit: 2,
        sphereFactor: 0.865,
        spurFollowsChild: false,
        showLocalAxes: false,
        localAxesSize: 0.075,
    };
    if (viewers.length > 0) {
        initialState.displayMode = viewers[0].displayMode;
        if (viewers[0].options.displayOptions) {
            Object.assign(initialState, viewers[0].options.displayOptions);
        }
    }
    const [options, updateOptions] = useReducer((options, deltaOptions) => {
        const mergedOptions = { ...options, ...deltaOptions };
        for (const viewer of viewers) {
            viewer.changeDisplayMode(mergedOptions.displayMode);
            viewer.changeDisplayOptions("midStep", mergedOptions.midStep);
            viewer.changeDisplayOptions("midStepFactor", mergedOptions.midStepFactor);
            viewer.changeDisplayOptions("sphereBaseSize", mergedOptions.sphereBaseSize);
            viewer.changeDisplayOptions("sphereScaleUnit", mergedOptions.sphereScaleUnit);
            viewer.changeDisplayOptions("sphereFactor", mergedOptions.sphereFactor);
            viewer.changeDisplayOptions("spurFollowsChild", mergedOptions.spurFollowsChild);
            viewer.changeDisplayOptions("showLocalAxes", mergedOptions.showLocalAxes);
            viewer.changeDisplayOptions("localAxesSize", mergedOptions.localAxesSize);
        }
        return mergedOptions;
    }, initialState);
    return (jsxs(Fragment, { children: [jsx(SwitchPropertyLine, { label: "Enabled", description: "Whether skeleton viewer is enabled or not.", value: enabled, onChange: (checked) => {
                    if (checked) {
                        for (const mesh of scene.meshes) {
                            if (mesh.skeleton === skeleton && !mesh.reservedDataStore?.skeletonViewer) {
                                mesh.reservedDataStore || (mesh.reservedDataStore = {});
                                mesh.reservedDataStore.skeletonViewer = new SkeletonViewer(skeleton, mesh, scene);
                            }
                        }
                    }
                    else {
                        for (const mesh of scene.meshes) {
                            if (mesh.skeleton === skeleton && mesh.reservedDataStore?.skeletonViewer) {
                                mesh.reservedDataStore.skeletonViewer.dispose();
                                delete mesh.reservedDataStore.skeletonViewer;
                            }
                        }
                    }
                    setEnabled(checked);
                    updateOptions({});
                } }, "SkeletonViewerEnabled"), jsx(Collapse, { visible: enabled, children: jsxs(Fragment, { children: [jsx(NumberDropdownPropertyLine, { label: "Display Mode", options: ViewerDisplayModes, description: "Show lines, spheres, or sphere and spurs.", value: options.displayMode, onChange: (value) => updateOptions({ displayMode: value }) }, "SkeletonViewerDisplayMode"), jsx(Collapse, { visible: options.displayMode !== SkeletonViewer.DISPLAY_LINES, children: jsxs(Fragment, { children: [jsx(NumberInputPropertyLine, { label: "Mid Step", value: options.midStep, description: "How far down to start tapering the bone spurs.", onChange: (value) => updateOptions({ midStep: value }) }, "SkeletonViewerDisplayOptionsMidStep"), jsx(NumberInputPropertyLine, { label: "Mid Step Factor", value: options.midStepFactor, description: "How big is the midStep?", onChange: (value) => updateOptions({ midStepFactor: value }) }, "SkeletonViewerDisplayOptionsMidStepFactor"), jsx(NumberInputPropertyLine, { label: "Sphere Base Size", value: options.sphereBaseSize, description: "Base for the Sphere Size.", onChange: (value) => updateOptions({ sphereBaseSize: value }) }, "SkeletonViewerDisplayOptionsSphereBaseSize"), jsx(NumberInputPropertyLine, { label: "Sphere Scale Unit", value: options.sphereScaleUnit, description: "The ratio of the sphere to the longest bone in units.", onChange: (value) => updateOptions({ sphereScaleUnit: value }) }, "SkeletonViewerDisplayOptionsSphereScaleUnit"), jsx(NumberInputPropertyLine, { label: "Sphere Factor", value: options.sphereFactor, description: "Ratio for the Sphere Size.", onChange: (value) => updateOptions({ sphereFactor: value }) }, "SkeletonViewerDisplayOptionsSphereFactor"), jsx(SwitchPropertyLine, { label: "Spur Follows Child", value: options.spurFollowsChild, description: "Whether a spur should attach its far end to the child bone position.", onChange: (checked) => updateOptions({ spurFollowsChild: checked }) }, "SkeletonViewerDisplayOptionsSpurFollowsChild"), jsx(SwitchPropertyLine, { label: "Show Local Axes", value: options.showLocalAxes, description: "Whether to show local axes or not.", onChange: (checked) => updateOptions({ showLocalAxes: checked }) }, "SkeletonViewerDisplayOptionsShowLocalAxes"), jsx(NumberInputPropertyLine, { label: "Local Axes Size", value: options.localAxesSize, description: "Length of each local axis.", onChange: (value) => updateOptions({ localAxesSize: value }) }, "SkeletonViewerDisplayOptionsLocalAxesSize")] }) })] }) })] }));
};

const SkeletonPropertiesServiceDefinition = {
    friendlyName: "Skeleton Properties",
    consumes: [PropertiesServiceIdentity, SelectionServiceIdentity],
    factory: (propertiesService, selectionService) => {
        const skeletonGeneralContentRegistration = propertiesService.addSectionContent({
            key: "Skeleton General Properties",
            predicate: (entity) => entity instanceof Skeleton,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(SkeletonGeneralProperties, { skeleton: context }),
                },
            ],
        });
        const skeletonViewerContentRegistration = propertiesService.addSectionContent({
            key: "Skeleton Viewer Properties",
            predicate: (entity) => entity instanceof Skeleton,
            content: [
                {
                    section: "Viewer",
                    component: ({ context }) => jsx(SkeletonViewerProperties, { skeleton: context }),
                },
            ],
        });
        const boneGeneralContentRegistration = propertiesService.addSectionContent({
            key: "Bone General Properties",
            predicate: (entity) => entity instanceof Bone,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(BoneGeneralProperties, { bone: context, selectionService: selectionService }),
                },
            ],
        });
        return {
            dispose: () => {
                boneGeneralContentRegistration.dispose();
                skeletonViewerContentRegistration.dispose();
                skeletonGeneralContentRegistration.dispose();
            },
        };
    },
};

const SpinButtonPropertyLine = (props) => {
    SpinButtonPropertyLine.displayName = "SpinButtonPropertyLine";
    return (jsx(PropertyLine, { ...props, children: jsx(SpinButton, { ...props }) }));
};

const SnippetDashboardStorageKey = "Babylon/InspectorV2/SnippetDashboard/SpriteManagers";
const SpriteManagerGeneralProperties = (props) => {
    const { spriteManager, selectionService } = props;
    return (jsxs(Fragment, { children: [jsx(TextPropertyLine, { label: "Capacity", value: spriteManager.capacity.toString() }), jsx(BoundProperty, { component: TextureSelectorPropertyLine, label: "Texture", target: spriteManager, propertyKey: "texture", scene: spriteManager.scene, onLink: (texture) => (selectionService.selectedEntity = texture) })] }));
};
const SpriteManagerOtherProperties = (props) => {
    const { spriteManager } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Pickable", target: spriteManager, propertyKey: "isPickable" }, "IsPickable"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Fog Enabled", target: spriteManager, propertyKey: "fogEnabled" }, "FogEnabled"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Depth Write", target: spriteManager, propertyKey: "disableDepthWrite", convertTo: (value) => !value, convertFrom: (value) => !value }, "DepthWrite"), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Rendering Group ID", target: spriteManager, propertyKey: "renderingGroupId", min: RenderingManager.MIN_RENDERINGGROUPS, max: RenderingManager.MAX_RENDERINGGROUPS, step: 1 }, "RenderingGroupId"), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Blend Mode", target: spriteManager, propertyKey: "blendMode", options: AlphaModeOptions }, "BlendMode")] }));
};
const SpriteManagerCellProperties = (props) => {
    const { spriteManager } = props;
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: SpinButtonPropertyLine, label: "Cell Width", target: spriteManager, propertyKey: "cellWidth", min: 1, step: 1 }, "CellWidth"), jsx(BoundProperty, { component: SpinButtonPropertyLine, label: "Cell Height", target: spriteManager, propertyKey: "cellHeight", min: 1, step: 1 }, "CellHeight")] }));
};
const SpriteManagerFileProperties = (props) => {
    const { spriteManager, selectionService } = props;
    const scene = spriteManager.scene;
    const loadFromFile = useCallback((files) => {
        const file = files[0];
        if (!file) {
            return;
        }
        Tools.ReadFile(file, (data) => {
            const decoder = new TextDecoder("utf-8");
            const jsonObject = JSON.parse(decoder.decode(data));
            spriteManager.dispose();
            selectionService.selectedEntity = null;
            const newManager = SpriteManager.Parse(jsonObject, scene, "");
            selectionService.selectedEntity = newManager;
        }, undefined, true);
    }, [spriteManager, scene, selectionService]);
    const saveToFile = useCallback(() => {
        const content = JSON.stringify(spriteManager.serialize(true));
        Tools.Download(new Blob([content]), "spriteManager.json");
    }, [spriteManager]);
    return (jsxs(Fragment, { children: [jsx(FileUploadLine, { label: "Load", onClick: loadFromFile, accept: ".json" }), jsx(ButtonLine, { label: "Save", onClick: saveToFile })] }));
};
const SpriteManagerSnippetProperties = (props) => {
    const { spriteManager, selectionService } = props;
    const scene = spriteManager.scene;
    const snippetUrl = Constants.SnippetUrl;
    const snippetId = useProperty(spriteManager, "snippetId");
    const loadFromSnippet = useCallback(async () => {
        const requestedSnippetId = PromptForSnippetId();
        if (!requestedSnippetId) {
            return;
        }
        spriteManager.dispose();
        selectionService.selectedEntity = null;
        try {
            const newManager = await SpriteManager.ParseFromSnippetAsync(requestedSnippetId, scene);
            selectionService.selectedEntity = newManager;
        }
        catch (err) {
            alert("Unable to load your sprite manager: " + err);
        }
    }, [spriteManager, scene, selectionService]);
    const saveToSnippet = useCallback(async () => {
        try {
            const content = JSON.stringify(spriteManager.serialize(true));
            const currentSnippetId = spriteManager.snippetId;
            const result = await SaveToSnippetServer({
                snippetUrl,
                currentSnippetId,
                content,
                payloadKey: "spriteManager",
                storageKey: SnippetDashboardStorageKey,
                entityName: "sprite manager",
            });
            // eslint-disable-next-line require-atomic-updates
            spriteManager.snippetId = result.snippetId;
            PersistSnippetId(SnippetDashboardStorageKey, result.snippetId);
            NotifyPlaygroundOfSnippetChange(result.oldSnippetId, result.snippetId, "SpriteManager.ParseFromSnippetAsync");
        }
        catch {
            // Alert already shown by SaveToSnippetServer
        }
    }, [spriteManager, snippetUrl]);
    return (jsxs(Fragment, { children: [snippetId && jsx(TextPropertyLine, { label: "Snippet ID", value: snippetId }), jsx(ButtonLine, { label: "Load from Snippet Server", onClick: loadFromSnippet, icon: CloudArrowUpRegular }), jsx(ButtonLine, { label: "Save to Snippet Server", onClick: saveToSnippet, icon: CloudArrowDownRegular })] }));
};
const SpriteManagerActionsProperties = (props) => {
    const { spriteManager, selectionService } = props;
    const addNewSprite = useCallback(() => {
        const newSprite = new Sprite("new sprite", spriteManager);
        selectionService.selectedEntity = newSprite;
    }, [spriteManager, selectionService]);
    const disposeManager = useCallback(() => {
        spriteManager.dispose();
        selectionService.selectedEntity = null;
    }, [spriteManager, selectionService]);
    return (jsxs(Fragment, { children: [spriteManager.sprites.length < spriteManager.capacity && jsx(ButtonLine, { label: "Add New Sprite", onClick: addNewSprite }), jsx(ButtonLine, { label: "Dispose", onClick: disposeManager })] }));
};

/**
 * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.
 * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.
 * @param texture the source texture
 * @param width the width of the result, which does not have to match the source texture width
 * @param height the height of the result, which does not have to match the source texture height
 * @param face if the texture has multiple faces, the face index to use for the source
 * @param channels a filter for which of the RGBA channels to return in the result
 * @param lod if the texture has multiple LODs, the lod index to use for the source
 * @returns the 8-bit texture data
 */
async function ApplyChannelsToTextureDataAsync(texture, width, height, face, channels, lod = 0) {
    const data = await GetTextureDataAsync(texture, width, height, face, lod);
    if (!channels.R || !channels.G || !channels.B || !channels.A) {
        for (let i = 0; i < width * height * 4; i += 4) {
            // If alpha is the only channel, just display alpha across all channels
            if (channels.A && !channels.R && !channels.G && !channels.B) {
                data[i] = data[i + 3];
                data[i + 1] = data[i + 3];
                data[i + 2] = data[i + 3];
                data[i + 3] = 255;
                continue;
            }
            let r = data[i], g = data[i + 1], b = data[i + 2], a = data[i + 3];
            // If alpha is not visible, make everything 100% alpha
            if (!channels.A) {
                a = 255;
            }
            // If only one color channel is selected, map both colors to it. If two are selected, the unused one gets set to 0
            if (!channels.R) {
                if (channels.G && !channels.B) {
                    r = g;
                }
                else if (channels.B && !channels.G) {
                    r = b;
                }
                else {
                    r = 0;
                }
            }
            if (!channels.G) {
                if (channels.R && !channels.B) {
                    g = r;
                }
                else if (channels.B && !channels.R) {
                    g = b;
                }
                else {
                    g = 0;
                }
            }
            if (!channels.B) {
                if (channels.R && !channels.G) {
                    b = r;
                }
                else if (channels.G && !channels.R) {
                    b = g;
                }
                else {
                    b = 0;
                }
            }
            data[i] = r;
            data[i + 1] = g;
            data[i + 2] = b;
            data[i + 3] = a;
        }
    }
    //To flip image on Y axis.
    if (texture.invertY || texture.isCube) {
        const numberOfChannelsByLine = width * 4;
        const halfHeight = height / 2;
        for (let i = 0; i < halfHeight; i++) {
            for (let j = 0; j < numberOfChannelsByLine; j++) {
                const currentCell = j + i * numberOfChannelsByLine;
                const targetLine = height - i - 1;
                const targetCell = j + targetLine * numberOfChannelsByLine;
                const temp = data[currentCell];
                data[currentCell] = data[targetCell];
                data[targetCell] = temp;
            }
        }
    }
    return data;
}

const useStyles$9 = makeStyles({
    root: {
        display: "flex",
        flexDirection: "column",
    },
    controls: {
        display: "flex",
        gap: tokens.spacingHorizontalXS,
    },
    controlButton: {
        minWidth: "auto",
        flex: "1 1 0", // Equal flex grow/shrink with 0 basis
        paddingVertical: tokens.spacingVerticalXS,
        paddingHorizontal: tokens.spacingHorizontalS,
        overflow: "hidden",
        textOverflow: "ellipsis",
    },
    preview: {
        border: `1px solid ${tokens.colorNeutralStroke1}`,
        display: "block",
        objectFit: "contain",
    },
    previewContainer: {
        display: "flex",
        justifyContent: "center",
        marginTop: tokens.spacingVerticalXS,
        marginBottom: tokens.spacingVerticalS,
        width: "100%",
        // Checkerboard background to show transparency
        background: "repeating-conic-gradient(#B2B2B2 0% 25%, white 25% 50%) 50% / 32px 32px",
    },
});
// This method of holding TextureChannels was brought over from inspectorv1 and can likely be refactored/simplified
const TextureChannelStates = {
    R: { R: true, G: false, B: false, A: false },
    G: { R: false, G: true, B: false, A: false },
    B: { R: false, G: false, B: true, A: false },
    A: { R: false, G: false, B: false, A: true },
    ALL: { R: true, G: true, B: true, A: true },
};
const TexturePreview = (props) => {
    const { texture, disableToolbar = false, maxWidth = "100%", maxHeight = "384px", offsetX = 0, offsetY = 0, width, height, imperativeRef } = props;
    const classes = useStyles$9();
    const canvasRef = useRef(null);
    const [channels, setChannels] = useState(TextureChannelStates.ALL);
    const [face, setFace] = useState(0);
    const [canvasStyle, setCanvasStyle] = useState();
    const internalTexture = useProperty(texture, "_texture");
    const { size } = useContext(ToolContext);
    const updatePreviewAsync = useCallback(async () => {
        const canvas = canvasRef.current;
        if (!canvas) {
            return;
        }
        try {
            await WhenTextureReadyAsync(texture); // Ensure texture is loaded before grabbing size
            const { width: textureWidth, height: textureHeight } = texture.getSize();
            // Set canvas dimensions to the sub-region size
            canvas.width = width ?? textureWidth;
            canvas.height = height ?? textureHeight;
            // Calculate the width that corresponds to maxHeight while maintaining aspect ratio
            const aspectRatio = canvas.width / canvas.height;
            // Use CSS min() to pick the smaller of maxWidth or the width that corresponds to maxHeight
            const imageWidth = `min(${maxWidth}, calc(${maxHeight} * ${aspectRatio}))`;
            setCanvasStyle({ width: imageWidth });
            // Get full texture data, then draw only the sub-region
            const data = await ApplyChannelsToTextureDataAsync(texture, textureWidth, textureHeight, face, channels);
            const context = canvas.getContext("2d");
            if (context) {
                const fullImageData = context.createImageData(textureWidth, textureHeight);
                fullImageData.data.set(data);
                // Use putImageData with dirty rect to draw only the sub-region
                context.putImageData(fullImageData, -offsetX, -offsetY, offsetX, offsetY, canvas.width, canvas.height);
            }
        }
        catch {
            // If we fail, leave the canvas empty
        }
    }, [texture, face, channels, offsetX, offsetY, width, height, internalTexture]);
    useImperativeHandle(imperativeRef, () => ({ refresh: updatePreviewAsync }), [updatePreviewAsync]);
    useEffect(() => {
        void updatePreviewAsync();
    }, [updatePreviewAsync]);
    return (jsxs("div", { className: classes.root, children: [disableToolbar ? null : texture.isCube ? (jsx(Toolbar$1, { className: classes.controls, size: size, "aria-label": "Cube Faces", children: ["+X", "-X", "+Y", "-Y", "+Z", "-Z"].map((label, idx) => (jsx(ToolbarButton, { className: classes.controlButton, appearance: face === idx ? "primary" : "subtle", onClick: () => setFace(idx), children: label }, label))) })) : (jsx(Toolbar$1, { className: classes.controls, size: size, "aria-label": "Channels", children: ["R", "G", "B", "A", "ALL"].map((ch) => (jsx(ToolbarButton, { className: classes.controlButton, appearance: channels === TextureChannelStates[ch] ? "primary" : "subtle", onClick: () => setChannels(TextureChannelStates[ch]), children: ch }, ch))) })), jsx("div", { className: classes.previewContainer, children: jsx("canvas", { ref: canvasRef, className: classes.preview, style: canvasStyle }) }), texture.isRenderTarget && (jsx(Button$1, { appearance: "outline", onClick: () => {
                    void updatePreviewAsync();
                }, children: "Refresh" }))] }));
};

function useMaxCellCount(sprite) {
    const manager = sprite.manager;
    const texture = useProperty(manager, "texture");
    const textureSize = texture.getSize();
    let maxCellCount = 0;
    if (!textureSize.width || !textureSize.height) {
        maxCellCount = Math.max(sprite.fromIndex, sprite.toIndex);
    }
    else {
        maxCellCount = (textureSize.width / manager.cellWidth) * (textureSize.height / manager.cellHeight);
    }
    return maxCellCount;
}
const SpriteGeneralProperties = (props) => {
    const { sprite, selectionService } = props;
    return (jsxs(Fragment, { children: [jsx(LinkToEntityPropertyLine, { label: "Parent", description: `Sprite Manager that owns this sprite.`, entity: sprite.manager, selectionService: selectionService }, "Parent"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Is Visible", description: "Whether the sprite is visible or not.", target: sprite, propertyKey: "isVisible" }, "IsVisible")] }));
};
const SpriteTransformProperties = (props) => {
    const { sprite, settings } = props;
    const [toDisplayAngle, fromDisplayAngle, useDegrees] = useAngleConverters(settings);
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: Vector3PropertyLine, label: "Position", target: sprite, propertyKey: "position" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Angle", description: `Rotation angle of the sprite in ${useDegrees ? "degrees" : "radians"}`, min: 0, max: toDisplayAngle(Math.PI * 2), step: toDisplayAngle(0.01), target: sprite, propertyKey: "angle", convertTo: toDisplayAngle, convertFrom: fromDisplayAngle }, "Angle"), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Width", description: "Width of the sprite (in world space units)", target: sprite, propertyKey: "width" }, "Width"), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Height", description: "Height of the sprite (in world space units)", target: sprite, propertyKey: "height" }, "Height")] }));
};
const SpriteAnimationProperties = (props) => {
    const { sprite } = props;
    const animationStarted = useObservableState(useCallback(() => sprite.animationStarted, [sprite]), useInterceptObservable("function", sprite, "playAnimation"), useInterceptObservable("function", sprite, "stopAnimation"), useInterceptObservable("function", sprite, "_animate"));
    const maxCellCount = useMaxCellCount(sprite);
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Start", description: "First frame of the animation.", min: 0, max: maxCellCount, target: sprite, propertyKey: "fromIndex" }, "Start"), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "End", description: "Last frame of the animation.", min: 0, max: maxCellCount, target: sprite, propertyKey: "toIndex" }, "End"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Loop", description: "Whether to loop the animation.", target: sprite, propertyKey: "loopAnimation" }, "Loop"), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Delay", description: "Delay between frames in milliseconds.", min: 0, target: sprite, propertyKey: "delay" }, "Delay"), jsx(ButtonLine, { label: animationStarted ? "Stop Animation" : "Start Animation", icon: animationStarted ? StopFilled : PlayFilled, onClick: () => {
                    if (animationStarted) {
                        sprite.stopAnimation();
                    }
                    else {
                        sprite.playAnimation(sprite.fromIndex, sprite.toIndex, sprite.loopAnimation, sprite.delay);
                    }
                } })] }));
};
const SpriteOtherProperties = (props) => {
    const { sprite } = props;
    const color = useColor4Property(sprite, "color");
    return (jsxs(Fragment, { children: [jsx(Color4PropertyLine, { label: "Color", description: "Color to tint the sprite.", value: color, onChange: (col) => (sprite.color = col) }, "Color"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Pickable", target: sprite, propertyKey: "isPickable" }, "IsPickable"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Alpha for Picking", target: sprite, propertyKey: "useAlphaForPicking" }, "UseAlphaForPicking")] }));
};
const SpriteCellProperties = (props) => {
    const { sprite } = props;
    const maxCellCount = useMaxCellCount(sprite);
    const manager = sprite.manager;
    const texture = manager.texture;
    const size = texture.getSize();
    const cellWidth = useProperty(manager, "cellWidth");
    const cellHeight = useProperty(manager, "cellHeight");
    const cellIndex = useProperty(sprite, "cellIndex");
    const offsetX = (cellIndex * cellWidth) % size.width;
    const offsetY = Math.floor((cellIndex * cellWidth) / size.width) * cellHeight;
    return (jsxs(Fragment, { children: [jsx(TexturePreview, { disableToolbar: true, texture: texture, maxHeight: "160px", offsetX: offsetX, offsetY: offsetY, width: cellWidth, height: cellHeight }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Cell Index", target: sprite, propertyKey: "cellIndex", min: 0, step: 1, max: maxCellCount }, "CellIndex"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Invert U", target: sprite, propertyKey: "invertU" }, "InvertU"), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Invert V", target: sprite, propertyKey: "invertV" }, "InvertV")] }));
};

const SpritePropertiesServiceDefinition = {
    friendlyName: "Sprite Properties",
    consumes: [PropertiesServiceIdentity, SelectionServiceIdentity, SettingsContextIdentity],
    factory: (propertiesService, selectionService, settingsContent) => {
        const spriteManagerSectionContentRegistration = propertiesService.addSectionContent({
            key: "Sprite Manager Properties",
            predicate: (entity) => entity instanceof SpriteManager,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(SpriteManagerGeneralProperties, { spriteManager: context, selectionService: selectionService }),
                },
                {
                    section: "Actions",
                    component: ({ context }) => jsx(SpriteManagerActionsProperties, { spriteManager: context, selectionService: selectionService }),
                },
                {
                    section: "File",
                    component: ({ context }) => jsx(SpriteManagerFileProperties, { spriteManager: context, selectionService: selectionService }),
                },
                {
                    section: "Snippet",
                    component: ({ context }) => jsx(SpriteManagerSnippetProperties, { spriteManager: context, selectionService: selectionService }),
                },
                {
                    section: "Cells",
                    component: ({ context }) => jsx(SpriteManagerCellProperties, { spriteManager: context }),
                },
                {
                    section: "Other",
                    component: ({ context }) => jsx(SpriteManagerOtherProperties, { spriteManager: context }),
                },
            ],
        });
        const spriteSectionContentRegistration = propertiesService.addSectionContent({
            key: "Sprite Properties",
            predicate: (entity) => entity instanceof Sprite,
            content: [
                {
                    section: "General",
                    component: ({ context }) => jsx(SpriteGeneralProperties, { sprite: context, selectionService: selectionService }),
                },
                {
                    section: "Transform",
                    component: ({ context }) => jsx(SpriteTransformProperties, { sprite: context, settings: settingsContent }),
                },
                {
                    section: "Cell",
                    component: ({ context }) => jsx(SpriteCellProperties, { sprite: context }),
                },
                {
                    section: "Animation",
                    component: ({ context }) => jsx(SpriteAnimationProperties, { sprite: context }),
                },
                {
                    section: "Other",
                    component: ({ context }) => jsx(SpriteOtherProperties, { sprite: context }),
                },
            ],
        });
        return {
            dispose: () => {
                spriteManagerSectionContentRegistration.dispose();
                spriteSectionContentRegistration.dispose();
            },
        };
    },
};

/**
 * Creates a lazy component wrapper that only calls the async function to get the underlying component when the lazy component is actually mounted.
 * This allows deferring imports until they are needed. While the underlying component is being loaded, a spinner is displayed.
 * @param getComponentAsync A function that returns a promise resolving to the component.
 * @param defaultProps Options for the loading spinner.
 * @returns A React component that displays a spinner while loading the async component.
 */
function MakeLazyComponent(getComponentAsync, defaultProps) {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    const LazyComponent = lazy(async () => {
        const component = await getComponentAsync();
        return { default: component };
    });
    return forwardRef((props, ref) => {
        const { spinnerSize = defaultProps?.spinnerSize, spinnerLabel = defaultProps?.spinnerLabel, ...rest } = props;
        const componentProps = { ...rest, ref };
        return (jsx(Suspense, { fallback: jsx(Spinner, { ref: ref, size: spinnerSize, label: spinnerLabel }), children: jsx(LazyComponent, { ...componentProps }) }));
    });
}

const AdvancedDynamicTextureGeneralProperties = MakeLazyComponent(async () => {
    // Defer importing anything from the gui package until this component is actually mounted.
    const { AdvancedDynamicTextureInstrumentation } = await import('@babylonjs/gui/2D/adtInstrumentation.js');
    return (props) => {
        const { texture } = props;
        const instrumentation = useResource(useCallback(() => {
            const instrumentation = new AdvancedDynamicTextureInstrumentation(texture);
            instrumentation.captureRenderTime = true;
            instrumentation.captureLayoutTime = true;
            return instrumentation;
        }, [texture]));
        const layoutTime = useObservableState(useCallback(() => instrumentation.layoutTimeCounter.current, [instrumentation.layoutTimeCounter]), usePollingObservable(1000));
        const renderTime = useObservableState(useCallback(() => instrumentation.renderTimeCounter.current, [instrumentation.renderTimeCounter]), usePollingObservable(1000));
        return (jsxs(Fragment, { children: [jsx(StringifiedPropertyLine, { label: "Last Layout Time", value: layoutTime, precision: 2, units: "ms" }), jsx(StringifiedPropertyLine, { label: "Last Render Time", value: renderTime, precision: 2, units: "ms" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Render Scale", target: texture, propertyKey: "renderScale", min: 0.1, max: 5, step: 0.1 }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Premultiply Alpha", target: texture, propertyKey: "premulAlpha" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Ideal Width", target: texture, propertyKey: "idealWidth" }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "Ideal Height", target: texture, propertyKey: "idealHeight" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use Smallest Ideal", target: texture, propertyKey: "useSmallestIdeal" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Render at Ideal Size", target: texture, propertyKey: "renderAtIdealSize" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Invalidate Rect Optimization", target: texture, propertyKey: "useInvalidateRectOptimization" })] }));
    };
}, { spinnerSize: "extra-tiny", spinnerLabel: "Loading..." });
const AdvancedDynamicTexturePreviewProperties = (props) => {
    const { texture } = props;
    return (jsx(Fragment, { children: jsx(ButtonLine, { label: "Edit GUI", icon: EditRegular, onClick: async () => {
                const { GUIEditor } = await import('@babylonjs/gui-editor');
                await GUIEditor.Show({ liveGuiTexture: texture });
            } }) }));
};

const TextureFormat = [
    { label: "Alpha", normalizable: false, value: Constants.TEXTUREFORMAT_ALPHA },
    { label: "Luminance", normalizable: false, value: Constants.TEXTUREFORMAT_LUMINANCE },
    { label: "Luminance/Alpha", normalizable: false, value: Constants.TEXTUREFORMAT_LUMINANCE_ALPHA },
    { label: "RGB", normalizable: true, value: Constants.TEXTUREFORMAT_RGB },
    { label: "RGBA", normalizable: true, value: Constants.TEXTUREFORMAT_RGBA },
    { label: "R (red)", normalizable: true, value: Constants.TEXTUREFORMAT_RED },
    { label: "RG (red/green)", normalizable: true, value: Constants.TEXTUREFORMAT_RG },
    { label: "R (red) integer", normalizable: false, value: Constants.TEXTUREFORMAT_RED_INTEGER },
    { label: "RG (red/green) integer", normalizable: false, value: Constants.TEXTUREFORMAT_RG_INTEGER },
    { label: "RGB integer", normalizable: false, value: Constants.TEXTUREFORMAT_RGB_INTEGER },
    { label: "RGBA integer", normalizable: false, value: Constants.TEXTUREFORMAT_RGBA_INTEGER },
    { label: "BGRA", normalizable: true, value: Constants.TEXTUREFORMAT_BGRA },
    { label: "Depth24/Stencil8", normalizable: false, hideType: true, value: Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 },
    { label: "Depth32 float", normalizable: false, hideType: true, value: Constants.TEXTUREFORMAT_DEPTH32_FLOAT },
    { label: "Depth16", normalizable: false, value: Constants.TEXTUREFORMAT_DEPTH16 },
    { label: "Depth24", normalizable: false, value: Constants.TEXTUREFORMAT_DEPTH24 },
    { label: "Depth24Unorm/Stencil8", normalizable: false, hideType: true, value: Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 },
    { label: "Depth32Float/Stencil8", normalizable: false, hideType: true, value: Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8 },
    { label: "RGBA BPTC UNorm", normalizable: false, compressed: true, value: Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM },
    { label: "RGB BPTC UFloat", normalizable: false, compressed: true, value: Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT },
    { label: "RGB BPTC SFloat", normalizable: false, compressed: true, value: Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT },
    { label: "RGBA S3TC DXT5", normalizable: false, compressed: true, value: Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5 },
    { label: "RGBA S3TC DXT3", normalizable: false, compressed: true, value: Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3 },
    { label: "RGBA S3TC DXT1", normalizable: false, compressed: true, value: Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1 },
    { label: "RGB S3TC DXT1", normalizable: false, compressed: true, value: Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1 },
    { label: "RGBA ASTC 4x4", normalizable: false, compressed: true, value: Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4 },
];
function FindTextureFormat(format) {
    for (let i = 0; i < TextureFormat.length; ++i) {
        if (TextureFormat[i].value === format) {
            return TextureFormat[i];
        }
    }
    return null;
}
const TextureType = [
    { label: "unsigned byte", normalizable: true, value: Constants.TEXTURETYPE_UNSIGNED_BYTE },
    { label: "32-bit float", normalizable: false, value: Constants.TEXTURETYPE_FLOAT },
    { label: "16-bit float", normalizable: false, value: Constants.TEXTURETYPE_HALF_FLOAT },
    { label: "signed byte", normalizable: true, value: Constants.TEXTURETYPE_BYTE },
    { label: "signed short", normalizable: false, value: Constants.TEXTURETYPE_SHORT },
    { label: "unsigned short", normalizable: false, value: Constants.TEXTURETYPE_UNSIGNED_SHORT },
    { label: "signed int", normalizable: false, value: Constants.TEXTURETYPE_INT },
    { label: "unsigned int", normalizable: false, value: Constants.TEXTURETYPE_UNSIGNED_INTEGER },
    { label: "unsigned 4/4/4/4 short", normalizable: false, value: Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 },
    { label: "unsigned 5/5/5/1 short", normalizable: false, value: Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 },
    { label: "unsigned 5/6/5 short", normalizable: false, value: Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 },
    { label: "unsigned 2/10/10/10 int", normalizable: false, value: Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV },
    { label: "unsigned 24/8 int", normalizable: false, value: Constants.TEXTURETYPE_UNSIGNED_INT_24_8 },
    { label: "unsigned 10f/11f/11f int", normalizable: false, value: Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV },
    { label: "unsigned 5/9/9/9 int", normalizable: false, value: Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV },
    { label: "32-bits with only 8-bit used (stencil)", normalizable: false, value: Constants.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV },
];
function FindTextureType(type) {
    for (let i = 0; i < TextureType.length; ++i) {
        if (TextureType[i].value === type) {
            return TextureType[i];
        }
    }
    return null;
}

const BaseTexturePreviewProperties = (props) => {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    const { texture, textureEditor: TextureEditor } = props;
    const texturePreviewImperativeRef = useRef(null);
    const childWindow = useRef(null);
    return (jsxs(Fragment, { children: [jsx(TexturePreview, { imperativeRef: texturePreviewImperativeRef, texture: texture }), jsx(TextureUpload, { texture: texture }), jsx(ButtonLine, { label: "Edit Texture", onClick: () => childWindow.current?.open(), icon: EditRegular }), jsx(ChildWindow, { id: "Texture Editor", imperativeRef: childWindow, children: jsx(TextureEditor, { texture: texture, onUpdate: async () => await texturePreviewImperativeRef.current?.refresh() }) })] }));
};
const BaseTextureGeneralProperties = (props) => {
    const { texture } = props;
    const internalTexture = useProperty(texture, "_texture");
    const internalUniqueId = useProperty(internalTexture, "uniqueId");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: TextInputPropertyLine, label: "Display Name", target: texture, propertyKey: "displayName" }), internalUniqueId != null ? (jsx(StringifiedPropertyLine, { label: "Internal Unique ID", description: "The unique ID of the internal texture.", value: internalUniqueId })) : (jsx(BooleanBadgePropertyLine, { label: "Internal Unique ID", description: "This texture has no internal texture.", value: false }))] }));
};
const CoordinatesMode = [
    { label: "Explicit", value: Texture.EXPLICIT_MODE },
    { label: "Cubic", value: Texture.CUBIC_MODE },
    { label: "Inverse cubic", value: Texture.INVCUBIC_MODE },
    { label: "Equirectangular", value: Texture.EQUIRECTANGULAR_MODE },
    { label: "Fixed equirectangular", value: Texture.FIXED_EQUIRECTANGULAR_MODE },
    { label: "Fixed equirectangular mirrored", value: Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE },
    { label: "Planar", value: Texture.PLANAR_MODE },
    { label: "Projection", value: Texture.PROJECTION_MODE },
    { label: "Skybox", value: Texture.SKYBOX_MODE },
    { label: "Spherical", value: Texture.SPHERICAL_MODE },
];
const BaseTextureCharacteristicProperties = (props) => {
    const { texture } = props;
    const internalTexture = useProperty(texture, "_texture");
    const format = useProperty(internalTexture, "format") ?? NaN;
    const type = useProperty(internalTexture, "type") ?? NaN;
    const depth = useProperty(internalTexture, "depth");
    const useSRGBBuffer = useProperty(internalTexture, "_useSRGBBuffer");
    const samples = useProperty(internalTexture, "samples") ?? "?";
    const displayFormat = FindTextureFormat(format === -1 ? Constants.TEXTUREFORMAT_RGBA : format);
    const displayType = FindTextureType(type === -1 ? Constants.TEXTURETYPE_UNSIGNED_BYTE : type);
    const maxAnisotropy = texture.getScene()?.getEngine().getCaps().maxAnisotropy ?? 1;
    return (jsxs(Fragment, { children: [texture.is2DArray && jsx(TextPropertyLine, { label: "Layers", value: depth?.toString() ?? "?" }), texture.is3D && jsx(TextPropertyLine, { label: "Depth", value: depth?.toString() ?? "?" }), jsx(TextPropertyLine, { label: "Format", value: displayFormat?.label ?? "unknown" }), !displayFormat?.hideType && !displayFormat?.compressed && jsx(TextPropertyLine, { label: "Type", value: displayType?.label ?? "unknown" }), !!displayFormat?.normalizable && !displayFormat?.compressed && displayType?.normalizable != undefined && (jsx(BooleanBadgePropertyLine, { label: "Normalized", value: displayType.normalizable })), jsx(BooleanBadgePropertyLine, { label: "Compressed", value: displayFormat?.compressed ?? false }), jsx(BooleanBadgePropertyLine, { label: "sRGB Buffers", value: useSRGBBuffer ?? false }), jsx(BoundProperty, { component: BooleanBadgePropertyLine, label: "Gamma Space", target: texture, propertyKey: "gammaSpace" }), jsx(BoundProperty, { component: BooleanBadgePropertyLine, label: "Has Alpha", target: texture, propertyKey: "hasAlpha" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Alpha from RGB", target: texture, propertyKey: "getAlphaFromRGB" }), jsx(BooleanBadgePropertyLine, { label: "3D", value: texture.is3D }), jsx(BooleanBadgePropertyLine, { label: "2D Array", value: texture.is2DArray }), jsx(BooleanBadgePropertyLine, { label: "Cube", value: texture.isCube }), jsx(BooleanBadgePropertyLine, { label: "Render Target", value: texture.isRenderTarget }), jsx(BooleanBadgePropertyLine, { label: "Mipmaps", value: !texture.noMipmap }), jsx(TextPropertyLine, { label: "Samples", value: samples.toString() }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "UV Set", target: texture, propertyKey: "coordinatesIndex", min: 0, max: 3, step: 1 }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Mode", target: texture, propertyKey: "coordinatesMode", options: CoordinatesMode }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Level", target: texture, propertyKey: "level", min: 0, max: 2, step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Anisotropy", target: texture, propertyKey: "anisotropicFilteringLevel", min: 1, max: maxAnisotropy, step: 1 })] }));
};
const BaseTextureTransformProperties = (props) => {
    const { texture } = props;
    return (jsxs(Fragment, { children: [texture.canRescale && (jsx(ButtonLine, { label: "Scale Up", onClick: () => {
                    texture.scale(2);
                } })), texture.canRescale && (jsx(ButtonLine, { label: "Scale Down", onClick: () => {
                    texture.scale(0.5);
                } }))] }));
};

const CubeTextureTransformProperties = (props) => {
    const { texture, settings } = props;
    const [toDisplayAngle, fromDisplayAngle] = useAngleConverters(settings);
    return (jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Rotation Y", target: texture, propertyKey: "rotationY", min: 0, max: toDisplayAngle(Math.PI * 2), convertTo: (value) => toDisplayAngle(value, true), convertFrom: fromDisplayAngle }));
};

const MultiRenderTargetGeneralProperties = (props) => {
    const { texture } = props;
    return (jsx(Fragment, { children: jsx(BoundProperty, { component: StringifiedPropertyLine, label: "Count", description: "The number of render target textures.", target: texture, propertyKey: "count" }) }));
};

const RenderTargetTextureGeneralProperties = (props) => {
    const { texture } = props;
    const depthStencilTexture = useProperty(texture.renderTarget, "_depthStencilTexture");
    const depthStencilTextureDisplayFormat = depthStencilTexture ? FindTextureFormat(depthStencilTexture.format) : null;
    return (jsx(Fragment, { children: depthStencilTextureDisplayFormat ? (jsx(TextPropertyLine, { label: "Depth/Stencil Format", value: depthStencilTextureDisplayFormat.label })) : (jsx(BooleanBadgePropertyLine, { label: "Depth/Stencil Texture", value: false })) }));
};

const TexturePreviewProperties = (props) => {
    const { texture } = props;
    const rawUrl = useProperty(texture, "url");
    const displayUrl = !rawUrl || rawUrl.substring(0, 4) === "data" || rawUrl.substring(0, 4) === "blob" ? "" : rawUrl;
    return (jsx(Fragment, { children: jsx(TextInputPropertyLine, { label: "URL", value: displayUrl, onChange: (value) => {
                texture.updateURL(value);
            } }) }));
};
const TextureGeneralProperties = (props) => {
    const { texture } = props;
    return (jsx(Fragment, { children: jsx(BooleanBadgePropertyLine, { label: "Invert Y", description: "If true, the texture is stored as inverted on Y", value: texture.invertY }) }));
};
const TextureTransformProperties = (props) => {
    const { texture, settings } = props;
    const [toDisplayAngle, fromDisplayAngle] = useAngleConverters(settings);
    const wrapU = useProperty(texture, "wrapU");
    const wrapV = useProperty(texture, "wrapV");
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: NumberInputPropertyLine, label: "U offset", target: texture, propertyKey: "uOffset", step: 0.01 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "V offset", target: texture, propertyKey: "vOffset", step: 0.01 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "U scale", target: texture, propertyKey: "uScale", step: 0.01 }), jsx(BoundProperty, { component: NumberInputPropertyLine, label: "V scale", target: texture, propertyKey: "vScale", step: 0.01 }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "U angle", target: texture, propertyKey: "uAng", min: 0, max: toDisplayAngle(Math.PI * 2), convertTo: (value) => toDisplayAngle(value, true), convertFrom: fromDisplayAngle }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "V angle", target: texture, propertyKey: "vAng", min: 0, max: toDisplayAngle(Math.PI * 2), convertTo: (value) => toDisplayAngle(value, true), convertFrom: fromDisplayAngle }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "W angle", target: texture, propertyKey: "wAng", min: 0, max: toDisplayAngle(Math.PI * 2), convertTo: (value) => toDisplayAngle(value, true), convertFrom: fromDisplayAngle }), jsx(SwitchPropertyLine, { label: "Clamp U", value: wrapU === Constants.TEXTURE_CLAMP_ADDRESSMODE, onChange: (value) => (texture.wrapU = value ? Constants.TEXTURE_CLAMP_ADDRESSMODE : Constants.TEXTURE_WRAP_ADDRESSMODE) }), jsx(SwitchPropertyLine, { label: "Clamp V", value: wrapV === Constants.TEXTURE_CLAMP_ADDRESSMODE, onChange: (value) => (texture.wrapV = value ? Constants.TEXTURE_CLAMP_ADDRESSMODE : Constants.TEXTURE_WRAP_ADDRESSMODE) })] }));
};

const SamplingMode = [
    { label: "Nearest", value: Texture.NEAREST_NEAREST }, // 1
    { label: "Linear", value: Texture.LINEAR_LINEAR }, // 2
    { label: "Linear & linear mip", value: Texture.LINEAR_LINEAR_MIPLINEAR }, // 3
    { label: "Linear & nearest mip", value: Texture.LINEAR_LINEAR_MIPNEAREST }, // 11
    { label: "Nearest & linear mip", value: Texture.NEAREST_NEAREST_MIPLINEAR }, // 8
    { label: "Nearest & nearest mip", value: Texture.NEAREST_NEAREST_MIPNEAREST }, // 4
    { label: "Nearest/Linear", value: Texture.NEAREST_LINEAR }, // 7
    { label: "Nearest/Linear & linear mip", value: Texture.NEAREST_LINEAR_MIPLINEAR }, // 6
    { label: "Nearest/Linear & nearest mip", value: Texture.NEAREST_LINEAR_MIPNEAREST }, // 5
    { label: "Linear/Nearest", value: Texture.LINEAR_NEAREST }, // 12
    { label: "Linear/Nearest & linear mip", value: Texture.LINEAR_NEAREST_MIPLINEAR }, // 10
    { label: "Linear/Nearest & nearest mip", value: Texture.LINEAR_NEAREST_MIPNEAREST }, // 9
];
const ThinTextureGeneralProperties = (props) => {
    const { texture } = props;
    return (jsxs(Fragment, { children: [jsx(StringifiedPropertyLine, { label: "Width", value: texture.getSize().width, units: "px" }), jsx(StringifiedPropertyLine, { label: "Height", value: texture.getSize().height, units: "px" })] }));
};
const ThinTextureSamplingProperties = (props) => {
    const { texture } = props;
    const samplingMode = useObservableState(useCallback(() => texture.samplingMode, [texture]), useInterceptObservable("function", texture, "updateSamplingMode"));
    return (jsx(Property, { component: NumberDropdownPropertyLine, label: "Sampling", propertyPath: "samplingMode", value: samplingMode, options: SamplingMode, onChange: (value) => texture.updateSamplingMode(value) }));
};

// eslint-disable-next-line @typescript-eslint/naming-convention
const canvasShader = {
    path: {
        vertexSource: `
            precision highp float;

            attribute vec3 position;
            attribute vec2 uv;

            uniform mat4 worldViewProjection;

            varying vec2 vUV;

            void main(void) {
                gl_Position = worldViewProjection * vec4(position, 1.0);
                vUV = uv;
            }
        `,
        fragmentSource: `
            precision highp float;
    
            uniform sampler2D textureSampler;
    
            uniform bool r;
            uniform bool g;
            uniform bool b;
            uniform bool a;

            uniform int x1;
            uniform int y1;
            uniform int x2;
            uniform int y2;
            uniform int w;
            uniform int h;

            uniform int time;
            uniform bool showGrid;
    
            varying vec2 vUV;

            float scl = 200.0;
            float speed = 10.0 / 1000.0;
            float smoothing = 0.2;
    
            void main(void) {
                vec2 pos2 = vec2(gl_FragCoord.x, gl_FragCoord.y);
                vec2 pos = floor(pos2 * 0.05);
                float pattern = mod(pos.x + pos.y, 2.0); 
                if (pattern == 0.0) {
                    pattern = 0.7;
                }
                vec4 bg = vec4(pattern, pattern, pattern, 1.0);
                vec4 col = texture(textureSampler, vUV);
                if (!r && !g && !b) {
                    if (a) {
                        col = vec4(col.a, col.a, col.a, 1.0);
                    } else {
                        col = vec4(0.0,0.0,0.0,0.0);
                    }
                } else {
                    if (!r) {
                        col.r = 0.0;
                        if (!b) {
                            col.r = col.g;
                        }
                        else if (!g) {
                            col.r = col.b;
                        }
                    }
                    if (!g) {
                        col.g = 0.0;
                        if (!b) {
                            col.g = col.r;
                        }
                        else if (!r) {
                            col.g = col.b;
                        }
                    }
                    if (!b) {
                        col.b = 0.0;
                        if (!r) {
                            col.b = col.g;
                        } else if (!g) {
                            col.b = col.r;
                        }
                    }
                    if (!a) {
                        col.a = 1.0;
                    }
                }
                gl_FragColor = col * (col.a) + bg * (1.0 - col.a);
                float wF = float(w);
                float hF = float(h);
                int xPixel = int(floor(vUV.x * wF));
                int yPixel = int(floor((1.0 - vUV.y) * hF));
                int xDis = min(abs(xPixel - x1), abs(xPixel - x2));
                int yDis = min(abs(yPixel - y1), abs(yPixel - y2));
                if (showGrid) {
                    vec2 frac = fract(vUV * vec2(wF,hF));
                    float thickness = 0.1;
                    if (abs(frac.x) < thickness || abs (frac.y) < thickness) {
                        gl_FragColor = vec4(0.75,0.75,0.75,1.0);
                    }
                }
                if (xPixel >= x1 && yPixel >= y1 && xPixel <= x2 && yPixel <= y2) {
                    if (xDis <= 4 || yDis <= 4) {
                        float c = sin(vUV.x * scl + vUV.y * scl + float(time) * speed);
                        c = smoothstep(-smoothing,smoothing,c);
                        float val = 1.0 - c;
                        gl_FragColor = vec4(val, val, val, 1.0) * 0.7 + gl_FragColor * 0.3;
                    }
                }
            }`,
    },
    options: {
        attributes: ["position", "uv"],
        uniforms: ["worldViewProjection", "textureSampler", "r", "g", "b", "a", "x1", "y1", "x2", "y2", "w", "h", "time", "showGrid"],
    },
};

class TextureCanvasManager {
    constructor(texture, window, canvasUI, canvas2D, canvas3D, setPixelData, metadata, onUpdate, setMetadata, setMipLevel) {
        this._isPanning = false;
        this._mouseX = 0;
        this._mouseY = 0;
        this._size = { width: 0, height: 0 };
        this._channels = [];
        this._face = 0;
        this._mipLevel = 0;
        /** This is a hidden texture which is only responsible for holding the actual texture memory in the original engine */
        this._target = null;
        /** Keeps track of whether we have modified the texture */
        this._didEdit = false;
        this._plane = null;
        /** Tracks which keys are currently pressed */
        this._keyMap = new Map();
        /** Tracks which mouse buttons are currently pressed */
        this._buttonsPressed = 0;
        this.ZOOM_MOUSE_SPEED = 0.001;
        this.ZOOM_KEYBOARD_SPEED = 0.4;
        this.ZOOM_IN_KEY = "+";
        this.ZOOM_OUT_KEY = "-";
        this.PAN_SPEED = 0.003;
        this.PAN_KEY = "Space";
        this.MIN_SCALE = 0.01;
        this.GRID_SCALE = 0.047;
        this.MAX_SCALE = 10;
        this.SELECT_ALL_KEY = "KeyA";
        this.SAVE_KEY = "KeyS";
        this.RESET_KEY = "KeyR";
        this.DESELECT_KEY = "Escape";
        /** The number of milliseconds between texture updates */
        this.PUSH_FREQUENCY = 32;
        this._tool = null;
        this._editing3D = false;
        this._imageData = null;
        this._canPush = true;
        this._shouldPush = false;
        this._window = window;
        this._uiCanvas = canvasUI;
        this._2DCanvas = canvas2D;
        this._3DCanvas = canvas3D;
        this._paintCanvas = document.createElement("canvas");
        this._setPixelData = setPixelData;
        this._metadata = metadata;
        this._onUpdate = onUpdate;
        this._setMetadata = setMetadata;
        this._setMipLevel = setMipLevel;
        this._originalTexture = texture;
        this._originalTextureProperties = {
            _texture: this._originalTexture._texture,
            url: this._originalTexture.url,
            _forceSerialize: this._originalTexture._forceSerialize,
        };
        this._engine = new Engine(this._uiCanvas, true);
        this._scene = new Scene(this._engine, { virtual: true });
        this._scene.clearColor = new Color4(0, 0, 0, 0);
        this._camera = new FreeCamera("camera", new Vector3(0, 0, -1), this._scene);
        this._camera.mode = Camera.ORTHOGRAPHIC_CAMERA;
        this._camera.minZ = 0.5;
        this._camera.maxZ = 1.5;
        this._cameraPos = new Vector2();
        this.setSize(texture.getSize());
        this._channelsTexture = new HtmlElementTexture("ct", this._2DCanvas, {
            engine: this._engine,
            scene: null,
            samplingMode: Texture.NEAREST_SAMPLINGMODE,
            generateMipMaps: true,
        });
        this._3DEngine = new Engine(this._3DCanvas);
        this._3DScene = new Scene(this._3DEngine, { virtual: true });
        this._3DScene.clearColor = new Color4(0, 0, 0, 0);
        this._3DCanvasTexture = new HtmlElementTexture("canvas", this._2DCanvas, { engine: this._3DEngine, scene: this._3DScene });
        this._3DCanvasTexture.hasAlpha = true;
        const cam = new FreeCamera("camera", new Vector3(0, 0, -1), this._3DScene);
        cam.mode = Camera.ORTHOGRAPHIC_CAMERA;
        [cam.orthoBottom, cam.orthoLeft, cam.orthoTop, cam.orthoRight] = [-0.5, -0.5, 0.5, 0.5];
        this._3DPlane = CreatePlane("texture", { width: 1, height: 1 }, this._3DScene);
        this._3DPlane.hasVertexAlpha = true;
        const mat = new StandardMaterial("material", this._3DScene);
        mat.diffuseTexture = this._3DCanvasTexture;
        mat.useAlphaFromDiffuseTexture = true;
        mat.disableLighting = true;
        mat.emissiveColor = Color3.White();
        this._3DPlane.material = mat;
        this._planeMaterial = new ShaderMaterial("canvasShader", this._scene, canvasShader.path, canvasShader.options);
        this.grabOriginalTexture();
        this._planeMaterial.setTexture("textureSampler", this._channelsTexture);
        this._planeMaterial.setFloat("r", 1.0);
        this._planeMaterial.setFloat("g", 1.0);
        this._planeMaterial.setFloat("b", 1.0);
        this._planeMaterial.setFloat("a", 1.0);
        this._planeMaterial.setInt("x1", -1);
        this._planeMaterial.setInt("y1", -1);
        this._planeMaterial.setInt("x2", -1);
        this._planeMaterial.setInt("y2", -1);
        this._planeMaterial.setInt("w", this._size.width);
        this._planeMaterial.setInt("h", this._size.height);
        this._planeMaterial.setInt("time", 0);
        this._planeMaterial.setFloat("showGrid", 0.0);
        if (this._plane) {
            this._plane.material = this._planeMaterial;
        }
        this._window.addEventListener("keydown", (evt) => {
            this._keyMap.set(evt.code, true);
            if (evt.code === this.SELECT_ALL_KEY && evt.ctrlKey) {
                this._setMetadata({
                    select: {
                        x1: 0,
                        y1: 0,
                        x2: this._size.width,
                        y2: this._size.height,
                    },
                });
                evt.preventDefault();
            }
            if (evt.code === this.SAVE_KEY && evt.ctrlKey) {
                this.saveTexture();
                evt.preventDefault();
            }
            if (evt.code === this.RESET_KEY && evt.ctrlKey) {
                this.reset();
                evt.preventDefault();
            }
            if (evt.code === this.DESELECT_KEY) {
                this._setMetadata({
                    select: {
                        x1: -1,
                        y1: -1,
                        x2: -1,
                        y2: -1,
                    },
                });
            }
        });
        this._window.addEventListener("keyup", (evt) => {
            this._keyMap.set(evt.code, false);
        });
        this._engine.runRenderLoop(() => {
            this._engine.resize();
            this._scene.render();
            this._planeMaterial.setInt("time", new Date().getTime());
        });
        this._scale = 1.5 / Math.max(this._size.width, this._size.height);
        this._isPanning = false;
        this._scene.onBeforeRenderObservable.add(() => {
            this._scale = Math.min(Math.max(this._scale, this.MIN_SCALE / Math.log2(Math.min(this._size.width, this._size.height))), this.MAX_SCALE);
            if (this._scale > this.GRID_SCALE) {
                this._planeMaterial.setFloat("showGrid", 1.0);
            }
            else {
                this._planeMaterial.setFloat("showGrid", 0.0);
            }
            const ratio = this._uiCanvas?.width / this._uiCanvas?.height;
            const { x, y } = this._cameraPos;
            this._camera.orthoBottom = y - 1 / this._scale;
            this._camera.orthoTop = y + 1 / this._scale;
            this._camera.orthoLeft = x - ratio / this._scale;
            this._camera.orthoRight = x + ratio / this._scale;
        });
        this._scene.onPointerObservable.add((pointerInfo) => {
            const leftButtonPressed = pointerInfo.event.buttons & 1;
            const middleButtonPressed = pointerInfo.event.buttons & 4;
            if (!this._isPanning) {
                if ((leftButtonPressed && !(this._buttonsPressed & 1) && this._keyMap.get(this.PAN_KEY)) || middleButtonPressed) {
                    this._isPanning = true;
                    this._mouseX = pointerInfo.event.x;
                    this._mouseY = pointerInfo.event.y;
                }
                if (middleButtonPressed) {
                    this._isPanning = true;
                }
            }
            else if ((!leftButtonPressed || !this._keyMap.get(this.PAN_KEY)) && !middleButtonPressed) {
                this._isPanning = false;
            }
            switch (pointerInfo.type) {
                case PointerEventTypes.POINTERWHEEL: {
                    const event = pointerInfo.event;
                    this._scale -= event.deltaY * this.ZOOM_MOUSE_SPEED * this._scale;
                    break;
                }
                case PointerEventTypes.POINTERMOVE:
                    if (this._isPanning) {
                        this._cameraPos.x -= ((pointerInfo.event.x - this._mouseX) * this.PAN_SPEED) / this._scale;
                        this._cameraPos.y += ((pointerInfo.event.y - this._mouseY) * this.PAN_SPEED) / this._scale;
                        this._mouseX = pointerInfo.event.x;
                        this._mouseY = pointerInfo.event.y;
                    }
                    if (pointerInfo.pickInfo?.hit) {
                        if (this._imageData) {
                            const pos = this.getMouseCoordinates(pointerInfo);
                            const idx = (pos.x + pos.y * this._size.width) * 4;
                            this._setPixelData({
                                x: pos.x,
                                y: pos.y,
                                r: this._imageData[idx],
                                g: this._imageData[idx + 1],
                                b: this._imageData[idx + 2],
                                a: this._imageData[idx + 3],
                            });
                        }
                    }
                    else {
                        this._setPixelData({});
                    }
                    break;
            }
            this._buttonsPressed = pointerInfo.event.buttons;
        });
        this._scene.onKeyboardObservable.add((kbInfo) => {
            switch (kbInfo.type) {
                case KeyboardEventTypes.KEYDOWN:
                    this._keyMap.set(kbInfo.event.key, true);
                    switch (kbInfo.event.key) {
                        case this.ZOOM_IN_KEY:
                            this._scale += this.ZOOM_KEYBOARD_SPEED * this._scale;
                            break;
                        case this.ZOOM_OUT_KEY:
                            this._scale -= this.ZOOM_KEYBOARD_SPEED * this._scale;
                            break;
                    }
                    break;
                case KeyboardEventTypes.KEYUP:
                    this._keyMap.set(kbInfo.event.key, false);
                    break;
            }
        });
    }
    async updateTexture() {
        if (this._mipLevel !== 0) {
            this._setMipLevel(0);
        }
        this._didEdit = true;
        const element = this._editing3D ? this._3DCanvas : this._2DCanvas;
        if (this._editing3D) {
            this._3DCanvasTexture.update();
            this._3DScene.render();
        }
        if (this._originalTexture.isCube) ;
        else {
            if (!this._target) {
                this._target = new HtmlElementTexture("editor", element, {
                    engine: this._originalTexture.getScene()?.getEngine(),
                    scene: null,
                    samplingMode: this._originalTexture.samplingMode,
                    generateMipMaps: this._originalTextureProperties._texture?.generateMipMaps,
                });
            }
            else {
                this._target.element = element;
            }
            this.pushTexture();
        }
        this._originalTexture._texture = this._target?._texture ?? null;
        this._originalTexture.url = null;
        this._originalTexture._forceSerialize = true;
        this._channelsTexture.element = element;
        this.updateDisplay();
        this._onUpdate();
    }
    async pushTexture() {
        if (this._canPush && this._target) {
            const invertY = this._target.constructor.name === HtmlElementTexture.name ? false : this._originalTexture.invertY;
            this._target.update(invertY);
            this._target._texture?.updateSize(this._size.width, this._size.height);
            if (this._editing3D) {
                const bufferView = await this._3DEngine.readPixels(0, 0, this._size.width, this._size.height);
                this._imageData = new Uint8Array(bufferView.buffer, 0, bufferView.byteLength);
            }
            else {
                this._imageData = this._2DCanvas.getContext("2d").getImageData(0, 0, this._size.width, this._size.height).data;
            }
            this._canPush = false;
            this._shouldPush = false;
            setTimeout(() => {
                this._canPush = true;
                if (this._shouldPush) {
                    this.pushTexture();
                }
            }, this.PUSH_FREQUENCY);
        }
        else {
            this._shouldPush = true;
        }
    }
    async startPainting() {
        if (this._mipLevel != 0) {
            this._setMipLevel(0);
        }
        let x = 0, y = 0, w = this._size.width, h = this._size.height;
        if (this._metadata.select.x1 != -1) {
            x = this._metadata.select.x1;
            y = this._metadata.select.y1;
            w = this._metadata.select.x2 - this._metadata.select.x1;
            h = this._metadata.select.y2 - this._metadata.select.y1;
        }
        this._paintCanvas.width = w;
        this._paintCanvas.height = h;
        const ctx = this._paintCanvas.getContext("2d");
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(this._2DCanvas, x, y, w, h, 0, 0, w, h);
        return ctx;
    }
    updatePainting() {
        let x = 0, y = 0, w = this._size.width, h = this._size.height;
        if (this._metadata.select.x1 != -1) {
            x = this._metadata.select.x1;
            y = this._metadata.select.y1;
            w = this._metadata.select.x2 - this._metadata.select.x1;
            h = this._metadata.select.y2 - this._metadata.select.y1;
        }
        let editingAllChannels = true;
        for (const channel of this._channels) {
            if (!channel.editable) {
                editingAllChannels = false;
            }
        }
        let oldData;
        if (!editingAllChannels) {
            oldData = this._2DCanvas.getContext("2d").getImageData(x, y, w, h).data;
        }
        const ctx = this._paintCanvas.getContext("2d");
        const ctx2D = this.canvas2D.getContext("2d");
        ctx2D.globalAlpha = 1.0;
        ctx2D.globalCompositeOperation = "destination-out";
        ctx2D.fillStyle = "white";
        ctx2D.fillRect(x, y, w, h);
        ctx2D.imageSmoothingEnabled = false;
        // If we're not editing all channels, we must process the pixel data
        if (!editingAllChannels) {
            const newData = ctx.getImageData(0, 0, w, h);
            const nd = newData.data;
            for (let index = 0; index < this._channels.length; index++) {
                const channel = this._channels[index];
                if (!channel.editable) {
                    for (let i = index; i < w * h * 4; i += 4) {
                        nd[i] = oldData[i];
                    }
                }
            }
            ctx2D.globalCompositeOperation = "source-over";
            ctx2D.globalAlpha = 1.0;
            ctx2D.putImageData(newData, x, y);
        }
        else {
            ctx2D.globalCompositeOperation = "source-over";
            ctx2D.globalAlpha = 1.0;
            // We want to use drawImage wherever possible since it is much faster than putImageData
            ctx2D.drawImage(ctx.canvas, x, y);
        }
        this.updateTexture();
    }
    stopPainting() {
        this._paintCanvas.getContext("2d").clearRect(0, 0, this._paintCanvas.width, this._paintCanvas.height);
    }
    updateDisplay() {
        this._3DScene.render();
        this._channelsTexture.update(true);
    }
    set channels(channels) {
        // Determine if we need to re-render the texture. This is an expensive operation, so we should only do it if channel visibility has changed.
        let needsRender = false;
        if (channels.length !== this._channels.length) {
            needsRender = true;
        }
        else {
            for (let i = 0; i < channels.length; i++) {
                const channel = channels[i];
                if (channel.visible !== this._channels[i].visible) {
                    needsRender = true;
                    this._planeMaterial.setFloat(channel.id.toLowerCase(), channel.visible ? 1.0 : 0.0);
                }
            }
        }
        this._channels = channels;
        if (needsRender) {
            this.updateDisplay();
        }
    }
    paintPixelsOnCanvas(pixelData, canvas) {
        const ctx = canvas.getContext("2d");
        const imgData = ctx.createImageData(canvas.width, canvas.height);
        imgData.data.set(pixelData);
        ctx.putImageData(imgData, 0, 0);
    }
    async grabOriginalTexture() {
        // Grab image data from original texture and paint it onto the context of a DynamicTexture
        this.setSize(this._originalTexture.getSize());
        const data = await ApplyChannelsToTextureDataAsync(this._originalTexture, this._size.width, this._size.height, this._face, { R: true, G: true, B: true, A: true }, this._mipLevel);
        this._imageData = data;
        this.paintPixelsOnCanvas(data, this._2DCanvas);
        this._3DCanvasTexture.update();
        this.updateDisplay();
        return data;
    }
    getMouseCoordinates(pointerInfo) {
        if (pointerInfo.pickInfo?.hit) {
            const x = Math.floor(pointerInfo.pickInfo.getTextureCoordinates().x * this._size.width);
            const y = Math.floor((1 - pointerInfo.pickInfo.getTextureCoordinates().y) * this._size.height);
            return new Vector2(x, y);
        }
        else {
            return new Vector2();
        }
    }
    get scene() {
        return this._scene;
    }
    get canvas2D() {
        return this._2DCanvas;
    }
    get size() {
        return this._size;
    }
    set tool(tool) {
        if (this._tool) {
            this._tool.deactivate();
        }
        this._tool = tool;
        if (this._tool) {
            this._tool.activate();
            if (this._editing3D && !this._tool.is3D) {
                this._editing3D = false;
                this._2DCanvas.getContext("2d")?.drawImage(this._3DCanvas, 0, 0);
            }
            else if (!this._editing3D && this._tool.is3D) {
                this._editing3D = true;
                this.updateTexture();
            }
        }
    }
    get tool() {
        return this._tool;
    }
    set face(face) {
        if (this._face !== face) {
            this._face = face;
            this.grabOriginalTexture();
            this.updateDisplay();
        }
    }
    set mipLevel(mipLevel) {
        if (this._mipLevel === mipLevel) {
            return;
        }
        this._mipLevel = mipLevel;
        this.grabOriginalTexture();
    }
    /** Returns the 3D scene used for postprocesses */
    get scene3D() {
        return this._3DScene;
    }
    set metadata(metadata) {
        this._metadata = metadata;
        const { x1, y1, x2, y2 } = metadata.select;
        this._planeMaterial.setInt("x1", x1);
        this._planeMaterial.setInt("y1", y1);
        this._planeMaterial.setInt("x2", x2);
        this._planeMaterial.setInt("y2", y2);
    }
    makePlane() {
        if (this._plane) {
            this._plane.dispose();
        }
        this._plane = CreatePlane("plane", { width: this._size.width, height: this._size.height }, this._scene);
        this._plane.enableEdgesRendering();
        this._plane.edgesWidth = 4.0;
        this._plane.edgesColor = new Color4(1, 1, 1, 1);
        this._plane.enablePointerMoveEvents = true;
        this._plane.material = this._planeMaterial;
    }
    reset() {
        if (this._tool && this._tool.reset) {
            this._tool.reset();
        }
        this._originalTexture._texture = this._originalTextureProperties._texture;
        this._originalTexture.url = this._originalTextureProperties.url;
        this._originalTexture._forceSerialize = this._originalTextureProperties._forceSerialize;
        this.grabOriginalTexture();
        this.makePlane();
        this._didEdit = false;
        this._onUpdate();
    }
    async resize(newSize) {
        const data = await ApplyChannelsToTextureDataAsync(this._originalTexture, newSize.width, newSize.height, this._face, { R: true, G: true, B: true, A: true });
        this.setSize(newSize);
        this.paintPixelsOnCanvas(data, this._2DCanvas);
        this.updateTexture();
        this._didEdit = true;
    }
    setSize(size) {
        const oldSize = this._size;
        this._size = size;
        this._2DCanvas.width = this._size.width;
        this._2DCanvas.height = this._size.height;
        this._3DCanvas.width = this._size.width;
        this._3DCanvas.height = this._size.height;
        if (this._planeMaterial) {
            this._planeMaterial.setInt("w", this._size.width);
            this._planeMaterial.setInt("h", this._size.height);
        }
        if (!oldSize || oldSize.width != size.width || oldSize.height != size.height) {
            this._cameraPos.x = 0;
            this._cameraPos.y = 0;
            this._scale = 1.5 / Math.max(this._size.width, this._size.height);
        }
        this.makePlane();
    }
    upload(file) {
        Tools.ReadFile(file, (data) => {
            const blob = new Blob([data], { type: "octet/stream" });
            let extension = undefined;
            if (file.name.toLowerCase().indexOf(".dds") > 0) {
                extension = ".dds";
            }
            else if (file.name.toLowerCase().indexOf(".env") > 0) {
                extension = ".env";
            }
            const reader = new FileReader();
            reader.readAsDataURL(blob);
            reader.onloadend = () => {
                const base64data = reader.result;
                if (extension === ".dds" || extension === ".env") {
                    // eslint-disable-next-line @typescript-eslint/no-misused-promises
                    this._originalTexture.updateURL(base64data, extension, async () => await this.grabOriginalTexture());
                }
                else {
                    const texture = new Texture(base64data, this._scene, this._originalTexture.noMipmap, false, Texture.NEAREST_SAMPLINGMODE, () => {
                        // eslint-disable-next-line github/no-then
                        ApplyChannelsToTextureDataAsync(texture, texture.getSize().width, texture.getSize().height, 0, { R: true, G: true, B: true, A: true }).then(async (pixels) => {
                            if (this._tool && this._tool.reset) {
                                this._tool.reset();
                            }
                            texture.dispose();
                            this.setSize(texture.getSize());
                            this.paintPixelsOnCanvas(pixels, this._2DCanvas);
                            await this.updateTexture();
                            this._setMipLevel(0);
                        });
                    });
                }
            };
        }, undefined, true);
    }
    saveTexture() {
        const canvas = this._editing3D ? this._3DCanvas : this._2DCanvas;
        Tools.ToBlob(canvas, (blob) => {
            Tools.Download(blob, this._originalTexture.name);
        });
    }
    toolInteractionEnabled() {
        return !(this._keyMap.get(this.PAN_KEY) || this._isPanning);
    }
    dispose() {
        if (this._didEdit) {
            this._originalTextureProperties._texture?.dispose();
        }
        if (this._tool) {
            this._tool.deactivate();
        }
        this._paintCanvas.parentNode?.removeChild(this._paintCanvas);
        this._3DPlane.dispose();
        this._3DCanvasTexture.dispose();
        this._3DScene.dispose();
        this._3DEngine.dispose();
        this._plane?.dispose();
        this._channelsTexture.dispose();
        this._planeMaterial.dispose();
        this._camera.dispose();
        this._scene.dispose();
        this._engine.dispose();
    }
}

const useStyles$8 = makeStyles({
    channelsBar: {
        display: "flex",
        flexDirection: "column",
        backgroundColor: tokens.colorNeutralBackground1,
        padding: tokens.spacingVerticalXS,
        gap: tokens.spacingVerticalXS,
        borderRadius: tokens.borderRadiusMedium,
        boxShadow: tokens.shadow8,
    },
    channel: {
        display: "flex",
        alignItems: "center",
        gap: tokens.spacingHorizontalXS,
        padding: tokens.spacingVerticalXS,
        borderRadius: tokens.borderRadiusMedium,
    },
    channelLabel: {
        fontWeight: tokens.fontWeightSemibold,
        margin: `0 ${tokens.spacingHorizontalXS}`,
        textAlign: "center",
    },
    channelR: {
        color: tokens.colorPaletteRedBorderActive,
    },
    channelG: {
        color: tokens.colorPaletteGreenBorderActive,
    },
    channelB: {
        color: tokens.colorPaletteBlueBorderActive,
    },
    channelA: {
        color: tokens.colorNeutralForeground1,
    },
    uneditable: {
        opacity: 0.5,
    },
});
/**
 * Displays channel visibility and editability controls
 * @param props - The channels bar properties
 * @returns The channels bar component
 */
const ChannelsBar = (props) => {
    const { channels, setChannels } = props;
    const classes = useStyles$8();
    const toggleVisibility = useCallback((index) => {
        const newChannels = [...channels];
        newChannels[index] = { ...newChannels[index], visible: !newChannels[index].visible };
        setChannels(newChannels);
    }, [channels, setChannels]);
    const toggleEditable = useCallback((index) => {
        const newChannels = [...channels];
        newChannels[index] = { ...newChannels[index], editable: !newChannels[index].editable };
        setChannels(newChannels);
    }, [channels, setChannels]);
    const getChannelColorClass = (id) => {
        switch (id) {
            case "R":
                return classes.channelR;
            case "G":
                return classes.channelG;
            case "B":
                return classes.channelB;
            default:
                return classes.channelA;
        }
    };
    return (jsx("div", { className: classes.channelsBar, children: channels.map((channel, index) => {
            const visTip = channel.visible ? "Hide" : "Show";
            const editTip = channel.editable ? "Lock" : "Unlock";
            return (jsxs("div", { className: `${classes.channel} ${!channel.editable ? classes.uneditable : ""}`, children: [jsx(Tooltip$1, { content: `${visTip} ${channel.name}`, relationship: "label", positioning: "before", children: jsx(ToggleButton$1, { appearance: "transparent", size: "small", checked: channel.visible, icon: channel.visible ? jsx(EyeRegular, {}) : jsx(EyeOffRegular, {}), onClick: () => toggleVisibility(index) }) }), jsx(Tooltip$1, { content: `${editTip} ${channel.name}`, relationship: "label", positioning: "before", children: jsx(ToggleButton$1, { appearance: "transparent", size: "small", checked: channel.editable, icon: channel.editable ? jsx(LockOpenRegular, {}) : jsx(LockClosedRegular, {}), onClick: () => toggleEditable(index) }) }), jsx(Body1, { className: mergeClasses(classes.channelLabel, getChannelColorClass(channel.id)), children: channel.id })] }, channel.id));
        }) }));
};

const useStyles$7 = makeStyles({
    propertiesBar: {
        display: "flex",
        backgroundColor: tokens.colorNeutralBackground1,
        alignItems: "center",
        padding: `${tokens.spacingVerticalXS} ${tokens.spacingHorizontalS}`,
        gap: tokens.spacingHorizontalS,
        borderBottom: `1px solid ${tokens.colorNeutralStroke1}`,
        flexWrap: "wrap",
    },
    section: {
        display: "flex",
        alignItems: "center",
        gap: tokens.spacingHorizontalXS,
    },
    dimensionsForm: {
        display: "flex",
        alignItems: "center",
        gap: tokens.spacingHorizontalXS,
    },
    dimensionInput: {
        width: "60px",
    },
    pixelData: {
        display: "flex",
        alignItems: "center",
        gap: tokens.spacingHorizontalXS,
        fontSize: tokens.fontSizeBase200,
        fontFamily: tokens.fontFamilyMonospace,
    },
    pixelDataLabel: {
        color: tokens.colorNeutralForeground3,
    },
    pixelDataValue: {
        color: tokens.colorNeutralForeground1,
        minWidth: "32px",
    },
    faceButton: {
        minWidth: "auto",
        paddingLeft: tokens.spacingHorizontalS,
        paddingRight: tokens.spacingHorizontalS,
    },
    spacer: {
        flex: 1,
    },
    uploadInput: {
        display: "none",
    },
});
const PixelDataDisplay = ({ label, value }) => {
    const classes = useStyles$7();
    return (jsxs("span", { className: classes.pixelData, children: [jsxs(Label, { className: classes.pixelDataLabel, children: [label, ":"] }), jsx(Label, { className: classes.pixelDataValue, children: value !== undefined ? value : "-" })] }));
};
const CubeFaces = ["+X", "-X", "+Y", "-Y", "+Z", "-Z"];
/**
 * Properties bar component showing texture info and actions
 * @param props - The properties bar properties
 * @returns The properties bar component
 */
const PropertiesBar = (props) => {
    const { texture, size, saveTexture, pixelData, face, setFace, resetTexture, resizeTexture, uploadTexture, mipLevel, setMipLevel } = props;
    const classes = useStyles$7();
    const uploadInputRef = useRef(null);
    const [width, setWidth] = useState(size.width);
    const [height, setHeight] = useState(size.height);
    // Update local state when size prop changes
    useEffect(() => {
        setWidth(size.width);
        setHeight(size.height);
    }, [size.width, size.height]);
    const maxLevels = Math.floor(Math.log2(Math.max(texture.getSize().width, texture.getSize().height)));
    const engine = texture.getScene()?.getEngine();
    const mipsEnabled = !texture.noMipmap && engine?.getCaps().textureLOD;
    const handleUploadClick = useCallback(() => {
        uploadInputRef.current?.click();
    }, []);
    const handleFileChange = useCallback((evt) => {
        const files = evt.target.files;
        if (files && files.length) {
            uploadTexture(files[0]);
        }
        evt.target.value = "";
    }, [uploadTexture]);
    const handleResize = useCallback(() => {
        resizeTexture(width, height);
    }, [width, height, resizeTexture]);
    const getNewDimension = (oldDim, newDim) => {
        const parsed = parseInt(newDim);
        if (!isNaN(parsed) && parsed > 0 && Number.isInteger(parsed)) {
            return parsed;
        }
        return oldDim;
    };
    return (jsxs("div", { className: classes.propertiesBar, children: [jsxs("div", { className: classes.section, children: [jsx(Label, { children: "W:" }), jsx(Input, { className: classes.dimensionInput, size: "small", type: "text", value: width.toString(), readOnly: texture.isCube, onChange: (_, data) => setWidth(getNewDimension(width, data.value)) }), jsx(Label, { children: "H:" }), jsx(Input, { className: classes.dimensionInput, size: "small", type: "text", value: height.toString(), readOnly: texture.isCube, onChange: (_, data) => setHeight(getNewDimension(height, data.value)) }), !texture.isCube && (jsx(Tooltip$1, { content: "Resize", relationship: "label", children: jsx(ToolbarButton, { icon: jsx(ResizeRegular, {}), onClick: handleResize }) }))] }), jsx(ToolbarDivider, {}), jsxs("div", { className: classes.section, children: [jsx(PixelDataDisplay, { label: "X", value: pixelData.x }), jsx(PixelDataDisplay, { label: "Y", value: pixelData.y })] }), jsx(ToolbarDivider, {}), jsxs("div", { className: classes.section, children: [jsx(PixelDataDisplay, { label: "R", value: pixelData.r }), jsx(PixelDataDisplay, { label: "G", value: pixelData.g }), jsx(PixelDataDisplay, { label: "B", value: pixelData.b }), jsx(PixelDataDisplay, { label: "A", value: pixelData.a })] }), texture.isCube && (jsxs(Fragment, { children: [jsx(ToolbarDivider, {}), jsx(Toolbar$1, { size: "small", children: CubeFaces.map((label, index) => (jsx(ToolbarButton, { className: classes.faceButton, appearance: face === index ? "primary" : "subtle", onClick: () => setFace(index), children: label }, label))) })] })), mipsEnabled && (jsxs(Fragment, { children: [jsx(ToolbarDivider, {}), jsxs("div", { className: classes.section, children: [jsx(Label, { children: "MIP:" }), jsx(Tooltip$1, { content: "Mip Preview Up", relationship: "label", children: jsx(ToolbarButton, { icon: jsx(ChevronUpRegular, {}), disabled: mipLevel <= 0, onClick: () => setMipLevel(mipLevel - 1) }) }), jsx(Label, { children: mipLevel }), jsx(Tooltip$1, { content: "Mip Preview Down", relationship: "label", children: jsx(ToolbarButton, { icon: jsx(ChevronDownRegular, {}), disabled: mipLevel >= maxLevels, onClick: () => setMipLevel(mipLevel + 1) }) })] })] })), jsx("div", { className: classes.spacer }), jsxs(Toolbar$1, { size: "small", children: [jsx(Tooltip$1, { content: "Reset", relationship: "label", children: jsx(ToolbarButton, { icon: jsx(ArrowResetRegular, {}), onClick: resetTexture }) }), jsx(Tooltip$1, { content: "Upload", relationship: "label", children: jsx(ToolbarButton, { icon: jsx(ArrowUploadRegular, {}), onClick: handleUploadClick }) }), jsx("input", { ref: uploadInputRef, className: classes.uploadInput, type: "file", accept: ".jpg, .png, .tga, .dds, .env, .exr", onChange: handleFileChange }), jsx(Tooltip$1, { content: "Save", relationship: "label", children: jsx(ToolbarButton, { icon: jsx(SaveRegular, {}), onClick: saveTexture }) })] })] }));
};

const useStyles$6 = makeStyles({
    statusBar: {
        display: "flex",
        backgroundColor: tokens.colorNeutralBackground1,
        alignItems: "center",
        justifyContent: "space-between",
        padding: `${tokens.spacingVerticalXS} ${tokens.spacingHorizontalM}`,
        fontSize: tokens.fontSizeBase200,
        color: tokens.colorNeutralForeground2,
        borderTop: `1px solid ${tokens.colorNeutralStroke1}`,
        minHeight: "24px",
    },
    fileName: {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
    },
    mipInfo: {
        flexShrink: 0,
    },
});
/**
 * Displays status information about the texture
 * @param props - The status bar properties
 * @returns The status bar component
 */
const StatusBar = (props) => {
    const { texture, mipLevel } = props;
    const classes = useStyles$6();
    const factor = Math.pow(2, mipLevel);
    const width = Math.ceil(texture.getSize().width / factor);
    const height = Math.ceil(texture.getSize().height / factor);
    return (jsxs("div", { className: classes.statusBar, children: [jsx("span", { className: classes.fileName, children: texture.name }), !texture.noMipmap && (jsxs("span", { className: classes.mipInfo, children: ["MIP Preview: ", mipLevel, " (", width, "\u00D7", height, ")"] }))] }));
};

const useStyles$5 = makeStyles({
    toolbar: {
        display: "flex",
        flexDirection: "column",
        backgroundColor: tokens.colorNeutralBackground1,
        padding: tokens.spacingVerticalXS,
        gap: tokens.spacingVerticalXS,
        borderRadius: tokens.borderRadiusMedium,
        boxShadow: tokens.shadow8,
    },
    toolsSection: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalXXS,
    },
    toolButton: {
        minWidth: "36px",
        minHeight: "36px",
        padding: tokens.spacingVerticalXS,
    },
    toolIcon: {
        width: "24px",
        height: "24px",
    },
    colorSection: {
        display: "flex",
        justifyContent: "center",
        margin: tokens.spacingVerticalS,
    },
});
/**
 * Toolbar component for texture editing tools
 * @param props - The toolbar properties
 * @returns The toolbar component
 */
const ToolBar = (props) => {
    const { tools, changeTool, activeToolIndex, metadata, setMetadata, hasAlpha } = props;
    const classes = useStyles$5();
    const computeRGBAColor = useCallback(() => {
        const opacityInt = Math.floor(metadata.alpha * 255);
        const opacityHex = opacityInt.toString(16).padStart(2, "0");
        return Color4.FromHexString(`${metadata.color}${opacityHex}`);
    }, [metadata.color, metadata.alpha]);
    const handleColorChange = useCallback((color) => {
        const newMetadata = {
            color: color.toHexString(true),
            alpha: color.a ?? 1,
        };
        if (newMetadata.color !== metadata.color || newMetadata.alpha !== metadata.alpha) {
            setMetadata(newMetadata);
        }
    }, [metadata, setMetadata]);
    const handleToolClick = useCallback((index) => {
        if (activeToolIndex === index) {
            // Deselect current tool
            changeTool(-1);
        }
        else {
            changeTool(index);
        }
    }, [activeToolIndex, changeTool]);
    return (jsxs("div", { className: classes.toolbar, children: [jsx("div", { className: classes.colorSection, children: jsx(Tooltip$1, { relationship: "label", content: "Pick Tool Color", positioning: "after", children: jsx(ColorPickerPopup, { value: hasAlpha ? computeRGBAColor() : Color3.FromHexString(metadata.color), onChange: handleColorChange }) }) }), jsx(Divider, {}), jsx("div", { className: classes.toolsSection, children: tools.map((tool, index) => {
                    return (jsx(Tooltip$1, { content: tool.name, relationship: "label", positioning: "after", children: jsx(ToggleButton$1, { className: classes.toolButton, appearance: "subtle", checked: index === activeToolIndex, onClick: () => handleToolClick(index), icon: jsx(tool.icon, {}) }) }, index));
                }) })] }));
};

const useStyles$4 = makeStyles({
    textureEditor: {
        display: "flex",
        flexDirection: "column",
        height: "100%",
        width: "100%",
        backgroundColor: tokens.colorNeutralBackground3,
        color: tokens.colorNeutralForeground1,
        overflow: "hidden",
    },
    mainContent: {
        display: "flex",
        flex: 1,
        overflow: "hidden",
        position: "relative",
    },
    canvasContainer: {
        flex: 1,
        position: "relative",
        overflow: "hidden",
    },
    canvasUI: {
        width: "100%",
        height: "100%",
        outline: "none",
    },
    canvas2D: {
        display: "none",
    },
    canvas3D: {
        display: "none",
    },
    sidebarLeft: {
        display: "flex",
        flexDirection: "column",
        position: "absolute",
        left: tokens.spacingHorizontalM,
        top: tokens.spacingVerticalM,
    },
    sidebarRight: {
        display: "flex",
        flexDirection: "column",
        position: "absolute",
        right: tokens.spacingHorizontalM,
        top: tokens.spacingVerticalM,
    },
    toolSettingsContainer: {
        position: "absolute",
        left: tokens.spacingHorizontalM,
        bottom: tokens.spacingVerticalM,
        backgroundColor: tokens.colorNeutralBackground1,
        borderRadius: tokens.borderRadiusMedium,
        padding: tokens.spacingVerticalS,
        boxShadow: tokens.shadow8,
    },
});
const PREVIEW_UPDATE_DELAY_MS = 160;
/**
 * Main texture editor component
 * @param props - The texture editor properties
 * @returns The texture editor component
 */
const TextureEditor = (props) => {
    const { texture, toolProviders = [], window: editorWindow, onUpdate } = props;
    const classes = useStyles$4();
    // Canvas refs
    const uiCanvasRef = useRef(null);
    const canvas2DRef = useRef(null);
    const canvas3DRef = useRef(null);
    const timerRef = useRef(null);
    const canvasManagerRef = useRef(null);
    // State
    const [activeToolIndex, setActiveToolIndex] = useState(-1);
    const [metadata, setMetadataState] = useState({
        color: "#ffffff",
        alpha: 1,
        select: {
            x1: -1,
            y1: -1,
            x2: -1,
            y2: -1,
        },
    });
    const [channels, setChannels] = useState(() => {
        const baseChannels = [
            { name: "Red", visible: true, editable: true, id: "R" },
            { name: "Green", visible: true, editable: true, id: "G" },
            { name: "Blue", visible: true, editable: true, id: "B" },
        ];
        baseChannels.push({
            name: texture.isCube ? "Display" : "Alpha",
            visible: true,
            editable: true,
            id: "A",
        });
        return baseChannels;
    });
    const [pixelData, setPixelData] = useState({});
    const [face, setFace] = useState(0);
    const [mipLevel, setMipLevel] = useState(0);
    const [size, setSize] = useState(texture.getSize());
    // Callbacks
    const textureDidUpdate = useCallback(() => {
        if (timerRef.current != null) {
            window.clearTimeout(timerRef.current);
        }
        timerRef.current = window.setTimeout(() => {
            onUpdate?.();
            timerRef.current = null;
        }, PREVIEW_UPDATE_DELAY_MS);
    }, [onUpdate]);
    const setMetadata = useCallback((newMetadata) => {
        setMetadataState((prev) => {
            const data = { ...prev, ...newMetadata };
            if (canvasManagerRef.current) {
                canvasManagerRef.current.metadata = data;
            }
            return data;
        });
    }, []);
    const getToolParameters = () => {
        const manager = canvasManagerRef.current;
        return {
            scene: manager.scene,
            canvas2D: manager.canvas2D,
            scene3D: manager.scene3D,
            size: manager.size,
            updateTexture: () => void manager.updateTexture(),
            // eslint-disable-next-line @typescript-eslint/promise-function-async
            startPainting: () => manager.startPainting(),
            stopPainting: () => manager.stopPainting(),
            updatePainting: () => manager.updatePainting(),
            metadata,
            setMetadata,
            getMouseCoordinates: (pointerInfo) => manager.getMouseCoordinates(pointerInfo),
            interactionEnabled: () => manager.toolInteractionEnabled(),
        };
    };
    const getToolParametersRef = useRef(getToolParameters);
    getToolParametersRef.current = getToolParameters;
    const tools = useMemo(() => toolProviders?.map((provider) => provider.getTool({ getParameters: () => getToolParametersRef.current() })), [toolProviders]);
    const changeTool = useCallback((index) => {
        if (canvasManagerRef.current) {
            if (index !== -1 && tools[index]) {
                canvasManagerRef.current.tool = {
                    is3D: toolProviders[index].is3D ?? false,
                    activate: () => tools[index].activate(),
                    deactivate: () => tools[index].deactivate(),
                    reset: () => tools[index].reset?.(),
                };
            }
            else {
                canvasManagerRef.current.tool = null;
            }
        }
        setActiveToolIndex(index);
    }, [toolProviders, tools]);
    const saveTexture = useCallback(() => {
        canvasManagerRef.current?.saveTexture();
    }, []);
    const resetTexture = useCallback(() => {
        canvasManagerRef.current?.reset();
    }, []);
    const resizeTexture = useCallback((width, height) => {
        void canvasManagerRef.current?.resize({ width, height });
    }, []);
    const uploadTexture = useCallback((file) => {
        canvasManagerRef.current?.upload(file);
    }, []);
    // Initialize canvas manager
    useEffect(() => {
        if (!uiCanvasRef.current || !canvas2DRef.current || !canvas3DRef.current) {
            return;
        }
        const manager = new TextureCanvasManager(texture, editorWindow ?? uiCanvasRef.current.ownerDocument.defaultView ?? window, uiCanvasRef.current, canvas2DRef.current, canvas3DRef.current, setPixelData, metadata, textureDidUpdate, setMetadata, setMipLevel);
        canvasManagerRef.current = manager;
        setSize(manager.size);
        return () => {
            manager.dispose();
            canvasManagerRef.current = null;
        };
    }, [texture, editorWindow]);
    // Update canvas manager when channels/face/mipLevel change
    useEffect(() => {
        if (canvasManagerRef.current) {
            canvasManagerRef.current.channels = [...channels];
        }
    }, [channels]);
    useEffect(() => {
        if (canvasManagerRef.current) {
            canvasManagerRef.current.face = face;
        }
    }, [face]);
    useEffect(() => {
        if (canvasManagerRef.current) {
            canvasManagerRef.current.mipLevel = mipLevel;
        }
    }, [mipLevel]);
    // Compute cursor style
    let cursor = "default";
    if (canvasManagerRef.current && !canvasManagerRef.current.toolInteractionEnabled()) {
        cursor = "grab";
    }
    else if (toolProviders[activeToolIndex]?.cursor) {
        cursor = toolProviders[activeToolIndex].cursor;
    }
    const hasAlpha = texture.textureFormat === -1 || texture.textureFormat === Constants.TEXTUREFORMAT_RGBA;
    // eslint-disable-next-line @typescript-eslint/naming-convention
    const CurrentToolSettings = useMemo(() => tools[activeToolIndex]?.settingsComponent, [tools, activeToolIndex]);
    return (jsxs("div", { className: classes.textureEditor, children: [jsx(PropertiesBar, { texture: texture, saveTexture: saveTexture, pixelData: pixelData, face: face, setFace: setFace, resetTexture: resetTexture, resizeTexture: resizeTexture, uploadTexture: uploadTexture, mipLevel: mipLevel, setMipLevel: setMipLevel, size: canvasManagerRef.current?.size || size }), jsxs("div", { className: classes.mainContent, children: [jsxs("div", { className: classes.canvasContainer, style: { cursor }, children: [jsx("canvas", { ref: uiCanvasRef, className: classes.canvasUI, tabIndex: 1 }), jsx("canvas", { ref: canvas2DRef, className: classes.canvas2D }), jsx("canvas", { ref: canvas3DRef, className: classes.canvas3D })] }), CurrentToolSettings && (jsx("div", { className: classes.toolSettingsContainer, children: jsx(CurrentToolSettings, {}) })), !texture.isCube && (jsx("div", { className: classes.sidebarLeft, children: jsx(ToolBar, { tools: toolProviders, activeToolIndex: activeToolIndex, changeTool: changeTool, metadata: metadata, setMetadata: setMetadata, hasAlpha: hasAlpha }) })), jsx("div", { className: classes.sidebarRight, children: jsx(ChannelsBar, { channels: channels, setChannels: setChannels }) })] }), jsx(StatusBar, { texture: texture, mipLevel: mipLevel })] }));
};

const useStyles$3 = makeStyles({
    settingsContainer: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalS,
        minWidth: "150px",
    },
    sliderRow: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalXS,
    },
    icon: {
        rotate: "-90deg",
    },
});
const Contrast = {
    name: "Contrast/Exposure",
    order: 500,
    icon: () => {
        const classes = useStyles$3();
        return jsx(CircleHalfFillRegular, { className: classes.icon });
    },
    is3D: true,
    getTool: (context) => {
        let _contrast = 0;
        let _exposure = 0;
        const stateChangedObservable = new Observable();
        /**
         * Maps slider values to post processing values using an exponential regression
         * @param sliderValue - The slider value
         * @returns exposure value
         */
        function computeExposure(sliderValue) {
            if (sliderValue <= 0) {
                return 1 - -sliderValue / 100;
            }
            else {
                return Math.pow(1.05698, sliderValue) + 0.0000392163 * sliderValue;
            }
        }
        /**
         * Maps slider values to post processing values using an exponential regression
         * @param sliderValue - The slider value
         * @returns contrast value
         */
        function computeContrast(sliderValue) {
            if (sliderValue <= 0) {
                return 1 - -sliderValue / 100;
            }
            else {
                return Math.pow(1.05698, sliderValue) + 0.0000392163 * sliderValue;
            }
        }
        function setExposure(exposure) {
            _exposure = exposure;
            stateChangedObservable.notifyObservers();
            const { scene3D, updateTexture } = context.getParameters();
            scene3D.imageProcessingConfiguration.isEnabled = true;
            scene3D.imageProcessingConfiguration.exposure = computeExposure(_exposure);
            updateTexture();
        }
        function setContrast(contrast) {
            _contrast = contrast;
            stateChangedObservable.notifyObservers();
            const { scene3D, updateTexture } = context.getParameters();
            scene3D.imageProcessingConfiguration.isEnabled = true;
            scene3D.imageProcessingConfiguration.contrast = computeContrast(_contrast);
            updateTexture();
        }
        return {
            activate: () => {
                _contrast = 0;
                _exposure = 0;
                setExposure(_exposure);
                setContrast(_contrast);
            },
            deactivate: () => {
                // No cleanup needed
            },
            reset: () => {
                setExposure(0);
                setContrast(0);
            },
            settingsComponent: () => {
                const classes = useStyles$3();
                const [contrast, exposure] = useObservableState(useCallback(() => [_contrast, _exposure], []), stateChangedObservable);
                const handleContrastChange = (_, data) => {
                    setContrast(data.value);
                };
                const handleExposureChange = (_, data) => {
                    setExposure(data.value);
                };
                return (jsxs("div", { className: classes.settingsContainer, children: [jsxs("div", { className: classes.sliderRow, children: [jsxs(Label, { children: ["Contrast: ", contrast] }), jsx(Slider, { min: -100, max: 100, value: contrast, onChange: handleContrastChange })] }), jsxs("div", { className: classes.sliderRow, children: [jsxs(Label, { children: ["Exposure: ", exposure] }), jsx(Slider, { min: -100, max: 100, value: exposure, onChange: handleExposureChange })] })] }));
            },
        };
    },
};

/**
 * Eyedropper tool for picking colors from the texture
 */
const Eyedropper = {
    name: "Eyedropper",
    order: 300,
    icon: () => jsx(EyedropperRegular, {}),
    cursor: "crosshair",
    getTool: (context) => {
        let pointerObserver = null;
        let isPicking = false;
        function pick(pointerInfo) {
            const { canvas2D, setMetadata, getMouseCoordinates } = context.getParameters();
            const ctx = canvas2D.getContext("2d");
            const { x, y } = getMouseCoordinates(pointerInfo);
            const pixel = ctx.getImageData(x, y, 1, 1).data;
            setMetadata({
                color: Color3.FromInts(pixel[0], pixel[1], pixel[2]).toHexString(),
                alpha: pixel[3] / 255,
            });
        }
        return {
            activate: () => {
                pointerObserver = context.getParameters().scene.onPointerObservable.add((pointerInfo) => {
                    if (pointerInfo.pickInfo?.hit) {
                        if (pointerInfo.type === PointerEventTypes.POINTERDOWN && pointerInfo.event.buttons === 1 && context.getParameters().interactionEnabled()) {
                            isPicking = true;
                            pick(pointerInfo);
                        }
                        if (isPicking) {
                            if (pointerInfo.event.buttons !== 1 || !context.getParameters().interactionEnabled()) {
                                isPicking = false;
                            }
                            else {
                                pick(pointerInfo);
                            }
                        }
                    }
                });
                isPicking = false;
            },
            deactivate: () => {
                pointerObserver?.remove();
            },
        };
    },
};

/**
 * Floodfill tool for filling regions with a solid color
 */
const Floodfill = {
    name: "Floodfill",
    order: 400,
    icon: () => jsx(PaintBucketRegular, {}),
    cursor: "crosshair",
    getTool: (context) => {
        let pointerObserver = null;
        async function fillAsync() {
            const { metadata, startPainting, updatePainting, stopPainting } = context.getParameters();
            const ctx = await startPainting();
            ctx.fillStyle = metadata.color;
            ctx.globalAlpha = metadata.alpha;
            ctx.globalCompositeOperation = "copy";
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            updatePainting();
            stopPainting();
        }
        return {
            activate: () => {
                pointerObserver = context.getParameters().scene.onPointerObservable.add((pointerInfo) => {
                    if (pointerInfo.type === PointerEventTypes.POINTERDOWN &&
                        pointerInfo.event.buttons === 1 &&
                        context.getParameters().interactionEnabled() &&
                        pointerInfo.pickInfo?.hit) {
                        // eslint-disable-next-line @typescript-eslint/no-floating-promises
                        fillAsync();
                    }
                });
            },
            deactivate: () => {
                pointerObserver?.remove();
            },
        };
    },
};

const useStyles$2 = makeStyles({
    settingsContainer: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalS,
        minWidth: "150px",
    },
    sliderRow: {
        display: "flex",
        flexDirection: "column",
        gap: tokens.spacingVerticalXS,
    },
});
const Paintbrush = {
    name: "Paintbrush",
    order: 200,
    icon: () => jsx(InkStrokeRegular, {}),
    cursor: "crosshair",
    getTool: (context) => {
        let pointerObserver = null;
        let isPainting = false;
        let _width = 15;
        let mousePos = null;
        let ctx = null;
        let circleCanvas = null;
        const stateChangedObservable = new Observable();
        function setWidth(width) {
            _width = width;
            stateChangedObservable.notifyObservers();
        }
        function paint(pointerInfo) {
            if (ctx && circleCanvas) {
                const { getMouseCoordinates, metadata, updatePainting } = context.getParameters();
                let { x, y } = getMouseCoordinates(pointerInfo);
                if (metadata.select.x1 !== -1) {
                    x -= metadata.select.x1;
                    y -= metadata.select.y1;
                }
                let numSteps, stepVector;
                stepVector = new Vector2();
                if (mousePos === null) {
                    mousePos = new Vector2(x, y);
                    numSteps = 1;
                }
                else {
                    const maxDistance = _width / 4;
                    const diffVector = new Vector2(x - mousePos.x, y - mousePos.y);
                    numSteps = Math.ceil(diffVector.length() / maxDistance);
                    const trueDistance = diffVector.length() / numSteps;
                    stepVector = diffVector.normalize().multiplyByFloats(trueDistance, trueDistance);
                }
                const paintVector = mousePos.clone();
                for (let stepCount = 0; stepCount < numSteps; stepCount++) {
                    ctx.globalAlpha = 1.0;
                    ctx.globalCompositeOperation = "destination-out";
                    ctx.drawImage(circleCanvas, Math.ceil(paintVector.x - _width / 2), Math.ceil(paintVector.y - _width / 2));
                    ctx.globalAlpha = metadata.alpha;
                    ctx.globalCompositeOperation = "source-over";
                    ctx.drawImage(circleCanvas, Math.ceil(paintVector.x - _width / 2), Math.ceil(paintVector.y - _width / 2));
                    paintVector.addInPlace(stepVector);
                }
                updatePainting();
                mousePos = new Vector2(x, y);
            }
        }
        return {
            activate: () => {
                const { scene } = context.getParameters();
                pointerObserver = scene.onPointerObservable.add(async (pointerInfo) => {
                    const { startPainting, stopPainting, metadata } = context.getParameters();
                    if (!isPainting) {
                        if (pointerInfo.type === PointerEventTypes.POINTERDOWN &&
                            pointerInfo.event.buttons === 1 &&
                            context.getParameters().interactionEnabled() &&
                            pointerInfo.pickInfo?.hit) {
                            isPainting = true;
                            circleCanvas = document.createElement("canvas");
                            circleCanvas.width = _width;
                            circleCanvas.height = _width;
                            const circleCtx = circleCanvas.getContext("2d");
                            circleCtx.imageSmoothingEnabled = false;
                            const pixels = new Array(4 * _width * _width);
                            const dis = (_width * _width) / 4;
                            const rgb = Color3.FromHexString(metadata.color);
                            const r = Math.floor(rgb.r * 255);
                            const g = Math.floor(rgb.g * 255);
                            const b = Math.floor(rgb.b * 255);
                            let idx = 0;
                            const x1 = -Math.floor(_width / 2), x2 = Math.ceil(_width / 2);
                            const y1 = -Math.floor(_width / 2), y2 = Math.ceil(_width / 2);
                            for (let y = y1; y < y2; y++) {
                                for (let x = x1; x < x2; x++) {
                                    pixels[idx++] = r;
                                    pixels[idx++] = g;
                                    pixels[idx++] = b;
                                    pixels[idx++] = x * x + y * y <= dis ? 255 : 0;
                                }
                            }
                            circleCtx.putImageData(new ImageData(Uint8ClampedArray.from(pixels), _width, _width), 0, 0);
                            ctx = await startPainting();
                            paint(pointerInfo);
                        }
                    }
                    else {
                        if (pointerInfo.event.buttons !== 1 || !context.getParameters().interactionEnabled()) {
                            isPainting = false;
                            circleCanvas?.parentNode?.removeChild(circleCanvas);
                            stopPainting();
                            mousePos = null;
                        }
                        else {
                            if (pointerInfo.pickInfo?.hit && pointerInfo.type === PointerEventTypes.POINTERMOVE) {
                                paint(pointerInfo);
                            }
                        }
                    }
                });
                isPainting = false;
            },
            deactivate: () => {
                isPainting = false;
                pointerObserver?.remove();
            },
            settingsComponent: () => {
                const classes = useStyles$2();
                const width = useObservableState(useCallback(() => _width, []), stateChangedObservable);
                const handleWidthChange = (_, data) => {
                    setWidth(data.value);
                };
                return (jsx("div", { className: classes.settingsContainer, children: jsxs("div", { className: classes.sliderRow, children: [jsxs(Label, { children: ["Size: ", width] }), jsx(Slider, { min: 1, max: 100, value: width, onChange: handleWidthChange })] }) }));
            },
        };
    },
};

/**
 * Rectangle selection tool for selecting regions of the texture
 */
const RectangleSelect = {
    name: "Rectangle Select",
    order: 100,
    icon: () => jsx(SelectObjectRegular, {}),
    cursor: "crosshair",
    getTool: (context) => {
        let pointerObserver = null;
        let isSelecting = false;
        let xStart = -1;
        let yStart = -1;
        return {
            activate: () => {
                const { scene } = context.getParameters();
                pointerObserver = scene.onPointerObservable.add((pointerInfo) => {
                    const { getMouseCoordinates, setMetadata, metadata } = context.getParameters();
                    if (!isSelecting) {
                        if (pointerInfo.type === PointerEventTypes.POINTERDOWN &&
                            pointerInfo &&
                            pointerInfo.event.buttons === 1 &&
                            context.getParameters().interactionEnabled() &&
                            pointerInfo.pickInfo?.hit) {
                            isSelecting = true;
                            const { x, y } = ({ x: xStart, y: yStart } = getMouseCoordinates(pointerInfo));
                            setMetadata({
                                select: {
                                    x1: x,
                                    y1: y,
                                    x2: x,
                                    y2: y,
                                },
                            });
                        }
                    }
                    else {
                        if (pointerInfo.event.buttons !== 1 || !context.getParameters().interactionEnabled()) {
                            isSelecting = false;
                            if (metadata.select.x1 === metadata.select.x2 || metadata.select.y1 === metadata.select.y2) {
                                setMetadata({
                                    select: {
                                        x1: -1,
                                        y1: -1,
                                        x2: -1,
                                        y2: -1,
                                    },
                                });
                            }
                        }
                        else {
                            if (pointerInfo.pickInfo?.hit && pointerInfo.type === PointerEventTypes.POINTERMOVE) {
                                if (pointerInfo.type === PointerEventTypes.POINTERMOVE && isSelecting) {
                                    const { x, y } = getMouseCoordinates(pointerInfo);
                                    setMetadata({
                                        select: {
                                            x1: Math.min(x, xStart),
                                            y1: Math.min(y, yStart),
                                            x2: Math.max(x, xStart),
                                            y2: Math.max(y, yStart),
                                        },
                                    });
                                }
                            }
                        }
                    }
                });
            },
            deactivate() {
                isSelecting = false;
                pointerObserver?.remove();
            },
        };
    },
};

const TextureEditorServiceIdentity = Symbol("TextureEditorService");
const TextureEditorServiceDefinition = {
    friendlyName: "Texture Editor",
    produces: [TextureEditorServiceIdentity],
    factory: () => {
        const toolsCollection = new ObservableCollection();
        // Add the default tools.
        toolsCollection.add(RectangleSelect);
        toolsCollection.add(Paintbrush);
        toolsCollection.add(Eyedropper);
        toolsCollection.add(Floodfill);
        toolsCollection.add(Contrast);
        return {
            addTool: (toolProvider) => toolsCollection.add(toolProvider),
            component: (props) => {
                const tools = useOrderedObservableCollection(toolsCollection);
                return jsx(TextureEditor, { ...props, toolProviders: tools });
            },
        };
    },
};

// Don't use instanceof in this case as we don't want to bring in the gui package just to check if the entity is an AdvancedDynamicTexture.
function IsAdvancedDynamicTexture$1(entity) {
    return entity?.getClassName?.() === "AdvancedDynamicTexture";
}
const TexturePropertiesServiceDefinition = {
    friendlyName: "Texture Properties",
    consumes: [PropertiesServiceIdentity, SettingsContextIdentity, TextureEditorServiceIdentity],
    factory: (propertiesService, settingsContext, textureEditorService) => {
        const baseTextureContentRegistration = propertiesService.addSectionContent({
            key: "Base Texture Properties",
            predicate: (entity) => entity instanceof BaseTexture,
            content: [
                {
                    section: "Preview",
                    component: ({ context }) => jsx(BaseTexturePreviewProperties, { texture: context, textureEditor: textureEditorService.component }),
                },
                {
                    section: "General",
                    order: 0,
                    component: ({ context }) => jsx(BaseTextureGeneralProperties, { texture: context }),
                },
                {
                    section: "General",
                    order: 200,
                    component: ({ context }) => jsx(BaseTextureCharacteristicProperties, { texture: context }),
                },
                {
                    section: "Transform",
                    component: ({ context }) => jsx(BaseTextureTransformProperties, { texture: context }),
                },
            ],
        });
        const thinTextureContentRegistration = propertiesService.addSectionContent({
            key: "Thin Texture Properties",
            predicate: (entity) => entity instanceof ThinTexture,
            content: [
                {
                    section: "General",
                    order: 100,
                    component: ({ context }) => jsx(ThinTextureGeneralProperties, { texture: context }),
                },
                {
                    section: "General",
                    order: 200,
                    component: ({ context }) => jsx(ThinTextureSamplingProperties, { texture: context }),
                },
            ],
        });
        const textureContentRegistration = propertiesService.addSectionContent({
            key: "Texture Properties",
            predicate: (entity) => entity instanceof Texture,
            content: [
                {
                    section: "Preview",
                    component: ({ context }) => jsx(TexturePreviewProperties, { texture: context }),
                    order: 200,
                },
                {
                    section: "General",
                    order: 300,
                    component: ({ context }) => jsx(TextureGeneralProperties, { texture: context }),
                },
            ],
        });
        const textureExcludingCubeContentRegistration = propertiesService.addSectionContent({
            key: "Texture Transform Properties",
            predicate: (entity) => entity instanceof Texture && !entity.isCube,
            content: [
                {
                    section: "Transform",
                    component: ({ context }) => jsx(TextureTransformProperties, { texture: context, settings: settingsContext }),
                },
            ],
        });
        const cubeTextureContentRegistration = propertiesService.addSectionContent({
            key: "Cube Texture Properties",
            predicate: (entity) => entity instanceof CubeTexture,
            content: [
                {
                    section: "Transform",
                    component: ({ context }) => jsx(CubeTextureTransformProperties, { texture: context, settings: settingsContext }),
                },
            ],
        });
        const renderTargetTextureContentRegistration = propertiesService.addSectionContent({
            key: "Render Target Texture Properties",
            predicate: (entity) => entity instanceof RenderTargetTexture,
            content: [
                {
                    section: "Render Target",
                    component: ({ context }) => jsx(RenderTargetTextureGeneralProperties, { texture: context }),
                },
            ],
        });
        const multiRenderTargetContentRegistration = propertiesService.addSectionContent({
            key: "Multi Render Target Properties",
            predicate: (entity) => entity instanceof MultiRenderTarget,
            content: [
                {
                    section: "Render Target",
                    order: 100,
                    component: ({ context }) => jsx(MultiRenderTargetGeneralProperties, { texture: context }),
                },
            ],
        });
        const advancedDynamicTextureContentRegistration = propertiesService.addSectionContent({
            key: "Advanced Dynamic Texture Properties",
            predicate: (entity) => IsAdvancedDynamicTexture$1(entity),
            content: [
                {
                    section: "Advanced Dynamic Texture",
                    order: 100,
                    component: ({ context }) => jsx(AdvancedDynamicTextureGeneralProperties, { texture: context }),
                },
                {
                    section: "Preview",
                    order: 100,
                    component: ({ context }) => jsx(AdvancedDynamicTexturePreviewProperties, { texture: context }),
                },
            ],
        });
        return {
            dispose: () => {
                advancedDynamicTextureContentRegistration.dispose();
                multiRenderTargetContentRegistration.dispose();
                renderTargetTextureContentRegistration.dispose();
                cubeTextureContentRegistration.dispose();
                textureExcludingCubeContentRegistration.dispose();
                textureContentRegistration.dispose();
                baseTextureContentRegistration.dispose();
                thinTextureContentRegistration.dispose();
            },
        };
    },
};

const TransformProperties = (props) => {
    const { transform, settings } = props;
    const quatRotation = useQuaternionProperty(transform, "rotationQuaternion");
    const useDegrees = useObservableState(() => settings.useDegrees, settings.settingsChangedObservable);
    const useEuler = useObservableState(() => settings.useEuler, settings.settingsChangedObservable);
    return (jsxs(Fragment, { children: [jsx(BoundProperty, { component: Vector3PropertyLine, label: "Position", target: transform, propertyKey: "position" }), quatRotation ? (jsx(Property, { component: QuaternionPropertyLine, label: "Rotation (Quat)", propertyPath: "rotationQuaternion", value: quatRotation, onChange: (val) => (transform.rotationQuaternion = val), useDegrees: useDegrees, useEuler: useEuler })) : (jsx(BoundProperty, { component: RotationVectorPropertyLine, label: "Rotation", target: transform, propertyKey: "rotation", useDegrees: useDegrees })), jsx(BoundProperty, { component: Vector3PropertyLine, label: "Scaling", target: transform, propertyKey: "scaling" })] }));
};

const TransformPropertiesServiceDefinition = {
    friendlyName: "Transform Properties",
    consumes: [PropertiesServiceIdentity, SettingsContextIdentity],
    factory: (propertiesService, settingsContent) => {
        const contentRegistration = propertiesService.addSectionContent({
            key: "Transform Properties",
            // TransformNode and Bone don't share a common base class, but both have the same transform related properties.
            predicate: (entity) => entity instanceof TransformNode || entity instanceof Bone,
            content: [
                {
                    section: "Transform",
                    component: ({ context }) => jsx(TransformProperties, { transform: context, settings: settingsContent }),
                },
            ],
        });
        return {
            dispose: () => {
                contentRegistration.dispose();
            },
        };
    },
};

const AnimationGroupExplorerServiceDefinition = {
    friendlyName: "Animation Group Explorer",
    consumes: [SceneExplorerServiceIdentity, SceneContextIdentity],
    factory: (sceneExplorerService, sceneContext) => {
        const scene = sceneContext.currentScene;
        if (!scene) {
            return undefined;
        }
        const sectionRegistration = sceneExplorerService.addSection({
            displayName: "Animation Groups",
            order: 1000 /* DefaultSectionsOrder.AnimationGroups */,
            getRootEntities: () => scene.animationGroups,
            getEntityChildren: (entity) => (entity instanceof AnimationGroup ? entity.targetedAnimations : []),
            getEntityDisplayInfo: (entity) => {
                const namedEntity = entity instanceof AnimationGroup ? entity : entity.animation;
                const onChangeObservable = new Observable();
                const nameHookToken = InterceptProperty(namedEntity, "name", {
                    afterSet: () => {
                        onChangeObservable.notifyObservers();
                    },
                });
                return {
                    get name() {
                        return namedEntity.name;
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        nameHookToken.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
            entityIcon: ({ entity }) => (entity instanceof AnimationGroup ? jsx(StackRegular, {}) : jsx(FilmstripRegular, {})),
            getEntityAddedObservables: () => [scene.onNewAnimationGroupAddedObservable],
            getEntityRemovedObservables: () => [scene.onAnimationGroupRemovedObservable],
        });
        const animationPlayPauseCommandRegistration = sceneExplorerService.addEntityCommand({
            predicate: (entity) => entity instanceof AnimationGroup,
            order: 900 /* DefaultCommandsOrder.AnimationGroupPlay */,
            getCommand: (animationGroup) => {
                const onChangeObservable = new Observable();
                const playObserver = animationGroup.onAnimationGroupPlayObservable.add(() => onChangeObservable.notifyObservers());
                const pauseObserver = animationGroup.onAnimationGroupPauseObservable.add(() => onChangeObservable.notifyObservers());
                const endObserver = animationGroup.onAnimationGroupEndObservable.add(() => onChangeObservable.notifyObservers());
                return {
                    type: "toggle",
                    get displayName() {
                        return `${animationGroup.isPlaying ? "Pause" : "Play"} Animation`;
                    },
                    icon: () => (animationGroup.isPlaying ? jsx(PauseFilled, {}) : jsx(PlayFilled, {})),
                    get isEnabled() {
                        return animationGroup.isPlaying;
                    },
                    set isEnabled(enabled) {
                        if (enabled) {
                            animationGroup.play(true);
                        }
                        else {
                            animationGroup.pause();
                        }
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        playObserver.remove();
                        pauseObserver.remove();
                        endObserver.remove();
                        onChangeObservable.clear();
                    },
                };
            },
        });
        return {
            dispose: () => {
                sectionRegistration.dispose();
                animationPlayPauseCommandRegistration.dispose();
            },
        };
    },
};

const AtmosphereExplorerServiceDefinition = {
    friendlyName: "Atmosphere Explorer",
    consumes: [SceneExplorerServiceIdentity, SceneContextIdentity],
    factory: (sceneExplorerService, sceneContext) => {
        const scene = sceneContext.currentScene;
        if (!scene) {
            return undefined;
        }
        const sectionRegistration = sceneExplorerService.addSection({
            displayName: "Atmosphere",
            order: 1300 /* DefaultSectionsOrder.Atmosphere */,
            getRootEntities: () => (scene.getExternalData("atmosphere") ? [scene.getExternalData("atmosphere")] : []),
            getEntityDisplayInfo: (atmosphere) => {
                const onChangeObservable = new Observable();
                const nameHookToken = InterceptProperty(atmosphere, "name", {
                    afterSet: () => {
                        onChangeObservable.notifyObservers();
                    },
                });
                return {
                    get name() {
                        return atmosphere.name;
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        nameHookToken.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
            entityIcon: () => jsx(WeatherSunnyLowFilled, {}),
            // TODO in order for inspector UX to display atmosphere created after inspector is created
            getEntityAddedObservables: () => [],
            getEntityRemovedObservables: () => [],
        });
        return {
            dispose: () => {
                sectionRegistration.dispose();
            },
        };
    },
};

const EffectLayerExplorerServiceDefinition = {
    friendlyName: "Effect Layer Explorer",
    consumes: [SceneExplorerServiceIdentity, SceneContextIdentity],
    factory: (sceneExplorerService, sceneContext) => {
        const scene = sceneContext.currentScene;
        if (!scene) {
            return undefined;
        }
        const sectionRegistration = sceneExplorerService.addSection({
            displayName: "Effect Layers",
            order: 700 /* DefaultSectionsOrder.EffectLayers */,
            getRootEntities: () => scene.effectLayers,
            getEntityDisplayInfo: (effectLayer) => {
                const onChangeObservable = new Observable();
                const nameHookToken = InterceptProperty(effectLayer, "name", {
                    afterSet: () => {
                        onChangeObservable.notifyObservers();
                    },
                });
                return {
                    get name() {
                        return effectLayer.name;
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        nameHookToken.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
            entityIcon: () => jsx(LayerRegular, {}),
            getEntityAddedObservables: () => [scene.onNewEffectLayerAddedObservable],
            getEntityRemovedObservables: () => [scene.onEffectLayerRemovedObservable],
        });
        return {
            dispose: () => {
                sectionRegistration.dispose();
            },
        };
    },
};

const FrameGraphExplorerServiceDefinition = {
    friendlyName: "Frame Graph Explorer",
    consumes: [SceneExplorerServiceIdentity, SceneContextIdentity],
    factory: (sceneExplorerService, sceneContext) => {
        const scene = sceneContext.currentScene;
        if (!scene) {
            return undefined;
        }
        const sectionRegistration = sceneExplorerService.addSection({
            displayName: "Frame Graphs",
            order: 1200 /* DefaultSectionsOrder.FrameGraphs */,
            getRootEntities: () => scene.frameGraphs,
            getEntityDisplayInfo: (frameGraph) => {
                const onChangeObservable = new Observable();
                const nameHookToken = InterceptProperty(frameGraph, "name", {
                    afterSet: () => {
                        onChangeObservable.notifyObservers();
                    },
                });
                return {
                    get name() {
                        return frameGraph.name;
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        nameHookToken.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
            entityIcon: () => jsx(FrameRegular, {}),
            getEntityAddedObservables: () => [scene.onNewFrameGraphAddedObservable],
            getEntityRemovedObservables: () => [scene.onFrameGraphRemovedObservable],
        });
        const activeFrameGraphCommandRegistration = sceneExplorerService.addEntityCommand({
            predicate: (entity) => entity instanceof FrameGraph,
            order: 900 /* DefaultCommandsOrder.FrameGraphPlay */,
            getCommand: (frameGraph) => {
                const onChangeObservable = new Observable();
                const frameGraphHook = InterceptProperty(scene, "frameGraph", {
                    afterSet: () => onChangeObservable.notifyObservers(),
                });
                return {
                    type: "toggle",
                    displayName: "Make Active",
                    icon: () => (scene.frameGraph === frameGraph ? jsx(PlayFilled, {}) : jsx(PlayRegular, {})),
                    get isEnabled() {
                        return scene.frameGraph === frameGraph;
                    },
                    set isEnabled(enabled) {
                        if (enabled && scene.frameGraph !== frameGraph) {
                            scene.frameGraph = frameGraph;
                        }
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        frameGraphHook.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
        });
        return {
            dispose: () => {
                sectionRegistration.dispose();
                activeFrameGraphCommandRegistration.dispose();
            },
        };
    },
};

// Don't use instanceof in this case as we don't want to bring in the gui package just to check if the entity is an AdvancedDynamicTexture.
function IsAdvancedDynamicTexture(entity) {
    return entity?.getClassName?.() === "AdvancedDynamicTexture";
}
function IsContainer(entity) {
    // Check for Container-specific properties without using instanceof to avoid importing the concrete type
    return entity?.children !== undefined && entity?.onControlAddedObservable !== undefined;
}
function IsControl(entity) {
    // Check for Control-specific properties without using instanceof to avoid importing the concrete type
    return entity?._currentMeasure !== undefined && entity?.onPointerDownObservable !== undefined;
}
const GuiExplorerServiceDefinition = {
    friendlyName: "GUI Explorer",
    consumes: [SceneExplorerServiceIdentity, SceneContextIdentity],
    factory: (sceneExplorerService, sceneContext) => {
        const scene = sceneContext.currentScene;
        if (!scene) {
            return undefined;
        }
        const guiEntityAddedObservable = new Observable();
        const guiEntityRemovedObservable = new Observable();
        const textureAddedObserver = scene.onNewTextureAddedObservable.add((texture) => {
            if (IsAdvancedDynamicTexture(texture)) {
                guiEntityAddedObservable.notifyObservers(texture);
            }
        });
        const textureRemovedObserver = scene.onTextureRemovedObservable.add((texture) => {
            if (IsAdvancedDynamicTexture(texture)) {
                guiEntityRemovedObservable.notifyObservers(texture);
            }
        });
        const sectionRegistration = sceneExplorerService.addSection({
            displayName: "GUI",
            order: 1100 /* DefaultSectionsOrder.GUIs */,
            getRootEntities: () => scene.textures.filter(IsAdvancedDynamicTexture),
            getEntityChildren: (entity) => (IsAdvancedDynamicTexture(entity) ? entity.getChildren() : IsContainer(entity) ? entity.children : []),
            getEntityDisplayInfo: (entity) => {
                const disposeActions = [];
                const onChangeObservable = new Observable();
                disposeActions.push(() => onChangeObservable.clear());
                const nameHookToken = InterceptProperty(entity, "name", {
                    afterSet: () => {
                        onChangeObservable.notifyObservers();
                    },
                });
                disposeActions.push(() => nameHookToken.dispose());
                if (!IsAdvancedDynamicTexture(entity) && IsContainer(entity)) {
                    const controlAddedObserver = entity.onControlAddedObservable.add((control) => {
                        if (control) {
                            guiEntityAddedObservable.notifyObservers(control);
                        }
                    });
                    disposeActions.push(() => entity.onControlAddedObservable.remove(controlAddedObserver));
                    const controlRemovedObserver = entity.onControlRemovedObservable.add((control) => {
                        if (control) {
                            guiEntityRemovedObservable.notifyObservers(control);
                        }
                    });
                    disposeActions.push(() => entity.onControlRemovedObservable.remove(controlRemovedObserver));
                }
                return {
                    get name() {
                        if (IsAdvancedDynamicTexture(entity)) {
                            return entity.name;
                        }
                        else {
                            return `${entity.name ?? "No name"} [${entity.getClassName()}]`;
                        }
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        disposeActions.reverse().forEach((disposeAction) => disposeAction());
                    },
                };
            },
            entityIcon: ({ entity }) => (IsAdvancedDynamicTexture(entity) ? jsx(AppGenericRegular, {}) : jsx(RectangleLandscapeRegular, {})),
            getEntityAddedObservables: () => [guiEntityAddedObservable],
            getEntityRemovedObservables: () => [guiEntityRemovedObservable],
        });
        const highlightControlCommandRegistration = sceneExplorerService.addEntityCommand({
            predicate: (entity) => IsControl(entity),
            order: 1000 /* DefaultCommandsOrder.GuiHighlight */,
            getCommand: (control) => {
                const onChangeObservable = new Observable();
                const showBoundingBoxHook = InterceptProperty(control, "isHighlighted", {
                    afterSet: () => onChangeObservable.notifyObservers(),
                });
                return {
                    type: "toggle",
                    get displayName() {
                        return `${control.isHighlighted ? "Hide" : "Show"} Bounding Box`;
                    },
                    icon: () => (control.isHighlighted ? jsx(BorderOutsideRegular, {}) : jsx(BorderNoneRegular, {})),
                    get isEnabled() {
                        return control.isHighlighted;
                    },
                    set isEnabled(enabled) {
                        control.isHighlighted = enabled;
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        showBoundingBoxHook.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
        });
        const controlVisibilityCommandRegistration = sceneExplorerService.addEntityCommand({
            predicate: (entity) => IsControl(entity),
            order: 1100 /* DefaultCommandsOrder.GuiVisibility */,
            getCommand: (control) => {
                return {
                    type: "toggle",
                    get displayName() {
                        return `${control.isVisible ? "Hide" : "Show"} Mesh`;
                    },
                    icon: () => (control.isVisible ? jsx(EyeRegular, {}) : jsx(EyeOffRegular, {})),
                    get isEnabled() {
                        return !control.isVisible;
                    },
                    set isEnabled(enabled) {
                        control.isVisible = !enabled;
                    },
                    onChange: control.onIsVisibleChangedObservable,
                };
            },
        });
        return {
            dispose: () => {
                textureAddedObserver.remove();
                textureRemovedObserver.remove();
                sectionRegistration.dispose();
                highlightControlCommandRegistration.dispose();
                controlVisibilityCommandRegistration.dispose();
            },
        };
    },
};

const MaterialExplorerServiceDefinition = {
    friendlyName: "Material Explorer",
    consumes: [SceneExplorerServiceIdentity, SceneContextIdentity],
    factory: (sceneExplorerService, sceneContext) => {
        const scene = sceneContext.currentScene;
        if (!scene) {
            return undefined;
        }
        const sectionRegistration = sceneExplorerService.addSection({
            displayName: "Materials",
            order: 300 /* DefaultSectionsOrder.Materials */,
            getRootEntities: () => [...scene.materials, ...scene.multiMaterials],
            getEntityDisplayInfo: (material) => {
                const onChangeObservable = new Observable();
                const nameHookToken = InterceptProperty(material, "name", {
                    afterSet: () => {
                        onChangeObservable.notifyObservers();
                    },
                });
                return {
                    get name() {
                        return material.name;
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        nameHookToken.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
            entityIcon: () => jsx(MaterialIcon, {}),
            getEntityAddedObservables: () => [scene.onNewMaterialAddedObservable],
            getEntityRemovedObservables: () => [scene.onMaterialRemovedObservable],
        });
        return {
            dispose: () => {
                sectionRegistration.dispose();
            },
        };
    },
};

const NodeExplorerServiceDefinition = {
    friendlyName: "Node Explorer",
    consumes: [SceneExplorerServiceIdentity, SceneContextIdentity, GizmoServiceIdentity],
    factory: (sceneExplorerService, sceneContext, gizmoService) => {
        const scene = sceneContext.currentScene;
        if (!scene) {
            return undefined;
        }
        const nodeMovedObservable = new Observable();
        const sectionRegistration = sceneExplorerService.addSection({
            displayName: "Nodes",
            order: 100 /* DefaultSectionsOrder.Nodes */,
            getRootEntities: () => {
                const rootNodes = [...scene.rootNodes];
                // If any non-root node has a parent and that parent is not one of the node types shown in the Nodes section,
                // then we should treat it as a root node, otherwise it won't show up anywhere in scene explorer.
                // An example of this is when a Mesh or a TransformNode is parented under a Bone.
                for (const node of [...scene.meshes, ...scene.transformNodes, ...scene.cameras, ...scene.lights]) {
                    if (node.parent &&
                        !(node.parent instanceof AbstractMesh) &&
                        !(node.parent instanceof TransformNode) &&
                        !(node.parent instanceof Camera) &&
                        !(node.parent instanceof Light)) {
                        rootNodes.push(node);
                    }
                }
                // Lights within a clustered light container are not included in Scene.lights or Scene.rootNodes.
                // If they also have no parent, then they won't show up anywhere, so show them as root nodes.
                for (const light of scene.lights) {
                    if (light instanceof ClusteredLightContainer) {
                        for (const childLight of light.lights) {
                            if (!childLight.parent && !rootNodes.includes(childLight)) {
                                rootNodes.push(childLight);
                            }
                        }
                    }
                }
                return rootNodes;
            },
            getEntityChildren: (node) => node.getChildren(),
            getEntityDisplayInfo: (node) => {
                const onChangeObservable = new Observable();
                const nameHookToken = InterceptProperty(node, "name", {
                    afterSet: () => onChangeObservable.notifyObservers(),
                });
                const parentHookToken = InterceptProperty(node, "parent", {
                    afterSet: () => {
                        nodeMovedObservable.notifyObservers(node);
                    },
                });
                return {
                    get name() {
                        return node.name;
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        nameHookToken.dispose();
                        parentHookToken.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
            entityIcon: ({ entity: node }) => node instanceof AbstractMesh ? (jsx(MeshIcon, {})) : node instanceof TransformNode ? (jsx(MyLocationRegular, {})) : node instanceof Camera ? (jsx(CameraRegular, {})) : node instanceof Light ? (jsx(LightbulbRegular, {})) : (jsx(Fragment, {})),
            getEntityAddedObservables: () => [
                scene.onNewMeshAddedObservable,
                scene.onNewTransformNodeAddedObservable,
                scene.onNewCameraAddedObservable,
                scene.onNewLightAddedObservable,
            ],
            getEntityRemovedObservables: () => [
                scene.onMeshRemovedObservable,
                scene.onTransformNodeRemovedObservable,
                scene.onCameraRemovedObservable,
                scene.onLightRemovedObservable,
            ],
            getEntityMovedObservables: () => [nodeMovedObservable],
        });
        const abstractMeshBoundingBoxCommandRegistration = sceneExplorerService.addEntityCommand({
            predicate: (entity) => entity instanceof AbstractMesh && entity.getTotalVertices() > 0,
            order: 1000 /* DefaultCommandsOrder.MeshBoundingBox */,
            getCommand: (mesh) => {
                const onChangeObservable = new Observable();
                const showBoundingBoxHook = InterceptProperty(mesh, "showBoundingBox", {
                    afterSet: () => onChangeObservable.notifyObservers(),
                });
                return {
                    type: "toggle",
                    get displayName() {
                        return `${mesh.showBoundingBox ? "Hide" : "Show"} Bounding Box`;
                    },
                    icon: () => (mesh.showBoundingBox ? jsx(BorderOutsideRegular, {}) : jsx(BorderNoneRegular, {})),
                    get isEnabled() {
                        return mesh.showBoundingBox;
                    },
                    set isEnabled(enabled) {
                        mesh.showBoundingBox = enabled;
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        showBoundingBoxHook.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
        });
        const abstractMeshVisibilityCommandRegistration = sceneExplorerService.addEntityCommand({
            predicate: (entity) => entity instanceof AbstractMesh && entity.getTotalVertices() > 0,
            order: 1100 /* DefaultCommandsOrder.MeshVisibility */,
            getCommand: (mesh) => {
                const onChangeObservable = new Observable();
                const isVisibleHook = InterceptProperty(mesh, "isVisible", {
                    afterSet: () => onChangeObservable.notifyObservers(),
                });
                return {
                    type: "toggle",
                    get displayName() {
                        return `${mesh.isVisible ? "Hide" : "Show"} Mesh`;
                    },
                    icon: () => (mesh.isVisible ? jsx(EyeRegular, {}) : jsx(EyeOffRegular, {})),
                    get isEnabled() {
                        return !mesh.isVisible;
                    },
                    set isEnabled(enabled) {
                        mesh.isVisible = !enabled;
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        isVisibleHook.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
        });
        const activeCameraCommandRegistration = sceneExplorerService.addEntityCommand({
            predicate: (entity) => entity instanceof Camera,
            order: 700 /* DefaultCommandsOrder.CameraActive */,
            getCommand: (camera) => {
                const scene = camera.getScene();
                const onChangeObservable = new Observable();
                const activeCameraChangedObserver = scene.onActiveCameraChanged.add(() => {
                    onChangeObservable.notifyObservers();
                });
                return {
                    type: "toggle",
                    displayName: "Activate and Attach Controls",
                    icon: () => (scene.activeCamera === camera ? jsx(VideoFilled, {}) : jsx(VideoRegular, {})),
                    get isEnabled() {
                        return scene.activeCamera === camera;
                    },
                    set isEnabled(enabled) {
                        if (enabled && scene.activeCamera !== camera) {
                            scene.activeCamera?.detachControl();
                            scene.activeCamera = camera;
                            camera.attachControl(true);
                        }
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        activeCameraChangedObserver.remove();
                        onChangeObservable.clear();
                    },
                };
            },
        });
        function addGizmoCommand(nodeClass, getGizmoRef) {
            return sceneExplorerService.addEntityCommand({
                predicate: (entity) => entity instanceof nodeClass,
                order: 800 /* DefaultCommandsOrder.GizmoActive */,
                getCommand: (node) => {
                    const onChangeObservable = new Observable();
                    let gizmoRef = null;
                    return {
                        type: "toggle",
                        get displayName() {
                            return `Turn ${gizmoRef ? "Off" : "On"} Gizmo`;
                        },
                        icon: () => (gizmoRef ? jsx(EyeRegular, {}) : jsx(EyeOffRegular, {})),
                        get isEnabled() {
                            return !!gizmoRef;
                        },
                        set isEnabled(enabled) {
                            if (enabled) {
                                if (!gizmoRef) {
                                    gizmoRef = getGizmoRef(node);
                                    onChangeObservable.notifyObservers();
                                }
                            }
                            else {
                                if (gizmoRef) {
                                    gizmoRef.dispose();
                                    gizmoRef = null;
                                    onChangeObservable.notifyObservers();
                                }
                            }
                        },
                        onChange: onChangeObservable,
                        dispose: () => {
                            onChangeObservable.clear();
                        },
                    };
                },
            });
        }
        const cameraGizmoCommandRegistration = addGizmoCommand(Camera, gizmoService.getCameraGizmo.bind(gizmoService));
        const lightEnabledCommandRegistration = sceneExplorerService.addEntityCommand({
            predicate: (entity) => entity instanceof Light,
            order: 700 /* DefaultCommandsOrder.LightActive */,
            getCommand: (light) => {
                return {
                    type: "toggle",
                    get displayName() {
                        return `Turn Light ${light.isEnabled() ? "Off" : "On"}`;
                    },
                    icon: () => (light.isEnabled() ? jsx(FlashlightRegular, {}) : jsx(FlashlightOffRegular, {})),
                    get isEnabled() {
                        return !light.isEnabled();
                    },
                    set isEnabled(enabled) {
                        light.setEnabled(!enabled);
                    },
                    onChange: light.onEnabledStateChangedObservable,
                };
            },
        });
        const lightGizmoCommandRegistration = addGizmoCommand(Light, gizmoService.getLightGizmo.bind(gizmoService));
        return {
            dispose: () => {
                sectionRegistration.dispose();
                abstractMeshBoundingBoxCommandRegistration.dispose();
                abstractMeshVisibilityCommandRegistration.dispose();
                activeCameraCommandRegistration.dispose();
                cameraGizmoCommandRegistration.dispose();
                lightEnabledCommandRegistration.dispose();
                lightGizmoCommandRegistration.dispose();
            },
        };
    },
};

const ParticleSystemExplorerServiceDefinition = {
    friendlyName: "Particle System Explorer",
    consumes: [SceneExplorerServiceIdentity, SceneContextIdentity],
    factory: (sceneExplorerService, sceneContext) => {
        const scene = sceneContext.currentScene;
        if (!scene) {
            return undefined;
        }
        const sectionRegistration = sceneExplorerService.addSection({
            displayName: "Particle Systems",
            order: 800 /* DefaultSectionsOrder.ParticleSystems */,
            getRootEntities: () => scene.particleSystems,
            getEntityDisplayInfo: (particleSystem) => {
                const onChangeObservable = new Observable();
                const nameHookToken = InterceptProperty(particleSystem, "name", {
                    afterSet: () => {
                        onChangeObservable.notifyObservers();
                    },
                });
                return {
                    get name() {
                        return particleSystem.name;
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        nameHookToken.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
            entityIcon: () => jsx(DropRegular, {}),
            getEntityAddedObservables: () => [scene.onNewParticleSystemAddedObservable],
            getEntityRemovedObservables: () => [scene.onParticleSystemRemovedObservable],
        });
        return {
            dispose: () => {
                sectionRegistration.dispose();
            },
        };
    },
};

const PostProcessExplorerServiceDefinition = {
    friendlyName: "Post Process Explorer",
    consumes: [SceneExplorerServiceIdentity, SceneContextIdentity],
    factory: (sceneExplorerService, sceneContext) => {
        const scene = sceneContext.currentScene;
        if (!scene) {
            return undefined;
        }
        const sectionRegistration = sceneExplorerService.addSection({
            displayName: "Post Processes",
            order: 500 /* DefaultSectionsOrder.PostProcesses */,
            getRootEntities: () => scene.postProcesses,
            getEntityDisplayInfo: (postProcess) => {
                const onChangeObservable = new Observable();
                const nameHookToken = InterceptProperty(postProcess, "name", {
                    afterSet: () => {
                        onChangeObservable.notifyObservers();
                    },
                });
                return {
                    get name() {
                        return postProcess.name;
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        nameHookToken.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
            entityIcon: () => jsx(BlurRegular, {}),
            getEntityAddedObservables: () => [scene.onNewPostProcessAddedObservable],
            getEntityRemovedObservables: () => [scene.onPostProcessRemovedObservable],
        });
        return {
            dispose: () => {
                sectionRegistration.dispose();
            },
        };
    },
};

const RenderingPipelineExplorerServiceDefinition = {
    friendlyName: "Rendering Pipeline Explorer",
    consumes: [SceneExplorerServiceIdentity, SceneContextIdentity],
    factory: (sceneExplorerService, sceneContext) => {
        const scene = sceneContext.currentScene;
        if (!scene) {
            return undefined;
        }
        const sectionRegistration = sceneExplorerService.addSection({
            displayName: "Rendering Pipelines",
            order: 600 /* DefaultSectionsOrder.RenderingPipelines */,
            getRootEntities: () => scene.postProcessRenderPipelineManager.supportedPipelines ?? [],
            getEntityDisplayInfo: (pipeline) => {
                return {
                    get name() {
                        const typeName = pipeline.getClassName();
                        return `${pipeline.name} (${typeName})`;
                    },
                };
            },
            entityIcon: () => jsx(PipelineRegular, {}),
            getEntityAddedObservables: () => [scene.postProcessRenderPipelineManager.onNewPipelineAddedObservable],
            getEntityRemovedObservables: () => [scene.postProcessRenderPipelineManager.onPipelineRemovedObservable],
        });
        return {
            dispose: () => {
                sectionRegistration.dispose();
            },
        };
    },
};

const SkeletonExplorerServiceDefinition = {
    friendlyName: "Skeleton Explorer",
    consumes: [SceneExplorerServiceIdentity, SceneContextIdentity],
    factory: (sceneExplorerService, sceneContext) => {
        const scene = sceneContext.currentScene;
        if (!scene) {
            return undefined;
        }
        const boneMovedObservable = new Observable();
        const sectionRegistration = sceneExplorerService.addSection({
            displayName: "Skeletons",
            order: 200 /* DefaultSectionsOrder.Skeletons */,
            getRootEntities: () => scene.skeletons,
            getEntityChildren: (skeletonOrBone) => skeletonOrBone.getChildren(),
            getEntityDisplayInfo: (skeletonOrBone) => {
                const onChangeObservable = new Observable();
                const nameHookToken = InterceptProperty(skeletonOrBone, "name", {
                    afterSet: () => onChangeObservable.notifyObservers(),
                });
                const parentHookToken = skeletonOrBone instanceof Skeleton
                    ? null
                    : InterceptProperty(skeletonOrBone, "parent", {
                        afterSet: () => {
                            boneMovedObservable.notifyObservers(skeletonOrBone);
                        },
                    });
                return {
                    get name() {
                        return skeletonOrBone.name;
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        nameHookToken.dispose();
                        parentHookToken?.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
            entityIcon: ({ entity: skeletonOrBone }) => (skeletonOrBone instanceof Skeleton ? jsx(PersonWalkingRegular, {}) : jsx(DataLineRegular, {})),
            getEntityAddedObservables: () => [scene.onNewSkeletonAddedObservable],
            getEntityRemovedObservables: () => [scene.onSkeletonRemovedObservable],
            getEntityMovedObservables: () => [boneMovedObservable],
        });
        return {
            dispose: () => {
                sectionRegistration.dispose();
            },
        };
    },
};

const SoundExplorerServiceDefinition = {
    friendlyName: "Sound Explorer",
    consumes: [SceneExplorerServiceIdentity, SceneContextIdentity],
    factory: (sceneExplorerService, sceneContext) => {
        const scene = sceneContext.currentScene;
        if (!scene) {
            return undefined;
        }
        const soundAddedObservable = new Observable();
        const soundRemovedObservable = new Observable();
        const addSoundHook = InterceptFunction(scene.mainSoundTrack, "addSound", {
            afterCall: (sound) => soundAddedObservable.notifyObservers(sound),
        });
        const removeSoundHook = InterceptFunction(scene.mainSoundTrack, "removeSound", {
            afterCall: (sound) => soundRemovedObservable.notifyObservers(sound),
        });
        const sectionRegistration = sceneExplorerService.addSection({
            displayName: "Sounds",
            order: 1400 /* DefaultSectionsOrder.Sounds */,
            getRootEntities: () => scene.mainSoundTrack.soundCollection,
            getEntityDisplayInfo: (sound) => {
                const onChangeObservable = new Observable();
                const displayNameHookToken = InterceptProperty(sound, "name", {
                    afterSet: () => {
                        onChangeObservable.notifyObservers();
                    },
                });
                const nameHookToken = InterceptProperty(sound, "name", {
                    afterSet: () => {
                        onChangeObservable.notifyObservers();
                    },
                });
                return {
                    get name() {
                        return sound.name;
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        nameHookToken.dispose();
                        displayNameHookToken.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
            entityIcon: () => jsx(SoundWaveCircleRegular, {}),
            getEntityAddedObservables: () => [soundAddedObservable],
            getEntityRemovedObservables: () => [soundRemovedObservable],
        });
        return {
            dispose: () => {
                addSoundHook.dispose();
                removeSoundHook.dispose();
                soundAddedObservable.clear();
                soundRemovedObservable.clear();
                sectionRegistration.dispose();
            },
        };
    },
};

const SpriteManagerExplorerServiceDefinition = {
    friendlyName: "Sprite Manager Explorer",
    consumes: [SceneExplorerServiceIdentity, SceneContextIdentity],
    factory: (sceneExplorerService, sceneContext) => {
        const scene = sceneContext.currentScene;
        if (!scene) {
            return undefined;
        }
        const sectionRegistration = sceneExplorerService.addSection({
            displayName: "Sprite Managers",
            order: 900 /* DefaultSectionsOrder.SpriteManagers */,
            getRootEntities: () => scene.spriteManagers ?? [],
            getEntityChildren: (spriteEntity) => (spriteEntity instanceof Sprite ? [] : spriteEntity.sprites),
            getEntityDisplayInfo: (spriteEntity) => {
                const onChangeObservable = new Observable();
                const nameHookToken = InterceptProperty(spriteEntity, "name", {
                    afterSet: () => onChangeObservable.notifyObservers(),
                });
                return {
                    get name() {
                        return spriteEntity.name;
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        nameHookToken.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
            entityIcon: ({ entity: spriteEntity }) => (spriteEntity instanceof Sprite ? jsx(PersonSquareRegular, {}) : jsx(LayerDiagonalPersonRegular, {})),
            getEntityAddedObservables: () => [scene.onNewSpriteManagerAddedObservable],
            getEntityRemovedObservables: () => [scene.onSpriteManagerRemovedObservable],
        });
        const spritePlayStopCommandRegistration = sceneExplorerService.addEntityCommand({
            predicate: (entity) => entity instanceof Sprite,
            order: 600 /* DefaultCommandsOrder.SpritePlay */,
            getCommand: (sprite) => {
                const onChangeObservable = new Observable();
                const playHook = InterceptFunction(sprite, "playAnimation", {
                    afterCall: () => onChangeObservable.notifyObservers(),
                });
                const stopHook = InterceptFunction(sprite, "stopAnimation", {
                    afterCall: () => onChangeObservable.notifyObservers(),
                });
                const animateHook = InterceptFunction(sprite, "_animate", {
                    afterCall: () => onChangeObservable.notifyObservers(),
                });
                return {
                    type: "action",
                    get displayName() {
                        return `${sprite.animationStarted ? "Stop" : "Play"} Animation`;
                    },
                    icon: () => (sprite.animationStarted ? jsx(StopFilled, {}) : jsx(PlayFilled, {})),
                    execute: () => (sprite.animationStarted ? sprite.stopAnimation() : sprite.playAnimation(sprite.fromIndex, sprite.toIndex, sprite.loopAnimation, sprite.delay)),
                    onChange: onChangeObservable,
                    dispose: () => {
                        playHook.dispose();
                        stopHook.dispose();
                        animateHook.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
        });
        return {
            dispose: () => {
                sectionRegistration.dispose();
                spritePlayStopCommandRegistration.dispose();
            },
        };
    },
};

const TextureExplorerServiceDefinition = {
    friendlyName: "Texture Explorer",
    consumes: [SceneExplorerServiceIdentity, SceneContextIdentity],
    factory: (sceneExplorerService, sceneContext) => {
        const scene = sceneContext.currentScene;
        if (!scene) {
            return undefined;
        }
        const sectionRegistration = sceneExplorerService.addSection({
            displayName: "Textures",
            order: 400 /* DefaultSectionsOrder.Textures */,
            getRootEntities: () => scene.textures.filter((texture) => texture.getClassName() !== "AdvancedDynamicTexture"),
            getEntityDisplayInfo: (texture) => {
                const onChangeObservable = new Observable();
                const displayNameHookToken = InterceptProperty(texture, "displayName", {
                    afterSet: () => {
                        onChangeObservable.notifyObservers();
                    },
                });
                const nameHookToken = InterceptProperty(texture, "name", {
                    afterSet: () => {
                        onChangeObservable.notifyObservers();
                    },
                });
                return {
                    get name() {
                        return texture.displayName || texture.name || `${texture.getClassName() || "Unnamed Texture"} (${texture.uniqueId})`;
                    },
                    onChange: onChangeObservable,
                    dispose: () => {
                        nameHookToken.dispose();
                        displayNameHookToken.dispose();
                        onChangeObservable.clear();
                    },
                };
            },
            entityIcon: ({ entity: texture }) => (texture instanceof DynamicTexture ? jsx(ImageEditRegular, {}) : jsx(ImageRegular, {})),
            getEntityAddedObservables: () => [scene.onNewTextureAddedObservable],
            getEntityRemovedObservables: () => [scene.onTextureRemovedObservable],
        });
        return {
            dispose: () => {
                sectionRegistration.dispose();
            },
        };
    },
};

const EquirectangularCaptureTool = ({ scene }) => {
    const captureEquirectangularAsync = useCallback(async () => {
        const currentActiveCamera = scene.activeCamera;
        if (!currentActiveCamera && scene.frameGraph) {
            scene.activeCamera = FrameGraphUtils.FindMainCamera(scene.frameGraph);
        }
        if (scene.activeCamera) {
            await captureEquirectangularFromScene(scene, { size: 1024, filename: "equirectangular_capture.png" });
        }
        // eslint-disable-next-line require-atomic-updates
        scene.activeCamera = currentActiveCamera;
    }, [scene]);
    return jsx(ButtonLine, { label: "Capture Equirectangular", icon: CameraRegular, onClick: captureEquirectangularAsync });
};

const GIFCaptureTool = MakeLazyComponent(async () => {
    const gif = (await import('./gif-8Ty35Toc.js')).default;
    // TODO: Figure out how to grab this from NPM package instead of CDN
    const workerContent = await Tools.LoadFileAsync("https://cdn.jsdelivr.net/gh//terikon/gif.js.optimized@0.1.6/dist/gif.worker.js");
    const workerBlob = new Blob([workerContent], { type: "application/javascript" });
    const workerUrl = URL.createObjectURL(workerBlob);
    return ({ scene }) => {
        const [recordingSession, setRecordingSession] = useState({ state: "Idle" });
        const [targetWidth, setTargetWidth] = useState(512);
        const [frequency, setFrequency] = useState(200);
        useEffect(() => {
            return () => {
                if (recordingSession.state === "Recording") {
                    // Reset session resources if component is unmounted
                    scene.onAfterRenderObservable.remove(recordingSession.captureObserver);
                    scene.getEngine().setHardwareScalingLevel(recordingSession.previousHardwareScaling);
                }
            };
        }, [recordingSession, scene]);
        // Use functional setState to guard against multiple rapid clicks
        const startRecording = useCallback(() => {
            setRecordingSession((currentSession) => {
                // If already recording/rendering, don't start a new session
                if (currentSession.state !== "Idle") {
                    return currentSession;
                }
                const engine = scene.getEngine();
                const canvas = engine.getRenderingCanvas();
                if (!canvas) {
                    return currentSession;
                }
                const gifInstance = new gif({
                    workers: 2,
                    quality: 10,
                    workerScript: workerUrl,
                });
                // Adjust hardware scaling to match desired width
                const previousHardwareScaling = engine.getHardwareScalingLevel();
                engine.setHardwareScalingLevel(engine.getRenderWidth() / (targetWidth * globalThis.devicePixelRatio) || 1);
                // Capture frames after each render
                let lastCaptureTime = 0;
                const captureObserver = scene.onAfterRenderObservable.add(() => {
                    const now = Date.now();
                    if (now - lastCaptureTime >= frequency && gifInstance) {
                        lastCaptureTime = now;
                        gifInstance.addFrame(canvas, { delay: 1, copy: true });
                    }
                });
                return {
                    state: "Recording",
                    gif: gifInstance,
                    captureObserver: captureObserver,
                    previousHardwareScaling: previousHardwareScaling,
                };
            });
        }, [scene, targetWidth, frequency]);
        const stopRecording = useCallback(() => {
            setRecordingSession((currentSession) => {
                if (currentSession.state !== "Recording") {
                    return currentSession;
                }
                // Remove the frame capture observer
                scene.onAfterRenderObservable.remove(currentSession.captureObserver);
                // Restore previous hardware scaling
                scene.getEngine().setHardwareScalingLevel(currentSession.previousHardwareScaling);
                currentSession.gif.on("finished", (blob) => {
                    // Download the rendered GIF
                    Tools.Download(blob, "recording.gif");
                    // Reset state
                    setRecordingSession({ state: "Idle" });
                });
                // Start rendering the GIF
                currentSession.gif.render();
                return { state: "Rendering", gif: currentSession.gif };
            });
        }, [scene]);
        return (jsxs(Fragment, { children: [recordingSession.state === "Idle" && jsx(ButtonLine, { label: "Record GIF", icon: RecordRegular, onClick: startRecording }), recordingSession.state === "Recording" && jsx(ButtonLine, { label: "Stop", icon: RecordStopRegular, onClick: stopRecording }), recordingSession.state === "Rendering" && jsx(Label, { children: "Creating the GIF file..." }), jsxs(Collapse, { visible: recordingSession.state === "Idle", children: [jsx(SyncedSliderPropertyLine, { label: "Resolution", description: "The pixel width of the output. The height will be adjusted accordingly to maintain the aspect ratio.", value: targetWidth, onChange: (value) => setTargetWidth(Math.floor(value)), min: 128, max: 2048, step: 128 }), jsx(SyncedSliderPropertyLine, { label: "Frequency (ms)", description: "The time interval in milliseconds between each capture of the scene.", value: frequency, onChange: (value) => setFrequency(Math.floor(value)), min: 50, max: 1000, step: 50 })] })] }));
    };
}, { spinnerSize: "extra-tiny", spinnerLabel: "Loading..." });

const SceneReplayTool = ({ scene }) => {
    const [isRecording, setIsRecording] = useState(false);
    const sceneRecorder = useResource(() => new SceneRecorder());
    const startRecording = useCallback(() => {
        sceneRecorder.track(scene);
        setIsRecording(true);
    }, [scene]);
    const exportReplay = useCallback(() => {
        const content = JSON.stringify(sceneRecorder.getDelta());
        const blob = new Blob([content], { type: "application/json" });
        Tools.Download(blob, "replay_delta.json");
        setIsRecording(false);
    }, []);
    const applyDelta = useCallback((files) => {
        const file = files[0];
        if (!file) {
            return;
        }
        Tools.ReadFile(file, (data) => {
            try {
                const json = JSON.parse(data);
                SceneRecorder.ApplyDelta(json, scene);
            }
            catch (error) {
                Logger.Error("Failed to apply replay delta:" + error);
            }
        }, undefined, false);
    }, [scene]);
    return (jsxs(Fragment, { children: [!isRecording && jsx(ButtonLine, { label: "Start Recording", icon: RecordRegular, onClick: startRecording }), isRecording && (jsxs(Fragment, { children: [jsx(Label, { children: "Recording in progress..." }), jsx(ButtonLine, { label: "Generate Delta File", icon: SaveRegular, onClick: exportReplay })] })), jsx(FileUploadLine, { label: "Apply Delta File", icon: ArrowDownloadRegular, onClick: applyDelta, accept: ".json" })] }));
};

const ScreenshotTool = ({ scene }) => {
    const [precision, setPrecision] = useState(1);
    const [useCustomSize, setUseCustomSize] = useState(false);
    const [width, setWidth] = useState(512);
    const [height, setHeight] = useState(512);
    const captureScreenshot = useCallback(async () => {
        const engine = scene.getEngine();
        const camera = scene.frameGraph ? FrameGraphUtils.FindMainCamera(scene.frameGraph) : scene.activeCamera;
        const screenshotSize = useCustomSize ? { width, height, precision } : { precision };
        if (camera) {
            await CreateScreenshotUsingRenderTargetAsync(engine, camera, screenshotSize, "image/png", undefined, undefined, "screenshot.png");
        }
    }, [useCustomSize, precision, width, height, scene]);
    return (jsxs(Fragment, { children: [jsx(ButtonLine, { label: "Capture Screenshot", icon: CameraRegular, onClick: captureScreenshot }), jsx(SyncedSliderPropertyLine, { label: "Precision", description: "A multiplier allowing capture at a higher or lower resolution.", value: precision, onChange: setPrecision, min: 0.1, max: 10, step: 0.1 }), jsx(SwitchPropertyLine, { label: "Use Custom Size", value: useCustomSize, onChange: setUseCustomSize }), jsxs(Collapse, { visible: useCustomSize, children: [jsx(SyncedSliderPropertyLine, { label: "Width", description: "The width of the screenshot in pixels. ", value: width, onChange: setWidth, min: 1, step: 1 }), jsx(SyncedSliderPropertyLine, { label: "Height", description: "The height of the screenshot in pixels.", value: height, onChange: setHeight, min: 1, step: 1 })] })] }));
};

const VideoCaptureTool = ({ scene }) => {
    const [isRecording, setIsRecording] = useState(false);
    const videoRecorder = useResource(useCallback(() => {
        return new VideoRecorder(scene.getEngine());
    }, [scene.getEngine()]));
    const recordVideoAsync = useCallback(async () => {
        if (videoRecorder && videoRecorder.isRecording) {
            videoRecorder.stopRecording();
            setIsRecording(false);
            return;
        }
        void videoRecorder.startRecording(undefined, 0); // Use 0 to prevent automatic stop; let the user stop it
        setIsRecording(true);
    }, [scene]);
    return (jsx(Fragment, { children: jsx(ButtonLine, { label: isRecording ? "Stop Recording" : "Record Video", icon: isRecording ? RecordStopRegular : RecordRegular, onClick: recordVideoAsync }) }));
};

const CaptureToolsDefinition = {
    friendlyName: "Capture Tools",
    consumes: [ToolsServiceIdentity],
    factory: (toolsService) => {
        const contentRegistrations = [];
        // Screenshot
        contentRegistrations.push(toolsService.addSectionContent({
            key: "Screenshot",
            section: "Screenshot",
            order: 10,
            component: ({ context }) => jsx(ScreenshotTool, { scene: context }),
        }));
        // Equirectangular capture
        contentRegistrations.push(toolsService.addSectionContent({
            key: "Equirectangular",
            section: "Equirectangular",
            order: 15,
            component: ({ context }) => jsx(EquirectangularCaptureTool, { scene: context }),
        }));
        // Video recorder
        contentRegistrations.push(toolsService.addSectionContent({
            key: "Video",
            section: "Video",
            order: 20,
            component: ({ context }) => jsx(VideoCaptureTool, { scene: context }),
        }));
        // GIF recorder
        contentRegistrations.push(toolsService.addSectionContent({
            key: "GIF",
            section: "GIF",
            order: 25,
            component: ({ context }) => jsx(GIFCaptureTool, { scene: context }),
        }));
        // Scene replay
        contentRegistrations.push(toolsService.addSectionContent({
            key: "Scene Replay",
            section: "Scene Replay",
            order: 30,
            component: ({ context }) => jsx(SceneReplayTool, { scene: context }),
        }));
        return {
            dispose: () => {
                contentRegistrations.forEach((registration) => registration.dispose());
            },
        };
    },
};

const EnvExportImageTypes = [
    { label: "PNG", value: 0, imageType: "image/png" },
    { label: "WebP", value: 1, imageType: "image/webp" },
];
const ExportBabylonTools = ({ scene }) => {
    const [babylonExportOptions, setBabylonExportOptions] = useState({
        imageTypeIndex: 0,
        imageQuality: 0.8,
        iblDiffuse: false,
    });
    const exportBabylon = useCallback(async () => {
        const strScene = JSON.stringify(SceneSerializer.Serialize(scene));
        const blob = new Blob([strScene], { type: "octet/stream" });
        Tools.Download(blob, "scene.babylon");
    }, [scene]);
    const createEnvTexture = useCallback(async () => {
        if (!scene.environmentTexture) {
            return;
        }
        try {
            const buffer = await EnvironmentTextureTools.CreateEnvTextureAsync(scene.environmentTexture, {
                imageType: EnvExportImageTypes[babylonExportOptions.imageTypeIndex].imageType,
                imageQuality: babylonExportOptions.imageQuality,
                disableIrradianceTexture: !babylonExportOptions.iblDiffuse,
            });
            const blob = new Blob([buffer], { type: "octet/stream" });
            Tools.Download(blob, "environment.env");
        }
        catch (error) {
            Logger.Error(error);
            alert(error);
        }
    }, [scene, babylonExportOptions]);
    return (jsxs(Fragment, { children: [jsx(ButtonLine, { label: "Export to Babylon", icon: ArrowDownloadRegular, onClick: exportBabylon }), !scene.getEngine().premultipliedAlpha && scene.environmentTexture && scene.environmentTexture._prefiltered && scene.activeCamera && (jsxs(Fragment, { children: [jsx(ButtonLine, { label: "Generate .env texture", icon: ArrowDownloadRegular, onClick: createEnvTexture }), scene.environmentTexture.irradianceTexture && (jsx(SwitchPropertyLine, { label: "Diffuse Texture", description: "Export diffuse texture for IBL", value: babylonExportOptions.iblDiffuse, onChange: (value) => {
                            setBabylonExportOptions((prev) => ({ ...prev, iblDiffuse: value }));
                        } }, "iblDiffuse")), jsx(NumberDropdownPropertyLine, { label: "Image type", options: EnvExportImageTypes, value: babylonExportOptions.imageTypeIndex, onChange: (val) => {
                            setBabylonExportOptions((prev) => ({ ...prev, imageTypeIndex: val }));
                        } }), jsx(Collapse, { visible: babylonExportOptions.imageTypeIndex > 0, children: jsx(SyncedSliderPropertyLine, { label: "Quality", value: babylonExportOptions.imageQuality, onChange: (value) => setBabylonExportOptions((prev) => ({ ...prev, imageQuality: value })), min: 0, max: 1 }) })] }))] }));
};
const ExportGltfTools = MakeLazyComponent(async () => {
    // Defer importing anything from the serializers package until this component is actually mounted.
    const { GLTF2Export } = await import('@babylonjs/serializers/glTF/2.0/glTFSerializer.js');
    return (props) => {
        const [isExportingGltf, setIsExportingGltf] = useState(false);
        const [gltfExportOptions, setGltfExportOptions] = useState({
            exportDisabledNodes: false,
            exportSkyboxes: false,
            exportCameras: false,
            exportLights: false,
            dracoCompression: false,
        });
        const exportGLTF = useCallback(async () => {
            setIsExportingGltf(true);
            const shouldExport = (node) => {
                if (!gltfExportOptions.exportDisabledNodes) {
                    if (!node.isEnabled()) {
                        return false;
                    }
                }
                if (!gltfExportOptions.exportSkyboxes) {
                    if (node instanceof Mesh) {
                        if (node.material) {
                            const material = node.material;
                            const reflectionTexture = material.reflectionTexture;
                            if (reflectionTexture && reflectionTexture.coordinatesMode === Texture.SKYBOX_MODE) {
                                return false;
                            }
                        }
                    }
                }
                if (!gltfExportOptions.exportCameras) {
                    if (node instanceof Camera) {
                        return false;
                    }
                }
                if (!gltfExportOptions.exportLights) {
                    if (node instanceof Light) {
                        return false;
                    }
                }
                return true;
            };
            try {
                const glb = await GLTF2Export.GLBAsync(props.scene, "scene", {
                    meshCompressionMethod: gltfExportOptions.dracoCompression ? "Draco" : undefined,
                    shouldExportNode: (node) => shouldExport(node),
                });
                glb.downloadFiles();
            }
            catch (reason) {
                Logger.Error(`Failed to export GLB: ${reason}`);
            }
            finally {
                setIsExportingGltf(false);
            }
        }, [gltfExportOptions, props.scene]);
        return (jsxs(Fragment, { children: [jsx(ButtonLine, { label: "Export to GLB", icon: ArrowDownloadRegular, onClick: exportGLTF, disabled: isExportingGltf }), jsx(SwitchPropertyLine, { label: "Export Disabled Nodes", description: "Whether to export nodes that are disabled in the scene.", value: gltfExportOptions.exportDisabledNodes, onChange: (checked) => setGltfExportOptions({ ...gltfExportOptions, exportDisabledNodes: checked }) }, "GLTFExportDisabledNodes"), jsx(SwitchPropertyLine, { label: "Export Skyboxes", description: "Whether to export skybox nodes in the scene.", value: gltfExportOptions.exportSkyboxes, onChange: (checked) => setGltfExportOptions({ ...gltfExportOptions, exportSkyboxes: checked }) }, "GLTFExportSkyboxes"), jsx(SwitchPropertyLine, { label: "Export Cameras", description: "Whether to export cameras in the scene.", value: gltfExportOptions.exportCameras, onChange: (checked) => setGltfExportOptions({ ...gltfExportOptions, exportCameras: checked }) }, "GLTFExportCameras"), jsx(SwitchPropertyLine, { label: "Export Lights", description: "Whether to export lights in the scene.", value: gltfExportOptions.exportLights, onChange: (checked) => setGltfExportOptions({ ...gltfExportOptions, exportLights: checked }) }, "GLTFExportLights"), jsx(SwitchPropertyLine, { label: "Draco Compression", description: "Whether to apply Draco compression to geometry.", value: gltfExportOptions.dracoCompression, onChange: (checked) => setGltfExportOptions({ ...gltfExportOptions, dracoCompression: checked }) }, "GLTFDracoCompression")] }));
    };
});

const ExportServiceDefinition = {
    friendlyName: "Export Tools",
    consumes: [ToolsServiceIdentity],
    factory: (toolsService) => {
        const contentRegistrations = [];
        // glTF export content
        contentRegistrations.push(toolsService.addSectionContent({
            key: "GLTF Export",
            section: "GLTF Export",
            component: ({ context }) => jsx(ExportGltfTools, { scene: context }),
        }));
        // Babylon export content
        contentRegistrations.push(toolsService.addSectionContent({
            key: "Babylon Export",
            section: "Babylon Export",
            component: ({ context }) => jsx(ExportBabylonTools, { scene: context }),
        }));
        return {
            dispose: () => {
                contentRegistrations.forEach((registration) => registration.dispose());
            },
        };
    },
};

const AnimationGroupLoadingModes = [
    { label: "Clean", value: 0 /* SceneLoaderAnimationGroupLoadingMode.Clean */ },
    { label: "Stop", value: 1 /* SceneLoaderAnimationGroupLoadingMode.Stop */ },
    { label: "Sync", value: 2 /* SceneLoaderAnimationGroupLoadingMode.Sync */ },
    { label: "NoSync", value: 3 /* SceneLoaderAnimationGroupLoadingMode.NoSync */ },
];
const GLTFAnimationImportTool = ({ scene }) => {
    const [importDefaults, setImportDefaults] = useState({
        overwriteAnimations: true,
        animationGroupLoadingMode: 0 /* SceneLoaderAnimationGroupLoadingMode.Clean */,
    });
    const importAnimations = (event) => {
        const reloadAsync = async function (sceneFile) {
            if (sceneFile) {
                try {
                    await ImportAnimationsAsync(sceneFile, scene, {
                        overwriteAnimations: importDefaults.overwriteAnimations,
                        animationGroupLoadingMode: importDefaults.animationGroupLoadingMode,
                    });
                    if (scene.animationGroups.length > 0) {
                        const currentGroup = scene.animationGroups[0];
                        currentGroup.play(true);
                    }
                }
                catch (error) {
                    Logger.Error(`Error importing animations: ${error}`);
                }
            }
        };
        const filesInputAnimation = new FilesInput(scene.getEngine(), scene, null, null, null, null, null, reloadAsync, null);
        filesInputAnimation.loadFiles(event);
        filesInputAnimation.dispose();
    };
    return (jsxs(Fragment, { children: [jsx(FileUploadLine, { label: "Import Animations", accept: "gltf", onClick: (evt) => importAnimations(evt) }), jsx(SwitchPropertyLine, { label: "Overwrite Animations", value: importDefaults.overwriteAnimations, onChange: (value) => {
                    setImportDefaults({ ...importDefaults, overwriteAnimations: value });
                } }), jsx(Collapse, { visible: !importDefaults.overwriteAnimations, children: jsx(NumberDropdownPropertyLine, { label: "Animation Merge Mode", options: AnimationGroupLoadingModes, value: importDefaults.animationGroupLoadingMode, onChange: (value) => {
                        setImportDefaults({ ...importDefaults, animationGroupLoadingMode: value });
                    } }) })] }));
};

const GLTFAnimationImportServiceDefinition = {
    friendlyName: "GLTF Animation Import",
    consumes: [ToolsServiceIdentity],
    factory: (toolsService) => {
        const contentRegistration = toolsService.addSectionContent({
            key: "AnimationImport",
            order: 40,
            section: "GLTF Animation Import",
            component: ({ context }) => jsx(GLTFAnimationImportTool, { scene: context }),
        });
        return {
            dispose: () => {
                contentRegistration.dispose();
            },
        };
    },
};

const AnimationStartModeOptions = [
    { label: "None", value: GLTFLoaderAnimationStartMode.NONE },
    { label: "First", value: GLTFLoaderAnimationStartMode.FIRST },
    { label: "All", value: GLTFLoaderAnimationStartMode.ALL },
];
const CoordinateSystemModeOptions = [
    { label: "Auto", value: GLTFLoaderCoordinateSystemMode.AUTO },
    { label: "Right Handed", value: GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED },
];
const GLTFLoaderOptionsTool = ({ loaderOptions }) => {
    return (jsx(PropertyLine, { label: "Loader Options", expandByDefault: false, expandedContent: jsxs(Fragment, { children: [jsx(BoundProperty, { component: SwitchPropertyLine, label: "Always compute bounding box", target: loaderOptions, propertyKey: "alwaysComputeBoundingBox" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Always compute skeleton root node", target: loaderOptions, propertyKey: "alwaysComputeSkeletonRootNode" }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Animation start mode", options: AnimationStartModeOptions, target: loaderOptions, propertyKey: "animationStartMode" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Capture performance counters", target: loaderOptions, propertyKey: "capturePerformanceCounters" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Compile materials", target: loaderOptions, propertyKey: "compileMaterials" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Compile shadow generators", target: loaderOptions, propertyKey: "compileShadowGenerators" }), jsx(BoundProperty, { component: NumberDropdownPropertyLine, label: "Coordinate system", options: CoordinateSystemModeOptions, target: loaderOptions, propertyKey: "coordinateSystemMode" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Create instances", target: loaderOptions, propertyKey: "createInstances" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Enable logging", target: loaderOptions, propertyKey: "loggingEnabled" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Load all materials", target: loaderOptions, propertyKey: "loadAllMaterials" }), jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Target FPS", target: loaderOptions, propertyKey: "targetFps", min: 1, max: 120, step: 1 }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Transparency as coverage", target: loaderOptions, propertyKey: "transparencyAsCoverage" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use clip plane", target: loaderOptions, propertyKey: "useClipPlane" }), jsx(BoundProperty, { component: SwitchPropertyLine, label: "Use sRGB buffers", target: loaderOptions, propertyKey: "useSRGBBuffers" })] }) }));
};
const GLTFExtensionOptionsTool = ({ extensionOptions }) => {
    return (jsx(PropertyLine, { label: "Extension Options", expandByDefault: false, expandedContent: jsx(Fragment, { children: Object.entries(extensionOptions).map(([extensionName, options]) => {
                return (jsx(BoundProperty, { component: SwitchPropertyLine, label: extensionName, target: options, propertyKey: "enabled", expandedContent: (extensionName === "MSFT_lod" && (jsx(BoundProperty, { component: SyncedSliderPropertyLine, label: "Maximum LODs", target: extensionOptions[extensionName], propertyKey: "maxLODsToLoad", min: 1, max: 10, step: 1 }, extensionName + "_maxLODsToLoad"))) ||
                        undefined }, extensionName));
            }) }) }));
};

// Options exposed in Inspector includes all the properties from the default loader options (GLTFLoaderDefaultOptions)
// plus some options that only exist directly on the GLTFFileLoader class itself.
const CurrentLoaderOptions = Object.assign({
    capturePerformanceCounters: false,
    loggingEnabled: false,
}, GLTFLoaderDefaultOptions);
const CurrentExtensionOptions = {
    /* eslint-disable @typescript-eslint/naming-convention */
    EXT_lights_image_based: { enabled: true },
    EXT_mesh_gpu_instancing: { enabled: true },
    EXT_texture_webp: { enabled: true },
    EXT_texture_avif: { enabled: true },
    KHR_draco_mesh_compression: { enabled: true },
    KHR_materials_pbrSpecularGlossiness: { enabled: true },
    KHR_materials_clearcoat: { enabled: true },
    KHR_materials_iridescence: { enabled: true },
    KHR_materials_anisotropy: { enabled: true },
    KHR_materials_emissive_strength: { enabled: true },
    KHR_materials_ior: { enabled: true },
    KHR_materials_sheen: { enabled: true },
    KHR_materials_specular: { enabled: true },
    KHR_materials_unlit: { enabled: true },
    KHR_materials_variants: { enabled: true },
    KHR_materials_transmission: { enabled: true },
    KHR_materials_diffuse_transmission: { enabled: true },
    KHR_materials_volume: { enabled: true },
    KHR_materials_dispersion: { enabled: true },
    KHR_materials_diffuse_roughness: { enabled: true },
    KHR_mesh_quantization: { enabled: true },
    KHR_lights_punctual: { enabled: true },
    EXT_lights_area: { enabled: true },
    KHR_texture_basisu: { enabled: true },
    KHR_texture_transform: { enabled: true },
    KHR_xmp_json_ld: { enabled: true },
    MSFT_lod: { enabled: true, maxLODsToLoad: 10 },
    MSFT_minecraftMesh: { enabled: true },
    MSFT_sRGBFactors: { enabled: true },
    MSFT_audio_emitter: { enabled: true },
};
const GLTFLoaderOptionsServiceDefinition = {
    friendlyName: "GLTF Loader Options",
    consumes: [ToolsServiceIdentity],
    factory: (toolsService) => {
        // Subscribe to plugin activation
        const pluginObserver = SceneLoader.OnPluginActivatedObservable.add((plugin) => {
            if (plugin.name === "gltf") {
                const loader = plugin;
                // Apply loader settings
                Object.assign(loader, CurrentLoaderOptions);
                // Subscribe to extension loading
                loader.onExtensionLoadedObservable.add((extension) => {
                    const extensionOptions = CurrentExtensionOptions[extension.name];
                    if (extensionOptions) {
                        // Apply extension settings
                        Object.assign(extension, extensionOptions);
                    }
                });
            }
        });
        const loaderToolsRegistration = toolsService.addSectionContent({
            key: "GLTFLoaderOptions",
            section: "GLTF Loader",
            order: 50,
            component: () => {
                return (jsxs(Fragment, { children: [jsx(MessageBar, { intent: "info", message: "Reload the file for changes to take effect" }), jsx(GLTFLoaderOptionsTool, { loaderOptions: CurrentLoaderOptions }), jsx(GLTFExtensionOptionsTool, { extensionOptions: CurrentExtensionOptions })] }));
            },
        });
        return {
            dispose: () => {
                pluginObserver.remove();
                loaderToolsRegistration.dispose();
            },
        };
    },
};

const GLTFValidationTool = ({ validationResults }) => {
    const childWindow = useRef(null);
    const issues = validationResults.issues;
    const hasErrors = issues.numErrors > 0;
    return (jsxs(Fragment, { children: [jsx(MessageBar, { intent: hasErrors ? "error" : "success", message: hasErrors ? "Your file has validation issues" : "Your file is a valid glTF file" }), jsx(StringifiedPropertyLine, { label: "Errors", value: issues.numErrors }, "NumErrors"), jsx(StringifiedPropertyLine, { label: "Warnings", value: issues.numWarnings }, "NumWarnings"), jsx(StringifiedPropertyLine, { label: "Infos", value: issues.numInfos }, "NumInfos"), jsx(StringifiedPropertyLine, { label: "Hints", value: issues.numHints }, "NumHints"), jsx(ButtonLine, { label: "View Report Details", onClick: () => childWindow.current?.open() }), jsx(ChildWindow, { id: "gltfValidationResults", imperativeRef: childWindow, children: jsx("pre", { style: { margin: 0, overflow: "auto" }, children: jsx("code", { children: JSON.stringify(validationResults, null, 2) }) }) })] }));
};

const GLTFValidationServiceDefinition = {
    friendlyName: "GLTF Validation",
    consumes: [ToolsServiceIdentity],
    factory: (toolsService) => {
        const pluginObserver = SceneLoader.OnPluginActivatedObservable.add((plugin) => {
            if (plugin.name === "gltf") {
                const loader = plugin;
                loader.validate = true;
            }
        });
        const sectionRegistration = toolsService.addSectionContent({
            key: "GLTFValidation",
            section: "GLTF Validation",
            order: 60,
            component: () => {
                const validationState = useProperty(GLTFValidation, "_LastResults");
                if (!validationState) {
                    return jsx(MessageBar, { intent: "info", message: "Reload the file to see validation results" });
                }
                return jsx(GLTFValidationTool, { validationResults: validationState });
            },
        });
        return {
            dispose: () => {
                sectionRegistration.dispose();
                pluginObserver.remove();
            },
        };
    },
};

const PickingToolbar = (props) => {
    const { scene, selectEntity, gizmoService, ignoreBackfaces } = props;
    const meshDataCache = useMemo(() => new WeakMap(), [scene]);
    // Not sure why changing the cursor on the canvas itself doesn't work, so change it on the parent.
    const sceneElement = scene.getEngine().getRenderingCanvas()?.parentElement;
    const [pickingEnabled, setPickingEnabled] = useState(false);
    useEffect(() => {
        if (pickingEnabled && sceneElement) {
            const originalCursor = getComputedStyle(sceneElement).cursor;
            sceneElement.style.cursor = "crosshair";
            const pointerObserver = scene.onPrePointerObservable.add(() => {
                let pickedEntity = null;
                // Check camera gizmos.
                if (!pickedEntity) {
                    for (const cameraGizmo of gizmoService.getCameraGizmos(scene)) {
                        if (cameraGizmo.isHovered) {
                            pickedEntity = cameraGizmo.camera;
                        }
                    }
                }
                // Check light gizmos.
                if (!pickedEntity) {
                    for (const lightGizmo of gizmoService.getLightGizmos(scene)) {
                        if (lightGizmo.isHovered) {
                            pickedEntity = lightGizmo.light;
                        }
                    }
                }
                // Check the main scene.
                if (!pickedEntity) {
                    // Refresh bounding info to ensure morph target and skeletal animations are taken into account.
                    for (const mesh of scene.meshes) {
                        let cache = meshDataCache.get(mesh);
                        if (!cache) {
                            cache = {};
                            meshDataCache.set(mesh, cache);
                        }
                        mesh.refreshBoundingInfo({ applyMorph: true, applySkeleton: true, cache });
                    }
                    const pickingInfo = scene.pick(scene.unTranslatedPointer.x, scene.unTranslatedPointer.y, (mesh) => mesh.isEnabled() && mesh.isVisible && mesh.getTotalVertices() > 0, false, undefined, (p0, p1, p2, ray) => {
                        if (!ignoreBackfaces) {
                            return true;
                        }
                        const p0p1 = TmpVectors.Vector3[0];
                        const p1p2 = TmpVectors.Vector3[1];
                        let normal = TmpVectors.Vector3[2];
                        p1.subtractToRef(p0, p0p1);
                        p2.subtractToRef(p1, p1p2);
                        normal = Vector3.Cross(p0p1, p1p2);
                        return Vector3.Dot(normal, ray.direction) < 0;
                    });
                    pickedEntity = pickingInfo.pickedMesh;
                }
                // If an entity was picked, select it.
                if (pickedEntity) {
                    selectEntity(pickedEntity);
                }
            }, PointerEventTypes.POINTERTAP);
            // Exit picking mode if the escape key is pressed.
            const handleKeyDown = (e) => {
                if (e.key === "Escape") {
                    setPickingEnabled(false);
                }
            };
            document.addEventListener("keydown", handleKeyDown);
            return () => {
                sceneElement.style.cursor = originalCursor;
                pointerObserver.remove();
                document.removeEventListener("keydown", handleKeyDown);
            };
        }
        return () => {
            /* No-op */
        };
    }, [pickingEnabled, sceneElement, ignoreBackfaces]);
    return (sceneElement && jsx(ToggleButton, { title: `${pickingEnabled ? "Disable" : "Enable"} Picking`, checkedIcon: TargetRegular, value: pickingEnabled, onChange: setPickingEnabled }));
};

const PickingServiceDefinition = {
    friendlyName: "Picking Service",
    consumes: [SceneContextIdentity, ShellServiceIdentity, SelectionServiceIdentity, GizmoServiceIdentity, SettingsContextIdentity],
    factory: (sceneContext, shellService, selectionService, gizmoService, settingsContext) => {
        shellService.addToolbarItem({
            key: "Picking Service",
            verticalLocation: "top",
            horizontalLocation: "left",
            suppressTeachingMoment: true,
            component: () => {
                const scene = useObservableState(() => sceneContext.currentScene, sceneContext.currentSceneObservable);
                const selectEntity = useCallback((entity) => (selectionService.selectedEntity = entity), []);
                const ignoreBackfacesForPicking = useObservableState(() => settingsContext.ignoreBackfacesForPicking, settingsContext.settingsChangedObservable);
                return scene ? jsx(PickingToolbar, { scene: scene, selectEntity: selectEntity, gizmoService: gizmoService, ignoreBackfaces: ignoreBackfacesForPicking }) : null;
            },
        });
    },
};

const UserFeedbackServiceDefinition = {
    friendlyName: "User Feedback",
    consumes: [ShellServiceIdentity],
    factory: (shellService) => {
        shellService.addToolbarItem({
            key: "User Feedback",
            verticalLocation: "bottom",
            horizontalLocation: "right",
            suppressTeachingMoment: true,
            component: () => {
                return (jsx(Tooltip, { content: "Give Feedback on Inspector v2", children: jsx(Button, { appearance: "subtle", icon: PersonFeedbackRegular, onClick: () => window.open("https://forum.babylonjs.com/t/introducing-inspector-v2/60937", "_blank") }) }));
            },
        });
    },
};

// TODO: The key should probably be the Canvas, because we only want to show one inspector instance per canvas.
//       If it is called for a different scene that is rendering to the same canvas, then we should probably
//       switch the inspector instance to that scene (once this is supported).
const InspectorTokens = new WeakMap();
// This async lock is used to sequentialize all calls to ShowInspector and dispose of existing inspectors.
// This is needed because each time Inspector is shown or hidden, it is potentially mutating the same DOM element.
const InspectorLock = new AsyncLock();
function ShowInspector(scene, options = {}) {
    // Dispose of any existing inspector for this scene.
    InspectorTokens.get(scene)?.dispose();
    // Default the dispose logic to a no-op until we know that we are actually going
    // to show the Inspector and there will be cleanup work to do.
    let disposeAsync = async () => await Promise.resolve();
    // Create an inspector dispose token. The dispose will use the same async lock to
    // make sure async dispose (hide) does not actually start until async show is finished.
    let isDisposed = false;
    const onDisposed = new Observable();
    const inspectorToken = {
        dispose() {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            InspectorLock.lockAsync(async () => {
                await disposeAsync();
                isDisposed = true;
                onDisposed.notifyObservers();
                onDisposed.clear();
            });
        },
        get isDisposed() {
            return isDisposed;
        },
        get onDisposed() {
            return onDisposed;
        },
    };
    // Track the inspector token for the scene.
    InspectorTokens.set(scene, inspectorToken);
    // Set default options.
    options = {
        autoResizeEngine: true,
        layoutMode: "overlay",
        ...options,
    };
    // Sequentialize showing the inspector (e.g. don't start showing until after a previous hide (for example) is finished).
    // eslint-disable-next-line @typescript-eslint/no-floating-promises
    InspectorLock.lockAsync(async () => {
        let parentElement = options.containerElement ?? null;
        // If a container element was not found, find an appropriate one above the engine's rendering canvas.
        if (!parentElement) {
            const renderingCanvas = scene.getEngine().getRenderingCanvas();
            parentElement = renderingCanvas;
            while (parentElement) {
                const rootNode = parentElement.getRootNode();
                // TODO: Right now we never parent the inspector within a ShadowRoot because we need to do more work to get FluentProvider to work correctly in this context.
                if (rootNode instanceof ShadowRoot) {
                    // If we are in a ShadowRoot, continue up the tree.
                    parentElement = rootNode.host.parentElement;
                }
                else {
                    // Found the closest ancestor that is not in a ShadowRoot.
                    break;
                }
            }
            if (renderingCanvas && parentElement === renderingCanvas) {
                // If we were not in a ShadowRoot, then the direct parent of the rendering canvas is the container.
                parentElement = renderingCanvas.parentElement;
            }
            if (!parentElement) {
                // If we still haven't found a parent element, default to document.body.
                parentElement = document.body;
            }
        }
        // If we couldn't find a parent element, we can't show the inspector.
        if (!parentElement) {
            Logger.Warn("Unable to find a parent element to host the Inspector.");
            return;
        }
        // This will keep track of all the cleanup work we need to do when hiding the inspector.
        const disposeActions = [];
        // Update the disposeAsync function to walk the dispose actions in reverse order
        // and call each one.
        let disposed = false;
        disposeAsync = async () => {
            if (disposed) {
                return;
            }
            disposed = true;
            for (const disposeAction of disposeActions.reverse()) {
                const result = disposeAction();
                if (result) {
                    // eslint-disable-next-line no-await-in-loop
                    await result;
                }
            }
        };
        // If we were responsible for resizing the engine, resize one more after the inspector UI is hidden.
        disposeActions.push(() => {
            if (options.autoResizeEngine) {
                scene.getEngine().resize();
            }
        });
        // This array will contain all the default Inspector service definitions.
        const serviceDefinitions = [];
        // Create a container element for the inspector UI.
        // This element will become the root React node, so it must be a new empty node
        // since React will completely take over its contents.
        const containerElement = document.createElement("div");
        containerElement.id = "babylon-inspector-container";
        containerElement.style.position = "absolute";
        containerElement.style.inset = "0";
        containerElement.style.display = "flex";
        // For "overlay" layout mode, we let pointer events pass through the inspector container.
        // Pointer events are re-enabled specifically for toolbars, side panes, and central content elements.
        containerElement.style.pointerEvents = "none";
        // When the layoutMode is "inline", we will re-parent the child nodes of the parentElement under the containerElement.
        if (options.layoutMode === "inline") {
            // Remove all the existing children from the parent element.
            const canvasContainerDisplay = parentElement.style.display;
            const canvasContainerChildren = [...parentElement.childNodes];
            parentElement.replaceChildren();
            disposeActions.push(() => {
                parentElement.replaceChildren(...canvasContainerChildren);
            });
            // This service is responsible for injecting the passed in canvas as the "central content" of the shell UI (the main area between the side panes and toolbars).
            const canvasInjectorServiceDefinition = {
                friendlyName: "Canvas Injector",
                consumes: [ShellServiceIdentity],
                factory: (shellService) => {
                    const registration = shellService.addCentralContent({
                        key: "Canvas Injector",
                        component: () => {
                            const canvasContainerRef = useRef(null);
                            useEffect(() => {
                                canvasContainerRef.current?.replaceChildren(...canvasContainerChildren);
                            }, []);
                            return jsx("div", { ref: canvasContainerRef, style: { display: canvasContainerDisplay, position: "absolute", inset: "0" } });
                        },
                    });
                    return {
                        dispose: () => {
                            registration.dispose();
                        },
                    };
                },
            };
            serviceDefinitions.push(canvasInjectorServiceDefinition);
        }
        // Now it is safe to append the container element to the parent.
        parentElement.appendChild(containerElement);
        disposeActions.push(() => {
            parentElement.removeChild(containerElement);
        });
        // This service exposes the scene that was passed into Inspector through ISceneContext, which is used by other services that may be used in other contexts outside of Inspector.
        const sceneContextServiceDefinition = {
            friendlyName: "Inspector Scene Context",
            produces: [SceneContextIdentity],
            factory: () => {
                return {
                    currentScene: scene,
                    currentSceneObservable: new Observable(),
                };
            },
        };
        serviceDefinitions.push(sceneContextServiceDefinition);
        if (options.autoResizeEngine) {
            const observer = scene.onBeforeRenderObservable.add(() => scene.getEngine().resize());
            disposeActions.push(() => observer.remove());
        }
        serviceDefinitions.push(
        // Helps with managing gizmos and a shared utility layer.
        GizmoServiceDefinition, 
        // Scene explorer tab and related services.
        SceneExplorerServiceDefinition, NodeExplorerServiceDefinition, SkeletonExplorerServiceDefinition, MaterialExplorerServiceDefinition, TextureExplorerServiceDefinition, PostProcessExplorerServiceDefinition, RenderingPipelineExplorerServiceDefinition, EffectLayerExplorerServiceDefinition, ParticleSystemExplorerServiceDefinition, SpriteManagerExplorerServiceDefinition, AnimationGroupExplorerServiceDefinition, GuiExplorerServiceDefinition, FrameGraphExplorerServiceDefinition, AtmosphereExplorerServiceDefinition, SoundExplorerServiceDefinition, 
        // Properties pane tab and related services.
        ScenePropertiesServiceDefinition, PropertiesServiceDefinition, TexturePropertiesServiceDefinition, CommonPropertiesServiceDefinition, TransformPropertiesServiceDefinition, AnimationPropertiesServiceDefinition, NodePropertiesServiceDefinition, PhysicsPropertiesServiceDefinition, SkeletonPropertiesServiceDefinition, MaterialPropertiesServiceDefinition, LightPropertiesServiceDefinition, SpritePropertiesServiceDefinition, ParticleSystemPropertiesServiceDefinition, CameraPropertiesServiceDefinition, PostProcessPropertiesServiceDefinition, RenderingPipelinePropertiesServiceDefinition, EffectLayerPropertiesServiceDefinition, FrameGraphPropertiesServiceDefinition, AnimationGroupPropertiesServiceDefinition, MetadataPropertiesServiceDefinition, AtmospherePropertiesServiceDefinition, AudioPropertiesServiceDefinition, 
        // Texture editor and related services.
        TextureEditorServiceDefinition, 
        // Debug pane tab and related services.
        DebugServiceDefinition, 
        // Stats pane tab and related services.
        StatsServiceDefinition, 
        // Tools pane tab and related services.
        ToolsServiceDefinition, ExportServiceDefinition, GLTFAnimationImportServiceDefinition, GLTFLoaderOptionsServiceDefinition, GLTFValidationServiceDefinition, CaptureToolsDefinition, 
        // Settings pane tab and related services.
        SettingsServiceDefinition, 
        // Tracks entity selection state (e.g. which Mesh or Material or other entity is currently selected in scene explorer and bound to the properties pane, etc.).
        SelectionServiceDefinition, 
        // Gizmos for manipulating objects in the scene.
        GizmoToolbarServiceDefinition, 
        // Allows picking objects from the scene to select them.
        PickingServiceDefinition, 
        // Adds entry points for user feedback on Inspector v2 (probably eventually will be removed).
        UserFeedbackServiceDefinition, 
        // Adds always present "mini stats" (like fps) to the toolbar, etc.
        MiniStatsServiceDefinition, 
        // Legacy service to support custom inspectable properties on objects.
        LegacyInspectableObjectPropertiesServiceDefinition);
        const modularTool = MakeModularTool({
            containerElement,
            serviceDefinitions: [
                // Default Inspector services.
                ...serviceDefinitions,
                // Additional services passed in to the Inspector.
                ...(options.serviceDefinitions ?? []),
            ],
            themeMode: options.themeMode,
            showThemeSelector: options.showThemeSelector,
            extensionFeeds: [DefaultInspectorExtensionFeed, ...(options.extensionFeeds ?? [])],
            toolbarMode: "compact",
            sidePaneRemapper: options.sidePaneRemapper,
        });
        disposeActions.push(() => modularTool.dispose());
        const sceneDisposedObserver = scene.onDisposeObservable.addOnce(() => {
            inspectorToken.dispose();
        });
        disposeActions.push(() => sceneDisposedObserver.remove());
        disposeActions.push(() => {
            InspectorTokens.delete(scene);
        });
    });
    return inspectorToken;
}

// Mappings for Inspector v1 property section names to Inspector v2 section names.
const LegacyPropertiesSectionMapping = {
    // Common sections
    ["GENERAL"]: "General",
    ["CUSTOM"]: "Custom",
    ["COMMANDS"]: "Commands",
    ["DEBUG"]: "Debug",
    ["ADVANCED"]: "Advanced",
    ["PROPERTIES"]: "Properties",
    // Transform sections
    ["TRANSFORMATIONS"]: "Transform",
    ["TRANSFORMS"]: "Transform",
    ["TRANSFORM"]: "Transform",
    // Animation sections
    ["ANIMATION"]: "Animation",
    ["ANIMATION RANGES"]: "Animation Ranges",
    ["ANIMATIONS"]: "Animation",
    ["ANIMATION GENERAL CONTROL"]: "Animation Control",
    ["CONTROLS"]: "Control",
    ["INFOS"]: "Info",
    // Camera sections
    ["COLLISIONS"]: "Collision",
    ["LIMITS"]: "Limits",
    ["BEHAVIORS"]: "Behaviors",
    // Material sections
    ["TRANSPARENCY"]: "Transparency",
    ["STENCIL"]: "Stencil",
    ["STENCIL - FRONT"]: "Stencil Front",
    ["STENCIL - BACK"]: "Stencil Back",
    ["TEXTURES"]: "Textures",
    ["LIGHTING & COLORS"]: "Lighting & Colors",
    ["LEVELS"]: "Levels",
    ["NORMAL MAP"]: "Normal Map",
    ["RENDERING"]: "Rendering",
    ["CHANNELS"]: "Channels",
    // PBR Material sections
    ["METALLIC WORKFLOW"]: "Metallic Workflow",
    ["CLEAR COAT"]: "Clear Coat",
    ["IRIDESCENCE"]: "Iridescence",
    ["ANISOTROPIC"]: "Anisotropic",
    ["SHEEN"]: "Sheen",
    ["SUBSURFACE"]: "Subsurface",
    // OpenPBR Material sections
    ["BASE"]: "Base",
    ["SPECULAR"]: "Specular",
    ["COAT"]: "Coat",
    ["FUZZ"]: "Fuzz",
    ["EMISSION"]: "Emission",
    ["THIN FILM"]: "Thin Film",
    ["GEOMETRY"]: "Geometry",
    // Sky Material
    ["SKY"]: "Sky",
    // Multi Material
    ["CHILDREN"]: "Children",
    // Mesh sections
    ["DISPLAY"]: "Display",
    ["DISPLAY OPTIONS"]: "Display Options",
    ["NODE GEOMETRY"]: "Node Geometry",
    ["MORPH TARGETS"]: "Morph Targets",
    ["PHYSICS"]: "Physics",
    ["OCCLUSIONS"]: "Occlusions",
    ["EDGE RENDERING"]: "Edge Rendering",
    ["OUTLINE & OVERLAY"]: "Outlines & Overlays",
    // Light sections
    ["SETUP"]: "Setup",
    ["SHADOWS"]: "Shadows",
    ["SHADOW GENERATOR"]: "Shadow Generator",
    // Particle System sections
    ["NODE PARTICLE EDITOR"]: "Node Particle Editor",
    ["FILE"]: "File",
    ["SNIPPET"]: "Snippet",
    ["ATTRACTORS"]: "Attractors",
    ["IMPOSTORS"]: "Impostors",
    ["EMITTER"]: "Emitter",
    ["SIZE"]: "Size",
    ["LIFETIME"]: "Lifetime",
    ["COLORS"]: "Color",
    ["ROTATION"]: "Rotation",
    ["SPRITESHEET"]: "Spritesheet",
    // Sprite sections
    ["CELLS"]: "Cells",
    ["CELL"]: "Cell",
    ["SCALE"]: "Scale",
    // Post Process sections
    ["CONFIGURATION"]: "Configuration",
    ["BLOOM"]: "Bloom",
    ["CHROMATIC ABERRATION"]: "Chromatic Aberration",
    ["DEPTH OF FIELD"]: "Depth of Field",
    ["FXAA"]: "FXAA",
    ["GLOW LAYER"]: "Glow Layer",
    ["GRAIN"]: "Grain",
    ["IMAGE PROCESSING"]: "Image Processing",
    ["SHARPEN"]: "Sharpen",
    ["OPTIONS"]: "Options",
    ["SSAO"]: "SSAO",
    ["Denoiser"]: "Denoiser",
    ["SSR"]: "SSR",
    ["Voxel Shadows"]: "Voxel Shadows",
    ["Screenspace Shadows"]: "Screenspace Shadows",
    ["Automatic thickness computation"]: "Automatic Thickness Computation",
    ["Blur"]: "Blur",
    ["Attenuations"]: "Attenuations",
    ["Color space"]: "Color Space",
    // Scene sections
    ["RENDERING MODE"]: "Rendering",
    ["ENVIRONMENT"]: "Environment",
    ["MATERIAL IMAGE PROCESSING"]: "Material Image Processing",
    // Texture sections
    ["PREVIEW"]: "Preview",
    ["ADVANCED TEXTURE PROPERTIES"]: "Advanced Texture Properties",
    // Frame Graph sections
    ["TASKS"]: "Tasks",
    // Metadata
    ["METADATA"]: "Metadata",
    ["XMP METADATA"]: "XMP Metadata",
    // Variants
    ["VARIANTS"]: "Variants",
    // Node Material
    ["INPUTS"]: "Inputs",
};

/**
 * Converts Inspector v1 options to Inspector v2 options.
 * @param v1Options Inspector v1 options.
 * @returns Inspector v2 options.
 */
function ConvertOptions(v1Options) {
    // Options not currently handled:
    //  enablePopup: Do users care about this one?
    //  enableClose: Currently Inspector v2 does not allow panes/tabs to be closed.
    //  skipDefaultFontLoading: Probably doesn't make sense for Inspector v2 using Fluent.
    //  contextMenuOverride: Currently there are no default section context menu items to override.
    //                        If the create extension ends up adding context menu items to match v1
    //                        behavior, then it should only enable that feature if contextMenuOverride
    //                        is not set to true.
    v1Options = {
        overlay: false,
        showExplorer: true,
        showInspector: true,
        embedMode: false,
        enableClose: true,
        handleResize: true,
        enablePopup: true,
        ...v1Options,
    };
    const serviceDefinitions = [];
    if (v1Options.initialTab) {
        const paneKey = (() => {
            switch (v1Options.initialTab) {
                case 1 /* DebugLayerTab.Debug */:
                    return "Debug";
                case 2 /* DebugLayerTab.Statistics */:
                    return "Statistics";
                case 4 /* DebugLayerTab.Settings */:
                    return "Settings";
                case 3 /* DebugLayerTab.Tools */:
                    return "Tools";
            }
        })();
        const initialTabServiceDefinition = {
            friendlyName: "Initial Tab Selector (Backward Compatibility)",
            consumes: [ShellServiceIdentity],
            factory: (shellService) => {
                // Just find and select the requested initial tab.
                shellService.sidePanes.find((pane) => pane.key === paneKey)?.select();
            },
        };
        serviceDefinitions.push(initialTabServiceDefinition);
    }
    if (v1Options.gizmoCamera) {
        const { gizmoCamera } = v1Options;
        const gizmoCameraServiceDefinition = {
            friendlyName: "Gizmo Camera (Backward Compatibility)",
            consumes: [GizmoServiceIdentity],
            factory: (gizmoService) => {
                // As a simple back compat solution, just keep the utility layer alive until Inspector is unloaded.
                // This way we don't need to keep re-assigning the gizmo camera to the utility layer if it is recreated.
                const utilityLayerRef = gizmoService.getUtilityLayer(gizmoCamera.getScene());
                utilityLayerRef.value.setRenderCamera(gizmoCamera);
                return {
                    dispose: () => utilityLayerRef.dispose(),
                };
            },
        };
        serviceDefinitions.push(gizmoCameraServiceDefinition);
    }
    if (v1Options.additionalNodes && v1Options.additionalNodes.length > 0) {
        const { additionalNodes } = v1Options;
        const additionalNodesServiceDefinition = {
            friendlyName: "Additional Nodes (Backward Compatibility)",
            consumes: [SceneExplorerServiceIdentity],
            factory: (sceneExplorerService) => {
                const sceneExplorerSectionRegistrations = additionalNodes.map((node) => sceneExplorerService.addSection({
                    displayName: node.name,
                    order: Number.MAX_SAFE_INTEGER,
                    getRootEntities: () => node.getContent(),
                    getEntityDisplayInfo: (entity) => {
                        const onChangeObservable = new Observable();
                        const nameHookToken = InterceptProperty(entity, "name", {
                            afterSet: () => {
                                onChangeObservable.notifyObservers();
                            },
                        });
                        return {
                            get name() {
                                return entity.name;
                            },
                            onChange: onChangeObservable,
                            dispose: () => {
                                nameHookToken.dispose();
                                onChangeObservable.clear();
                            },
                        };
                    },
                    entityIcon: () => jsx(BranchRegular, {}),
                    getEntityAddedObservables: () => [],
                    getEntityRemovedObservables: () => [],
                }));
                return {
                    dispose: () => {
                        sceneExplorerSectionRegistrations.forEach((registration) => registration.dispose());
                    },
                };
            },
        };
        serviceDefinitions.push(additionalNodesServiceDefinition);
    }
    if (v1Options.explorerExtensibility && v1Options.explorerExtensibility.length > 0) {
        const { explorerExtensibility } = v1Options;
        const explorerExtensibilityServiceDefinition = {
            friendlyName: "Explorer Extensibility (Backward Compatibility)",
            consumes: [SceneExplorerServiceIdentity],
            factory: (sceneExplorerService) => {
                const sceneExplorerCommandRegistrations = explorerExtensibility.flatMap((command) => command.entries.map((entry) => sceneExplorerService.addEntityCommand({
                    predicate: (entity) => command.predicate(entity),
                    getCommand: (entity) => {
                        return {
                            displayName: entry.label,
                            type: "action",
                            mode: "contextMenu",
                            execute: () => entry.action(entity),
                        };
                    },
                })));
                return {
                    dispose: () => {
                        sceneExplorerCommandRegistrations.forEach((registration) => registration.dispose());
                    },
                };
            },
        };
        serviceDefinitions.push(explorerExtensibilityServiceDefinition);
    }
    if (v1Options.contextMenu) {
        const { contextMenu } = v1Options;
        const sections = Object.entries(contextMenu);
        if (sections.length > 0) {
            const legacySectionMapping = {
                pipeline: "Rendering Pipelines",
                node: "Nodes",
                materials: "Materials",
                spriteManagers: "Sprite Managers",
                particleSystems: "Particle Systems",
                frameGraphs: "Frame Graphs",
            };
            const sectionContextMenuServiceDefinition = {
                friendlyName: "Context Menu (Backward Compatibility)",
                consumes: [SceneExplorerServiceIdentity],
                factory: (sceneExplorerService) => {
                    const sceneExlplorerCommandRegistrations = sections.flatMap(([sectionName, entries]) => entries.map((entry) => sceneExplorerService.addSectionCommand({
                        predicate: (section) => legacySectionMapping[sectionName] === section,
                        getCommand: () => {
                            return {
                                displayName: entry.label,
                                type: "action",
                                mode: "contextMenu",
                                execute: () => entry.action(),
                            };
                        },
                    })));
                    return {
                        dispose: () => {
                            sceneExlplorerCommandRegistrations.forEach((registration) => registration.dispose());
                        },
                    };
                },
            };
            serviceDefinitions.push(sectionContextMenuServiceDefinition);
        }
    }
    const v2Options = {
        containerElement: v1Options.globalRoot,
        layoutMode: v1Options.overlay ? "overlay" : "inline",
        autoResizeEngine: v1Options.handleResize,
        sidePaneRemapper: (sidePane) => {
            if (v1Options.showExplorer === false && sidePane.key === "Scene Explorer") {
                return null;
            }
            if (v1Options.showInspector === false &&
                (sidePane.key === "Properties" || sidePane.key === "Debug" || sidePane.key === "Statistics" || sidePane.key === "Settings" || sidePane.key === "Tools")) {
                return null;
            }
            if (v1Options.embedMode) {
                if (sidePane.horizontalLocation === "right") {
                    // All right panes go to right bottom.
                    return {
                        horizontalLocation: "right",
                        verticalLocation: "bottom",
                    };
                }
                else {
                    // All left panes go to right top.
                    return {
                        horizontalLocation: "right",
                        verticalLocation: "top",
                    };
                }
            }
            return sidePane;
        },
        serviceDefinitions,
    };
    return v2Options;
}
/**
 * @deprecated This class only exists for backward compatibility. Use the module-level ShowInspector function instead.
 */
class Inspector {
    // @ts-expect-error TS6133: This is private, but used by debugLayer (same as Inspector v1).
    static get _OpenedPane() {
        return this._SidePaneOpenCounter?.() ?? 0;
    }
    static MarkLineContainerTitleForHighlighting(title) {
        this.MarkMultipleLineContainerTitlesForHighlighting([title]);
    }
    static MarkMultipleLineContainerTitlesForHighlighting(titles) {
        this._SectionHighlighter?.(titles);
    }
    static PopupEmbed() {
        this._PopupToggler?.("right");
    }
    static PopupSceneExplorer() {
        this._PopupToggler?.("left");
    }
    static PopupInspector() {
        this._PopupToggler?.("right");
    }
    static get IsVisible() {
        return !!this._CurrentInstance;
    }
    static Show(scene, userOptions) {
        this._Show(scene, userOptions);
    }
    static _Show(scene, userOptions) {
        if (!scene) {
            scene = EngineStore.LastCreatedScene;
        }
        if (!scene || scene.isDisposed) {
            return;
        }
        let options = ConvertOptions(userOptions);
        const serviceDefinitions = [];
        const popupServiceDefinition = {
            friendlyName: "Popup Service (Backward Compatibility)",
            consumes: [ShellServiceIdentity],
            factory: (shellService) => {
                this._PopupToggler = (side) => {
                    const sidePaneContainer = side === "left" ? shellService.leftSidePaneContainer : shellService.rightSidePaneContainer;
                    if (sidePaneContainer) {
                        if (sidePaneContainer.isDocked) {
                            sidePaneContainer.undock();
                        }
                        else {
                            sidePaneContainer.dock();
                        }
                    }
                };
                return {
                    dispose: () => (this._PopupToggler = null),
                };
            },
        };
        serviceDefinitions.push(popupServiceDefinition);
        const selectionChangedServiceDefinition = {
            friendlyName: "Selection Changed Service (Backward Compatibility)",
            consumes: [SelectionServiceIdentity],
            factory: (selectionService) => {
                const selectionServiceObserver = selectionService.onSelectedEntityChanged.add(() => {
                    this.OnSelectionChangeObservable.notifyObservers(selectionService.selectedEntity);
                });
                const legacyObserver = this.OnSelectionChangeObservable.add((entity) => {
                    selectionService.selectedEntity = entity;
                });
                return {
                    dispose: () => {
                        selectionServiceObserver.remove();
                        legacyObserver.remove();
                    },
                };
            },
        };
        serviceDefinitions.push(selectionChangedServiceDefinition);
        const propertyChangedServiceDefinition = {
            friendlyName: "Property Changed Service (Backward Compatibility)",
            consumes: [PropertiesServiceIdentity],
            factory: (propertiesService) => {
                const observer = propertiesService.onPropertyChanged.add((changeInfo) => {
                    this.OnPropertyChangedObservable.notifyObservers({
                        object: changeInfo.entity,
                        property: changeInfo.propertyKey.toString(),
                        value: changeInfo.newValue,
                        initialValue: changeInfo.oldValue,
                    });
                });
                return {
                    dispose: () => {
                        observer.remove();
                    },
                };
            },
        };
        serviceDefinitions.push(propertyChangedServiceDefinition);
        const sectionHighlighterServiceDefinition = {
            friendlyName: "Section Highlighter Service (Backward Compatibility)",
            consumes: [PropertiesServiceIdentity],
            factory: (propertiesService) => {
                this._SectionHighlighter = (sectionIds) => {
                    propertiesService.highlightSections(sectionIds.map((id) => LegacyPropertiesSectionMapping[id] ?? id));
                };
                return {
                    dispose: () => {
                        this._SectionHighlighter = null;
                    },
                };
            },
        };
        serviceDefinitions.push(sectionHighlighterServiceDefinition);
        const openedPanesServiceDefinition = {
            friendlyName: "Opened Panes Service (Backward Compatibility)",
            consumes: [ShellServiceIdentity],
            factory: (shellService) => {
                this._SidePaneOpenCounter = () => (shellService.leftSidePaneContainer ? 1 : 0) + (shellService.rightSidePaneContainer ? 1 : 0);
                return {
                    dispose: () => {
                        this._SidePaneOpenCounter = null;
                    },
                };
            },
        };
        serviceDefinitions.push(openedPanesServiceDefinition);
        options = {
            ...options,
            serviceDefinitions: [...(options.serviceDefinitions ?? []), ...serviceDefinitions],
        };
        this._CurrentInstance = {
            scene,
            options,
            disposeToken: ShowInspector(scene, options),
        };
        this._CurrentInstance.disposeToken.onDisposed.addOnce(() => (this._CurrentInstance = null));
    }
    static Hide() {
        this._CurrentInstance?.disposeToken.dispose();
    }
    // @ts-expect-error TS6133: This is private, but used by debugLayer (same as Inspector v1).
    static _SetNewScene(scene) {
        if (this._CurrentInstance && this._CurrentInstance.scene !== scene) {
            // TODO: For now, just hide and re-show the Inspector.
            // Need to think more about this when we work on multi-scene support in Inspector v2.
            const options = this._CurrentInstance.options;
            this.Hide();
            this._CurrentInstance = {
                scene,
                options,
                disposeToken: ShowInspector(scene, options),
            };
        }
    }
}
Inspector._CurrentInstance = null;
Inspector._PopupToggler = null;
Inspector._SectionHighlighter = null;
Inspector._SidePaneOpenCounter = null;
Inspector.OnSelectionChangeObservable = new Observable();
Inspector.OnPropertyChangedObservable = new Observable();

var inspector = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ConvertOptions: ConvertOptions,
    Inspector: Inspector
});

const LazyInspectorModule = new Lazy(async () => await Promise.resolve().then(function () { return inspector; }));
class DebugLayerEx extends DebugLayer {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    async show(config) {
        // If a custom inspector URL is not provided, default to a lazy dynamic import of the inspector module.
        if (!config?.inspectorURL) {
            this.BJSINSPECTOR = await LazyInspectorModule.value;
        }
        return await super.show(config);
    }
}
let CachedDebugLayerDescriptor;
const DebugLayerExKey = Symbol("DebugLayerEx");
const DebugLayerExDescriptor = {
    get: function () {
        // NOTE: We don't replace the _debugLayer property because we want to leave it
        // intact so we can dynamically switch back to v1. Eventually when v1 is fully
        // deprecated we can have just a single _debugLayer property.
        // If there is no DebugLayerEx yet, create it.
        if (!this[DebugLayerExKey]) {
            this[DebugLayerExKey] = new DebugLayerEx(this);
        }
        return this[DebugLayerExKey];
    },
    enumerable: true,
    configurable: true,
};
/**
 * Attaches Inspector v2 to Scene.debugLayer.
 */
function AttachDebugLayer() {
    const currentPropertyDescriptor = Reflect.getOwnPropertyDescriptor(Scene.prototype, "debugLayer");
    // Check if Inspector v2 is already attached, but don't compare the property descriptors directly
    // as getOwnPropertyDescriptor returns a new object instance each time.
    // Instead, check the get function.
    if (currentPropertyDescriptor?.get !== DebugLayerExDescriptor.get) {
        // Cache the property descriptor so we can restore it if/when Inspector v2 is detached from Scene._debugLayer.
        CachedDebugLayerDescriptor = currentPropertyDescriptor;
        // Define the debugLayer property to return our extended DebugLayerEx (Inspector v2).
        Reflect.defineProperty(Scene.prototype, "debugLayer", DebugLayerExDescriptor);
    }
}
/**
 * Detaches Inspector v2 from Scene.debugLayer.
 */
function DetachDebugLayer() {
    const currentPropertyDescriptor = Reflect.getOwnPropertyDescriptor(Scene.prototype, "debugLayer");
    // Check if Inspector v2 is already attached, but don't compare the property descriptors directly
    // as getOwnPropertyDescriptor returns a new object instance each time.
    // Instead, check the get function.
    if (currentPropertyDescriptor?.get === DebugLayerExDescriptor.get) {
        // Revert the debugLayer property descriptor.
        if (CachedDebugLayerDescriptor) {
            Reflect.defineProperty(Scene.prototype, "debugLayer", CachedDebugLayerDescriptor);
            CachedDebugLayerDescriptor = undefined;
        }
        else {
            Reflect.deleteProperty(Scene.prototype, "debugLayer");
        }
    }
}

const useDraggableStyles = makeStyles({
    draggable: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        position: "relative",
        columnGap: tokens.spacingHorizontalS,
        cursor: "grab",
        textAlign: "center",
        boxSizing: "border-box",
        margin: `${tokens.spacingVerticalXS} 0px`,
        padding: `${tokens.spacingVerticalSNudge} ${tokens.spacingHorizontalMNudge}`,
        // Button-like styling
        backgroundColor: tokens.colorNeutralBackground1,
        border: `${tokens.strokeWidthThin} solid ${tokens.colorNeutralStroke1}`,
        borderRadius: tokens.borderRadiusMedium,
        color: tokens.colorNeutralForeground1,
        fontSize: tokens.fontSizeBase300,
        fontFamily: tokens.fontFamilyBase,
        fontWeight: tokens.fontWeightRegular,
        lineHeight: tokens.lineHeightBase300,
        minHeight: "32px",
        // eslint-disable-next-line @typescript-eslint/naming-convention
        ":hover": {
            backgroundColor: tokens.colorNeutralBackground1Hover,
        },
        // eslint-disable-next-line @typescript-eslint/naming-convention
        ":active": {
            backgroundColor: tokens.colorNeutralBackground1Pressed,
        },
    },
    icon: {
        pointerEvents: "auto", // reenable interaction
        display: "flex",
        alignItems: "center",
        position: "absolute",
        right: tokens.spacingHorizontalSNudge,
        color: tokens.colorNeutralForeground2,
        cursor: "pointer",
        fontSize: tokens.fontSizeBase400,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        ":hover": {
            color: tokens.colorNeutralForeground2Hover,
        },
    },
});
const DraggableLine = (props) => {
    DraggableLine.displayName = "DraggableLine";
    const classes = useDraggableStyles();
    return (jsxs("div", { className: classes.draggable, title: props.tooltip, draggable: true, onDragStart: (event) => {
            event.dataTransfer.setData(props.format, props.data);
        }, children: [props.label, props.onDelete && jsx(DeleteFilled, { className: classes.icon, onClick: props.onDelete })] }));
};

/**
 * PositionedPopover component that shows a popover at specific coordinates
 * @param props - The component props
 * @returns The positioned popover component
 */
const PositionedPopover = (props) => {
    PositionedPopover.displayName = "PositionedPopover";
    const [open, setOpen] = useState(false);
    useEffect(() => {
        setOpen(props.visible);
    }, [props.visible, props.x, props.y]);
    const handleOpenChange = (_, data) => {
        setOpen(data.open);
        if (!data.open) {
            props.hide();
        }
    };
    return (jsxs(Popover$1, { open: open, onOpenChange: handleOpenChange, positioning: {
            position: "below", // Places the popover directly below the trigger element
            autoSize: "height-always", //Automatically adjusts the popover height to fit within the viewport
            fallbackPositions: ["above", "after", "before"], //If the primary position doesn't fit, automatically tries these positions in order
        }, withArrow: false, children: [jsx(PopoverTrigger, { children: jsx("div", { style: {
                        position: "absolute",
                        left: `${props.x}px`,
                        top: `${props.y}px`,
                        visibility: "hidden",
                    } }) }), jsx(PopoverSurface, { children: props.children })] }));
};

const useStyles$1 = makeStyles({
    search: {
        minWidth: "50px",
    },
});
const SearchBar = forwardRef((props, ref) => {
    SearchBar.displayName = "SearchBar";
    const classes = useStyles$1();
    const onChange = (_, data) => {
        props.onChange(data.value);
    };
    return (jsx(Field, { children: jsx(SearchBox$1, { ref: ref, className: classes.search, placeholder: props.placeholder, onChange: onChange }) }));
});

const useSearchBoxStyles = makeStyles({
    searchBox: {
        width: "300px",
        height: "400px",
        backgroundColor: tokens.colorNeutralBackground1,
        border: `${tokens.strokeWidthThick} solid ${tokens.colorNeutralStroke1}`,
        borderRadius: tokens.borderRadiusMedium,
        boxShadow: tokens.shadow16,
        display: "grid",
        gridTemplateRows: "auto auto 1fr",
        overflow: "hidden", // Prevent content overflow
    },
    title: {
        borderBottom: `${tokens.strokeWidthThin} solid ${tokens.colorNeutralStroke2}`,
        margin: tokens.spacingVerticalXS,
        paddingBottom: tokens.spacingVerticalXS,
        color: tokens.colorNeutralForeground1,
        gridRow: "1",
        fontSize: tokens.fontSizeBase300,
        fontWeight: tokens.fontWeightSemibold,
    },
    filterContainer: {
        margin: tokens.spacingVerticalXS,
        paddingBottom: tokens.spacingVerticalXS,
        gridRow: "2",
    },
    list: {
        gridRow: "3",
        overflowY: "auto",
        display: "flex",
        flexDirection: "column",
        maxHeight: "100%",
    },
    listItem: {
        marginLeft: tokens.spacingHorizontalXS,
        marginRight: tokens.spacingHorizontalXS,
        cursor: "pointer",
        color: tokens.colorNeutralForeground1,
        marginTop: tokens.spacingVerticalXXS,
        marginBottom: tokens.spacingVerticalXXS,
        padding: tokens.spacingVerticalXS,
        borderRadius: tokens.borderRadiusSmall,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        ":hover": {
            backgroundColor: tokens.colorNeutralBackground2Hover,
        },
    },
    listItemSelected: {
        backgroundColor: tokens.colorBrandBackground,
        color: tokens.colorNeutralForegroundOnBrand,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        ":hover": {
            backgroundColor: tokens.colorBrandBackgroundHover,
        },
    },
});
/**
 * SearchBox component that displays a popup with search functionality
 * @param props - The component props
 * @returns The search box component
 */
const SearchBox = (props) => {
    SearchBox.displayName = "SearchBox";
    const classes = useSearchBoxStyles();
    const [selectedIndex, setSelectedIndex] = useState(0);
    const [items, setItems] = useState(props.items);
    // In future could replace this with a fluent component like menuList or comboBox depending on desired UX
    const onKeyDown = (evt) => {
        if (items.length === 0) {
            return;
        }
        if (evt.code === "Enter") {
            props.onItemSelected(items[selectedIndex]);
            return;
        }
        if (evt.code === "ArrowDown") {
            setSelectedIndex((prev) => Math.min(prev + 1, items.length - 1));
            return;
        }
        if (evt.code === "ArrowUp") {
            setSelectedIndex((prev) => Math.max(prev - 1, 0));
            return;
        }
    };
    const onFilterChange = (filter) => {
        const filteredItems = props.items.filter((item) => item.toLowerCase().includes(filter.toLowerCase()));
        setItems(filteredItems);
    };
    useEffect(() => {
        setItems(props.items);
    }, [props.items]);
    return (jsxs("div", { className: classes.searchBox, onKeyDown: onKeyDown, children: [props.title ? jsx("div", { className: classes.title, children: props.title }) : null, jsx("div", { className: classes.filterContainer, children: jsx(SearchBar, { onChange: onFilterChange, placeholder: "Search..." }) }), jsx("div", { role: "listbox", className: classes.list, children: items.map((item, index) => (jsx("div", { role: "option", className: `${classes.listItem} ${index === selectedIndex ? classes.listItemSelected : ""}`, onClick: () => props.onItemSelected(item), children: item }, item))) })] }));
};

const useStyles = makeStyles({
    rootDiv: {
        flex: 1,
        overflow: "hidden",
        display: "flex",
        flexDirection: "column",
    },
    icon: {
        width: tokens.fontSizeBase400,
        height: tokens.fontSizeBase400,
        verticalAlign: "middle",
    },
    header: {
        height: tokens.fontSizeBase400,
        fontSize: tokens.fontSizeBase400,
        textAlign: "center",
        verticalAlign: "middle",
    },
});
const Pane = (props) => {
    const classes = useStyles();
    return (jsxs("div", { className: classes.rootDiv, children: [jsxs("div", { className: classes.header, children: [props.icon ? (jsx(props.icon, { className: classes.icon })) : (jsx("img", { className: classes.icon, id: "logo", src: "https://www.babylonjs.com/Assets/logo-babylonjs-social-twitter.png" })), jsx(Body1Strong, { id: "title", children: props.title })] }), props.children] }));
};

/**
 * Wraps textarea in a property line
 * @param props - PropertyLineProps and TextProps
 * @returns property-line wrapped text
 */
const TextAreaPropertyLine = (props) => {
    TextAreaPropertyLine.displayName = "TextAreaPropertyLine";
    return (jsx(PropertyLine, { ...props, children: jsx(Textarea, { ...props }) }));
};

// Export the parts of inspector that are intended to be part of the public API.
// Attach Inspector v2 to Scene.debugLayer as a side effect for back compat.
AttachDebugLayer();

export { useAngleConverters as $, Accordion as A, Button as B, CheckboxPropertyLine as C, DebugServiceIdentity as D, ExtensibleAccordion as E, useColor3Property as F, useColor4Property as G, useQuaternionProperty as H, Inspector as I, MakePropertyHook as J, useInterceptObservable as K, Link as L, MessageBar as M, NumberInputPropertyLine as N, useEventfulState as O, Popover as P, useObservableCollection as Q, useOrderedObservableCollection as R, SpinButtonPropertyLine as S, TextInputPropertyLine as T, usePollingObservable as U, Vector3PropertyLine as V, useResource as W, useAsyncResource as X, useCompactMode as Y, useDisableCopy as Z, useSidePaneDockOverrides as _, ShellServiceIdentity as a, MakeTeachingMoment as a0, MakeDialogTeachingMoment as a1, InterceptFunction as a2, GetPropertyDescriptor as a3, IsPropertyReadonly as a4, InterceptProperty as a5, ObservableCollection as a6, ConstructorFactory as a7, SelectionServiceIdentity as a8, SelectionServiceDefinition as a9, TextInput as aA, ToggleButton as aB, ChildWindow as aC, FileUploadLine as aD, FactorGradientList as aE, Color3GradientList as aF, Color4GradientList as aG, Pane as aH, BooleanBadgePropertyLine as aI, Color3PropertyLine as aJ, Color4PropertyLine as aK, HexPropertyLine as aL, LinkPropertyLine as aM, PropertyLine as aN, LineContainer as aO, PlaceholderPropertyLine as aP, StringifiedPropertyLine as aQ, SwitchPropertyLine as aR, SyncedSliderPropertyLine as aS, TextAreaPropertyLine as aT, TextPropertyLine as aU, RotationVectorPropertyLine as aV, QuaternionPropertyLine as aW, Vector2PropertyLine as aX, Vector4PropertyLine as aY, SettingsContextIdentity as aa, ShowInspector as ab, Checkbox as ac, Collapse as ad, ColorPickerPopup as ae, InputHexField as af, InputHsvField as ag, ComboBox as ah, DraggableLine as ai, Dropdown as aj, NumberDropdown as ak, StringDropdown as al, FactorGradientComponent as am, Color3GradientComponent as an, Color4GradientComponent as ao, ColorStepGradientComponent as ap, InfoLabel as aq, MakeLazyComponent as ar, List as as, PositionedPopover as at, SearchBar as au, SearchBox as av, SpinButton as aw, Switch as ax, SyncedSliderInput as ay, Textarea as az, SceneContextIdentity as b, useObservableState as c, AccordionSection as d, ButtonLine as e, ToolsServiceIdentity as f, useExtensionManager as g, MakePopoverTeachingMoment as h, TeachingMoment as i, SidePaneContainer as j, PropertiesServiceIdentity as k, SceneExplorerServiceIdentity as l, SettingsServiceIdentity as m, StatsServiceIdentity as n, ConvertOptions as o, AttachDebugLayer as p, DetachDebugLayer as q, NumberDropdownPropertyLine as r, StringDropdownPropertyLine as s, BoundProperty as t, useProperty as u, Property as v, LinkToEntityPropertyLine as w, Theme as x, BuiltInsExtensionFeed as y, useVector3Property as z };
//# sourceMappingURL=index-ByfjmUIP.js.map
